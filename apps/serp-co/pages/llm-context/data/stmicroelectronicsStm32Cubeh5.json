[
  {
    "owner": "stmicroelectronics",
    "repo": "stm32cubeh5",
    "content": "TITLE: Signing Hash with PSA API\nDESCRIPTION: This snippet explains the function used to sign an already calculated hash using the PSA API. It uses `psa_sign_hash` and describes the key usage requirements (`PSA_KEY_USAGE_SIGN_HASH`) and functions for determining output buffer size (`PSA_SIGN_OUTPUT_SIZE`, `PSA_SIGNATURE_MAX_SIZE`).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_22\n\n\n\n----------------------------------------\n\nTITLE: Example PSA function with buffer copying\nDESCRIPTION: Illustrates how to add buffer copying to an existing PSA function using the defined macros. It demonstrates declaring, allocating, and freeing local input and output copies while retaining the original variable names for the copies and using a suffixed name for the originals. This allows for near-seamless integration of copying into PSA functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-shared-memory.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_foo(const uint8_t *input_external, size_t input_length,\n                     uint8_t *output_external, size_t output_size, size_t *output_length)\n{\n    psa_status_t status;\n\n    LOCAL_INPUT_DECLARE(input_external, input);\n    LOCAL_OUTPUT_DECLARE(output_external, output);\n\n    LOCAL_INPUT_ALLOC(input_external, input);\n    LOCAL_OUTPUT_ALLOC(output_external, output);\n\n    /* Do some operation on input and output */\n\nexit:\n    LOCAL_INPUT_FREE(input_external, input);\n    LOCAL_OUTPUT_FREE(output_external, output);\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Azure IoT Hub (C)\nDESCRIPTION: This function connects the Azure IoT Hub client to the Azure IoT Hub. It takes a pointer to the client instance, a clean session flag (0 to re-use the current session, 1 to start a new session), and a wait option in ticks. A successful operation connects to the Azure IoT Hub; failures may occur due to invalid parameters, SDK core errors, insufficient buffer space, DNS resolution issues, or network connectivity problems.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_connect(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                     UINT clean_session, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Checking HMAC Support (PSA API)\nDESCRIPTION: This code snippet demonstrates how to check for HMAC support in the PSA API. It verifies that the HMAC key type, HMAC algorithm, and the underlying SHA-256 algorithm are enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\n#if PSA_WANT_KEY_TYPE_HMAC && PSA_WANT_ALG_HMAC && PSA_WANT_ALG_SHA_256\n```\n\n----------------------------------------\n\nTITLE: IoT Hub Client Implementation with MQTT Stack in C\nDESCRIPTION: This C code snippet demonstrates an implementation for using the IoT Hub Client SDK with a custom MQTT stack. It includes initializing the IoT Hub client, configuring MQTT client parameters, subscribing to relevant topics (C2D, methods, twin patch, and twin response), connecting to the IoT Hub, sending telemetry messages, and handling incoming messages.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/coding_patterns.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include <az/az_core.h>\n#include <az/az_iot.h>\n\naz_iot_hub_client my_client;\nstatic az_span my_iothub_hostname = AZ_SPAN_LITERAL_FROM_STR(\"<your hub fqdn here>\");\nstatic az_span my_device_id = AZ_SPAN_LITERAL_FROM_STR(\"<your device id here>\");\n\n//Make sure the buffer is large enough to fit the user name (100 is an example)\nstatic char my_mqtt_user_name[100];\n\n//Make sure the buffer is large enough to fit the client id (16 is an example)\nstatic char my_mqtt_client_id[16];\n\n//This assumes an X509 Cert. SAS keys may also be used.\nstatic const char my_device_cert[]= \"-----BEGIN CERTIFICATE-----abcdefg-----END CERTIFICATE-----\";\n\nstatic char telemetry_topic[128];\nstatic char telemetry_payload[] = \"Hello World\";\n\nvoid handle_iot_message(mqtt_client_message* msg);\n\nint main(void)\n{\n  //Get the default IoT Hub options\n  az_iot_hub_client_options options = az_iot_hub_client_options_default();\n\n  //Initialize the client with hostname, device id, and options\n  az_iot_hub_client_init(&my_client, my_iothub_hostname, my_device_id, &options);\n\n  //Get the MQTT user name to connect\n  az_iot_hub_client_get_user_name(&my_client, my_mqtt_user_name,\n                sizeof(my_mqtt_user_name), NULL);\n\n  //Get the MQTT client id to connect\n  az_iot_hub_client_get_client_id(&my_client, my_mqtt_client_id,\n                sizeof(my_mqtt_client_id), NULL);\n\n  //Initialize MQTT client with necessary parameters (example params shown)\n  mqtt_client my_mqtt_client;\n  mqtt_client_init(&my_mqtt_client, my_iothub_hostname, my_mqtt_client_id);\n\n  //Subscribe to c2d messages\n  mqtt_client_subscribe(&my_mqtt_client, AZ_IOT_HUB_CLIENT_C2D_SUBSCRIBE_TOPIC);\n\n  //Subscribe to device methods\n  mqtt_client_subscribe(&my_mqtt_client, AZ_IOT_HUB_CLIENT_METHODS_SUBSCRIBE_TOPIC);\n\n  //Subscribe to twin patch topic\n  mqtt_client_subscribe(&my_mqtt_client, AZ_IOT_HUB_CLIENT_TWIN_PATCH_SUBSCRIBE_TOPIC);\n\n  //Subscribe to twin response topic\n  mqtt_client_subscribe(&my_mqtt_client, AZ_IOT_HUB_CLIENT_TWIN_RESPONSE_SUBSCRIBE_TOPIC);\n\n  //Connect to the IoT Hub with your chosen mqtt stack\n  mqtt_client_connect(&my_mqtt_client, my_mqtt_user_name, my_device_cert);\n\n  //This example would run to receive any incoming message and send a telemetry message five times\n  int iterations = 0;\n  mqtt_client_message msg;\n  while(iterations++ < 5)\n  {\n    if(mqtt_client_receive(&msg))\n    {\n      handle_iot_message(&msg);\n    }\n\n    send_telemetry_message();\n  }\n\n  //Disconnect from the IoT Hub\n  mqtt_client_disconnect(&my_mqtt_client);\n\n  //Destroy the mqtt client\n  mqtt_client_destroy(&my_mqtt_client);\n}\n\nvoid send_telemetry_message(void)\n{\n  //Get the topic to send a telemetry message\n  az_iot_hub_client_telemetry_get_publish_topic(&client, NULL, telemetry_topic, sizeof(telemetry_topic), NULL);\n\n  //Send the telemetry message with the MQTT client\n  mqtt_client_publish(telemetry_topic, telemetry_payload, AZ_HUB_CLIENT_DEFAULT_MQTT_TELEMETRY_QOS);\n}\n\nvoid handle_iot_message(mqtt_client_message* msg)\n{\n  //Initialize the incoming topic to a span\n  az_span incoming_topic = az_span_create(msg->topic, msg->topic_len);\n\n  //The message could be for three features so parse the topic to see which it is for\n  az_iot_hub_client_method_request method_request;\n  az_iot_hub_client_c2d_request c2d_request;\n  az_iot_hub_client_twin_response twin_response;\n  if (az_result_succeeded(az_iot_hub_client_methods_parse_received_topic(&client, incoming_topic, &method_request)))\n  {\n    //Handle the method request\n  }\n  else if (az_result_succeeded(az_iot_hub_client_c2d_parse_received_topic(&client, incoming_topic, &c2d_request)))\n  {\n    //Handle the c2d message\n  }\n  else if (az_result_succeeded(az_iot_hub_client_twin_parse_received_topic(&client, incoming_topic, &twin_response)))\n  {\n    //Handle the twin message\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Installing vcpkg and dependencies using PowerShell\nDESCRIPTION: This PowerShell script installs the vcpkg package manager and necessary dependencies like curl, cmocka, and paho-mqtt. It clones the vcpkg repository, checks out a specific commit, bootstraps vcpkg, and then installs the required packages using the x64-windows-static triplet. This process may take approximately 15-20 minutes to complete.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS C:\\> git clone https://github.com/Microsoft/vcpkg.git\nPS C:\\> cd vcpkg\nPS C:\\vcpkg> git checkout <vcpkg commit> # Checkout the vcpkg commit per vcpkg-commit.txt above.\nPS C:\\vcpkg> .\\bootstrap-vcpkg.bat\nPS C:\\vcpkg> .\\vcpkg.exe install --triplet x64-windows-static curl[winssl] cmocka paho-mqtt # Update triplet per your system.\nPS C:\\vcpkg> cd ..\n```\n\n----------------------------------------\n\nTITLE: Enabling Cloud-to-Device Message Receiving in C\nDESCRIPTION: This function enables the reception of cloud-to-device (C2D) messages from Azure IoT Hub. It requires a pointer to the IoT Hub client. Successful execution allows the device to receive messages sent from the cloud.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_19\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_cloud_message_enable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Building Mbed TLS as Shared Library\nDESCRIPTION: This snippet configures CMake to build Mbed TLS as a shared library instead of a static library.  The `USE_SHARED_MBEDTLS_LIBRARY` option controls this behavior.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\ncmake -DUSE_SHARED_MBEDTLS_LIBRARY=On /path/to/mbedtls_source\n```\n\n----------------------------------------\n\nTITLE: RSA PKCS#1 v1.5 Signature Algorithm Constructor in PSA\nDESCRIPTION: Uses the `PSA_ALG_RSA_PKCS1V15_SIGN(hash)` macro to format the hash according to PKCS#1 v1.5 for RSA signatures.  The `hash` parameter corresponds to the `md_alg` parameter in the legacy Mbed TLS functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_38\n\nLANGUAGE: C\nCODE:\n```\nPSA_ALG_RSA_PKCS1V15_SIGN(PSA_ALG_SHA256)\n```\n\n----------------------------------------\n\nTITLE: RSA Initialization with PKCS#1 v2.1 Padding - C\nDESCRIPTION: Demonstrates how to initialize RSA with PKCS#1 v2.1 padding using `mbedtls_rsa_init()` and `mbedtls_rsa_set_padding()` after the changes.  This involves calling `mbedtls_rsa_init()` first, followed by `mbedtls_rsa_set_padding()` to explicitly set the desired padding scheme and hash identifier. The context `ctx`, padding scheme, and hash identifier `hash_id` must be appropriately initialized before calling these functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/3.0-migration-guide.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n    mbedtls_rsa_init(ctx);\n    mbedtls_rsa_set_padding(ctx, padding, hash_id);\n```\n\n----------------------------------------\n\nTITLE: Setting Key Type Attribute PSA\nDESCRIPTION: This code snippet explains how to set the key type attribute using the `psa_set_key_type` function. It is required to specify the type of the key such as RSA, ECC, or Diffie-Hellman before generating or importing a key.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\npsa_set_key_type\n```\n\n----------------------------------------\n\nTITLE: C Header Includes - Azure Core and IoT\nDESCRIPTION: This snippet shows how to include the Azure Core and Azure IoT headers in a C project. It demonstrates the simplified, all-inclusive service headers provided by the Azure SDK for C.  The project should include the `sdk/inc` directory in the include path for this to work.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/README.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\n#include <az/az_core.h>\n#include <az/az_iot.h>\n```\n\n----------------------------------------\n\nTITLE: Sending Extended Telemetry to Azure IoT Hub in C\nDESCRIPTION: This function sends telemetry data to Azure IoT Hub, including properties provided in a NetX Duo packet. It returns a packet ID for tracking telemetry acknowledgments. The function requires a pointer to the IoT Hub client, a packet containing properties, a pointer to the telemetry data, the size of the data, a pointer to store the packet ID, and a wait option.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_17\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_telemetry_send_extended(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                     NX_PACKET *packet_ptr,\n                                                     const UCHAR *telemetry_data, UINT data_size,\n                                                     USHORT *packet_id, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Importing ECC Private Key from mbedtls_ecp_keypair in C\nDESCRIPTION: This code snippet demonstrates how to import an ECC private key, initially stored in an `mbedtls_ecp_keypair` object, into the PSA framework. It involves writing the key to a buffer, defining the ECC curve, setting key attributes, and then importing the key using `psa_import_key`. Error handling is omitted for brevity. The `curve` variable must be determined manually, a point which a future Mbed TLS version aims to automate.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_19\n\nLANGUAGE: C\nCODE:\n```\nmbedtls_ecp_keypair ec;\nmbedtls_ecp_keypair_init(&ec);\n// Omitted: fill ec with key material\n// (the public key will not be used and does not need to be set)\nunsigned char buf[PSA_BITS_TO_BYTES(PSA_VENDOR_ECC_MAX_CURVE_BITS)];\nsize_t length;\nmbedtls_ecp_write_key_ext(&ec, &length, buf, sizeof(buf));\npsa_ecc_curve_t curve = ...; // need to determine the curve family manually\npsa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;\npsa_set_key_attributes(&attributes, PSA_KEY_TYPE_ECC_KEY_PAIR(curve));\npsa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_... | ...);\npsa_set_key_algorithm(&attributes, PSA_ALGORITHM_...);\npsa_key_id_t key_id = 0;\npsa_import_key(&attributes, buf, length, &key_id);\nmbedtls_ecp_keypair_free(&ec);\n```\n\n----------------------------------------\n\nTITLE: ThreadX Managed Interrupt Handler Template (Assembly)\nDESCRIPTION: This assembly code provides a template for a ThreadX managed interrupt handler. It demonstrates the standard structure for ISRs, allowing access to ThreadX services from the interrupt context. It includes pushing and popping registers to preserve the context and branching to a C interrupt routine.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/ac6/readme_threadx.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\n        .global  __tx_IntHandler\n        .thumb_func\n__tx_IntHandler:\n; VOID InterruptHandler (VOID)\n; {\n        PUSH    {r0, lr}\n\n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n        POP     {r0, lr}\n        BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Creating and Canceling Azure Contexts in C\nDESCRIPTION: This code demonstrates how to create a hierarchy of `az_context` instances with expiration times and how to cancel the application root context, which will propagate the cancellation to all child contexts. The `az_context` type is part of the Azure Core library. This example shows the use of `az_context_create_with_expiration` to create child contexts with expiration times and `az_context_cancel` to cancel the application context.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\n// Some function creates a child with a 10-second expiration:\naz_context child = az_context_create_with_expiration(&az_context_application, 10);\n\n// Some function creates a grandchild with a 60-second expiration:\naz_context grandchild = az_context_create_with_expiration(&child, 60);\n\n// Some other function (perhaps in response to a SIGINT) cancels the application root:\naz_context_cancel(&az_context_application);\n// All children are now in the canceled state & the threads will start unwinding\n```\n\n----------------------------------------\n\nTITLE: Setting Symmetric Key for Azure IoT Hub Client (C)\nDESCRIPTION: This function sets the symmetric key for the Azure IoT Hub client, which is used for authentication. It takes a pointer to the client instance, the symmetric key, and the length of the key as input.  A successful operation sets the symmetric key to the IoTHub client; otherwise, it fails due to an invalid parameter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_symmetric_key_set(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                               const UCHAR *symmetric_key, UINT symmetric_key_length);\n```\n\n----------------------------------------\n\nTITLE: Update Device Twin Desired Properties JSON\nDESCRIPTION: This JSON snippet demonstrates how to update a device twin's desired properties within the Azure IoT Hub. It shows the format for setting the `device_count` property to a specific value (42 in this case). This is sent to the device, triggering a response to report the updated property.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_27\n\nLANGUAGE: json\nCODE:\n```\n  \"properties\": {\n      \"desired\": {\n          \"device_count\": 42\n      }\n  }\n```\n\n----------------------------------------\n\nTITLE: Setting up the NetXDuo Project with CMake\nDESCRIPTION: This CMake snippet sets up the basic project configurations, including required CMake version, project name, supported languages (C and ASM), and options to enable FileX and Azure IoT functionalities. It defines fatal errors if THREADX_ARCH or THREADX_TOOLCHAIN are not defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\n\n# Set up the project\nproject(netxduo\n    LANGUAGES C ASM\n)\n\noption(NXD_ENABLE_FILE_SERVERS \"Includes a dependency on FileX to support 'server' protocol handlers\" ON)\noption(NXD_ENABLE_AZURE_IOT \"Enable Azure IoT\" OFF)\n\nif(NOT DEFINED THREADX_ARCH)\n    message(FATAL_ERROR \"Error: THREADX_ARCH not defined\")\nendif()\nif(NOT DEFINED THREADX_TOOLCHAIN)\n    message(FATAL_ERROR \"Error: THREADX_TOOLCHAIN not defined\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Get IoT Hub Telemetry Topic C\nDESCRIPTION: This code snippet shows how to retrieve the telemetry topic to publish messages to using the `az_iot_hub_client_telemetry_get_publish_topic()` API. It initializes the IoT Hub client and retrieves the topic into a character buffer. It needs a pre-initialized client, hostname, and device id.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n// FOR SIMPLICITY THIS DOES NOT HAVE ERROR CHECKING. IN PRODUCTION ENSURE PROPER ERROR CHECKING.\n\nstatic az_iot_hub_client my_client;\nstatic az_span my_iothub_hostname = AZ_SPAN_LITERAL_FROM_STR(\"contoso.azure-devices.net\");\nstatic az_span my_device_id = AZ_SPAN_LITERAL_FROM_STR(\"contoso_device\");\n\nvoid my_telemetry_func(void)\n{\n  // Initialize the client to then pass to the telemetry API.\n  az_iot_hub_client_init(&my_client, my_iothub_hostname, my_device_id, NULL);\n\n  // Allocate a char buffer with capacity large enough to put the telemetry topic.\n  char telemetry_topic[64];\n  size_t telemetry_topic_length;\n\n  // Get the NULL terminated topic and put in telemetry_topic to send the telemetry.\n  az_iot_hub_client_telemetry_get_publish_topic(\n      &my_client, NULL, telemetry_topic, sizeof(telemetry_topic), &telemetry_topic_length);\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running Unit Tests with CMake\nDESCRIPTION: These commands are used to build and execute unit tests within the Azure SDK for Embedded C project using CMake. The first command configures the build with unit testing enabled. The second command builds the project. The third command executes the unit tests using CTest in verbose mode, providing detailed output.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncmake -DUNIT_TESTING=ON ..\ncmake --build .\n# ctest will call and run tests\n# -V runs tests in verbose mode to show more info about tests\nctest -V\n```\n\n----------------------------------------\n\nTITLE: Set Receive Callback - Azure IoT Hub Client (C)\nDESCRIPTION: Sets a callback function to be invoked when a message is received from Azure IoT Hub. The callback can be set for various message types, such as cloud-to-device messages, commands, properties, and direct methods. Setting the callback to NULL disables it.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_receive_callback_set(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                  UINT message_type,\n                                                  VOID (*callback_ptr)(\n                                                        NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr, VOID *args),\n                                                  VOID *callback_args);\n```\n\n----------------------------------------\n\nTITLE: Initialize IoT Message Properties with Span C\nDESCRIPTION: This code snippet demonstrates how to initialize IoT message properties using an already populated span with the `az_iot_message_properties_init()` API. The span contains a formatted property string. It relies on a pre-defined span named `property_span`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n// FOR SIMPLICITY THIS DOES NOT HAVE ERROR CHECKING. IN PRODUCTION ENSURE PROPER ERROR CHECKING.\n\nstatic az_span property_span = AZ_SPAN_LITERAL_FROM_STR(\"my_device=contoso&my_key=my_value\");\nvoid my_property_func(void)\n{\n  // Initialize the property struct with the span.\n  az_iot_message_properties props;\n  az_iot_message_properties_init(&props, property_span, az_span_size(property_span));\n\n  // At this point, you are able to pass the `props` to other APIs with property parameters.\n}\n```\n\n----------------------------------------\n\nTITLE: Send Telemetry Message - Azure IoT Hub Client (C)\nDESCRIPTION: Sends a telemetry message to Azure IoT Hub, including the telemetry data and any previously added properties within the NX_PACKET. The ownership of the NX_PACKET is released upon successful return. The wait_option specifies how long to wait for the message to be sent.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_telemetry_send(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr, NX_PACKET *packet_ptr,\n                                            const UCHAR *telemetry_data, UINT data_size, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Receive Device Twin Properties - C\nDESCRIPTION: This function receives the complete device twin properties from Azure IoT Hub. It requires a pointer to an NX_AZURE_IOT_HUB_CLIENT, a pointer to an NX_PACKET to store the received properties, and a timeout value. The caller is responsible for managing the NX_PACKET memory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_36\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_device_twin_properties_receive(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                            NX_PACKET **packet_pptr, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Enabling Cryptographic Mechanisms via PSA_WANT_xxx macros in Mbed TLS\nDESCRIPTION: This code snippet demonstrates how to enable specific cryptographic mechanisms in Mbed TLS using the `PSA_WANT_xxx` macros. It includes examples for SHA-256 hashing, AES-GCM AEAD, deterministic ECDSA signature, ECDH key exchange on secp256r1 and Curve25519.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define PSA_WANT_ALG_SHA_256 1\n\n#define PSA_WANT_KEY_TYPE_AES 1\n#define PSA_WANT_ALG_GCM 1\n\n#define PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_GENERATE 1\n// ^^ In Mbed TLS <= 3.4, enable PSA_WANT_KEY_TYPE_ECC_KEY_PAIR instead\n// ^^ implicitly enables PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_BASIC, PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY\n#define PSA_WANT_ECC_SECP_R1_256 1 // secp256r1 (suitable for ECDSA and ECDH)\n#define PSA_WANT_ECC_MONTGOMERY_255 1 // Curve25519 (suitable for ECDH)\n#define PSA_WANT_ALG_DETERMINISTIC_ECDSA 1\n#define PSA_WANT_ALG_ECDH\n```\n\n----------------------------------------\n\nTITLE: Set Environment Variable for Certificate Path (PowerShell)\nDESCRIPTION: This command sets the `AZ_IOT_DEVICE_X509_CERT_PEM_FILE_PATH` environment variable to the absolute path of the combined certificate file (`device_cert_store.pem`). This variable is used by the Azure IoT Hub samples to locate the device certificate.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_7\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS C:\\azure-sdk-for-c\\sdk\\samples\\iot> $env:AZ_IOT_DEVICE_X509_CERT_PEM_FILE_PATH=$(Resolve-Path device_cert_store.pem)\n```\n\n----------------------------------------\n\nTITLE: DPS X509 Configuration (C)\nDESCRIPTION: These macros configure the device to connect to Azure Device Provisioning Service using an X.509 certificate.  The certificate must be registered with DPS. The `ENABLE_DPS_SAMPLE` macro enables DPS functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/samples/README.md#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\n#define ENDPOINT                                    \"<Service Endpoint or Global device endpoint from Provisioning service overview page>\"\n#define ID_SCOPE                                    \"<ID Scope value from Provisioning service overview page>\"\n#define REGISTRATION_ID                             \"<RegistrationId provide when doing Individual registration>\"\n#define USE_DEVICE_CERTIFICATE                      1\n#define DEVICE_KEY_TYPE                             NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER /* Right now only RSA certs are supported*/\n\n/* Enable DPS */\n#define ENABLE_DPS_SAMPLE\n```\n\n----------------------------------------\n\nTITLE: Receiving Direct Method Message - C\nDESCRIPTION: This function receives a direct method message from IoT Hub. It blocks until a message is received or a timeout occurs, as specified by the `wait_option` parameter. The function returns the method name, context, and payload in provided output parameters, including an allocated packet.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_25\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_direct_method_message_receive(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                           const UCHAR **method_name_pptr, USHORT *method_name_length_ptr,\n                                                           VOID **context_pptr, USHORT *context_length_ptr,\n                                                           NX_PACKET **packet_pptr, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Append Property Name Azure IoT JSON Writer C\nDESCRIPTION: Appends a property name to the JSON payload using the Azure IoT JSON writer.  This function takes a pointer to the writer, the UTF-8 encoded property name, and its length as input. The property name is escaped before writing to the payload. Returns NX_AZURE_IOT_SUCCESS on successful append.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_property_name(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr,\n                                                   const UCHAR *value, UINT value_len);\n```\n\n----------------------------------------\n\nTITLE: Generate Self-Signed Device Certificate (OpenSSL)\nDESCRIPTION: These commands generate a self-signed device certificate for X.509 authentication with Azure IoT Hub. The first command creates an elliptic curve private key. The second creates a certificate signing request and signs it with the key to create a self-signed certificate. The third displays the certificate content.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_5\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS C:\\> cd .\\azure-sdk-for-c\\sdk\\samples\\iot\\\n\nPS C:\\azure-sdk-for-c\\sdk\\samples\\iot> openssl ecparam -out device_ec_key.pem -name prime256v1 -genkey\nPS C:\\azure-sdk-for-c\\sdk\\samples\\iot> openssl req -new -days 1 -nodes -x509 -key device_ec_key.pem -out device_ec_cert.pem -extensions client_auth -config x509_config.cfg -subj \"/CN=paho-sample-device1\"\nPS C:\\azure-sdk-for-c\\sdk\\samples\\iot> openssl x509 -noout -text -in device_ec_cert.pem\n```\n\n----------------------------------------\n\nTITLE: Parsing Received MQTT Topics in Azure IoT Hub Client (C)\nDESCRIPTION: This code showcases how to parse incoming MQTT topics to identify the type of message (C2D, Method request, or Twin operation) using the `az_iot_hub_client` library.  It attempts to parse the received topic as a C2D message, then a method request, and finally a twin response.  Based on the successful parse, it extracts relevant data from the parsed request structures.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/mqtt_state_machine.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n    az_iot_hub_client_c2d_request c2d_request;\n    az_iot_hub_client_method_request method_request;\n    az_iot_hub_client_twin_response twin_response;\n\n    //az_span received_topic is filled by the application.\n\n    if (az_result_succeeded(az_iot_hub_client_c2d_parse_received_topic(client, received_topic, &c2d_request))\n    {\n        // This is a C2D message:\n        //  c2d_request.properties contain the properties of the message.\n        //  the MQTT message payload contains the data.\n    }\n    else if (az_result_succeeded(ret = az_iot_hub_client_methods_parse_received_topic(client, received_topic, &method_request))\n    {\n        // This is a Method request:\n        //  method_request.name contains the method\n        //  method_request.request_id contains the request ID that must be used to submit the response using az_iot_hub_client_methods_response_get_publish_topic()\n    }\n    else if (az_result_succeeded(ret = az_iot_hub_client_twin_parse_received_topic(client, received_topic, &twin_response))\n    {\n        // This is a Twin operation.\n        switch (twin_response.response_type)\n        {\n            case AZ_IOT_CLIENT_TWIN_RESPONSE_TYPE_GET:\n                // This is a response to a az_iot_hub_client_twin_document_get_publish_topic.\n                break;\n            case AZ_IOT_CLIENT_TWIN_RESPONSE_TYPE_DESIRED_PROPERTIES:\n                // This is received as the Twin desired properties were changed using the service client.\n                break;\n            case AZ_IOT_CLIENT_TWIN_RESPONSE_TYPE_REPORTED_PROPERTIES:\n                // This is a response received after patching the reported properties using az_iot_hub_client_twin_patch_get_publish_topic().\n                break;\n            default:\n                // error.\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Reading Azure IoT Hub Properties in C\nDESCRIPTION: This code snippet iterates through the properties in a JSON document received from Azure IoT Hub. It checks if a property matches 'user_property' and extracts its value if it does. If the property is not of interest, the reader skips to the next property.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client_properties.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nif (nx_azure_iot_json_reader_find_next_property(&json_reader,\n                                                                                   &component_name_ptr, &component_length)) == NX_AZURE_IOT_SUCCESS)\n {\n \n     /* Check if property is of interest (substitute user_property for your own property name)  */\n     if (nx_azure_iot_json_reader_token_is_text_equal(&json_reader, user_property, user_property_length))\n     {\n         nx_azure_iot_json_reader_next_token(&json_reader);\n\n         /* Get the property value here\n            Example: nx_azure_iot_json_reader_token_int32_get(&json_reader, &user_int);  */\n \n         /* Skip to next property value  */\n         nx_azure_iot_json_reader_next_token(&json_reader);\n    }\n    else\n    {\n\n        /* The JSON reader must be advanced regardless of whether the property\n           is of interest or not.  */\n        nx_azure_iot_json_reader_next_token(&json_reader);\n \n        /* Skip children in case the property value is an object.  */\n        nx_azure_iot_json_reader_skip_children(&json_reader);\n        nx_azure_iot_json_reader_next_token(&json_reader);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Client Send Request Contract (C)\nDESCRIPTION: This C code snippet defines the contract that an HTTP transport adapter must implement when using a custom HTTP stack. It takes an `az_http_request` and populates an `az_http_response`. This function is part of the Azure SDK Core and is used to abstract the underlying HTTP implementation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/README.md#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nAZ_NODISCARD az_result\naz_http_client_send_request(az_http_request const* request, az_http_response* ref_response);\n```\n\n----------------------------------------\n\nTITLE: Setting DHCP Test Cases\nDESCRIPTION: This snippet defines a list of C source files that form the DHCP regression test suite, including both IPv4 and IPv6 tests. These files are used to test various aspects of the DHCP client and server implementations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(dhcp_test_cases\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_03_01_01_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_03_02_01_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_03_02_02_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_03_02_03_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_03_05_01_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_04_01_01_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_04_03_02_01_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_04_03_02_02_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_04_03_02_03_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_04_03_05_01_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_04_04_01_01_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_04_04_01_02_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_basic_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_basic_restore_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_user_option_add_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_packet_process_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_client_send_with_zero_source_address_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_multiple_instances_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_send_request_internal_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_extract_information_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_get_option_value_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_delete_test.    \n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_stop_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_enable_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_start_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_release_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_reinitialize_test.    \n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_client_activate_interfaces_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_client_secondary_interface_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_client_interface_order_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_client_ip_mutex_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_client_server_source_port_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_client_ntp_option_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_client_parameter_request_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_coverage_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_unicast_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_server_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_server_improper_term_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_server_second_interface_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_server_options_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_server_small_packet_payload_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_skip_discover_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_client_nxe_api_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcpv6_basic_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcpv6_extended_api_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcpv6_packet_loss_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcpv6_client_process_server_duid_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcpv6_server_ia_options_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcpv6_server_iana_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcpv6_server_process_repeated_msgs_test.c\n    ${SOURCE_DIR}/dhcp_test/netx_dhcpv6_user_option_add_test.c)\n```\n\n----------------------------------------\n\nTITLE: Setting Device Certificate in C\nDESCRIPTION: This code snippet shows how to set the device certificate for the Azure IoT Hub client using the `nx_azure_iot_hub_client_device_cert_set` function. It takes a pointer to the hub client and a pointer to the device certificate as parameters. This function can be called multiple times to set the certificate chain.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_device_cert_set(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                             NX_SECURE_X509_CERT *device_certificate);\n```\n\n----------------------------------------\n\nTITLE: Interrupt Service Routine (ISR) in C with ThreadX\nDESCRIPTION: This C code snippet demonstrates the structure of an Interrupt Service Routine (ISR) for Cortex-M processors using IAR tools, which can directly access ThreadX APIs.  'your_C_isr' represents an entry in the vector table linked to the ISR. It does not require explicit context saving or restoring calls.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/iar/readme_threadx.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling VFP for a Thread (C)\nDESCRIPTION: This C code snippet shows how to enable VFP (Vector Floating Point) register saving for a specific thread in ThreadX. The `tx_thread_vfp_enable()` function must be called from the thread's context before the thread starts using VFP instructions. This ensures that VFP registers are saved/restored when the thread is preempted by an interrupt.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/gnu/readme_threadx.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nvoid    tx_thread_vfp_enable(void);\n```\n\n----------------------------------------\n\nTITLE: Enabling VFP Support - C\nDESCRIPTION: This C code demonstrates how to enable VFP (Vector Floating Point) register saving for a specific thread. `tx_thread_vfp_enable()` must be called from the thread's context before VFP usage. After this call, VFP registers will be saved and restored if the thread is preempted via an interrupt.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac5/readme_threadx.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nvoid    tx_thread_vfp_enable(void);\n```\n\n----------------------------------------\n\nTITLE: Initializing Azure IoT Subsystem in C\nDESCRIPTION: This code snippet demonstrates how to create an Azure IoT subsystem using the `nx_azure_iot_create` function. It requires pointers to an IP stack, packet pool, DNS, memory stack, and a callback function to fetch the unix time.  The function creates an internal thread to manage Azure IoT services such as IoT Hub, IoT Central and DPS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_create(NX_AZURE_IOT *nx_azure_iot_ptr, const UCHAR *name_ptr,\n                         NX_IP *ip_ptr, NX_PACKET_POOL *pool_ptr, NX_DNS *dns_ptr,\n                         VOID *stack_memory_ptr, UINT stack_memory_size,\n                         UINT priority, UINT (*unix_time_callback)(ULONG *unix_time));\n```\n\n----------------------------------------\n\nTITLE: Determining the Type of a JSON Token in C\nDESCRIPTION: Determines the type of token the NX_AZURE_IOT_JSON_READER currently points to. It requires a pointer to the reader instance. Returns a token type such as NX_AZURE_IOT_READER_TOKEN_NONE, NX_AZURE_IOT_READER_TOKEN_BEGIN_OBJECT, etc.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_token_type(NX_AZURE_IOT_JSON_READER *reader_ptr);\n```\n\n----------------------------------------\n\nTITLE: Receiving Command Message - C\nDESCRIPTION: This function receives a command message from IoT Hub. It blocks until a message arrives or the timeout specified by `wait_option` is reached.  Upon success, it returns the component name, command name, context, and the command payload within an `NX_PACKET`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_29\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_command_message_receive(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                     const UCHAR **component_name_pptr, \n                                                     USHORT *component_name_length_ptr,\n                                                     const UCHAR **pnp_command_name_pptr, \n                                                     USHORT *pnp_command_name_length_ptr,\n                                                     VOID **context_pptr, \n                                                     USHORT *context_length_ptr,\n                                                     NX_PACKET **packet_pptr, \n                                                     UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Appending Component End to Reported Properties JSON Payload (C)\nDESCRIPTION: This routine appends the necessary characters to end a reported property JSON payload belonging to a subcomponent.  It finalizes the JSON structure for the current component.  Dependencies include NX_AZURE_IOT_HUB_CLIENT and NX_AZURE_IOT_JSON_WRITER.  It must be called after adding all component properties and values, in conjunction with `nx_azure_iot_hub_client_reported_properties_component_begin()`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client_properties.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_reported_properties_component_end(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                               NX_AZURE_IOT_JSON_WRITER *writer_ptr);\n```\n\nLANGUAGE: c\nCODE:\n```\nnx_azure_iot_hub_client_reported_properties_component_begin()\n```\n\n----------------------------------------\n\nTITLE: Nested IRQ Handler in Assembly\nDESCRIPTION: This assembly code shows an example of enabling nested IRQ interrupts in a standard IRQ handler. It calls _tx_thread_irq_nesting_start and _tx_thread_irq_nesting_end to manage the interrupt nesting. TX_ENABLE_IRQ_NESTING must be defined during library compilation to enable this functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/cortex_a7_smp/gnu/readme_threadx.txt#_snippet_2\n\nLANGUAGE: assembly\nCODE:\n```\nEXPORT  __tx_irq_handler\nEXPORT  __tx_irq_processing_return\n__tx_irq_handler\n;\n;    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save\n__tx_irq_processing_return\n;\n;    /* Enable nested IRQ interrupts. NOTE:  Since this service returns\n;       with IRQ interrupts enabled, all IRQ interrupt sources must be \n;       cleared prior to calling this service.  */\n    BL      _tx_thread_irq_nesting_start\n;    \n;    /* Application ISR call(s) go here!  */\n;\n;    /* Disable nested IRQ interrupts. The mode is switched back to\n;       IRQ mode and IRQ interrupts are disable upon return.  */\n    BL      _tx_thread_irq_nesting_end\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: EWARM linker file modification for ThreadX\nDESCRIPTION: This snippet shows the modification needed in the EWARM linker (.icf) file to enable dynamic memory allocation for ThreadX.  It places the `FREE_MEM` section in the RAM region, allowing ThreadX to manage memory dynamically. This configuration is necessary when using dynamic memory allocation features in ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_MultiAccess/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Appending Property with Integer Value\nDESCRIPTION: Appends a UTF-8 property name and an integer value to the JSON writer. The property name is escaped before writing.  This function allows for adding integer key-value pairs to the JSON structure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_property_with_int32_value(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr,\n                                                               const UCHAR *property_name, UINT property_name_len,\n                                                               int32_t value);\n```\n\n----------------------------------------\n\nTITLE: Creating PSA key from PK object in Mbed TLS\nDESCRIPTION: This code snippet demonstrates how to create a PSA key from a PK object in Mbed TLS. It initializes a PK context, parses a key from a buffer, gets the PSA attributes, imports the key into PSA, and then frees the PK context. Requires mbedtls/pk.h and psa/crypto.h. The 'key_buffer' and 'key_buffer_length' variables should contain the key data, and MBEDTLS_PSA_RANDOM_STATE is assumed to be initialized.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_18\n\nLANGUAGE: C\nCODE:\n```\nmbedtls_pk_context pk;\nmbedtls_pk_init(&pk);\nmbedtls_pk_parse_key(&pk, key_buffer, key_buffer_length, NULL, 0,\n                     mbedtls_psa_get_random, MBEDTLS_PSA_RANDOM_STATE);\npsa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;\nmbedtls_pk_get_psa_attributes(&pk, PSA_KEY_USAGE_SIGN_HASH, &attributes);\npsa_key_id_t key_id;\nmbedtls_pk_import_into_psa(&pk, &attributes, &key_id);\nmbedtls_pk_free(&pk);\npsa_sign_hash(key_id, ...);\n```\n\n----------------------------------------\n\nTITLE: Initializing PSA Crypto\nDESCRIPTION: When `MBEDTLS_USE_PSA_CRYPTO` is enabled, you need to call `psa_crypto_init()` before calling any function from the SSL/TLS, X.509 or PK modules, except for the various mbedtls_xxx_init() functions. This initializes the PSA crypto subsystem for use by these modules. It is a prerequisite for using PSA-based cryptographic operations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/use-psa-crypto.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\npsa_crypto_init()\n```\n\n----------------------------------------\n\nTITLE: Getting the Next Component Property (C)\nDESCRIPTION: This routine retrieves the next desired or reported property within a component from a JSON properties document. It allows iteration through the properties within components, extracting both the component name and the property name. Dependencies include NX_AZURE_IOT_HUB_CLIENT and NX_AZURE_IOT_JSON_READER. After extracting name and value, user should call `nx_azure_iot_json_reader_next_token()` before calling this API again.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client_properties.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_properties_component_property_next_get(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                                    NX_AZURE_IOT_JSON_READER *reader_ptr,\n                                                                    UINT message_type, UINT property_type,\n                                                                    const UCHAR **component_name_pptr,\n                                                                    USHORT *component_name_length_ptr);\n```\n\nLANGUAGE: c\nCODE:\n```\n while ((status = nx_azure_iot_hub_client_properties_component_property_next_get(&iothub_client,\n                                                                                 &json_reader,\n                                                                                 message_type,             \n                                                                                 NX_AZURE_IOT_HUB_CLIENT_PROPERTY_WRITABLE,\n```\n\n----------------------------------------\n\nTITLE: Handling Retry-After from Provisioning Service in C\nDESCRIPTION: This code snippet demonstrates how to handle the `retry-after` parameter provided by the Provisioning Service in case of service-level errors. If a `retry-after` value is present in the response, it is used as the delay; otherwise, the exponential back-off with jitter calculation is used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/mqtt_state_machine.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\n// az_iot_provisioning_client_received_topic_payload_parse was successful and created a az_iot_provisioning_client_register_response response\n\nint32_t delay_ms;\nif ( response.retry_after_seconds > 0 )\n{\n    delay_ms = response.retry_after_seconds;\n}\nelse\n{\n    delay_ms = az_iot_calculate_retry_delay(operation_msec, attempt, min_retry_delay_msec, max_retry_delay_msec, random_jitter_msec);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Connection Status Callback for Azure IoT Hub Client (C)\nDESCRIPTION: This function sets a callback function to be invoked when the Azure IoT Hub client's connection status changes. It takes a pointer to the client instance and a pointer to the callback function as input.  Setting the callback function to NULL disables the callback function. The callback provides the new status of the connection (e.g., success, failure, disconnection events).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_connection_status_callback_set(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                            VOID (*connection_status_cb)(\n                                                                 struct NX_AZURE_IOT_HUB_CLIENT_STRUCT\n                                                                 *hub_client_ptr, UINT status));\n```\n\n----------------------------------------\n\nTITLE: Importing Key PSA\nDESCRIPTION: This code snippet shows how to import key material using the `psa_import_key` function. This function allows directly importing key material into a PSA key object.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_13\n\nLANGUAGE: C\nCODE:\n```\npsa_import_key\n```\n\n----------------------------------------\n\nTITLE: Set CMake Minimum Version and Project Name\nDESCRIPTION: Sets the minimum required CMake version and the project name for the CMSIS-DSP library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\ncmake_policy(SET CMP0077 NEW)\nproject(CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Create EC Self-Signed Certificates (Shell)\nDESCRIPTION: These commands generate EC self-signed certificates using OpenSSL. It includes generating a private key, creating a certificate signing request, and converting the key and certificate to DER format for use in embedded systems.  This example uses the secp384r1 elliptic curve.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/samples/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n# Generate private key and certificate (public key). Note: The comman name must be device id.\nopenssl req -new -x509 -nodes -days 365 -newkey ec:<(openssl ecparam -name secp384r1) -keyout privkey.pem -out cert.pem -config x509_config.cfg -subj \"/CN=<Same as device Id>\"\n\n# Convert format from key to der.\nopenssl ec -outform der -in privkey.pem -out privkey.der\n\n# Convert format from cert pem to der.\nopenssl x509 -outform der -in cert.pem -out cert.der\n```\n\n----------------------------------------\n\nTITLE: Setting vcpkg Environment Variables - PowerShell\nDESCRIPTION: This code snippet demonstrates how to set the VCPKG_DEFAULT_TRIPLET and VCPKG_ROOT environment variables in PowerShell. It's used to configure the vcpkg dependency manager for the build process.  Replace '<FULL PATH to vcpkg>' with the actual path to your vcpkg installation, and update the triplet to match your vcpkg installation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_13\n\nLANGUAGE: powershell\nCODE:\n```\n$env:VCPKG_DEFAULT_TRIPLET='x64-windows-static' # Update triplet to match what was used during vcpkg install.\n$env:VCPKG_ROOT='<FULL PATH to vcpkg>'\n```\n\n----------------------------------------\n\nTITLE: OSPI Flash Erase Configuration\nDESCRIPTION: This code snippet demonstrates how to enable the NOR Flash chip erase operation before formatting it using FileX and LevelX.  The flag LX_STM32_OSPI_ERASE in the lx_stm32_ospi_driver.h file should be set to 1.  This operation is disabled by default due to its time-consuming nature.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_Dual_Instance/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define LX_STM32_OSPI_ERASE                              1\n```\n\n----------------------------------------\n\nTITLE: Create Telemetry Message - Azure IoT Hub Client (C)\nDESCRIPTION: Creates a packet for sending telemetry data to Azure IoT Hub. The application owns the allocated NX_PACKET and can add user-defined properties before sending it. The wait_option specifies the number of ticks to wait if no packet is available.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_telemetry_message_create(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                      NX_PACKET **packet_pptr,\n                                                      UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Writing Early Data via TLS with Mbed TLS\nDESCRIPTION: This function writes early data to a TLS connection during the initial handshake phase. It uses mbedtls_ssl_write_early_data() and handles potential errors such as MBEDTLS_ERR_SSL_CANNOT_WRITE_EARLY_DATA.  The function expects a fresh SSL context and takes the SSL context, data buffer, data length, and a pointer to store the amount of data written as parameters. It returns 0 on success, or an error code if an error occurs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/tls13-early-data.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nint write_early_data(mbedtls_ssl_context *ssl,\n                     const unsigned char *data_to_write,\n                     size_t data_to_write_len,\n                     size_t *data_written)\n{\n    int ret;\n    *data_written = 0;\n\n    while (*data_written < data_to_write_len) {\n        ret = mbedtls_ssl_write_early_data(ssl, data_to_write + *data_written,\n                                           data_to_write_len - *data_written);\n\n        if (ret < 0 &&\n            ret != MBEDTLS_ERR_SSL_WANT_READ &&\n            ret != MBEDTLS_ERR_SSL_WANT_WRITE) {\n            return ret;\n        }\n\n        *data_written += ret;\n    }\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Receive Desired Properties - C\nDESCRIPTION: This function receives desired properties from Azure IoT Hub. It takes a pointer to an NX_AZURE_IOT_HUB_CLIENT, a pointer to an NX_PACKET for storing the received properties, and a timeout value. The caller owns the NX_PACKET memory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_37\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_device_twin_desired_properties_receive(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                                    NX_PACKET **packet_pptr, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Disable IoTHub Features (C)\nDESCRIPTION: These macros are used to disable specific features like telemetry, C2D messages, and direct methods. Defining these macros will prevent the corresponding features from being used in the sample application.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/samples/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n/* Defined, telemetry is disabled. */\n#define DISABLE_TELEMETRY_SAMPLE\n\n/* Defined, C2D is disabled. */\n#define DISABLE_C2D_SAMPLE\n\n/* Defined, Direct methods is disabled. */\n#define DISABLE_DIRECT_METHOD_SAMPLE\n```\n\n----------------------------------------\n\nTITLE: Creating an AES-GCM Key in a Secure Element with PSA in C\nDESCRIPTION: This snippet demonstrates how to create an AES-GCM key that is only accessible inside a secure element using the PSA Cryptography API. The `PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION` macro is used to set the key's lifetime, indicating its location and persistence.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_51\n\nLANGUAGE: C\nCODE:\n```\npsa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;\npsa_set_key_lifetime(&attributes, PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(\n        PSA_KEY_PERSISTENCE_DEFAULT, PSA_KEY_LOCATION_acme));\npsa_set_key_identifier(&attributes, 42);\npsa_set_key_type(&attributes, PSA_KEY_TYPE_AES);\npsa_set_key_size(&attributes, 128);\npsa_set_key_algorithm(&attributes, PSA_ALG_GCM);\npsa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);\npsa_key_id_t key;\npsa_generate_key(&attributes, &key);\n```\n\n----------------------------------------\n\nTITLE: Setting IoT Provisioning X.509 Environment Variables - PowerShell\nDESCRIPTION: This code snippet shows how to set the AZ_IOT_PROVISIONING_REGISTRATION_ID and AZ_IOT_PROVISIONING_ID_SCOPE environment variables in PowerShell. These are required for the IoT Provisioning X.509 certificate sample. Replace `<registration-id>` and `<id-scope>` with values obtained from your Azure IoT Hub Device Provisioning Service.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_18\n\nLANGUAGE: powershell\nCODE:\n```\n$env:AZ_IOT_PROVISIONING_REGISTRATION_ID='<registration-id>'\n$env:AZ_IOT_PROVISIONING_ID_SCOPE='<id-scope>'\n```\n\n----------------------------------------\n\nTITLE: Send Device Twin Reported Properties in C\nDESCRIPTION: This function sends device twin reported properties to the IoT Hub. It requires a hub client pointer, a message buffer containing the JSON document, the message length, pointers to store request ID, response status, and version, and a wait option.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_34\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_device_twin_reported_properties_send(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                                  const UCHAR *message_buffer, UINT message_length,\n                                                                  UINT *request_id_ptr, UINT *response_status_ptr,\n                                                                  ULONG *version_ptr, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Defining TX_LOW_POWER_USER_EXIT Macro in C\nDESCRIPTION: This example shows how to define the TX_LOW_POWER_USER_EXIT macro. This macro invokes the user-defined `low_power_exit` function, which contains the processor-specific code required when exiting low power mode, such as re-enabling peripherals.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/low_power/low_power.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n/* Low power exit function prototype. */\nvoid low_power_exit(void);\n\n/* Define the TX_LOW_POWER_USER_EXIT macro. */\n#define TX_LOW_POWER_USER_EXIT low_power_exit\n\nvoid low_power_exit(void)\n{\n    /* Insert code here to configure the processor to exit low power mode. */\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Key PSA\nDESCRIPTION: This code snippet shows how to generate a key randomly using the `psa_generate_key` function. This function is used when a new cryptographic key needs to be created randomly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_14\n\nLANGUAGE: C\nCODE:\n```\npsa_generate_key\n```\n\n----------------------------------------\n\nTITLE: Get Next Timer Expiration in tx_low_power_enter (C)\nDESCRIPTION: This example demonstrates how the `tx_timer_get_next` function is used within `tx_low_power_enter` to determine the next timer expiration before entering low power mode.  The `tx_low_power_next_expiration` variable stores the number of ticks until the next timer event. `timers_active` indicates if any timers are currently active.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/low_power/low_power.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nULONG   tx_low_power_next_expiration;   /* The next timer expiration (units of ThreadX timer ticks). */\nULONG   timers_active;\n\n    /*  At this point, we want to enter low power mode, since nothing\n        meaningful is going on in the system. However, in order to keep\n        the ThreadX timer services accurate, we must first determine the\n        next ThreadX timer expiration in terms of ticks. This is\n        accomplished via the tx_timer_get_next API.  */\n    timers_active =  tx_timer_get_next(&tx_low_power_next_expiration);\n```\n\n----------------------------------------\n\nTITLE: Configuring Mbed TLS Build Options with CMake\nDESCRIPTION: This snippet defines CMake options to control the build type of the Mbed TLS library and its dependencies. It specifies whether to build a static or shared library, and if linking with pthread or trusted_storage is required. The options are used to configure the compilation and linking process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\noption(USE_STATIC_MBEDTLS_LIBRARY \"Build Mbed TLS static library.\" ON)\noption(USE_SHARED_MBEDTLS_LIBRARY \"Build Mbed TLS shared library.\" OFF)\noption(LINK_WITH_PTHREAD \"Explicitly link Mbed TLS library to pthread.\" OFF)\noption(LINK_WITH_TRUSTED_STORAGE \"Explicitly link Mbed TLS library to trusted_storage.\" OFF)\n```\n\n----------------------------------------\n\nTITLE: C ISR Implementation in ThreadX\nDESCRIPTION: This code snippet demonstrates how to implement an Interrupt Service Routine (ISR) in C that is compatible with ThreadX.  The ISR, 'your_C_isr', is a standard C function that performs interrupt handling tasks. No explicit context saving or restoring is needed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Data with Early Data Rejection Handling in Mbed TLS\nDESCRIPTION: This snippet handles the possibility of the server rejecting early data. It attempts to write early data, then completes the handshake, checks the early data status, and writes the remaining data using the standard `write_data` function. mbedtls_ssl_get_early_data_status() is used to check if early data was rejected and adjusts early_data_written accordingly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/tls13-early-data.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nret = write_early_data(ssl,\n                       data_to_write,\n                       data_to_write_len,\n                       &early_data_written);\nif (ret < 0 &&\n    ret != MBEDTLS_ERR_SSL_CANNOT_WRITE_EARLY_DATA) {\n    goto error;\n}\n\n/*\n * Make sure the handshake is completed as it is a requisite of\n * mbedtls_ssl_get_early_data_status().\n */\nwhile (!mbedtls_ssl_is_handshake_over(ssl)) {\n    ret = mbedtls_ssl_handshake(ssl);\n    if (ret < 0 &&\n        ret != MBEDTLS_ERR_SSL_WANT_READ &&\n        ret != MBEDTLS_ERR_SSL_WANT_WRITE) {\n        goto error;\n    }\n}\n\nret = mbedtls_ssl_get_early_data_status(ssl);\nif (ret < 0) {\n    goto error;\n}\n\nif (ret == MBEDTLS_SSL_EARLY_DATA_STATUS_REJECTED) {\n   early_data_written = 0;\n}\n\nret = write_data(ssl,\n                 data_to_write + early_data_written,\n                 data_to_write_len - early_data_written,\n                 &data_written);\nif (ret < 0) {\n    goto error;\n}\n\ndata_written += early_data_written;\n```\n\n----------------------------------------\n\nTITLE: Enabling Libcurl\nDESCRIPTION: Conditionally adds a compile definition to enable libcurl support. If the `TRANSPORT_CURL` option is enabled, the `TRANSPORT_CURL` definition is added, which will be used to enable the use of libcurl for HTTP transport.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif(TRANSPORT_CURL)\n  add_compile_definitions(TRANSPORT_CURL)\nendif()\n```\n\n----------------------------------------\n\nTITLE: DPS Symmetric Key Configuration (C)\nDESCRIPTION: These macros configure the device to connect to Azure Device Provisioning Service using a symmetric key. The placeholders must be replaced with the correct values from the Azure portal. The `ENABLE_DPS_SAMPLE` macro enables DPS functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/samples/README.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\n#define ENDPOINT                                    \"<Service Endpoint or Global device endpoint from Provisioning service overview page>\"\n#define ID_SCOPE                                    \"<ID Scope value from Provisioning service overview page>\"\n#define REGISTRATION_ID                             \"<RegistrationId provide when doing Individual registration>\"\n#define DEVICE_SYMMETRIC_KEY                        \"<Symmetric key from Individual registration detail page>\"\n\n/* Enable DPS */\n#define ENABLE_DPS_SAMPLE\n```\n\n----------------------------------------\n\nTITLE: Applying ADU Update in C\nDESCRIPTION: This code snippet shows the prototype for applying a downloaded and installed ADU update. It takes a pointer to the ADU agent. This function triggers the update application, which may involve a device reboot.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_adu_agent.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_adu_agent_update_apply(NX_AZURE_IOT_ADU_AGENT *adu_agent_ptr);\n```\n\n----------------------------------------\n\nTITLE: Checking IoT Hub Status for Error and Retriability in C\nDESCRIPTION: This code snippet demonstrates how to check an `az_iot_status` value received from IoT Hub to determine if an operation was successful, if it resulted in an error, and whether the operation should be retried. It leverages the `az_iot_status_succeeded` and `az_iot_status_retriable` functions to classify the status.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/mqtt_state_machine.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\naz_iot_status status = response.status;\nif (az_iot_status_succeeded(status))\n{\n    // success case\n}\nelse\n{\n    if (az_iot_status_retriable(status))\n    {\n        // retry\n    }\n    else\n    {\n        // fail\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up an Opaque Key in PK Context\nDESCRIPTION: The `mbedtls_pk_setup_opaque()` function wraps a PSA key pair into a PK context. This allows the key to be used for private-key operations, and its public part can be exported. The key is managed by PSA, which enables isolation of long-term secrets and use of PSA Crypto drivers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/use-psa-crypto.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nmbedtls_pk_setup_opaque()\n```\n\n----------------------------------------\n\nTITLE: Session Cache API: Custom Implementation Signatures in C\nDESCRIPTION: Defines the function signatures required for implementing a custom session cache in Mbed TLS 3.0. This API replaces the previous session cache configuration, requiring the cache to act as a key-value store where keys are session IDs and values are `mbedtls_ssl_session` instances. The structure of `mbedtls_ssl_session` is now private, so portable session cache implementations must not access its internal fields directly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/3.0-migration-guide.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\ntypedef int mbedtls_ssl_cache_get_t( void *data,\n                                     unsigned char const *session_id,\n                                     size_t session_id_len,\n                                     mbedtls_ssl_session *session );\ntypedef int mbedtls_ssl_cache_set_t( void *data,\n                                     unsigned char const *session_id,\n                                     size_t session_id_len,\n                                     const mbedtls_ssl_session *session );\n```\n\n----------------------------------------\n\nTITLE: Enabling Direct Method Message Receiving in C\nDESCRIPTION: This function enables receiving direct method invocation requests from Azure IoT Hub.  It takes a pointer to the IoT Hub client as a parameter. After enabling, the device can receive and process direct method calls initiated from the cloud.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_23\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_direct_method_enable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Create CMSIS-DSP Interpolation Static Library\nDESCRIPTION: This snippet creates a static library named `CMSISDSPInterpolation` and adds the source files for various interpolation functions to it. It includes implementations for bilinear, linear, and spline interpolation, supporting floating-point (f32) and fixed-point (q15, q31, q7) data types.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/InterpolationFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(CMSISDSPInterpolation STATIC)\n\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_bilinear_interp_f32.c)\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_bilinear_interp_q15.c)\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_bilinear_interp_q31.c)\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_bilinear_interp_q7.c)\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_linear_interp_f32.c)\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_linear_interp_q15.c)\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_linear_interp_q31.c)\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_linear_interp_q7.c)\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_spline_interp_f32.c)\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_spline_interp_init_f32.c)\n```\n\n----------------------------------------\n\nTITLE: PSA Key Type Configuration Symbol Example\nDESCRIPTION: Example showing the configuration symbols for different types of key operations in PSA Cryptography like basic support, import, generation, derivation, and export.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-conditional-inclusion-c.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nPSA_WANT_KEY_TYPE_xxx_KEY_PAIR_BASIC\nPSA_WANT_KEY_TYPE_xxx_KEY_PAIR_IMPORT\nPSA_WANT_KEY_TYPE_xxx_KEY_PAIR_GENERATE\nPSA_WANT_KEY_TYPE_xxx_KEY_PAIR_DERIVE\nPSA_WANT_KEY_TYPE_xxx_KEY_PAIR_EXPORT\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Template - ThreadX Cortex-M85\nDESCRIPTION: This assembly code snippet provides a template for creating interrupt service routines (ISRs) within a ThreadX environment on a Cortex-M85 processor. It includes the necessary stack manipulation and branching instructions to ensure proper context switching. It requires the `.thumb_func` directive to ensure the linker creates thumb labels for exception handlers. The label `__tx_IntHandler` needs to be inserted in the interrupt vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/ac6/readme_threadx.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\n    .global  your_assembly_isr\n    .thumb_func\nyour_assembly_isr:\n; VOID your_assembly_isr(VOID)\n; {\n    PUSH    {r0, lr}\n;       \n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n    POP     {r0, lr}\n    BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Modifying driver wrapper for sign_hash in Mbed TLS\nDESCRIPTION: This C code snippet demonstrates how the `psa_driver_wrapper_sign_hash()` function in Mbed TLS is modified to integrate p256-m. It checks if p256-m is enabled (`MBEDTLS_PSA_P256M_DRIVER_ENABLED`) and then performs several checks on the key attributes (key type, algorithm, family, and bits) to ensure compatibility with p256-m's supported non-deterministic ECDSA on NIST P256. If all checks pass, it calls the `p256_transparent_sign_hash` function. The result is returned unless `PSA_ERROR_NOT_SUPPORTED` is received, in which case another driver/implementation is called.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-driver-example-and-guide.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\n#if defined (MBEDTLS_PSA_P256M_DRIVER_ENABLED)\n            if( PSA_KEY_TYPE_IS_ECC( psa_get_key_type(attributes) ) &&\n                PSA_ALG_IS_ECDSA(alg) &&\n                !PSA_ALG_ECDSA_IS_DETERMINISTIC( alg ) &&\n                PSA_KEY_TYPE_ECC_GET_FAMILY(psa_get_key_type(attributes)) == PSA_ECC_FAMILY_SECP_R1 &&\n                psa_get_key_bits(attributes) == 256 )\n            {\n                status = p256_transparent_sign_hash( attributes,\n                                                     key_buffer,\n                                                     key_buffer_size,\n                                                     alg,\n                                                     hash,\n                                                     hash_length,\n                                                     signature,\n                                                     signature_size,\n                                                     signature_length );\n                if( status != PSA_ERROR_NOT_SUPPORTED )\n                return( status );\n            }\n#endif /* MBEDTLS_PSA_P256M_DRIVER_ENABLED */\n```\n\n----------------------------------------\n\nTITLE: Initialize IoT Hub Client C\nDESCRIPTION: This code snippet demonstrates how to initialize the IoT Hub client using the `az_iot_hub_client_init()` API. It also retrieves the MQTT client ID and username for establishing a connection with IoT Hub. It requires the `az_iot_hub_client` struct and hostname/device ID spans.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n// FOR SIMPLICITY THIS DOES NOT HAVE ERROR CHECKING. IN PRODUCTION ENSURE PROPER ERROR CHECKING.\n\naz_iot_hub_client my_client;\nstatic az_span my_iothub_hostname = AZ_SPAN_LITERAL_FROM_STR(\"contoso.azure-devices.net\");\nstatic az_span my_device_id = AZ_SPAN_LITERAL_FROM_STR(\"contoso_device\");\n\n// Make sure to size the buffer to fit the client id (16 is an example)\nstatic char my_mqtt_client_id[16];\nstatic size_t my_mqtt_client_id_length;\n\n// Make sure to size the buffer to fit the username (128 is an example)\nstatic char my_mqtt_user_name[128];\nstatic size_t my_mqtt_user_name_length;\n\nint main(void)\n{\n  // Get the default IoT Hub options.\n  az_iot_hub_client_options options = az_iot_hub_client_options_default();\n\n  // Initialize the hub client with hostname, device id, and default connection options.\n  az_iot_hub_client_init(&my_client, my_iothub_hostname, my_device_id, &options);\n\n  // Get the MQTT client id used for the MQTT connection.\n  az_iot_hub_client_get_client_id(\n      &my_client, my_mqtt_client_id, sizeof(my_mqtt_client_id),  &my_mqtt_client_id_length);\n\n  // Get the MQTT user name to connect.\n  az_iot_hub_client_get_user_name(\n      &my_client, my_mqtt_user_name, sizeof(my_mqtt_user_name), &my_mqtt_user_name_length);\n\n  // At this point you are free to use my_mqtt_client_id and my_mqtt_user_name to connect using\n  // your MQTT client.\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Respond to IoT Hub Command Message in C\nDESCRIPTION: This function sends a response to an IoT Hub command message. It requires a hub client pointer, status code, context information, payload, and a wait option to control the sending timeout. The payload should be a JSON formatted string.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_30\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_command_message_response(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                      UINT status_code, VOID *context_ptr,\n                                                      USHORT context_length, const UCHAR *payload_ptr,\n                                                      UINT payload_length, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Handling Early Data Reception with Mbed TLS\nDESCRIPTION: This code snippet demonstrates how to handle early data reception during a TLS 1.3 handshake. It adapts a standard TLS handshake loop to check for MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA. If early data is received, it's read using mbedtls_ssl_read_early_data(). The data is read into the 'buffer' array, up to its maximum size. The `data_read_len` variable keeps track of the total amount of early data received.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/tls13-early-data.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nsize_t data_read_len = 0;\nwhile ((ret = mbedtls_ssl_handshake(&ssl)) != 0) {\n\n    if (ret == MBEDTLS_ERR_SSL_RECEIVED_EARLY_DATA) {\n        ret = mbedtls_ssl_read_early_data(&ssl,\n                                          buffer + data_read_len,\n                                          sizeof(buffer) - data_read_len);\n        if (ret < 0) {\n            break;\n        }\n        data_read_len += ret;\n        continue;\n    }\n\n    if (ret < 0 &&\n        ret != MBEDTLS_ERR_SSL_WANT_READ &&\n        ret != MBEDTLS_ERR_SSL_WANT_WRITE) {\n        break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enable/Disable Testing\nDESCRIPTION: Enables or disables testing based on the compiler. Testing is disabled for MSVC due to compile errors. For other compilers, testing is enabled by default.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_COMPILER_IS_MSVC)\n    option(ENABLE_TESTING \"Build Mbed TLS tests.\" OFF)\nelse()\n    option(ENABLE_TESTING \"Build Mbed TLS tests.\" ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Enabling Mocked Function Tests with CMake\nDESCRIPTION: These commands are used to enable and build tests that use mocked functions for unit testing within the Azure SDK for Embedded C project.  This is particularly useful for testing PAL (Platform Abstraction Layer) related functions. GCC or a compatible compiler supporting the -ld linker flag is required.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ncmake -DUNIT_TESTING=ON -DUNIT_TESTING_MOCKS=ON ..\n```\n\n----------------------------------------\n\nTITLE: Key Agreement Driver Entry Points Prototype in C\nDESCRIPTION: Defines the function prototypes for the `key_agreement` and `key_agreement_to_key` entry points in a PSA cryptography driver. These functions are responsible for performing key agreement operations, either directly or by creating a shared secret key object. The `acme_key_agreement` function outputs the shared secret directly, while `acme_key_agreement_to_key` creates a key object.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_key_agreement(psa_algorithm_t alg,\n                                const psa_key_attributes_t *our_attributes,\n                                const uint8_t *our_key_buffer,\n                                size_t our_key_buffer_length,\n                                const uint8_t *peer_key,\n                                size_t peer_key_length,\n                                uint8_t *output,\n                                size_t output_size,\n                                size_t *output_length);\npsa_status_t acme_key_agreement_to_key(psa_algorithm_t alg,\n                                       const psa_key_attributes_t *our_attributes,\n                                       const uint8_t *our_key_buffer,\n                                       size_t our_key_buffer_length,\n                                       const uint8_t *peer_key,\n                                       size_t peer_key_length,\n                                       const psa_key_attributes_t *shared_secret_attributes,\n                                       uint8_t *shared_secret_key_buffer,\n                                       size_t shared_secret_key_buffer_size,\n                                       size_t *shared_secret_key_buffer_length);\n```\n\n----------------------------------------\n\nTITLE: Initializing PSA with Mutex\nDESCRIPTION: The code uses a mutex, `mbedtls_threading_psa_globaldata_mutex`, defined in `include/mbedtls/threading.h`, to ensure thread-safe initialization of the PSA crypto subsystem via the `psa_crypto_init` function.  This prevents race conditions during the initialization process when multiple threads attempt to initialize the PSA crypto system simultaneously. This protects the `psa_global_data_t` struct in `library/psa_crypto.c`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-thread-safety/psa-thread-safety.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nmbedtls_threading_psa_globaldata_mutex\n```\n\n----------------------------------------\n\nTITLE: Disconnecting from Azure IoT Hub (C)\nDESCRIPTION: This function disconnects the Azure IoT Hub client from the Azure IoT Hub.  It requires a pointer to the IoT Hub client instance.  A successful operation disconnects the client; otherwise, it fails due to an invalid parameter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_disconnect(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Custom X.509 Profile Configuration in Mbed TLS\nDESCRIPTION: This code snippet demonstrates how to create a custom X.509 verification profile in Mbed TLS to allow specific hash algorithms, such as SHA-224, that are no longer enabled by default.  It initializes a profile based on the default and then modifies the allowed_mds field to include the SHA-224 hash algorithm. The modified profile can then be passed to the mbedtls_x509_crt_verify_with_profile function for certificate verification.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/3.0-migration-guide.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nmbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_default;\nmy_profile.allowed_mds |= MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA224 );\n```\n\n----------------------------------------\n\nTITLE: Set Telemetry Component - Azure IoT Hub Client (C)\nDESCRIPTION: Sets a component name for a telemetry message before sending. The component is stored in the order it's set.  This should be called after creating the telemetry packet and before sending.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_telemetry_component_set(NX_PACKET *packet_ptr,\n                                                     const UCHAR *component_name_ptr,\n                                                     USHORT component_name_length,\n                                                     UINT wait_option));\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration for ThreadX Heap\nDESCRIPTION: This snippet illustrates how to configure the linker file in STM32CubeIDE for ThreadX dynamic memory allocation. It defines a new section named ._threadx_heap within the linker script.  This section provides a dedicated memory area for ThreadX's heap, ensuring that ThreadX can dynamically allocate memory as needed.  The example sets the heap size to 64KB and specifies its location within the RAM_D1 region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_HID_CDC_ACM/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Adding Compile Options\nDESCRIPTION: Adds compiler options that apply to the entire project.  These options include architecture settings, C standard, debugging information, and preprocessor definitions for ThreadX SMP configurations.  Also includes the build type specific compile definitions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_compile_options(\n  -m32\n  -std=c99\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  # -Werror\n  -DTX_THREAD_SMP_ONLY_CORE_0_DEFAULT\n  -DTX_SMP_NOT_POSSIBLE\n  -DTX_REGRESSION_TEST\n  -DTEST_STACK_SIZE_PRINTF=4096\n  ${${CMAKE_BUILD_TYPE}})\n```\n\n----------------------------------------\n\nTITLE: Defining TX_LOW_POWER_USER_ENTER Macro in C\nDESCRIPTION: This example demonstrates how to define the TX_LOW_POWER_USER_ENTER macro. This macro invokes the user-defined `low_power_enter` function, which contains the processor-specific code to prepare the system for entering a low power state (e.g., turning off peripherals).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/low_power/low_power.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n/* Low power enter function prototype. */\nvoid low_power_enter(void);\n\n/* Define the TX_LOW_POWER_USER_ENTER macro. */\n#define TX_LOW_POWER_USER_ENTER low_power_enter\n\nvoid low_power_enter(void)\n{\n    /* Insert code here to configure the processor to enter low power mode. */\n}\n```\n\n----------------------------------------\n\nTITLE: Send Reported Properties Message - C\nDESCRIPTION: This function sends a reported properties message to Azure IoT Hub. It takes a pointer to the NX_AZURE_IOT_HUB_CLIENT, a pointer to the NX_PACKET containing the properties, pointers to store the request ID, response status, version, and a timeout value.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_41\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_reported_properties_send(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                      NX_PACKET *packet_ptr,\n                                                      UINT *request_id_ptr, UINT *response_status_ptr,\n                                                      ULONG *version_ptr, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories\nDESCRIPTION: Sets the include directories for the `az_core` library. The `PUBLIC` keyword ensures that these include directories are also available to dependent projects. Uses generator expressions to specify different include paths for build and install interfaces.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/core/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories (az_core\n  PUBLIC\n  $<BUILD_INTERFACE:${az_SOURCE_DIR}/sdk/inc>\n  $<INSTALL_INTERFACE:include/az_core>\n)\n```\n\n----------------------------------------\n\nTITLE: Defining NetX Duo Test Cases in CMake\nDESCRIPTION: This snippet defines a list of source files for core NetX Duo test cases using CMake's `set` command. These tests likely cover a wide array of NetX Duo features, including ICMP, ARP, TCP, UDP, and IPv6 functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nset(netxduo_test_cases\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_mtu_option_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_branch_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_forward_icmp_small_header_test2.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_receive_under_interface_detach_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_8_29_02_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_new_reno_algorithm_test4.c\n    ${SOURCE_DIR}/netxduo_test/netx_15_26_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_udp_ipv6_interface2_test_1_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_15_24_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_12_31_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_small_window_preempt_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_conflict_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_4_29_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_packet_suspension_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_udp_tunnel_ipv4_ipv6_basic_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmp_ping_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmp_interface2_ping6_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_nxe_api_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_8_02_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_prefix_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_11_26_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_socket_unaccept_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_6_28_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_9_21_01_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_10_23_01_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_6_29_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_11_27_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_6_22_02_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_fragmentation_packet_delay_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_dropped_packet_test2.c\n    ${SOURCE_DIR}/netxduo_test/netx_10_26_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_8_19_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_igmp_leave_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_igmp_basic_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_14_19_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_address_delete_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_2_20_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_no_duplicate_entry_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_raw_loopback_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_multiple_send_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_102_22_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_forward_icmp_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_ack_check_for_syn_message_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_raw_packet_filter_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_max_payload_size_find_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_3_06_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_1_21_01_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_fragmentation_error_test2.c\n    ${SOURCE_DIR}/netxduo_test/netx_udp_packet_type_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_raw_special_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_1_17_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_raw_packet_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_forward_udp_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_api_compile_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_branch_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmp_cleanup_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_window_update_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_11_28_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_auto_entry_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_client_socket_unbind_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_10_24_01_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_branch_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_malformed_packet_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_idle_scan_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_multiple_send_test2.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_fast_disconnect_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_keepalive_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_abnormal_mtu_in_ra_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmp_multiple_ping_test1.c\n    ${SOURCE_DIR}/netxduo_test/netx_old_api_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_udp_loopback_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_fragmentation_time_exceeded_message_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_forward_icmp_small_header_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_3_23_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_invalid_ra_dest_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_retransmit_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_basic_processing_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_3_21_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_basic_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_client_socket_port_get_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_interface_capability_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_23_02_02_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_data_trim_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_4_26_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_udp_nxe_api_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_14_20_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_interface_detachment_tcp_connection_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_interface_address_get_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmp_invalid_echo_reply_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_10_24_03_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_packet_branch_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_urgent_packet_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_transmit_cleanup_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_dynamic_entry_fail_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_na_tlla_changed_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_nxe_api_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_socket_listen_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_disable_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmp_multiple_ping6_test1.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_address_get_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_10_24_02_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_default_router_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_106_17_test.c)\n```\n\n----------------------------------------\n\nTITLE: Beginning Reported Properties Status with Confirmation Status (C)\nDESCRIPTION: This routine begins a property response payload with a confirmation status. It is used in response to an incoming writable property, allowing the device to report the status, version, and description of the property update.  It prepares the JSON structure for adding the property value.  Dependencies include NX_AZURE_IOT_HUB_CLIENT and NX_AZURE_IOT_JSON_WRITER. This function should be followed by `nx_azure_iot_hub_client_reported_properties_status_end()`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client_properties.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_reported_properties_status_begin(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                              NX_AZURE_IOT_JSON_WRITER *writer_ptr,\n                                                              const UCHAR *property_name_ptr,  \n                                                              UINT property_name_length,\n                                                              UINT status_code, \n                                                              ULONG version,\n                                                              const UCHAR *description_ptr, \n                                                              UINT description_length);\n```\n\nLANGUAGE: c\nCODE:\n```\n//{\n//  \\\"<property_name>\\\":{\n//    \\\"ac\\\": <status_code>,\n//    \\\"av\\\": <version>,\n//    \\\"ad\\\": \\\"<description>\\\",\n//    \\\"value\\\": <user_value>\n//  }\n//}\n```\n\nLANGUAGE: c\nCODE:\n```\nnx_azure_iot_hub_client_reported_properties_component_begin()\nnx_azure_iot_hub_client_reported_properties_status_begin()\n// Append user value here (<user_value>)\nnx_azure_iot_hub_client_reported_properties_status_end()\nnx_azure_iot_hub_client_reported_properties_component_end()\n```\n\nLANGUAGE: c\nCODE:\n```\n//{\n//  \\\"<component_name>\\\": {\n//    \\\"__t\\\": \\\"c\\\",\n//    \\\"<property_name>\\\": {\n//      \\\"ac\\\": <status_code>,\n//      \\\"av\\\": <version>,\n//      \\\"ad\\\": \\\"<description>\\\",\n//      \\\"value\\\": <user_value>\n//    }\n//  }\n//}\n```\n\nLANGUAGE: c\nCODE:\n```\nnx_azure_iot_hub_client_reported_properties_status_end()\n```\n\n----------------------------------------\n\nTITLE: Linker Configuration for STM32CubeIDE\nDESCRIPTION: This code shows the linker configuration for STM32CubeIDE to allocate a heap for ThreadX. It creates a new section called `._threadx_heap` within the `RAM_D1` region and sets its size to 64KB. The `tx_initialize_low_level.S` file also needs to be modified to enable dynamic memory allocation by setting the `USE_DYNAMIC_MEMORY_ALLOCATION` flag.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/NetXDuo/Nx_SNTP_Client/README.md#_snippet_3\n\nLANGUAGE: Other\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: C ISR Example for ThreadX on Cortex-M23\nDESCRIPTION: This C code demonstrates a basic Interrupt Service Routine (ISR) that can be used with ThreadX on the Cortex-M23 architecture using the GNU toolchain. The ISR, `your_C_isr`, is declared as a void function and contains the interrupt processing logic. This ISR can access the ThreadX API that is available to ISRs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m23/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Setting TLS Cipher Suites in Paho MQTT C\nDESCRIPTION: This C code snippet demonstrates how to modify the Paho MQTT for C samples to configure the TLS stack for Azure Cloud ECC server certificate chain. It restricts the allowed cipher suites to prevent RSA cipher suites from being advertised by setting `enabledCipherSuites` to \"ECDH+ECDSA+HIGH\". This ensures compatibility with Azure's ECC server certificates.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_28\n\nLANGUAGE: C\nCODE:\n```\nmqtt_ssl_options.enabledCipherSuites = \"ECDH+ECDSA+HIGH\";\n```\n\n----------------------------------------\n\nTITLE: Creating test executables and tests\nDESCRIPTION: This snippet iterates through the `regression_test_cases` list, creates an executable for each test case, links the executable with the `test_utility` library, and adds a CTest test for each executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/regression/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(test_case ${regression_test_cases})\n  get_filename_component(test_name ${test_case} NAME_WE)\n  add_executable(${test_name} ${test_case})\n  target_link_libraries(${test_name} PRIVATE test_utility)\n  add_test(${CMAKE_BUILD_TYPE}::${test_name} ${test_name})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Defining TX_LOW_POWER_USER_TIMER_ADJUST Macro in C\nDESCRIPTION: This example illustrates how to define the TX_LOW_POWER_USER_TIMER_ADJUST macro. This macro invokes the user-defined function `low_power_timer_adjust`, which determines the actual amount of time elapsed during low power mode in ThreadX ticks.  The `actual_ticks_slept` value is returned to adjust the ThreadX timers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/low_power/low_power.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n/* Low power timer adjust function prototype. */\nULONG low_power_timer_adjust(void);\n\n/* Define the TX_LOW_POWER_USER_TIMER_ADJUST macro. */\n#define TX_LOW_POWER_USER_TIMER_ADJUST low_power_timer_adjust\n\nULONG low_power_timer_adjust(void)\n{\n    ULONG actual_ticks_slept;\n    ULONG elapsed_time_in_ms;\n\n    /* Insert code here to read timer registers to determine\n       how long the processor actually slept. */\n    elapsed_time_in_ms = read_timer_register();\n\n    /* Convert elapsed time to ThreadX ticks. */\n    actual_ticks_slept = elapsed_time_in_ms / (1000/TX_TIMER_TICKS_PER_SECOND);\n\n    return(actual_ticks_slept);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding an executable for dlopen (CMake)\nDESCRIPTION: Adds an executable named `dlopen` if `USE_SHARED_MBEDTLS_LIBRARY` is enabled and the system is not Windows.  It includes the necessary include directories and links against the dynamic library loader.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(USE_SHARED_MBEDTLS_LIBRARY AND\n   NOT ${CMAKE_SYSTEM_NAME} MATCHES \"[Ww][Ii][Nn]\")\n    add_executable(dlopen \"dlopen.c\")\n    target_include_directories(dlopen PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../include)\n    target_link_libraries(dlopen ${CMAKE_DL_LIBS})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Importing ECC Public Key from mbedtls_ecp_point in C\nDESCRIPTION: This code snippet illustrates how to import an ECC public key, starting with an `mbedtls_ecp_point` object.  The process involves initializing an elliptic curve group, writing the point to a binary buffer, setting PSA key attributes to indicate a public key, and then importing it using `psa_import_key`. The specific elliptic curve (`curve`) needs to be manually determined. Error checks are omitted.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_20\n\nLANGUAGE: C\nCODE:\n```\nmbedtls_ecp_group grp;\nmbedtls_ecp_group_init(&grp);\nmbedtls_ecp_group_load(&grp, MBEDTLS_ECP_DP_...);\nmbedtls_ecp_point pt;\nmbedtls_ecp_point_init(&pt);\n// Omitted: fill pt with key material\nunsigned char buf[PSA_BITS_TO_BYTES(PSA_VENDOR_ECC_PUBLIC_KEY_MAX_SIZE)];\nsize_t length;\nmbedtls_ecp_point_write_binary(&grp, &pt, &length, buf, sizeof(buf));\npsa_ecc_curve_t curve = ...; // need to determine the curve family manually\npsa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;\npsa_set_key_attributes(&attributes, PSA_KEY_TYPE_ECC_PUBLIC_KEY(curve));\npsa_set_key_usage_flags(&attributes, PSA_KEY_USAGE_... | ...);\npsa_set_key_algorithm(&attributes, PSA_ALGORITHM_...);\npsa_key_id_t key_id = 0;\npsa_import_key(&attributes, buf, length, &key_id);\nmbedtls_ecp_point_free(&pt);\nmbedtls_ecp_group_free(&grp);\n```\n\n----------------------------------------\n\nTITLE: Vectored IRQ Handler in Assembly\nDESCRIPTION: This assembly code provides an example of a vectored IRQ handler (__tx_irq_example_handler) in tx_initialize_low_level.S. It saves scratch registers, picks up the saved SPSR, adjusts the point of interrupt, stores other scratch registers, calls the vectored IRQ context save function (_tx_thread_vectored_context_save), and finally jumps to the context restore routine (_tx_thread_context_restore).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac6/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n    .global __tx_irq_example_handler\n__tx_irq_example_handler:\n@\n@    /* Call context save to save system context.  */\n\n    STMDB   sp!, {r0-r3}                        @ Save some scratch registers\n    MRS     r0, SPSR                            @ Pickup saved SPSR\n    SUB     lr, lr, #4                          @ Adjust point of interrupt \n    STMDB   sp!, {r0, r10, r12, lr}             @ Store other scratch registers\n    BL      _tx_thread_vectored_context_save    @ Call the vectored IRQ context save\n@\n@    /* At this point execution is still in the IRQ mode. The CPSR, point of\n@       interrupt, and all C scratch registers are available for use. Note \n@       that IRQ interrupts are still disabled upon return from the context\n@       save function.  */\n@\n@    /* Application ISR call goes here!  */\n@\n@    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Project Definition and Build Configurations\nDESCRIPTION: Defines the CMake project name and sets up various build configurations (default, coverage, disable notify callbacks, stack checking, and tracing). It allows selecting a specific build type from the available configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(threadx_test LANGUAGES C)\n\n# Set build configurations\nset(BUILD_CONFIGURATIONS default_build_coverage disable_notify_callbacks_build\n                         stack_checking_build stack_checking_rand_fill_build trace_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: C ISR for ThreadX on Cortex-M23 with IAR\nDESCRIPTION: This snippet demonstrates the structure of an Interrupt Service Routine (ISR) written in C for use with ThreadX on a Cortex-M23 microcontroller using IAR tools. The ISR, named 'your_C_isr', can contain any necessary processing logic, including calls to ThreadX API functions that are available to ISRs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m23/iar/readme_threadx.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Standard IRQ Handler in Assembly\nDESCRIPTION: This is the default IRQ handler defined in tx_initialize_low_level.S. It saves the system context by jumping to _tx_thread_context_save, then restores the context by jumping to _tx_thread_context_restore. Application-specific ISR calls should be placed between these two calls. This snippet is written in ARM assembly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/gnu/readme_threadx.txt#_snippet_3\n\nLANGUAGE: assembly\nCODE:\n```\n    .global __tx_irq_handler\n    .global __tx_irq_processing_return      \n__tx_irq_handler:\n@\n@    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save             @ Jump to the context save\n__tx_irq_processing_return:\n@\n@    /* At this point execution is still in the IRQ mode. The CPSR, point of\n@       interrupt, and all C scratch registers are available for use. Note \n@       that IRQ interrupts are still disabled upon return from the context\n@       save function.  */\n@\n@    /* Application ISR call(s) go here!  */\n@\n@    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Creating X.509 Certificate (Linux)\nDESCRIPTION: These commands create a self-signed X.509 certificate and key for device authentication. It generates an EC key, creates a certificate signing request, generates the certificate, combines the certificate and key into a single file, and extracts the SHA1 fingerprint. These certificates are for testing and MUST NOT be used in production.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nopenssl ecparam -out device_ec_key.pem -name prime256v1 -genkey\nopenssl req -new -days 30 -nodes -x509 -key device_ec_key.pem -out device_ec_cert.pem -extensions client_auth -config x509_config.cfg -subj \"/CN=paho-sample-device1\"\nopenssl x509 -noout -text -in device_ec_cert.pem\n\nrm -f device_cert_store.pem\ncat device_ec_cert.pem device_ec_key.pem > device_cert_store.pem\n\nopenssl x509 -noout -fingerprint -in device_ec_cert.pem | sed 's/://g'| sed 's/\\(SHA1 Fingerprint=\\)//g' | tee fingerprint.txt\n\nexport AZ_IOT_DEVICE_X509_CERT_PEM_FILE_PATH=$(pwd)/device_cert_store.pem\n```\n\n----------------------------------------\n\nTITLE: ECDSA signature capability with SHA and SECP curves (JSON)\nDESCRIPTION: This JSON snippet shows a capability declaration for a driver that can perform deterministic ECDSA signatures using SHA-256 or SHA-384 with SECP256R1 or SECP384R1 private keys. It specifies the `sign_hash` entry point, supported algorithms, key types (ECC key pair with SECP curves), and key sizes (256 and 384 bits).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"entry_points\": [\"sign_hash\"],\n    \"algorithms\": [\"PSA_ALG_DETERMINISTIC_ECDSA(PSA_ALG_SHA_256)\",\n                   \"PSA_ALG_DETERMINISTIC_ECDSA(PSA_ALG_SHA_384)\"],\n    \"key_types\": [\"PSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1)\"],\n    \"key_sizes\": [256, 384]\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Testing\nDESCRIPTION: Enables the use of CTest for running tests within the project.  This is essential for automated testing and verification.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nenable_testing()\n```\n\n----------------------------------------\n\nTITLE: Subscribing to MQTT Topics for Azure IoT Hub Client (C)\nDESCRIPTION: This code snippet demonstrates how to subscribe to a topic using an MQTT client. It uses a predefined constant `AZ_IOT_HUB_CLIENT_METHODS_SUBSCRIBE_TOPIC` as the topic filter and sets the QoS level to 1. The function `MQTTClient_subscribe` from an external MQTT client library is used to perform the subscription.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/mqtt_state_machine.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n// AZ_IOT_HUB_CLIENT_METHODS_SUBSCRIBE_TOPIC contains the methods topic filter.\nMQTTClient_subscribe(mqtt_client, AZ_IOT_HUB_CLIENT_METHODS_SUBSCRIBE_TOPIC, 1);\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR for ThreadX on Cortex-M23 with IAR\nDESCRIPTION: This code snippet illustrates the structure of an Interrupt Service Routine (ISR) written in assembly language for use with ThreadX on a Cortex-M23 microcontroller using IAR tools. The ISR, named 'your_assembly_isr', pushes the r0 and lr registers onto the stack, performs the ISR processing, and then restores the registers before returning.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m23/iar/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n    PUBLIC  your_assembly_isr\nyour_assembly_isr:\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, r1}\n    MOV     lr, r1\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Enabling WebSocket for Azure IoT Hub Client (C)\nDESCRIPTION: This function enables MQTT over WebSocket to connect to the Azure IoT Hub.  It requires a pointer to the IoT Hub client instance.  A successful operation enables MQTT over Websocket; otherwise, it fails due to an invalid parameter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_websocket_enable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Cloning and Installing VCPKG on Linux\nDESCRIPTION: This snippet clones the vcpkg repository, checks out a specific commit, and installs required packages (curl, cmocka, and paho-mqtt) using the vcpkg package manager for a Linux x64 target.  The vcpkg commit should be specified as indicated in the document.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\ngit checkout <vcpkg commit> # Checkout the vcpkg commit per vcpkg-commit.txt above.\n./bootstrap-vcpkg.sh\n./vcpkg install --triplet x64-linux curl cmocka paho-mqtt\n```\n\n----------------------------------------\n\nTITLE: Checking Key Consistency via Public Key Export - C\nDESCRIPTION: This code snippet demonstrates how to check the consistency between a private and public key using the PSA API by exporting both public keys and comparing them. It allocates buffers for the exported keys, exports the keys using `psa_export_public_key`, compares the lengths, and then the contents of the exported keys using `memcmp`. The code omits error checking for brevity.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_43\n\nLANGUAGE: C\nCODE:\n```\n// Error checking omitted\nunsigned char pub1[PSA_EXPORT_PUBLIC_KEY_MAX_SIZE];\nunsigned char pub2[PSA_EXPORT_PUBLIC_KEY_MAX_SIZE];\nsize_t length1, length2;\npsa_export_public_key(key1, pub1, sizeof(pub1), &length1);\npsa_export_public_key(key2, pub2, sizeof(pub2), &length2);\nif (length1 == length2 && !memcmp(pub1, pub2, length1))\n    puts(\"The keys match\");\nelse\n    puts(\"The keys do not match\");\n```\n\n----------------------------------------\n\nTITLE: Deinitializing Azure IoT Hub Client in C\nDESCRIPTION: This code snippet demonstrates how to deinitialize the Azure IoT Hub client using the `nx_azure_iot_hub_client_deinitialize` function. It takes a pointer to the Azure IoT Hub client instance as input.  The function returns a status code indicating success or failure, allowing for proper resource cleanup.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_deinitialize(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: ThreadX Managed Interrupt Template (Assembly)\nDESCRIPTION: This assembly code provides a template for managed Interrupt Service Routines (ISRs) in ThreadX.  By following these conventions, the application ISR is allowed access to various ThreadX services from the ISR. It's essential that the label `__tx_IntHandler` is properly placed within the interrupt vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/gnu/readme_threadx.txt#_snippet_3\n\nLANGUAGE: Assembly\nCODE:\n```\n        .global  __tx_IntHandler\n        .thumb_func\n__tx_IntHandler:\n; VOID InterruptHandler (VOID)\n; {\n        PUSH    {r0, lr}\n\n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n        POP     {r0, lr}\n        BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Delete Telemetry Message - Azure IoT Hub Client (C)\nDESCRIPTION: Deletes a telemetry message by releasing the allocated NX_PACKET. This function should be called after the telemetry message has been sent or is no longer needed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_telemetry_message_delete(NX_PACKET *packet_ptr);\n```\n\n----------------------------------------\n\nTITLE: Enabling IRQ Nested Interrupts in Handler (Assembly)\nDESCRIPTION: This assembly code snippet demonstrates how to enable nested IRQ interrupts within a standard IRQ handler in ThreadX. It involves saving the system context, enabling nested interrupts using `_tx_thread_irq_nesting_start`, calling the application's ISR, disabling nested interrupts using `_tx_thread_irq_nesting_end`, and restoring the system context. Prior to calling `_tx_thread_irq_nesting_start`, all IRQ interrupt sources must be cleared. The code uses branch instructions (`B` and `BL`) to jump to context saving/restoring routines and ThreadX services.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/gnu/readme_threadx.txt#_snippet_5\n\nLANGUAGE: assembly\nCODE:\n```\n    .global __tx_irq_handler\n    .global __tx_irq_processing_return      \n__tx_irq_handler:\n@\n@    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save\n__tx_irq_processing_return:\n@\n@    /* Enable nested IRQ interrupts. NOTE:  Since this service returns\n@       with IRQ interrupts enabled, all IRQ interrupt sources must be \n@       cleared prior to calling this service.  */\n    BL      _tx_thread_irq_nesting_start\n@    \n@    /* Application ISR call(s) go here!  */\n@\n@    /* Disable nested IRQ interrupts. The mode is switched back to\n@       IRQ mode and IRQ interrupts are disable upon return.  */\n    BL      _tx_thread_irq_nesting_end\n@\n@    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Finding Mbed TLS Package in CMake\nDESCRIPTION: This snippet uses the `find_package` command to locate the Mbed TLS package for use in another CMake project. It depends on Mbed TLS being installed and `MbedTLS_DIR` being correctly set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(MbedTLS)\n```\n\n----------------------------------------\n\nTITLE: Timer Task Priority Configuration in tx_user.h (C)\nDESCRIPTION: This configuration allows setting the priority of the ThreadX timer task. Setting the timer task priority to 0 is recommended for better emulation of FreeRTOS timer behavior. It is not necessary, but is recommended.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/FreeRTOS/readme.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n#define TX_TIMER_THREAD_PRIORITY 0\n```\n\n----------------------------------------\n\nTITLE: Random Number Generation Entry Point Prototype (get_random)\nDESCRIPTION: Defines the prototype for the `get_random` entry point in a PSA Cryptography driver. This function is responsible for generating cryptographic-quality random data. It takes a context, output buffer, output size, and an output length pointer as parameters. The function returns a PSA status code indicating success or failure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_36\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_get_random(acme_random_context_t *context,\n                             uint8_t *output,\n                             size_t output_size,\n                             size_t *output_length);\n```\n\n----------------------------------------\n\nTITLE: Add DSP Module Path\nDESCRIPTION: Appends the DSP directory to the CMake module path, allowing CMake to find modules within that directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fir_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration for ThreadX Heap\nDESCRIPTION: This snippet illustrates how to add a new section to the STM32CubeIDE linker script (.ld) to provide memory for the ThreadX heap. The example defines a ._threadx_heap section, allocating 64KB of memory in the RAM_D1 region, positioned between .bss and ._user_heap_stack sections.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Device_DFU/README.md#_snippet_2\n\nLANGUAGE: Other\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: IAR Thread-safe Library Configuration\nDESCRIPTION: Specifies the linker control file modification for enabling thread-safe support in the IAR library when using ThreadX. This line is added to the linker control file and instructs the linker to properly initialize per-thread data.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/iar/readme_threadx.txt#_snippet_2\n\nLANGUAGE: other\nCODE:\n```\ninitialize by copy with packing = none { section __DLIB_PERTHREAD }; // Required in a multi-threaded application\n```\n\n----------------------------------------\n\nTITLE: Convert DER to Hex Array (Shell)\nDESCRIPTION: These commands convert the DER-formatted certificate and private key files into C header files containing hex arrays. The arrays can then be included in the embedded application for X.509 authentication. This uses `xxd` and `sed` to format the output.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/samples/README.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\necho \"#include \\\"nx_api.h\\\"\\n/**\ndevice cert (`openssl x509 -in cert.pem -fingerprint -noout | sed 's/://g' `) :\\n`cat cert.pem`\\n\\ndevice private key :\\n`cat privkey.pem`\\n*/\\n\" > sample_device_identity.c\n\nxxd -i cert.der | sed -E \"s/(unsigned char) (\\w+)/\\1 sample_device_cert_ptr/g; s/(unsigned int) (\\w+)_len/\\1 sample_device_cert_len/g\" >> sample_device_identity.c\nxxd -i privkey.der | sed -E \"s/(unsigned char) (\\w+)/\\1 sample_device_private_key_ptr/g; s/(unsigned int) (\\w+)_len/\\1 sample_device_private_key_len/g\" >> sample_device_identity.c\n```\n\n----------------------------------------\n\nTITLE: Initializing Azure IoT Logging in C\nDESCRIPTION: This code snippet presents the `nx_azure_iot_log_init` function used to initialize logging for the Azure IoT subsystem. It requires a callback function `log_callback` that takes the log classification, a message, and the message length as input.  This function allows the user to customize the logging output for different classifications.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nVOID nx_azure_iot_log_init(VOID(*log_callback)(az_log_classification classification, UCHAR *msg, UINT msg_len));\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files in CMake\nDESCRIPTION: This snippet demonstrates how to add multiple source files to a CMake project using the `file(GLOB)` command. The source files are located in the `${CMAKE_CURRENT_LIST_DIR}/src/` directory and include various ThreadX timer and thread-related functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/common/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_time_slice_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_wait_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_timer_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_timer_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_timer_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_timer_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_timer_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_timer_info_get.c\n```\n\n----------------------------------------\n\nTITLE: Key Derivation Verify Key Function Prototype (PSA)\nDESCRIPTION: This code snippet defines the function prototype for a key derivation driver's verify key entry point. This function verifies a derived key against an expected key. It takes the derivation operation context, a buffer containing the key, and the key buffer size as parameters and returns a PSA status code indicating whether the key is valid.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_19\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_key_derivation_verify_key(\n    acme_key_derivation_operation_t *operation,\n    uint8_t *key_buffer, size_t key_buffer_size);\n```\n\n----------------------------------------\n\nTITLE: Add CMSIS-DSP Subdirectory\nDESCRIPTION: Adds the CMSIS-DSP source directory as a subdirectory to the build, making its contents available. It also creates a target named 'bin_dsp'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fir_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: MD Context Structure Definition\nDESCRIPTION: This C code defines the structure of `mbedtls_md_context_t` which encapsulates the necessary information for performing hash operations.  It includes the hash type, an engine indicator to select between legacy and PSA implementations, a pointer to the underlying hash context (either legacy or PSA), and a pointer to an HMAC context when HMAC is enabled. The engine field indicates which implementation (legacy or PSA) is in use. All fields are private.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-migration/md-cipher-dispatch.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nenum {\n    MBEDTLS_MD_ENGINE_LEGACY,\n    MBEDTLS_MD_ENGINE_PSA,\n} mbedtls_md_engine_t; // private type\n\ntypedef struct mbedtls_md_context_t {\n    mbedtls_md_type_t type;\n#if defined(MBEDTLS_MD_SOME_PSA)\n    mbedtls_md_engine_t engine;\n#endif\n    void *md_ctx; // mbedtls_xxx_context or psa_hash_operation\n#if defined(MBEDTLS_MD_C)\n    void *hmac_ctx;\n#endif\n} mbedtls_md_context_t;\n```\n\n----------------------------------------\n\nTITLE: Disabling Cloud-to-Device Message Receiving in C\nDESCRIPTION: This function disables the reception of cloud-to-device (C2D) messages from Azure IoT Hub. It requires a pointer to the IoT Hub client. After execution, the device will no longer receive C2D messages.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_20\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_cloud_message_disable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Creating X.509 Certificate (Windows)\nDESCRIPTION: These commands create a self-signed X.509 certificate and key for device authentication using PowerShell. It generates an EC key, creates a certificate signing request, generates the certificate, combines the certificate and key into a single file, and extracts the SHA1 fingerprint. These certificates are for testing and MUST NOT be used in production.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_9\n\nLANGUAGE: powershell\nCODE:\n```\nopenssl ecparam -out device_ec_key.pem -name prime256v1 -genkey\nopenssl req -new -days 30 -nodes -x509 -key device_ec_key.pem -out device_ec_cert.pem -extensions client_auth -config x509_config.cfg -subj \"/CN=paho-sample-device1\"\nopenssl x509 -noout -text -in device_ec_cert.pem\n\nGet-Content device_ec_cert.pem, device_ec_key.pem | Set-Content device_cert_store.pem\n\nopenssl x509 -noout -fingerprint -in device_ec_cert.pem | % {$_.replace(\":\", \"\")} | % {$_.replace(\"SHA1 Fingerprint=\", \"\")} | Tee-Object fingerprint.txt\n\n$env:AZ_IOT_DEVICE_X509_CERT_PEM_FILE_PATH=$(Resolve-Path device_cert_store.pem)\n```\n\n----------------------------------------\n\nTITLE: Append End Object Azure IoT JSON Writer C\nDESCRIPTION: Appends the end of the current JSON object ('}') to the payload. Requires a pointer to the JSON writer. Returns NX_AZURE_IOT_SUCCESS if the object end is appended successfully.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_29\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_end_object(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr);\n```\n\n----------------------------------------\n\nTITLE: JSON Example for Device Twin Configuration in Azure IoT Hub\nDESCRIPTION: This JSON snippet demonstrates how to add a 'device_count' property to the 'desired' section of the Device Twin in Azure IoT Hub. This allows the device to receive updates from the cloud regarding the desired state of the device, such as configuration settings or commands. This example sets the initial desired device count to 42.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_vxworks.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n \"properties\": {\n      \"desired\": {\n          \"device_count\": 42,\n      }\n  }\n```\n\n----------------------------------------\n\nTITLE: Request Complete Device Twin Properties in C\nDESCRIPTION: This function requests the complete device twin properties from the IoT Hub. It takes the hub client pointer and a wait option as input.  The wait option specifies the time to wait for the request to be sent.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_35\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_device_twin_properties_request(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                            UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Heap Configuration with configTOTAL_HEAP_SIZE in FreeRTOS\nDESCRIPTION: This configuration parameter defines the total memory size available for dynamic allocation of FreeRTOS kernel objects when using the adaptation layer. Setting `configTOTAL_HEAP_SIZE` to 0 disables dynamic allocation, affecting the creation of tasks, semaphores, and other kernel objects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/FreeRTOS/readme.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nconfigTOTAL_HEAP_SIZE\n```\n\n----------------------------------------\n\nTITLE: Vectored IRQ Handler in Assembly\nDESCRIPTION: This is an example IRQ handler for the vectored ARM IRQ mechanism defined in tx_initialize_low_level.S. It saves scratch registers and the SPSR, calls _tx_thread_vectored_context_save, and then restores the context with _tx_thread_context_restore. Application ISR calls go between context save and restore. This snippet is written in ARM assembly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/gnu/readme_threadx.txt#_snippet_4\n\nLANGUAGE: assembly\nCODE:\n```\n    .global __tx_irq_example_handler\n__tx_irq_example_handler:\n@\n@    /* Call context save to save system context.  */\n\n    STMDB   sp!, {r0-r3}                        @ Save some scratch registers\n    MRS     r0, SPSR                            @ Pickup saved SPSR\n    SUB     lr, lr, #4                          @ Adjust point of interrupt \n    STMDB   sp!, {r0, r10, r12, lr}             @ Store other scratch registers\n    BL      _tx_thread_vectored_context_save    @ Call the vectored IRQ context save\n@\n@    /* At this point execution is still in the IRQ mode. The CPSR, point of\n@       interrupt, and all C scratch registers are available for use. Note \n@       that IRQ interrupts are still disabled upon return from the context\n@       save function.  */\n@\n@    /* Application ISR call goes here!  */\n@\n@    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Sending a Message to a Queue with tm_queue_send in C\nDESCRIPTION: This function sends a message to a previously created queue. It takes the queue_id and a pointer to the message as input and returns TM_SUCCESS if successful. The message is expected to be 16 bytes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nint  tm_queue_send(int queue_id, unsigned long *message_ptr);\n```\n\n----------------------------------------\n\nTITLE: Configure Target Sources with CMake\nDESCRIPTION: This snippet configures the target sources for the project using CMake's `target_sources` command. It defines the sources as `PRIVATE`, meaning they are only used internally by the library/executable being built and are not exposed to other targets that link against it. The source file list is expected to be populated between the BEGIN_TARGET_SOURCES and END_TARGET_SOURCES comments.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m55/ac6/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Initialize ThreadX CMake Project\nDESCRIPTION: Sets the minimum CMake version, defines the project name and supported languages (C and ASM), and checks for required variables THREADX_ARCH and THREADX_TOOLCHAIN. If these variables are not defined, the script will throw a fatal error.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\n\n# Set up the project\nproject(threadx\n    LANGUAGES C ASM\n)\n\nif(NOT DEFINED THREADX_ARCH)\n    message(FATAL_ERROR \"Error: THREADX_ARCH not defined\")\nendif()\nif(NOT DEFINED THREADX_TOOLCHAIN)\n    message(FATAL_ERROR \"Error: THREADX_TOOLCHAIN not defined\")\nendif()\nmessage(STATUS \"THREADX_ARCH: ${THREADX_ARCH}\")\nmessage(STATUS \"THREADX_TOOLCHAIN: ${THREADX_TOOLCHAIN}\")\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Modification for ThreadX Heap\nDESCRIPTION: This snippet illustrates the linker modification for STM32CubeIDE to define a new section `.threadx_heap` for ThreadX.  It aligns the section, defines the end of RAM segment, allocates 64KB for the heap, and specifies the RAM region. Requires modifying `tx_initialize_low_level.S` to enable the dynamic memory allocation flag.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ThreadX/Tx_MPU/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Create Reported Properties Message - C\nDESCRIPTION: This function creates an IoT Hub reported properties message. It needs a pointer to the NX_AZURE_IOT_HUB_CLIENT, a pointer to an NX_PACKET to store the created message, and a timeout value. The function allocates a packet which has to be sent to the IotHub.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_40\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_reported_properties_create(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                        NX_PACKET **packet_pptr,\n                                                        UINT wait_option)\n```\n\n----------------------------------------\n\nTITLE: C ISR Definition for Cortex-M55 with IAR\nDESCRIPTION: This code snippet demonstrates how to define an Interrupt Service Routine (ISR) in C for the Cortex-M architecture using the IAR toolchain. The ISR is a standard C function that can directly access the ThreadX API. No explicit context switching calls are required.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/iar/readme_threadx.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Operations for Interruptible Operations in PSA\nDESCRIPTION: Sets the maximum number of basic operations allowed per call to `psa_sign_hash_complete` or `psa_verify_hash_complete` using `psa_interruptible_set_max_ops`.  This controls how much computation is performed before returning, allowing for better responsiveness in constrained environments.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_36\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t status = psa_interruptible_set_max_ops(max_ops);\n```\n\n----------------------------------------\n\nTITLE: Enabling Command Message Receiving - C\nDESCRIPTION: This function enables receiving command messages from IoT Hub. It takes a pointer to a `NX_AZURE_IOT_HUB_CLIENT` instance as input and returns a status code indicating success or failure. Failures can occur due to invalid parameters, MQTT connection issues, packet pool exhaustion, or communication errors.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_27\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_command_enable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This CMake code block adds assembly source files to the specified target (${PROJECT_NAME}). These assembly files implement essential RTOS functionalities such as thread context switching, interrupt control, thread scheduling, and timer interrupts. The PRIVATE keyword indicates that these sources are only used for building the target and are not exposed to other projects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Building Executables Loop\nDESCRIPTION: This loop iterates through the list of executables and defines the build process for each. It adds executable targets, links libraries, sets include directories, and handles dependencies based on conditional checks for specific executables and the `GEN_FILES` flag.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/ssl/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(exe IN LISTS executables)\n    set(extra_sources \"\")\n    if(exe STREQUAL \"ssl_client2\" OR exe STREQUAL \"ssl_server2\")\n        list(APPEND extra_sources\n            ssl_test_lib.c\n            ${CMAKE_CURRENT_SOURCE_DIR}/../test/query_config.h\n            ${CMAKE_CURRENT_BINARY_DIR}/../test/query_config.c)\n    endif()\n    add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>\n        ${extra_sources})\n    target_link_libraries(${exe} ${libs} ${CMAKE_THREAD_LIBS_INIT})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\n    if(exe STREQUAL \"ssl_client2\" OR exe STREQUAL \"ssl_server2\")\n        if(GEN_FILES)\n            add_dependencies(${exe} generate_query_config_c)\n        endif()\n        target_include_directories(${exe}\n            PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../test)\n    endif()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Installing vcpkg and Paho MQTT C client\nDESCRIPTION: This snippet installs Microsoft's vcpkg package manager and the Eclipse Paho MQTT C client.  The commands clone the vcpkg repository, checkout to a specific commit, bootstrap vcpkg, and install required libraries (curl, cmocka, paho-mqtt) using vcpkg. This installation is crucial for managing dependencies for the Azure SDK for Embedded C samples.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd ~ # Run this command from any directory to go to your user home directory.\n~$ sudo git clone https://github.com/Microsoft/vcpkg.git\n~$ cd vcpkg\n~/vcpkg git checkout <vcpkg commit> # Checkout the vcpkg commit per vcpkg-commit.txt above.\n~/vcpkg$ sudo ./bootstrap-vcpkg.sh\n~/vcpkg$ sudo ./vcpkg install --triplet x64-linux curl cmocka paho-mqtt\n~/vcpkg$ cd ..\n```\n\n----------------------------------------\n\nTITLE: Stopping Azure IoT ADU Agent in C\nDESCRIPTION: This code snippet shows the prototype for stopping the Azure IoT ADU agent. The function simply takes a pointer to the ADU agent. Stopping the agent releases associated resources and halts update processing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_adu_agent.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_adu_agent_stop(NX_AZURE_IOT_ADU_AGENT *adu_agent_ptr);\n```\n\n----------------------------------------\n\nTITLE: Getting the Property Version (C)\nDESCRIPTION: This routine retrieves the version of a property from a JSON payload. It extracts the version information from the properties document. Dependencies include NX_AZURE_IOT_HUB_CLIENT and NX_AZURE_IOT_JSON_READER. The `message_type` parameter should be set to either `NX_AZURE_IOT_HUB_PROPERTIES` or `NX_AZURE_IOT_HUB_WRITABLE_PROPERTIES`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client_properties.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_properties_version_get(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                    NX_AZURE_IOT_JSON_READER *reader_ptr,\n                                                    UINT message_type, ULONG *version_ptr);\n```\n\n----------------------------------------\n\nTITLE: IAR Thread-safe Library Initialization\nDESCRIPTION: This snippet demonstrates how to configure the IAR linker control file to enable thread-safe library support for ThreadX. The 'initialize by copy' directive ensures that the `__DLIB_PERTHREAD` section, which contains thread-specific data, is properly initialized in a multi-threaded application.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/iar/readme_threadx.txt#_snippet_2\n\nLANGUAGE: linker control file\nCODE:\n```\ninitialize by copy with packing = none { section __DLIB_PERTHREAD }; // Required in a multi-threaded application\n```\n\n----------------------------------------\n\nTITLE: Creating a test utility library\nDESCRIPTION: This snippet creates a library named 'test_utility' using a set of TLS test utility files. It then links this library to the azrtos::netxduo library and sets the include directories.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt_interoperability/regression/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(\n  UTILITY_SOURCE_DIR\n  ${CMAKE_CURRENT_LIST_DIR}/../../../regression/interoperability_test/test_frame\n  ABSOLUTE)\nadd_library(\n  test_utility\n  ${UTILITY_SOURCE_DIR}/tls_test_get_external_test_process_output.c\n  ${UTILITY_SOURCE_DIR}/tls_test_launch_external_test_process.c\n  ${UTILITY_SOURCE_DIR}/tls_test_launch_external_test_process_in_background.c\n  ${UTILITY_SOURCE_DIR}/tls_test_director_clean_all.c\n  ${UTILITY_SOURCE_DIR}/tls_test_director_cleanup_registered_instances.c\n  ${UTILITY_SOURCE_DIR}/tls_test_director_create.c\n  ${UTILITY_SOURCE_DIR}/tls_test_director_destroy.c\n  ${UTILITY_SOURCE_DIR}/tls_test_director_register_test_instance.c\n  ${UTILITY_SOURCE_DIR}/tls_test_director_test_start.c\n  ${UTILITY_SOURCE_DIR}/tls_test_instance_attributes_access.c\n  ${UTILITY_SOURCE_DIR}/tls_test_instance_append.c\n  ${UTILITY_SOURCE_DIR}/tls_test_instance_create.c\n  ${UTILITY_SOURCE_DIR}/tls_test_instance_destroy.c\n  ${UTILITY_SOURCE_DIR}/tls_test_instance_find_next.c\n  ${UTILITY_SOURCE_DIR}/tls_test_instance_set_exit_status.c\n  ${UTILITY_SOURCE_DIR}/tls_test_instance_shared_buffer_manipulate.c\n  ${UTILITY_SOURCE_DIR}/tls_test_kill_external_test_process.c\n  ${UTILITY_SOURCE_DIR}/tls_test_semaphore_create.c\n  ${UTILITY_SOURCE_DIR}/tls_test_semaphore_destroy.c\n  ${UTILITY_SOURCE_DIR}/tls_test_semaphore_post.c\n  ${UTILITY_SOURCE_DIR}/tls_test_semaphore_wait.c\n  ${UTILITY_SOURCE_DIR}/tls_test_wait_all_child_process.c\n  ${UTILITY_SOURCE_DIR}/tls_test_wait_external_test_process.c\n  ${UTILITY_SOURCE_DIR}/tls_test_uninterruptable_wait.c)\ntarget_link_libraries(test_utility PUBLIC azrtos::netxduo)\ntarget_include_directories(test_utility PUBLIC ${UTILITY_SOURCE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Adding USB Device Class Sources with CMake\nDESCRIPTION: This snippet demonstrates how to add source files related to various USB device classes (Printer, RNDIS, Storage, and Video) to a CMake project. It iterates through a list of files defined by `${CMAKE_CURRENT_LIST_DIR}` to compile the necessary components for the USB device functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_device_classes/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_ioctl.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_read_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_soft_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_printer_write_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_bulkin_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_bulkout_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_interrupt_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_msg_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_msg_keep_alive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_msg_query.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_msg_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_msg_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_rndis_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_csw_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_format.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_get_configuration.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_get_performance.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_get_status_notification.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_inquiry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_mode_select.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_mode_sense.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_prevent_allow_media_removal.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_read_capacity.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_read_disk_information.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_read_dvd_structure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_read_format_capacity.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_read_toc.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_report_key.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_request_sense.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_start_stop.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_synchronize_cache.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_test_ready.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_verify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_storage_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_ioctl.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_max_payload_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_read_payload_free.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_read_payload_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_read_task_function.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_read_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_reception_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_stream_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_transmission_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_write_payload_commit.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_write_payload_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_write_task_function.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_video_write_thread_entry.\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion - Cosine Functions\nDESCRIPTION: Conditionally includes source files for cosine functions based on configuration flags. It checks if `CONFIGTABLE` is false, `ALLFAST` is true, or a specific data type's cosine function (e.g., `ARM_COS_F32`) is enabled.  This allows for selectively including optimized or alternative implementations based on the build configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_COS_F32)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_cos_f32.c)\nendif()\n\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_COS_Q15)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_cos_q15.c)\nendif()\n\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_COS_Q31)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_cos_q31.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Include Directories with CMake\nDESCRIPTION: This CMake code snippet configures the include directories for the project. It defines a public include directory using the `target_include_directories` command, which makes the header files in the specified directory available to other targets that depend on this project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m0/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Define Build Options\nDESCRIPTION: Defines various build options related to NEON and Helium acceleration, loop unrolling, rounding, matrix checks, and disabling float16 kernels.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\noption(NEON \"Neon acceleration\" OFF)\noption(NEONEXPERIMENTAL \"Neon experimental acceleration\" OFF)\noption(HELIUMEXPERIMENTAL \"Helium experimental acceleration\" OFF)\noption(LOOPUNROLL \"Loop unrolling\" ON)\noption(ROUNDING \"Rounding\" OFF)\noption(MATRIXCHECK \"Matrix Checks\" OFF)\noption(HELIUM \"Helium acceleration (MVEF and MVEI supported)\" OFF)\noption(MVEF \"MVEF intrinsics supported\" OFF)\noption(MVEI \"MVEI intrinsics supported\" OFF)\noption(MVEFLOAT16 \"Float16 MVE intrinsics supported\" OFF)\noption(DISABLEFLOAT16 \"Disable building float16 kernels\" OFF)\noption(HOST \"Build for host\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Setting compiler flags for MSVC\nDESCRIPTION: This snippet defines an option to build the libraries with the `/MT` compiler flag, which links the C runtime library statically.  If the option `MSVC_STATIC_RUNTIME` is enabled, it iterates through various CMake flag variables and replaces `/MD` (dynamic linking) with `/MT` (static linking).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_COMPILER_IS_MSVC)\n    option(MSVC_STATIC_RUNTIME \"Build the libraries with /MT compiler flag\" OFF)\n    if(MSVC_STATIC_RUNTIME)\n        foreach(flag_var\n            CMAKE_C_FLAGS CMAKE_C_FLAGS_DEBUG CMAKE_C_FLAGS_RELEASE\n            CMAKE_C_FLAGS_MINSIZEREL CMAKE_C_FLAGS_RELWITHDEBINFO\n            CMAKE_C_FLAGS_CHECK)\n            string(REGEX REPLACE \"/MD\" \"/MT\" ${flag_var} \"${${flag_var}}\")\n        endforeach(flag_var)\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows the required configuration in the EWARM linker (.icf) file to allocate memory for ThreadX dynamic memory allocation. It places the `FREE_MEM` section within the `RAM_region`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/USBX/Ux_Device_HID/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: ThreadX Heap Configuration - MDK-ARM\nDESCRIPTION: This configuration is for the ARM MDK toolchain. It shows how to define the `RW_IRAM1` region in the scatter file or modify the `tx_initialize_low_level.S` file to match the memory region being used by ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Applications/USBX/Ux_Device_CDC_ACM/README.md#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\nLDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Linker configuration for MDK-ARM in .sct format\nDESCRIPTION: This snippet shows how to configure the linker file for MDK-ARM. It can either define the RW_IRAM1 region in the \".sct\" file, or modify the line in \"tx_initialize_low_level.S\" to match the memory region being used.  This step provides a pointer to the first free memory location in RAM, which is required by ThreadX for dynamic memory allocation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_TCP_Echo_Client/README.md#_snippet_2\n\nLANGUAGE: other\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S\" to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker File Modification\nDESCRIPTION: This snippet demonstrates how to add a new section named ._threadx_heap to the STM32CubeIDE linker file (.ld) for ThreadX dynamic memory allocation.  It allocates 64KB of RAM to the heap and aligns it to 8 bytes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Applications/ThreadX/Tx_Thread_Creation/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Initializing Azure IoT Provisioning Client in C\nDESCRIPTION: Initializes the Azure IoT Provisioning client instance.  It requires pointers to the provisioning client, Azure IoT instance, endpoint, ID scope, registration ID, crypto methods, cipher suites, metadata memory, memory size, and a trusted certificate. The function returns a status code indicating success or failure with specific error codes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_provisioning_client.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_provisioning_client_initialize(NX_AZURE_IOT_PROVISIONING_CLIENT *prov_client_ptr,\n                                                 NX_AZURE_IOT *nx_azure_iot_ptr,\n                                                 const UCHAR *endpoint, UINT endpoint_length,\n                                                 const UCHAR *id_scope, UINT id_scope_length,\n                                                 const UCHAR *registration_id, UINT registration_id_length,\n                                                 const NX_CRYPTO_METHOD **crypto_array, UINT crypto_array_size,\n                                                 const NX_CRYPTO_CIPHERSUITE **cipher_map, UINT cipher_map_size,\n                                                 UCHAR *metadata_memory, UINT memory_size,\n                                                 NX_SECURE_X509_CERT *trusted_certificate);\n```\n\n----------------------------------------\n\nTITLE: Include and Configure Application\nDESCRIPTION: Includes a configuration file (config) and calls the configApp function to configure the 'arm_fir_example' executable. It passes the ROOT variable to the function.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fir_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(config)\nconfigApp(arm_fir_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Setting Symmetric Key in C\nDESCRIPTION: Sets the symmetric key for the Azure IoT Provisioning client. It requires a pointer to the provisioning client, a pointer to the symmetric key, and the length of the symmetric key. The function returns a status code indicating success or failure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_provisioning_client.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_provisioning_client_symmetric_key_set(NX_AZURE_IOT_PROVISIONING_CLIENT *prov_client_ptr,\n                                                        const UCHAR *symmetric_key, UINT symmetric_key_length);\n```\n\n----------------------------------------\n\nTITLE: Adding Trusted Certificate in C\nDESCRIPTION: Adds a trusted certificate to the Azure IoT Provisioning client. It requires a pointer to the provisioning client and a pointer to the trusted certificate. The function allows setting up a certificate chain and returns a status code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_provisioning_client.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_provisioning_client_trusted_cert_add(NX_AZURE_IOT_PROVISIONING_CLIENT *prov_client_ptr,\n                                                       NX_SECURE_X509_CERT *trusted_certificate);\n```\n\n----------------------------------------\n\nTITLE: Linker Configuration for MDK-ARM\nDESCRIPTION: This snippet shows the linker configuration for MDK-ARM to allocate memory for ThreadX.  It defines the `RW_IRAM1` region in the `.sct` file or modifies the `tx_initialize_low_level.S` file to match the used memory region. This provides the necessary memory space for ThreadX operations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/NetXDuo/Nx_SNTP_Client/README.md#_snippet_2\n\nLANGUAGE: Other\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Enable/Disable XML Options (Bash)\nDESCRIPTION: This command utilizes the `xmlen` tool to enable or disable an XML parameter based on its `<Command>` value, referencing a macro definition from an image layout file.  It takes the input file, a symbol to search, and filters xml parameters by command. The output xml file will be modified.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nxmlen -l image_macros_preprocessed_bl2.c -m RE_ENCRYPTION -c E OEMiRoT_Secure_Code.xml\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Handler Example\nDESCRIPTION: This snippet demonstrates the structure of an Interrupt Service Routine (ISR) written in assembly language for ThreadX on Cortex-M55.  It pushes and pops registers, and includes space for user interrupt handling code. The `.thumb_func` directive is essential for Cortex-M55 exception handlers, ensuring the label is a thumb label.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/gnu/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    .global  your_assembly_isr\n    .thumb_func\nyour_assembly_isr:\n    PUSH    {r0, lr}\n;\n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: FreeRTOS Initialization Example in tx_application_define (C++)\nDESCRIPTION: This code snippet demonstrates a minimal initialization of the FreeRTOS adaptation layer within the `tx_application_define()` function. It initializes the adaptation layer using `tx_freertos_init()` and creates an initial application task using `xTaskCreate()`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/FreeRTOS/readme.md#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nVOID tx_application_define(VOID * first_unused_memory)\n{\n    BaseType_t error;\n    TaskHandle_t task_handle;\n\n    tx_freertos_init();\n\n    error = xTaskCreate(first_thread_entry, \"Initial Task\", STACK_SIZE, NULL, 10, &task_handle);\n    if(error != pdPASS) {\n        // Handle error.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running ThreadX Application in Linux\nDESCRIPTION: This command executes the compiled ThreadX application. It requires the application to run with privilege because ThreadX for Linux utilizes the API pthread_setschedparam().\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/linux/gnu/readme_threadx.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n./sample_threadx\n```\n\n----------------------------------------\n\nTITLE: ECDSA Raw to DER and DER to Raw Conversion in C\nDESCRIPTION: These functions convert between raw and DER ECDSA signature formats. `mbedtls_ecdsa_raw_to_der` converts a raw signature to DER format, while `mbedtls_ecdsa_der_to_raw` converts a DER signature to raw format. The `bits` parameter is the key size in bits, `raw` and `der` are the input/output buffers, and `raw_len` and `der_len` specify the size of the input and output buffers. The output buffers can overlap.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-migration/psa-legacy-bridges.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nint mbedtls_ecdsa_raw_to_der(size_t bits,\n                             const unsigned char *raw, size_t raw_len,\n                             unsigned char *der, size_t der_size, size_t *der_len);\nint mbedtls_ecdsa_der_to_raw(size_t bits,\n                             const unsigned char *der, size_t der_len,\n                             unsigned char *raw, size_t raw_size, size_t *raw_len);\n```\n\n----------------------------------------\n\nTITLE: Verifying Message with PSA API\nDESCRIPTION: This snippet describes how to verify a message using `psa_verify_message` with the PSA API, which combines hash calculation and signature verification. It mentions that either `PSA_KEY_USAGE_VERIFY_MESSAGE` or `PSA_KEY_USAGE_VERIFY_HASH` usage flag is sufficient.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_25\n\n\n\n----------------------------------------\n\nTITLE: Add Telemetry Property - Azure IoT Hub Client (C)\nDESCRIPTION: Adds a user-defined property to a telemetry message before it is sent to Azure IoT Hub. This function can be called multiple times to add multiple properties.  It must be called after the telemetry packet is created and before the message is sent.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_15\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_telemetry_property_add(NX_PACKET *packet_ptr,\n                                                    const UCHAR *property_name, USHORT property_name_length,\n                                                    const UCHAR *property_value, USHORT property_value_length,\n                                                    UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Define CTR_DRBG Warning\nDESCRIPTION: Defines a warning message related to using 128-bit keys for CTR_DRBG.  This provides information to the user that this configuration limits security. The warning is constructed as a list for compatibility with older CMake versions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nset(CTR_DRBG_128_BIT_KEY_WARN_L1 \"****  WARNING!  MBEDTLS_CTR_DRBG_USE_128_BIT_KEY defined!\\n\")\nset(CTR_DRBG_128_BIT_KEY_WARN_L2 \"****  Using 128-bit keys for CTR_DRBG limits the security of generated\\n\")\nset(CTR_DRBG_128_BIT_KEY_WARN_L3 \"****  keys and operations that use random values generated to 128-bit security\\n\")\n\nset(CTR_DRBG_128_BIT_KEY_WARNING \"${WARNING_BORDER}\"\n                         \"${CTR_DRBG_128_BIT_KEY_WARN_L1}\"\n                         \"${CTR_DRBG_128_BIT_KEY_WARN_L2}\"\n                         \"${CTR_DRBG_128_BIT_KEY_WARN_L3}\"\n                         \"${WARNING_BORDER}\")\n```\n\n----------------------------------------\n\nTITLE: Setting MBEDTLS_DIR CMake variable\nDESCRIPTION: This snippet sets the MBEDTLS_DIR variable to the CMake source directory if it's not already defined. This variable is likely used to locate Mbed TLS source files and related scripts.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT DEFINED MBEDTLS_DIR)\n    set(MBEDTLS_DIR ${CMAKE_SOURCE_DIR})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Key Usage Flags Attribute PSA\nDESCRIPTION: This code snippet explains how to set the key usage flags using the `psa_set_key_usage_flags` function. This is required to enable specific usages such as signing, verification, encryption, decryption, or key agreement.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_12\n\nLANGUAGE: C\nCODE:\n```\npsa_set_key_usage_flags\n```\n\n----------------------------------------\n\nTITLE: Setting TSN Test Cases (NetXDuo)\nDESCRIPTION: Defines a set of TSN (Time-Sensitive Networking) test cases for NetXDuo. These tests cover MRP (Multiple Registration Protocol) state machine, CBS (Credit-Based Shaper), and TAS (Time-Aware Shaper).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_27\n\nLANGUAGE: CMake\nCODE:\n```\nset(tsn_test_cases\n    ${SOURCE_DIR}/tsn_test/netx_mrp_state_machine_test.c\n    ${SOURCE_DIR}/tsn_test/netx_shaper_cbs_test.c\n    ${SOURCE_DIR}/tsn_test/netx_shaper_tas_test.c)\n```\n\n----------------------------------------\n\nTITLE: Low Power Mode Entry/Exit Example (ARM Assembly)\nDESCRIPTION: This example demonstrates how to enter and exit low power mode using ARM assembly instructions within the ThreadX framework. It includes conditional compilation using TX_LOW_POWER and TX_ENABLE_WFI macros. It assumes that tx_low_power_enter and tx_low_power_exit are defined elsewhere.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/low_power/low_power.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#ifdef TX_LOW_POWER\n    PUSH    {r0-r3}\n    BL      tx_low_power_enter                      // Enter low power mode\n    POP     {r0-r3}\n#endif\n\n#ifdef TX_ENABLE_WFI\n    DSB                                             // Ensure no outstanding memory transactions\n    WFI                                             // Wait for interrupt\n    ISB                                             // Ensure pipeline is flushed\n#endif\n\n#ifdef TX_LOW_POWER\n    PUSH    {r0-r3}\n    BL      tx_low_power_exit                       // Exit low power mode\n    POP     {r0-r3}\n#endif\n```\n\n----------------------------------------\n\nTITLE: Linker Configuration for EWARM\nDESCRIPTION: This code snippet shows the required linker configuration for EWARM to allocate memory for ThreadX dynamic memory allocation.  It places the FREE_MEM section in the RAM region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/USBPD/USBPD_SNK_UX_Device_HID/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: PSA Cipher Capability Check\nDESCRIPTION: This code snippet shows the new internal function `psa_can_do_cipher`. The job of this private function is to return 1 if `hash_alg` can be performed through PSA now, and 0 otherwise. It is only defined on algorithms that are enabled via PSA. As a starting point, return 1 if PSA crypto's driver subsystem has been initialized.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-migration/md-cipher-dispatch.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nint psa_can_do_cipher(psa_key_type_t key_type, psa_algorithm_t cipher_alg);\n```\n\n----------------------------------------\n\nTITLE: Setting Target Compile Options\nDESCRIPTION: Sets various compile options for the 'filex' target, including error handling, warnings, and code style checks.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(\n  filex\n  PRIVATE -Werror\n          -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal)\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Definition in ThreadX\nDESCRIPTION: Defines an interrupt service routine (ISR) written in assembly language for use with ThreadX. This ISR, 'your_assembly_isr', includes a standard prologue and epilogue to preserve the execution context.  It pushes the registers r0 and lr onto the stack and pops them back upon exiting, ensuring proper function call conventions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m23/ac6/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    .global  your_assembly_isr\n    .thumb_func\nyour_assembly_isr:\n; VOID your_assembly_isr(VOID)\n; {\n    PUSH    {r0, lr}\n;       \n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n    POP     {r0, r1}\n    MOV     lr, r1\n    BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: PSA Key Copy Function in Mbed TLS (C)\nDESCRIPTION: This function copies a PSA key into an Mbed TLS PK context, allowing the usage of PSA-managed keys with existing PK context-based APIs.  It creates a standard, transparent PK context, not an opaque wrapper around the PSA key.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-migration/psa-legacy-bridges.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nint mbedtls_pk_copy_from_psa(mbedtls_svc_key_id_t key_id,\n                             mbedtls_pk_context *pk);\n```\n\n----------------------------------------\n\nTITLE: Putting a Semaphore with tm_semaphore_put in C\nDESCRIPTION: This function puts (releases) the previously created binary semaphore. This will release a blocked thread (if any) waiting on this semaphore. Returns TM_SUCCESS upon releasing the semaphore.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\nint  tm_semaphore_put(int semaphore_id);\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Options\nDESCRIPTION: Defines several CMake options that control various aspects of the build process.  These options are used to enable or disable features like treating warnings as errors, building with CURL support, enabling unit testing, using mock implementations for unit tests, building with Paho MQTT support, enabling preconditions, enabling logging, and enabling the address sanitizer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\noption(WARNINGS_AS_ERRORS \"Treat compiler warnings as errors\" ON)\noption(TRANSPORT_CURL \"Build internal http transport implementation with CURL for HTTP Pipeline\" OFF)\noption(UNIT_TESTING \"Build unit test projects\" OFF)\noption(UNIT_TESTING_MOCKS \"wrap PAL functions with mock implementation for tests\" OFF)\noption(TRANSPORT_PAHO \"Build IoT Samples with Paho MQTT support\" OFF)\noption(PRECONDITIONS \"Build SDK with preconditions enabled\" ON)\noption(LOGGING \"Build SDK with logging support\" ON)\noption(ADDRESS_SANITIZER \"Build with address sanitizer\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Setting Compile Definitions\nDESCRIPTION: Sets definitions for secure, TLS requirement, queue depth, cloud, and WebSocket features. These definitions are combined into specific build configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(SECURE -DNX_SECURE_ENABLE)\nset(REQUIRE_TLS -DNXD_MQTT_REQUIRE_TLS)\nset(QUEUE_DEPTH -DNXD_MQTT_MAXIMUM_TRANSMIT_QUEUE_DEPTH=20)\nset(CLOUD -DNXD_MQTT_CLOUD_ENABLE)\nset(WEBSOCKET -DNXD_MQTT_OVER_WEBSOCKET)\n\nset(default_build_coverage)\nset(secure_build_coverage ${SECURE})\nset(require_secure_build ${SECURE} ${REQUIRE_TLS})\nset(queue_depth_build ${QUEUE_DEPTH})\n\nset(cloud_default_build_coverage ${CLOUD})\nset(cloud_secure_build_coverage ${SECURE} ${CLOUD})\nset(cloud_require_secure_build ${SECURE} ${REQUIRE_TLS} ${CLOUD})\nset(cloud_queue_depth_build ${CLOUD} ${QUEUE_DEPTH})\n\nset(websocket_secure_build ${WEBSOCKET} ${SECURE} -DNX_ENABLE_EXTENDED_NOTIFY_SUPPORT)\n```\n\n----------------------------------------\n\nTITLE: Request Complete Properties - C\nDESCRIPTION: This function requests complete properties from the Azure IoT Hub. It requires a pointer to an NX_AZURE_IOT_HUB_CLIENT and a timeout value. This function initiates the process of retrieving the full device twin properties.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_42\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_properties_request(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Using Default USART Commands List in OpenBootloader (C)\nDESCRIPTION: This code snippet illustrates how to utilize the default list of supported commands for the USART interface provided by the OpenBootloader middleware. It retrieves the default command list using `OPENBL_USART_GetCommandsList()` and assigns it to the USART handle's command pointer (`p_Cmd`). This allows the USART interface to support the full set of commands defined by the middleware without requiring custom command definitions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/OpenBootloader/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n/* Register USART interfaces */\nUSART_Handle.p_Ops = &USART_Ops;\nUSART_Handle.p_Cmd = OPENBL_USART_GetCommandsList();  /* Initialize the USART handle with the default list supported commands */\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration\nDESCRIPTION: This code snippet demonstrates how to configure the linker file for STM32CubeIDE to allocate memory for ThreadX's heap. It defines a new section called `._threadx_heap` with a size of 64KB, placed between the `.bss` and `._user_heap_stack` sections.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/USBX/Ux_Device_HID_CDC_ACM/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration\nDESCRIPTION: This code snippet shows two options for configuring the linker in MDK-ARM to provide memory for ThreadX. Either define the RW_IRAM1 region in the .sct file, or modify the line in tx_low_level_initilize.S to match the memory region being used. The second option involves locating the limit of the RW_IRAM1 region and loading it into register r1.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_SecureLEDToggle_TrustZone/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Asymmetric Decryption using PSA\nDESCRIPTION: Decrypts a short message (typically a symmetric key) using `psa_asymmetric_decrypt`. The key must be a key pair allowing the usage `PSA_KEY_USAGE_DECRYPT`. The output buffer size can be determined using `PSA_ASYMMETRIC_DECRYPT_OUTPUT_SIZE` or `PSA_ASYMMETRIC_DECRYPT_OUTPUT_MAX_SIZE`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_42\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_asymmetric_decrypt(psa_key_handle_t key,\n                                        psa_algorithm_t alg,\n                                        const uint8_t *input,\n                                        size_t input_length,\n                                        uint8_t *output,\n                                        size_t output_size,\n                                        size_t *output_length);\n```\n\n----------------------------------------\n\nTITLE: Submodule Check and Subdirectory Addition CMake\nDESCRIPTION: This snippet checks for the existence of the `framework/CMakeLists.txt` file. If it's missing, it emits a fatal error message instructing the user to run `git submodule update --init` to fetch the submodule content. Afterwards, it adds several subdirectories to the build process: `framework`, `include`, `3rdparty`, `library`, and `pkgconfig`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_23\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT EXISTS \"${CMAKE_CURRENT_SOURCE_DIR}/framework/CMakeLists.txt\")\n    message(FATAL_ERROR \"${CMAKE_CURRENT_SOURCE_DIR}/framework/CMakeLists.txt not found. Run `git submodule update --init` from the source tree to fetch the submodule contents.\")\nendif()\nadd_subdirectory(framework)\n\nadd_subdirectory(include)\n\nadd_subdirectory(3rdparty)\n\nadd_subdirectory(library)\n\nadd_subdirectory(pkgconfig)\n```\n\n----------------------------------------\n\nTITLE: Add FileX Library and Alias\nDESCRIPTION: This snippet adds the FileX library and creates an alias for it named \"azrtos::${PROJECT_NAME}\". This allows consumers to link against the library using either name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# Define our target library and an alias for consumers\nadd_library(${PROJECT_NAME})\nadd_library(\"azrtos::${PROJECT_NAME}\" ALIAS ${PROJECT_NAME})\n```\n\n----------------------------------------\n\nTITLE: ThreadX Interrupt Handler Template (Assembly)\nDESCRIPTION: This assembly code provides a template for implementing a ThreadX managed interrupt handler (ISR). It pushes the necessary registers onto the stack, executes the user-defined interrupt routine (assumed to be a C function), and then restores the registers before returning from the interrupt. This allows access to ThreadX services from within the ISR.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\n        .global  __tx_IntHandler\n        .thumb_func\n__tx_IntHandler:\n; VOID InterruptHandler (VOID)\n; {\n        PUSH    {r0, lr}\n\n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n        POP     {r0, lr}\n        BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration for ThreadX Heap\nDESCRIPTION: This snippet shows the linker configuration for STM32CubeIDE to allocate a memory region for the ThreadX heap.  It defines a ._threadx_heap section within the RAM_D1 region, setting its size to 64KB.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_LowPower/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n{\n   . = ALIGN(8);\n   __RAM_segment_used_end__ = .;\n   . = . + 64K;\n   . = ALIGN(8);\n } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Asymmetric Encryption using PSA\nDESCRIPTION: Encrypts a short message (typically a symmetric key) using `psa_asymmetric_encrypt`. The key must be a public key (or a key pair) allowing the usage `PSA_KEY_USAGE_ENCRYPT`. The output buffer size can be determined using `PSA_ASYMMETRIC_ENCRYPT_OUTPUT_SIZE` or `PSA_ASYMMETRIC_ENCRYPT_OUTPUT_MAX_SIZE`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_41\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_asymmetric_encrypt(psa_key_handle_t key,\n                                        psa_algorithm_t alg,\n                                        const uint8_t *input,\n                                        size_t input_length,\n                                        uint8_t *output,\n                                        size_t output_size,\n                                        size_t *output_length);\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This snippet configures the target sources for the project using the `target_sources` command in CMake. The intention is to add source files within the designated comment block, ensuring they are included in the build process. The `PRIVATE` keyword indicates that these sources are only used internally by the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m7/iar/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Key Slot State Transition\nDESCRIPTION: The internal function `psa_key_slot_state_transition` changes the state of a key slot. It validates the `expected_state` before transitioning to the `new_state`. If the expected state doesn't match, `PSA_ERROR_CORRUPTION_DETECTED` is returned, indicating an internal coding error. `psa_wipe_key_slot` is used to set the state to `PSA_SLOT_EMPTY`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-thread-safety/psa-thread-safety.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\npsa_key_slot_state_transition(slot, expected_state, new_state)\npsa_wipe_key_slot\n```\n\n----------------------------------------\n\nTITLE: Writing PSA Public Key to DER Format Using PK Module in C\nDESCRIPTION: This code snippet shows how to export a PSA public key, identified by `key_id`, to DER format using the PK (Public Key) module.  It copies the PSA public key to an `mbedtls_pk_context`, writes it to a DER buffer using `mbedtls_pk_write_pubkey_der`, and then performs a memory move to ensure the DER-encoded key is at the beginning of the provided buffer.  The function returns 0 on success and a non-zero value on failure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\nint write_psa_pubkey(psa_key_id_t key_id,\n                     unsigned char *buf, size_t size, size_t *len) {\n    mbedtls_pk_context pk;\n    mbedtls_pk_init(&pk);\n    int ret = mbedtls_pk_copy_public_from_psa(key_id, &pk);\n    if (ret != 0) goto exit;\n    ret = mbedtls_pk_write_pubkey_der(&pk, buf, size);\n    if (ret < 0) goto exit;\n    *len = ret;\n    memmove(buf, buf + size - ret, ret);\n    ret = 0;\nexit:\n    mbedtls_pk_free(&pk);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an az_span from a String in C\nDESCRIPTION: This code creates an `az_span` from a string using `AZ_SPAN_FROM_STR`. The span does not include the null terminator. Useful for passing string literals to functions expecting spans.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nsome_function(AZ_SPAN_FROM_STR(\"Hello\"));  // size = 5\n```\n\n----------------------------------------\n\nTITLE: Building Threaded Executable\nDESCRIPTION: Conditionally builds the `ssl_pthread_server` executable if the `THREADS_FOUND` variable is set (indicating that the Threads package was found). It adds the executable, sets include directories, and links the necessary libraries including the thread library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/ssl/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(THREADS_FOUND)\n    add_executable(ssl_pthread_server ssl_pthread_server.c $<TARGET_OBJECTS:mbedtls_test>)\n    target_include_directories(ssl_pthread_server PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\n    target_link_libraries(ssl_pthread_server ${libs} ${CMAKE_THREAD_LIBS_INIT})\n    list(APPEND executables ssl_pthread_server)\nendif(THREADS_FOUND)\n```\n\n----------------------------------------\n\nTITLE: Define pthread_cond_wait Function Prototype in C\nDESCRIPTION: Defines the prototype for the `pthread_cond_wait` function, used for waiting on a condition variable. It takes a pointer to a condition variable and a pointer to a mutex as input.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nINT                   pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\n```\n\n----------------------------------------\n\nTITLE: Key Slot States\nDESCRIPTION: Key slots in the key store have four possible states to control access and usage: `PSA_SLOT_EMPTY`, `PSA_SLOT_FILLING`, `PSA_SLOT_FULL`, and `PSA_SLOT_PENDING_DELETION`. These states dictate whether a thread can access a slot and how the slot can be used. The `registered_readers` counter tracks the number of threads currently reading the slot.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-thread-safety/psa-thread-safety.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nPSA_SLOT_EMPTY\nPSA_SLOT_FILLING\nPSA_SLOT_FULL\nPSA_SLOT_PENDING_DELETION\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This snippet utilizes the `target_sources` command in CMake to configure the private source files for the specified project. It defines a section within which source files can be listed, denoted by `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m7/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration for ThreadX Heap\nDESCRIPTION: This snippet shows how to configure the linker in MDK-ARM for ThreadX dynamic memory allocation.  It involves defining the RW_IRAM1 region or modifying the tx_initialize_low_level.S file to specify the memory region.  This setup is crucial for enabling dynamic memory allocation in ThreadX applications built with MDK-ARM.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_HID_CDC_ACM/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Getting Telemetry Publish Topic for Azure IoT Hub Client (C)\nDESCRIPTION: This code demonstrates how to retrieve the MQTT topic for publishing telemetry data using the `az_iot_hub_client` library. It calls the function `az_iot_hub_client_telemetry_get_publish_topic` with the client instance, and buffers for the topic and its size. The function populates the `topic` buffer with the telemetry publish topic.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/mqtt_state_machine.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nif(az_result_failed(az_iot_hub_client_telemetry_get_publish_topic(client, NULL, topic, topic_size, NULL)))\n{\n    // error.\n}\n```\n\n----------------------------------------\n\nTITLE: Building Azure SDK for Embedded C\nDESCRIPTION: This snippet creates a `build` directory, navigates into it, and uses CMake to generate the build files for the Azure SDK for Embedded C.  The `TRANSPORT_PAHO=ON` flag enables the Paho MQTT transport layer. This step prepares the source code for compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n~/azure-sdk-for-c/sdk/samples/iot$ cd ../../..\n~/azure-sdk-for-c$ mkdir build\n~/azure-sdk-for-c$ cd build\n~/azure-sdk-for-c/build$ cmake -DTRANSPORT_PAHO=ON ..\n```\n\n----------------------------------------\n\nTITLE: OpenSSL Configuration File (Shell)\nDESCRIPTION: This is an OpenSSL configuration file used for creating self-signed certificates. It sets up the required extensions and distinguished name for the certificate, including specifying the common name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/samples/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\ncat > x509_config.cfg <<EOT\n[req]\nreq_extensions = client_auth\ndistinguished_name = req_distinguished_name\n\n[req_distinguished_name]\n\n[ client_auth ]\nbasicConstraints = CA:FALSE\nkeyUsage = digitalSignature, keyEncipherment\nextendedKeyUsage = clientAuth\nEOT\n```\n\n----------------------------------------\n\nTITLE: File Naming with sprintf (C stdio, Mbed Crypto 0.1.0)\nDESCRIPTION: This C code snippet demonstrates how key files are named when using C stdio for storage in Mbed Crypto 0.1.0. It utilizes `sprintf` to construct a file name based on a configurable location prefix (`CRYPTO_STORAGE_FILE_LOCATION`) and the key identifier (`key_id`). This filename is then used to store key data.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/mbed-crypto-storage-specification.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nsprintf(CRYPTO_STORAGE_FILE_LOCATION \"psa_key_slot_%lu\", key_id)\n```\n\n----------------------------------------\n\nTITLE: Initializing Azure IoT Hub Client in C\nDESCRIPTION: This code snippet demonstrates the initialization of the Azure IoT Hub client using the `nx_azure_iot_hub_client_initialize` function. It requires pointers to an IoT Hub client instance, an Azure IoT instance, and parameters for host name, device ID, module ID, crypto methods, cipher suites, metadata memory, and a trusted certificate.  The function returns a status code indicating success or failure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_initialize(NX_AZURE_IOT_HUB_CLIENT* hub_client_ptr,\n                                        NX_AZURE_IOT *nx_azure_iot_ptr,\n                                        const UCHAR *host_name, UINT host_name_length,\n                                        const UCHAR *device_id, UINT device_id_length,\n                                        const UCHAR *module_id, UINT module_id_length,\n                                        const NX_CRYPTO_METHOD **crypto_array, UINT crypto_array_size,\n                                        const NX_CRYPTO_CIPHERSUITE **cipher_map, UINT cipher_map_size,\n                                        UCHAR * metadata_memory, UINT memory_size,\n                                        NX_SECURE_X509_CERT *trusted_certificate);\n```\n\n----------------------------------------\n\nTITLE: Setting Registration Completion Callback in C\nDESCRIPTION: Sets the callback function to be executed upon registration completion with the Azure IoT Provisioning Service. It requires a pointer to the provisioning client and a pointer to the callback function. The callback provides the provisioning client and a status code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_provisioning_client.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_provisioning_client_completion_callback_set(NX_AZURE_IOT_PROVISIONING_CLIENT *prov_client_ptr,\n                                                              VOID (*on_complete_callback)(struct NX_AZURE_IOT_PROVISIONING_CLIENT_STRUCT *prov_client_ptr, UINT status));\n```\n\n----------------------------------------\n\nTITLE: Running FIH Tests\nDESCRIPTION: These shell commands illustrate how to execute the FIH tests locally after building the docker image with `ci/fih-tests_install.sh`. The environment variables control the FIH level, build type, skip size, and damage type.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_20\n\nLANGUAGE: Shell Script\nCODE:\n```\n$ ./ci/fih-tests_install.sh\n$ FIH_LEVEL=MCUBOOT_FIH_PROFILE_MEDIUM BUILD_TYPE=RELEASE SKIP_SIZE=2 \\\n    DAMAGE_TYPE=SIGNATURE ./ci/fih-tests_run.sh\n```\n\n----------------------------------------\n\nTITLE: Modifying file values using command-line tool\nDESCRIPTION: This example demonstrates how to modify file values using a command-line tool, specifically targeting parameter values within an XML configuration. It involves filtering an XML file based on a tag's content, extracting the corresponding value, and updating a specific variable in a CSV file. The shift value parameter shifts the extracted XML value to the left by the specified number of bits before updating the CSV file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_26\n\nLANGUAGE: text\nCODE:\n```\nflash -xml \"SMAK_Config_General.xml\" -n \"Product state minimal allowed\" -var \"OPTSR_PRG\" -sft \"8\" Option_Bytes.csv\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure IoT Hub Client\nDESCRIPTION: This code snippet shows the configuration settings for the `azureClientSample.c` file. It includes definitions for the IoT Hub name, device ID (with options for X509 certificate and provisioning), certificate file paths, and primary key. The user must update these definitions to match their Azure IoT Hub and device configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_vxworks.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n/*\n * This definition has to be updated according to the name of\n * your Azure IoT Hub\n */\n#define IOT_HUB_NAME \"VxWorksIoT\"\n\n/*\n * Define X509_CERTIFICATE to use user-generated Root Certificate.\n * If you only want to use SAS, undefine or comment out this macro.\n */\n#define X509_CERTIFICATE\n\n/*\n * Connect to provisioned devices\n * If you want to connect to devices which are not provisioned in your hub,\n * undefine or comment out this macro.\n */\n#define USE_PROVISIONING\n\n/* Update Device ID */\n#ifdef X509_CERTIFICATE\n#ifdef USE_PROVISIONING\n#define DEVICE_ID \"[Provisioned X509 Device ID]\"\n#else /* USE_PROVISIONING */\n#define DEVICE_ID \"[Non-Provisioned X509 Device ID]\"\n#endif /* USE_PROVISIONING */\n#else /* X509_CERTIFICATE */\n#ifdef USE_PROVISIONING\n#define DEVICE_ID \"[Provisioned SAS Device ID]\"\n#else /* USE_PROVISIONING */\n#define DEVICE_ID \"[Non-Provisioned SAS Device ID]\"\n#endif /* USE_PROVISIONING */\n#endif /* X509_CERTIFICATE */\n\n/*\n * Server certificate file path. It can be found in:\n * https://github.com/Azure/azure-iot-sdk-c/blob/master/certs/certs.c\n *\n * Copy all the sections beginning with “-----BEGIN CERTIFICATE-----” and\n * ending with “-----END CERTIFICATE-----” into a file with an extension “pem”\n * like “certs.pem”. Remove all the beginning and ending double quotes and\n * “\\r\\n”.\n * -----BEGIN CERTIFICATE-----\n * MIIDdzCCAl+gAwIBAgIEAgAAuTANBgkqhkiG9w0BAQUFADBaMQswCQYDVQQGEwJJ\n * RTESMBAGA1UEChMJQmFsdGltb3JlMRMwEQYDVQQLEwpDeWJlclRydXN0MSIwIAYD\n * …………………………………………………………………………..\n * …………………………………………………………………………..\n * Epn3o0WC4zxe9Z2etciefC7IpJ5OCBRLbf1wbWsaY71k5h+3zvDyny67G7fyUIhz\n * ksLi4xaNmjICq44Y3ekQEe5+NauQrz4wlHrQMz2nZQ/1/I6eYs9HRCwBXbsdtTLS\n * R9I4LtD+gdwyah617jzV/OeBHRnDJELqYzmp\n * -----END CERTIFICATE-----\n */\n#define CERT_FILE \"/romfs/certs/cert.pem\"\n\n/* X509 certificate file and private key file paths */\n/*\n * X509 user-generated Root Certificate guide:\n * https://github.com/Azure/azure-iot-sdk-c/blob/master/tools\n * /CACertificates/CACertificateOverview.md\n */\n#ifdef X509_CERTIFICATE\n#ifdef USE_PROVISIONING\n#define X509_CERT_FILE \"/romfs/certs/[Provisioned X509 certificate].pem\"\n#define X509_KEY_FILE \"/romfs/certs/[Provisioned X509 Private Key].pem\"\n#else /* USE_PROVISIONING */\n#define X509_CERT_FILE \"/romfs/certs/[Non-Provisioned X509 certificate].pem\"\n#define X509_KEY_FILE \"/romfs/certs/[Non-Provisioned X509 Private Key].pem\"\n#endif /* USE_PROVISIONING */\n#else /* X509_CERTIFICATE */\n#define X509_CERT_FILE NULL\n#define X509_KEY_FILE NULL\n/*\n * Primary Key is only needed by SAS device.\n * It can be found via:\n * Azure IoT Hub Service -> IoT devices -> one specific enrollment\n *  -> Primary Key\n *\n * For a provisioned device, its primary key is the same as its enrollment's.\n */\n#ifdef USE_PROVISIONING\nstatic char primaryKey[] = \"[Device's Primary Key]\";\n#else /* USE_PROVISIONING */\nstatic char primaryKey[] = \"[Provisioned Device's Primary Key]\";\n#endif /* USE_PROVISIONING */\n#endif /* X509_CERTIFICATE */\n```\n\n----------------------------------------\n\nTITLE: Enable Properties Feature - C\nDESCRIPTION: This function enables the device twin properties feature within the Azure IoT Hub client. It requires a pointer to the NX_AZURE_IOT_HUB_CLIENT instance. It returns NX_AZURE_IOT_SUCCESS on successful enabling of the properties feature.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_38\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_properties_enable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Signing Message with PSA API\nDESCRIPTION: This snippet describes how to sign a message using `psa_sign_message` with the PSA API, which combines hash calculation and signature generation. It mentions that either `PSA_KEY_USAGE_SIGN_MESSAGE` or `PSA_KEY_USAGE_SIGN_HASH` usage flag is sufficient.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_24\n\n\n\n----------------------------------------\n\nTITLE: Installing AppliCfg with setup.py (Python)\nDESCRIPTION: This command installs the AppliCfg tool and its dependencies using the `setup.py` script. Running this ensures that all necessary libraries are available for the tool to function correctly, especially when modifying the source code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython setup.py install\n```\n\n----------------------------------------\n\nTITLE: Calculating Retry Delay with Exponential Backoff and Jitter in C\nDESCRIPTION: This code snippet shows how to calculate a retry delay using exponential back-off with random jitter, using the `az_iot_calculate_retry_delay` function. It takes into account the previous operation's duration, the attempt number, minimum and maximum retry delays, and a random jitter value to avoid synchronized retries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/mqtt_state_machine.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\n// The previous operation took operation_msec.\n// The application calculates random_jitter_msec between 0 and max_random_jitter_msec.\n\nint32_t delay_msec = az_iot_calculate_retry_delay(operation_msec, attempt, min_retry_delay_msec, max_retry_delay_msec, random_jitter_msec);\n```\n\n----------------------------------------\n\nTITLE: Create Executable for IoT PnP Sample\nDESCRIPTION: This snippet creates an executable named `paho_iot_pnp_sample` from several C files and links it against the common library.  A map file is then created.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable (paho_iot_pnp_sample\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_pnp_sample.c\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_pnp_sample_common.c\n)\n\ntarget_link_libraries(paho_iot_pnp_sample\n  PRIVATE\n    az::iot::sample::common\n)\n\ncreate_map_file(paho_iot_pnp_sample paho_iot_pnp_sample.map)\n```\n\n----------------------------------------\n\nTITLE: Enable Device Twin Feature in C\nDESCRIPTION: This function enables the device twin feature for the given IoT Hub client. It only takes the hub client pointer as input. This function must be called before using any device twin related features.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_31\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_device_twin_enable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Linking Custom HTTP Stack (CMake)\nDESCRIPTION: This cmake snippet shows how to link a custom HTTP adapter and stack to your application. It uses `target_link_libraries` to link the application target with the custom adapter and HTTP stack library. This avoids the default libcurl implementation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/README.md#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(your_application_target PRIVATE lib_adapter http_stack_lib)\n\n# For instance, this is how we link libcurl and its adapter\ntarget_link_libraries(blobs_client_example PRIVATE az_curl CURL::libcurl)\n```\n\n----------------------------------------\n\nTITLE: Defining Image Header Structure\nDESCRIPTION: This code defines the structure of the image header (`image_header`).  This header contains essential metadata about the image, including magic number, load address, header size, protected TLV size, image size, flags, and version information. All fields are in little-endian byte order.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nstruct image_header {\n    uint32_t ih_magic;\n    uint32_t ih_load_addr;\n    uint16_t ih_hdr_size;           /* Size of image header (bytes). */\n    uint16_t ih_protect_tlv_size;   /* Size of protected TLV area (bytes). */\n    uint32_t ih_img_size;           /* Does not include header. */\n    uint32_t ih_flags;              /* IMAGE_F_[...]. */\n    struct image_version ih_ver;\n    uint32_t _pad1;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Entropy Collection Entry Point in C\nDESCRIPTION: This code snippet shows the prototype for defining an entropy source entry point in a driver. The function `acme_get_entropy` takes flags, pointers to estimate the amount of entropy and output buffer, and the size of the output buffer as parameters. It returns a `psa_status_t` indicating the success or failure of the operation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_32\n\nLANGUAGE: c\nCODE:\n```\npsa_status_t acme_get_entropy(uint32_t flags,\n                              size_t *estimate_bits,\n                              uint8_t *output,\n                              size_t output_size);\n```\n\n----------------------------------------\n\nTITLE: Creating Header File Symbolic Links\nDESCRIPTION: This snippet iterates through the ThreadX, NetX Duo, and FileX libraries to create symbolic links for all header files in a common include directory within the build directory. It ensures that all necessary header files are easily accessible for compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/libs/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(lib threadx netxduo filex)\n  get_target_property(dirs ${lib} INCLUDE_DIRECTORIES)\n  execute_process(COMMAND mkdir -p ${CMAKE_BINARY_DIR}/inc)\n  foreach(dir ${dirs})\n    file(GLOB header_files ${dir}/*.h)\n    foreach(header_file ${header_files})\n      execute_process(COMMAND ln -sf ${header_file} ${CMAKE_BINARY_DIR}/inc)\n    endforeach()\n  endforeach()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Assembly Interrupt Service Routine (ISR) Example\nDESCRIPTION: This code snippet illustrates the structure for writing an Interrupt Service Routine (ISR) in assembly language for ThreadX on Cortex-M0. It includes necessary directives for creating thumb labels and handling the stack. The example shows how to save and restore registers and branch back to the interrupted code. It is essential to ensure thumb labels, which can be achieved by preceding the label declaration with the .thumb_func assembler directive. The label __tx_IntHandler needs to be inserted in the interrupt vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/gnu/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n\t.global  your_assembly_isr\n\t.thumb_func\nyour_assembly_isr:\n; VOID your_assembly_isr(VOID)\n; {\n\tPUSH    {r0, lr}\n;\t\n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n\tPOP     {r0, r1}\n\tMOV     lr, r1\n\tBX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Define Source Sets for USB Hub Class Tests\nDESCRIPTION: This snippet defines a variable `ux_class_hub_test_cases` that contains a list of C source files for USB Hub class tests. These files are located in the specified `SOURCE_DIR`. The tests cover various aspects of hub functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_hub_test_cases\n    ${SOURCE_DIR}/usbx_host_class_hub_port_change_connection_process_coverage_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hub_descriptor_get_coverage_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hub_status_get_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hub_transfer_request_completed_test.c\n    ${SOURCE_DIR}/usbx_hub_hub_status_get_invalid_length_test.c\n    ${SOURCE_DIR}/usbx_hub_no_power_switching_test.c\n    ${SOURCE_DIR}/usbx_hub_get_hub_status_fails_during_port_reset_test.c\n    ${SOURCE_DIR}/usbx_hub_port_never_reset_test.c\n    ${SOURCE_DIR}/usbx_hub_port_change_reset_test.c\n    ${SOURCE_DIR}/usbx_hub_port_change_over_current_test.c\n    ${SOURCE_DIR}/usbx_hub_port_change_suspend_test.c\n    ${SOURCE_DIR}/usbx_hub_get_hub_status_fails_during_hub_device_enum_test.c\n    ${SOURCE_DIR}/usbx_hub_basic_test.c\n    ${SOURCE_DIR}/usbx_hub_basic_memory_test.c\n    ${SOURCE_DIR}/usbx_hub_get_status_fails_during_configuration_test.c\n    ${SOURCE_DIR}/usbx_hub_invalid_hub_descriptor_length_test.c\n    ${SOURCE_DIR}/usbx_bus_powered_hub_conn_to_self_and_bus_powered_hub_test.c\n    ${SOURCE_DIR}/usbx_hub_full_speed_hub_test.c\n    ${SOURCE_DIR}/usbx_hub_multiple_tt_test.c\n    ${SOURCE_DIR}/usbx_hub_invalid_device_protocol_test.c\n    ${SOURCE_DIR}/usbx_hub_request_to_hub_itself_test.c\n    ${SOURCE_DIR}/usbx_hub_single_tt_too_many_hub_ports_test.c\n    ${SOURCE_DIR}/usbx_hub_multiple_tt_too_many_hub_ports_test.c\n    ${SOURCE_DIR}/usbx_hub_no_endpoints_test.c\n    ${SOURCE_DIR}/usbx_hub_interrupt_out_endpoint_test.c\n    ${SOURCE_DIR}/usbx_hub_non_interrupt_in_endpoint_test.c\n    ${SOURCE_DIR}/usbx_hub_hub_device_connect_test.c\n    ${SOURCE_DIR}/usbx_hub_hub_device_disconnect_test.c\n    ${SOURCE_DIR}/usbx_hub_quick_hub_device_reconnection_test.c\n    ${SOURCE_DIR}/usbx_hub_hub_device_enumeration_keeps_failing_test.c\n    ${SOURCE_DIR}/usbx_hub_port_reset_fails_during_hub_device_enum_test.c\n    ${SOURCE_DIR}/usbx_hub_get_port_status_fails_during_hub_device_enum_test.c\n    ${SOURCE_DIR}/usbx_hub_low_speed_hub_device_test.c\n    ${SOURCE_DIR}/usbx_hub_full_speed_hub_device_test.c\n    ${SOURCE_DIR}/usbx_hub_quick_hub_device_disconnection_test.c\n    ${SOURCE_DIR}/usbx_hub_port_change_enable_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hub_entry_test.c)\n```\n\n----------------------------------------\n\nTITLE: Example JSON Payload - IoT Hub Methods Sample\nDESCRIPTION: This JSON payload represents the successful response from the `paho_iot_hub_methods_sample` when the `ping` method is invoked. This verifies the method invocation was successful.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_26\n\nLANGUAGE: json\nCODE:\n```\n{\"response\": \"pong\"}\n```\n\n----------------------------------------\n\nTITLE: Defining Target Sources for NetX Crypto in CMake\nDESCRIPTION: This CMake snippet uses `target_sources` to define a list of C source files that implement various cryptographic algorithms and functionalities for the NetX Crypto library within the specified project. The source files are located in the `src` directory within the current list directory. This ensures that these source files are compiled and linked into the target during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/crypto_libraries/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_3des.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_aes.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_cbc.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ccm.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ctr.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_des.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_dh.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_drbg.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ec.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ec_secp192r1_fixed_points.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ec_secp224r1_fixed_points.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ec_secp256r1_fixed_points.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ec_secp384r1_fixed_points.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ec_secp521r1_fixed_points.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ecdh.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ecdsa.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_ecjpake.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_gcm.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_generic_ciphersuites.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_hkdf.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_hmac.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_hmac_md5.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_hmac_sha1.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_hmac_sha2.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_hmac_sha5.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_huge_number.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_huge_number_extended.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_md5.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_3des.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_aes.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_des.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_drbg.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_ecdh.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_ecdsa.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_hmac_md5.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_hmac_sha.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_md5.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_pkcs1.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_prf.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_rsa.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_method_self_test_sha.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_methods.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_null_cipher.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_phash.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_pkcs1_v1.5.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_rsa.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_sha1.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_sha2.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_sha5.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_tls_prf_1.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_tls_prf_sha256.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_tls_prf_sha384.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_tls_prf_sha512.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_crypto_xcbc_mac.c\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Key Import Entry Point in C\nDESCRIPTION: This code snippet illustrates the prototype for a key import entry point for transparent drivers. The `acme_import_key` function accepts key attributes, input data, the length of the input data, a key buffer, the key buffer size, pointers to store the key buffer length, and the number of bits. It returns a `psa_status_t` indicating success or failure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_33\n\nLANGUAGE: c\nCODE:\n```\npsa_status_t acme_import_key(const psa_key_attributes_t *attributes,\n                             const uint8_t *data,\n                             size_t data_length,\n                             uint8_t *key_buffer,\n                             size_t key_buffer_size,\n                             size_t *key_buffer_length,\n                             size_t *bits);\n```\n\n----------------------------------------\n\nTITLE: Modifying Linker Variable from XML (linker)\nDESCRIPTION: This example shows how to modify a linker variable in an ICF file based on the value of a tag in an XML file. It filters the XML parameters by name and uses the corresponding value to update the specified linker variable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nlinker -xml OEMiRoT_Secure_Code.xml -nxml Firmware area size -n CODE_SIZE stm32h573xx_flash_s.icf\n```\n\n----------------------------------------\n\nTITLE: User Option Bytes Configuration (TrustZone)\nDESCRIPTION: This snippet shows the required user option bytes configuration for enabling TrustZone security and defining secure/non-secure memory regions. TZEN enables TrustZone, SECWM1_STRT/END define the secure Flash region (Bank1), and SECWM2_STRT/END define the non-secure Flash region (Bank2).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples/GTZC/GTZC_TZSC_MPCBB_TrustZone/README.md#_snippet_0\n\nLANGUAGE: none\nCODE:\n```\nTZEN=B4\nSECWM1_STRT=0x0  SECWM1_END=0x7F    meaning all 128 pages of Bank1 set as secure\nSECWM2_STRT=0x1  SECWM2_END=0x0     meaning no page of Bank2 set as secure, hence Bank2 non-secure\n```\n\n----------------------------------------\n\nTITLE: Input/Output file modification using command-line tool\nDESCRIPTION: This example demonstrates how to modify input and output project binaries using a command-line tool. It involves specifying the location of the file containing preprocessed macros, macro symbols for encryption mode and image number, the XML file for the Rot Application, input and output binary file paths, and the tag names for selecting the input and output binaries, and encryption mode in the XML file. Also requires a 'begin' line to replace in the script file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_32\n\nLANGUAGE: text\nCODE:\n```\niofile --layout image_macros_preprocessed_bl2.c -mi RE_APP_IMAGE_NUMBER -me RE_ENCRYPTION --xml OEMiRoT_NonSecure_Code.xml -in \"Firmware binary input file\" -i ../../ROT_Appli_TrustZone/Binary/rot_app.bin -on \"Image output file\" -en \"Encryption key\" -b ns_code_image ob_flash_programming.bat\n```\n\n----------------------------------------\n\nTITLE: Conditionally Appending BSD Sources (CMake)\nDESCRIPTION: This snippet conditionally appends the BSD socket implementation source file (nxd_bsd.c) to the SOURCES list if the NXD_ENABLE_BSD CMake option is enabled. This allows the project to include or exclude BSD socket support based on the configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NXD_ENABLE_BSD)\n    list(APPEND SOURCES\n         ${CMAKE_CURRENT_LIST_DIR}/BSD/nxd_bsd.c\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Define WebSocket Test Cases\nDESCRIPTION: This snippet defines a CMake variable `websocket_test_cases` that holds a list of C source files containing test cases for the NetX WebSocket functionality. These tests cover areas such as sending chained packets, non-blocking operations, multi-instance scenarios, and connection management.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nset(websocket_test_cases\n    ${SOURCE_DIR}/websocket_test/netx_websocket_send_chain_packets_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_non_block_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_multi_instance_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_delete_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_16_bit_payload_length_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_one_packet_with_multi_frames_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_one_frame_in_packets_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_disconnect_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_connect_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_mask_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_fin_test.c\n    ${SOURCE_DIR}/websocket_test/netx_websocket_opcode_test.c)\n\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration\nDESCRIPTION: This code snippet shows how to configure the linker file for MDK-ARM to allocate memory for ThreadX dynamic memory allocation. It defines the `RW_IRAM1` region in the `.sct` file or modifies the `tx_initialize_low_level.S` file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/USBX/Ux_Device_HID_CDC_ACM/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM linker configuration for ThreadX heap\nDESCRIPTION: This snippet describes how to configure the linker file for MDK-ARM to add a section for ThreadX dynamic memory allocation, either by defining a region or modifying the `tx_initialize_low_level.S` file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_Thread_Sync/README.md#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Creating a Semaphore with tm_semaphore_create in C\nDESCRIPTION: This function creates a binary semaphore. It takes a semaphore_id as input and returns TM_SUCCESS if successful. The semaphore is initially available.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nint  tm_semaphore_create(int semaphore_id);\n```\n\n----------------------------------------\n\nTITLE: Create Executable for IoT Provisioning SAS Sample\nDESCRIPTION: This snippet creates an executable named `paho_iot_provisioning_sas_sample` from the `paho_iot_provisioning_sas_sample.c` file and links it against the common library. A map file is then created.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable (paho_iot_provisioning_sas_sample\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_provisioning_sas_sample.c\n)\n\ntarget_link_libraries(paho_iot_provisioning_sas_sample\n  PRIVATE\n    az::iot::sample::common\n)\n\ncreate_map_file(paho_iot_provisioning_sas_sample paho_iot_provisioning_sas_sample.map)\n```\n\n----------------------------------------\n\nTITLE: Getting Cloud-to-Device Message Property in C\nDESCRIPTION: This function retrieves a property from a cloud-to-device (C2D) message. It requires a pointer to the IoT Hub client, a pointer to the packet containing the C2D message, the name of the property to retrieve, the length of the property name, and pointers to store the property value and its length.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_22\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_cloud_message_property_get(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr, NX_PACKET *packet_ptr,\n                                                        const UCHAR *property_name, USHORT property_name_length,\n                                                        const UCHAR **property_value, USHORT *property_value_length);\n```\n\n----------------------------------------\n\nTITLE: Set Reported Properties Response Callback in C\nDESCRIPTION: This function sets the callback function to handle responses for reported properties. The callback function receives the hub client pointer, request ID, response status, version, and callback arguments. Setting the callback to NULL disables it.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_33\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_reported_properties_response_callback_set(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                                       VOID (*callback_ptr)(\n                                                                             NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                                             UINT request_id,\n                                                                             UINT response_status,\n                                                                             ULONG version,\n                                                                             VOID *args),\n                                                                       VOID *callback_args);\n```\n\n----------------------------------------\n\nTITLE: RTC Clock Source Selection\nDESCRIPTION: This code snippet shows how to choose the RTC clock source between LSI and LSE. By default, the LSI oscillator clock is used. To use LSE, the user needs to uncomment the `#define RTC_CLOCK_SOURCE_LSE` line and comment out `#define RTC_CLOCK_SOURCE_LSI`. This selection influences the accuracy of the RTC.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Examples/RTC/RTC_Alarm/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define RTC_CLOCK_SOURCE_LSI\n/* #define RTC_CLOCK_SOURCE_LSE */\n```\n\n----------------------------------------\n\nTITLE: Initializing ETH in main.c\nDESCRIPTION: This code snippet initializes the Ethernet (ETH) peripheral. It sets the MAC address for the STM32H5 device.  Ensure the MAC address is unique if multiple devices are on the same LAN. The `heth` instance is assigned to the ETH peripheral.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/NetXDuo/Nx_UDP_Echo_Client/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid MX_ETH_Init(void)\n{\n\n  /* USER CODE BEGIN ETH_Init 0 */\n\n  /* USER CODE END ETH_Init 0 */\n\n  /* USER CODE BEGIN ETH_Init 1 */\n\n  /* USER CODE END ETH_Init 1 */\n  heth.Instance = ETH;\n  MACAddr[0] = 0x00;\n  MACAddr[1] = 0x80;\n  MACAddr[2] = 0xE1;\n  MACAddr[3] = 0x00;\n  MACAddr[4] = 0x00;\n  MACAddr[5] = 0x00;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Logging Message Callback in C\nDESCRIPTION: This code defines the type for a logging message callback function. The callback receives a log classification and an `az_span` containing the log message.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\ntypedef void (*az_log_message_fn)(az_log_classification classification, az_span message);\n```\n\n----------------------------------------\n\nTITLE: Building Executables CMake\nDESCRIPTION: This CMake snippet iterates through the list of executables and adds them to the build process.  It links each executable with the mbedtls_test object library, mbedcrypto target, and thread libraries.  It also sets include directories for each executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/psa/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(exe IN LISTS executables)\n    add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>)\n    target_link_libraries(${exe} ${mbedcrypto_target} ${CMAKE_THREAD_LIBS_INIT})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: ThreadX Timer Interrupt Call - Assembly\nDESCRIPTION: This assembly code demonstrates where the ThreadX timer interrupt processing is called within an IRQ.  The function `_tx_timer_interrupt` needs to be called in the IRQ processing to manage all time-slicing, thread sleeps, timeouts, and application timers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac5/readme_threadx.txt#_snippet_6\n\nLANGUAGE: Assembly\nCODE:\n```\n_tx_timer_interrupt\n```\n\n----------------------------------------\n\nTITLE: Configuring Opaque PSK Key for TLS\nDESCRIPTION: The functions `mbedtls_ssl_conf_psk_opaque()` and `mbedtls_ssl_set_hs_psk_opaque()` register a PSA key for use with a PSK key exchange in TLS. This provides isolation of long-term secrets and uses the key managed by PSA. The application needs to register the key using one of the new APIs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/use-psa-crypto.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nmbedtls_ssl_conf_psk_opaque()\n```\n\nLANGUAGE: C\nCODE:\n```\nmbedtls_ssl_set_hs_psk_opaque()\n```\n\n----------------------------------------\n\nTITLE: Linker Configuration for MDK-ARM\nDESCRIPTION: This snippet illustrates the linker configuration required for MDK-ARM. It involves either defining the RW_IRAM1 region in the .sct file or modifying the tx_initialize_low_level.S file to align with the memory region used. Note that backslashes are escaped.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/USBPD/USBPD_SNK_UX_Device_HID/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Hashing binary content using command-line tool\nDESCRIPTION: This example demonstrates how to compute the SHA256 hash of a binary file's content and update another binary file with the hash. It involves specifying the input data file, the offset at which to insert the hash, and the output file to update.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_33\n\nLANGUAGE: text\nCODE:\n```\nhashcontent -i user_password.bin -o 0x8 password.bin\n```\n\n----------------------------------------\n\nTITLE: Including Azure RTOS Source CMake\nDESCRIPTION: Includes the `azure_rtos_src.cmake` file, which likely manages the inclusion of Azure RTOS source files in the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n# Include azure rtos cmake\ninclude(configs/azure_rtos_src.cmake)\n```\n\n----------------------------------------\n\nTITLE: Declare output buffer functions in C\nDESCRIPTION: Declares two C functions for managing local output buffer copies: `psa_crypto_local_output_alloc` and `psa_crypto_local_output_free`. The `alloc` function allocates memory for the output buffer and stores the pointer and length in the provided struct. The `free` function copies the local buffer to the original, then releases the allocated memory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-shared-memory.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_crypto_local_output_alloc(uint8_t *output, size_t output_len,\n                                           psa_crypto_local_output_t *local_output);\n\npsa_status_t psa_crypto_local_output_free(psa_crypto_local_output_t *local_output);\n```\n\n----------------------------------------\n\nTITLE: Starting ECDSA Interruptible Signature in PSA\nDESCRIPTION: Starts an interruptible ECDSA signature operation using `psa_sign_hash_start`. It takes the private key object and the hash to be signed as input.  The operation might not complete immediately, requiring subsequent calls to `psa_sign_hash_complete`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_29\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t status = psa_sign_hash_start(&operation, key, alg, hash, hash_length);\n```\n\n----------------------------------------\n\nTITLE: Time Increment Example in tx_low_power_exit (C)\nDESCRIPTION: This example shows how the `tx_time_increment` function is used within `tx_low_power_exit` to adjust the ThreadX time after exiting low power mode. It relies on the `TX_LOW_POWER_USER_TIMER_ADJUST` macro to determine the number of ticks to increment. If `TX_LOW_POWER_TIMER_ADJUST` is not defined, the increment is set to 0.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/low_power/low_power.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n/* Call the low-power timer driver code to obtain the amount of time (in ticks)\nthe system has been in low power mode. */\n#ifdef TX_LOW_POWER_TIMER_ADJUST\n        tx_low_power_adjust_ticks = TX_LOW_POWER_USER_TIMER_ADJUST;\n#else\n        tx_low_power_adjust_ticks = (ULONG) 0;\n#endif\n\n        /* Determine if the ThreadX timer needs incrementing.  */\n        if (tx_low_power_adjust_ticks)\n        {\n            /* Yes, the ThreadX time must be incremented.  */\n            tx_time_increment(tx_low_power_adjust_ticks);\n        }\n```\n\n----------------------------------------\n\nTITLE: Defining TX_LOW_POWER_TIMER_SETUP Macro in C\nDESCRIPTION: This example shows how to define the TX_LOW_POWER_TIMER_SETUP macro, which allows configuration of a hardware timer to wake the processor from sleep after a specified number of ThreadX ticks. The macro invokes the user-defined function `low_power_timer_config`, which needs to be implemented to configure the hardware timer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/low_power/low_power.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n/* Low power timer function prototype. */\nvoid low_power_timer_config(ULONG ticks);\n\n/* Define the TX_LOW_POWER_TIMER_SETUP macro. */\n#define TX_LOW_POWER_TIMER_SETUP low_power_timer_config\n\nvoid low_power_timer_config(ULONG ticks)\n{\n    /* Insert code here to configure a hardware timer\n       to wake the processor from sleep after\n       ticks/TX_TIMER_TICKS_PER_SECOND seconds. */\n}\n```\n\n----------------------------------------\n\nTITLE: Get IoTHub Device Info - C\nDESCRIPTION: This function retrieves the IoTHub hostname and device ID into user-supplied buffers. It requires a pointer to a `NX_AZURE_IOT_PROVISIONING_CLIENT`, and buffers for the hostname and device ID, along with their respective lengths. The function returns a status indicating success, invalid parameters, wrong state, or insufficient buffer space.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_provisioning_client.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_provisioning_client_iothub_device_info_get(NX_AZURE_IOT_PROVISIONING_CLIENT *prov_client_ptr,\n                                                             UCHAR *iothub_hostname, UINT *iothub_hostname_len,\n                                                             UCHAR *device_id, UINT *device_id_len);\n```\n\n----------------------------------------\n\nTITLE: Building Azure SDK for C from Command Prompt (Bash)\nDESCRIPTION: This snippet provides the commands to build the Azure SDK for C from the command prompt. It involves navigating to the project folder, creating a build directory, generating cmake files, and compiling the project. The generated files depend on the default C compiler used by the system.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# cd to project folder\ncd azure-sdk-for-c\n# create a new folder to generate cmake files for building (i.e. build)\nmkdir build\ncd build\n# generate files\n# cmake will automatically detect what C compiler is used by system by default and will generate files for it\ncmake ..\n# compile files. Cmake would call compiler and linker to generate libs\ncmake --build .\n```\n\n----------------------------------------\n\nTITLE: Entropy Injection in C\nDESCRIPTION: This code snippet shows the function prototype for injecting entropy into a random number generator context. The function `acme_add_entropy` takes a pointer to a `acme_random_context_t`, a pointer to an entropy buffer (`uint8_t *entropy`), and the size of the entropy buffer (`size_t entropy_size`) as input. It returns a `psa_status_t` to indicate success or failure. The core calls this function to supply entropy to the driver.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_35\n\nLANGUAGE: c\nCODE:\n```\npsa_status_t acme_add_entropy(acme_random_context_t *context,\n                              const uint8_t *entropy,\n                              size_t entropy_size);\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration for ThreadX Memory\nDESCRIPTION: This configuration snippet shows how to configure the EWARM linker file (.icf) to allocate memory for ThreadX dynamic memory allocation. It places the last section FREE_MEM in the RAM_region to define the starting address of the heap for dynamic allocation, which ThreadX uses.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_TCP_Echo_Server/README.md#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Defining Hash Operation Entry Points in C\nDESCRIPTION: This code snippet demonstrates the required type and entry points for a driver (with prefix 'acme') that implements the `hash_multipart` operation family. It includes definitions for setup, update, finish, and abort functions for hash operations.  It assumes the capability doesn't use the `names` property to declare different type and entry point names.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\ntypedef ... acme_hash_operation_t;\npsa_status_t acme_hash_setup(acme_hash_operation_t *operation,\n                             psa_algorithm_t alg);\npsa_status_t acme_hash_update(acme_hash_operation_t *operation,\n                              const uint8_t *input,\n                              size_t input_length);\npsa_status_t acme_hash_finish(acme_hash_operation_t *operation,\n                              uint8_t *hash,\n                              size_t hash_size,\n                              size_t *hash_length);\npsa_status_t acme_hash_abort(acme_hash_operation_t *operation);\n```\n\n----------------------------------------\n\nTITLE: Enabling PSA Crypto Support in Mbed TLS\nDESCRIPTION: To enable PSA cryptography support for X.509 and TLS code in Mbed TLS, you need to activate the `MBEDTLS_USE_PSA_CRYPTO` compilation option within the `mbedtls_config.h` file. This directs the X.509 and TLS code to utilize PSA cryptography for most operations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_20\n\nLANGUAGE: c\nCODE:\n```\n#define MBEDTLS_USE_PSA_CRYPTO\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation Configuration - STM32CubeIDE\nDESCRIPTION: This code snippet demonstrates how to add a new section in the STM32CubeIDE linker file to allocate memory for the ThreadX heap. It defines a `._threadx_heap` section, sets its size to 64KB, and locates it between the `.bss` and `._user_heap_stack` sections in the `RAM_D1` memory region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBPD/USBPD_SRC_UX_Host_MSC/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n  {\n    . = ALIGN(8);\n    __RAM_segment_used_end__ = .;\n    . = . + 64K;\n    . = ALIGN(8);\n  } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Conditional Inclusion of iperf Sources\nDESCRIPTION: This snippet conditionally includes the iperf source file (nx_iperf.c) into the target's sources if NXD_ENABLE_FILE_SERVERS is enabled. It uses CMake's `target_sources` command to add the specified source file to the project's build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/utility/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NXD_ENABLE_FILE_SERVERS)\n    target_sources(${PROJECT_NAME}\n        PRIVATE\n        # {{BEGIN_TARGET_SOURCES}}\n        ${CMAKE_CURRENT_LIST_DIR}/iperf/nx_iperf.c\n\n        # {{END_TARGET_SOURCES}}\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing Python dependencies for ROT_AppliConfig\nDESCRIPTION: This command installs the required Python modules for the python version of ROT_AppliConfig using pip, based on the packages listed in the requirements.txt file. It ensures the necessary dependencies are available for the Python tool to function correctly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ROT/OEMiROT_Appli_TrustZone/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Source Inclusion - Arctangent2 Functions\nDESCRIPTION: Includes source files for the arctangent2 function for f32, q31 and q15 data types.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(CMSISDSPFastMath PRIVATE arm_atan2_f32.c)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_atan2_q31.c)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_atan2_q15.c)\n```\n\n----------------------------------------\n\nTITLE: Enabling Thread-Safe Library Support in IAR\nDESCRIPTION: This configuration snippet demonstrates how to enable thread-safe support for the IAR tools when building ThreadX. It requires building both the ThreadX library and application with TX_ENABLE_IAR_LIBRARY_SUPPORT defined, and adding a specific line to the linker control file.  Ensure the 'Enable thread support in library' box is checked under 'General Options -> Library Configuration'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/iar/readme_threadx.txt#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\ninitialize by copy with packing = none { section __DLIB_PERTHREAD }; // Required in a multi-threaded application\n```\n\n----------------------------------------\n\nTITLE: Adding ThreadX Include Directories in CMake\nDESCRIPTION: This CMake snippet specifies the include directory for the ThreadX header files. The `target_include_directories` command adds the specified directory to the include search path for the given target. This allows the compiler to find the necessary header files during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Enabling p256-m in Mbed TLS with config.py\nDESCRIPTION: These python commands configure Mbed TLS to use p256-m by setting the necessary macros in `config.py`. The `MBEDTLS_PSA_CRYPTO_CONFIG` enables PSA crypto support, and `MBEDTLS_PSA_P256M_DRIVER_ENABLED` enables the p256-m driver. These commands must be run from the root of the `mbedtls/` directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-driver-example-and-guide.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\npython3 scripts/config.py set MBEDTLS_PSA_CRYPTO_CONFIG\npython3 scripts/config.py set MBEDTLS_PSA_P256M_DRIVER_ENABLED\nmake\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration\nDESCRIPTION: This snippet shows the required configuration in the STM32CubeIDE linker (.ld) file to properly allocate memory for ThreadX. It defines a new section named ._threadx_heap within the RAM_D1 region, allocating 64KB for the ThreadX heap.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_DualClass/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation based on TRANSPORT_PAHO\nDESCRIPTION: This snippet demonstrates conditional compilation based on the `TRANSPORT_PAHO` variable. The entire build configuration is only included if `TRANSPORT_PAHO` is defined. This allows for different build configurations depending on the transport protocol used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nif (TRANSPORT_PAHO)\n\n...\n\nendif() # TRANSPORT_PAHO\n```\n\n----------------------------------------\n\nTITLE: Handle custom ux_user.h file\nDESCRIPTION: This snippet configures the `ux_user.h` file for the USBX library.  If a custom file is provided (`UX_USER_FILE`), it's used; otherwise, a default sample is copied.  It also defines a compile definition `UX_INCLUDE_USER_DEFINE_FILE`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n# If the user provided an override, copy it to the custom directory\nif (NOT UX_USER_FILE)\n    message(STATUS \"Using default ux_user.h file\")\n    set(UX_USER_FILE ${CMAKE_CURRENT_LIST_DIR}/common/core/inc/ux_user_sample.h)\nelse()\n    message(STATUS \"Using custom ux_user.h file from ${UX_USER_FILE}\")\nendif()\nconfigure_file(${UX_USER_FILE} ${CUSTOM_INC_DIR}/ux_user.h COPYONLY)\ntarget_include_directories(${PROJECT_NAME} \n    PUBLIC \n    ${CUSTOM_INC_DIR}\n)\ntarget_compile_definitions(${PROJECT_NAME} PUBLIC \"UX_INCLUDE_USER_DEFINE_FILE\" )\n```\n\n----------------------------------------\n\nTITLE: Deleting Azure IoT Subsystem in C\nDESCRIPTION: This code snippet shows how to delete an Azure IoT subsystem using the `nx_azure_iot_delete` function. It takes a pointer to a `NX_AZURE_IOT` instance and stops all Azure services managed by the instance, cleaning up internal resources. It is essential to ensure that no resources are in use before calling this function.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nUINT  nx_azure_iot_delete(NX_AZURE_IOT *nx_azure_iot_ptr);\n```\n\n----------------------------------------\n\nTITLE: Makefile Configuration Example\nDESCRIPTION: This snippet demonstrates how to define MBEDTLS_CONFIG_FILE using make.  It sets the CFLAGS variable to include the path to the configuration file and defines the MBEDTLS_CONFIG_FILE macro. This method allows users to specify a custom configuration file outside of the Mbed TLS tree.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/configs/README.txt#_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\nCFLAGS=\"-I$PWD/configs -DMBEDTLS_CONFIG_FILE='<foo.h>'\" make\n```\n\n----------------------------------------\n\nTITLE: Adding Compile and Link Options\nDESCRIPTION: Adds compile options for debugging, diagnostics, and ThreadX integration, along with the selected build type configurations. Also includes link options to target the 'm32' architecture. Enables testing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_compile_options(\n  -m32\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  -DTX_INCLUDE_USER_DEFINE_FILE\n  ${${CMAKE_BUILD_TYPE}})\nadd_link_options(-m32)\n\nenable_testing()\n```\n\n----------------------------------------\n\nTITLE: Appending Component Begin to Reported Properties JSON Payload (C)\nDESCRIPTION: This routine appends the necessary characters to the beginning of a reported property JSON payload belonging to a subcomponent.  It prefixes the component name and type indicator in the JSON structure, preparing for property value additions.  Dependencies include NX_AZURE_IOT_HUB_CLIENT and NX_AZURE_IOT_JSON_WRITER.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client_properties.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_reported_properties_component_begin(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                                 NX_AZURE_IOT_JSON_WRITER *writer_ptr,\n                                                                 const UCHAR *component_name_ptr,\n                                                                 USHORT component_name_length);\n```\n\nLANGUAGE: c\nCODE:\n```\n\"reported\": {\n    \\\"<component_name>\\\": {\n        \\\"__t\\\": \\\"c\\\",\n        \\\"temperature\\\": 23\n    }\n}\n```\n\nLANGUAGE: c\nCODE:\n```\nnx_azure_iot_hub_client_reported_properties_component_end()\n```\n\n----------------------------------------\n\nTITLE: Linker configuration for STM32CubeIDE in .ld format\nDESCRIPTION: This snippet shows how to configure the linker file for STM32CubeIDE to define a new section named ._threadx_heap.  The heap size is set to 64KBytes in this example, and the section must be located between the .bss and the ._user_heap_stack sections in the linker script. This provides memory for ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_TCP_Echo_Client/README.md#_snippet_3\n\nLANGUAGE: other\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Converting ECDSA Signature Formats\nDESCRIPTION: This snippet describes the difference between the PSA API and the legacy API regarding ECDSA signature formats. The PSA API uses the raw fixed-size format, while the legacy API uses the ASN.1 DER format. It highlights the use of `mbedtls_ecdsa_raw_to_der` and `mbedtls_ecdsa_der_to_raw` for conversion.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_26\n\n\n\n----------------------------------------\n\nTITLE: Adding CMSIS-DSP as Subdirectory\nDESCRIPTION: This snippet adds the CMSIS-DSP source directory as a subdirectory, making its targets available to the project. The `bin_dsp` is the name assigned within this project to the DSP library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Validating Required Variables\nDESCRIPTION: Checks if the THREADX_ARCH and THREADX_TOOLCHAIN variables are defined. If not, a fatal error is raised, halting the CMake configuration process. These variables are expected to be defined externally.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT DEFINED THREADX_ARCH)\n    message(FATAL_ERROR \"Error: THREADX_ARCH not defined\")\nendif()\nif(NOT DEFINED THREADX_TOOLCHAIN)\n    message(FATAL_ERROR \"Error: THREADX_TOOLCHAIN not defined\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration for ThreadX Heap\nDESCRIPTION: This snippet demonstrates how to configure the linker file in EWARM to allocate memory for the ThreadX heap. The `place in RAM_region { last section FREE_MEM };` line ensures that the ThreadX heap is placed in the specified RAM region after the `FREE_MEM` section.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_MQTT_Client/README.md#_snippet_1\n\nLANGUAGE: OTHER\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Cortex-M ISR in C with ThreadX\nDESCRIPTION: This code snippet demonstrates the structure of an Interrupt Service Routine (ISR) written in C that is compatible with ThreadX on Cortex-M. The ISR can access ThreadX API functions available for ISRs. The 'your_C_isr' function must be an entry in the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/ac5/readme_threadx.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CMSIS-DSP Path\nDESCRIPTION: This snippet defines the path to the CMSIS-DSP library using the root directory (ROOT) and adds the DSP folder to the module path. The ROOT variable is intended to be defined on the command line.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_convolution_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Needed to include the configBoot module\n# Define the path to CMSIS-DSP (ROOT is defined on command line when using cmake)\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\n# Add DSP folder to module path\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: Navigating to Build Directory\nDESCRIPTION: Changes the current directory to the 'build' directory. This step ensures that subsequent build commands are executed from the correct location.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd build\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directory with target_include_directories in CMake\nDESCRIPTION: This snippet uses the `target_include_directories` command in CMake to add an include directory to a target named `${PROJECT_NAME}`. The include directory is specified as `${CMAKE_CURRENT_LIST_DIR}/inc`. The `PUBLIC` keyword ensures that this include directory is not only available to the specified target but also to any other targets that depend on it. This is essential for accessing header files defined within that directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: STM32 PHY Driver for Ethernet\nDESCRIPTION: This driver is needed by the nx_stm32_eth_driver.c to communicate with the RJ45 Phy interface. Two main versions are provided to support LAN8742 and RTL8211 phys.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n**nx_stm32_phy_driver.c**\n```\n\n----------------------------------------\n\nTITLE: Installing build tools and OpenSSL in Linux\nDESCRIPTION: This snippet installs essential build tools, curl, unzip, tar, pkg-config, git, OpenSSL, and libssl-dev using apt-get package manager.  It's necessary for compiling and running the Azure SDK for Embedded C samples. The commands update the package list and then install the required packages.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update\nsudo apt-get install build-essential curl unzip tar pkg-config git openssl libssl-dev\n```\n\n----------------------------------------\n\nTITLE: C ISR Example\nDESCRIPTION: Example of an Interrupt Service Routine (ISR) written in C for ThreadX. This ISR doesn't require explicit context saving or restoring and can directly access the ThreadX API available to ISRs. The ISR function must be entered into the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Key Import Function Prototype C\nDESCRIPTION: Defines the function prototype for the key import function, `acme_import_key`. This function imports a key into the system. It takes key attributes, the key data, the length of the data, a buffer for storing the key, the size of the buffer, a pointer to store the key length, and a pointer to store the key size in bits. The function returns a `psa_status_t` to indicate success or failure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_30\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_import_key(const psa_key_attributes_t *attributes,\n                             const uint8_t *data,\n                             size_t data_length,\n                             uint8_t *key_buffer,\n                             size_t key_buffer_size,\n                             size_t *key_buffer_length,\n                             size_t *bits); // additional parameter, see below\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration for ThreadX Heap\nDESCRIPTION: This snippet shows how to configure the linker file in STM32CubeIDE to allocate memory for the ThreadX heap. It defines a new section named `._threadx_heap` within the RAM_D1 region and specifies its size (64KB in this example).  It's crucial that this section is located between the .bss and ._user_heap_stack sections.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_MQTT_Client/README.md#_snippet_3\n\nLANGUAGE: OTHER\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: C Interrupt Service Routine (ISR) Example\nDESCRIPTION: This code snippet demonstrates a basic structure for writing an Interrupt Service Routine (ISR) in C for ThreadX on Cortex-M0. It shows the required function signature and provides a placeholder for interrupt handling logic. ISRs written in C can access the ThreadX API.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration for ThreadX Heap\nDESCRIPTION: This snippet shows how to configure the linker file in MDK-ARM to allocate memory for the ThreadX heap. It involves either defining the `RW_IRAM1` region in the scatter file or modifying the `tx_initialize_low_level.S` file to match the used memory region.  The example shows how to find the end of the RW_IRAM1 region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_MQTT_Client/README.md#_snippet_2\n\nLANGUAGE: OTHER\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Building ThreadX Libraries\nDESCRIPTION: Executes a script to build the ThreadX and FileX libraries, creates a custom target to ensure the libraries are built, and adds dependencies so that NetX Duo depends on the libraries.  Also configures include directories and links to the built libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\n# Build ThreadX library once\nexecute_process(COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh build_libs)\nadd_custom_target(build_libs ALL COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh\n                                         build_libs)\nadd_dependencies(netxduo build_libs)\ntarget_include_directories(netxduo PUBLIC ${CMAKE_BINARY_DIR}/../libs/inc)\nadd_library(threadx SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::threadx\" ALIAS threadx)\nset_target_properties(\n  threadx PROPERTIES IMPORTED_LOCATION\n                     ${CMAKE_BINARY_DIR}/../libs/threadx/libthreadx.so)\nadd_library(filex SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::filex\" ALIAS filex)\nset_target_properties(\n  filex PROPERTIES IMPORTED_LOCATION\n                   ${CMAKE_BINARY_DIR}/../libs/filex/libfilex.so)\ntarget_link_libraries(netxduo PUBLIC filex)\n```\n\n----------------------------------------\n\nTITLE: Starting Azure IoT ADU Agent in C\nDESCRIPTION: This code snippet shows the prototype for starting the Azure IoT ADU agent.  It initializes the agent with manufacturer, model, and installed criteria, and sets up callbacks for update notifications and driver operations. The function requires pointers to the ADU agent and IoT Hub client, as well as the lengths of the manufacturer, model, and installed criteria strings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_adu_agent.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_adu_agent_start(NX_AZURE_IOT_ADU_AGENT *adu_agent_ptr,\n                                  NX_AZURE_IOT_HUB_CLIENT *iothub_client_ptr,\n                                  const UCHAR *manufacturer, UINT manufacturer_length,\n                                  const UCHAR *model, UINT model_length,\n                                  const UCHAR *installed_criteria, UINT installed_criteria_length,\n                                  VOID (*adu_agent_update_notify)(NX_AZURE_IOT_ADU_AGENT *adu_agent_ptr,\n                                                                  UCHAR *provider, UINT provider_length,\n                                                                  UCHAR *name, UINT name_length,\n                                                                  UCHAR *version, UINT version_length),\n                                  VOID (*adu_agent_driver)(NX_AZURE_IOT_ADU_AGENT_DRIVER *));\n```\n\n----------------------------------------\n\nTITLE: Setting Toolchain File Based on Architecture\nDESCRIPTION: This snippet sets the `CMAKE_TOOLCHAIN_FILE` variable based on the operating system.  If `THREADX_ARCH` is not defined, it checks if the system is Windows or Unix and sets the toolchain file accordingly. If neither, it throws a fatal error.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT DEFINED THREADX_ARCH)\n  if(WIN32)\n    set(CMAKE_TOOLCHAIN_FILE\n        \"configs/win32.cmake\"\n        CACHE STRING \"\")\n  elseif(UNIX)\n    set(CMAKE_TOOLCHAIN_FILE\n        \"configs/linux.cmake\"\n        CACHE STRING \"\")\n  else()\n    message(FATAL_ERROR \"Error: Architecture not supported\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting IoT Provisioning SAS Environment Variables - PowerShell\nDESCRIPTION: This code snippet shows how to set the AZ_IOT_PROVISIONING_SAS_REGISTRATION_ID, AZ_IOT_PROVISIONING_SAS_KEY, and AZ_IOT_PROVISIONING_ID_SCOPE environment variables in PowerShell for DPS SAS authentication. Replace `<sas-registration-id>`, `<sas-key>`, and `<id-scope>` with the correct values from your Azure IoT Hub Device Provisioning Service.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_22\n\nLANGUAGE: powershell\nCODE:\n```\n$env:AZ_IOT_PROVISIONING_SAS_REGISTRATION_ID='<sas-registration-id>'\n$env:AZ_IOT_PROVISIONING_SAS_KEY='<sas-key>'\n$env:AZ_IOT_PROVISIONING_ID_SCOPE='<id-scope>'\n  \n```\n\n----------------------------------------\n\nTITLE: Modify XML Value with Function Option (Bash)\nDESCRIPTION: This command forces the modification of an XML parameter's `<Value>` tag using `xmlval` with a provided value, filtering by either `<Name>` or `<Command>`. The `<Value>` tag of the matching parameters will be replaced by the new value. It requires a new value to be set and filters by command.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nxmval -v 0x6500 -c -S OEMiRoT_Secure_Code.xml\n```\n\n----------------------------------------\n\nTITLE: Setting Trust PEM Filepath Environment Variable - PowerShell\nDESCRIPTION: This code snippet shows how to set the AZ_IOT_DEVICE_X509_TRUST_PEM_FILE_PATH environment variable in PowerShell. This variable is used to specify the path to the PEM file containing trusted root certificates for X.509 authentication on Windows. Replace '<FULL PATH TO>\\CAStore.pem' with the actual path to your CAStore.pem file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_14\n\nLANGUAGE: powershell\nCODE:\n```\n$env:AZ_IOT_DEVICE_X509_TRUST_PEM_FILE_PATH='<FULL PATH TO>\\CAStore.pem'\n```\n\n----------------------------------------\n\nTITLE: Defining regression test cases\nDESCRIPTION: This snippet defines a variable `regression_test_cases` that lists all the C source files to be used as test cases. The variable uses an absolute path based on `CMAKE_CURRENT_LIST_DIR` to point to the `regression` directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../regression)\n\nset(regression_test_cases\n    ${SOURCE_DIR}/threadx_block_memory_basic_test.c\n    ${SOURCE_DIR}/threadx_block_memory_error_detection_test.c\n    ${SOURCE_DIR}/threadx_block_memory_information_test.c\n    ${SOURCE_DIR}/threadx_block_memory_prioritize_test.c\n    ${SOURCE_DIR}/threadx_block_memory_suspension_test.c\n    ${SOURCE_DIR}/threadx_block_memory_suspension_timeout_test.c\n    ${SOURCE_DIR}/threadx_block_memory_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_basic_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_information_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_prioritize_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_suspension_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_suspension_timeout_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_thread_contention_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_event_flag_basic_test.c\n    ${SOURCE_DIR}/threadx_event_flag_information_test.c\n    ${SOURCE_DIR}/threadx_event_flag_isr_set_clear_test.c\n    ${SOURCE_DIR}/threadx_event_flag_isr_wait_abort_test.c\n    ${SOURCE_DIR}/threadx_event_flag_single_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_event_flag_suspension_consume_test.c\n    ${SOURCE_DIR}/threadx_event_flag_suspension_different_bits_consume_test.c\n    ${SOURCE_DIR}/threadx_event_flag_suspension_different_bits_test.c\n    ${SOURCE_DIR}/threadx_event_flag_suspension_test.c\n    ${SOURCE_DIR}/threadx_event_flag_suspension_timeout_test.c\n    ${SOURCE_DIR}/threadx_event_flag_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_interrupt_control_test.c\n    ${SOURCE_DIR}/threadx_mutex_basic_test.c\n    ${SOURCE_DIR}/threadx_mutex_delete_test.c\n    ${SOURCE_DIR}/threadx_mutex_information_test.c\n    ${SOURCE_DIR}/threadx_mutex_nested_priority_inheritance_test.c\n    ${SOURCE_DIR}/threadx_mutex_no_preemption_test.c\n    ${SOURCE_DIR}/threadx_mutex_preemption_test.c\n    ${SOURCE_DIR}/threadx_mutex_priority_inheritance_test.c\n    ${SOURCE_DIR}/threadx_mutex_proritize_test.c\n    ${SOURCE_DIR}/threadx_mutex_suspension_timeout_test.c\n    ${SOURCE_DIR}/threadx_mutex_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_queue_basic_eight_word_test.c\n    ${SOURCE_DIR}/threadx_queue_basic_four_word_test.c\n    ${SOURCE_DIR}/threadx_queue_basic_one_word_test.c\n    ${SOURCE_DIR}/threadx_queue_basic_sixteen_word_test.c\n    ${SOURCE_DIR}/threadx_queue_basic_two_word_test.c\n    ${SOURCE_DIR}/threadx_queue_empty_suspension_test.c\n    ${SOURCE_DIR}/threadx_queue_flush_no_suspension_test.c\n    ${SOURCE_DIR}/threadx_queue_flush_test.c\n    ${SOURCE_DIR}/threadx_queue_front_send_test.c\n    ${SOURCE_DIR}/threadx_queue_full_suspension_test.c\n    ${SOURCE_DIR}/threadx_queue_information_test.c\n    ${SOURCE_DIR}/threadx_queue_prioritize.c\n    ${SOURCE_DIR}/threadx_queue_suspension_timeout_test.c\n    ${SOURCE_DIR}/threadx_queue_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_semaphore_basic_test.c\n    ${SOURCE_DIR}/threadx_semaphore_ceiling_put_test.c\n    ${SOURCE_DIR}/threadx_semaphore_delete_test.c\n    ${SOURCE_DIR}/threadx_semaphore_information_test.c\n    ${SOURCE_DIR}/threadx_semaphore_non_preemption_test.c\n    ${SOURCE_DIR}/threadx_semaphore_preemption_test.c\n    ${SOURCE_DIR}/threadx_semaphore_prioritize.c\n    ${SOURCE_DIR}/threadx_semaphore_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_semaphore_timeout_test.c\n    ${SOURCE_DIR}/threadx_thread_basic_execution_test.c\n    ${SOURCE_DIR}/threadx_thread_basic_time_slice_test.c\n    ${SOURCE_DIR}/threadx_thread_completed_test.c\n    ${SOURCE_DIR}/threadx_thread_create_preemption_threshold_test.c\n    ${SOURCE_DIR}/threadx_thread_delayed_suspension_test.c\n    ${SOURCE_DIR}/threadx_thread_information_test.c\n    ${SOURCE_DIR}/threadx_thread_multi_level_preemption_threshold_test.c\n    ${SOURCE_DIR}/threadx_thread_multiple_non_current_test.c\n    ${SOURCE_DIR}/threadx_thread_multiple_sleep_test.c\n    ${SOURCE_DIR}/threadx_thread_multiple_suspension_test.c\n    ${SOURCE_DIR}/threadx_thread_multiple_time_slice_test.c\n    ${SOURCE_DIR}/threadx_thread_preemptable_suspension_test.c\n    ${SOURCE_DIR}/threadx_thread_preemption_change_test.c\n    ${SOURCE_DIR}/threadx_thread_priority_change.c\n    ${SOURCE_DIR}/threadx_thread_relinquish_test.c\n    ${SOURCE_DIR}/threadx_thread_reset_test.c\n    ${SOURCE_DIR}/threadx_thread_simple_sleep_non_clear_test.c\n    ${SOURCE_DIR}/threadx_thread_simple_sleep_test.c\n    ${SOURCE_DIR}/threadx_thread_simple_suspend_test.c\n    ${SOURCE_DIR}/threadx_thread_sleep_for_100ticks_test.c\n    ${SOURCE_DIR}/threadx_thread_sleep_terminate_test.c\n    ${SOURCE_DIR}/threadx_thread_stack_checking_test.c\n    ${SOURCE_DIR}/threadx_thread_terminate_delete_test.c\n    ${SOURCE_DIR}/threadx_thread_time_slice_change_test.c\n    ${SOURCE_DIR}/threadx_thread_wait_abort_and_isr_test.c\n    ${SOURCE_DIR}/threadx_thread_wait_abort_test.c\n    ${SOURCE_DIR}/threadx_time_get_set_test.c\n    ${SOURCE_DIR}/threadx_timer_activate_deactivate_test.c\n    ${SOURCE_DIR}/threadx_timer_deactivate_accuracy_test.c\n    ${SOURCE_DIR}/threadx_timer_information_test.c\n    ${SOURCE_DIR}/threadx_timer_large_timer_accuracy_test.c\n    ${SOURCE_DIR}/threadx_timer_multiple_accuracy_test.c\n    ${SOURCE_DIR}/threadx_timer_multiple_test.c\n    ${SOURCE_DIR}/threadx_timer_simple_test.c\n    ${SOURCE_DIR}/threadx_trace_basic_test.c\n    ${SOURCE_DIR}/threadx_initialize_kernel_setup_test.c)\n```\n\n----------------------------------------\n\nTITLE: Opaque Driver Persistent State Functions in C\nDESCRIPTION: These are the callback functions provided by the PSA Cryptography core for opaque drivers to manage persistent state. `psa_crypto_driver_get_persistent_state` retrieves a pointer to the persistent state. `psa_crypto_driver_commit_persistent_state` updates the persistent state in persistent storage.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_49\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_crypto_driver_get_persistent_state(uint_8_t **persistent_state_ptr);\npsa_status_t psa_crypto_driver_commit_persistent_state(size_t from, size_t length);\n```\n\n----------------------------------------\n\nTITLE: Customizing USART Commands List in OpenBootloader (C)\nDESCRIPTION: This code snippet demonstrates how to customize the list of supported commands for the USART interface in the OpenBootloader application. It defines a custom command structure `OPENBL_CommandsTypeDef` and assigns function pointers to the `OPENBL_USART_ReadMemory` and `OPENBL_USART_WriteMemory` functions, effectively limiting the supported commands to read and write operations. The USART handle is then initialized with this custom command list, and the list is registered within the middleware.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/OpenBootloader/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nOPENBL_CommandsTypeDef USART_Cmd =\n{\n  NULL,\n  NULL,\n  NULL,\n  OPENBL_USART_ReadMemory,\n  OPENBL_USART_WriteMemory,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL,\n  NULL\n};\n\nUSART_Handle.p_Ops = &USART_Ops;\nUSART_Handle.p_Cmd = &USART_Cmd;           /* Initialize the USART handle with the list of supported commands */\nOPENBL_USART_SetCommandsList(&USART_Cmd);  /* Register the list of supported commands in MW side */\n```\n\n----------------------------------------\n\nTITLE: Master Board Transmit and Receive using Interrupts in C\nDESCRIPTION: The HAL_I2C_Master_Transmit_IT() and HAL_I2C_Master_Receive_IT() functions facilitate the transmission and reception of data between a master and slave, utilizing interrupts. These functions enable non-blocking communication, allowing the microcontroller to perform other tasks while data transfer is in progress. The functions require the I2C handle, slave address, data buffer, and data size as input.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples/I2C/I2C_TwoBoards_AdvComIT/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nHAL_I2C_Master_Receive_IT()\nHAL_I2C_Master_Transmit_IT()\n```\n\n----------------------------------------\n\nTITLE: Adding USB Source Files using CMake\nDESCRIPTION: This snippet demonstrates how to add multiple C source files to a CMake project using the `target_sources` command. It includes various source files related to USB device and host functionalities within the STM32CubeH5 project. The files are added as PRIVATE sources to the specified target, meaning they are only used when building that target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/core/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_address_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_endpoint_destroy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_endpoint_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_endpoint_stall.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_endpoint_status.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_frame_number_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_function.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_initialize_complete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_state_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_transfer_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_transfer_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_dcd_sim_slave_transfer_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dpump_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dpump_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dpump_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dpump_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dpump_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dpump_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dpump_read_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dpump_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dpump_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dpump_write_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_alternate_setting_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_alternate_setting_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_class_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_class_unregister.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_clear_feature.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_configuration_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_configuration_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_control_request_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_descriptor_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_disconnect.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_endpoint_stall.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_get_status.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_host_wakeup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_interface_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_interface_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_interface_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_interface_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_microsoft_extension_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_set_feature.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_transfer_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_transfer_all_request_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_transfer_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_transfer_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_stack_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_asynch_queue_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_asynch_schedule.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_asynchronous_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_asynchronous_endpoint_destroy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_controller_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_ed_obtain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_ed_td_clean.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_endpoint_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_frame_number_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_frame_number_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_interrupt_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_iso_queue_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_iso_schedule.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_isochronous_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_isochronous_td_obtain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_least_traffic_list_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_periodic_endpoint_destroy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_periodic_schedule.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_periodic_tree_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_port_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_port_status_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_regular_td_obtain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_request_bulk_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_request_control_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_request_interupt_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_request_isochronous_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_request_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_timer_function.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_transaction_schedule.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_transfer_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_transfer_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_sim_host_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_dpump_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_dpump_configure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_dpump_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_dpump_endpoints_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_dpump_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_dpump_ioctl.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_dpump_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_dpump_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_bandwidth_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_bandwidth_claim.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_bandwidth_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_class_call.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_class_device_scan.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_class_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_class_instance_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_class_instance_destroy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_class_instance_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_class_instance_verify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_class_interface_scan.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_class_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_class_unregister.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_configuration_descriptor_parse.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_configuration_enumerate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_configuration_instance_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_configuration_instance_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_configuration_interface_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_configuration_interface_scan.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_configuration_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_delay_ms.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_address_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_configuration_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_configuration_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_configuration_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_configuration_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_configuration_select.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_descriptor_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_string_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_remove.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_device_resources_free.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_endpoint_instance_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_endpoint_instance_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_endpoint_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_endpoint_transfer_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_enum_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_hcd_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_hcd_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_hcd_transfer_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_hcd_unregister.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_hnp_polling_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_interface_endpoint_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_interface_instance_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_interface_instance_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_interface_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_interface_setting_select.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_interfaces_scan.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_new_configuration_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_new_device_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_new_device_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_new_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_new_interface_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_rh_change_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_rh_device_extraction.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_rh_device_insertion.c\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories and Compile Definitions for MbedTLS Target in CMake\nDESCRIPTION: This CMake code sets the include directories and compile definitions for a specified MbedTLS target.  It configures public and private include paths, passes through configuration file definitions, and ensures proper permissions are set during installation. Key variables used include `${target}`, `${MBEDTLS_DIR}`, `MBEDTLS_CONFIG_FILE`, and `MBEDTLS_USER_CONFIG_FILE`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_18\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${target}\n        PUBLIC $<BUILD_INTERFACE:${MBEDTLS_DIR}/include/>\n               $<INSTALL_INTERFACE:include/>\n        PRIVATE ${MBEDTLS_DIR}/library/\n                # Needed to include psa_crypto_driver_wrappers.h\n                ${CMAKE_CURRENT_BINARY_DIR})\n    # Pass-through MBEDTLS_CONFIG_FILE and MBEDTLS_USER_CONFIG_FILE\n    if(MBEDTLS_CONFIG_FILE)\n        target_compile_definitions(${target}\n            PUBLIC MBEDTLS_CONFIG_FILE=\"${MBEDTLS_CONFIG_FILE}\")\n    endif()\n    if(MBEDTLS_USER_CONFIG_FILE)\n        target_compile_definitions(${target}\n            PUBLIC MBEDTLS_USER_CONFIG_FILE=\"${MBEDTLS_USER_CONFIG_FILE}\")\n    endif()\n    install(\n        TARGETS ${target}\n        EXPORT MbedTLSTargets\n        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n        PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ)\n```\n\n----------------------------------------\n\nTITLE: Creating a Static Library in CMake\nDESCRIPTION: This snippet creates a static library named cmsis-nn. It also sets compile options for this library, specifically -Ofast, which enables aggressive optimizations for speed.  It defines include directories for the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(cmsis-nn STATIC)\n\ntarget_compile_options(cmsis-nn PRIVATE -Ofast)\n\n### Includes\ntarget_include_directories(cmsis-nn PUBLIC \"${NN}/Include\")\ntarget_include_directories(cmsis-nn PUBLIC \"${ROOT}/CMSIS/Core/Include\")\ntarget_include_directories(cmsis-nn PUBLIC \"${ROOT}/CMSIS/DSP/Include\")\n```\n\n----------------------------------------\n\nTITLE: Setting Libraries in CMake\nDESCRIPTION: This snippet sets the `libs` variable to contain the `mbedx509_target` library. This variable is later used to link the executables against this library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/x509/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(libs\n    ${mbedx509_target}\n)\n```\n\n----------------------------------------\n\nTITLE: C ISR Example: ThreadX Cortex-M3\nDESCRIPTION: Defines an Interrupt Service Routine (ISR) written in C for ThreadX on Cortex-M3.  The ISR performs processing without requiring explicit context save/restore calls and can access ThreadX API functions available to ISRs. \"your_C_isr\" must be an entry in the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/keil/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Definition for Cortex-M55 with IAR\nDESCRIPTION: This code snippet demonstrates how to define an Interrupt Service Routine (ISR) in assembly language for the Cortex-M architecture using the IAR toolchain. The ISR saves and restores necessary registers and performs the interrupt handling logic.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/iar/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n    PUBLIC  your_assembly_isr\nyour_assembly_isr:\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure IoT Hub Provisioning Client\nDESCRIPTION: This code snippet shows configuration settings for the `azureProvisioningClientSample.c` file. It contains definitions for the host, certificate file path, X509 certificate paths, registration ID, ID Scope, global endpoint, and primary key. The user must update these to correspond with their Azure IoT Hub Provisioning Service and device enrollment details.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_vxworks.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n/*\n * Define X509_CERTIFICATE to use user-generated Root Certificate.\n * If you only want to use SAS, undefine or comment out this macro.\n */\n#define X509_CERTIFICATE\n\n/*\n * Host name can be found via:\n * Azure IoT Hub Provisioning Service -> Overview -> Global device endpoint\n */\n#define HOST \"global.azure-devices-provisioning.net\"\n\n/*\n * Server certificate file path. It can be found in:\n * https://github.com/Azure/azure-iot-sdk-c/blob/master/certs/certs.c\n *\n * Copy all the sections beginning with “-----BEGIN CERTIFICATE-----” and\n * ending with “-----END CERTIFICATE-----” into a file with an extension “pem”\n * like “certs.pem”. Remove all the beginning and ending double quotes and\n * “\\r\\n”.\n * -----BEGIN CERTIFICATE-----\n * MIIDdzCCAl+gAwIBAgIEAgAAuTANBgkqhkiG9w0BAQUFADBaMQswCQYDVQQGEwJJ\n * RTESMBAGA1UEChMJQmFsdGltb3JlMRMwEQYDVQQLEwpDeWJlclRydXN0MSIwIAYD\n * …………………………………………………………………………..\n * …………………………………………………………………………..\n * Epn3o0WC4zxe9Z2etciefC7IpJ5OCBRLbf1wbWsaY71k5h+3zvDyny67G7fyUIhz\n * ksLi4xaNmjICq44Y3ekQEe5+NauQrz4wlHrQMz2nZQ/1/I6eYs9HRCwBXbsdtTLS\n * R9I4LtD+gdwyah617jzV/OeBHRnDJELqYzmp\n * -----END CERTIFICATE-----\n */\n#define CERT_FILE \"/romfs/certs/cert.pem\"\n\n/* X509 certificate file and private key file paths */\n/*\n * X509 user-generated Root Certificate guide:\n * https://github.com/Azure/azure-iot-sdk-c/blob/master/tools\n * /CACertificates/CACertificateOverview.md\n */\n#ifdef X509_CERTIFICATE\n#define X509_CERT_FILE \"/romfs/certs/[X509 certificate].pem\"\n#define X509_KEY_FILE \"/romfs/certs/[X509 Private Key].pem\"\n#else\n#define X509_CERT_FILE NULL\n#define X509_KEY_FILE NULL\n#endif\n\n/*\n * Registration ID is the name of each enrollment. Can be found via:\n * Azure IoT Hub Provisioning Service -> Manage Enrollments\n *  -> Individual Enrollment\n */\n#ifdef X509_CERTIFICATE\nstatic az_span const provisioningRegId =\n    AZ_SPAN_LITERAL_FROM_STR (\"[Registration ID with X509]\");\n#else\nstatic az_span const provisioningRegId =\n    AZ_SPAN_LITERAL_FROM_STR (\"[Registration ID with SAS]\");\n#endif /* X509_CERTIFICATE */\n\n/*\n * ID Scope can be found via:\n * Azure IoT Hub Provisioning Service -> Overview -> ID Scope\n */\nstatic az_span const provisioningIdScope =\n    AZ_SPAN_LITERAL_FROM_STR (\"[ID Scope string]\");\n\n/*\n * Global Endpoint can be found via:\n * Azure IoT Hub Provisioning Service -> Overview -> Global device endpoint\n * and add prefix \"ssl://\" as well as suffix \":8883\"\n */\nstatic char provisioningGlobalEndpoint[] =\n    \"ssl://global.azure-devices-provisioning.net:8883\";\n\n/*\n * Primary Key is only needed by SAS enrollment.\n * It can be found via:\n * Azure IoT Hub Provisioning Service -> Manage Enrollments\n *  -> Individual Enrollment -> one specific enrollment -> Primary Key\n */\nstatic char provisioningPrimaryKey[] = \"ch/EsBKjGNEHLc1h...\";\n```\n\n----------------------------------------\n\nTITLE: Enabling PSA Crypto Configuration in Mbed TLS\nDESCRIPTION: The `MBEDTLS_PSA_CRYPTO_CONFIG` compilation option allows you to enable PSA cryptographic mechanisms without including the code of the corresponding software implementation. This is particularly useful when using hardware drivers for cryptographic operations, reducing the overall code size.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_21\n\nLANGUAGE: c\nCODE:\n```\n#define MBEDTLS_PSA_CRYPTO_CONFIG\n```\n\n----------------------------------------\n\nTITLE: Byte Manipulation and Buffer Pointer Checks in MBedTLS\nDESCRIPTION: This snippet demonstrates the use of macros for byte manipulation and buffer pointer checks in MBedTLS. It shows how to write data to a buffer using MBEDTLS_BYTE_2 and MBEDTLS_PUT_UINT16_BE, and how to verify sufficient buffer space with MBEDTLS_SSL_CHK_BUF_PTR.  These macros improve readability and reduce risks of buffer overflows or incorrect byte order.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/tls13-support.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nhs_hdr[1] = MBEDTLS_BYTE_2( total_hs_len );\nMBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SUPPORTED_VERSIONS, p, 0 );\nMBEDTLS_SSL_CHK_BUF_PTR( p, end, 7 );\n```\n\n----------------------------------------\n\nTITLE: Setting Build Configurations\nDESCRIPTION: This snippet defines a variable named `BUILD_CONFIGURATIONS` and assigns a list of different build configurations to it. These configurations likely represent different build variants with specific features enabled or disabled, such as coverage reports, TLS versions, or security features (e.g., EAL4). These configurations can be used later in the CMake file to conditionally configure the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_CONFIGURATIONS\n    default_build_coverage\n    psk_build_coverage\n    tls_1_0_enable_build\n    tls_1_1_enable_build\n    tls_1_3_enable_build_coverage\n    client_disable_build\n    server_disable_build\n    tls_1_3_client_disable_build\n    tls_1_3_server_disable_build\n    ecjpake_build\n    dtls_build_coverage\n    eal4_build_coverage\n    sesip_build_coverage\n    no_ecc_build_coverage\n    no_renegotiation_build\n    no_client_renegotiation_build\n    hash_clone_build\n    curve25519_448_build)\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation - STM32CubeIDE\nDESCRIPTION: This snippet demonstrates how to add a memory section for ThreadX in the STM32CubeIDE linker script (.ld). It defines a ._threadx_heap section within the RAM_D1 region, allocating 64KB of memory for ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Applications/USBX/Ux_Device_CDC_ACM/README.md#_snippet_2\n\nLANGUAGE: LD\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration for ThreadX Dynamic Memory Allocation\nDESCRIPTION: This snippet shows how to configure the EWARM linker file (.icf) to enable dynamic memory allocation for ThreadX. It places the last section FREE_MEM in the RAM_region to define the end of the used memory, allowing ThreadX to manage the remaining space as a heap.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Device_DFU/README.md#_snippet_0\n\nLANGUAGE: Other\nCODE:\n```\nplace in RAM_region { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Building CMSIS-NN with CMake\nDESCRIPTION: These commands demonstrate how to build the CMSIS-NN library using CMake, specifying the toolchain file and target CPU.  It includes steps to create a build directory, navigate into it, run CMake with the necessary parameters, and then compile the library using make. The examples assume the 'ethos-u-core-platform' project is available and provide configurations for different Cortex-M processors.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/README.md#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncd </path/to/CMSIS_5>/CMSIS/NN\nmkdir build\ncd build\ncmake .. -DCMAKE_TOOLCHAIN_FILE=</path/to/ethos-u-core-platform>/cmake/toolchain/arm-none-eabi-gcc.cmake -DTARGET_CPU=cortex-m55\nmake\n```\n\n----------------------------------------\n\nTITLE: Cloning Azure SDK for C Repository\nDESCRIPTION: This snippet clones the Azure SDK for C repository from GitHub. It is important to clone this repository to access the necessary source code and samples.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/Azure/azure-sdk-for-c.git\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows how to configure the EWARM linker file to allocate memory for ThreadX when using dynamic memory allocation. The `place in RAM_region { last section FREE_MEM };` line places the `FREE_MEM` section in the `RAM_region`, which is necessary for ThreadX to find the first free memory location.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBPD/USBPD_SRC/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: UART Console Configuration\nDESCRIPTION: This snippet provides the UART configuration parameters needed to view the application menu. Configure your UART console with these settings to communicate with the STM32H5 device.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ROT/STiROT_Appli/README.md#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nSpeed: 115200, Data: 8bits, Parity: None, stop bits: 1, Flow control: none.\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation Configuration for STM32CubeIDE\nDESCRIPTION: This code snippet shows how to configure the ThreadX memory allocation in the .ld linker file for STM32CubeIDE. It defines a new section `._threadx_heap` within the RAM_D1 region, allocating 64KB for the ThreadX heap.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_Iperf_wifi/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n        {\n         . = ALIGN(8);\n         __RAM_segment_used_end__ = .;\n         . = . + 64K;\n         . = ALIGN(8);\n        } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Thread Extension Configuration in tx_user.h (C)\nDESCRIPTION: This code snippet defines a thread user extension within the `TX_THREAD` data structure. This is required by the adaptation layer to store thread-related data. Failure to add this configuration to `tx_user.h` will result in a compilation error.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/FreeRTOS/readme.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define TX_THREAD_USER_EXTENSION VOID *txfr_thread_ptr;\n```\n\n----------------------------------------\n\nTITLE: Setting Key Enrollment Algorithm PSA\nDESCRIPTION: This code snippet explains how to permit a second algorithm or wildcard using the `psa_set_key_enrollment_algorithm` function. This is for scenarios where a key is normally used with a single algorithm, but needs to be used with a different algorithm for enrollment.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_17\n\nLANGUAGE: C\nCODE:\n```\npsa_set_key_enrollment_algorithm\n```\n\n----------------------------------------\n\nTITLE: Getting the Source Directory\nDESCRIPTION: This snippet retrieves the absolute path to the source directory where the regression test files are located. It uses `get_filename_component` to extract the absolute path from the current list directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../regression\n                       ABSOLUTE)\n```\n\n----------------------------------------\n\nTITLE: Select CMSIS-DSP Components\nDESCRIPTION: Defines options to select which parts of the CMSIS-DSP library should be compiled, such as Basic Math Functions, Complex Math Functions, Controller Functions, etc.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\noption(BASICMATH            \"Basic Math Functions\"              ON)\noption(COMPLEXMATH          \"Complex Math Functions\"            ON)\noption(CONTROLLER           \"Controller Functions\"              ON)\noption(FASTMATH             \"Fast Math Functions\"               ON)\noption(FILTERING            \"Filtering Functions\"               ON)\noption(MATRIX               \"Matrix Functions\"                  ON)\noption(STATISTICS           \"Statistics Functions\"              ON)\noption(SUPPORT              \"Support Functions\"                 ON)\noption(TRANSFORM            \"Transform Functions\"               ON)\noption(SVM                  \"Support Vector Machine Functions\"  ON)\noption(BAYES                \"Bayesian Estimators\"               ON)\noption(DISTANCE             \"Distance Functions\"                ON)\noption(INTERPOLATION        \"Interpolation Functions\"                ON)\noption(QUATERNIONMATH       \"Quaternion Math Functions\"                ON)\n```\n\n----------------------------------------\n\nTITLE: Generate Key Prototype - C\nDESCRIPTION: Defines the function prototype for the `generate_key` entry point in a PSA opaque driver. This function generates a key within the driver. It takes key attributes, a key buffer, its size, and a pointer to store the key buffer length as input, and returns a PSA status.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_46\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_generate_key(const psa_key_attributes_t *attributes,\n                               uint8_t *key_buffer,\n                               size_t key_buffer_size,\n                               size_t *key_buffer_length);\n```\n\n----------------------------------------\n\nTITLE: Configuring Include Directories with CMake\nDESCRIPTION: This snippet uses the `target_include_directories` command in CMake to specify a public include directory for the project. The `${PROJECT_NAME}` variable refers to the name of the project, and the `PUBLIC` keyword indicates that the specified include directory is available to other targets that depend on this one.  `${CMAKE_CURRENT_LIST_DIR}/inc` specifies the 'inc' subdirectory within the current CMake list file's directory as an include directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/ports/cortex_m0/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration\nDESCRIPTION: This snippet shows the necessary configuration to add to the EWARM linker file (.icf) to define the memory region for ThreadX. This allows ThreadX to manage memory dynamically.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Applications/ThreadX/Tx_LowPower/README.md#_snippet_0\n\nLANGUAGE: Other\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Initializing JSON Reader with Buffer in C\nDESCRIPTION: Initializes an NX_AZURE_IOT_JSON_READER to read a JSON payload from a provided buffer.  It requires a pointer to the reader instance, a pointer to the buffer containing the JSON data, and the length of the buffer. On success, it returns NX_AZURE_IOT_SUCCESS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_with_buffer_init(NX_AZURE_IOT_JSON_READER *reader_ptr,\n                                               const UCHAR *buffer_ptr, UINT buffer_len);\n```\n\n----------------------------------------\n\nTITLE: Combine Certificate and Key, Generate Fingerprint (OpenSSL)\nDESCRIPTION: These commands combine the device certificate and key into a single PEM file, and then generate the SHA1 fingerprint of the certificate. The fingerprint is stored in `fingerprint.txt` for use in Azure IoT Hub device registration. Requires OpenSSL to be installed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_6\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS C:\\azure-sdk-for-c\\sdk\\samples\\iot> Get-Content device_ec_cert.pem, device_ec_key.pem | Set-Content device_cert_store.pem\nPS C:\\azure-sdk-for-c\\sdk\\samples\\iot> openssl x509 -noout -fingerprint -in device_ec_cert.pem | % {$_.replace(\":\", \"\")} | % {$_.replace(\"SHA1 Fingerprint=\", \"\")} | Tee-Object fingerprint.txt\n```\n\n----------------------------------------\n\nTITLE: Default FIQ Handler in ThreadX Assembly\nDESCRIPTION: This code snippet shows the default FIQ handler defined in `tx_initialize_low_level.s`. It saves the system context by jumping to `_tx_thread_fiq_context_save` and restores it by jumping to `_tx_thread_fiq_context_restore`. Application FIQ handlers can be called between context save and restore.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/cortex_a7_smp/ac5/readme_threadx.txt#_snippet_3\n\nLANGUAGE: assembly\nCODE:\n```\nEXPORT  __tx_fiq_handler\nEXPORT  __tx_fiq_processing_return\n__tx_fiq_handler\n;\n;    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return:\n;\n;    /* At this point execution is still in the FIQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use.  */\n;\n;    /* Application FIQ handlers can be called here!  */\n;\n;    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: ECDSA Algorithm Constructors in PSA API\nDESCRIPTION: This snippet describes three algorithm constructors for ECDSA in the PSA API: `PSA_ALG_ECDSA(hash)`, `PSA_ALG_ECDSA_ANY`, and `PSA_ALG_DETERMINISTIC_ECDSA(hash)`. It explains the differences in signature behavior and usage with `psa_sign_hash` and `psa_verify_hash`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_27\n\n\n\n----------------------------------------\n\nTITLE: CMake Build Examples\nDESCRIPTION: These are example CMake commands for building CMSIS-NN, configured for different ARM Cortex-M processors. They specify the toolchain file and the target CPU architecture, which are essential for cross-compilation. The examples show how to configure the build system for Cortex-M55, Cortex-M7, and Cortex-M3.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/README.md#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ncmake .. -DCMAKE_TOOLCHAIN_FILE=~/ethos-u-core-platform/cmake/toolchain/arm-none-eabi-gcc.cmake -DTARGET_CPU=cortex-m55\ncmake .. -DCMAKE_TOOLCHAIN_FILE=~/ethos-u-core-platform/cmake/toolchain/arm-none-eabi-gcc.cmake -DTARGET_CPU=cortex-m7\ncmake .. -DCMAKE_TOOLCHAIN_FILE=~/ethos-u-core-platform/cmake/toolchain/armclang.cmake -DTARGET_CPU=cortex-m3\n```\n\n----------------------------------------\n\nTITLE: Key Generate Function Prototype C\nDESCRIPTION: Defines the function prototype for the key generation function, `acme_generate_key`. This function generates a new key. It takes the key attributes, a buffer for storing the key, the size of the buffer, and a pointer to store the key length as parameters. Returns a `psa_status_t` indicating the success or failure of the operation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_31\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_generate_key(const psa_key_attributes_t *attributes,\n                               uint8_t *key_buffer,\n                               size_t key_buffer_size,\n                               size_t *key_buffer_length);\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM linker .sct file modification (C)\nDESCRIPTION: This code snippet illustrates how to configure the MDK-ARM linker `.sct` file for ThreadX memory allocation. This includes either defining the RW_IRAM1 region or modifying the line in `tx_low_level_initilize.S` to match the appropriate memory region. This is a prerequisite for enabling ThreadX dynamic memory allocation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_NoR_Write_Read_File/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Compiling and running a sample\nDESCRIPTION: This snippet compiles the Azure SDK for Embedded C and then runs a specific sample, in this case, `paho_iot_hub_telemetry_sample`. The compilation is performed using the generated build files. Running the compiled executable connects to the configured Azure IoT Hub and demonstrates the functionality of the chosen sample.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n~/azure-sdk-for-c/build$ cmake --build .\n~/azure-sdk-for-c/build$ ./sdk/samples/iot/paho_iot_hub_telemetry_sample  # Use the executable of your choice.\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE linker configuration for ThreadX heap\nDESCRIPTION: This snippet shows how to configure the linker file for STM32CubeIDE to add a ._threadx_heap section for ThreadX dynamic memory allocation, specifying the alignment, end marker, size (64K), and location in RAM.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_Thread_Sync/README.md#_snippet_2\n\nLANGUAGE: LD\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: ThreadX heap configuration for EWARM\nDESCRIPTION: This code snippet shows the configuration needed in the EWARM linker file to define the memory region for the ThreadX heap.  It places the last section FREE_MEM in the RAM_region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_MSC/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Generating self-signed device certificate\nDESCRIPTION: This snippet generates a self-signed device certificate using OpenSSL.  It creates an elliptic curve private key, generates a certificate signing request, and creates a self-signed certificate. These certificates are for testing and should NOT be used in production environments due to their short expiration and lack of proper security practices.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n~$ cd azure-sdk-for-c/sdk/samples/iot/\n\n~/azure-sdk-for-c/sdk/samples/iot$ openssl ecparam -out device_ec_key.pem -name prime256v1 -genkey\n~/azure-sdk-for-c/sdk/samples/iot$ openssl req -new -days 1 -nodes -x509 -key device_ec_key.pem -out device_ec_cert.pem -extensions client_auth -config x509_config.cfg -subj \"/CN=paho-sample-device1\"\n~/azure-sdk-for-c/sdk/samples/iot$ openssl x509 -noout -text -in device_ec_cert.pem\n```\n\n----------------------------------------\n\nTITLE: Setting IoT Hub X.509 Environment Variables - PowerShell\nDESCRIPTION: This code snippet shows how to set the AZ_IOT_HUB_DEVICE_ID and AZ_IOT_HUB_HOSTNAME environment variables in PowerShell. These are required for IoT Hub X.509 certificate-based authentication. Replace `<device-id>` and `<hostname>` with the corresponding values from your Azure IoT Hub.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_16\n\nLANGUAGE: powershell\nCODE:\n```\n$env:AZ_IOT_HUB_DEVICE_ID='<device-id>'\n$env:AZ_IOT_HUB_HOSTNAME='<hostname>'\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration\nDESCRIPTION: This code snippet demonstrates how to add a new section named `._threadx_heap` to the STM32CubeIDE linker script (.ld) file. This section defines a 64KB heap for ThreadX dynamic memory allocation, ensuring it's properly aligned and located between the `.bss` and `._user_heap_stack` sections within the `RAM_D1` memory region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Device_CDC_ECM/README.md#_snippet_2\n\nLANGUAGE: Other\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .; \n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: C ISR Example for ThreadX on Cortex-M33\nDESCRIPTION: This code snippet demonstrates the structure of an Interrupt Service Routine (ISR) written in C for use with ThreadX on the Cortex-M33. It shows the basic function definition and a comment placeholder for ISR processing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/ac6/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Define Compiler Flags\nDESCRIPTION: Defines various compiler flags for configuring NetXDuo features such as IPv4/IPv6, checksumming, fragmentation, and other network-related options.  These flags are used to customize the NetXDuo build based on the selected configuration. Each `set` command defines a variable containing specific compiler flags.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(IPV4 -DNX_DISABLE_IPV6)\nset(DISABLE_RX_CHECKSUM\n    -DNX_DISABLE_ICMPV4_RX_CHECKSUM -DNX_DISABLE_ICMPV6_RX_CHECKSUM\n    -DNX_DISABLE_IP_RX_CHECKSUM -DNX_DISABLE_TCP_RX_CHECKSUM\n    -DNX_DISABLE_UDP_RX_CHECKSUM)\nset(DISABLE_TX_CHECKSUM\n    -DNX_DISABLE_ICMPV4_TX_CHECKSUM -DNX_DISABLE_ICMPV6_TX_CHECKSUM\n    -DNX_DISABLE_IP_TX_CHECKSUM -DNX_DISABLE_TCP_TX_CHECKSUM\n    -DNX_DISABLE_UDP_TX_CHECKSUM)\nset(PHY_HEADER -DNX_PHYSICAL_HEADER=48)\nset(NO_INFO\n    -DNX_DISABLE_ARP_INFO\n    -DNX_DISABLE_IP_INFO\n    -DNX_DISABLE_ICMP_INFO\n    -DNX_DISABLE_PACKET_INFO\n    -DNX_DISABLE_RARP_INFO\n    -DNX_DISABLE_TCP_INFO\n    -DNX_DISABLE_UDP_INFO)\nset(NO_FRAG -DNX_DISABLE_FRAGMENTATION)\nset(NO_CHECK -DTX_DISABLE_ERROR_CHECKING -DNX_DISABLE_ERROR_CHECKING)\nset(NO_RESET_DISCONNECT -DNX_DISABLE_RESET_DISCONNECT)\nset(NO_AUTO_ARP_ENTRY -DNX_DISABLE_ARP_AUTO_ENTRY)\nset(IMME_ACK -DNX_TCP_ACK_EVERY_N_PACKETS=1)\nset(NO_LOOPBACK -DNX_DISABLE_LOOPBACK_INTERFACE)\nset(NO_RX_SIZE_CHECK -DNX_DISABLE_RX_SIZE_CHECKING)\nset(NO_IGMPV2 -DNX_DISABLE_IGMPV2)\nset(TCP_KEEPALIVE -DNX_ENABLE_TCP_KEEPALIVE -DNX_TCP_KEEPALIVE_INITIAL=60\n                  -DTCP_KEEPALIVE_RETRY -DNX_TCP_KEEPALIVE_RETRY=10)\nset(TCP_WINDOW -DNX_ENABLE_TCP_WINDOW_SCALING)\nset(IP_STATIC_ROUTING -DNX_ENABLE_IP_STATIC_ROUTING)\nset(PACKET_ALIGNMENT -DNX_PACKET_ALIGNMENT=64)\nset(MULTI_INTERFACE -DNX_MAX_PHYSICAL_INTERFACES=4\n                    -DNX_DHCP_CLIENT_MAX_RECORDS=2)\nset(IMME_FRAG_ASSEMBLY -DNX_FRAGMENT_IMMEDIATE_ASSEMBLY)\nset(MSS_CHECK -DNX_ENABLE_TCP_MSS_CHECK -DNX_TCP_MSS_MINIMUM=32)\nset(TCP_QUEUE_NOTIFY -DNX_ENABLE_TCP_QUEUE_DEPTH_UPDATE_NOTIFY)\nset(ARP_EXPIRATION_RATE -DNX_ARP_EXPIRATION_RATE=5)\nset(NAT -DNX_NAT_ENABLE)\nset(IP_PACKET_FILTER -DNX_ENABLE_IP_PACKET_FILTER)\nset(TRACE -DTX_ENABLE_EVENT_TRACE)\nset(BSD\n    -D__suseconds_t_defined\n    -D_STRUCT_TIMEVAL\n    -D_SYS_SELECT_H\n    -DNX_ENABLE_EXTENDED_NOTIFY_SUPPORT\n    -DNX_BSD_SOCKET_QUEUE_MAX=20\n    -DNX_BSD_ENABLE\n    -DNX_IPV6_NEIGHBOR_CACHE_SIZE=32\n    -DNX_IPV6_DESTINATION_TABLE_SIZE=32\n    -DNX_BSD_ENABLE_DNS\n    -DNX_DNS_ENABLE_EXTENDED_RR_TYPES)\nset(TAHI -DNX_TAHI_ENABLE)\nset(IPV6 -DFEATURE_NX_IPV6)\nset(IPV6_PMTU_DISCOVERY -DNX_ENABLE_IPV6_PATH_MTU_DISCOVERY)\nset(NO_DAD -DNX_DISABLE_IPV6_DAD)\nset(NO_ICMPV6_ERROR -DNX_DISABLE_ICMPV6_ERROR_MESSAGE)\nset(NO_CHAIN -DNX_DISABLE_PACKET_CHAIN -DNX_DISABLE_FRAGMENTATION)\nset(LINK_CAP -DNX_ENABLE_INTERFACE_CAPABILITY)\nset(ADDRESS_CHANGE_NOTIFY -DNX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY)\nset(ADDRESS_CHECK -DNX_ENABLE_SOURCE_ADDRESS_CHECK\n                  -DNX_ENABLE_ICMP_ADDRESS_CHECK)\nset(MULTICAST -DNX_ENABLE_IPV6_MULTICAST)\nset(LOW_WATERMARK -DNX_ENABLE_LOW_WATERMARK)\nif(PRODUCT STREQUAL netxduo)\n  set(BSD_RAW ${BSD} -DNX_BSD_RAW_SUPPORT -DNX_ENABLE_IP_RAW_PACKET_FILTER\n              -DNX_BSD_RAW_PPPOE_SUPPORT -DNX_ENABLE_IP_RAW_PACKET_FILTER)\n  list(REMOVE_ITEM BSD_RAW -DNX_BSD_RAW_PPPOE_SUPPORT)\n  set(RAW_FILTER -DNX_ENABLE_IP_RAW_PACKET_FILTER)\n  set(RAW_ALL_STACK -DNX_ENABLE_IP_RAW_PACKET_ALL_STACK)\nendif()\nset(NO_REDIRECT_PROCESS -DNX_DISABLE_ICMPV6_REDIRECT_PROCESS)\nset(NO_RA_PROCESS -DNX_DISABLE_ICMPV6_ROUTER_ADVERTISEMENT_PROCESS)\nset(NO_RS -DNX_DISABLE_ICMPV6_ROUTER_SOLICITATION)\nset(STATELESS_AC -DNX_IPV6_STATELESS_AUTOCONFIG_CONTROL)\nset(NO_PURGE_UNUSED_CACHE -DNX_DISABLE_IPV6_PURGE_UNUSED_CACHE_ENTRIES)\nset(PACKET_PAD -DNX_PACKET_HEADER_PAD=4)\nset(MSS_CHECK -DNX_ENABLE_TCP_MSS_CHECK -DNX_TCP_MSS_MINIMUM=32)\nset(DUAL_POOL -DNX_ENABLE_DUAL_PACKET_POOL)\nset(DHCPV6_TAHI -DNX_DHCPV6_TAHI_ENABLE)\nset(MULTIPART -DNX_HTTP_MULTIPART_ENABLE)\nset(PACKET_DEBUG -DNX_ENABLE_PACKET_DEBUG_INFO)\nset(TCP_RX_LIMIT -DNX_TCP_MAX_OUT_OF_ORDER_PACKETS=8)\nset(TELNET_MAX_CLIENTS -DNX_TELNET_MAX_CLIENTS=2)\nset(TELNET_ACTIVITY_TIMEOUT -DNX_TELNET_ACTIVITY_TIMEOUT=10)\nset(TELNET_TIMEOUT_PERIOD -DNX_TELNET_TIMEOUT_PERIOD=2)\nset(CREATE_TELNET_PACKET_POOL -DNX_TELNET_SERVER_USER_CREATE_PACKET_POOL)\nset(LCP_PROTOCOL_RETRIES -DNX_PPP_MAX_LCP_PROTOCOL_RETRIES=5)\nset(IPCP_PROTOCOL_RETRIES -DNX_PPP_MAX_IPCP_PROTOCOL_RETRIES=5)\nset(PREFIX_LIMIT -DNX_IPV6_PREFIX_LIST_TABLE_SIZE=4)\nset(LARGE_DEST_TABLE -DNX_IPV6_DESTINATION_TABLE_SIZE=32)\nset(ND_CACHE_LIMIT -DNX_IPV6_NEIGHBOR_CACHE_SIZE=8)\nset(TX_RX_INTERFACE_CAPABILITY\n    -DNX_INTERFACE_CAPABILITY=NX_INTERFACE_CAPABILITY_IPV4_TX_CHECKSUM|NX_INTERFACE_CAPABILITY_TCP_TX_CHECKSUM|NX_INTERFACE_CAPABILITY_UDP_TX_CHECKSUM|NX_INTERFACE_CAPABILITY_ICMPV4_TX_CHECKSUM|NX_INTERFACE_CAPABILITY_ICMPV6_TX_CHECKSUM|NX_INTERFACE_CAPABILITY_IGMP_TX_CHECKSUM|NX_INTERFACE_CAPABILITY_IPV4_RX_CHECKSUM|NX_INTERFACE_CAPABILITY_TCP_RX_CHECKSUM|NX_INTERFACE_CAPABILITY_UDP_RX_CHECKSUM|NX_INTERFACE_CAPABILITY_ICMPV4_RX_CHECKSUM|NX_INTERFACE_CAPABILITY_ICMPV6_RX_CHECKSUM|NX_INTERFACE_CAPABILITY_IGMP_RX_CHECKSUM\n)\nset(RX_INTERFACE_CAPABILITY\n    -DNX_INTERFACE_CAPABILITY=NX_INTERFACE_CAPABILITY_IPV4_RX_CHECKSUM|NX_INTERFACE_CAPABILITY_TCP_RX_CHECKSUM|NX_INTERFACE_CAPABILITY_UDP_RX_CHECKSUM|NX_INTERFACE_CAPABILITY_ICMPV4_RX_CHECKSUM|NX_INTERFACE_CAPABILITY_ICMPV6_RX_CHECKSUM|NX_INTERFACE_CAPABILITY_IGMP_RX_CHECKSUM\n)\nset(NO_INTERFACE_CAPABILITY -DNX_INTERFACE_CAPABILITY=0)\nset(DHCP_ARP_PROBE -DNX_DHCP_CLIENT_SEND_ARP_PROBE)\nset(NO_ASSERT -DNX_DISABLE_ASSERT)\nset(NO_IPV4 -DNX_DISABLE_IPV4)\nset(MDNS_IPV6 -DNX_MDNS_ENABLE_IPV6 -DFEATURE_NX_IPV6\n              -DNX_ENABLE_IPV6_MULTICAST -DNX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY)\nset(MDNS_NO_CLIENT -DNX_MDNS_DISABLE_CLIENT)\nset(MDNS_NO_SERVER -DNX_MDNS_DISABLE_SERVER)\nset(PPPOE -DNX_PPP_PPPOE_ENABLE -DNX_PPPOE_SERVER_INITIALIZE_DRIVER_ENABLE\n          -DNX_PPPOE_CLIENT_INITIALIZE_DRIVER_ENABLE)\nset(PPPOE_CONTROL -DNX_PPPOE_SERVER_SESSION_CONTROL_ENABLE)\nset(HTTP_DIGEST -DNX_HTTP_DIGEST_ENABLE)\nset(DHCP_RESTORE -DNX_DHCP_CLIENT_RESTORE_STATE)\nset(DNS_CACHE -DNX_DNS_CACHE_ENABLE)\nset(TCPIP_OFFLOAD -DNX_ENABLE_TCPIP_OFFLOAD ${LINK_CAP})\nset(ARP -DNX_ARP_DEFEND_BY_REPLY)\nset(HTTP_PROXY -DNX_ENABLE_HTTP_PROXY)\nset(RAND_ID -DNX_ENABLE_IP_ID_RANDOMIZATION)\nset(PPP_COMPRESSION -DNX_PPP_COMPRESSION_ENABLE)\n```\n\n----------------------------------------\n\nTITLE: Get Key Derivation Input Size Function (C)\nDESCRIPTION: This function retrieves the size of a key derivation input, given the inputs structure and a step. It returns `PSA_SUCCESS` and populates the `size` parameter with the size of the input in bytes, or an error code if it fails.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_crypto_driver_key_derivation_get_input_size(\n    const psa_crypto_driver_key_derivation_inputs_t *inputs,\n    psa_key_derivation_step_t step,\n    size_t *size);\n```\n\n----------------------------------------\n\nTITLE: ISR in Assembly for ThreadX on Cortex-M\nDESCRIPTION: This Assembly code snippet demonstrates the structure of an Interrupt Service Routine (ISR) for ThreadX on Cortex-M processors.  The ISR must preserve the link register and any registers it uses by pushing them onto the stack.  After processing, the registers and link register are popped off the stack and the ISR returns using the BX lr instruction.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/ac5/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n    EXPORT  your_assembly_isr\nyour_assembly_isr\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Transparent Cooked Key Derivation Function Prototype (PSA)\nDESCRIPTION: This code snippet defines the function prototype for a transparent driver's 'derive_key' entry point, used for cooked key derivation. This function takes key attributes, input data, a memory object (if the 'memory' property is true), an output buffer, the buffer size, and a pointer to store the actual output length as parameters. It derives a portion of the key and writes it into the buffer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_derive_key(\n    const psa_key_attributes_t *attributes,\n    const uint8_t *input, size_t input_length,\n    acme_derive_key_memory_t *memory, // if the \"memory\" property is false: void*\n    uint8_t *key_buffer, size_t key_buffer_size, size_t *key_buffer_length);\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Options for 32/64 bit\nDESCRIPTION: This snippet checks the environment variable ENABLE_64 and sets compiler and linker options accordingly. If ENABLE_64 is set, it prints a message indicating a 64-bit build. Otherwise, it adds compiler and linker options for 32-bit compilation using -m32.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/libs/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif($ENV{ENABLE_64})\n  message(STATUS \"Building for 64bit\")\nelse()\n  add_compile_options(-m32)\n  add_link_options(-m32)\n  message(STATUS \"Building for 32bit\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Create Executable for IoT PnP Component Sample\nDESCRIPTION: This snippet creates an executable named `paho_iot_pnp_component_sample` from multiple C files including component implementations and links it against the common library. It also sets include directories and defines a map file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable (paho_iot_pnp_component_sample\n  ${CMAKE_CURRENT_LIST_DIR}/pnp/pnp_mqtt_message.c\n  ${CMAKE_CURRENT_LIST_DIR}/pnp/pnp_device_info_component.c\n  ${CMAKE_CURRENT_LIST_DIR}/pnp/pnp_thermostat_component.c\n  ${CMAKE_CURRENT_LIST_DIR}/pnp/pnp_temperature_controller_component.c\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_pnp_component_sample.c\n)\n\n# SDK deps\ntarget_link_libraries(paho_iot_pnp_component_sample\n  PRIVATE\n    az::iot::sample::common\n)\n\ntarget_include_directories(paho_iot_pnp_component_sample\n  PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}\n)\n\ncreate_map_file(paho_iot_pnp_component_sample paho_iot_pnp_component_sample.map)\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories in CMake\nDESCRIPTION: This CMake snippet adds include directories to the project. It uses the `target_include_directories` command to specify the directories where the compiler should look for header files. The `PUBLIC` keyword indicates that these include directories are also visible to other targets that depend on this target. The `${CMAKE_CURRENT_LIST_DIR}/inc` variable specifies the path to the include directory relative to the current CMake list file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/ports/cortex_m4/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting paths for CMSIS-DSP library\nDESCRIPTION: This snippet defines the paths to the CMSIS-DSP library. It sets the root directory and the DSP directory based on the current source directory and appends the DSP folder to the CMAKE_MODULE_PATH.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Needed to include the configBoot module\n# Define the path to CMSIS-DSP (ROOT is defined on command line when using cmake)\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\n# Add DSP folder to module path\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration\nDESCRIPTION: This code snippet shows how to add a new section named '._threadx_heap' to the STM32CubeIDE linker file (.ld). This section is used to define a memory region for ThreadX's heap. It sets the alignment, defines the end of the RAM segment used, allocates 64KB of memory for the heap, and specifies that this region is located in and loaded from 'RAM_D1'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_SecureLEDToggle_TrustZone/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n._threadx_heap :\n  {\n    . = ALIGN(8);\n    __RAM_segment_used_end__ = .;\n    . = . + 64K;\n    . = ALIGN(8);\n  } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Creating an OSEK Resource in C\nDESCRIPTION: This C code shows the function signature for creating an OSEK resource using the CreateResource function.  The parameters include the resource name, type, and a linked resource. The function returns the created resource.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nResourceType CreateResource(const CHAR *name, \n                                StatusType type, \n                                ResourceType linked_res);\n```\n\n----------------------------------------\n\nTITLE: Setting device and hub environment variables\nDESCRIPTION: This snippet sets the `AZ_IOT_HUB_DEVICE_ID` and `AZ_IOT_HUB_HOSTNAME` environment variables.  `AZ_IOT_HUB_DEVICE_ID` is the device ID registered in Azure IoT Hub, and `AZ_IOT_HUB_HOSTNAME` is the hostname of the Azure IoT Hub. These variables are necessary for the Azure SDK for Embedded C samples to connect to the IoT Hub.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nexport AZ_IOT_HUB_DEVICE_ID=testdevice-x509\nexport AZ_IOT_HUB_HOSTNAME=myiothub.azure-devices.net # Use the your hostname instead.\n```\n\n----------------------------------------\n\nTITLE: Configuring and Including the nx_user.h File\nDESCRIPTION: This snippet configures the `nx_user.h` file. If `NX_USER_FILE` is not defined, it uses the default sample file; otherwise, it uses the custom file specified by `NX_USER_FILE`. It then copies the file to the `CUSTOM_INC_DIR`, adds the directory to the include paths for the target, and defines the `NX_INCLUDE_USER_DEFINE_FILE` compilation flag.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# If the user provided an override, copy it to the custom directory\nif (NOT NX_USER_FILE)\n    message(STATUS \"Using default nx_user.h file\")\n    set(NX_USER_FILE ${CMAKE_CURRENT_LIST_DIR}/common/inc/nx_user_sample.h)\nelse()\n    message(STATUS \"Using custom nx_user.h file from ${NX_USER_FILE}\")\nendif()\nconfigure_file(${NX_USER_FILE} ${CUSTOM_INC_DIR}/nx_user.h COPYONLY)\ntarget_include_directories(${PROJECT_NAME} \n    PUBLIC \n    ${CUSTOM_INC_DIR}\n)\ntarget_compile_definitions(${PROJECT_NAME} PUBLIC \"NX_INCLUDE_USER_DEFINE_FILE\" )\n```\n\n----------------------------------------\n\nTITLE: Creating Static Library and Adding Sources\nDESCRIPTION: This snippet creates a static library named CMSISDSPMatrix and adds the previously defined source files to it. The target_sources command is used to specify the source files for the library. Different source sets are added as PRIVATE sources.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/MatrixFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(CMSISDSPMatrix STATIC ${SRCF64})\ntarget_sources(CMSISDSPMatrix PRIVATE ${SRCF32})\n\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPMatrix PRIVATE ${SRCF16})\nendif()\n\ntarget_sources(CMSISDSPMatrix PRIVATE ${SRCQ31})\ntarget_sources(CMSISDSPMatrix PRIVATE ${SRCQ15})\ntarget_sources(CMSISDSPMatrix PRIVATE ${SRCQ7})\n\ntarget_sources(CMSISDSPMatrix PRIVATE ${SRCU32})\ntarget_sources(CMSISDSPMatrix PRIVATE ${SRCU16})\ntarget_sources(CMSISDSPMatrix PRIVATE ${SRCU8})\n```\n\n----------------------------------------\n\nTITLE: Set Target Include Directories (PUBLIC)\nDESCRIPTION: Adds the DSP/Include directory to the library's public include directories. This allows projects that link against CMSISDSPBasicMath to include header files from this directory without having to explicitly specify the path in their own build configurations.  `${DSP}` likely points to the root directory of the DSP library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/BasicMathFunctions/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(CMSISDSPBasicMath PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration\nDESCRIPTION: This configuration adds a section to the EWARM linker file to allocate memory for ThreadX. The `place in RAM_region    { last section FREE_MEM };` line ensures the `FREE_MEM` section is placed in the RAM region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ThreadX/Tx_Thread_Creation/README.md#_snippet_0\n\nLANGUAGE: EWARM Linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: C ISR Definition Example\nDESCRIPTION: This code snippet shows how to define an Interrupt Service Routine (ISR) in C for ThreadX on Cortex-M55. The ISR 'your_C_isr' is defined as a void function and contains the interrupt handling logic.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/ac6/readme_threadx.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Standard IRQ Handler in ThreadX (Assembly)\nDESCRIPTION: This assembly code defines the standard IRQ handler (__tx_irq_handler) within ThreadX. It saves the system context and then jumps to a routine to restore the system context after the application-specific ISR dispatch. The interrupt handler utilizes `_tx_thread_context_save` and `_tx_thread_context_restore` functions for context management.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/iar/readme_threadx.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\n    PUBLIC  __tx_irq_handler\n    PUBLIC  __tx_irq_processing_return      \n__tx_irq_handler\n;\n;    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save\n__tx_irq_processing_return\n;\n;    /* At this point execution is still in the IRQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use. Note \n;       that IRQ interrupts are still disabled upon return from the context\n;       save function.  */\n;\n;    /* Application ISR dispatch call goes here!  */\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable (Linux)\nDESCRIPTION: This snippet shows how to set an environment variable in Linux using the export command.  Replace ENV_VARIABLE_NAME with the desired variable name and VALUE with the corresponding value.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nexport ENV_VARIABLE_NAME=VALUE\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration for ThreadX Memory\nDESCRIPTION: This code snippet shows how to configure the STM32CubeIDE linker file (.ld) to allocate memory for ThreadX. It defines a new section called ._threadx_heap within the RAM_D1 memory region, setting aside 64KB for ThreadX's heap. The section must be placed between the .bss and ._user_heap_stack sections.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_TCP_Echo_Server/README.md#_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Checking AES-CMAC Support (PSA API)\nDESCRIPTION: This code snippet demonstrates how to check for AES-CMAC support in the PSA API. It verifies that the AES key type and the CMAC algorithm are enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\n#if PSA_WANT_KEY_TYPE_AES && PSA_WANT_ALG_CMAC\n```\n\n----------------------------------------\n\nTITLE: Setting Specific Build Definitions\nDESCRIPTION: Defines preprocessor definitions for various build configurations, including exFAT, caching, error checking, and standalone builds. These definitions control the behavior of FileX during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(default_build_coverage \"\")\nset(no_cache_build -DFX_DISABLE_CACHE -DFX_DISABLE_FAT_ENTRY_REFRESH)\nset(fault_tolerant_build_coverage ${FX_FAULT_TOLERANT_DEFINITIONS})\n# FX_EXFAT_SECTOR_SIZE is a test symbol only used to change exFAt format option\nset(fault_tolerant_exfat_build ${FX_FAULT_TOLERANT_DEFINITIONS}\n                               -DFX_ENABLE_EXFAT\n                               -DFX_EXFAT_SECTOR_SIZE=4096\n                               -DFX_EXFAT_MAX_CACHE_SIZE=FX_EXFAT_SECTOR_SIZE\n                               -DTX_ENABLE_EVENT_TRACE)\nset(exfat_build -DFX_ENABLE_EXFAT -DFX_EXFAT_SECTOR_SIZE=512\n                               -DFX_EXFAT_MAX_CACHE_SIZE=FX_EXFAT_SECTOR_SIZE)\nset(exfat_no_cache_build ${exfat_build} -DFX_DISABLE_CACHE)\nset(exfat_build_4096 -DFX_ENABLE_EXFAT -DFX_EXFAT_SECTOR_SIZE=4096\n                               -DFX_EXFAT_MAX_CACHE_SIZE=FX_EXFAT_SECTOR_SIZE)\nset(exfat_no_check_build -DFX_ENABLE_EXFAT -DFX_DISABLE_ERROR_CHECKING -DFX_EXFAT_SECTOR_SIZE=2048\n                               -DFX_EXFAT_MAX_CACHE_SIZE=FX_EXFAT_SECTOR_SIZE)\nset(exfat_standalone_build_coverage -DFX_STANDALONE_ENABLE -DFX_ENABLE_EXFAT -DFX_EXFAT_SECTOR_SIZE=2048\n                               -DFX_EXFAT_MAX_CACHE_SIZE=FX_EXFAT_SECTOR_SIZE)\nset(exfat_standalone_fault_tolerant_build_coverage ${FX_FAULT_TOLERANT_DEFINITIONS}\n                                                   -DFX_STANDALONE_ENABLE -DFX_ENABLE_EXFAT -DFX_EXFAT_SECTOR_SIZE=4096\n                                                   -DFX_EXFAT_MAX_CACHE_SIZE=FX_EXFAT_SECTOR_SIZE)   \nset(exfat_standalone_build_1024 -DFX_STANDALONE_ENABLE -DFX_ENABLE_EXFAT -DFX_EXFAT_SECTOR_SIZE=1024\n                               -DFX_EXFAT_MAX_CACHE_SIZE=FX_EXFAT_SECTOR_SIZE)\nset(standalone_build_coverage  -DFX_STANDALONE_ENABLE)\nset(standalone_fault_tolerant_build_coverage ${FX_FAULT_TOLERANT_DEFINITIONS}\n                                             -DFX_STANDALONE_ENABLE)       \nset(no_cache_standalone_build -DFX_DISABLE_CACHE -DFX_STANDALONE_ENABLE)\nset(no_check_build ${FX_COMPILE_DEFINITIONS} -DFX_DISABLE_ERROR_CHECKING)\nset(no_cache_fault_tolerant_build ${no_cache_build} ${FX_FAULT_TOLERANT_DEFINITIONS})\nset(standalone_no_cache_fault_tolerant_build ${no_cache_build} ${FX_FAULT_TOLERANT_DEFINITIONS} -DFX_STANDALONE_ENABLE)\n```\n\n----------------------------------------\n\nTITLE: Define Build Configurations with Flags\nDESCRIPTION: Defines specific build configurations by combining previously defined compiler flags. This allows for creating specialized builds with specific NetXDuo features enabled or disabled.  Each `set` command creates a build configuration and assigns it a combination of compiler flags.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset(v4_build ${IPV4} ${PACKET_DEBUG})\nset(v4_dns_cache_build ${IPV4} ${DNS_CACHE})\nset(v4_no_checksum_build ${IPV4} ${DISABLE_TX_CHECKSUM} ${DISABLE_RX_CHECKSUM})\nset(v4_physical_48_build ${IPV4} ${PHY_HEADER} ${MDNS_NO_CLIENT} ${PPPOE} ${MULTI_INTERFACE})\nset(v4_small_build\n    ${IPV4}\n    ${NO_INFO}\n    ${NO_FRAG}\n    ${NO_CHECK}\n    ${NO_RESET_DISCONNECT}\n    ${NO_AUTO_ARP_ENTRY}\n    ${IMME_ACK}\n    ${NO_LOOPBACK}\n    ${NO_RX_SIZE_CHECK}\n    ${NO_IGMPV2}\n    ${RAND_ID})\nset(v4_packet_pad_build ${IPV4} ${PACKET_ALIGNMENT})\nset(v4_full_build\n    ${IPV4}\n    ${TCP_KEEPALIVE}\n    ${TCP_WINDOW}\n    ${IP_STATIC_ROUTING}\n    ${BSD}\n    ${MULTI_INTERFACE}\n    ${IMME_FRAG_ASSEMBLY}\n    ${MSS_CHECK}\n    ${TCP_QUEUE_NOTIFY}\n    ${RAW_FILTER}\n    ${ARP_EXPIRATION_RATE}\n    ${MULTIPART}\n    ${NAT}\n    ${PACKET_DEBUG}\n    ${DUAL_POOL}\n    ${IP_PACKET_FILTER}\n    ${CREATE_TELNET_PACKET_POOL}\n    ${TELNET_MAX_CLIENTS}\n    ${TELNET_ACTIVITY_TIMEOUT}\n    ${TELNET_TIMEOUT_PERIOD}\n    ${LCP_PROTOCOL_RETRIES}\n    ${IPCP_PROTOCOL_RETRIES}\n    ${DHCP_ARP_PROBE}\n    ${TRACE}\n    ${DHCP_RESTORE}\n    ${DNS_CACHE}\n    ${ARP}\n    ${HTTP_PROXY}\n    ${PPP_COMPRESSION})\nset(v4_no_frag_build ${IPV4} ${NO_FRAG})\nset(v4_no_check_build ${IPV4} ${NO_CHECK})\nset(v4_no_reset_disconn_build ${IPV4} ${NO_RESET_DISCONNECT})\n```\n\n----------------------------------------\n\nTITLE: Set Include Directories for CMSISDSPQuaternionMath\nDESCRIPTION: This snippet sets the include directories for the CMSISDSPQuaternionMath library. It adds the `DSP/Include` directory to the library's include path, making the header files located in that directory available during compilation. The `${DSP}` variable represents the path to the DSP component, presumably defined in the `configDsp` include.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/QuaternionMathFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(CMSISDSPQuaternionMath PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Import Key Prototype - C\nDESCRIPTION: Defines the function prototype for the `import_key` entry point in a PSA opaque driver. This function imports a key into the driver. It takes key attributes, the key data, its length, a key buffer, its size, and pointers to store the key buffer length and bits as input, and returns a PSA status.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_45\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_import_key(const psa_key_attributes_t *attributes,\n                             const uint8_t *data,\n                             size_t data_length,\n                             uint8_t *key_buffer,\n                             size_t key_buffer_size,\n                             size_t *key_buffer_length,\n                             size_t *bits);\n```\n\n----------------------------------------\n\nTITLE: RSA Prime Factor (P) Definition\nDESCRIPTION: Defines the first RSA prime factor (P) as a hexadecimal string. P is one of the two large prime numbers that make up the modulus N. This value, along with Q, is used in key generation and optimization of decryption.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/rsa_priv.txt#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nP = CD083568D2D46C44C40C1FA0101AF2155E59C70B08423112AF0C1202514BBA5210765E29FF13036F56C7495894D80CF8C3BAEE2839BACBB0B86F6A2965F60DB1\n```\n\n----------------------------------------\n\nTITLE: Configuring CFFT Options (Double Precision) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Complex FFT (CFFT) implementations for double-precision floating-point numbers (f64) with various sizes (16 to 4096). These options are used to customize the CMSIS-DSP library by selecting specific CFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\noption(CFFT_F64_16          \"cfft f64 16\"                       OFF)\noption(CFFT_F64_32          \"cfft f64 32\"                       OFF)\noption(CFFT_F64_64          \"cfft f64 64\"                       OFF)\noption(CFFT_F64_128         \"cfft f64 128\"                      OFF)\noption(CFFT_F64_256         \"cfft f64 256\"                      OFF)\noption(CFFT_F64_512         \"cfft f64 512\"                      OFF)\noption(CFFT_F64_1024        \"cfft f64 1024\"                     OFF)\noption(CFFT_F64_2048        \"cfft f64 2048\"                     OFF)\noption(CFFT_F64_4096        \"cfft f64 4096\"                     OFF)\n```\n\n----------------------------------------\n\nTITLE: Linker Configuration for EWARM\nDESCRIPTION: This snippet shows the necessary linker configuration for EWARM to allocate memory for ThreadX.  Specifically, it places the `FREE_MEM` section in the `RAM_region`. This allows ThreadX to correctly manage dynamic memory allocation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/NetXDuo/Nx_SNTP_Client/README.md#_snippet_1\n\nLANGUAGE: Other\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Setting Test Utility File Sources CMake\nDESCRIPTION: This snippet defines the source files for test utilities in CMake. The `test_utility_files` variable is assigned a list of C files containing utilities like network driver emulation, test control, DHCP cloning, and DNS response handling, used to support the test cases.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_35\n\nLANGUAGE: CMake\nCODE:\n```\nset(test_utility_files\n    ${SOURCE_DIR}/test/nx_ram_network_driver_test_1500.c\n    ${SOURCE_DIR}/test/netxtestcontrol.c\n    # DHCP utilities\n    ${SOURCE_DIR}/dhcp_test/netx_dhcp_clone_function.c\n    # DNS utilities\n    ${SOURCE_DIR}/dns_test/response_txt_google_com.c\n    ${SOURCE_DIR}/dns_test/response_cname_mail_baidu_com.c\n    ${SOURCE_DIR}/dns_test/response_mx_a_berkley_edu.c\n    ${SOURCE_DIR}/dns_test/response_mx_a_google_com.c\n    ${SOURCE_DIR}/dns_test/response_soa_google_com.c)\n```\n\n----------------------------------------\n\nTITLE: Creating Build Directory with CMake - Linux\nDESCRIPTION: This code snippet describes the steps to create a build directory, navigate into it, and then run cmake to generate the build files. The TRANSPORT_PAHO option enables Paho MQTT transport. This snippet assumes you are at the root of the azure-sdk-for-c directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\nmkdir build\ncd build\ncmake -DTRANSPORT_PAHO=ON ..\n```\n\n----------------------------------------\n\nTITLE: Configuring Host Bridge\nDESCRIPTION: This section configures the host bridge within the FVP MPS2 simulation, defining parameters related to host interface and networking.  It includes setting the interface name (`interfaceName`), enabling/disabling user-mode networking (`userNetworking`), and defining the virtual subnet and ports for user-mode networking (`userNetSubnet`, `userNetPorts`).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_module/cortex_m23/ac6/example_build/ARMCM23_TZ_config.txt#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nfvp_mps2.hostbridge.interfaceName=\"ARM0\"\nfvp_mps2.hostbridge.userNetworking=0\nfvp_mps2.hostbridge.userNetSubnet=\"172.20.51.0/24\"\nfvp_mps2.hostbridge.userNetPorts=\"\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Mock Functions\nDESCRIPTION: Conditionally adds a compile definition to enable mock functions. If the `UNIT_TESTING_MOCKS` option is enabled, the `_az_MOCK_ENABLED` definition is added, which will be used to enable the mocking of PAL functions during unit tests. This requires the `UNIT_TESTING` option to be also enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif(UNIT_TESTING_MOCKS)\n  add_compile_definitions(_az_MOCK_ENABLED)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Initializing Ethernet MAC Address in C\nDESCRIPTION: This code snippet initializes the MAC address for the Ethernet interface. It sets the individual bytes of the MAC address within the `heth.Init.MACAddr` array. This is a crucial step for proper network communication.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_TCP_Echo_Client/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid MX_ETH_Init(void)\n{\n\n  /* USER CODE BEGIN ETH_Init 0 */\n\n  /* USER CODE END ETH_Init 0 */\n\n  /* USER CODE BEGIN ETH_Init 1 */\n\n  /* USER CODE END ETH_Init 1 */\n  heth.Instance = ETH;\n  heth.Init.MACAddr[0] =   0x00;\n  heth.Init.MACAddr[1] =   0x80;\n  heth.Init.MACAddr[2] =   0xE1;\n  heth.Init.MACAddr[3] =   0x00;\n  heth.Init.MACAddr[4] =   0x00;\n  heth.Init.MACAddr[5] =   0x00;\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Modification for ThreadX Heap\nDESCRIPTION: This snippet outlines the linker modification for MDK-ARM to define the memory region for the ThreadX heap. It mentions either defining the `RW_IRAM1` region in the `.sct` file or modifying the `tx_low_level_initilize.S` file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ThreadX/Tx_MPU/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration\nDESCRIPTION: This snippet illustrates the configuration needed in MDK-ARM's linker file (.sct) or `tx_initialize_low_level.S` to define or modify the memory region used by ThreadX for dynamic memory allocation. Specifically, it shows how to define the `RW_IRAM1` region or modify the initialization line in `tx_initialize_low_level.S` to match the memory region being used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Device_CDC_ECM/README.md#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Define Target Sources for STM32CubeH5 USB Device Classes\nDESCRIPTION: This CMake code snippet defines the target sources for the STM32CubeH5 project, specifically for USB device class implementations. It uses the `target_sources` command to add a list of C source files located in the `src` directory under `CMAKE_CURRENT_LIST_DIR` to the project. These files implement various USB device classes like Audio, CCID, CDC ACM, CDC ECM, DFU, HID, and PIMA.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_device_classes/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio10_control_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio20_control_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_feedback_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_feedback_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_feedback_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_feedback_task_function.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_frame_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_interrupt_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_interrupt_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_interrupt_task_function.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_ioctl.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_read_frame_free.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_read_frame_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_read_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_read_task_function.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_reception_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_sample_read16.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_sample_read24.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_sample_read32.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_sample_read8.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_speed_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_stream_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_transmission_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_unitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_write_frame_commit.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_write_frame_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_write_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_write_task_function.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_audio_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_auto_seq_done.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_auto_seq_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_control_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_hardware_error.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_icc_insert.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_icc_remove.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_notify_task_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_notify_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_response.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_runner_task_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_runner_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_time_extension.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_ccid_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_bulkin_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_bulkout_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_ioctl.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_read_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_unitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_write_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_acm_write_with_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_bulkin_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_bulkout_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_interrupt_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_cdc_ecm_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dfu_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dfu_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dfu_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dfu_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dfu_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dfu_state_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dfu_state_sync.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dfu_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_dfu_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_descriptor_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_event_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_event_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_interrupt_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_read_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_receiver_event_free.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_receiver_event_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_receiver_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_receiver_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_receiver_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_receiver_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_report_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_report_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_hid_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_data.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_device_info_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_device_prop_desc_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_device_prop_value_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_device_prop_value_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_device_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_event_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_event_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_interrupt_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_data_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_data_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_handles_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_info_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_prop_desc_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_prop_value_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_prop_value_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_props_supported_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_references_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_object_references_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_objects_number_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_partial_object_data_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_response_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_storage_format.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_storage_id_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_storage_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_device_class_pima_thread.c\n)\n```\n\n----------------------------------------\n\nTITLE: Combining certificate and key and generating fingerprint\nDESCRIPTION: This snippet combines the device certificate and key into a single file (`device_cert_store.pem`) and generates the SHA1 fingerprint of the certificate.  The fingerprint is then extracted and stored in `fingerprint.txt`. The fingerprint is used to register the device with the Azure IoT Hub using X.509 authentication.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n~/azure-sdk-for-c/sdk/samples/iot$ rm -f device_cert_store.pem\n~/azure-sdk-for-c/sdk/samples/iot$ cat device_ec_cert.pem device_ec_key.pem > device_cert_store.pem\n~/azure-sdk-for-c/sdk/samples/iot$ openssl x509 -noout -fingerprint -in device_ec_cert.pem | sed 's/://g'| sed 's/\\(SHA1 Fingerprint=\\)//g' | tee fingerprint.txt\n```\n\n----------------------------------------\n\nTITLE: Setting IoT Hub SAS Environment Variables - Linux\nDESCRIPTION: This code snippet shows how to set the AZ_IOT_HUB_SAS_DEVICE_ID, AZ_IOT_HUB_SAS_KEY, and AZ_IOT_HUB_HOSTNAME environment variables in a Linux environment for IoT Hub SAS authentication. Replace `<sas-device-id>`, `<sas-key>`, and `<hostname>` with the appropriate values from your Azure IoT Hub.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nexport AZ_IOT_HUB_SAS_DEVICE_ID=<sas-device-id>\nexport AZ_IOT_HUB_SAS_KEY=<sas-key>\nexport AZ_IOT_HUB_HOSTNAME=<hostname>\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation Configuration for EWARM\nDESCRIPTION: This code snippet shows how to configure the ThreadX memory allocation in the .icf linker file for EWARM. It places the last section FREE_MEM into the RAM_region to define the memory space for ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_Iperf_wifi/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Key Derivation Input Step Entry Point (C)\nDESCRIPTION: Defines the function signature for the key derivation input step entry point.  This function is called for long inputs after the setup. It takes the operation object, the step, a pointer to the input data, and the length of the input.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_14\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_key_derivation_input_step(\n    acme_key_derivation_operation_t *operation,\n    psa_key_derivation_step_t step,\n    const uint8_t *input, size_t input_length);\n```\n\n----------------------------------------\n\nTITLE: Creating a String as an az_span in C\nDESCRIPTION: This code shows how to create a string as an `az_span` using the macro `AZ_SPAN_FROM_STR`.  The string is not zero-terminated and its length is calculated by the macro.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\naz_span hello_world = AZ_SPAN_FROM_STR(\"Hello world!\");\n```\n\n----------------------------------------\n\nTITLE: Setting Generated Source File Properties\nDESCRIPTION: This block sets the `GENERATED` property to `TRUE` for `query_config.c` when `GEN_FILES` is enabled. This informs CMake that the file is generated during the build process, preventing errors if the file does not exist initially.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/ssl/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(GEN_FILES)\n    # Inform CMake that the following file will be generated as part of the build\n    # process, so it doesn't complain that it doesn't exist yet. Starting from\n    # CMake 3.20, this will no longer be necessary as CMake will automatically\n    # propagate this information across the tree, for now it's only visible\n    # inside the same directory, so we need to propagate manually.\n    set_source_files_properties(\n        ${CMAKE_CURRENT_BINARY_DIR}/../test/query_config.c\n        PROPERTIES GENERATED TRUE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Appending JSON Text\nDESCRIPTION: Appends an existing UTF-8 encoded JSON text to the JSON writer. This is useful for appending nested JSON structures. The provided JSON text is appended as-is, without any formatting or escaping changes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_21\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_json_text(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr,\n                                               const UCHAR *json, UINT json_len);\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Configuration\nDESCRIPTION: Configures unit testing based on the `UNIT_TESTING` option. It finds the cmocka library, sets the `CMOCKA_LIB` variable, adds a compiler option to suppress warnings about set-jump functions (if using GCC), and then adds subdirectories for the core and IoT unit tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nif (UNIT_TESTING)\n  # make generate step fail if cmocka dependency is not found\n  find_package(cmocka CONFIG REQUIRED)\n\n  # Old versions of cmocka (including the latest stable) don't define an imported target\n  if(NOT TARGET cmocka::cmocka)\n    set(CMOCKA_LIB ${CMOCKA_LIBRARIES})\n  else()\n    set(CMOCKA_LIB cmocka::cmocka)\n  endif()\n\n  # for gcc, we need to add no-clobbered compile opt to avoid warning about set-jump function\n  set(NO_CLOBBERED_WARNING \"\")\n  if (CMAKE_C_COMPILER_ID MATCHES \"GNU\")\n    set(NO_CLOBBERED_WARNING \"-Wno-clobbered\")\n  endif()\n\n  # Core\n  add_subdirectory(sdk/tests/core)\n\n  # IoT\n  add_subdirectory(sdk/tests/iot/adu)\n  add_subdirectory(sdk/tests/iot/common)\n  add_subdirectory(sdk/tests/iot/hub)\n  add_subdirectory(sdk/tests/iot/provisioning)\n\nendif()\n```\n\n----------------------------------------\n\nTITLE: Define clock_gettime Function Prototype in C\nDESCRIPTION: Defines the prototype for the `clock_gettime` function, used for retrieving the time of a specified clock. It takes a `clockid_t` specifying the clock and a pointer to a `timespec` structure to store the time.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nINT                   clock_gettime(clockid_t t, struct timespec * tspec)\n```\n\n----------------------------------------\n\nTITLE: Comment/Uncomment #define MASTER_BOARD\nDESCRIPTION: This code snippet outlines the steps to configure the boards as either Master or Slave. To configure a board as a Slave, comment out the `#define MASTER_BOARD` directive. Conversely, to configure a board as the Master, uncomment the `#define MASTER_BOARD` directive before loading the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples/I2C/I2C_TwoBoards_RestartAdvComIT/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nComment \"#define MASTER_BOARD\" and load the project in Slave Board\nUncomment \"#define MASTER_BOARD\" and load the project in Master Board\n```\n\n----------------------------------------\n\nTITLE: Assembling binaries into one image using command-line tool\nDESCRIPTION: This example demonstrates how to assemble two binary files into a single image using a command-line tool. It involves specifying the paths to the first and second binaries, adding optional padding to both binaries to meet specified sizes, and specifying the output binary file name. The optional size parameters ensure binaries are padded to a minimum size before concatenation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_30\n\nLANGUAGE: text\nCODE:\n```\noneimage -fb ...\\Secure\\STM32H573I-DK_S\\Exe\\Project.bin -sb ...\\NonSecure\\STM32H573I-DK_NS\\Exe\\Project.bin -o 0x6000 rot_app.bin\n```\n\n----------------------------------------\n\nTITLE: Adding Crypto Test Cases (Coverage Build)\nDESCRIPTION: Conditionally adds crypto-related test cases to `nx_secure_test_cases` if the `CMAKE_BUILD_TYPE` is set to `default_build_coverage`. These tests cover cryptographic algorithms used by NX_Secure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/regression/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(\"s${CMAKE_BUILD_TYPE}\" STREQUAL \"sdefault_build_coverage\")\n  list(\n    APPEND\n    nx_secure_test_cases\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_3des_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_aes_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_aes_ccm_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_des_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_ec_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_ecdh_self_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_ecdh_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_ecdsa_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_ecjpake_self_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_hkdf_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_hmac_md5_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_hmac_sha1_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_hmac_sha224_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_hmac_sha256_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_hmac_sha384_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_hmac_sha512_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_phash_prf_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_rsa_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_sha256_rfc_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_sha224_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_sha256_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_sha384_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_sha512_test.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditional exFAT Test Cases\nDESCRIPTION: This snippet conditionally defines additional regression test cases for exFAT if the `-DFX_ENABLE_EXFAT` option is present in the CMake build type. It sets the `regression_test_cases_exfat` variable to a list of exFAT-specific test file paths.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/regression/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"-DFX_ENABLE_EXFAT\" IN_LIST ${CMAKE_BUILD_TYPE})\n  set(regression_test_cases_exfat\n      ${SOURCE_DIR}/filex_directory_attributes_read_set_exfat_test.c\n      ${SOURCE_DIR}/filex_directory_create_delete_exfat_test.c\n      ${SOURCE_DIR}/filex_directory_default_path_get_set_exfat_test.c\n      ${SOURCE_DIR}/filex_directory_first_next_find_exfat_test.c\n      ${SOURCE_DIR}/filex_directory_local_path_exfat_test.c\n      ${SOURCE_DIR}/filex_directory_naming_exfat_test.c\n      ${SOURCE_DIR}/filex_directory_rename_exfat_test.c\n      ${SOURCE_DIR}/filex_file_allocate_truncate_exfat_test.c\n      ${SOURCE_DIR}/filex_file_attributes_read_set_exfat_test.c\n      )\n```\n\n----------------------------------------\n\nTITLE: Invoking Device Method via Azure CLI\nDESCRIPTION: This snippet demonstrates how to invoke a device method using the Azure CLI.  The --device-id, --hub-name and --method-name parameters need to be replaced with the appropriate values. Requires Azure CLI to be installed and configured.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_vxworks.md#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\naz iot hub invoke-device-method --device-id [Device ID] --hub-name [IoT Hub Name] --method-name testMethod\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Options for NN Components\nDESCRIPTION: These options allow users to selectively compile specific parts of the CMSIS-DSP library. Each option corresponds to a particular function or set of functions, such as concatenation, fully connected layers, convolutions, activations, and pooling. The default value for each option is set to ON, meaning the corresponding function is included in the compilation by default.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\noption(CONCATENATION        \"Concatenation\"         ON)\noption(FULLYCONNECTED       \"Fully Connected\"       ON)\noption(CONVOLUTION          \"Convolutions\"          ON)\noption(ACTIVATION           \"Activations\"           ON)\noption(POOLING              \"Pooling\"               ON)\noption(SOFTMAX              \"Softmax\"              ON)\noption(BASICMATHSNN         \"Basic Maths for NN\"    ON)\noption(RESHAPE              \"Reshape\"               ON)\noption(SVDF                 \"SVDF\"                  ON)\noption(NNSUPPORT            \"NN Support\"            ON)\n```\n\n----------------------------------------\n\nTITLE: Define Mbed TLS Project\nDESCRIPTION: Defines the Mbed TLS project with specified languages (C and optionally C++) and version number. The project name is \"Mbed TLS\".\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(TEST_CPP)\n    project(\"Mbed TLS\"\n        LANGUAGES C CXX\n        VERSION 3.6.2\n    )\nelse()\n    project(\"Mbed TLS\"\n        LANGUAGES C\n        VERSION 3.6.2\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Block Cipher Initialization\nDESCRIPTION: This code snippet shows the API functions offered by the new internal `block_cipher` module. These functions include initializing, freeing, setting up, setting the key, and performing encryption with a block cipher context.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-migration/md-cipher-dispatch.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nvoid mbedtls_block_cipher_init(mbedtls_block_cipher_context_t *ctx);\nvoid mbedtls_block_cipher_free(mbedtls_block_cipher_context_t *ctx);\nint mbedtls_block_cipher_setup(mbedtls_block_cipher_context_t *ctx,\n                               mbedtls_cipher_id_t cipher_id);\nint mbedtls_block_cipher_setkey(mbedtls_block_cipher_context_t *ctx,\n                                const unsigned char *key,\n                                unsigned key_bitlen);\nint mbedtls_block_cipher_encrypt(mbedtls_block_cipher_context_t *ctx,\n                                 const unsigned char input[16],\n                                 unsigned char output[16]);\n```\n\n----------------------------------------\n\nTITLE: Disable Properties Feature - C\nDESCRIPTION: This function disables the device twin properties feature in the Azure IoT Hub client. It requires a pointer to the NX_AZURE_IOT_HUB_CLIENT. Returns NX_AZURE_IOT_SUCCESS on successful disabling.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_39\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_properties_disable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Writing Data via TLS with Mbed TLS\nDESCRIPTION: This function writes data to a TLS connection using the provided SSL context. It handles the handshake transparently and loops until all data is written. The function takes the SSL context, data buffer, data length, and a pointer to store the amount of data written as parameters. It returns 0 on success, or an error code if an error occurs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/tls13-early-data.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nint write_data(mbedtls_ssl_context *ssl,\n               const unsigned char *data_to_write,\n               size_t data_to_write_len,\n               size_t *data_written)\n{\n    int ret;\n    *data_written = 0;\n\n    while (*data_written < data_to_write_len) {\n        ret = mbedtls_ssl_write(ssl, data_to_write + *data_written,\n                                data_to_write_len - *data_written);\n\n        if (ret < 0 &&\n            ret != MBEDTLS_ERR_SSL_WANT_READ &&\n            ret != MBEDTLS_ERR_SSL_WANT_WRITE) {\n            return ret;\n        }\n\n        *data_written += ret;\n    }\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: PAKE Input Get-Data Functions in C\nDESCRIPTION: Defines the function prototypes for accessing the PAKE input data. These functions provide a standardized way for drivers to retrieve password, user identity, peer identity, and cipher suite information from the `psa_crypto_driver_pake_inputs_t` structure. The functions return status codes indicating success or failure, with specific errors for buffer size issues or invalid state.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_25\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_crypto_driver_pake_get_password_len(\n\tconst psa_crypto_driver_pake_inputs_t *inputs,\n\tsize_t *password_len);\n\npsa_status_t psa_crypto_driver_pake_get_password_bytes(\n\tconst psa_crypto_driver_pake_inputs_t *inputs,\n\tuint8_t *buffer, size_t buffer_size, size_t *buffer_length);\n\npsa_status_t psa_crypto_driver_pake_get_password_key(\n\tconst psa_crypto_driver_pake_inputs_t *inputs,\n\tuint8_t** p_key_buffer, size_t *key_buffer_size,\n    const psa_key_attributes_t *attributes);\n\npsa_status_t psa_crypto_driver_pake_get_user_len(\n\tconst psa_crypto_driver_pake_inputs_t *inputs,\n\tsize_t *user_len);\n\npsa_status_t psa_crypto_driver_pake_get_user(\n    const psa_crypto_driver_pake_inputs_t *inputs,\n    uint8_t *user_id, size_t user_id_size, size_t *user_id_len);\n\npsa_status_t psa_crypto_driver_pake_get_peer_len(\n\tconst psa_crypto_driver_pake_inputs_t *inputs,\n\tsize_t *peer_len);\n\npsa_status_t psa_crypto_driver_pake_get_peer(\n    const psa_crypto_driver_pake_inputs_t *inputs,\n    uint8_t *peer_id, size_t peer_id_size, size_t *peer_id_length);\n\npsa_status_t psa_crypto_driver_pake_get_cipher_suite(\n\tconst psa_crypto_driver_pake_inputs_t *inputs,\n\tpsa_pake_cipher_suite_t *cipher_suite);\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation Configuration for STM32CubeIDE\nDESCRIPTION: This code snippet provides the memory allocation configuration for ThreadX using STM32CubeIDE. It involves adding a section named `._threadx_heap` to the .ld linker file. This section defines the heap size for ThreadX, typically 64KB in this example, and its location in memory between .bss and ._user_heap_stack sections.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_WebServer/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: RTC Clock Source Definition - C\nDESCRIPTION: This code snippet shows how to define the RTC clock source, either using LSI (Low Speed Internal) or LSE (Low Speed External) oscillator.  Uncommenting the appropriate line selects the desired clock source for the RTC peripheral. By default, LSI is selected.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples_LL/RTC/RTC_Alarm_Init/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n #define RTC_CLOCK_SOURCE_LSI\n\n /* #define RTC_CLOCK_SOURCE_LSE */\n```\n\n----------------------------------------\n\nTITLE: Defining source file lists for Mbed TLS modules\nDESCRIPTION: These snippets define lists of source files for the crypto, X.509, and TLS modules of Mbed TLS. These lists are then used later in the CMake configuration to create the corresponding libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(src_crypto\n    aes.c\n    aesni.c\n    aesce.c\n    aria.c\n    asn1parse.c\n    asn1write.c\n    base64.c\n    bignum.c\n    bignum_core.c\n    bignum_mod.c\n    bignum_mod_raw.c\n    block_cipher.c\n    camellia.c\n    ccm.c\n    chacha20.c\n    chachapoly.c\n    cipher.c\n    cipher_wrap.c\n    constant_time.c\n    cmac.c\n    ctr_drbg.c\n    des.c\n    dhm.c\n    ecdh.c\n    ecdsa.c\n    ecjpake.c\n    ecp.c\n    ecp_curves.c\n    ecp_curves_new.c\n    entropy.c\n    entropy_poll.c\n    error.c\n    gcm.c\n    hkdf.c\n    hmac_drbg.c\n    lmots.c\n    lms.c\n    md.c\n    md5.c\n    memory_buffer_alloc.c\n    nist_kw.c\n    oid.c\n    padlock.c\n    pem.c\n    pk.c\n    pk_ecc.c\n    pk_wrap.c\n    pkcs12.c\n    pkcs5.c\n    pkparse.c\n    pkwrite.c\n    platform.c\n    platform_util.c\n    poly1305.c\n    psa_crypto.c\n    psa_crypto_aead.c\n    psa_crypto_cipher.c\n    psa_crypto_client.c\n    psa_crypto_driver_wrappers_no_static.c\n    psa_crypto_ecp.c\n    psa_crypto_ffdh.c\n    psa_crypto_hash.c\n    psa_crypto_mac.c\n    psa_crypto_pake.c\n    psa_crypto_rsa.c\n    psa_crypto_se.c\n    psa_crypto_slot_management.c\n    psa_crypto_storage.c\n    psa_its_file.c\n    psa_util.c\n    ripemd160.c\n    rsa.c\n    rsa_alt_helpers.c\n    sha1.c\n    sha256.c\n    sha512.c\n    sha3.c\n    threading.c\n    timing.c\n    version.c\n    version_features.c\n)\n\nset(src_x509\n    pkcs7.c\n    x509.c\n    x509_create.c\n    x509_crl.c\n    x509_crt.c\n    x509_csr.c\n    x509write.c\n    x509write_crt.c\n    x509write_csr.c\n)\n\nset(src_tls\n    debug.c\n    mps_reader.c\n    mps_trace.c\n    net_sockets.c\n    ssl_cache.c\n    ssl_ciphersuites.c\n    ssl_client.c\n    ssl_cookie.c\n    ssl_debug_helpers_generated.c\n    ssl_msg.c\n    ssl_ticket.c\n    ssl_tls.c\n    ssl_tls12_client.c\n    ssl_tls12_server.c\n    ssl_tls13_keys.c\n    ssl_tls13_server.c\n    ssl_tls13_client.c\n    ssl_tls13_generic.c\n)\n```\n\n----------------------------------------\n\nTITLE: Deallocating Memory to a Pool with tm_memory_pool_deallocate in C\nDESCRIPTION: This function releases a previously allocated 128-byte block of memory back to the memory pool. It takes the pool_id and a pointer to the memory block as input. Returns TM_SUCCESS if deallocation is successful.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_14\n\nLANGUAGE: C\nCODE:\n```\nint  tm_memory_pool_deallocate(int pool_id, unsigned char *memory_ptr);\n```\n\n----------------------------------------\n\nTITLE: Modifying USBX Include Directories for Generic Build\nDESCRIPTION: This CMake code block conditionally modifies the include directories of the `usbx` target when the `CMAKE_BUILD_TYPE` is set to `generic_build`. It replaces the string \"ports/linux/gnu\" with \"ports/generic\" in each include directory path and updates the target properties with the modified include list.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_15\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_BUILD_TYPE STREQUAL \"generic_build\")\n  get_target_property(INCLUDES_LIST usbx INCLUDE_DIRECTORIES)\n  set(NEW_INCLUDES_LIST \"\")\n  foreach(INCLUDE_LIST ${INCLUDES_LIST})\n    string(REPLACE \"ports/linux/gnu\" \"ports/generic\" INCLUDE_LIST ${INCLUDE_LIST})\n    list(APPEND NEW_INCLUDES_LIST \"${INCLUDE_LIST}\")\n  endforeach()\n  set_target_properties(usbx PROPERTIES INCLUDE_DIRECTORIES \"${NEW_INCLUDES_LIST}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Linking Platform Abstraction Layer (PAL)\nDESCRIPTION: Links the `az_core` library against the Platform Abstraction Layer (PAL). The `PUBLIC` keyword makes the PAL dependency available to projects that link against `az_core`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/core/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(az_core\n  PUBLIC\n    ${PAL}\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for Video Class Device Standalone Tests CMake\nDESCRIPTION: Defines the source file paths for the USBX device class video standalone test cases. These tests are designed to run independently, without requiring an operating system. It tests basic video class functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\n   ${SOURCE_DIR}/usbx_ux_device_class_video_basic_tests.c\n    ${SOURCE_DIR}/usbx_uxe_device_video_test.c\n```\n\n----------------------------------------\n\nTITLE: Declare input buffer functions in C\nDESCRIPTION: Declares two C functions for managing local input buffer copies: `psa_crypto_local_input_alloc` and `psa_crypto_local_input_free`. The `alloc` function allocates memory for the input buffer, copies the input data, and stores the pointer and length in the provided struct. The `free` function releases the allocated memory and resets the pointer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-shared-memory.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_crypto_local_input_alloc(const uint8_t *input, size_t input_len,\n                                          psa_crypto_local_input_t *local_input);\n\nvoid psa_crypto_local_input_free(psa_crypto_local_input_t *local_input);\n```\n\n----------------------------------------\n\nTITLE: PAKE Setup Driver Entry Point Prototype in C\nDESCRIPTION: Defines the function prototype for the `acme_pake_setup` entry point in a PSA cryptography driver for PAKE operations.  This function is responsible for initializing the PAKE operation, which involves copying the relevant inputs from the `psa_crypto_driver_pake_inputs_t` structure using get-data functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_26\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_pake_setup( acme_pake_operation_t *operation,\n\t\t\t\t\t\t\t\t\t const psa_crypto_driver_pake_inputs_t *inputs );\n```\n\n----------------------------------------\n\nTITLE: RSA DP Definition\nDESCRIPTION: Defines DP as a hexadecimal string, representing D mod (P-1). This parameter is used in CRT (Chinese Remainder Theorem) based RSA implementations for faster decryption.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/rsa_priv.txt#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nDP = 0D0E21C07BF434B4A83B116472C2147A11D8EB98A33CFBBCF1D275EF19D815941622435AAF3839B6C432CA53CE9E772CFBE1923A937A766FD93E96E6EDEC1DF1\n```\n\n----------------------------------------\n\nTITLE: Adding Mbed TLS as Subdirectory\nDESCRIPTION: This snippet adds Mbed TLS as a subdirectory using `add_subdirectory`. It tells CMake to process the CMakeLists.txt file located in the `${MBEDTLS_DIR}/build` directory, effectively incorporating Mbed TLS into the current project's build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_subproject/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Add Mbed TLS as a subdirectory.\nadd_subdirectory(${MBEDTLS_DIR} build)\n```\n\n----------------------------------------\n\nTITLE: Building ThreadX Sample (Batch)\nDESCRIPTION: This batch script builds the ThreadX demonstration application. It compiles the sample_threadx.c file (the demonstration application) and links it with the tx.a library to create the sample_threadx.out binary, which can be downloaded and executed on a simulator or board.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/gnu/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Batch\nCODE:\n```\nbuild_threadx_sample.bat\n```\n\n----------------------------------------\n\nTITLE: Pass-through mbedTLS Configuration\nDESCRIPTION: This snippet passes through the mbedTLS configuration files (MBEDTLS_CONFIG_FILE and MBEDTLS_USER_CONFIG_FILE) to the P256-M library target as compile definitions. This ensures that the P256-M library uses the same configuration as mbedTLS, even when not directly linked against mbedTLS targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/p256-m/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(MBEDTLS_CONFIG_FILE)\n    target_compile_definitions(${p256m_target}\n        PUBLIC MBEDTLS_CONFIG_FILE=\"${MBEDTLS_CONFIG_FILE}\")\nendif()\nif(MBEDTLS_USER_CONFIG_FILE)\n    target_compile_definitions(${p256m_target}\n        PUBLIC MBEDTLS_USER_CONFIG_FILE=\"${MBEDTLS_USER_CONFIG_FILE}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Storage Test Cases Variable in CMake\nDESCRIPTION: This snippet defines a CMake variable, `ux_class_storage_test_cases`, and assigns it a list of source files related to storage tests. These source files are C files for testing the USBX storage class on both host and device sides.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_storage_test_cases\n    ${SOURCE_DIR}/usbx_host_class_storage_max_lun_get_coverage_test.c\n    ${SOURCE_DIR}/usbx_host_class_storage_entry_coverage_test.c\n    ${SOURCE_DIR}/usbx_storage_basic_memory_test.c\n    ${SOURCE_DIR}/usbx_storage_multi_lun_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_request_sense_coverage_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_control_request_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_entry_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_format_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_initialize_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_inquiry_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_mode_select_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_mode_sense_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_prevent_allow_media_removal_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_read_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_request_sense_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_storage_start_stop_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: Define Value with XML and Expression\nDESCRIPTION: This command uses the `definevalue` tool to modify a variable in a header file based on values extracted from an XML file and a mathematical expression. It filters the XML file by the tag `<Name>` to find specific values, performs a calculation using these values, and updates the specified variable in the header file with the result.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_18\n\nLANGUAGE: text\nCODE:\n```\ndefinevalue -xml OEMiRoT_Secure_Code.xml -nxml \"Firmware area size\" -nxml \"Firmware area size\" -e \"(val1 * val2)/0x500\" -n FLASH_ADDRESS_SECURE rot_variables.h\n```\n\n----------------------------------------\n\nTITLE: Cloning Azure SDK for Embedded C IoT repository using Git\nDESCRIPTION: This PowerShell command uses Git to clone the Azure SDK for Embedded C IoT repository from GitHub. It's recommended to clone the repository near the C:\\ root due to potential filepath length issues.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS C:\\> git clone https://github.com/Azure/azure-sdk-for-c.git\n```\n\n----------------------------------------\n\nTITLE: C ISR for Cortex-M4 with ThreadX\nDESCRIPTION: Illustrates the basic structure of a C language Interrupt Service Routine (ISR) compatible with ThreadX on Cortex-M4. The ISR can contain any required processing and function calls that are thread-safe and meet the constraints of interrupt context.  `your_C_isr` must be a valid entry point within the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/keil/readme_threadx.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Simulated Interrupt Thread Template\nDESCRIPTION: This is a template for a simulated interrupt thread that will occur periodically. It uses nanosleep to introduce a delay, then calls _tx_thread_context_save before calling the interrupt service routine (_sample_linux_interrupt_isr), and finally calls _tx_thread_context_restore.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/linux/gnu/readme_threadx.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nvoid    *_sample_linux_interrupt_entry(void *p)\n{\nstruct timespec ts;\n\n    while(1)\n    {\n\n        ts.tv_sec = 0;\n        ts.tv_nsec = 10000;\n        while(nanosleep(&ts, &ts));\n\n        /* Call ThreadX context save for interrupt preparation.  */\n        _tx_thread_context_save();\n\n        /* Call the real ISR routine */\n        _sample_linux_interrupt_isr();\n\n        /* Call ThreadX context restore for interrupt completion.  */\n        _tx_thread_context_restore();\n    } \n}\n```\n\n----------------------------------------\n\nTITLE: Simulated Interrupt Thread Template\nDESCRIPTION: This is a template for a simulated interrupt thread that runs periodically. It uses nanosleep for timing, saves and restores the ThreadX SMP context, and calls the actual ISR routine.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/linux/gnu/readme_threadx.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nvoid    *_sample_linux_interrupt_entry(void *p)\n{\nstruct timespec ts;\n\n    while(1)\n    {\n\n        ts.tv_sec = 0;\n        ts.tv_nsec = 10000;\n        while(nanosleep(&ts, &ts));\n\n        /* Call ThreadX SMP context save for interrupt preparation.  */\n        _tx_thread_context_save();\n\n        /* Call the real ISR routine */\n        _sample_linux_interrupt_isr();\n\n        /* Call ThreadX SMP context restore for interrupt completion.  */\n        _tx_thread_context_restore();\n    } \n}\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration\nDESCRIPTION: This configuration shows how to configure memory allocation for ThreadX in MDK-ARM. It involves either defining the RW_IRAM1 region in the scatter file or modifying the tx_low_level_initilize.S file to match the memory region being used by ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ThreadX/Tx_Thread_Creation/README.md#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: SPI Peripheral Initialization\nDESCRIPTION: The HAL_SPI_Init() function initializes the SPI peripheral with specific configurations. This function is then calling the HAL_SPI_MspInit() function which core is implementing the configuration of the needed SPI resources according to the used hardware (CLOCK & GPIO).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples_MIX/SPI/SPI_FullDuplex_ComPolling_Slave/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nHAL_SPI_Init();\n```\n\n----------------------------------------\n\nTITLE: Registering a Task to a Resource in C\nDESCRIPTION: This C code demonstrates how to register a task to a resource using the RegisterTasktoResource function. This enables the task to access the resource. The function takes the resource and the task ID as parameters and returns a StatusType.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nStatusType RegisterTasktoResource(ResourceType Resource, \n                                      TaskType TaskID);\n```\n\n----------------------------------------\n\nTITLE: Adding Component to Azure IoT Hub Client (C)\nDESCRIPTION: This function adds a component to the Azure IoT Hub client. It is required for all components in the IoT hub model.  It takes a pointer to the client instance, a pointer to the component name, and the length of the component name as input. Returns NX_AZURE_IOT_SUCCESS if the component is successfully added or NX_AZURE_IOT_INSUFFICIENT_BUFFER_SPACE if there isn't enough memory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_component_add(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                           const UCHAR *component_name_ptr,\n                                           USHORT component_name_length);\n```\n\n----------------------------------------\n\nTITLE: Modifying Define Value from XML (definevalue)\nDESCRIPTION: This snippet demonstrates how to modify a define variable in a header file based on a value in an XML file. It filters the XML file by a name and then updates the corresponding variable in the header file with the value associated to that name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ndefinevalue -xml OEMiRoT_Secure_Code.xml -nxml Firmware area size -n FLASH_ADDRESS_SECURE rot_variables.h\n```\n\n----------------------------------------\n\nTITLE: Iperf client command example\nDESCRIPTION: This is an example of the Iperf command used to start an Iperf client that connects to a server at IP address 192.168.137.188. The command measures network performance by sending data to the server on port 5001.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_Iperf_wifi/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ bin/iperf.exe -c  192.168.137.188 -i 1\n```\n\n----------------------------------------\n\nTITLE: Application Menu Example\nDESCRIPTION: This snippet displays the expected output in the UART console after the application starts, demonstrating the main menu with the option to start the bootloader.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ROT/STiROT_Appli/README.md#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n=================== Main Menu =============================\n Start BootLoader -------------------------------------- 1\n Selection :\n```\n\n----------------------------------------\n\nTITLE: Get Key Derivation Input Integer Function (C)\nDESCRIPTION: This function retrieves the integer value of a key derivation input for a particular step. It copies the input integer value into the `value` parameter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_12\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_crypto_driver_key_derivation_get_input_integer(\n    const psa_crypto_driver_key_derivation_inputs_t *inputs,\n    psa_key_derivation_step_t step,\n    uint64_t *value);\n```\n\n----------------------------------------\n\nTITLE: Building Documentation with Doxygen\nDESCRIPTION: This command generates HTML documentation for the CORE headers in the Azure SDK for Embedded C using Doxygen. Doxygen version 1.8.18 or later needs to be installed. The documentation will be generated in a new 'docs' folder.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndoxygen doc/Doxyfile\n```\n\n----------------------------------------\n\nTITLE: Enabling Nested FIQ Interrupts Assembly\nDESCRIPTION: This assembly code demonstrates how to enable nested FIQ interrupts in a FIQ handler. It uses the _tx_thread_fiq_nesting_start and _tx_thread_fiq_nesting_end functions to manage the FIQ nesting. It first saves context, then enables nested interrupts, calls application FIQ handlers, disables nested interrupts, and finally restores the context.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/cortex_a7_smp/gnu/readme_threadx.txt#_snippet_4\n\nLANGUAGE: Assembly\nCODE:\n```\nEXPORT  __tx_fiq_handler\nEXPORT  __tx_fiq_processing_return\n__tx_fiq_handler\n;\n;    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return\n;\n;    /* At this point execution is still in the FIQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use.  */\n;\n;    /* Enable nested FIQ interrupts. NOTE:  Since this service returns\n;       with FIQ interrupts enabled, all FIQ interrupt sources must be \n;       cleared prior to calling this service.  */\n    BL      _tx_thread_fiq_nesting_start\n;\n;    /* Application FIQ handlers can be called here!  */\n;\n;    /* Disable nested FIQ interrupts. The mode is switched back to\n;       FIQ mode and FIQ interrupts are disable upon return.  */\n    BL      _tx_thread_fiq_nesting_end\n;\n;    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: Example Certificate Output (Bash)\nDESCRIPTION: This is an example of the output from the `openssl x509` command. It shows the certificate details, including the serial number, issuer, validity dates, subject, and public key information.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_11\n\nLANGUAGE: Bash\nCODE:\n```\nCertificate:\n    Data:\n        Version: 1 (0x0)\n        Serial Number:\n            40:1a:fa:d2:fd:a5:b2:b7:e7:59:b8:0d:17:4d:9a:10:19:6f:56:0b\n        Signature Algorithm: ecdsa-with-SHA256\n        Issuer: CN = paho-sample-device1\n        Validity\n            Not Before: Sep 17 22:10:12 2020 GMT\n            Not After : Sep 17 22:10:12 2021 GMT\n        Subject: CN = paho-sample-device1\n        Subject Public Key Info:\n            Public Key Algorithm: id-ecPublicKey\n                Public-Key: (256 bit)\n                pub:\n                    04:d0:23:f4:71:8a:5b:d2:2b:e3:95:94:0f:62:1b:\n                    03:52:f2:e3:99:50:e8:23:84:26:ac:aa:88:e5:28:\n                    44:ba:56:5c:80:0d:4f:3b:e2:a3:28:60:87:a4:d1:\n                    e5:13:49:45:cd:e0:e6:ad:f1:39:e6:47:47:7d:d5:\n                    55:1b:fd:53:3e\n                ASN1 OID: prime256v1\n                NIST CURVE: P-256\n    Signature Algorithm: ecdsa-with-SHA256\n        30:46:02:21:00:a6:c6:63:16:97:e6:19:ec:a2:f5:c2:20:da:\n        91:73:5e:c1:a3:9a:02:76:c7:89:ab:65:c7:22:8b:ea:21:2e:\n        cf:02:21:00:9a:c9:15:c7:b3:ac:c0:ef:38:9b:ed:3b:ff:3d:\n        62:88:71:29:56:ce:3f:d7:39:fb:0f:54:a3:78:65:c6:be:2f\n```\n\n----------------------------------------\n\nTITLE: CPI Multiplier Configuration\nDESCRIPTION: This parameter sets the multiplier for calculating Cycles Per Instruction (CPI). It's an integer value that can be configured at run-time.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/ARMCM3_config.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.cpi_mul=1                               # (int   , run-time ) default = '0x1'    : multiplier for calculating CPI (Cycles Per Instruction)\n```\n\n----------------------------------------\n\nTITLE: Configuring and Installing mbedx509.pc with CMake\nDESCRIPTION: This CMake snippet configures the mbedx509.pc.in file, replacing variables with their values, and then installs the generated mbedx509.pc file into the pkgconfig directory within the library installation directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/pkgconfig/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nconfigure_file(mbedx509.pc.in mbedx509.pc @ONLY)\ninstall(FILES\n    ${CMAKE_CURRENT_BINARY_DIR}/mbedx509.pc\n    DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration\nDESCRIPTION: This snippet shows the required configuration in the EWARM linker (.icf) file to properly allocate memory for ThreadX. It places the last section FREE_MEM in the RAM_region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_DualClass/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories in CMake\nDESCRIPTION: This CMake code snippet adds an include directory to the specified target (`${PROJECT_NAME}`). It uses the `target_include_directories` command with the `PUBLIC` keyword, making the include directory available to other targets that depend on this one. The `CMAKE_CURRENT_LIST_DIR` variable represents the directory where the current CMakeLists.txt file is located, and \"/inc\" specifies the subdirectory containing the header files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/win32/vs_2019/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting IoT Hub SAS Environment Variables - PowerShell\nDESCRIPTION: This code snippet shows how to set the AZ_IOT_HUB_SAS_DEVICE_ID, AZ_IOT_HUB_SAS_KEY, and AZ_IOT_HUB_HOSTNAME environment variables in PowerShell for IoT Hub SAS authentication. Replace `<sas-device-id>`, `<sas-key>`, and `<hostname>` with the correct values from your Azure IoT Hub.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_20\n\nLANGUAGE: powershell\nCODE:\n```\n$env:AZ_IOT_HUB_SAS_DEVICE_ID='<sas-device-id>'\n$env:AZ_IOT_HUB_SAS_KEY='<sas-key>'\n$env:AZ_IOT_HUB_HOSTNAME='<hostname>'\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories with CMake\nDESCRIPTION: This CMake command adds include directories to the specified target. The PUBLIC keyword makes these include directories available to other targets that link against this one. The ${CMAKE_CURRENT_LIST_DIR}/inc variable specifies the path to the include directory, relative to the current CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m0/iar/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion\nDESCRIPTION: Conditionally includes the floating-point 16-bit source files (SRCF16) in the build based on whether ARMAC5 is defined and DISABLEFLOAT16 is not defined. This allows for tailoring the library to specific target architectures and build configurations.  `ARMAC5` likely refers to the ARM Compiler 5, and `DISABLEFLOAT16` suggests the ability to disable float16 support.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/BasicMathFunctions/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPBasicMath PRIVATE ${SRCF16})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building ThreadX Runtime Library (Batch)\nDESCRIPTION: This batch script builds the ThreadX runtime environment. It compiles and assembles ThreadX source files and combines them into the tx.a library file, which is necessary for linking with applications using ThreadX. The script assumes that the ARM GNU compiler path and environment variables are properly configured.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: Batch\nCODE:\n```\nbuild_threadx.bat\n```\n\n----------------------------------------\n\nTITLE: Adding Complex FFT source files (Q31) in CMake\nDESCRIPTION: This snippet conditionally adds various complex FFT (CFFT) source files for Q31 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR CFFT_Q31_16 OR CFFT_Q31_32 OR CFFT_Q31_64 OR CFFT_Q31_128 OR CFFT_Q31_256 OR CFFT_Q31_512 \n    OR CFFT_Q31_1024 OR CFFT_Q31_2048 OR CFFT_Q31_4096)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix2_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_q31.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Add TLS Test Cases with Source Files\nDESCRIPTION: This snippet demonstrates how to add TLS test cases to the nx_secure_test_cases list and associate specific source files with each test case using set command. Each test case represents a different aspect of TLS functionality, like version negotiation or cipher suite testing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/regression/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND nx_secure_test_cases demo_ping_test)\nset(demo_ping_test_file_list ${SOURCE_DIR}/demo_ping_test.c)\n\nlist(APPEND nx_secure_test_cases demo_tls_test)\nset(demo_tls_test_file_list ${SOURCE_DIR}/demo_tls_test.c\n                            ${SOURCE_DIR}/demo_tls_test_server.c)\n\nlist(APPEND nx_secure_test_cases\n     tls_1_0_openssl_echo_server_nx_secure_echo_client_test)\nset(tls_1_0_openssl_echo_server_nx_secure_echo_client_test_file_list\n    ${SOURCE_DIR}/tls_1_0_openssl_echo_server_entry.c\n    ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_test.c\n    ${SOURCE_DIR}/nx_secure_1_0_1_1_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases\n     tls_1_1_openssl_echo_server_nx_secure_echo_client_test)\nset(tls_1_1_openssl_echo_server_nx_secure_echo_client_test_file_list\n    ${SOURCE_DIR}/tls_1_1_openssl_echo_server_entry.c\n    ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_test.c\n    ${SOURCE_DIR}/nx_secure_1_0_1_1_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases\n     tls_1_2_openssl_echo_server_nx_secure_echo_client_test)\nset(tls_1_2_openssl_echo_server_nx_secure_echo_client_test_file_list\n    ${SOURCE_DIR}/tls_1_2_openssl_echo_server_entry.c\n    ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_test.c\n    ${SOURCE_DIR}/nx_secure_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases\n     override_tls_1_1_openssl_echo_server_nx_secure_echo_client_test)\nset(override_tls_1_1_openssl_echo_server_nx_secure_echo_client_test_file_list\n    ${SOURCE_DIR}/tls_1_1_openssl_echo_server_entry.c\n    ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_long_time_test.c\n    ${SOURCE_DIR}/nx_secure_override_tls_1_1_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_1_2_protocol_version_negotiation_test)\nset(tls_1_2_protocol_version_negotiation_test_file_list\n    ${SOURCE_DIR}/tls_negotiation_test.c\n    ${SOURCE_DIR}/nx_secure_echo_server_entry.c\n    ${SOURCE_DIR}/tls_1_2_openssl_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases openssl_1_1_protocol_version_negotiation_test)\nset(openssl_1_1_protocol_version_negotiation_test_file_list\n    ${SOURCE_DIR}/tls_ecc_negotiation_test.c\n    ${SOURCE_DIR}/nx_secure_ecc_echo_server_entry.c\n    ${SOURCE_DIR}/tls_openssl_1_1_prime256v1_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_1_1_protocol_version_negotiation_test)\nset(tls_1_1_protocol_version_negotiation_test_file_list\n    ${SOURCE_DIR}/tls_negotiation_test.c\n    ${SOURCE_DIR}/nx_secure_1_0_1_1_echo_server_entry.c\n    ${SOURCE_DIR}/tls_1_1_openssl_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_1_0_protocol_version_negotiation_test)\nset(tls_1_0_protocol_version_negotiation_test_file_list\n    ${SOURCE_DIR}/tls_negotiation_test.c\n    ${SOURCE_DIR}/nx_secure_echo_server_entry.c\n    ${SOURCE_DIR}/tls_1_0_openssl_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_ecc_client_ciphersuites_test)\nset(tls_ecc_client_ciphersuites_test_file_list\n    ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_long_time_test.c\n    ${SOURCE_DIR}/nx_secure_ecc_echo_client_entry.c\n    ${SOURCE_DIR}/ecc_tls_1_2_openssl_echo_server_entry.c)\n\nlist(APPEND nx_secure_test_cases rsa_aes128_sha_ciphersuite_test)\nset(rsa_aes128_sha_ciphersuite_test_file_list\n    ${SOURCE_DIR}/tls_negotiation_test.c\n    ${SOURCE_DIR}/nx_secure_echo_server_entry.c\n    ${SOURCE_DIR}/rsa_aes128_sha_openssl_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases rsa_aes256_sha_ciphersuite_test)\nset(rsa_aes256_sha_ciphersuite_test_file_list\n    ${SOURCE_DIR}/tls_negotiation_test.c\n    ${SOURCE_DIR}/nx_secure_echo_server_entry.c\n    ${SOURCE_DIR}/rsa_aes256_sha_openssl_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases rsa_aes128_gcm_ciphersuite_test)\nset(rsa_aes128_gcm_ciphersuite_test_file_list\n    ${SOURCE_DIR}/tls_negotiation_test.c\n    ${SOURCE_DIR}/nx_secure_echo_server_entry.c\n    ${SOURCE_DIR}/rsa_aes128_gcm_openssl_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases rsa_aes128_gcm_ciphersuite_client_test)\nset(rsa_aes128_gcm_ciphersuite_client_test_file_list\n    ${SOURCE_DIR}/tls_1_2_openssl_echo_server_entry.c\n    ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_test.c\n    ${SOURCE_DIR}/nx_secure_echo_client_aes128_gcm_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_ecc_server_basic_test)\nset(tls_ecc_server_basic_test_file_list\n    ${SOURCE_DIR}/tls_ecc_negotiation_test.c\n    ${SOURCE_DIR}/nx_secure_ecc_echo_server_entry.c\n    ${SOURCE_DIR}/tls_1_2_openssl_echo_client_entry.c)\n\nlist(APPEND nx_secure_test_cases client_certificate_verify_server_test)\nset(client_certificate_verify_server_test_file_list\n    ${SOURCE_DIR}/tls_negotiation_test.c\n    ${SOURCE_DIR}/openssl_client_certificate_verify_test_client_entry.c\n    ${SOURCE_DIR}/nx_secure_client_certificate_verify_test_server_entry.c)\n\nlist(APPEND nx_secure_test_cases client_certificate_verify_client_test)\nset(client_certificate_verify_client_test_file_list\n    ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_test.c\n    ${SOURCE_DIR}/openssl_client_certificate_verify_test_server_entry.c\n    ${SOURCE_DIR}/nx_secure_client_certificate_verify_test_client_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_ecc_server_ciphersuites_test)\nset(tls_ecc_server_ciphersuites_test_file_list\n    ${SOURCE_DIR}/tls_ecc_server_ciphersuites_test.c\n    ${SOURCE_DIR}/nx_secure_ecc_server_ciphersuites_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_ecc_server_curves_test)\nset(tls_ecc_server_curves_test_file_list\n    ${SOURCE_DIR}/tls_ecc_server_curves_test.c\n    ${SOURCE_DIR}/nx_secure_ecc_server_curves_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_ecc_client_curves_test)\nset(tls_ecc_client_curves_test_file_list\n    ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_long_time_test.c\n    ${SOURCE_DIR}/ecc_tls_1_2_openssl_curves_test_server_entry.c\n    ${SOURCE_DIR}/nx_secure_ecc_curves_test_client_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_ecc_server_cert_test)\nset(tls_ecc_server_cert_test_file_list\n    ${SOURCE_DIR}/tls_ecc_server_cert_test.c\n    ${SOURCE_DIR}/nx_secure_ecc_server_cert_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_ecc_client_cert_test)\nset(tls_ecc_client_cert_test_file_list\n    ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_test.c\n    ${SOURCE_DIR}/ecc_tls_1_2_openssl_client_cert_test_server_entry.c\n    ${SOURCE_DIR}/nx_secure_ecc_client_cert_test_client_entry.c)\n\nlist(APPEND nx_secure_test_cases tls_1_0_1_1_ecc_server_test)\nset(tls_1_0_1_1_ecc_server_test_file_list\n    ${SOURCE_DIR}/tls_1_0_1_1_ecc_server_test.c\n    ${SOURCE_DIR}/nx_secure_ecc_1_0_1_1_server_entry.c)\n```\n\n----------------------------------------\n\nTITLE: Linker configuration for EWARM in .icf format\nDESCRIPTION: This snippet shows how to configure the linker file for EWARM to place the free memory section in the RAM region. This is necessary for ThreadX to properly allocate memory dynamically by finding the last section FREE_MEM.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_TCP_Echo_Client/README.md#_snippet_1\n\nLANGUAGE: other\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Setting BSD Test Cases (Conditional)\nDESCRIPTION: This snippet conditionally defines a list of BSD socket test cases.  It checks if the `-DNX_BSD_ENABLE` flag is present in the `CMAKE_BUILD_TYPE` variable. If it is, it defines the `bsd_test_cases` variable with a list of C source files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"-DNX_BSD_ENABLE\" IN_LIST ${CMAKE_BUILD_TYPE})\n  set(bsd_test_cases\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_clients_shared_port_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_accept_noselect_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_blocking_bidirection_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_udp_blocking_bidirection_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_clients_share_port_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_servers_share_port_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_basic_blocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_two_blocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_2nd_bind_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_multicast_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_bind_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_disconnect_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_udp_select_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_accept_nonblocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_pton_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_ntoa_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_ntop_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_ioctl_nonblocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_udp_connect_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_sendto_recvfrom_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_accept_nonblocking_timeout_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_udp_bind_connect_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_udp_basic_nonblocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_multiple_accept_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_udp_bind_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_aton_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_inet_addr_pton_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_accept_blocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_udp_basic_blocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_basic_nonblocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_servers_shared_port_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_getsockname_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_accept_blocking_timeout_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_udp_checksum_corrupt_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_getaddrinfo_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_getsockname_without_bind_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_rcvbuf_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_tcp_fionread_test.c)\n```\n\n----------------------------------------\n\nTITLE: Setting ThreadX Include Directories in CMake\nDESCRIPTION: This CMake snippet sets the target include directories for the ThreadX component. It uses the `target_include_directories` command to add the `inc` directory as a public include directory for the specified project name (`${PROJECT_NAME}`). This allows other parts of the project to include header files from the `inc` directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/ac6/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    inc\n)\n```\n\n----------------------------------------\n\nTITLE: Logging HTTP Requests and Responses in C\nDESCRIPTION: This example demonstrates how to log HTTP request and response messages to standard output.  It includes the callback functions for writing the log message and filtering the log classification.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nstatic void write_log_message(az_log_classification classification, az_span message)\n{\n   (void)classification;\n   printf(\"%.*s\\n\", az_span_size(message), az_span_ptr(message));\n}\n\nstatic bool should_write_log_message(az_log_classification classification)\n{\n   switch (classification)\n   {\n      case AZ_LOG_HTTP_REQUEST:\n      case AZ_LOG_HTTP_RESPONSE:\n         return true;\n      default:\n         return false;\n   }\n}\n\nint main()\n{\n   az_log_set_message_callback(write_log_message);\n   az_log_set_classification_filter_callback(should_write_log_message);\n\n   // More code goes here...\n}\n```\n\n----------------------------------------\n\nTITLE: Running Mbed TLS Tests with CTest\nDESCRIPTION: This snippet demonstrates how to run the Mbed TLS test suite using the `ctest` command after a CMake build. It assumes that the necessary dependencies (Python and Perl) are installed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nctest\n```\n\n----------------------------------------\n\nTITLE: Set Architecture Compile Options\nDESCRIPTION: This snippet sets compile and link options based on whether the environment variable `ENABLE_64` is set. If it's set, it builds for 64-bit; otherwise, it adds options to build for 32-bit architecture. It uses the -m32 flag for both compilation and linking when building for 32-bit.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif($ENV{ENABLE_64})\n  message(STATUS \"Building for 64bit\")\nelse()\n  add_compile_options(-m32)\n  add_link_options(-m32)\n  message(STATUS \"Building for 32bit\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Registering an Event to a Task in C\nDESCRIPTION: This C code demonstrates how to register an event to a task using the RegisterEventtoTask function.  The function takes the event ID and the Task ID as parameters and returns a StatusType. An event can only be registered to a single task.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nStatusType RegisterEventtoTask(EventType eventid, \n                                   TaskType TaskID);\n```\n\n----------------------------------------\n\nTITLE: Adding USB Host Class Source Files in CMake\nDESCRIPTION: This snippet demonstrates how to add C source files for various USB host classes (ASIX, Audio, CDC ACM/ECM, GSER, HID, Hub) to a target using CMake's `target_sources` command.  The `PRIVATE` keyword indicates that these sources are only used for the specified target. The snippet uses `${CMAKE_CURRENT_LIST_DIR}` to reference the current directory in the CMake list file where this command is present.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_host_classes/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_configure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_endpoints_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_interrupt_notification.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_reception_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_setup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_transmission_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_asix_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_alternate_setting_locate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_configure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_control_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_control_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_control_value_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_control_value_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_descriptor_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_descriptors_parse.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_device_controls_list_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_device_type_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_endpoints_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_entity_control_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_entity_control_value_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_entity_control_value_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_feedback_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_feedback_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_feedback_transfer_completed.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_interrupt_notification.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_interrupt_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_raw_sampling_parse.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_stop.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_streaming_sampling_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_streaming_sampling_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_streaming_terminal_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_transfer_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_transfer_request_completed.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_audio_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_capabilities_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_command.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_configure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_endpoints_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_ioctl.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_reception_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_reception_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_reception_stop.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_transfer_request_completed.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_transmission_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_acm_write_with_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_ecm_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_ecm_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_ecm_endpoints_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_ecm_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_ecm_interrupt_notification.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_ecm_mac_address_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_ecm_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_ecm_transmission_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_ecm_transmit_queue_clean.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_cdc_ecm_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_command.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_configure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_endpoints_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_ioctl.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_reception_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_reception_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_reception_stop.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_gser_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_client_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_client_search.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_configure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_descriptor_parse.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_field_decompress.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_global_item_parse.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_idle_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_idle_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_idle_set_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_instance_clean.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_interrupt_endpoint_search.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_item_data_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_keyboard_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_keyboard_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_keyboard_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_keyboard_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_keyboard_ioctl.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_keyboard_key_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_keyboard_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_keyboard_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_local_item_parse.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_main_item_parse.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_mouse_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_mouse_buttons_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_mouse_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_mouse_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_mouse_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_mouse_position_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_mouse_wheel_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_periodic_report_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_periodic_report_stop.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_remote_control_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_remote_control_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_remote_control_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_remote_control_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_remote_control_usage_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_report_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_report_callback_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_report_compress.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_report_decompress.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_report_descriptor_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_report_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_report_id_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_report_item_analyse.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_report_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_report_set_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_resources_free.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hid_transfer_request_completed.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_change_detect.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_change_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_configure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_descriptor_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_feature.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_hub_change_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_interrupt_endpoint_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_port_change_connection_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_port_change_enable_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_port_change_over_current_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_class_hub_port_change_process.c)\n```\n\n----------------------------------------\n\nTITLE: C ISR Definition in ThreadX\nDESCRIPTION: Defines an interrupt service routine (ISR) written in C for use with ThreadX. The ISR, 'your_C_isr', is a void function that contains the interrupt processing logic. This function represents an entry point in the vector table.  The ThreadX API available to ISRs can be called within this function.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m23/ac6/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: ThreadX Heap Configuration - STM32CubeIDE\nDESCRIPTION: This configuration is for the STM32CubeIDE. It shows how to define a new section in the linker script (.ld file) for the ThreadX heap, aligning it and setting its size.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Applications/USBX/Ux_Device_CDC_ACM/README.md#_snippet_2\n\nLANGUAGE: LD\nCODE:\n```\n._threadx_heap :\n  {\n    . = ALIGN(8);\n    __RAM_segment_used_end__ = .;\n    . = . + 64K;\n    . = ALIGN(8);\n  } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: RSA Modulus Declaration\nDESCRIPTION: Defines the RSA modulus (N) as a hexadecimal string. The modulus is a large integer that is part of the public key used for encryption and signature verification in RSA cryptography. It is a critical parameter for the security of the RSA algorithm.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/rsa_pub.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nN = A1D46FBA2318F8DCEF16C280948B1CF27966B9B47225ED2989F8D74B45BD36049C0AAB5AD0FF003553BA843C8E12782FC5873BB89A3DC84B883D25666CD22BF3ACD5B675969F8BEBFBCAC93FDD927C7442B178B10D1DFF9398E52316AAE0AF74E594650BDC3C670241D418684593CDA1A7B9DC4F20D2FDC6F66344074003E211\n```\n\n----------------------------------------\n\nTITLE: Allocating Memory from a Pool with tm_memory_pool_allocate in C\nDESCRIPTION: This function allocates a 128-byte block of memory from the previously created memory pool. It takes the pool_id and a pointer to store the allocated memory address. Returns TM_SUCCESS if allocation is successful.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_13\n\nLANGUAGE: C\nCODE:\n```\nint  tm_memory_pool_allocate(int pool_id, unsigned char **memory_ptr);\n```\n\n----------------------------------------\n\nTITLE: Defining a Logging Classification Filter Callback in C\nDESCRIPTION: This code defines the type for a logging classification filter callback function.  The callback receives a log classification and returns a boolean indicating whether to process the log message.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\ntypedef bool (*az_log_classification_filter_fn)(az_log_classification classification);\n```\n\n----------------------------------------\n\nTITLE: Configure Target Sources for USB Host Controller Driver with CMake\nDESCRIPTION: This snippet uses the `target_sources` command in CMake to specify the source files for the USB Host Controller Driver (HCD). It includes source files for both EHCI and OHCI implementations, referencing files within the `${CMAKE_CURRENT_LIST_DIR}/src/` directory. The source files are added as `PRIVATE` to the specified target `${PROJECT_NAME}`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_host_controllers/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_asynch_td_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_asynchronous_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_asynchronous_endpoint_destroy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_controller_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_done_queue_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_door_bell_wait.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_ed_clean.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_ed_obtain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_endpoint_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_frame_number_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_frame_number_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_fsisochronous_td_obtain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_fsisochronous_tds_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_hsisochronous_td_obtain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_hsisochronous_tds_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_interrupt_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_interrupt_endpoint_destroy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_interrupt_handler.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_isochronous_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_isochronous_endpoint_destroy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_least_traffic_list_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_next_td_clean.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_periodic_descriptor_link.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_periodic_tree_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_poll_rate_entry_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_port_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_port_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_port_resume.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_port_status_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_port_suspend.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_power_down_port.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_power_on_port.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_power_root_hubs.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_register_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_register_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_regular_td_obtain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_request_bulk_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_request_control_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_request_interrupt_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_request_isochronous_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_request_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_request_transfer_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_transfer_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ehci_transfer_request_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_asynchronous_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_asynchronous_endpoint_destroy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_controller_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_done_queue_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_ed_obtain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_endpoint_error_clear.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_endpoint_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_frame_number_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_frame_number_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_interrupt_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_interrupt_handler.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_isochronous_endpoint_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_isochronous_td_obtain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_least_traffic_list_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_next_td_clean.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_periodic_endpoint_destroy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_periodic_tree_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_port_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_port_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_port_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_port_resume.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_port_status_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_port_suspend.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_power_down_port.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_power_on_port.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_power_root_hubs.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_register_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_register_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_regular_td_obtain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_request_bulk_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_request_control_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_request_interupt_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_request_isochronous_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_request_transfer.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_transfer_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_hcd_ohci_transfer_request_process.c\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Target Sources in CMake\nDESCRIPTION: This snippet adds the source files defined in the `SOURCES` variable to the specified target (`${PROJECT_NAME}`) as private sources. It utilizes the `target_sources` command to achieve this.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/tsn/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Append IoT Message Properties C\nDESCRIPTION: This code snippet demonstrates how to append properties to an IoT message using the `az_iot_message_properties_init()` and `az_iot_message_properties_append()` APIs. It allocates a buffer, initializes the properties struct, and appends a key-value pair.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n//FOR SIMPLICITY THIS DOES NOT HAVE ERROR CHECKING. IN PRODUCTION ENSURE PROPER ERROR CHECKING.\n\nvoid my_property_func(void)\n{\n  // Allocate a span to put the properties.\n  uint8_t property_buffer[64];\n  az_span property_span = AZ_SPAN_FROM_BUFFER(property_buffer);\n\n  // Initialize the property struct with the span.\n  az_iot_message_properties props;\n  az_iot_message_properties_init(&props, property_span, 0);\n\n  // Append properties.\n  az_iot_message_properties_append(\n      &props, AZ_SPAN_LITERAL_FROM_STR(\"key\"), AZ_SPAN_LITERAL_FROM_STR(\"value\"));\n\n  // At this point, you are able to pass the `props` to other APIs with message property parameters.\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RFFT Options (Q31) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Real FFT (RFFT) implementations for Q31 data types with various sizes (32 to 8192). These options are used to customize the CMSIS-DSP library by selecting specific RFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\noption(RFFT_Q31_32          \"rfft q31 32\"                       OFF)\noption(RFFT_Q31_64          \"rfft q31 64\"                       OFF)\noption(RFFT_Q31_128         \"rfft q31 128\"                      OFF)\noption(RFFT_Q31_256         \"rfft q31 256\"                      OFF)\noption(RFFT_Q31_512         \"rfft q31 512\"                      OFF)\noption(RFFT_Q31_1024        \"rfft q31 1024\"                     OFF)\noption(RFFT_Q31_2048        \"rfft q31 2048\"                     OFF)\noption(RFFT_Q31_4096        \"rfft q31 4096\"                     OFF)\noption(RFFT_Q31_8192        \"rfft q31 8192\"                     OFF)\n```\n\n----------------------------------------\n\nTITLE: Creating Alias for Library\nDESCRIPTION: Creates an alias for the `az_core` library. This allows users to refer to the library using the namespace `az::core`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/core/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library (az::core ALIAS az_core)\n```\n\n----------------------------------------\n\nTITLE: Linking Azure SDK Libraries\nDESCRIPTION: This code snippet provides the list of libraries that need to be linked to your VxWorks Real Time Process Project when using the Azure SDK. It includes standard C libraries, network libraries, SSL libraries, Mosquitto, and the Azure SDK libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_vxworks.md#_snippet_4\n\nLANGUAGE: Makefile\nCODE:\n```\n-lc                         # C standard library\n-lnet                       # Network library\n-lssl -lcrypto              # SSL library\n-lmosquitto                 # Mosquitto library\n-laz_core -laz_iot_common   # Azure SDK common libraries\n-laz_iot_provisioning       # Azure IoT Hub Provisioning Client library\n-laz_iot_hub                # Azure IoT Hub Client library\n```\n\n----------------------------------------\n\nTITLE: C ISR Definition for ThreadX with IAR\nDESCRIPTION: This C code snippet defines an Interrupt Service Routine (ISR) for use with ThreadX in an IAR environment. The ISR, named 'your_C_isr', contains the processing logic for the interrupt event. This type of ISR can directly access the ThreadX API functions that are available to ISRs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/iar/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Check CTR_DRBG Configuration\nDESCRIPTION: Executes a Python script to check if 128-bit keys are configured for CTR_DRBG. If so, displays a warning message. Requires a Python executable to be found.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nif(MBEDTLS_PYTHON_EXECUTABLE)\n\n    # If 128-bit keys are configured for CTR_DRBG, display an appropriate warning\n    execute_process(COMMAND ${MBEDTLS_PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/scripts/config.py -f ${CMAKE_CURRENT_SOURCE_DIR}/include/mbedtls/mbedtls_config.h get MBEDTLS_CTR_DRBG_USE_128_BIT_KEY\n                        RESULT_VARIABLE result)\n    if(${result} EQUAL 0)\n        message(WARNING ${CTR_DRBG_128_BIT_KEY_WARNING})\n    endif()\n\nendif()\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration for ThreadX Heap\nDESCRIPTION: This snippet demonstrates the linker configuration for MDK-ARM to allocate memory for the ThreadX heap. It either defines the RW_IRAM1 region in the .sct file or modifies the tx_low_level_initilize.S file to match the memory region being used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_LowPower/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for Video Class Host Tests CMake\nDESCRIPTION: Defines the source file paths for the USBX host class video test cases. These files are used to test the video class functionality on the host side of a USB connection. It includes format specific tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\n ${SOURCE_DIR}/usbx_ux_host_class_video_format_frame_based_test.c # device control buffer > 512\n    ${SOURCE_DIR}/usbx_ux_host_class_video_format_h264_test.c        # device control buffer > 512\n    ${SOURCE_DIR}/usbx_uxe_device_video_test.c\n    ${SOURCE_DIR}/usbx_uxe_host_video_test.c\n```\n\n----------------------------------------\n\nTITLE: Get Key Derivation Input Bytes Function (C)\nDESCRIPTION: This function retrieves the bytes of a key derivation input for a specified step. It copies the input data into the provided buffer, setting the actual length in `buffer_length`.  If `buffer_size` is too small, it returns `PSA_ERROR_BUFFER_TOO_SMALL`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_crypto_driver_key_derivation_get_input_bytes(\n    const psa_crypto_driver_key_derivation_inputs_t *inputs,\n    psa_key_derivation_step_t step,\n    uint8_t *buffer, size_t buffer_size, size_t *buffer_length);\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for Basic Tests CMake\nDESCRIPTION: Defines the source file paths for the basic USBX test cases. These tests cover fundamental USB functionalities such as device enumeration, interface enumeration, and string retrieval.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_26\n\nLANGUAGE: CMake\nCODE:\n```\n   ${SOURCE_DIR}/usbx_class_device_enumeration_test.c\n    ${SOURCE_DIR}/usbx_class_interface_enumeration_test.c\n    ${SOURCE_DIR}/usbx_class_multi_interface_enumeration_test.c\n    ${SOURCE_DIR}/usbx_ux_host_stack_device_string_get_test.c\n```\n\n----------------------------------------\n\nTITLE: Relinquishing Thread Control with tm_thread_relinquish in C\nDESCRIPTION: This function allows other threads of the same priority to execute before the calling thread runs again. It effectively yields the current thread's time slice.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nvoid  tm_thread_relinquish(void);\n```\n\n----------------------------------------\n\nTITLE: Configure Executables in CMake\nDESCRIPTION: This CMake script iterates through a list of executables.  For each executable, it adds the executable, links it with the mbedtls test target, mbedcrypto library, and thread libraries.  It also adds an include directory for the executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/aes/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(exe IN LISTS executables)\n    add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>)\n    target_link_libraries(${exe} ${mbedcrypto_target} ${CMAKE_THREAD_LIBS_INIT})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Enabling FIQ Nested Interrupts in Handler (Assembly)\nDESCRIPTION: This assembly code snippet demonstrates how to enable nested FIQ interrupts within a typical FIQ handler in ThreadX, when the library is built with TX_ENABLE_FIQ_NESTING defined. It saves the FIQ context, enables nested FIQ interrupts using `_tx_thread_fiq_nesting_start`, calls the application's FIQ handlers, disables nested FIQ interrupts using `_tx_thread_fiq_nesting_end`, and restores the FIQ context. Prior to calling `_tx_thread_fiq_nesting_start`, all FIQ interrupt sources must be cleared. The code switches from FIQ mode to SYS mode and back, using the SYS mode stack.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/gnu/readme_threadx.txt#_snippet_7\n\nLANGUAGE: assembly\nCODE:\n```\n    .global __tx_fiq_handler\n    .global __tx_fiq_processing_return\n__tx_fiq_handler:\n@\n@    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return:\n@\n@    /* At this point execution is still in the FIQ mode. The CPSR, point of\n@       interrupt, and all C scratch registers are available for use.  */\n@\n@    /* Enable nested FIQ interrupts. NOTE:  Since this service returns\n@       with FIQ interrupts enabled, all FIQ interrupt sources must be \n@       cleared prior to calling this service.  */\n    BL      _tx_thread_fiq_nesting_start\n@\n@    /* Application FIQ handlers can be called here!  */\n@\n@    /* Disable nested FIQ interrupts. The mode is switched back to\n@       FIQ mode and FIQ interrupts are disable upon return.  */\n    BL      _tx_thread_fiq_nesting_end\n@\n@    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration\nDESCRIPTION: This snippet demonstrates how to add a new section in the STM32CubeIDE linker file (.ld) to provide memory for ThreadX. It defines a ._threadx_heap section within the RAM_D1 region and sets its size to 64KB.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_Dual_Instance/README.md#_snippet_3\n\nLANGUAGE: LD\nCODE:\n```\n._threadx_heap :\n      {\n         . = ALIGN(8);\n         __RAM_segment_used_end__ = .;\n         . = . + 64K;\n         . = ALIGN(8);\n       } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Appending BSD RAW Test Cases (Conditional)\nDESCRIPTION: This snippet conditionally appends additional RAW socket test cases to the `bsd_test_cases` variable. It checks if both `-DNX_BSD_ENABLE` and `-DNX_BSD_RAW_SUPPORT` flags are present in the `CMAKE_BUILD_TYPE` variable. It uses `list(APPEND ...)` to add the new files to the existing list.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"-DNX_BSD_RAW_SUPPORT\" IN_LIST ${CMAKE_BUILD_TYPE})\n    list(\n      APPEND\n      bsd_test_cases\n      ${SOURCE_DIR}/bsd_test/netx_bsd_raw_rx_nohdr_basic_blocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_raw_basic_rx_nohdr_nonblocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_raw_bind_connect_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_raw_basic_nonblocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_raw_basic_blocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_raw_basic_rx_nohdr_blocking_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_raw_pppoe_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_raw_ping_test.c\n      ${SOURCE_DIR}/bsd_test/netx_bsd_raw_tx_test.)\n  endif()\n```\n\n----------------------------------------\n\nTITLE: Create Executable for IoT Hub Methods Sample\nDESCRIPTION: This snippet creates an executable named `paho_iot_hub_methods_sample` from the `paho_iot_hub_methods_sample.c` file and links it against the common library.  It then defines a map file using the create_map_file macro.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable (paho_iot_hub_methods_sample\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_hub_methods_sample.c\n)\n\ntarget_link_libraries(paho_iot_hub_methods_sample\n  PRIVATE\n    az::iot::sample::common\n)\n\ncreate_map_file(paho_iot_hub_methods_sample paho_iot_hub_methods_sample.map)\n```\n\n----------------------------------------\n\nTITLE: Full-Duplex SPI Transfer using LL Drivers\nDESCRIPTION: The Full-Duplex SPI transfer (16bit) is done using LL Driver functions LL_SPI_TransmitData16 and LL_SPI_ReceiveData16. These low-layer functions offer direct control over the SPI hardware, providing efficient data transfer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples_MIX/SPI/SPI_FullDuplex_ComPolling_Slave/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nLL_SPI_TransmitData16(...);\nLL_SPI_ReceiveData16(...);\n```\n\n----------------------------------------\n\nTITLE: Adding CMSIS-DSP Subdirectory\nDESCRIPTION: This snippet adds the CMSIS-DSP source directory as a subdirectory within the CMake project. This allows the CMSIS-DSP library to be built as part of the main project build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_svm_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Creating Suites Directory\nDESCRIPTION: This snippet creates a directory named `suites` within the current binary directory. This directory will store the generated data files for the test suites.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/tests/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nfile(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/suites)\n```\n\n----------------------------------------\n\nTITLE: Disabling VFP for a Thread (C)\nDESCRIPTION: This C code snippet shows how to disable VFP (Vector Floating Point) register saving for a specific thread in ThreadX. The `tx_thread_vfp_disable()` function disables the saving and restoring of VFP registers when the thread is preempted by an interrupt. This can improve performance if the thread no longer requires VFP support.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/gnu/readme_threadx.txt#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nvoid    tx_thread_vfp_disable(void);\n```\n\n----------------------------------------\n\nTITLE: Creating an az_span from a Byte Buffer in C\nDESCRIPTION: This example shows how to create an `az_span` from a byte buffer in C using `AZ_SPAN_FROM_BUFFER`. This macro takes a byte buffer as input and creates an `az_span` with the size of the buffer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nuint8_t buffer[1024];\nsome_function(AZ_SPAN_FROM_BUFFER(buffer));  // size = 1024\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources in CMake\nDESCRIPTION: This CMake snippet defines the source files for the target named ${PROJECT_NAME}. It uses the target_sources command with the PRIVATE keyword to specify the source files that are internal to the target and should not be exposed to other targets.  The sources include assembly and C files related to thread context switching, interrupt handling, scheduling, and timer interrupts for the ThreadX RTOS, tailored for IAR.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/iar/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_iar.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S    \n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Create and Link Test Utility Library\nDESCRIPTION: This snippet creates the test utility library and links it with the NetXDuo library. It also specifies the include directories and compile definitions for the utility library. The library is marked as PUBLIC for NetXDuo and PRIVATE for the test executables.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/regression/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(test_utility ${test_utility_files})\ntarget_link_libraries(test_utility PUBLIC azrtos::netxduo)\ntarget_include_directories(test_utility PUBLIC ${SOURCE_DIR}/test)\ntarget_compile_definitions(test_utility PUBLIC BATCH_TEST CTEST)\n```\n\n----------------------------------------\n\nTITLE: Coverage settings CMake\nDESCRIPTION: This snippet configures the build for code coverage analysis. If the `CMAKE_BUILD_TYPE` contains `_coverage`, it adds compiler and linker flags to enable coverage reporting using `gcov`. These flags enable the generation of `.gcno` and `.gcda` files during compilation and linking, which are used by `gcov` to produce coverage reports.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\n# Coverage\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(${PRODUCT} PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(${PRODUCT} PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Executable Target\nDESCRIPTION: This snippet creates an executable target named arm_convolution_example.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_convolution_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(arm_convolution_example)\n```\n\n----------------------------------------\n\nTITLE: Configuring Include Directories with CMake\nDESCRIPTION: This snippet uses the `target_include_directories` command in CMake to add include directories for the project. The `${PROJECT_NAME}` variable represents the project's name, and `${CMAKE_CURRENT_LIST_DIR}/inc` specifies the directory containing header files relative to the current CMake list file. These include directories are marked as PUBLIC, making them available to other dependent projects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m3/iar/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Executable\nDESCRIPTION: This snippet creates the executable target named `arm_fft_bin_example`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(arm_fft_bin_example)\n```\n\n----------------------------------------\n\nTITLE: Creating Executable Target\nDESCRIPTION: This snippet defines the executable target named `arm_svm_example`. This creates a target that will be built into an executable file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_svm_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(arm_svm_example)\n```\n\n----------------------------------------\n\nTITLE: Enabling IAR Thread-safe Library Support\nDESCRIPTION: This code shows the line required in the IAR linker control file to enable thread-safe library support when using ThreadX. It initializes a specific section for per-thread data.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/iar/readme_threadx.txt#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\ninitialize by copy with packing = none { section __DLIB_PERTHREAD }; // Required in a multi-threaded application\n```\n\n----------------------------------------\n\nTITLE: Set Environment Variables (PowerShell)\nDESCRIPTION: Shows an example of environment variables that will be outputted by the script to manage Azure KeyVault resources. These variables need to be set manually in the shell or profile script.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/README.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\n${env:KEYVAULT_TENANT_ID} = '<<secret>>'\n${env:KEYVAULT_CLIENT_ID} = '<<secret>>'\n${env:KEYVAULT_CLIENT_SECRET} = '<<secret>>'\n${env:KEYVAULT_SUBSCRIPTION_ID} = 'YOUR SUBSCRIPTION ID'\n${env:KEYVAULT_RESOURCE_GROUP} = 'rg-myusername'\n${env:KEYVAULT_LOCATION} = 'westus'\n${env:KEYVAULT_SKU} = 'premium'\n${env:AZURE_KEYVAULT_URL} = '<<url>>'\n```\n\n----------------------------------------\n\nTITLE: Setting Telemetry Acknowledgment Callback in C\nDESCRIPTION: This function sets a callback function that is invoked when a telemetry acknowledgment is received from Azure IoT Hub. The callback function receives a pointer to the IoT Hub client and the packet ID of the telemetry message. Setting the callback function to NULL disables the callback function.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_18\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_telemetry_ack_callback_set(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                        VOID (*callback_ptr)(\n                                                              NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                              USHORT packet_id));\n```\n\n----------------------------------------\n\nTITLE: Fixing Code Formatting with Clang-Format\nDESCRIPTION: This command uses `clang-format` version 9.0.0 to automatically format all C and header files within the Azure SDK for Embedded C project.  It recursively searches for files ending in `.h` or `.c` and applies formatting changes in-place.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nfind . \\( -iname '*.h' -o -iname '*.c' \\) -exec clang-format -i {} \\; \n```\n\n----------------------------------------\n\nTITLE: Calling OSEK to process an ISR from within the hardware ISR handler in C\nDESCRIPTION: This code snippet shows how to call OSEK to process the ISR from within the hardware ISR handler using the process_ISR2 function. This call is necessary to instruct the OSEK layer to schedule the category 2 ISR as soon as possible. The argument is the ISR name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nvoid demo_isr_hardware_handler(void)\n{\n    /* Call OSEK to process the ISR. */\n    process_ISR2(DemoISR);\n}\n```\n\n----------------------------------------\n\nTITLE: Set CMake Policies\nDESCRIPTION: Sets CMake policies to ensure compatibility and avoid warnings with different CMake versions. These policies govern the behavior of certain CMake commands and features.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_policy(SET CMP0011 NEW)\ncmake_policy(SET CMP0012 NEW)\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows a line of code within the `tx_initialize_low_level.S` file. The instruction loads the limit of the RW_IRAM1 region into register r1, where ThreadX expects to find the available memory. This setup is essential to allocate memory for ThreadX in the MDK-ARM environment.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_Network_Basics_wifi/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nLDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Target Compile Options for FileX\nDESCRIPTION: This snippet adds a compile option to enable the ExFAT file system for the FileX library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/libs/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(filex PRIVATE -DFX_ENABLE_EXFAT)\n```\n\n----------------------------------------\n\nTITLE: Setting Key Algorithm Attribute PSA\nDESCRIPTION: This code snippet explains how to set the permitted algorithm using the `psa_set_key_algorithm` function. This is required to define what cryptographic algorithms can be used with the key.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\npsa_set_key_algorithm\n```\n\n----------------------------------------\n\nTITLE: UART Configuration\nDESCRIPTION: This snippet describes the UART configuration used in the example.  It specifies the BaudRate, Word Length, Stop Bits, Parity, and Hardware flow control settings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples/UART/UART_TwoBoards_ComPolling/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n    - BaudRate = 9600 baud\n    - Word Length = 8 bits (8 data bits, no parity bit)\n    - One Stop Bit\n    - No parity\n    - Hardware flow control disabled (RTS and CTS signals)\n    - Reception and transmission are enabled in the time\n```\n\n----------------------------------------\n\nTITLE: Configure CMSISDSPQuaternionMath Library\nDESCRIPTION: This snippet configures the CMSISDSPQuaternionMath library by calling `configLib` and `configDsp` with the library name and the root directory. These functions are assumed to handle specific configurations related to library setup and DSP features, respectively. It uses the ROOT variable which should be defined elsewhere in the CMake configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/QuaternionMathFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nconfigLib(CMSISDSPQuaternionMath ${ROOT})\nconfigDsp(CMSISDSPQuaternionMath ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: CMake Project Initialization\nDESCRIPTION: Initializes the CMake project, specifying the minimum required CMake version and setting the project name and version. This is the basic starting point for a CMake project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_class_marks_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: Configure Include Directories CMake\nDESCRIPTION: This snippet uses CMake's `target_include_directories` command to add an include directory to the project's include path. It uses a PUBLIC scope so that the included directory is available to other dependent projects. The `${CMAKE_CURRENT_LIST_DIR}/inc` variable specifies the relative path to the include directory, which is located in the `inc` subdirectory of the current list directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/ports/cortex_m0/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: ThreadX heap configuration for STM32CubeIDE\nDESCRIPTION: This code snippet illustrates how to add a new section in the STM32CubeIDE linker file to provide memory for ThreadX. It includes aligning, defining memory usage start/end and the location for ._threadx_heap.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_MSC/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Configuring Include Directories with CMake\nDESCRIPTION: This snippet configures the include directories for the project using the `target_include_directories` command in CMake. It adds the `inc` directory located in the current list directory to the project's include paths. The `PUBLIC` keyword indicates that these headers are accessible to other targets that depend on this project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m7/iar/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This snippet shows how to add a new section named '._threadx_heap' to the STM32CubeIDE linker script (.ld) to allocate memory for ThreadX. The example allocates 64KB for the ThreadX heap and ensures proper alignment.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_CDC_ACM/README.md#_snippet_2\n\nLANGUAGE: STM32CubeIDE Linker\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Managed Interrupt Handler in C for Cortex-M0 ThreadX\nDESCRIPTION: This code snippet demonstrates how to write an Interrupt Service Routine (ISR) in C for Cortex-M0 targets using ThreadX.  The ISR does not require explicit context saving or restoring and has access to ThreadX APIs. It's an entry in the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/keil/readme_threadx.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid your_C_isr(void)\n{\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Example: ThreadX Cortex-M3\nDESCRIPTION: Defines an Interrupt Service Routine (ISR) written in assembly language for ThreadX on Cortex-M3. The ISR must push and pop registers and use BX lr to return. \"your_assembly_isr\" must be an entry in the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/keil/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    EXPORT  your_assembly_isr\nyour_assembly_isr\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Create Executable for IoT Provisioning Sample\nDESCRIPTION: This snippet creates an executable named `paho_iot_provisioning_sample` from the `paho_iot_provisioning_sample.c` file and links it against the common library. A map file is then created.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable (paho_iot_provisioning_sample\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_provisioning_sample.c\n)\n\ntarget_link_libraries(paho_iot_provisioning_sample\n  PRIVATE\n    az::iot::sample::common\n)\n\ncreate_map_file(paho_iot_provisioning_sample paho_iot_provisioning_sample.map)\n```\n\n----------------------------------------\n\nTITLE: Define Project and Languages\nDESCRIPTION: This snippet defines the project name as `nx_secure_test` and specifies that the project uses the C language. This declaration allows CMake to properly manage the build process for a C-based project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(nx_secure_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Example for ThreadX on Cortex-M23\nDESCRIPTION: This assembly code provides a template for creating an Interrupt Service Routine (ISR) in assembly language for ThreadX on Cortex-M23 using the GNU toolchain. It demonstrates how to push registers onto the stack, perform interrupt handling work, and pop the registers before returning from the interrupt. The `.thumb_func` directive ensures that the linker creates a thumb label, required for Cortex-M23 exception handlers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m23/gnu/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    .global  your_assembly_isr\n    .thumb_func\nyour_assembly_isr:\n; VOID your_assembly_isr(VOID)\n; {\n        PUSH    {r0, lr}\n;       \n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n        POP     {r0, r1}\n        MOV     lr, r1\n        BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Disabling Direct Method Message Receiving - C\nDESCRIPTION: This function disables the reception of direct method messages from IoT Hub. It requires a pointer to a valid `NX_AZURE_IOT_HUB_CLIENT` instance and returns a status code indicating success or failure.  Possible failure reasons include invalid parameters, MQTT connection issues, packet pool exhaustion, or communication errors.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_24\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_direct_method_disable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Template for ThreadX on Cortex-M0\nDESCRIPTION: This assembly code snippet demonstrates the structure for creating an ISR in assembly language within ThreadX for Cortex-M0. It pushes the necessary registers onto the stack, performs the ISR logic (potentially calling a C function), and restores the registers before exiting. It requires the `.thumb_func` directive and that bit 0 is set for Thumb compatibility.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/ac6/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n        .global  your_assembly_isr\n        .thumb_func\nyour_assembly_isr:\n; VOID your_assembly_isr(VOID)\n; {\n        PUSH    {r0, lr}\n;       \n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n        POP     {r0, r1}\n        MOV     lr, r1\n        BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Setting NN Source Directory in CMake\nDESCRIPTION: This snippet sets the NN variable to the directory containing the CMSIS-NN source code, which is located under ${ROOT}/CMSIS/NN. It then appends this directory to the CMAKE_MODULE_PATH, which allows CMake to find modules in this directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nSET(NN ${ROOT}/CMSIS/NN)\nlist(APPEND CMAKE_MODULE_PATH ${NN}/Source)\n```\n\n----------------------------------------\n\nTITLE: Target Compile Options for ThreadX\nDESCRIPTION: Sets target-specific compile options for the ThreadX library, including various warning flags to improve code quality and detect potential issues. These are applied privately to the threadx target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(\n  threadx\n  PRIVATE -Werror\n          -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          # -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal)\n```\n\n----------------------------------------\n\nTITLE: Adding Target Compile Options\nDESCRIPTION: This snippet adds a set of compile options to the `netxduo` target, including options for error handling, warnings, code style, and function sections. These options enhance code quality and help identify potential issues during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/crypto/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(\n  netxduo\n  PRIVATE -Werror\n          -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal)\n```\n\n----------------------------------------\n\nTITLE: Setting Key Lifetime with Specified Persistence with PSA in C\nDESCRIPTION: This demonstrates how to set the key lifetime with a specified persistence level using the `PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION` macro. The `persistence` variable holds the desired persistence level.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_54\n\nLANGUAGE: C\nCODE:\n```\npsa_set_key_lifetime(&attributes, PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(\n        PSA_KEY_LOCATION_foo,\n        persistence));\n```\n\n----------------------------------------\n\nTITLE: Install Executables to 'bin' Directory (CMake)\nDESCRIPTION: Installs the built executables to the 'bin' directory.  It also sets the file permissions for the installed executables, providing read, write and execute permissions for the owner, read and execute permissions for the group, and read and execute permissions for others.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/util/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(TARGETS ${executables}\n        DESTINATION \"bin\"\n        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n```\n\n----------------------------------------\n\nTITLE: Interrupt Service Routine (ISR) in Assembly\nDESCRIPTION: This code snippet demonstrates how to write an ISR (Interrupt Service Routine) in assembly language for ThreadX using IAR tools. It shows the basic structure of an assembly ISR, including pushing the link register (lr) onto the stack, performing ISR processing, popping the value back into r0, moving r0 to lr, and then branching to lr to return from the interrupt.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/iar/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    PUBLIC  your_assembly_isr\nyour_assembly_isr:\n\n    PUSH    {lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0}\n    MOV     lr, r0\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Set Regression Test Cases\nDESCRIPTION: This snippet defines a list of C source files that represent the individual regression test cases. These files are later used to create executable tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/regression/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(regression_test_cases\n    ${SOURCE_DIR}/threadx_block_memory_basic_test.c\n    ${SOURCE_DIR}/threadx_block_memory_error_detection_test.c\n    ${SOURCE_DIR}/threadx_block_memory_information_test.c\n    ${SOURCE_DIR}/threadx_block_memory_prioritize_test.c\n    ${SOURCE_DIR}/threadx_block_memory_suspension_test.c\n    ${SOURCE_DIR}/threadx_block_memory_suspension_timeout_test.c\n    ${SOURCE_DIR}/threadx_block_memory_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_basic_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_information_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_prioritize_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_suspension_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_suspension_timeout_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_thread_contention_test.c\n    ${SOURCE_DIR}/threadx_byte_memory_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_event_flag_basic_test.c\n    ${SOURCE_DIR}/threadx_event_flag_information_test.c\n    ${SOURCE_DIR}/threadx_event_flag_isr_set_clear_test.c\n    ${SOURCE_DIR}/threadx_event_flag_isr_wait_abort_test.c\n    ${SOURCE_DIR}/threadx_event_flag_single_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_event_flag_suspension_consume_test.c\n    ${SOURCE_DIR}/threadx_event_flag_suspension_different_bits_consume_test.c\n    ${SOURCE_DIR}/threadx_event_flag_suspension_different_bits_test.c\n    ${SOURCE_DIR}/threadx_event_flag_suspension_test.c\n    ${SOURCE_DIR}/threadx_event_flag_suspension_timeout_test.c\n    ${SOURCE_DIR}/threadx_event_flag_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_interrupt_control_test.c\n    ${SOURCE_DIR}/threadx_mutex_basic_test.c\n    ${SOURCE_DIR}/threadx_mutex_delete_test.c\n    ${SOURCE_DIR}/threadx_mutex_information_test.c\n    ${SOURCE_DIR}/threadx_mutex_nested_priority_inheritance_test.c\n    ${SOURCE_DIR}/threadx_mutex_no_preemption_test.c\n    ${SOURCE_DIR}/threadx_mutex_preemption_test.c\n    ${SOURCE_DIR}/threadx_mutex_priority_inheritance_test.c\n    ${SOURCE_DIR}/threadx_mutex_proritize_test.c\n    ${SOURCE_DIR}/threadx_mutex_suspension_timeout_test.c\n    ${SOURCE_DIR}/threadx_mutex_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_queue_basic_eight_word_test.c\n    ${SOURCE_DIR}/threadx_queue_basic_four_word_test.c\n    ${SOURCE_DIR}/threadx_queue_basic_one_word_test.c\n    ${SOURCE_DIR}/threadx_queue_basic_sixteen_word_test.c\n    ${SOURCE_DIR}/threadx_queue_basic_two_word_test.c\n    ${SOURCE_DIR}/threadx_queue_empty_suspension_test.c\n    ${SOURCE_DIR}/threadx_queue_flush_no_suspension_test.c\n    ${SOURCE_DIR}/threadx_queue_flush_test.c\n    ${SOURCE_DIR}/threadx_queue_front_send_test.c\n    ${SOURCE_DIR}/threadx_queue_full_suspension_test.c\n    ${SOURCE_DIR}/threadx_queue_information_test.c\n    ${SOURCE_DIR}/threadx_queue_prioritize.c\n    ${SOURCE_DIR}/threadx_queue_suspension_timeout_test.c\n    ${SOURCE_DIR}/threadx_queue_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_semaphore_basic_test.c\n    ${SOURCE_DIR}/threadx_semaphore_ceiling_put_test.c\n    ${SOURCE_DIR}/threadx_semaphore_delete_test.c\n    ${SOURCE_DIR}/threadx_semaphore_information_test.c\n    ${SOURCE_DIR}/threadx_semaphore_non_preemption_test.c\n    ${SOURCE_DIR}/threadx_semaphore_preemption_test.c\n    ${SOURCE_DIR}/threadx_semaphore_prioritize.c\n    ${SOURCE_DIR}/threadx_semaphore_thread_terminate_test.c\n    ${SOURCE_DIR}/threadx_semaphore_timeout_test.c\n    ${SOURCE_DIR}/threadx_smp_multiple_threads_one_core_test.c\n    ${SOURCE_DIR}/threadx_smp_non_trivial_scheduling_test.c\n    ${SOURCE_DIR}/threadx_smp_one_thread_dynamic_exclusion_test.c\n    ${SOURCE_DIR}/threadx_smp_preemption_threshold_test.c\n    ${SOURCE_DIR}/threadx_smp_random_resume_suspend_exclusion_pt_test.c\n    ${SOURCE_DIR}/threadx_smp_random_resume_suspend_exclusion_test.c\n    ${SOURCE_DIR}/threadx_smp_random_resume_suspend_test.c\n    ${SOURCE_DIR}/threadx_smp_rebalance_exclusion_test.c\n    ${SOURCE_DIR}/threadx_smp_relinquish_test.c\n    ${SOURCE_DIR}/threadx_smp_resume_suspend_accending_order_test.c\n    ${SOURCE_DIR}/threadx_smp_resume_suspend_decending_order_test.c\n    ${SOURCE_DIR}/threadx_smp_time_slice_test.c\n    ${SOURCE_DIR}/threadx_smp_two_threads_one_core_test.c\n    ${SOURCE_DIR}/threadx_thread_basic_execution_test.c\n    ${SOURCE_DIR}/threadx_thread_basic_time_slice_test.c\n    ${SOURCE_DIR}/threadx_thread_completed_test.c\n    ${SOURCE_DIR}/threadx_thread_create_preemption_threshold_test.c\n    ${SOURCE_DIR}/threadx_thread_delayed_suspension_test.c\n    ${SOURCE_DIR}/threadx_thread_information_test.c\n    ${SOURCE_DIR}/threadx_thread_multi_level_preemption_threshold_test.c\n    ${SOURCE_DIR}/threadx_thread_multiple_non_current_test.c\n    ${SOURCE_DIR}/threadx_thread_multiple_sleep_test.c\n    ${SOURCE_DIR}/threadx_thread_multiple_suspension_test.c\n    ${SOURCE_DIR}/threadx_thread_multiple_time_slice_test.c\n    ${SOURCE_DIR}/threadx_thread_preemptable_suspension_test.c\n    ${SOURCE_DIR}/threadx_thread_preemption_change_test.c\n    ${SOURCE_DIR}/threadx_thread_priority_change.c\n    ${SOURCE_DIR}/threadx_thread_relinquish_test.c\n    ${SOURCE_DIR}/threadx_thread_reset_test.c\n    ${SOURCE_DIR}/threadx_thread_simple_sleep_non_clear_test.c\n    ${SOURCE_DIR}/threadx_thread_simple_sleep_test.c\n    ${SOURCE_DIR}/threadx_thread_simple_suspend_test.c\n    ${SOURCE_DIR}/threadx_thread_sleep_for_100ticks_test.c\n    ${SOURCE_DIR}/threadx_thread_sleep_terminate_test.c\n    ${SOURCE_DIR}/threadx_thread_stack_checking_test.c\n    ${SOURCE_DIR}/threadx_thread_terminate_delete_test.c\n    ${SOURCE_DIR}/threadx_thread_time_slice_change_test.c\n    ${SOURCE_DIR}/threadx_thread_wait_abort_and_isr_test.c\n    ${SOURCE_DIR}/threadx_thread_wait_abort_test.c\n    ${SOURCE_DIR}/threadx_time_get_set_test.c\n    ${SOURCE_DIR}/threadx_timer_activate_deactivate_test.c\n    ${SOURCE_DIR}/threadx_timer_deactivate_accuracy_test.c\n    ${SOURCE_DIR}/threadx_timer_information_test.c\n    ${SOURCE_DIR}/threadx_timer_large_timer_accuracy_test.c\n    ${SOURCE_DIR}/threadx_timer_multiple_accuracy_test.c\n    ${SOURCE_DIR}/threadx_timer_multiple_test.c\n    ${SOURCE_DIR}/threadx_timer_simple_test.c\n    ${SOURCE_DIR}/threadx_trace_basic_test.c\n    ${SOURCE_DIR}/threadx_initialize_kernel_setup_test.c)\n```\n\n----------------------------------------\n\nTITLE: Setting CDC-ACM Test Cases Variable in CMake\nDESCRIPTION: This snippet defines a CMake variable, `ux_class_cdc_acm_test_cases`, and assigns it a list of source files related to CDC-ACM tests.  The source files are C files for testing the USBX CDC-ACM class, for both host and device sides.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_cdc_acm_test_cases\n    ${SOURCE_DIR}/usbx_cdc_acm_basic_test.c\n    ${SOURCE_DIR}/usbx_cdc_acm_basic_memory_test.c\n    ${SOURCE_DIR}/usbx_cdc_acm_configure_test.c\n    ${SOURCE_DIR}/usbx_cdc_acm_device_dtr_rts_reset_on_disconnect_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_acm_activate_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_acm_deactivate_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_acm_ioctl_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_acm_transmission_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_acm_write_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_acm_timeout_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_acm_activate_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_acm_capabilities_get_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_acm_deactivate_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_acm_endpoints_get_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_acm_entry_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_acm_read_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_acm_transfer_request_completed_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_acm_write_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_acm_bulkout_thread_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: Configure Target Sources with CMake\nDESCRIPTION: This snippet configures the target sources for the project using the `target_sources` command in CMake. The `PRIVATE` keyword indicates that these sources are only used within the target. The placeholder comments `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` suggest that specific source files should be listed within these comments.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m33/ac6/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Target Include Directories with CMake\nDESCRIPTION: This CMake snippet adds the include directories to the specified project target. It sets the include directories to be PUBLIC, making them available to dependent projects. It includes both the 'inc' and 'ports' directories within the current list directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/nx_secure/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} \n    PUBLIC \n    ${CMAKE_CURRENT_LIST_DIR}/inc\n    ${CMAKE_CURRENT_LIST_DIR}/ports\n)\n```\n\n----------------------------------------\n\nTITLE: Define Standalone Source Sets for USB Hub Class Tests\nDESCRIPTION: This snippet defines a variable `ux_class_hub_standalone_test_cases` that contains a list of C source files for standalone USB Hub class tests. These files are located in the specified `SOURCE_DIR`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_hub_standalone_test_cases\n    ${SOURCE_DIR}/usbx_hub_basic_test.c\n    ${SOURCE_DIR}/usbx_hub_basic_memory_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: Conditionally Appending Azure IoT Sources (CMake)\nDESCRIPTION: This snippet conditionally appends Azure IoT source files to the SOURCES list and adds the Azure SDK as a subdirectory if the NXD_ENABLE_AZURE_IOT CMake option is enabled. It also sets an environment variable to disable samples in the Azure SDK build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(NXD_ENABLE_AZURE_IOT)\n    list(APPEND SOURCES\n         ${CMAKE_CURRENT_LIST_DIR}/azure_iot/nx_azure_iot.c\n         ${CMAKE_CURRENT_LIST_DIR}/azure_iot/nx_azure_iot_hub_client.c\n         ${CMAKE_CURRENT_LIST_DIR}/azure_iot/nx_azure_iot_hub_client_properties.c\n         ${CMAKE_CURRENT_LIST_DIR}/azure_iot/nx_azure_iot_json_reader.c\n         ${CMAKE_CURRENT_LIST_DIR}/azure_iot/nx_azure_iot_json_writer.c\n         ${CMAKE_CURRENT_LIST_DIR}/azure_iot/nx_azure_iot_provisioning_client.c\n         ${CMAKE_CURRENT_LIST_DIR}/azure_iot/nx_azure_iot_adu_agent.c\n         ${CMAKE_CURRENT_LIST_DIR}/azure_iot/nx_azure_iot_adu_root_key.c\n    )\n    set(ENV{AZ_SDK_C_NO_SAMPLES} TRUE)\n    add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/azure_iot/azure-sdk-for-c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Common Tables Subdirectory\nDESCRIPTION: This code snippet conditionally adds the CommonTables subdirectory and links the CMSISDSPCommon library to the CMSISDSP interface library if either FILTERING, CONTROLLER, FASTMATH, TRANSFORM, SVM, or DISTANCE flag is set. It configures ARM_FFT_ALLOW_TABLES or ARM_FAST_ALLOW_TABLES based on the flags and CONFIGTABLE.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_35\n\nLANGUAGE: cmake\nCODE:\n```\nif (FILTERING OR CONTROLLER OR FASTMATH OR TRANSFORM OR SVM OR DISTANCE)\n  add_subdirectory(CommonTables)\n  if (TRANSFORM)\n    # FFT tables inclusion is allowed\n    if (CONFIGTABLE)\n      target_compile_definitions(CMSISDSPCommon PUBLIC ARM_FFT_ALLOW_TABLES)\n    endif()\n  endif()\n  if (FILTERING OR CONTROLLER OR FASTMATH)\n    # Select which tables to include\n    if (CONFIGTABLE)\n      target_compile_definitions(CMSISDSPCommon PUBLIC ARM_FAST_ALLOW_TABLES)\n    endif()\n  endif()\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPCommon)\n  # Common project is adding ComputeLibrary tables used by SVM and Distance\n  # when NEon is ON.\nendif()\n```\n\n----------------------------------------\n\nTITLE: Define Source Sets for USB DFU Class Tests\nDESCRIPTION: This snippet defines a variable `ux_class_dfu_test_cases` that contains a list of C source files for USB Device Firmware Upgrade (DFU) class tests. These files are located in the specified `SOURCE_DIR`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../regression\n                       ABSOLUTE)\n\nset(ux_class_dfu_test_cases\n    ${SOURCE_DIR}/usbx_device_dfu_basic_test.c\n    ${SOURCE_DIR}/usbx_uxe_device_dfu_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: Adding executable target\nDESCRIPTION: Adds an executable target named arm_matrix_example. This is the main application that will be built.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(arm_matrix_example)\n```\n\n----------------------------------------\n\nTITLE: RSA QP Definition\nDESCRIPTION: Defines QP as a hexadecimal string, representing Q^-1 mod P (the modular inverse of Q modulo P). This parameter is used in CRT (Chinese Remainder Theorem) based RSA implementations for faster decryption.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/rsa_priv.txt#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nQP = 97AC5BB885ABCA314375E9E4DB1BA4B2218C90619F61BD474F5785075ECA81750A735199A8C191FE2D3355E7CF601A70E5CABDE0E02C2538BB9FB4871540B3C1\n```\n\n----------------------------------------\n\nTITLE: Creating executable using pyinstaller\nDESCRIPTION: This example demonstrates how to create an executable file from a python script using pyinstaller. This will package the script and its dependencies into a standalone executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_35\n\nLANGUAGE: text\nCODE:\n```\npyinstaller AppliCfg.py --onedir --name AppliCfg\n```\n\n----------------------------------------\n\nTITLE: Add ThreadX SMP Sources CMake\nDESCRIPTION: Adds a list of source files related to ThreadX SMP to the target `PROJECT_NAME` as private sources. These files are located in the `${CURRENT_DIR}/src/` directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/common_smp/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CURRENT_DIR}/src/tx_block_allocate.c\n\t${CURRENT_DIR}/src/tx_block_allocate.c\n\t${CURRENT_DIR}/src/tx_block_pool_cleanup.c\n\t${CURRENT_DIR}/src/tx_block_pool_create.c\n\t${CURRENT_DIR}/src/tx_block_pool_delete.c\n\t${CURRENT_DIR}/src/tx_block_pool_info_get.c\n\t${CURRENT_DIR}/src/tx_block_pool_initialize.c\n\t${CURRENT_DIR}/src/tx_block_pool_performance_info_get.c\n\t${CURRENT_DIR}/src/tx_block_pool_performance_system_info_get.c\n\t${CURRENT_DIR}/src/tx_block_pool_prioritize.c\n\t${CURRENT_DIR}/src/tx_block_release.c\n\t${CURRENT_DIR}/src/tx_byte_allocate.c\n\t${CURRENT_DIR}/src/tx_byte_pool_cleanup.c\n\t${CURRENT_DIR}/src/tx_byte_pool_create.c\n\t${CURRENT_DIR}/src/tx_byte_pool_delete.c\n\t${CURRENT_DIR}/src/tx_byte_pool_info_get.c\n\t${CURRENT_DIR}/src/tx_byte_pool_initialize.c\n\t${CURRENT_DIR}/src/tx_byte_pool_performance_info_get.c\n\t${CURRENT_DIR}/src/tx_byte_pool_performance_system_info_get.c\n\t${CURRENT_DIR}/src/tx_byte_pool_prioritize.c\n\t${CURRENT_DIR}/src/tx_byte_pool_search.c\n\t${CURRENT_DIR}/src/tx_byte_release.c\n\t${CURRENT_DIR}/src/txe_block_allocate.c\n\t${CURRENT_DIR}/src/txe_block_pool_create.c\n\t${CURRENT_DIR}/src/txe_block_pool_delete.c\n\t${CURRENT_DIR}/src/txe_block_pool_info_get.c\n\t${CURRENT_DIR}/src/txe_block_pool_prioritize.c\n\t${CURRENT_DIR}/src/txe_block_release.c\n\t${CURRENT_DIR}/src/txe_byte_allocate.c\n\t${CURRENT_DIR}/src/txe_byte_pool_create.c\n\t${CURRENT_DIR}/src/txe_byte_pool_delete.c\n\t${CURRENT_DIR}/src/txe_byte_pool_info_get.c\n\t${CURRENT_DIR}/src/txe_byte_pool_prioritize.c\n\t${CURRENT_DIR}/src/txe_byte_release.c\n\t${CURRENT_DIR}/src/txe_event_flags_create.c\n\t${CURRENT_DIR}/src/txe_event_flags_delete.c\n\t${CURRENT_DIR}/src/txe_event_flags_get.c\n\t${CURRENT_DIR}/src/txe_event_flags_info_get.c\n\t${CURRENT_DIR}/src/txe_event_flags_set.c\n\t${CURRENT_DIR}/src/txe_event_flags_set_notify.c\n\t${CURRENT_DIR}/src/txe_mutex_create.c\n\t${CURRENT_DIR}/src/txe_mutex_delete.c\n\t${CURRENT_DIR}/src/txe_mutex_get.c\n\t${CURRENT_DIR}/src/txe_mutex_info_get.c\n\t${CURRENT_DIR}/src/txe_mutex_prioritize.c\n\t${CURRENT_DIR}/src/txe_mutex_put.c\n\t${CURRENT_DIR}/src/txe_queue_create.c\n\t${CURRENT_DIR}/src/txe_queue_delete.c\n\t${CURRENT_DIR}/src/txe_queue_flush.c\n\t${CURRENT_DIR}/src/txe_queue_front_send.c\n\t${CURRENT_DIR}/src/txe_queue_info_get.c\n\t${CURRENT_DIR}/src/txe_queue_prioritize.c\n\t${CURRENT_DIR}/src/txe_queue_receive.c\n\t${CURRENT_DIR}/src/txe_queue_send.c\n\t${CURRENT_DIR}/src/txe_queue_send_notify.c\n\t${CURRENT_DIR}/src/txe_semaphore_ceiling_put.c\n\t${CURRENT_DIR}/src/txe_semaphore_create.c\n\t${CURRENT_DIR}/src/txe_semaphore_delete.c\n\t${CURRENT_DIR}/src/txe_semaphore_get.c\n\t${CURRENT_DIR}/src/txe_semaphore_info_get.c\n\t${CURRENT_DIR}/src/txe_semaphore_prioritize.c\n\t${CURRENT_DIR}/src/txe_semaphore_put.c\n\t${CURRENT_DIR}/src/txe_semaphore_put_notify.c\n\t${CURRENT_DIR}/src/txe_thread_create.c\n\t${CURRENT_DIR}/src/txe_thread_delete.c\n\t${CURRENT_DIR}/src/txe_thread_entry_exit_notify.c\n\t${CURRENT_DIR}/src/txe_thread_info_get.c\n\t${CURRENT_DIR}/src/txe_thread_preemption_change.c\n\t${CURRENT_DIR}/src/txe_thread_priority_change.c\n\t${CURRENT_DIR}/src/txe_thread_relinquish.c\n\t${CURRENT_DIR}/src/txe_thread_reset.c\n\t${CURRENT_DIR}/src/txe_thread_resume.c\n\t${CURRENT_DIR}/src/txe_thread_suspend.c\n\t${CURRENT_DIR}/src/txe_thread_terminate.c\n\t${CURRENT_DIR}/src/txe_thread_time_slice_change.c\n\t${CURRENT_DIR}/src/txe_thread_wait_abort.c\n\t${CURRENT_DIR}/src/txe_timer_activate.c\n\t${CURRENT_DIR}/src/txe_timer_change.c\n\t${CURRENT_DIR}/src/txe_timer_create.c\n\t${CURRENT_DIR}/src/txe_timer_deactivate.c\n\t${CURRENT_DIR}/src/txe_timer_delete.c\n\t${CURRENT_DIR}/src/txe_timer_info_get.c\n\t${CURRENT_DIR}/src/tx_event_flags_cleanup.c\n\t${CURRENT_DIR}/src/tx_event_flags_create.c\n\t${CURRENT_DIR}/src/tx_event_flags_delete.c\n\t${CURRENT_DIR}/src/tx_event_flags_get.c\n\t${CURRENT_DIR}/src/tx_event_flags_info_get.c\n\t${CURRENT_DIR}/src/tx_event_flags_initialize.c\n\t${CURRENT_DIR}/src/tx_event_flags_performance_info_get.c\n\t${CURRENT_DIR}/src/tx_event_flags_performance_system_info_get.c\n\t${CURRENT_DIR}/src/tx_event_flags_set.c\n\t${CURRENT_DIR}/src/tx_event_flags_set_notify.c\n\t${CURRENT_DIR}/src/tx_initialize_high_level.c\n\t${CURRENT_DIR}/src/tx_initialize_kernel_enter.c\n\t${CURRENT_DIR}/src/tx_initialize_kernel_setup.c\n\t${CURRENT_DIR}/src/tx_misra.c\n\t${CURRENT_DIR}/src/tx_mutex_cleanup.c\n\t${CURRENT_DIR}/src/tx_mutex_create.c\n\t${CURRENT_DIR}/src/tx_mutex_delete.c\n\t${CURRENT_DIR}/src/tx_mutex_get.c\n\t${CURRENT_DIR}/src/tx_mutex_info_get.c\n\t${CURRENT_DIR}/src/tx_mutex_initialize.c\n\t${CURRENT_DIR}/src/tx_mutex_performance_info_get.c\n\t${CURRENT_DIR}/src/tx_mutex_performance_system_info_get.c\n\t${CURRENT_DIR}/src/tx_mutex_prioritize.c\n\t${CURRENT_DIR}/src/tx_mutex_priority_change.c\n\t${CURRENT_DIR}/src/tx_mutex_put.c\n\t${CURRENT_DIR}/src/tx_queue_cleanup.c\n\t${CURRENT_DIR}/src/tx_queue_create.c\n\t${CURRENT_DIR}/src/tx_queue_delete.c\n\t${CURRENT_DIR}/src/tx_queue_flush.c\n\t${CURRENT_DIR}/src/tx_queue_front_send.c\n\t${CURRENT_DIR}/src/tx_queue_info_get.c\n\t${CURRENT_DIR}/src/tx_queue_initialize.c\n\t${CURRENT_DIR}/src/tx_queue_performance_info_get.c\n\t${CURRENT_DIR}/src/tx_queue_performance_system_info_get.c\n\t${CURRENT_DIR}/src/tx_queue_prioritize.c\n\t${CURRENT_DIR}/src/tx_queue_receive.c\n\t${CURRENT_DIR}/src/tx_queue_send.c\n\t${CURRENT_DIR}/src/tx_queue_send_notify.c\n\t${CURRENT_DIR}/src/tx_semaphore_ceiling_put.c\n\t${CURRENT_DIR}/src/tx_semaphore_cleanup.c\n\t${CURRENT_DIR}/src/tx_semaphore_create.c\n\t${CURRENT_DIR}/src/tx_semaphore_delete.c\n\t${CURRENT_DIR}/src/tx_semaphore_get.c\n\t${CURRENT_DIR}/src/tx_semaphore_info_get.c\n\t${CURRENT_DIR}/src/tx_semaphore_initialize.c\n\t${CURRENT_DIR}/src/tx_semaphore_performance_info_get.c\n\t${CURRENT_DIR}/src/tx_semaphore_performance_system_info_get.c\n\t${CURRENT_DIR}/src/tx_semaphore_prioritize.c\n\t${CURRENT_DIR}/src/tx_semaphore_put.c\n\t${CURRENT_DIR}/src/tx_semaphore_put_notify.c\n\t${CURRENT_DIR}/src/tx_thread_create.c\n\t${CURRENT_DIR}/src/tx_thread_entry_exit_notify.c\n\t${CURRENT_DIR}/src/tx_thread_identify.c\n\t${CURRENT_DIR}/src/tx_thread_info_get.c\n\t${CURRENT_DIR}/src/tx_thread_initialize.c\n\t${CURRENT_DIR}/src/tx_thread_performance_info_get.c\n\t${CURRENT_DIR}/src/tx_thread_performance_system_info_get.c\n\t${CURRENT_DIR}/src/tx_thread_preemption_change.c\n\t${CURRENT_DIR}/src/tx_thread_priority_change.c\n\t${CURRENT_DIR}/src/tx_thread_relinquish.c\n\t${CURRENT_DIR}/src/tx_thread_resume.c\n\t${CURRENT_DIR}/src/tx_thread_shell_entry.c\n\t${CURRENT_DIR}/src/tx_thread_sleep.c\n\t${CURRENT_DIR}/src/tx_thread_smp_utilities.c\n\t${CURRENT_DIR}/src/tx_thread_stack_analyze.c\n\t${CURRENT_DIR}/src/tx_thread_stack_error_handler.c\n\t${CURRENT_DIR}/src/tx_thread_stack_error_notify.c\n\t${CURRENT_DIR}/src/tx_thread_suspend.c\n\t${CURRENT_DIR}/src/tx_thread_system_preempt_check.c\n\t${CURRENT_DIR}/src/tx_thread_system_resume.c\n\t${CURRENT_DIR}/src/tx_thread_system_suspend.c\n\t${CURRENT_DIR}/src/tx_thread_terminate.c\n\t${CURRENT_DIR}/src/tx_thread_timeout.c\n\t${CURRENT_DIR}/src/tx_thread_time_slice.c\n\t${CURRENT_DIR}/src/tx_thread_time_slice_change.c\n\t${CURRENT_DIR}/src/tx_thread_wait_abort.c\n\t${CURRENT_DIR}/src/tx_time_get.c\n\t${CURRENT_DIR}/src/tx_timer_activate.c\n\t${CURRENT_DIR}/src/tx_timer_change.c\n\t${CURRENT_DIR}/src/tx_timer_create.c\n\t${CURRENT_DIR}/src/tx_timer_deactivate.c\n\t${CURRENT_DIR}/src/tx_timer_delete.c\n\t${CURRENT_DIR}/src/tx_timer_expiration_process.c\n\t${CURRENT_DIR}/src/tx_timer_info_get.c\n\t${CURRENT_DIR}/src/tx_timer_initialize.c\n\t${CURRENT_DIR}/src/tx_timer_performance_info_get.c\n\t${CURRENT_DIR}/src/tx_timer_performance_system_info_get.c\n\t${CURRENT_DIR}/src/tx_timer_system_activate.c\n\t${CURRENT_DIR}/src/tx_timer_system_deactivate.c\n\t${CURRENT_DIR}/src/tx_timer_thread_entry.c\n\t${CURRENT_DIR}/src/tx_time_set.c\n\t${CURRENT_DIR}/src/tx_trace_buffer_full_notify.c\n\t${CURRENT_DIR}/src/tx_trace_disable.c\n\t${CURRENT_DIR}/src/tx_trace_enable.c\n\t${CURRENT_DIR}/src/tx_trace_event_filter.c\n\t${CURRENT_DIR}/src/tx_trace_event_unfilter.c\n\t${CURRENT_DIR}/src/tx_trace_initialize.c\n\t${CURRENT_DIR}/src/tx_trace_interrupt_control.c\n\t${CURRENT_DIR}/src/tx_trace_isr_enter_insert.c\n\t${CURRENT_DIR}/src/tx_trace_isr_exit_insert.c\n\t${CURRENT_DIR}/src/tx_trace_object_register.c\n\t${CURRENT_DIR}/src/tx_trace_object_unregister.c\n\t${CURRENT_DIR}/src/tx_trace_user_event_insert.c\n\t${CURRENT_DIR}/src/tx_thread_smp_core_exclude.c\n\t${CURRENT_DIR}/src/tx_thread_smp_core_exclude_get.c\n\t${CURRENT_DIR}/src/tx_thread_smp_current_state_set.c\n\t${CURRENT_DIR}/src/tx_thread_smp_debug_entry_insert.c\n\t${CURRENT_DIR}/src/tx_thread_smp_high_level_initialize.c\n\t${CURRENT_DIR}/src/tx_thread_smp_rebalance_execute_list.c\n\t${CURRENT_DIR}/src/tx_timer_smp_core_exclude.c\n\t${CURRENT_DIR}/src/tx_timer_smp_core_exclude_get.c\n\n    # {{END_TARGET_SOURCES}})\n\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration\nDESCRIPTION: This snippet shows the necessary configuration to add to the MDK-ARM linker file (.sct) or to modify the 'tx_low_level_initilize.s' file to define the memory region for ThreadX. This allows ThreadX to manage memory dynamically.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Applications/ThreadX/Tx_LowPower/README.md#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.s to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories with CMake\nDESCRIPTION: This CMake snippet sets the include directories for the project.  It ensures that the compiler can find the necessary header files during compilation. The `target_include_directories` command adds the specified directories to the include search path for the given target (`${PROJECT_NAME}`).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m33/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Key Lifetime for Opaque Driver with PSA in C\nDESCRIPTION: This demonstrates setting the key lifetime to use an opaque driver, using the compile-time constant `PSA_KEY_LIFETIME_foo`. This indicates that the key operations will be handled by the opaque driver associated with the `foo` location.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_52\n\nLANGUAGE: C\nCODE:\n```\npsa_set_key_lifetime(&attributes, PSA_KEY_LIFETIME_foo);\n```\n\n----------------------------------------\n\nTITLE: Initialize CMake Project for CMSISDSPStatistics\nDESCRIPTION: This snippet initializes the CMake project and includes configuration files.  It sets the minimum required CMake version, names the project `CMSISDSPStatistics`, and includes `configLib` and `configDsp` for further configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/StatisticsFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n\nproject(CMSISDSPStatistics)\n\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: Define Executables CMake\nDESCRIPTION: Defines a list of executable names that will be built by CMake. This list is later iterated over to configure each executable target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/hash/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(executables\n  generic_sum\n  hello\n  md_hmac_demo\n)\n```\n\n----------------------------------------\n\nTITLE: Platform Determination\nDESCRIPTION: Determines the target platform based on the `AZ_PLATFORM_IMPL` variable. If it's `WIN32`, `POSIX`, or `CUSTOM`, it sets the `PAL` variable to the corresponding platform implementation. If `CUSTOM` is specified, `AZ_CUSTOM_PLATFORM_IMPL_NAME` must also be defined. If no platform is specified, it defaults to `az_noplatform`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nif(AZ_PLATFORM_IMPL STREQUAL \"WIN32\")\n  set(PAL az_win32)\nelif(AZ_PLATFORM_IMPL STREQUAL \"POSIX\")\n  set(PAL az_posix)\nelif(AZ_PLATFORM_IMPL STREQUAL \"CUSTOM\")\n  if(NOT DEFINED AZ_CUSTOM_PLATFORM_IMPL_NAME)\n    message(FATAL_ERROR \"When using AZ_PLATFORM_IMPL=CUSTOM, AZ_CUSTOM_PLATFORM_IMPL_NAME must be defined as well. See Readme.\")\n  endif()\n  set(PAL ${AZ_CUSTOM_PLATFORM_IMPL_NAME})\nelse()\n  #noplatform\n  set(PAL az_noplatform)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Main Test Execution (Pseudo Code)\nDESCRIPTION: This pseudo-code outlines the main steps involved in the MCUboot FIH testing process. It showcases the functions called, parameters passed, and their respective implementations located in different shell and python scripts.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_19\n\nLANGUAGE: Shell Script\nCODE:\n```\nfn main()\n  # Implemented in ci/fih-tests_install.sh\n  generate_docker_image(Dockerfile)\n\n  # See details below. Implemented in ci/fih-tests_run.sh.\n  # Calling the function with different parameters is done by Travis CI based on\n  # the values provided in the .travis.yaml\n  start_docker_image(skip_sizes, build_type, damage_type, fih_level)\n\nfn start_docker_image(skip_sizes, build_type, damage_type, fih_level)\n  # implemented in ci/fih_test_docker/execute_test.sh\n  compile_mcuboot(build_type)\n\n  # implemented in ci/fih_test_docker/damage_image.py\n  damage_image(damage_type)\n\n  # implemented in ci/fih_test_docker/run_fi_test.sh\n  ranges = generate_address_ranges()\n  for s in skip_sizes\n    for r in ranges\n      do_skip_in_qemu(s, r) # See details below\n  evaluate_logs()\n\nfn do_skip_in_qemu(size, range)\n  for a in r\n    run_qemu(a, size)  # See details below\n\n# this part is implemented in ci/fih_test_docker/fi_tester_gdb.sh\nfn run_qemu(a, size)\n  script = create_debugger_script(a, size)\n  start_qemu_in_bacground() # logs serial out to a file\n  gdb_attach_to_qemu(script)\n  kill_qemu()\n\n  # This checks the debugger and the quemu logs, and decides whether the tets\n  # was executed successfully, and whether the image is booted or not. Then\n  # emits a yaml fragment on the standard out to be processed by the caller\n  # script\n  evaluate_run(qemu_log_file)\n```\n\n----------------------------------------\n\nTITLE: Defining USBX Excludes\nDESCRIPTION: These CMake commands define variables that store lists of files or modules to be excluded from the USBX build, specifically for standalone configurations.  These variables are later used to filter source lists based on the specified build type.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nset(UX_STANDALONE_HOST_EXCLUDES\n  # ux_host_class_asix\n  # ux_host_class_audio\n  # ux_host_class_cdc_acm\n  # ux_host_class_cdc_ecm\n  # ux_host_class_gser\n  # ux_host_class_hid\n  # ux_host_class_hub\n  # ux_host_class_pima\n  # ux_host_class_printer\n  # ux_host_class_prolific\n  # ux_host_class_storage\n  # ux_host_class_swar\n  # ux_host_class_video\n  # ux_hcd_ehci\n  # ux_hcd_ohci\n)\nset(UX_STANDALONE_DEVICE_EXCLUDES\n  # ux_device_class_audio\n  # ux_device_class_cdc_acm\n  # ux_device_class_cdc_ecm\n  # ux_device_class_dfu\n  # ux_device_class_hid\n  # ux_device_class_pima\n  # ux_device_class_rndis\n  # ux_device_class_ccid\n  # ux_device_class_printer\n  # ux_device_class_video\n)\nset(UX_STANDALONE_UTILITY_EXCLUDES\n  # ux_utility_event\n  # ux_utility_delay\n  # ux_utility_mutex\n  # ux_utility_semaphore\n  # ux_utility_thread\n  # ux_utility_timer\n)\nset(UX_STANDALONE_PICTBRIDGE_EXCLUDES\n  # ux_pictbridge\n)\nset(UX_STANDALONE_NX_EXCLUDES\n  # ux_network_driver\n)\nset(UX_STANDALONE_FX_EXCLUDES\n  # ux_host_class_storage_driver_entry\n  usbx_ux_host_class_storage_fx_driver\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project\nDESCRIPTION: This snippet sets the minimum required CMake version and defines the project name and version. It's the starting point for configuring the CMake project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_svm_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_svm_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: ThreadX Managed Interrupt Handler Template in Assembly\nDESCRIPTION: This assembly code provides a template for a ThreadX managed interrupt service routine (ISR). It demonstrates the necessary steps for preserving the context and calling a C-based interrupt handler. The label `__tx_IntHandler` should be inserted into the interrupt vector table. Ensure the .thumb_func directive is used to instruct the linker to create thumb labels.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/ac6/readme_threadx.txt#_snippet_0\n\nLANGUAGE: Assembly\nCODE:\n```\n        .global  __tx_IntHandler\n        .thumb_func\n__tx_IntHandler:\n; VOID InterruptHandler (VOID)\n; {\n        PUSH    {r0, lr}\n\n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n        POP     {r0, lr}\n        BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Pass data from pre-script to test-resources.json\nDESCRIPTION: Example PowerShell snippet from `test-resources-pre.ps1` that creates a certificate and adds the data to the `$templateFileParameters` variable. These parameters will be passed to `test-resources.json`\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/README.md#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\n$cert = New-X509Certificate2 -SubjectName 'E=opensource@microsoft.com, CN=Azure SDK, OU=Azure SDK, O=Microsoft, L=Frisco, S=TX, C=US' -ValidDays 3652\n# Create new entries in $templateFileParameters\n$templateFileParameters['ConfidentialLedgerPrincipalPEM'] = Format-X509Certificate2 -Certificate $cert\n$templateFileParameters['ConfidentialLedgerPrincipalPEMPK'] = Format-X509Certificate2 -Type Pkcs8 -Certificate $cert\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies for ROT_AppliConfig\nDESCRIPTION: This snippet shows how to install the required Python modules using pip, which is necessary when switching to the Python version of the ROT_AppliConfig tool. It installs the dependencies listed in the requirements.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Templates_ROT/OEMiROT_Appli/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Setting the Logging Classification Filter Callback in C\nDESCRIPTION: This code shows how to set the logging classification filter callback function using `az_log_set_classification_filter_callback`. The provided function filters the log messages based on their classification.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nvoid az_log_set_classification_filter_callback(az_log_classification_filter_fn message_filter_callback);\n```\n\n----------------------------------------\n\nTITLE: Setting FTP Test Cases\nDESCRIPTION: This snippet defines a list of C source files comprising the FTP regression test suite. These tests cover FTP client and server functionalities, including data transfer, command processing, security aspects, and error handling.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nset(ftp_test_cases\n    ${SOURCE_DIR}/ftp_test/netx_ftp_access_control_commands_02_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_access_control_commands_03_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_client_invalid_username_password_length_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_client_pasv_file_write_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_data_connection_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_service_commands_nlist_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_user_data_type_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_basic_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_establish_data_connection_05_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_commands_replys_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_service_commands_RETR_STOR_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_service_commands_rename_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_establish_data_connection_08_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_access_control_commands_04_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_client_pasv_denied.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_commands_characters_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_client_pasv_file_read_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_client_buffer_overflow_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_client_file_write_fail_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_establish_data_connection_06_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_service_commands_file_write_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_establish_data_connection_03_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_access_control_commands_01_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_control_connection_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_server_invalid_month_crash_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_rst_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_two_listen_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_client_multiple_connection_responses_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_client_packet_leak_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_parse_ipv6_address_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_server_abnormal_packet_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_server_list_command_test.c)\n```\n\n----------------------------------------\n\nTITLE: Build ThreadX Modules Examples (PowerShell)\nDESCRIPTION: This command executes the azrtos_cicd.ps1 script with the -MatchName 'Modules' and -build parameters. It builds all examples whose name matches 'Modules' in the default database. The pwsh -Command prefix ensures execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_5\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchName 'Modules' -build\n```\n\n----------------------------------------\n\nTITLE: RSA Private Exponent (D) Definition\nDESCRIPTION: Defines the RSA private exponent (D) as a hexadecimal string. The private exponent is a crucial component of the private key, used for decryption and signature generation. It must be kept secret.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/rsa_priv.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nD = 589552BB4F2F023ADDDD5586D0C8FD857512D82080436678D07F984A29D892D31F1F7000FC5A39A0F73E27D885E47249A4148C8A5653EF69F91F8F736BA9F84841C2D99CD8C24DE8B72B5C9BE0EDBE23F93D731749FEA9CFB4A48DD2B7F35A2703E74AA2D4DB7DE9CEEA7D763AF0ADA7AC176C4E9A22C4CDA65CEC0C65964401\n```\n\n----------------------------------------\n\nTITLE: Configuration Parameters for ARM Cortex-M3\nDESCRIPTION: These parameters configure various aspects of the ARM Cortex-M3 CT within the STM32CubeH5 project. They control features such as semihosting, CPI (Cycles Per Instruction) calculation, and minimum synchronization levels.  The parameters are defined using a key-value syntax with associated type, mode (init-time or run-time), default value, description, and range.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_convolution_example/ARMCM3_config.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.semihosting-enable=0                    # (bool  , init-time) default = '1'      : Enable semihosting SVC traps. Applications that do not use semihosting must set this parameter to false.\narmcortexm3ct.cpi_div=1                               # (int   , run-time ) default = '0x1'    : divider for calculating CPI (Cycles Per Instruction)\narmcortexm3ct.cpi_mul=1                               # (int   , run-time ) default = '0x1'    : multiplier for calculating CPI (Cycles Per Instruction)\narmcortexm3ct.min_sync_level=3                        # (int   , run-time ) default = '0x0'    : force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)\n```\n\n----------------------------------------\n\nTITLE: Setting Key Bits Attribute PSA\nDESCRIPTION: This code snippet explains how to set the key size in bits using the `psa_set_key_bits` function. This is optional with `psa_import_key`, which determines the key size from the length of the key material.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\npsa_set_key_bits\n```\n\n----------------------------------------\n\nTITLE: Disabling Master Board (Enabling Slave) in C\nDESCRIPTION: Commenting out the #define MASTER_BOARD directive in the main.c file configures the board to operate in slave mode. When commented, the code compiles with slave-specific configurations, enabling it to respond to requests from a master device and perform operations such as receiving data or transmitting data.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples/I2C/I2C_TwoBoards_AdvComIT/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n// #define MASTER_BOARD\n```\n\n----------------------------------------\n\nTITLE: Setting SNTP Test Cases (NetXDuo)\nDESCRIPTION: Defines a set of SNTP (Simple Network Time Protocol) test cases for NetXDuo. These tests cover unicast and broadcast updates, IPv6 support, date display, time conversion, KoD (Kiss-of-Death) handling, and packet chaining.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_26\n\nLANGUAGE: CMake\nCODE:\n```\nset(sntp_test_cases\n    ${SOURCE_DIR}/sntp_test/netx_sntp_forward_unicast_update_test.c\n    ${SOURCE_DIR}/sntp_test/netx_sntp_request_unicast_test.c\n    ${SOURCE_DIR}/sntp_test/netx_sntp_client_unicast_basic_test.c\n    ${SOURCE_DIR}/sntp_test/netx_sntp_client_ipv6_broadcast_basic_test.c\n    ${SOURCE_DIR}/sntp_test/netx_sntp_client_ipv6_unicast_basic_test.c\n    ${SOURCE_DIR}/sntp_test/netx_sntp_client_broadcast_basic_test.c\n    ${SOURCE_DIR}/sntp_test/netx_sntp_client_unicast_display_date_test.c\n    ${SOURCE_DIR}/sntp_test/netx_sntp_client_seconds_to_date_test.c\n    ${SOURCE_DIR}/sntp_test/netx_sntp_client_kod_test.c\n    ${SOURCE_DIR}/sntp_test/netx_sntp_client_packet_chain_test.c)\n```\n\n----------------------------------------\n\nTITLE: Setting CMake minimum version and project details\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.14 and defines the project name as 'arm_signal_convergence_example' with a version of 0.1.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_signal_convergence_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Memory Region Definition\nDESCRIPTION: This snippet shows how to define the `RW_IRAM1` region in the MDK-ARM `.sct` scatter file or modify the `tx_initialize_low_level.S` file to match the memory region being used. This configures the memory region for ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/NetXDuo/Nx_Iperf/README.md#_snippet_2\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Configure Executables with mbedtls and Thread Libraries (CMake)\nDESCRIPTION: This snippet iterates through the list of executables defined earlier. For each executable, it adds an executable target, links it with the `mbedcrypto_target` and thread libraries (`CMAKE_THREAD_LIBS_INIT`), and sets the include directory for the tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/random/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(exe IN LISTS executables)\n    add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>)\n    target_link_libraries(${exe} ${mbedcrypto_target} ${CMAKE_THREAD_LIBS_INIT})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Initializing Ethernet MAC Address in STM32 HAL\nDESCRIPTION: This code snippet initializes the Ethernet MAC address within the `MX_ETH_Init` function. It sets the MAC address octets for the Ethernet peripheral, which is crucial for network communication. The `heth` handle is assumed to be a global or file-scope variable representing the Ethernet handle. It relies on the STM32 HAL library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/NetXDuo/Nx_Iperf/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid MX_ETH_Init(void)\n{\n\n  /* USER CODE BEGIN ETH_Init 0 */\n\n  /* USER CODE END ETH_Init 0 */\n\n  /* USER CODE BEGIN ETH_Init 1 */\n\n  /* USER CODE END ETH_Init 1 */\n  heth.Instance = ETH;\n  heth.Init.MACAddr[0] =   0x00;\n  heth.Init.MACAddr[1] =   0x80;\n  heth.Init.MACAddr[2] =   0xE1;\n  heth.Init.MACAddr[3] =   0x00;\n  heth.Init.MACAddr[4] =   0x00;\n  heth.Init.MACAddr[5] =   0x00;\n```\n\n----------------------------------------\n\nTITLE: Defining ThreadX Target Include Directories with CMake\nDESCRIPTION: This CMake code snippet defines the include directories for the ThreadX target. It uses the `target_include_directories` command to add the specified 'inc' directory to the project's include path, making the header files within that directory accessible during compilation. `${PROJECT_NAME}` represents the project name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/ac6/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    inc\n)\n```\n\n----------------------------------------\n\nTITLE: Test All Examples (PowerShell)\nDESCRIPTION: This command executes the azrtos_cicd.ps1 script with the -test parameter. It runs basic tests on all examples specified in the default database (azrtos_cicd.csv). The pwsh -Command prefix is used for execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -test\n```\n\n----------------------------------------\n\nTITLE: Defining ThreadX Include Directories with CMake\nDESCRIPTION: This CMake snippet specifies the include directories required for compiling the ThreadX library. It uses the `target_include_directories` command to add the `inc` directory to the project's PUBLIC scope, ensuring that header files within this directory are accessible during compilation. The `${PROJECT_NAME}` variable refers to the name of the CMake project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    inc\n)\n```\n\n----------------------------------------\n\nTITLE: IAR Thread-safe Library Initialization\nDESCRIPTION: This snippet shows the linker control file entry required to enable thread-safe support for the IAR library when using ThreadX. This line ensures that the __DLIB_PERTHREAD section is properly initialized for multi-threaded applications.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m23/iar/readme_threadx.txt#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\ninitialize by copy with packing = none { section __DLIB_PERTHREAD }; // Required in a multi-threaded application\n```\n\n----------------------------------------\n\nTITLE: Enable Testing\nDESCRIPTION: This snippet enables testing for the project, allowing the use of CMake's testing framework. This command is necessary to run tests defined within the project using tools like CTest.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nenable_testing()\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This code snippet defines a new section named `._threadx_heap` in the STM32CubeIDE linker script. This section allocates 64KB of memory for the ThreadX heap.  The `tx_initialize_low_level.S` file should be also modified to enable the `USE_DYNAMIC_MEMORY_ALLOCATION` compilation flag.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_Network_Basics_wifi/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n        {\n         . = ALIGN(8);\n         __RAM_segment_used_end__ = .;\n         . = . + 64K;\n         . = ALIGN(8);\n        } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Cortex-M ISR in Assembly with ThreadX\nDESCRIPTION: This code snippet demonstrates the structure of an Interrupt Service Routine (ISR) written in assembly language that is compatible with ThreadX on Cortex-M. The ISR can access ThreadX API functions available for ISRs. 'your_assembly_isr' should be an entry in the vector table. It pushes r0 and lr onto the stack at the beginning, and pops them back before returning using BX lr.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/ac5/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n    EXPORT  your_assembly_isr\nyour_assembly_isr\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Configure Include Directories CMake\nDESCRIPTION: This CMake snippet configures the include directories for the project. The `target_include_directories` command specifies the project name and the `PUBLIC` keyword indicates that these include directories are available to other projects that depend on this one. It adds the `inc` directory to the include path, allowing the compiler to find header files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/ports/cortex_m7/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Ending Reported Properties Status with Confirmation Status (C)\nDESCRIPTION: This routine ends a property response payload, completing the confirmation status reporting process.  It finalizes the JSON structure for the property status report.  Dependencies include NX_AZURE_IOT_HUB_CLIENT and NX_AZURE_IOT_JSON_WRITER. This function should be preceded by `nx_azure_iot_hub_client_reported_properties_status_begin()` and have had the user value appended.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client_properties.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_hub_client_reported_properties_status_end(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                          NX_AZURE_IOT_JSON_WRITER *writer_ptr);\n```\n\nLANGUAGE: c\nCODE:\n```\nnx_azure_iot_hub_client_reported_properties_status_begin()\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This snippet configures the target sources for the STM32CubeH5 project. It uses the `target_sources` command to specify private source files associated with the project. The source files are inserted between the `BEGIN_TARGET_SOURCES` and `END_TARGET_SOURCES` markers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/ports/cortex_m3/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Linking Application with Driver Implementation (Makefile)\nDESCRIPTION: This command links the application with the driver implementation libraries. It specifies the paths to the driver libraries using the `-L` flag and the libraries themselves using the `-l` flag. It also links with the mbedcrypto library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-integration-guide.md#_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\ncd /path/to/application\nld myapp.o -L/path/to/acme -lacmedriver -L/path/to/nadir -lnadirdriver -L/path/to/mbedtls -lmbedcrypto\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration\nDESCRIPTION: This snippet provides two options for configuring the linker in MDK-ARM for ThreadX dynamic memory allocation: either define the RW_IRAM1 region in the .sct file or modify the line in \"tx_low_level_initilize.S\" to match the memory region being used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Applications/ThreadX/Tx_Thread_Creation/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.S to match the memory region being used\n        LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Enabling Nested FIQ Interrupts - Assembly\nDESCRIPTION: This code demonstrates enabling nested FIQ interrupts within a typical FIQ handler. It uses `_tx_thread_fiq_nesting_start` to enable FIQ nesting and `_tx_thread_fiq_nesting_end` to disable it. FIQ interrupt sources must be cleared before calling `_tx_thread_fiq_nesting_start` as it returns with FIQ interrupts enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac5/readme_threadx.txt#_snippet_5\n\nLANGUAGE: Assembly\nCODE:\n```\n    EXPORT  __tx_fiq_handler\n    EXPORT  __tx_fiq_processing_return\n__tx_fiq_handler\n;\n;    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return\n;\n;    /* At this point execution is still in the FIQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use.  */\n;\n;    /* Enable nested FIQ interrupts. NOTE:  Since this service returns\n;       with FIQ interrupts enabled, all FIQ interrupt sources must be \n;       cleared prior to calling this service.  */\n    BL      _tx_thread_fiq_nesting_start\n;\n;    /* Application FIQ handlers can be called here!  */\n;\n;    /* Disable nested FIQ interrupts. The mode is switched back to\n;       FIQ mode and FIQ interrupts are disable upon return.  */\n    BL      _tx_thread_fiq_nesting_end\n;\n;    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: C ISR Definition for ThreadX with IAR\nDESCRIPTION: This code snippet demonstrates the structure of an Interrupt Service Routine (ISR) written in C for use with ThreadX on Cortex-M processors using IAR tools.  It shows the basic function signature for an ISR that can access the ThreadX API.  The ISR processing logic should be placed within the function body.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/iar/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Set CMake Minimum Version\nDESCRIPTION: Specifies the minimum required CMake version for the project and sets CMake policies for compatibility and behavior. The `cmake_minimum_required` command enforces a minimum CMake version. `cmake_policy` commands configure specific CMake behaviors to ensure consistency.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\ncmake_policy(SET CMP0077 NEW)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup and Sample Compilation\nDESCRIPTION: This CMake code configures the build environment, specifies the project name and language (C), and defines the source files for the sample applications. It then iterates through the source files, creating an executable for each and linking it to the ThreadX library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/samples/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(samples LANGUAGES C)\n\nset(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../../ports/linux/gnu/example_build)\n\nset(sample_files\n    ${SOURCE_DIR}/sample_threadx.c)\n\nforeach(sample_file ${sample_files})\n  get_filename_component(sample_file_name ${sample_file} NAME_WE)\n  add_executable(${sample_file_name} ${sample_file} ${CMAKE_CURRENT_LIST_DIR}/fake.c)\n  target_link_libraries(${sample_file_name} PRIVATE azrtos::threadx)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Setting Host HID Test Cases Variable in CMake\nDESCRIPTION: This snippet defines a CMake variable, `ux_class_hid_host_standalone_test_cases`, and assigns it a list of source files related to HID host standalone tests. These source files are assumed to be C files for testing the USBX HID host class.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_hid_host_standalone_test_cases\n    ${SOURCE_DIR}/usbx_class_hid_basic_test.c\n    ${SOURCE_DIR}/usbx_class_hid_keyboard_basic_test.c\n    ${SOURCE_DIR}/usbx_class_hid_mouse_basic_test.c\n    ${SOURCE_DIR}/usbx_class_hid_remote_control_basic_test.c\n    ${SOURCE_DIR}/usbx_class_hid_basic_memory_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_report_set_int_out_test.c\n    ${SOURCE_DIR}/usbx_uxe_host_hid_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup and Sample Compilation\nDESCRIPTION: This CMake code configures the project, sets the minimum required CMake version, specifies the project language as C, defines the source directory for samples, and iterates through a list of sample files to create and link executables.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/samples/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(samples LANGUAGES C)\n\nset(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../../samples)\n\nset(sample_files\n    ${SOURCE_DIR}/demo_usbx.c)\n\nforeach(sample_file ${sample_files})\n  get_filename_component(sample_file_name ${sample_file} NAME_WE)\n  add_executable(${sample_file_name} ${sample_file} fake.c)\n  target_link_libraries(${sample_file_name} PRIVATE azrtos::usbx)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This snippet shows how to modify the EWARM linker configuration file (.icf) to allocate memory for ThreadX. It places the last section 'FREE_MEM' into the RAM region, allowing ThreadX to manage dynamic memory allocation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_CDC_ACM/README.md#_snippet_0\n\nLANGUAGE: EWARM Linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Assembler/Compiler Switches for ThreadX Demo\nDESCRIPTION: These compiler and assembler switches are used when building the ThreadX demonstration system for Cortex-A7. They control debugging information, object code generation, and target CPU selection.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n-g                      Specifies debug information\n-c                      Specifies object code generation\n-mcpu=cortex-a7         Specifies target cpu\n```\n\n----------------------------------------\n\nTITLE: Creating a Simulated Interrupt Thread\nDESCRIPTION: This code snippet demonstrates how to create a simulated interrupt thread in Linux using pthreads. It creates the thread, and sets its priority using pthread_setschedparam with a SCHED_FIFO scheduling policy.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/linux/gnu/readme_threadx.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nstruct sched_param sp;\n\n       /* Create the ISR thread */\n       pthread_create(&_sample_linux_interrupt_thread, NULL, _sample_linux_interrupt_entry, &_sample_linux_interrupt_thread);\n\n       /* Set up the ISR priority */\n       sp.sched_priority = TX_LINUX_PRIORITY_ISR;\n       pthread_setschedparam(_sample_linux_interrupt_thread, SCHED_FIFO, &sp);\n```\n\n----------------------------------------\n\nTITLE: Configure and Link Executables CMake\nDESCRIPTION: Iterates through the list of executables, adding each as an executable target, linking it to the mbedtls_test object library, mbedcrypto_target library, and thread libraries. Also, sets the include directory for the executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/hash/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(exe IN LISTS executables)\n  add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>)\n  target_link_libraries(${exe} ${mbedcrypto_target} ${CMAKE_THREAD_LIBS_INIT})\n  target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Setting Build Configurations\nDESCRIPTION: Defines a set of named build configurations (e.g., default, coverage, stack checking) and makes them available for selection.  It ensures a valid build type is always set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(BUILD_CONFIGURATIONS default_build_coverage\n                         disable_notify_callbacks_build stack_checking_build stack_checking_rand_fill_build\n                         trace_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: Adding CMake Module Path\nDESCRIPTION: Appends a path to the `CMAKE_MODULE_PATH` variable. This allows CMake to find custom modules located in the specified directory. The directory being added is `cmake-modules` within the current list directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_LIST_DIR}/cmake-modules\")\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories\nDESCRIPTION: This snippet adds an include directory to the CMSISDSPMatrix target. The directory is specified as ${DSP}/Include and is added as a PUBLIC include directory, making it available to other targets that depend on CMSISDSPMatrix.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/MatrixFunctions/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(CMSISDSPMatrix PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Clean Examples matching TX, IAR, SMP (PowerShell)\nDESCRIPTION: This command cleans all examples matching the keywords 'TX ', 'IAR', and 'SMP'.  These examples are likely ThreadX examples for SMP (Symmetric Multiprocessing) using the IAR compiler. The pwsh -Command prefix allows executing the command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_18\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','IAR','SMP' -clean\n```\n\n----------------------------------------\n\nTITLE: Setting up CMake Project\nDESCRIPTION: This snippet sets the minimum required CMake version and defines the project name and version.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_convolution_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_convolution_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: Link USBX dependencies\nDESCRIPTION: This snippet links the USBX library to other necessary libraries like ThreadX, FileX, and NetXDuo, ensuring that USBX can utilize the functionalities provided by these libraries during compilation and runtime. These are declared as public dependencies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# Define any required dependencies between this library and others\ntarget_link_libraries(${PROJECT_NAME} PUBLIC \n    \"azrtos::threadx\"\n    \"azrtos::filex\"\n    \"azrtos::netxduo\"\n)\n```\n\n----------------------------------------\n\nTITLE: Creating an az_span Literal from a String in C\nDESCRIPTION: Demonstrates creating an `az_span` literal from a string using `AZ_SPAN_LITERAL_FROM_STR`. This macro creates an `az_span` with the length of the string, excluding the null terminator.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\naz_span span_over_str = AZ_SPAN_LITERAL_FROM_STR(\"Hello\");  // size = 5\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories for ThreadX and FileX\nDESCRIPTION: This snippet defines the path to tx_user.h, calculates the absolute path to the 'externals' directory, and adds subdirectories for ThreadX and FileX to the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/libs/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(TX_USER_FILE ${CMAKE_CURRENT_SOURCE_DIR}/tx_user.h)\nget_filename_component(\n  externals ${CMAKE_CURRENT_SOURCE_DIR}/../.. ABSOLUTE)\nadd_subdirectory(${externals}/threadx threadx)\nadd_subdirectory(${externals}/filex filex)\n```\n\n----------------------------------------\n\nTITLE: Adding and Linking MbedTLS Executables (CMake)\nDESCRIPTION: Iterates through the `executables_mbedtls` list, adds each executable by specifying its source file, links the necessary libraries (mbedtls target and thread libraries), and includes the required directories.  It assumes that the source file name matches the executable name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(exe IN LISTS executables_mbedtls)\n    add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>)\n    target_link_libraries(${exe} ${mbedtls_target} ${CMAKE_THREAD_LIBS_INIT})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Define PPPoE Test Cases\nDESCRIPTION: This snippet defines a CMake variable, `pppoe_test_cases`, containing a list of C source files that test the NetX PPPoE (PPP over Ethernet) functionality. The test cases cover basic PPPoE operation, API usage, AC name handling, and session control.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\nset(pppoe_test_cases\n    ${SOURCE_DIR}/pppoe_test/netx_pppoe_basic_test.c\n    ${SOURCE_DIR}/pppoe_test/netx_pppoe_api_test.c\n    ${SOURCE_DIR}/pppoe_test/netx_pppoe_api_extended_test.c\n    ${SOURCE_DIR}/pppoe_test/netx_pppoe_ac_name_test.c\n    ${SOURCE_DIR}/pppoe_test/netx_pppoe_session_control_test.c)\n\n```\n\n----------------------------------------\n\nTITLE: Call Conditional Source Function CMake\nDESCRIPTION: Calls the `target_sources_if_not_overridden` function for `tx_thread_delete.c` and `tx_thread_reset.c`.  This allows these files to be overridden via the `TX_SRC_OVERRIDES` variable, otherwise the files from the `common_smp` directory are used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/common_smp/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# These files can be overridden by setting them in the variable list named TX_SRC_OVERRIDES\ntarget_sources_if_not_overridden(\"tx_thread_delete.c\")\ntarget_sources_if_not_overridden(\"tx_thread_reset.c\")\n```\n\n----------------------------------------\n\nTITLE: Including Fuzz Subdirectory Conditionally in CMake\nDESCRIPTION: This command includes the 'fuzz' subdirectory in the CMake build process only if the target platform is not WIN32. This allows for fuzz testing to be incorporated on platforms other than Windows.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT WIN32)\n    add_subdirectory(fuzz)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring RFFT Fast Options (Double Precision) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Real FFT (RFFT) fast implementations for double-precision floating-point numbers (f64) with various sizes (32 to 4096). These options are used to customize the CMSIS-DSP library by selecting specific RFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\noption(RFFT_FAST_F64_32     \"rfft fast f64 32\"                  OFF)\noption(RFFT_FAST_F64_64     \"rfft fast f64 64\"                  OFF)\noption(RFFT_FAST_F64_128    \"rfft fast f64 128\"                 OFF)\noption(RFFT_FAST_F64_256    \"rfft fast f64 256\"                 OFF)\noption(RFFT_FAST_F64_512    \"rfft fast f64 512\"                 OFF)\noption(RFFT_FAST_F64_1024   \"rfft fast f64 1024\"                OFF)\noption(RFFT_FAST_F64_2048   \"rfft fast f64 2048\"                OFF)\noption(RFFT_FAST_F64_4096   \"rfft fast f64 4096\"                OFF)\n```\n\n----------------------------------------\n\nTITLE: Random Generator Initialization in C\nDESCRIPTION: This code snippet shows the function prototype for initializing a random number generator context. The function `acme_init_random` takes a pointer to a `acme_random_context_t` as input and returns a `psa_status_t` to indicate success or failure. The core calls this function once after allocating the context.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_34\n\nLANGUAGE: c\nCODE:\n```\npsa_status_t acme_init_random(acme_random_context_t *context);\n```\n\n----------------------------------------\n\nTITLE: C ISR Handler Example\nDESCRIPTION: This snippet demonstrates the structure of an Interrupt Service Routine (ISR) written in C for ThreadX on Cortex-M55. It defines a function `your_C_isr` that contains the ISR processing logic.  No explicit context saving or restoring is required.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Defining FTP Test Cases in CMake\nDESCRIPTION: This snippet defines a list of source files for FTP (File Transfer Protocol) test cases using CMake's `set` command. These tests likely evaluate different aspects of FTP server and client functionality within the NetX Duo networking stack.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nset(ftp_test_cases\n    ${SOURCE_DIR}/ftp_test/netx_ftp_server_dangling_pointer_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_server_mss_too_small_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_pasv_twice_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_disconnection_event_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_ipv6_epsv_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_pasv_port_test.c\n    ${SOURCE_DIR}/ftp_test/netx_ftp_pasv_stor_test.c)\n```\n\n----------------------------------------\n\nTITLE: Set Include Directories with CMake\nDESCRIPTION: This snippet configures the include directories for the project using the `target_include_directories` command in CMake. The `PUBLIC` keyword indicates that these include directories are available to other targets that link against this target. `${CMAKE_CURRENT_LIST_DIR}/inc` specifies the 'inc' directory in the current list file's directory as an include directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m33/ac6/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Fault Tolerant Definitions\nDESCRIPTION: Defines preprocessor definitions for fault-tolerant builds, enabling features like fault tolerance and update file size on allocate.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(FX_FAULT_TOLERANT_DEFINITIONS\n    -DFX_ENABLE_FAULT_TOLERANT -DFX_UPDATE_FILE_SIZE_ON_ALLOCATE\n    -DFX_FAULT_TOLERANT_TRANSACTION_FAIL_FUNCTION)\n```\n\n----------------------------------------\n\nTITLE: Setting Link Libraries\nDESCRIPTION: Defines the list of libraries (`libs`) that the test executables will be linked against. `mbedtls_target` presumably references the Mbed TLS library itself.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/ssl/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(libs\n    ${mbedtls_target}\n)\n```\n\n----------------------------------------\n\nTITLE: Installing CMake on Ubuntu (16.04)\nDESCRIPTION: This snippet installs CMake on Ubuntu 16.04. It downloads a pre-built CMake binary, sets execute permissions, and runs the installer, specifying the installation prefix as `/usr`. The user is prompted to not include the default subdirectory to ensure installation in /usr/local.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n~$ wget https://cmake.org/files/v3.18/cmake-3.18.3-Linux-x86_64.sh # Use latest version.\n~$ sudo chmod 777 cmake-3.18.3-Linux-x86_64.sh # Update permissions to execute script.\n~$ sudo ./cmake-3.18.3-Linux-x86_64.sh --prefix=/usr\n```\n\n----------------------------------------\n\nTITLE: Append Bool Azure IoT JSON Writer C\nDESCRIPTION: Appends a boolean value (true or false) to the JSON payload using the Azure IoT JSON writer. The function takes a pointer to the JSON writer and the boolean value to be appended. Returns NX_AZURE_IOT_SUCCESS on success.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_23\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_bool(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr, UINT value);\n```\n\n----------------------------------------\n\nTITLE: Set up FileX Project with CMake\nDESCRIPTION: This snippet sets up the FileX project using CMake. It defines the minimum required CMake version, sets the project name, and specifies the languages used (C and ASM).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\n\n# Set up the project\nproject(filex\n    LANGUAGES C ASM\n)\n```\n\n----------------------------------------\n\nTITLE: Add CMSISDSPQuaternionMath Library Sources\nDESCRIPTION: This snippet adds the source files to the CMSISDSPQuaternionMath static library. Each `target_sources` command adds a specific `.c` file to the library, defining quaternion math functions. These functions perform operations such as norm calculation, inverse, conjugate, normalization, product, and conversion between quaternion and rotation representations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/QuaternionMathFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(CMSISDSPQuaternionMath STATIC arm_quaternion_norm_f32.c)\ntarget_sources(CMSISDSPQuaternionMath PRIVATE arm_quaternion_inverse_f32.c)\ntarget_sources(CMSISDSPQuaternionMath PRIVATE arm_quaternion_conjugate_f32.c)\ntarget_sources(CMSISDSPQuaternionMath PRIVATE arm_quaternion_normalize_f32.c)\ntarget_sources(CMSISDSPQuaternionMath PRIVATE arm_quaternion_product_single_f32.c)\ntarget_sources(CMSISDSPQuaternionMath PRIVATE arm_quaternion_product_f32.c)\ntarget_sources(CMSISDSPQuaternionMath PRIVATE arm_quaternion2rotation_f32.c)\ntarget_sources(CMSISDSPQuaternionMath PRIVATE arm_rotation2quaternion_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Cortex-M0 ISR in C with ThreadX API access\nDESCRIPTION: Defines the structure of an Interrupt Service Routine (ISR) written in C for Cortex-M0, with access to the ThreadX API. The ISR is declared as a void function with no arguments.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/ac5/readme_threadx.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Setting the trust pem filepath in PowerShell\nDESCRIPTION: This PowerShell script sets the AZ_IOT_DEVICE_X509_TRUST_PEM_FILE_PATH environment variable to the location of the BaltimoreCyberTrustRoot.crt.pem file. This file is used to verify the server's certificate during TLS/SSL handshake, enabling secure communication with Azure IoT Hub.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS C:\\> $env:AZ_IOT_DEVICE_X509_TRUST_PEM_FILE_PATH='C:\\azure-sdk-for-c\\sdk\\samples\\iot\\BaltimoreCyberTrustRoot.crt.pem'\n```\n\n----------------------------------------\n\nTITLE: Locate Mbed TLS Package\nDESCRIPTION: Locates the Mbed TLS CMake package using `find_package`. It sets the `MbedTLS_DIR` variable to the directory containing the Mbed TLS CMake configuration files. This allows CMake to find the necessary files for linking against Mbed TLS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_package/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(MbedTLS_DIR \"${MbedTLS_BINARY_DIR}/cmake\")\nfind_package(MbedTLS REQUIRED)\n```\n\n----------------------------------------\n\nTITLE: Nested IRQ Handler in ThreadX (Assembly)\nDESCRIPTION: This assembly code snippet illustrates the initial part of enabling nested IRQ interrupts within a standard IRQ handler in ThreadX.  It shows the declaration of the IRQ handler (`__tx_irq_handler`) and a return point (`__tx_irq_processing_return`). The complete implementation for nested IRQ would involve calling `_tx_thread_irq_nesting_start` and `_tx_thread_irq_nesting_end`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/iar/readme_threadx.txt#_snippet_2\n\nLANGUAGE: assembly\nCODE:\n```\n    RSEG    .text:CODE:NOROOT(2)\n    PUBLIC  __tx_irq_handler\n    RSEG    .text:CODE:NOROOT(2)\n    PUBLIC  __tx_irq_processing_return      \n__tx_irq_handler\n;\n```\n\n----------------------------------------\n\nTITLE: Define MQTT Test Cases\nDESCRIPTION: This snippet defines a list of C source files that represent the MQTT test cases.  Each file contains a specific test scenario for MQTT functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/regression/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(mqtt_test_cases\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_api_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connect_auth_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connect_auth_empty_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connect_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connect_packet_send_failure_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connect_v6_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connect_non_block_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connect_non_block_2_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_null_password_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_publish_qos0_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_publish_qos1_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_receive_qos0_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_receive_qos1_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_subscribe_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_unsubscribe_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connect_will_message_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connect_will_topic_only_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_not_connected_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connect_with_auth_will_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_keepalive_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_keepalive_timeout_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_multiple_receive_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_remaining_length_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_publish_non_zero_packet_id_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_subscribe_non_zero_packet_id_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_packet_leak_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_receive_span_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_publish_packet_chain_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_subscribe_packet_chain_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_connack_error_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_branch_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_transmit_queue_depth_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_websocket_non_block_test.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_websocket_block_test.c)\n```\n\n----------------------------------------\n\nTITLE: Create Executable for IoT Hub SAS Telemetry Sample\nDESCRIPTION: This snippet creates an executable named `paho_iot_hub_sas_telemetry_sample` from the `paho_iot_hub_sas_telemetry_sample.c` file and links it against the common library.  It then defines a map file using the create_map_file macro.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable (paho_iot_hub_sas_telemetry_sample\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_hub_sas_telemetry_sample.c\n)\n\ntarget_link_libraries(paho_iot_hub_sas_telemetry_sample\n  PRIVATE\n    az::iot::sample::common\n)\n\ncreate_map_file(paho_iot_hub_sas_telemetry_sample paho_iot_hub_sas_telemetry_sample.map)\n```\n\n----------------------------------------\n\nTITLE: Adding NX_Secure TLS Test Cases\nDESCRIPTION: Adds a list of C source files related to NX_Secure TLS tests to the `nx_secure_test_cases` variable. These files will be compiled and executed as part of the test suite.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/regression/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_serverhello_length_checking_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_session_create_ext_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_before_key_generation_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_send_plaintext_alert_after_key_generation_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_server_ciphersuite_priority_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_session_create_ext_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_transmit_mutex_wait_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_empty_clienthello_extension_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_payload_size_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_serverhello_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_hash_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_certificate_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_server_key_exchange_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_send_certificate_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_send_clienthello_test.c\n```\n\n----------------------------------------\n\nTITLE: ThreadX Application Defines (-D option)\nDESCRIPTION: These application defines, specified using the -D option during compilation, enable or disable various features of ThreadX, such as FIQ/IRQ support, stack checking, error checking, preemption threshold, and redundant clearing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/gnu/readme_threadx.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nTX_ENABLE_FIQ_SUPPORT                       This assembler define enables FIQ\n                                                interrupt handling support in the\n                                                ThreadX assembly files. If used,\n                                                it should be used on all assembly\n                                                files and the generic C source of\n                                                ThreadX should be compiled with \n                                                TX_ENABLE_FIQ_SUPPORT defined as well.\n\nTX_ENABLE_IRQ_NESTING                       This assembler define enables IRQ\n                                                nested support. If IRQ nested \n                                                interrupt support is needed, this\n                                                define should be applied to \n                                                tx_initialize_low_level.S.\n\nTX_ENABLE_FIQ_NESTING                       This assembler define enables FIQ\n                                                nested support. If FIQ nested \n                                                interrupt support is needed, this\n                                                define should be applied to \n                                                tx_initialize_low_level.S. In addition,\n                                                IRQ nesting should also be enabled.\n\nTX_ENABLE_FIQ_SUPPORT                       This compiler define enables FIQ\n                                                interrupt handling in the ThreadX\n                                                generic C source. This define \n                                                should also be used in conjunction\n                                                with the corresponding assembler\n                                                define.                                               \n\nTX_DISABLE_ERROR_CHECKING                   If defined before tx_api.h is included,\n                                                this define causes basic ThreadX error\n                                                checking to be disabled. Please see\n                                                Chapter 2 in the \"ThreadX User Guide\" \n                                                for more details.\n\nTX_MAX_PRIORITIES                           Defines the priority levels for ThreadX. \n                                                Legal values range from 32 through \n                                                1024 (inclusive) and MUST be evenly divisible \n                                                by 32. Increasing the number of priority levels \n                                                supported increases the RAM usage by 128 bytes \n                                                for every group of 32 priorities. However, there \n                                                is only a negligible effect on performance. By \n                                                default, this value is set to 32 priority levels.\n\nTX_MINIMUM_STACK                            Defines the minimum stack size (in bytes). It is \n                                                used for error checking when threads are created. \n                                                The default value is port-specific and is found \n                                                in tx_port.h.\n\nTX_TIMER_THREAD_STACK_SIZE                  Defines the stack size (in bytes) of the internal \n                                                ThreadX timer thread. This thread processes all \n                                                thread sleep requests as well as all service call \n                                                timeouts. In addition, all application timer callback \n                                                routines are invoked from this context. The default \n                                                value is port-specific and is found in tx_port.h.\n\nTX_TIMER_THREAD_PRIORITY                    Defines the priority of the internal ThreadX timer \n                                                thread. The default value is priority 0 - the highest \n                                                priority in ThreadX. The default value is defined \n                                                in tx_port.h.\n\nTX_TIMER_PROCESS_IN_ISR                     Defined, this option eliminates the internal system \n                                                timer thread for ThreadX. This results in improved \n                                                performance on timer events and smaller RAM requirements \n                                                because the timer stack and control block are no \n                                                longer needed. However, using this option moves all \n                                                the timer expiration processing to the timer ISR level. \n                                                By default, this option is not defined.\n\nTX_REACTIVATE_INLINE                        Defined, this option performs reactivation of ThreadX \n                                                timers in-line instead of using a function call. This \n                                                improves performance but slightly increases code size. \n                                                By default, this option is not defined.\n\nTX_DISABLE_STACK_FILLING                    Defined, placing the 0xEF value in each byte of each \n                                                thread's stack is disabled. By default, this option is \n                                                not defined.\n\nTX_ENABLE_STACK_CHECKING                    Defined, this option enables ThreadX run-time stack checking, \n                                                which includes analysis of how much stack has been used and \n                                                examination of data pattern \"fences\" before and after the \n                                                stack area. If a stack error is detected, the registered \n                                                application stack error handler is called. This option does \n                                                result in slightly increased overhead and code size. Please \n                                                review the tx_thread_stack_error_notify API for more information. \n                                                By default, this option is not defined.\n\nTX_DISABLE_PREEMPTION_THRESHOLD             Defined, this option disables the preemption-threshold feature \n                                                and slightly reduces code size and improves performance. Of course, \n                                                the preemption-threshold capabilities are no longer available. \n                                                By default, this option is not defined.\n\nTX_DISABLE_REDUNDANT_CLEARING               Defined, this option removes the logic for initializing ThreadX \n```\n\n----------------------------------------\n\nTITLE: Building Demonstration System using Make\nDESCRIPTION: This command builds the demonstration system. It compiles the sample_threadx.c application and links it with the tx.a library. The resulting DEMO file is a binary executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/linux/gnu/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\nmake sample_threadx\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: Adds subdirectories for the NetX Duo library and regression tests. This allows CMake to include and build these components as part of the main project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../../.. netxduo)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/regression regression)\n```\n\n----------------------------------------\n\nTITLE: Key Type Specification Example (C Macro)\nDESCRIPTION: These are valid examples that demonstrates how to define key types using `PSA_KEY_TYPE_xxx` macros. The key type specification consists of a string consisting of a `PSA_KEY_TYPE_xxx` macro that specifies a key type. If the macro takes an argument, the string must have the syntax of a C macro call and each argument must be the name of a constant of suitable type (curve or group).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nPSA_KEY_TYPE_AES\nPSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1)\nPSA_KEY_TYPE_ECC_KEY_PAIR(_)\n```\n\n----------------------------------------\n\nTITLE: CMSIS-DSP Path Configuration\nDESCRIPTION: This snippet defines the path to the CMSIS-DSP library. The ROOT variable is expected to be defined on the command line.  It then adds the DSP directory to the CMake module path so that custom modules can be found.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Needed to include the configBoot module\n# Define the path to CMSIS-DSP (ROOT is defined on command line when using cmake)\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\n# Add DSP folder to module path\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: Nested FIQ Interrupt Handler (Assembly)\nDESCRIPTION: This code demonstrates enabling nested FIQ interrupts within the FIQ handler. It calls _tx_thread_fiq_nesting_start and _tx_thread_fiq_nesting_end to manage the transition to system mode and enable/disable FIQ interrupts for nesting purposes. Requires TX_ENABLE_FIQ_NESTING to be defined during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/iar/readme_threadx.txt#_snippet_5\n\nLANGUAGE: Assembly\nCODE:\n```\n    RSEG    .text:CODE:NOROOT(2)\n    PUBLIC  __tx_fiq_handler\n    RSEG    .text:CODE:NOROOT(2)\n    PUBLIC  __tx_fiq_processing_return\n__tx_fiq_handler\n;\n;    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return:\n;\n;    /* At this point execution is still in the FIQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use.  */\n;\n;    /* Enable nested FIQ interrupts. NOTE:  Since this service returns\n;       with FIQ interrupts enabled, all FIQ interrupt sources must be \n;       cleared prior to calling this service.  */\n    BL      _tx_thread_fiq_nesting_start\n;\n;    /* Application FIQ dispatch call goes here!  */\n;\n;    /* Disable nested FIQ interrupts. The mode is switched back to\n;       FIQ mode and FIQ interrupts are disable upon return.  */\n    BL      _tx_thread_fiq_nesting_end\n;\n;    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: Link FileX to ThreadX\nDESCRIPTION: This snippet links the FileX library to the ThreadX library if FileX is not in standalone mode. It uses the alias \"azrtos::threadx\" to refer to the ThreadX library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT FX_STANDALONE_ENABLE)\n    target_link_libraries(${PROJECT_NAME} PUBLIC \n        \"azrtos::threadx\"\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditional Target Sources (Float16)\nDESCRIPTION: Conditionally includes float16 versions of complex math functions if ARMAC5 is not defined AND DISABLEFLOAT16 is not defined.  Includes complex conjugation, dot product, magnitude, magnitude squared, complex multiplication, and complex multiplication by real.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_17\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_conj_f16.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_dot_prod_f16.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_f16.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_squared_f16.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mult_cmplx_f16.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mult_real_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configure Target Sources CMake\nDESCRIPTION: This CMake snippet configures the target sources for the project, adding source files to be compiled. The `target_sources` command specifies the project name and the `PRIVATE` keyword indicates that these sources are used internally within the project. The code within the comments are placeholders for actual source files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/ports/cortex_m7/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Executables and Linking Libraries\nDESCRIPTION: This snippet iterates through the `sample_files` list. For each file, it extracts the filename without the extension, creates an executable with that name, and links the executable to the `azrtos::${PRODUCT}` library (where PRODUCT is likely a variable holding the product name such as NetXDuo).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/samples/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(sample_file ${sample_files})\n  get_filename_component(sample_file_name ${sample_file} NAME_WE)\n  add_executable(${sample_file_name} ${sample_file})\n  target_link_libraries(${sample_file_name} PRIVATE azrtos::${PRODUCT})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Initialize CMake Project for Regression Tests\nDESCRIPTION: This snippet initializes the CMake project, setting the minimum required CMake version and creating a new project named 'regression_test' that uses the C language.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(regression_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Creating test_utility library\nDESCRIPTION: This snippet creates a static library named `test_utility` from the `tx_initialize_low_level.c` and `testcontrol.c` source files. It then links it against the ThreadX library and defines compilation definitions for the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/regression/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(test_utility ${SOURCE_DIR}/tx_initialize_low_level.c\n                         ${SOURCE_DIR}/testcontrol.c)\ntarget_link_libraries(test_utility PUBLIC azrtos::threadx)\ntarget_compile_definitions(test_utility PUBLIC CTEST BATCH_TEST\n                                               TEST_STACK_SIZE_PRINTF=4096)\n```\n\n----------------------------------------\n\nTITLE: Adding Executables and Configuring Network (CMake)\nDESCRIPTION: This snippet iterates through the `nx_secure_test_cases` list, adds an executable for each test case, configures the network, and links the executable with the `test_utility` and `pcap` libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/regression/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(test_case ${nx_secure_test_cases})\n  add_executable(${test_case} ${${test_case}_file_list} ${PCAP_SOURCE})\n  network_config(${test_case})\n  target_link_libraries(${test_case} PRIVATE test_utility pcap)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Creating Executable Target\nDESCRIPTION: Creates an executable target named 'arm_sin_cos_example'. The 'config' module and 'configApp' function are used to configure the application, and the source file 'arm_sin_cos_example_f32.c' is added to the target's private sources.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_sin_cos_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(arm_sin_cos_example)\n\n\ninclude(config)\nconfigApp(arm_sin_cos_example ${ROOT})\n\ntarget_sources(arm_sin_cos_example PRIVATE arm_sin_cos_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Source Code Packaging Configuration (CMake)\nDESCRIPTION: This snippet configures CPack to create a ZIP archive of the source code. It specifies the generator as \"ZIP\" and sets up ignore patterns to exclude specific files and directories like '.git' and build directories.  It also includes the CPack module.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Enable a build target that produces a ZIP file of all sources\nset(CPACK_SOURCE_GENERATOR \"ZIP\")\nset(CPACK_SOURCE_IGNORE_FILES\n  \\\\.git/\n  \\\\.github/\n  _build/\n  \\\\.git\n  \\\\.gitattributes\n  \\\\.gitignore\n  \".*~$\"\n)\nset(CPACK_VERBATIM_VARIABLES YES)\ninclude(CPack)\n```\n\n----------------------------------------\n\nTITLE: Create Executable for IoT Hub Telemetry Sample\nDESCRIPTION: This snippet creates an executable named `paho_iot_hub_telemetry_sample` from the `paho_iot_hub_telemetry_sample.c` file and links it against the common library.  It then defines a map file using the create_map_file macro.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable (paho_iot_hub_telemetry_sample\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_hub_telemetry_sample.c\n)\n\ntarget_link_libraries(paho_iot_hub_telemetry_sample\n  PRIVATE\n    az::iot::sample::common\n)\n\ncreate_map_file(paho_iot_hub_telemetry_sample paho_iot_hub_telemetry_sample.map)\n```\n\n----------------------------------------\n\nTITLE: Adding custom command to generate query_config.c (CMake)\nDESCRIPTION: Adds a custom command to generate `query_config.c` using a Perl script and configuration files if `GEN_FILES` is enabled. The command depends on the Perl executable and input files. It also adds a custom target for this file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(GEN_FILES)\n    find_package(Perl REQUIRED)\n\n    add_custom_command(\n        OUTPUT\n            ${CMAKE_CURRENT_BINARY_DIR}/query_config.c\n        COMMAND\n            ${PERL}\n                ${CMAKE_CURRENT_SOURCE_DIR}/../../scripts/generate_query_config.pl\n                ${CMAKE_CURRENT_SOURCE_DIR}/../../include/mbedtls/mbedtls_config.h\n                ${CMAKE_CURRENT_SOURCE_DIR}/../../include/psa/crypto_config.h\n                ${CMAKE_CURRENT_SOURCE_DIR}/../../scripts/data_files/query_config.fmt\n                ${CMAKE_CURRENT_BINARY_DIR}/query_config.c\n        DEPENDS\n            ${CMAKE_CURRENT_SOURCE_DIR}/../../scripts/generate_query_config.pl\n            ${CMAKE_CURRENT_SOURCE_DIR}/../../include/mbedtls/mbedtls_config.h\n            ${CMAKE_CURRENT_SOURCE_DIR}/../../include/psa/crypto_config.h\n            ${CMAKE_CURRENT_SOURCE_DIR}/../../scripts/data_files/query_config.fmt\n    )\n    # this file will also be used in another directory, so create a target, see\n    # https://gitlab.kitware.com/cmake/community/-/wikis/FAQ#how-can-i-add-a-dependency-to-a-source-file-which-is-generated-in-a-subdirectory\n    add_custom_target(generate_query_config_c\n        DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/query_config.c)\nelse()\n    link_to_source(query_config.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files to Target with CMake\nDESCRIPTION: This snippet uses the `target_sources` command in CMake to add a list of C source files to the `cmsis-nn` target. The `PRIVATE` keyword indicates that these source files are only used for building the `cmsis-nn` target and are not exposed to other targets. The source files include implementations for q7 to q15 conversion, matrix multiplication kernels, and vector-matrix multiplication.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/NNSupportFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(cmsis-nn PRIVATE ${SRC} arm_q7_to_q15_with_offset.c\n                                       arm_nn_mat_mul_kernel_s16.c\n                                       arm_q7_to_q15_with_offset.c\n                                       arm_nn_mat_mul_kernel_s16.c\n                                       arm_nn_vec_mat_mult_t_s16.c\n                                       arm_q7_to_q15_no_shift.c)\n```\n\n----------------------------------------\n\nTITLE: Setting Folder Property\nDESCRIPTION: Enables the use of folders in the IDE for better project organization.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Set property for folder\nset_property(GLOBAL PROPERTY USE_FOLDERS ON)\n```\n\n----------------------------------------\n\nTITLE: Set Build Configurations\nDESCRIPTION: This snippet defines multiple build configurations for the project, each with specific preprocessor definitions. These configurations enable different features, such as coverage testing, TLS versions, and cipher suites. The configurations are then used to create CMake build types.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_CONFIGURATIONS\n    default_build_coverage\n    psk_build_coverage\n    tls_1_0_enable_build\n    tls_1_1_enable_build\n    tls_1_3_enable_build_coverage\n    client_disable_build\n    server_disable_build\n    tls_1_3_client_disable_build\n    tls_1_3_server_disable_build\n    ecjpake_build\n    dtls_build_coverage\n    eal4_build_coverage\n    sesip_build_coverage\n    no_ecc_build_coverage\n    no_renegotiation_build\n    no_client_renegotiation_build\n    no_x509_build\n    hash_clone_build\n    curve25519_448_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: Defining the NetXDuo Library and its Dependencies\nDESCRIPTION: This snippet defines the NetXDuo library and an alias, and it specifies dependencies on ThreadX. It conditionally links to FileX if NXD_ENABLE_FILE_SERVERS is enabled, and to Azure IoT libraries if NXD_ENABLE_AZURE_IOT is enabled. The target_link_libraries commands ensure that the NetXDuo library links against the necessary dependencies during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Define our target library and an alias for consumers\nadd_library(${PROJECT_NAME})\nadd_library(\"azrtos::${PROJECT_NAME}\" ALIAS ${PROJECT_NAME})\n\n# Define any required dependencies between this library and others\ntarget_link_libraries(${PROJECT_NAME} PUBLIC \"azrtos::threadx\")\n\nif(NXD_ENABLE_FILE_SERVERS)\n    message(STATUS \"NXD_ENABLE_FILE_SERVERS - defined\")\n    target_link_libraries(${PROJECT_NAME} PUBLIC \"azrtos::filex\")\nendif()\n\nif(NXD_ENABLE_AZURE_IOT)\n    message(STATUS \"NXD_ENABLE_AZURE_IOT - defined\")\n    target_link_libraries(${PROJECT_NAME} PUBLIC az_iot_hub az_iot_provisioning)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Build Mbed TLS with Make\nDESCRIPTION: This command initiates the build process for the Mbed TLS library using GNU Make. It compiles the source code and creates the necessary libraries and executables.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Environment Parameter\nDESCRIPTION: Optional name of the cloud environment. The default is the Azure Public Cloud ('AzureCloud'). This allows specifying different Azure environments, such as AzureUSGovernment or AzureChinaCloud.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nType: String\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: AzureCloud\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Linking Sources to Target in CMake\nDESCRIPTION: This snippet uses the `target_sources` command to link the source files found by the previous `file(GLOB)` commands to the `cmsis-nn` target. The `PRIVATE` keyword specifies that these sources are only used within the `cmsis-nn` target and are not exposed to other targets that depend on it.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/PoolingFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(cmsis-nn PRIVATE ${SRC} ${SRC_S16})\n```\n\n----------------------------------------\n\nTITLE: Configure ThreadX Source Files with CMake\nDESCRIPTION: This CMake code block configures the source files for the ThreadX RTOS library. It uses the `target_sources` command to specify a list of C source files to be compiled and linked into the target `${PROJECT_NAME}`. The `PRIVATE` keyword indicates that these sources are only visible within this target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/common/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_block_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_block_pool_cleanup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_block_pool_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_block_pool_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_block_pool_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_block_pool_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_block_pool_performance_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_block_pool_performance_system_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_block_pool_prioritize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_block_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_pool_cleanup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_pool_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_pool_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_pool_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_pool_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_pool_performance_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_pool_performance_system_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_pool_prioritize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_pool_search.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_byte_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_event_flags_cleanup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_event_flags_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_event_flags_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_event_flags_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_event_flags_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_event_flags_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_event_flags_performance_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_event_flags_performance_system_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_event_flags_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_event_flags_set_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_high_level.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_kernel_enter.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_kernel_setup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_misra.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_cleanup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_performance_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_performance_system_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_prioritize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_priority_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_mutex_put.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_cleanup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_flush.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_front_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_performance_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_performance_system_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_prioritize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_queue_send_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_ceiling_put.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_cleanup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_performance_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_performance_system_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_prioritize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_put.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_semaphore_put_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_entry_exit_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_identify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_performance_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_performance_system_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_preemption_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_priority_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_relinquish.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_resume.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_shell_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_sleep.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_analyze.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_error_handler.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_error_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_suspend.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_preempt_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_resume.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_suspend.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_terminate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_time_slice.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_time_slice_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_timeout.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_wait_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_time_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_time_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_expiration_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_performance_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_performance_system_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_system_activate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_system_deactivate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_buffer_full_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_event_filter.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_event_unfilter.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_interrupt_control.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_isr_enter_insert.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_isr_exit_insert.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_object_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_object_unregister.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_trace_user_event_insert.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_block_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_block_pool_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_block_pool_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_block_pool_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_block_pool_prioritize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_block_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_byte_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_byte_pool_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_byte_pool_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_byte_pool_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_byte_pool_prioritize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_byte_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_event_flags_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_event_flags_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_event_flags_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_event_flags_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_event_flags_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_event_flags_set_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_mutex_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_mutex_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_mutex_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_mutex_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_mutex_prioritize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_mutex_put.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_queue_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_queue_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_queue_flush.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_queue_front_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_queue_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_queue_prioritize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_queue_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_queue_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_queue_send_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_semaphore_ceiling_put.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_semaphore_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_semaphore_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_semaphore_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_semaphore_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_semaphore_prioritize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_semaphore_put.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_semaphore_put_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_entry_exit_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_preemption_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_priority_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_relinquish.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_resume.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_suspend.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_terminate.c\n)\n```\n\n----------------------------------------\n\nTITLE: Find Threads Library\nDESCRIPTION: Finds the Threads library and sets the necessary flags for using PThreads. This ensures that executables are linked against PThreads if available.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_THREAD_PREFER_PTHREAD TRUE)\nset(THREADS_PREFER_PTHREAD_FLAG TRUE)\nfind_package(Threads)\n```\n\n----------------------------------------\n\nTITLE: Add Include Directories with CMake\nDESCRIPTION: This CMake snippet adds an include directory to the project's build configuration. It uses the `target_include_directories` command to specify the directory containing header files.  The directory is set to the 'inc' folder within the current CMake list directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/ports/cortex_m3/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Source Directory and Sample Files\nDESCRIPTION: This section sets the source directory for the sample files using CMAKE_CURRENT_LIST_DIR. It then defines a variable 'sample_files' listing the C source file to be compiled, specifically demo_filex.c.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/samples/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../samples)\n\nset(sample_files\n    ${SOURCE_DIR}/demo_filex.c)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This snippet sets the minimum CMake version, defines the project name and version. This is a standard starting point for a CMake project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_fft_bin_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: Sending Direct Method Message Response - C\nDESCRIPTION: This function sends a response to a direct method message to IoT Hub.  It requires the status code, context received from the receive function, and the payload in JSON format. It returns a status indicating if the message was sent successfully or an error occurred, such as invalid parameters or packet pool exhaustion.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_26\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_direct_method_message_response(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                            UINT status_code, VOID *context_ptr, USHORT context_length,,\n                                                            const UCHAR *payload, UINT payload_length, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Creating a Simulated Interrupt Thread in C++\nDESCRIPTION: Creates a simulated interrupt thread in Win32. This code snippet uses the `CreateThread` function to create the thread in a suspended state and then sets the thread priority using `SetThreadPriority`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/win32/vs_2019/readme_threadx.txt#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n        _sample_win32_interrupt_handle =\n            CreateThread(NULL, 0, _sample_win32_interrupt, (LPVOID) &_sample_win32_interrupt_handle,\n                    CREATE_SUSPENDED, &_sample_win32_interrupt_id);\n\n        SetThreadPriority(_sample_win32_interrupt_handle, THREAD_PRIORITY_BELOW_NORMAL);\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Target for Building Libraries\nDESCRIPTION: This snippet adds a custom target named 'build_libs' that executes a shell script to build the required libraries.  It then sets up a dependency so that 'usbx' depends on 'build_libs'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\n# Build ThreadX library once\nexecute_process(COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh build_libs)\nadd_custom_target(build_libs ALL COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh\n                                         build_libs)\n\nadd_dependencies(usbx build_libs)\ntarget_include_directories(usbx PUBLIC ${CMAKE_BINARY_DIR}/../libs/inc)\n```\n\n----------------------------------------\n\nTITLE: Creating an OSEK ISR in C\nDESCRIPTION: This C code displays the function signature for creating an ISR using the CreateISR function. It takes the ISR name, entry function, category, and stack size as parameters. The function returns the created ISR ID.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nISRType CreateISR(const CHAR *name, \n                      void(*entry_function)(), \n                      UINT category, \n                      ULONG stack_size);\n```\n\n----------------------------------------\n\nTITLE: Creating an OSEK Alarm in C\nDESCRIPTION: This C code demonstrates the function signature to create an OSEK alarm using CreateAlarm. It takes parameters such as name, counter, action, events, task, callback function, startup time, alarm time, and cycle time.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_13\n\nLANGUAGE: C\nCODE:\n```\nAlarmType CreateAlarm(CHAR *name, \n                      CounterType cntr, \n                      UINT action, \n                      ULONG events, \n                      TaskType task, \n                      void (*callback)(), \n                      UINT Startup, TickType Alarmtime, \n                      TickType Cycle);\n```\n\n----------------------------------------\n\nTITLE: Generating Source File from Python CMake\nDESCRIPTION: This CMake snippet conditionally generates a C source file (psa_constant_names_generated.c) using a Python script (generate_psa_constants.py). It uses add_custom_command to invoke the Python script, and sets the dependencies so that the C file is regenerated when the Python script or the header files change.  If GEN_FILES is not defined, it links to an existing source file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/psa/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(GEN_FILES)\n    add_custom_command(\n        OUTPUT\n            ${CMAKE_CURRENT_BINARY_DIR}/psa_constant_names_generated.c\n        COMMAND\n            ${MBEDTLS_PYTHON_EXECUTABLE}\n                ${CMAKE_CURRENT_SOURCE_DIR}/../../scripts/generate_psa_constants.py\n                ${CMAKE_CURRENT_BINARY_DIR}\n        WORKING_DIRECTORY\n            ${CMAKE_CURRENT_SOURCE_DIR}/../..\n        DEPENDS\n            ${CMAKE_CURRENT_SOURCE_DIR}/../../scripts/generate_psa_constants.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../../include/psa/crypto_values.h\n            ${CMAKE_CURRENT_SOURCE_DIR}/../../include/psa/crypto_extra.h\n    )\nelse()\n    link_to_source(psa_constant_names_generated.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditional Inclusion of iperf Include Directories\nDESCRIPTION: This snippet conditionally includes the iperf directory into the target's include directories if NXD_ENABLE_FILE_SERVERS is enabled.  It uses CMake's `target_include_directories` command to add the specified directory to the project's include paths, making the iperf header files available.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/utility/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NXD_ENABLE_FILE_SERVERS)\n    target_include_directories(${PROJECT_NAME} PUBLIC\n        ${CMAKE_CURRENT_LIST_DIR}/iperf\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: EWARM linker configuration for ThreadX heap\nDESCRIPTION: This snippet shows how to configure the linker file for EWARM to add a section for ThreadX dynamic memory allocation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_Thread_Sync/README.md#_snippet_0\n\nLANGUAGE: Other\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for Utility Files CMake\nDESCRIPTION: Defines the source file paths for the USBX test utility files. These files provide common functions and utilities used by the various test cases. They include dummy device and host classes, simulation utilities, and standalone references.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_28\n\nLANGUAGE: CMake\nCODE:\n```\n   ${SOURCE_DIR}/usbxtestcontrol.c\n    ${SOURCE_DIR}/ux_test.c\n    ${SOURCE_DIR}/ux_host_class_dummy.c\n    ${SOURCE_DIR}/ux_host_class_dummy.h\n    ${SOURCE_DIR}/ux_device_class_dummy.c\n    ${SOURCE_DIR}/ux_device_class_dummy.h\n    ${SOURCE_DIR}/ux_device_class_dummy_hub.c\n    ${SOURCE_DIR}/ux_device_class_dummy_hub.h\n    # ${SOURCE_DIR}/ux_device_class_dummy_printer.c\n    # ${SOURCE_DIR}/ux_device_class_dummy_printer.h\n    ${SOURCE_DIR}/ux_test_utility_sim_no_overriding.c\n    ${SOURCE_DIR}/ux_test_race_condition_overrides.c\n    ${SOURCE_DIR}/ux_test_dcd_sim_slave.c\n    ${SOURCE_DIR}/ux_test_hcd_sim_host.c\n    ${SOURCE_DIR}/ux_test_utility_sim.c\n    ${SOURCE_DIR}/ux_test_standalone_references.c\n    ${SOURCE_DIR}/usbx_ux_host_class_storage_fx_driver.c\n```\n\n----------------------------------------\n\nTITLE: Setting Prolific Test Cases Variable in CMake\nDESCRIPTION: This snippet defines a CMake variable, `ux_class_prolific_test_cases`, and assigns it a single source file related to Prolific tests.  This file is a C file that tests the USBX Prolific host class.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_prolific_test_cases\n  ${SOURCE_DIR}/usbx_uxe_host_prolific_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: Linking CMSISDSP Library\nDESCRIPTION: Links the 'CMSISDSP' library to the 'arm_sin_cos_example' executable.  This ensures that the application can access the functions and data structures provided by the CMSIS-DSP library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_sin_cos_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(arm_sin_cos_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Conditional Helium/MVEF Sources\nDESCRIPTION: Conditionally adds the arm_mve_tables.c and arm_mve_tables_f16.c source files if either HELIUM or MVEF is enabled. These files provide tables for the MVE (Armv8-M Mainline Vector Extension) functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nif (HELIUM OR MVEF)\n    target_sources(CMSISDSPCommon PRIVATE \"${DSP}/Source/CommonTables/arm_mve_tables.c\")\n    target_sources(CMSISDSPCommon PRIVATE \"${DSP}/Source/CommonTables/arm_mve_tables_f16.c\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: System Clock Configuration\nDESCRIPTION: The SystemClock_Config() function is called to configure the system clock (SYSCLK) to run at 250 MHz.  This clock frequency is essential for proper operation of the peripherals and overall system timing. It should be called after HAL initialization.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples_MIX/SPI/SPI_FullDuplex_ComPolling_Slave/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nSystemClock_Config();\n```\n\n----------------------------------------\n\nTITLE: Create source ZIP archive\nDESCRIPTION: This snippet configures CPack to create a ZIP archive of the USBX source code. It specifies files and directories to ignore during the archiving process, such as Git repositories and build directories.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\n# Enable a build target that produces a ZIP file of all sources\nset(CPACK_SOURCE_GENERATOR \"ZIP\")\nset(CPACK_SOURCE_IGNORE_FILES\n  \\\\.git/\n  \\\\.github/\n  _build/\n  \\\\.git\n  \\\\.gitattributes\n  \\\\.gitignore\n  \".*~$\"\n)\nset(CPACK_VERBATIM_VARIABLES YES)\ninclude(CPack)\n```\n\n----------------------------------------\n\nTITLE: Create Executable for IoT Hub C2D Sample\nDESCRIPTION: This snippet creates an executable named `paho_iot_hub_c2d_sample` from the `paho_iot_hub_c2d_sample.c` file and links it against the common library.  It then defines a map file using the create_map_file macro.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable (paho_iot_hub_c2d_sample\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_hub_c2d_sample.c\n)\n\ntarget_link_libraries(paho_iot_hub_c2d_sample\n  PRIVATE\n    az::iot::sample::common\n)\n\ncreate_map_file(paho_iot_hub_c2d_sample paho_iot_hub_c2d_sample.map)\n```\n\n----------------------------------------\n\nTITLE: Generating Base Names for Data Files\nDESCRIPTION: This snippet uses `execute_process` to run Python scripts that generate lists of base names for the data files used in the test suites. It then removes any directory components from the generated names using `string(REGEX REPLACE)`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/tests/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(\n    COMMAND\n        ${MBEDTLS_PYTHON_EXECUTABLE}\n        ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_bignum_tests.py\n        --list-for-cmake\n    WORKING_DIRECTORY\n        ${CMAKE_CURRENT_SOURCE_DIR}/..\n    OUTPUT_VARIABLE\n        base_bignum_generated_data_files)\nstring(REGEX REPLACE \"[^;]*/\" \"\"\n       base_bignum_generated_data_files \"${base_bignum_generated_data_files}\")\n```\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(\n    COMMAND\n        ${MBEDTLS_PYTHON_EXECUTABLE}\n        ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_config_tests.py\n        --list-for-cmake\n    WORKING_DIRECTORY\n        ${CMAKE_CURRENT_SOURCE_DIR}/..\n    OUTPUT_VARIABLE\n        base_config_generated_data_files)\nstring(REGEX REPLACE \"[^;]*/\" \"\"\n       base_config_generated_data_files \"${base_config_generated_data_files}\")\n```\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(\n    COMMAND\n        ${MBEDTLS_PYTHON_EXECUTABLE}\n        ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_ecp_tests.py\n        --list-for-cmake\n    WORKING_DIRECTORY\n        ${CMAKE_CURRENT_SOURCE_DIR}/..\n    OUTPUT_VARIABLE\n        base_ecp_generated_data_files)\nstring(REGEX REPLACE \"[^;]*/\" \"\"\n       base_ecp_generated_data_files \"${base_ecp_generated_data_files}\")\n```\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(\n    COMMAND\n        ${MBEDTLS_PYTHON_EXECUTABLE}\n        ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_psa_tests.py\n        --list-for-cmake\n    WORKING_DIRECTORY\n        ${CMAKE_CURRENT_SOURCE_DIR}/..\n    OUTPUT_VARIABLE\n        base_psa_generated_data_files)\nstring(REGEX REPLACE \"[^;]*/\" \"\"\n       base_psa_generated_data_files \"${base_psa_generated_data_files}\")\n```\n\n----------------------------------------\n\nTITLE: ARM Template Parameters\nDESCRIPTION: Optional key-value pairs of parameters to pass to the ARM template(s). This parameter enables the passing of custom parameters to the ARM template during deployment, allowing for flexible resource configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\nType: Hashtable\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: None\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Create Test Utility Library\nDESCRIPTION: This snippet creates a static library named `test_utility` which includes `tx_initialize_low_level.c` and `testcontrol.c`. It links against the `azrtos::threadx_smp` library and defines compile definitions for testing. The `tx_initialize_low_level.c` is generated by the custom command defined above.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/regression/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(test_utility ${SOURCE_DIR}/tx_initialize_low_level.c\n                         ${SOURCE_DIR}/testcontrol.c)\ntarget_link_libraries(test_utility PUBLIC azrtos::threadx_smp)\ntarget_compile_definitions(test_utility PUBLIC CTEST BATCH_TEST)\n```\n\n----------------------------------------\n\nTITLE: Setting Target Include Directories with CMake\nDESCRIPTION: This CMake snippet uses the `target_include_directories` command to define the include directories for the specified project. It sets the `PUBLIC` visibility, meaning these include directories will be available to the target and any other targets that depend on it. This allows other modules to use the header files located in the specified \"inc\" directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    inc\n)\n```\n\n----------------------------------------\n\nTITLE: FIQ Handler with Nested FIQ Support in ARM Assembly\nDESCRIPTION: This assembly code shows a typical FIQ handler with nested FIQ support enabled. It includes saving the system context, enabling nested FIQ interrupts, disabling nested FIQ interrupts, and restoring the system context. The FIQ nesting start service must be called after clearing FIQ interrupt sources.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac6/readme_threadx.txt#_snippet_5\n\nLANGUAGE: assembly\nCODE:\n```\n    .global __tx_fiq_handler\n    .global __tx_fiq_processing_return\n__tx_fiq_handler:\n@\n@    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return:\n@\n@    /* At this point execution is still in the FIQ mode. The CPSR, point of\n@       interrupt, and all C scratch registers are available for use.  */\n@\n@    /* Enable nested FIQ interrupts. NOTE:  Since this service returns\n@       with FIQ interrupts enabled, all FIQ interrupt sources must be \n@       cleared prior to calling this service.  */\n    BL      _tx_thread_fiq_nesting_start\n@\n@    /* Application FIQ handlers can be called here!  */\n@\n@    /* Disable nested FIQ interrupts. The mode is switched back to\n@       FIQ mode and FIQ interrupts are disable upon return.  */\n    BL      _tx_thread_fiq_nesting_end\n@\n@    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: Skipping Test Suites\nDESCRIPTION: This snippet defines how to skip test suites. If the `SKIP_TEST_SUITES` variable is not already defined with -D, get it from the environment. Test suites caught by `SKIP_TEST_SUITES` are built but not executed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/tests/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif((NOT DEFINED SKIP_TEST_SUITES) AND (DEFINED ENV{SKIP_TEST_SUITES}))\n    set(SKIP_TEST_SUITES $ENV{SKIP_TEST_SUITES})\nendif()\n# Test suites caught by SKIP_TEST_SUITES are built but not executed.\n# \"foo\" as a skip pattern skips \"test_suite_foo\" and \"test_suite_foo.bar\"\n```\n\n----------------------------------------\n\nTITLE: Checking Python Executable\nDESCRIPTION: This snippet checks if `MBEDTLS_PYTHON_EXECUTABLE` is defined. If not, it raises a fatal error, indicating that Python 3 is required to build the test suites.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/tests/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT MBEDTLS_PYTHON_EXECUTABLE)\n    message(FATAL_ERROR \"Cannot build test suites without Python 3\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Bash - Setting Environment Variable for Storage URL\nDESCRIPTION: This snippet shows how to set the `AZURE_STORAGE_URL` environment variable on Linux. This variable is required by the storage sample to authenticate with the Azure Storage account and container. Ensure this environment variable is set before running the storage sample.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/README.md#_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\n# On linux, set env var like this. For Windows, do it from advanced settings/ env variables\n\nexport ENV_URL=\"https://?????????????\"\n```\n\n----------------------------------------\n\nTITLE: Defining Project and Toolchain Settings\nDESCRIPTION: This snippet defines the project name, supported languages, CPU architecture, and compiler.  It also sets up multiple build configurations including default, coverage, FIPS coverage, standalone and curve25519 builds. It defines variables for each build configuration that define compile options.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/crypto/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(crypto_test LANGUAGES C)\n\nset(CPU_ARCH \"linux\")\nset(COMPILER \"gnu\")\n\n# Set build configurations\nset(BUILD_CONFIGURATIONS default_build_coverage fips_build_coverage\n                         standalone_build curve25519_448_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n\nset(default_build_coverage \"\")\nset(fips_build_coverage -DNX_CRYPTO_SELF_TEST)\nset(standalone_build -DNX_CRYPTO_STANDALONE_ENABLE -DNX_CRYPTO_SELF_TEST)\nset(curve25519_448_build -DNX_CRYPTO_ENABLE_CURVE25519_448)\n```\n\n----------------------------------------\n\nTITLE: Building ThreadX and FileX libraries CMake\nDESCRIPTION: This snippet defines custom targets and dependencies for building ThreadX and FileX libraries. It executes a shell script `run.sh` to build the libraries. It then defines custom targets for the build process and specifies dependencies to ensure that the libraries are built before the main product. Finally, it imports ThreadX and FileX as shared libraries, sets their properties, and links FileX to the main product.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\n# Build ThreadX library once\nexecute_process(COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh build_libs)\nadd_custom_target(build_libs ALL COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh\n                                         build_libs)\nadd_dependencies(${PRODUCT} build_libs)\ntarget_include_directories(${PRODUCT} PUBLIC ${CMAKE_BINARY_DIR}/../libs/inc)\nadd_library(threadx SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::threadx\" ALIAS threadx)\nset_target_properties(\n  threadx PROPERTIES IMPORTED_LOCATION\n                     ${CMAKE_BINARY_DIR}/../libs/threadx/libthreadx.so)\nadd_library(filex SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::filex\" ALIAS filex)\nset_target_properties(\n  filex PROPERTIES IMPORTED_LOCATION\n                    ${CMAKE_BINARY_DIR}/../libs/filex/libfilex.so)\ntarget_link_libraries(${PRODUCT} PUBLIC filex)\n```\n\n----------------------------------------\n\nTITLE: Swap Status Records\nDESCRIPTION: Illustrates the structure of the swap status region, which stores single-byte records indicating the state of sector swapping. Each sector-state pair is represented by three records to overcome flash hardware limitations. The record values correspond to different states of the sector index during the swap process. A min-write-size of 1 is assumed for simplicity.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n     0                   1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |sec127,state 0 |sec127,state 1 |sec127,state 2 |sec126,state 0 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |sec126,state 1 |sec126,state 2 |sec125,state 0 |sec125,state 1 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    |sec125,state 2 |                                               |\n    +-+-+-+-+-+-+-+-+                                               +\n    ~\n    ~\n    ~\n    ~               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    ~               |sec000,state 0 |sec000,state 1 |sec000,state 2 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\n----------------------------------------\n\nTITLE: Link Libraries\nDESCRIPTION: This snippet links the 'CMSISDSP' library to the 'arm_bayes_example' executable.  The PRIVATE keyword indicates that CMSISDSP is a private dependency, not exposed to other targets that link against 'arm_bayes_example'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_bayes_example/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(arm_bayes_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Link CMSIS-DSP Library\nDESCRIPTION: Links the CMSISDSP library to the 'arm_class_marks_example' executable as a private dependency. This ensures that the necessary DSP functions are available at link time.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(arm_class_marks_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup for Regression Tests\nDESCRIPTION: This snippet sets up the CMake project, defining the minimum required version, the project name, and the source directory. It initializes the regression test cases.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(regression_test LANGUAGES C)\n\nset(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../regression)\n\nset(regression_test_cases\n    ${SOURCE_DIR}/levelx_nand_flash_test.c\n    ${SOURCE_DIR}/levelx_nor_flash_test.c\n    ${SOURCE_DIR}/levelx_nor_flash_test_cache.c)\n```\n\n----------------------------------------\n\nTITLE: Configuring Library and DSP\nDESCRIPTION: This snippet calls the configLib and configDsp functions with the CMSISDSPMatrix target and the ROOT variable. These functions likely perform additional configuration specific to the library and DSP components.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/MatrixFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nconfigLib(CMSISDSPMatrix ${ROOT})\nconfigDsp(CMSISDSPMatrix ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Default Retry Delay Values in C\nDESCRIPTION: This code snippet provides the recommended default values for the minimum retry delay, maximum retry delay, and maximum random jitter when using exponential back-off for retries. These values can be adjusted based on specific network characteristics and application requirements.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/mqtt_state_machine.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nmin_retry_delay_msec =     1000;\nmax_retry_delay_msec =   100000;\nmax_random_jitter_msec =   5000;\n```\n\n----------------------------------------\n\nTITLE: Create Executable and Link Mbed TLS Libraries\nDESCRIPTION: Creates an executable named `cmake_package` and links it against the Mbed TLS libraries (mbedcrypto, mbedtls, and mbedx509).  This allows the executable to use the functionality provided by Mbed TLS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_package/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(cmake_package cmake_package.c)\ntarget_link_libraries(cmake_package\n    MbedTLS::mbedcrypto MbedTLS::mbedtls MbedTLS::mbedx509)\n```\n\n----------------------------------------\n\nTITLE: Defining Image TLV Info Structure\nDESCRIPTION: This defines the structure `image_tlv_info`, which represents the header for the TLV (Type-Length-Value) area. It contains a magic number (`it_magic`) for identification and the total size of the TLV area (`it_tlv_tot`), including the header itself. All fields are in little-endian byte order.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nstruct image_tlv_info {\n    uint16_t it_magic;\n    uint16_t it_tlv_tot;  /* size of TLV area (including tlv_info header) */\n};\n```\n\n----------------------------------------\n\nTITLE: Define input/output buffer structs in C\nDESCRIPTION: Defines two C structs, `psa_crypto_local_input_s` and `psa_crypto_local_output_s`, used to manage local copies of input and output buffers. These structs store a pointer to the buffer and its length, allowing for easier tracking and memory management of copied data within the PSA crypto library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-shared-memory.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\ntypedef struct psa_crypto_local_input_s {\n    uint8_t *buffer;\n    size_t length;\n} psa_crypto_local_input_t;\n\ntypedef struct psa_crypto_local_output_s {\n    uint8_t *original;\n    uint8_t *buffer;\n    size_t length;\n} psa_crypto_local_output_t;\n```\n\n----------------------------------------\n\nTITLE: Comparing a JSON Token to Text in C\nDESCRIPTION: Determines whether the unescaped JSON token value that the #NX_AZURE_IOT_JSON_READER points to is equal to the expected text within the provided buffer bytes by doing a case-sensitive comparison. It requires a pointer to the reader instance, a pointer to the expected text, and the length of the expected text. Returns NX_TRUE if equal, NX_FALSE otherwise.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_token_is_text_equal(NX_AZURE_IOT_JSON_READER *reader_ptr,\n                                                  UCHAR *expected_text_ptr, UINT expected_text_len);\n```\n\n----------------------------------------\n\nTITLE: Setting compiler definitions for FFT tables in CMake\nDESCRIPTION: This snippet conditionally sets the ARM_ALL_FFT_TABLES compiler definition if both CONFIGTABLE and ALLFFT are enabled.  This enables precomputed FFT tables.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif (CONFIGTABLE AND ALLFFT)\ntarget_compile_definitions(CMSISDSPTransform PUBLIC ARM_ALL_FFT_TABLES) \nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Test Utility Library\nDESCRIPTION: This snippet creates a static library named `test_utility` from the utility files, links it with the `azrtos::netxduo` library, includes the test directory, and defines compile definitions for batch testing and CTest. The `test_utility` library provides commonly used test functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/regression/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(test_utility ${test_utility_files})\ntarget_link_libraries(test_utility PUBLIC azrtos::netxduo)\ntarget_include_directories(test_utility PUBLIC ${SOURCE_DIR}/test)\ntarget_compile_definitions(test_utility PUBLIC BATCH_TEST CTEST)\n```\n\n----------------------------------------\n\nTITLE: Including CMocka Test Module\nDESCRIPTION: Includes the AddCMockaTest module, which provides functions for adding CMocka unit tests to the project. This simplifies the process of integrating CMocka tests into the CMake build system.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/core/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(AddCMockaTest)\n```\n\n----------------------------------------\n\nTITLE: Define Target Sources CMake\nDESCRIPTION: This CMake snippet uses target_sources to define the private source files for the project. The actual source files are meant to be placed between the BEGIN_TARGET_SOURCES and END_TARGET_SOURCES comments. Currently, there are no source files specified.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m85/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Auto IP Test Cases\nDESCRIPTION: This snippet defines a list of C source files that make up the Auto IP regression test suite. The file paths are constructed relative to the `SOURCE_DIR` variable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(auto_ip_test_cases\n    ${SOURCE_DIR}/auto_ip_test/netx_auto_ip_address_check_test.c\n    ${SOURCE_DIR}/auto_ip_test/netx_auto_ip_arp_dest_addr_test.c\n    ${SOURCE_DIR}/auto_ip_test/netx_auto_ip_basic_test.c\n    ${SOURCE_DIR}/auto_ip_test/netx_auto_ip_max_conflicts_test.c\n    ${SOURCE_DIR}/auto_ip_test/netx_auto_ip_announce_num_test.c)\n```\n\n----------------------------------------\n\nTITLE: Linking CMSISDSP Library\nDESCRIPTION: This snippet links the CMSISDSP library to the arm_convolution_example executable target as a private dependency.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_convolution_example/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(arm_convolution_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Run Self Test Program\nDESCRIPTION: This command executes a minimal set of self-tests for the Mbed TLS library. It provides a basic verification of the library's functionality without requiring external testing frameworks.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nprograms/test/selftest\n```\n\n----------------------------------------\n\nTITLE: Initializing ECDSA Interruptible Verification Operation in PSA\nDESCRIPTION: Creates and initializes an operation object for interruptible ECDSA signature verification using `psa_verify_hash_interruptible_operation_t`. This object is then used with `psa_verify_hash_start` and `psa_verify_hash_complete` to perform the verification operation in a restartable manner.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_31\n\nLANGUAGE: C\nCODE:\n```\npsa_verify_hash_interruptible_operation_t operation;\nmemset(&operation, 0, sizeof(operation)); /* Or use the INIT macro */\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories with CMake\nDESCRIPTION: This snippet uses the `target_include_directories` command in CMake to add include directories to the project. The `PUBLIC` keyword makes the include directories available to other targets that link against this target. `${CMAKE_CURRENT_LIST_DIR}/inc` specifies a relative path to the 'inc' directory within the current CMake list file's directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/linux/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Define clock_getres Function Prototype in C\nDESCRIPTION: Defines the prototype for the `clock_getres` function, used for retrieving the resolution of a specified clock. It takes a `clockid_t` specifying the clock and a pointer to a `timespec` structure to store the resolution.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nINT                   clock_getres(clockid_t t, struct timespec * tspec)\n```\n\n----------------------------------------\n\nTITLE: Start CLI for Cortex M4, ARM compiler v6 (PowerShell)\nDESCRIPTION: This command opens a CLI environment for examples that match 'Cortex M4' and 'ARM compiler v6' using the -MatchName parameter.  The environment is set appropriately for the matched examples. The pwsh -Command prefix is used for executing this command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_7\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchName 'Cortex M4','ARM compiler v6' -StartCli\n```\n\n----------------------------------------\n\nTITLE: CMake Toolchain File Message\nDESCRIPTION: Prints the path to the CMake toolchain file being used for the build process. This is useful for debugging and verifying the correct toolchain is being utilized.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/libs/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation Options (32/64 bit)\nDESCRIPTION: This snippet conditionally sets compiler and linker options based on the value of the environment variable `ENABLE_64`. If `ENABLE_64` is set, it prints a message indicating a 64-bit build; otherwise, it adds options for a 32-bit build using `-m32` and prints a corresponding message.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/libs/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif($ENV{ENABLE_64})\n  message(STATUS \"Building for 64bit\")\n  set(NX_USER_FILE ${CMAKE_CURRENT_SOURCE_DIR}/nx_user.h)\nelse()\n  add_compile_options(-m32)\n  add_link_options(-m32)\n  message(STATUS \"Building for 32bit\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Get Key Derivation Input Key Function (C)\nDESCRIPTION: This function retrieves the key context of a key derivation input for a given step. It sets `p_key_buffer` to a pointer to the key context and `key_buffer_size` to the size of the context in bytes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_crypto_driver_key_derivation_get_input_key(\n    const psa_crypto_driver_key_derivation_inputs_t *inputs,\n    psa_key_derivation_step_t step,\n    const psa_key_attributes_t *attributes,\n    uint8_t** p_key_buffer, size_t *key_buffer_size);\n```\n\n----------------------------------------\n\nTITLE: HAL Initialization\nDESCRIPTION: The HAL_Init() function is called to reset all peripherals, initialize the Flash interface, and initialize the systick. This is a mandatory step in STM32 HAL based applications to initialize the hardware abstraction layer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples_MIX/SPI/SPI_FullDuplex_ComPolling_Slave/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nHAL_Init();\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: Specifies the minimum required CMake version for the project to be 3.10.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/iot/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files for PID Controllers\nDESCRIPTION: This section adds the source files for different PID (Proportional-Integral-Derivative) controller implementations to the CMSISDSPController library. It includes implementations for floating-point (f32), Q15, and Q31 data types, encompassing initialization and reset functions for each type. The `PRIVATE` keyword signifies these sources are not exposed outside the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ControllerFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPController PRIVATE arm_pid_init_f32.c)\ntarget_sources(CMSISDSPController PRIVATE arm_pid_init_q15.c)\ntarget_sources(CMSISDSPController PRIVATE arm_pid_init_q31.c)\ntarget_sources(CMSISDSPController PRIVATE arm_pid_reset_f32.c)\ntarget_sources(CMSISDSPController PRIVATE arm_pid_reset_q15.c)\ntarget_sources(CMSISDSPController PRIVATE arm_pid_reset_q31.c)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This snippet sets the minimum required CMake version, defines project policies, and initializes a project named 'regression_test' using the C language.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(regression_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Setting Target Include Directories (CMake)\nDESCRIPTION: This snippet sets the target include directories for the project. It adds directories containing header files for various NetXDuo components, allowing the compiler to find the necessary header files during compilation. The include directories are added as PUBLIC, making them available to other targets that depend on this target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/auto_ip\n    ${CMAKE_CURRENT_LIST_DIR}/azure_iot\n    ${CMAKE_CURRENT_LIST_DIR}/BSD\n    ${CMAKE_CURRENT_LIST_DIR}/cloud\n    ${CMAKE_CURRENT_LIST_DIR}/dhcp\n    ${CMAKE_CURRENT_LIST_DIR}/dns\n    ${CMAKE_CURRENT_LIST_DIR}/ftp\n    ${CMAKE_CURRENT_LIST_DIR}/http\n    ${CMAKE_CURRENT_LIST_DIR}/mdns\n    ${CMAKE_CURRENT_LIST_DIR}/mqtt\n    ${CMAKE_CURRENT_LIST_DIR}/nat\n    ${CMAKE_CURRENT_LIST_DIR}/pop3\n    ${CMAKE_CURRENT_LIST_DIR}/ppp\n    ${CMAKE_CURRENT_LIST_DIR}/pppoe\n    ${CMAKE_CURRENT_LIST_DIR}/ptp\n    ${CMAKE_CURRENT_LIST_DIR}/smtp\n    ${CMAKE_CURRENT_LIST_DIR}/snmp\n    ${CMAKE_CURRENT_LIST_DIR}/sntp\n    ${CMAKE_CURRENT_LIST_DIR}/telnet\n    ${CMAKE_CURRENT_LIST_DIR}/tftp\n    ${CMAKE_CURRENT_LIST_DIR}/web\n    ${CMAKE_CURRENT_LIST_DIR}/websocket\n    ${CMAKE_CURRENT_LIST_DIR}/rtp\n    ${CMAKE_CURRENT_LIST_DIR}/rtsp\n)\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration for ThreadX Heap\nDESCRIPTION: This snippet demonstrates how to configure the linker file in EWARM to allocate a memory region for the ThreadX heap.  It places the FREE_MEM section in the RAM region, allowing ThreadX to use dynamic memory allocation. This configuration is necessary when using dynamic memory allocation within the ThreadX environment.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_HID_CDC_ACM/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Setting SWAR Test Cases Variable in CMake\nDESCRIPTION: This snippet defines a CMake variable, `ux_class_swar_test_cases`, and assigns it a single source file related to SWAR tests. This C file tests the USBX SWAR host class.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_swar_test_cases\n  ${SOURCE_DIR}/usbx_uxe_host_swar_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: Build Examples matching TXM, IAR, Cortex M (PowerShell)\nDESCRIPTION: This command builds all examples matching all the keywords 'TXM', 'IAR', and 'Cortex M'. These examples are likely related to ThreadX Modules (TXM) for Cortex M using the IAR compiler. The pwsh -Command prefix ensures execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_15\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TXM','IAR','Cortex M' -build\n```\n\n----------------------------------------\n\nTITLE: Defining markupsafe Dependency with Version Constraint\nDESCRIPTION: This line defines a dependency on the `markupsafe` package, specifying that the version must be less than 2.1. This is to address compatibility issues between older versions of Jinja2 and newer versions of markupsafe.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/scripts/driver.requirements.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nmarkupsafe < 2.1\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration\nDESCRIPTION: This snippet shows the required modification in the MDK-ARM scatter file (.sct) or tx_low_level_initilize.S file to define the memory region for dynamic memory allocation in ThreadX. It either defines the RW_IRAM1 region in the .sct file or modifies the provided line in the .S file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_Dual_Instance/README.md#_snippet_2\n\nLANGUAGE: Assembly\nCODE:\n```\nLDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Zeroization Testing with GDB Debugger Script\nDESCRIPTION: This snippet refers to a GDB debugger script used to test memory zeroization. The script, located at `tests/scripts/test_zeroize.gdb`, verifies that the `mbedtls_platform_zeroize` function properly wipes the memory buffer. This approach is chosen because adding C code to observe the zeroization could prevent the compiler from optimizing it away, negating the test.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/testing/invasive-testing.md#_snippet_2\n\nLANGUAGE: GDB\nCODE:\n```\ntests/scripts/test_zeroize.gdb\n```\n\n----------------------------------------\n\nTITLE: Setting general compile options CMake\nDESCRIPTION: This snippet adds general compile options for the project. These options include setting the C standard to C99, enabling debugging information (`-ggdb`, `-g3`, `-gdwarf-2`), enabling colored diagnostics, including a user-defined header file, and using the compile type specified by the `CMAKE_BUILD_TYPE` variable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nadd_compile_options(\n  -std=c99\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  # -Werror\n  -DTX_INCLUDE_USER_DEFINE_FILE\n  ${${CMAKE_BUILD_TYPE}})\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files for Protocol Handlers (CMake)\nDESCRIPTION: This snippet sets the source files for various NetXDuo protocol handlers. Each file corresponds to a specific protocol such as DHCP, DNS, FTP, HTTP, MQTT, and others. The files are located in their respective subdirectories within the CMAKE_CURRENT_LIST_DIR.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES \n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/auto_ip/nx_auto_ip.c\n\t${CMAKE_CURRENT_LIST_DIR}/cloud/nx_cloud.c\n\t${CMAKE_CURRENT_LIST_DIR}/dhcp/nxd_dhcp_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/dhcp/nxd_dhcp_server.c\n\t${CMAKE_CURRENT_LIST_DIR}/dhcp/nxd_dhcpv6_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/dhcp/nxd_dhcpv6_server.c\n\t${CMAKE_CURRENT_LIST_DIR}/dns/nxd_dns.c\n\t${CMAKE_CURRENT_LIST_DIR}/ftp/nxd_ftp_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/ftp/nxd_ftp_server.c\n\t${CMAKE_CURRENT_LIST_DIR}/http/nxd_http_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/http/nxd_http_server.c\n\t${CMAKE_CURRENT_LIST_DIR}/mdns/nxd_mdns.c\n\t${CMAKE_CURRENT_LIST_DIR}/mqtt/nxd_mqtt_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/nat/nx_nat.c\n\t${CMAKE_CURRENT_LIST_DIR}/pop3/nxd_pop3_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/ppp/nx_ppp.c\n\t${CMAKE_CURRENT_LIST_DIR}/pppoe/nx_pppoe_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/pppoe/nx_pppoe_server.c\n\t${CMAKE_CURRENT_LIST_DIR}/ptp/nxd_ptp_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/smtp/nxd_smtp_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/snmp/nx_des.c\n\t${CMAKE_CURRENT_LIST_DIR}/snmp/nx_sha1.c\n\t${CMAKE_CURRENT_LIST_DIR}/snmp/nxd_snmp.c\n\t${CMAKE_CURRENT_LIST_DIR}/sntp/nxd_sntp_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/telnet/nxd_telnet_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/telnet/nxd_telnet_server.c\n\t${CMAKE_CURRENT_LIST_DIR}/tftp/nxd_tftp_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/tftp/nxd_tftp_server.c\n\t${CMAKE_CURRENT_LIST_DIR}/web/nx_tcpserver.c\n\t${CMAKE_CURRENT_LIST_DIR}/web/nx_web_http_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/web/nx_web_http_server.c\n\t${CMAKE_CURRENT_LIST_DIR}/websocket/nx_websocket_client.c\n    ${CMAKE_CURRENT_LIST_DIR}/rtp/nx_rtp_sender.c\n    ${CMAKE_CURRENT_LIST_DIR}/rtsp/nx_rtsp_server.c\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Test Include Directories\nDESCRIPTION: Sets the include directories for internal test headers within the `az_core` library. This ensures that tests can access necessary internal headers during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/core/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(az_core\n  PUBLIC\n    $<BUILD_INTERFACE:${az_SOURCE_DIR}/sdk/tests/core/inc>\n)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup for Azure IoT Common Tests\nDESCRIPTION: This snippet configures the CMake project for running tests against the `az_iot_common` library. It sets the minimum CMake version, project name, C standard, includes dependencies, and defines the test executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/common/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.10)\n\nproject (az_iot_common_test LANGUAGES C)\n\nset(CMAKE_C_STANDARD 99)\n\ninclude(AddCMockaTest)\n\nadd_cmocka_test(az_iot_common_test SOURCES\n                main.c\n                test_az_iot_common.c\n                COMPILE_OPTIONS ${DEFAULT_C_COMPILE_FLAGS} ${NO_CLOBBERED_WARNING}\n                LINK_LIBRARIES ${CMOCKA_LIB}\n                    az_iot_common\n                    az_core\n                INCLUDE_DIRECTORIES ${CMOCKA_INCLUDE_DIR}\n                )\n\ncreate_map_file(az_iot_common_test az_iot_common_test.map)\n\nadd_cmocka_test_environment(az_iot_common_test)\n```\n\n----------------------------------------\n\nTITLE: Enabling Nested FIQ Interrupts in ThreadX Assembly\nDESCRIPTION: This code snippet shows how to enable nested FIQ interrupts in a typical FIQ handler. It calls `_tx_thread_fiq_nesting_start` to enable nesting (switching to SYS mode and enabling FIQ interrupts) and `_tx_thread_fiq_nesting_end` to disable nesting (switching back to FIQ mode and disabling FIQ interrupts). This requires building the library with `TX_ENABLE_FIQ_NESTING` defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/cortex_a7_smp/ac5/readme_threadx.txt#_snippet_4\n\nLANGUAGE: assembly\nCODE:\n```\nEXPORT  __tx_fiq_handler\nEXPORT  __tx_fiq_processing_return\n__tx_fiq_handler\n;\n;    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return\n;\n;    /* At this point execution is still in the FIQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use.  */\n;\n;    /* Enable nested FIQ interrupts. NOTE:  Since this service returns\n;       with FIQ interrupts enabled, all FIQ interrupt sources must be \n;       cleared prior to calling this service.  */\n    BL      _tx_thread_fiq_nesting_start\n;\n;    /* Application FIQ handlers can be called here!  */\n;\n;    /* Disable nested FIQ interrupts. The mode is switched back to\n;       FIQ mode and FIQ interrupts are disable upon return.  */\n    BL      _tx_thread_fiq_nesting_end\n;\n;    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: Provisioner Application ID Parameter\nDESCRIPTION: Optional Application ID of the Azure Active Directory service principal to use for provisioning test resources. If not specified, the script uses the caller's context for provisioning.  Specifying a provisioner application ID requires specific Microsoft Graph API permissions for AAD interaction.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nType: String\nParameter Sets: Provisioner\nAliases:\n\nRequired: True\nPosition: Named\nDefault value: None\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Configure Target Sources CMake\nDESCRIPTION: This snippet uses CMake's `target_sources` command to configure the source files for the specified project. It uses a PRIVATE scope. The `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` placeholders indicate where source file paths should be added.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/ports/cortex_m0/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Disabling VFP Support for a Thread in C\nDESCRIPTION: This C code snippet disables VFP (Vector Floating Point) support for the calling thread. After this call, VFP registers will no longer be saved or restored for the thread.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac6/readme_threadx.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nvoid    tx_thread_vfp_disable(void);\n```\n\n----------------------------------------\n\nTITLE: Cloning and Installing VCPKG on Windows\nDESCRIPTION: This snippet clones the vcpkg repository, checks out a specific commit, and installs required packages (curl with winssl, cmocka, and paho-mqtt) using the vcpkg package manager for a Windows x64 target. The triplet should be updated per your system. The vcpkg commit should be specified as indicated in the document.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\ngit checkout <vcpkg commit> # Checkout the vcpkg commit per vcpkg-commit.txt above.\n.\\bootstrap-vcpkg.bat\n.\\vcpkg.exe install --triplet x64-windows-static curl[winssl] cmocka paho-mqtt # Update triplet per your system.\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation: Multihome Samples\nDESCRIPTION: This snippet conditionally adds multihome TCP and UDP sample files (`demo_netx_duo_multihome_tcp.c` and `demo_netx_duo_multihome_udp.c`) to the `sample_files` list if the `-DNX_MAX_PHYSICAL_INTERFACES` flag is in the `CMAKE_BUILD_TYPE`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/samples/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"-DNX_MAX_PHYSICAL_INTERFACES\" IN_LIST ${CMAKE_BUILD_TYPE})\n  list(APPEND sample_files ${SOURCE_DIR}/demo_netx_duo_multihome_tcp.c\n       ${SOURCE_DIR}/demo_netx_duo_multihome_udp.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Project Definition\nDESCRIPTION: Defines the project name and specifies the programming languages used in the project (in this case, C). This is a fundamental step in any CMake project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nproject(threadx_smp_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Target Sources (Float16 Support)\nDESCRIPTION: Conditionally adds source files for float16 filtering algorithms (FIR, Biquad, Correlation, Levinson-Durbin) to the CMSISDSPFiltering library if ARMAC5 is false and DISABLEFLOAT16 is false. This allows the library to utilize the half-precision floating-point format when it's supported and not explicitly disabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_f16.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_init_f16.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_f16.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_init_f16.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df2T_f16.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df2T_init_f16.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_stereo_df2T_f16.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_stereo_df2T_init_f16.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_f16.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_levinson_durbin_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Build Configurations with CMake\nDESCRIPTION: This snippet defines different build configurations (e.g., default_build_coverage, error_check_build_full_coverage) and sets the CMAKE_CONFIGURATION_TYPES variable, which specifies the supported build types. It also handles the case where CMAKE_BUILD_TYPE is not set or invalid.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Set build configurations\n# TODO: add when available : standalone_otg_build\nset(BUILD_CONFIGURATIONS \n  default_build_coverage \n  error_check_build_full_coverage \n  tracex_enable_build \n  device_buffer_owner_build \n  device_zero_copy_build\n  nofx_build_coverage \n  optimized_build \n  standalone_device_build_coverage \n  standalone_device_buffer_owner_build \n  standalone_device_zero_copy_build\n  standalone_host_build_coverage \n  standalone_build_coverage \n  generic_build \n  otg_support_build\n  memory_management_build_coverage\n  msrc_rtos_build\n  msrc_standalone_build\n  )\n\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n\nmessage(STATUS \"Build for usbx\")\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: Setting SRAM Fill Patterns\nDESCRIPTION: This snippet configures the fill patterns for internal SRAM modules (iotss_internal_sram0, iotss_internal_sram1, iotss_internal_sram2, iotss_internal_sram3) within the FVP MPS2 simulator. The `fill1` and `fill2` parameters define the alternating patterns used to initialize the memory at the start of the simulation. This helps in detecting uninitialized memory issues during simulation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_module/cortex_m23/ac6/example_build/ARMCM23_TZ_config.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nfvp_mps2.sse200.iotss_internal_sram0.fill1=0xDFDFDFCF\nfvp_mps2.sse200.iotss_internal_sram0.fill2=0xCFDFDFDF\nfvp_mps2.sse200.iotss_internal_sram1.fill1=0xDFDFDFCF\nfvp_mps2.sse200.iotss_internal_sram1.fill2=0xCFDFDFDF\nfvp_mps2.sse200.iotss_internal_sram2.fill1=0xDFDFDFCF\nfvp_mps2.sse200.iotss_internal_sram2.fill2=0xCFDFDFDF\nfvp_mps2.sse200.iotss_internal_sram3.fill1=0xDFDFDFCF\nfvp_mps2.sse200.iotss_internal_sram3.fill2=0xCFDFDFDF\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files to CMake Target (STM32CubeH5)\nDESCRIPTION: This CMake snippet adds a list of source files (both C and Assembly) to the specified target. The source files are related to thread management, interrupt control, secure stack handling and other low-level functionalities. The source files are located in the 'src' directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/ac6/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_allocate.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_free.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_low_level.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_allocate.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_free.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n)\n```\n\n----------------------------------------\n\nTITLE: Function to Determine PSA Hash Support at Runtime\nDESCRIPTION: The `psa_can_do_hash` function is a private function that determines whether a given hash algorithm (`hash_alg`) can be performed through PSA crypto at runtime. It returns 1 if PSA crypto support is available and initialized, and 0 otherwise. This is crucial for deciding whether to dispatch hash operations to PSA crypto for hardware acceleration. It is only defined on algorithms that are enabled via PSA.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-migration/md-cipher-dispatch.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nint psa_can_do_hash(psa_algorithm_t hash_alg);\n```\n\n----------------------------------------\n\nTITLE: Setting GSER Test Cases Variable in CMake\nDESCRIPTION: This snippet defines a CMake variable, `ux_class_gser_test_cases`, and assigns it a single source file related to GSER tests. This file is a C file used for testing the USBX GSER host class.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_gser_test_cases\n  ${SOURCE_DIR}/usbx_uxe_host_gser_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: Adding CFFT Radix4 Init Q15 source files in CMake\nDESCRIPTION: This snippet conditionally adds arm_cfft_radix4_init_q15.c as a private source files to the CMSISDSPTransform library if WRAPPER is defined or ARM_CFFT_RADIX4_Q15 is defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_22\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE  OR ALLFFT OR ARM_CFFT_RADIX4_Q15)\n  target_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_init_q15.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: Specifies the minimum required CMake version and sets CMake policies for compatibility.  This ensures that the CMake scripts are executed with a compatible version of CMake and behave as expected.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\n```\n\n----------------------------------------\n\nTITLE: Setting Libraries for Mbed TLS\nDESCRIPTION: This snippet sets the necessary libraries for the Mbed TLS target, including thread libraries. The `mbedtls_target` variable is assumed to be defined elsewhere in the CMake configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/tests/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(libs\n    ${mbedtls_target}\n    ${CMAKE_THREAD_LIBS_INIT}\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Include Directories with CMake\nDESCRIPTION: This CMake code configures the target include directories for the project. It uses the `target_include_directories` command to add the `inc` directory to the project's public include paths, allowing header files in that directory to be included in the project's source files. `${CMAKE_CURRENT_LIST_DIR}` represents the directory of the current CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/crypto_libraries/ports/cortex_m7/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Creating TAHI Library CMake\nDESCRIPTION: This code snippet conditionally creates an imported shared library named `tahi`. The location of the library is set based on the `ENABLE_64` environment variable. Finally, it links the `test_utility` library with the `tahi` library if it exists.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_38\n\nLANGUAGE: cmake\nCODE:\n```\nif(\"-DNX_TAHI_ENABLE\" IN_LIST ${CMAKE_BUILD_TYPE})\n  add_library(tahi SHARED IMPORTED)\n  if($ENV{ENABLE_64})\n    set_target_properties(tahi PROPERTIES IMPORTED_LOCATION\n                                          ${SOURCE_DIR}/tahi_test/tahi64.so)\n  else()\n    set_target_properties(tahi PROPERTIES IMPORTED_LOCATION\n                                          ${SOURCE_DIR}/tahi_test/tahi.so)\n  endif()\n  target_link_libraries(test_utility PUBLIC tahi)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Compile Options for Different Build Types\nDESCRIPTION: This snippet defines sets of compile options for different build configurations. Each configuration includes a set of preprocessor definitions (e.g., -DNX_PHYSICAL_HEADER, -DUX_DISABLE_ASSERT) to enable or disable specific features and functionalities.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(default_build_coverage\n  -DNX_PHYSICAL_HEADER=20\n#  -DUX_SLAVE_REQUEST_CONTROL_MAX_LENGTH=512\n#  -DUX_DEVICE_BIDIRECTIONAL_ENDPOINT_SUPPORT\n#  -DUX_HOST_DEVICE_CLASS_CODE_VALIDATION_ENABLE\n# -DUX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT\n# -DUX_HOST_CLASS_HID_INTERRUPT_OUT_SUPPORT\n  -DUX_DISABLE_ASSERT\n##############################################FeedBack Test Start\n#  -DUX_DEVICE_CLASS_AUDIO_FEEDBACK_SUPPORT\n#  -DUX_MAX_DEVICE_ENDPOINTS=6\n#  -DUX_DEVICE_BIDIRECTIONAL_ENDPOINT_SUPPORT\n#  -DUX_SLAVE_REQUEST_CONTROL_MAX_LENGTH=512\n##############################################FeedBack Test end\n  # -DUX_HOST_CLASS_AUDIO_2_SUPPORT\n  # -DUX_HOST_CLASS_AUDIO_FEEDBACK_SUPPORT\n  # -DUX_HOST_CLASS_AUDIO_DISABLE_CONTROLS\n  # -DUX_HOST_CLASS_AUDIO_INTERRUPT_SUPPORT\n  # -DUX_DEVICE_CLASS_PRINTER_WRITE_AUTO_ZLP\n  # -DUX_DEVICE_CLASS_CDC_ACM_WRITE_AUTO_ZLP\n  # -DUX_DEVICE_CLASS_AUDIO_INTERRUPT_SUPPORT\n  -DUX_HOST_STACK_CONFIGURATION_INSTANCE_CREATE_CONTROL=0\n  -DUX_DEVICE_ENABLE_GET_STRING_WITH_ZERO_LANGUAGE_ID\n)\n\nset(error_check_build_full_coverage\n  ${default_build_coverage}\n  -DUX_ENABLE_ASSERT\n  -DUX_ENABLE_ERROR_CHECKING\n  -DUX_PIMA_WITH_MTP_SUPPORT\n)\n\nset(msrc_rtos_build\n  ${error_check_build_full_coverage}\n  -DUX_SLAVE_REQUEST_CONTROL_MAX_LENGTH=512\n  -DUX_HOST_CLASS_AUDIO_2_SUPPORT\n  -DUX_HOST_CLASS_AUDIO_INTERRUPT_SUPPORT\n)\nset(msrc_standalone_build\n  ${msrc_rtos_build}\n  -DUX_STANDALONE\n)\n\nset(tracex_enable_build\n  -DNX_PHYSICAL_HEADER=20\n  -DTX_ENABLE_EVENT_TRACE\n  -DUX_TRACE_INSERT_MACROS\n)\n\nset(device_buffer_owner_build\n  -DNX_PHYSICAL_HEADER=20\n# -DUX_ENABLE_ASSERT\n  -DTX_ENABLE_EVENT_TRACE\n  -DUX_TRACE_INSERT_MACROS\n  -DUX_SLAVE_REQUEST_CONTROL_MAX_LENGTH=512\n  -DUX_DEVICE_ENDPOINT_BUFFER_OWNER=1\n  # -DUX_DEVICE_CLASS_CDC_ACM_TRANSMISSION_DISABLE\n  -DUX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT\n  -DUX_DEVICE_CLASS_AUDIO_FEEDBACK_SUPPORT\n  -DUX_DEVICE_CLASS_AUDIO_INTERRUPT_SUPPORT\n)\nset(device_zero_copy_build\n  ${device_buffer_owner_build}\n  -DUX_DEVICE_CLASS_CDC_ACM_ZERO_COPY\n  -DUX_DEVICE_CLASS_CDC_ACM_WRITE_AUTO_ZLP\n  -DUX_DEVICE_CLASS_HID_ZERO_COPY\n  -DUX_DEVICE_CLASS_CDC_ECM_ZERO_COPY\n  -DUX_DEVICE_CLASS_RNDIS_ZERO_COPY\n  -DUX_DEVICE_CLASS_PRINTER_ZERO_COPY\n)\n\nset(nofx_build_coverage\n  -DNX_PHYSICAL_HEADER=20\n  -DUX_HOST_CLASS_STORAGE_NO_FILEX\n)\nset(standalone_build_coverage\n  -DNX_PHYSICAL_HEADER=20\n  -DUX_STANDALONE\n  # -DTX_ENABLE_EVENT_TRACE\n)\nset(standalone_device_build_coverage\n  -DUX_DEVICE_STANDALONE\n  # -DUX_DEVICE_CLASS_HID_INTERRUPT_OUT_SUPPORT\n  -DUX_SLAVE_REQUEST_CONTROL_MAX_LENGTH=512\n##############################################FeedBack Test Start\n#  -DUX_DEVICE_CLASS_AUDIO_FEEDBACK_SUPPORT\n#  -DUX_MAX_DEVICE_ENDPOINTS=6\n#  -DUX_DEVICE_BIDIRECTIONAL_ENDPOINT_SUPPORT\n##############################################FeedBack Test End\n#  -DUX_DEVICE_CLASS_AUDIO_INTERRUPT_SUPPORT\n  -DUX_ENABLE_ERROR_CHECKING\n)\nset(standalone_device_buffer_owner_build\n  ${device_buffer_owner_build}\n  ${standalone_device_build_coverage}\n)\nset(standalone_device_zero_copy_build\n  ${device_zero_copy_build}\n  ${standalone_device_build_coverage}\n)\nset(standalone_host_build_coverage\n  -DUX_HOST_STANDALONE\n  # -DUX_HOST_CLASS_HID_INTERRUPT_OUT_SUPPORT\n  -DUX_ENABLE_ERROR_CHECKING\n)\nset(standalone_otg_build\n  -DUX_OTG_STANDALONE\n)\nset(optimized_build\n  -DNX_PHYSICAL_HEADER=20\n  -DUX_NAME_REFERENCED_BY_POINTER\n  -DUX_MAX_HCD=1\n  -DUX_MAX_ISO_TD=0\n  -DUX_MAX_TD=20\n  -DUX_MAX_CLASS_DRIVER=1\n  -DUX_MAX_DEVICES=1\n  -DUX_HOST_CLASS_STORAGE_MEMORY_BUFFER_SIZE=512\n  -DUX_HOST_CLASS_STORAGE_MAX_TRANSFER_SIZE=512\n  -DUX_HOST_CLASS_STORAGE_MAX_MEDIA=1\n  -DUX_DEVICE_INITIALIZE_FRAMEWORK_SCAN_DISABLE\n  -DUX_MAX_DEVICE_ENDPOINTS=2\n  -DUX_MAX_DEVICE_INTERFACES=1\n  -DUX_MAX_SLAVE_INTERFACES=1\n  -DUX_MAX_SLAVE_CLASS_DRIVER=1\n  -DUX_MAX_SLAVE_LUN=1\n  -DUX_SLAVE_REQUEST_DATA_MAX_LENGTH=512\n  -DUX_DEVICE_ALTERNATE_SETTING_SUPPORT_DISABLE\n)\nset(generic_build\n  -DUX_HCD_EHCI_SPLIT_TRANSFER_ENABLE\n  -DUX_HOST_CLASS_STORAGE_INCLUDE_LEGACY_PROTOCOL_SUPPORT\n  -DUX_SLAVE_CLASS_STORAGE_INCLUDE_MMC\n  ############################################## warning check: CDC ACM\n  -DUX_DEVICE_CLASS_CDC_ACM_TRANSMISSION_DISABLE\n  ############################################## warning check: DFU\n  # -DUX_DEVICE_CLASS_DFU_UPLOAD_DISABLE\n  # -DUX_DEVICE_CLASS_DFU_ERROR_GET_ENABLE\n  -DUX_DEVICE_CLASS_DFU_STATUS_MODE=1 #0/1\n  -DUX_DEVICE_CLASS_DFU_STATUS_POLLTIMEOUT=0\n  # -DUX_DEVICE_CLASS_DFU_CUSTOM_REQUEST_ENABLE\n  -DUX_HOST_STACK_CONFIGURATION_INSTANCE_CREATE_CONTROL=1\n)\nset(otg_support_build\n  -DNX_PHYSICAL_HEADER=20\n  -DUX_OTG_SUPPORT=\n)\nset(memory_management_build_coverage\n  ${default_build_coverage}\n  -DUX_ENFORCE_SAFE_ALIGNMENT\n  -DUX_ENABLE_MEMORY_STATISTICS\n  -DUX_ENABLE_MEMORY_POOL_SANITY_CHECK\n)\n```\n\n----------------------------------------\n\nTITLE: Setting IoT Provisioning SAS Environment Variables - Linux\nDESCRIPTION: This code snippet shows how to set the AZ_IOT_PROVISIONING_SAS_REGISTRATION_ID, AZ_IOT_PROVISIONING_SAS_KEY, and AZ_IOT_PROVISIONING_ID_SCOPE environment variables in a Linux environment for DPS SAS authentication. Replace `<sas-registration-id>`, `<sas-key>`, and `<id-scope>` with values from your Azure IoT Hub Device Provisioning Service.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nexport AZ_IOT_PROVISIONING_SAS_REGISTRATION_ID=<sas-registration-id>\nexport AZ_IOT_PROVISIONING_SAS_KEY=<sas-key>\nexport AZ_IOT_PROVISIONING_ID_SCOPE=<id-scope>\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation of F16 Support Code\nDESCRIPTION: This snippet conditionally adds source files for float16 support to the `CMSISDSPSupport` library, only if `ARMAC5` is not defined and `DISABLEFLOAT16` is not defined. It utilizes the `target_sources` command to add specific C source files as private sources to the library. These source files likely contain optimized routines for float16 data types.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/SupportFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPSupport PRIVATE arm_copy_f16.c)\ntarget_sources(CMSISDSPSupport PRIVATE arm_fill_f16.c)\ntarget_sources(CMSISDSPSupport PRIVATE arm_f16_to_q15.c)\ntarget_sources(CMSISDSPSupport PRIVATE arm_q15_to_f16.c)\ntarget_sources(CMSISDSPSupport PRIVATE arm_float_to_f16.c)\ntarget_sources(CMSISDSPSupport PRIVATE arm_f16_to_float.c)\ntarget_sources(CMSISDSPSupport PRIVATE arm_weighted_sum_f16.c)\ntarget_sources(CMSISDSPSupport PRIVATE arm_barycenter_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Print Build Information\nDESCRIPTION: Prints build-related information to the console, including the product name, build type, and toolchain file used. The `message(STATUS ...)` commands output the specified strings to the console during the CMake configuration process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nmessage(STATUS \"Build for ${PRODUCT}\")\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Include Directory\nDESCRIPTION: Sets up a custom include directory where generated or copied include files are placed. The CUSTOM_INC_DIR variable points to a directory within the build directory.  The directory is ${CMAKE_CURRENT_BINARY_DIR}/custom_inc.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(CUSTOM_INC_DIR ${CMAKE_CURRENT_BINARY_DIR}/custom_inc)\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This snippet configures the target sources for the project using the `target_sources` CMake command. It specifies the private source files that are part of the project build process. The placeholder comments indicate where the actual source file list would be inserted.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/ports/cortex_m4/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Building Libraries with Shell Script\nDESCRIPTION: This snippet executes a shell script to build ThreadX and FileX libraries. It defines a custom target 'build_libs' that runs the script, and adds a dependency to the 'netxduo' target to ensure the libraries are built before NetXDuo. It also sets up include directories and imports pre-built libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/ptp/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh build_libs)\nadd_custom_target(build_libs ALL COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh\n                                         build_libs)\nadd_dependencies(netxduo build_libs)\ntarget_include_directories(netxduo PUBLIC ${CMAKE_BINARY_DIR}/../libs/inc)\nadd_library(threadx SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::threadx\" ALIAS threadx)\nset_target_properties(\n  threadx PROPERTIES IMPORTED_LOCATION\n                     ${CMAKE_BINARY_DIR}/../libs/threadx/libthreadx.so)\nadd_library(filex SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::filex\" ALIAS filex)\nset_target_properties(\n  filex PROPERTIES IMPORTED_LOCATION\n                   ${CMAKE_BINARY_DIR}/../libs/filex/libfilex.so)\ntarget_link_libraries(netxduo PUBLIC filex)\n```\n\n----------------------------------------\n\nTITLE: Conditional Compile Definitions for Fast Tables\nDESCRIPTION: Conditionally adds the ARM_ALL_FAST_TABLES compile definition if both CONFIGTABLE and ALLFAST are true. This enables the inclusion of all fast tables during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif (CONFIGTABLE AND ALLFAST)\n    target_compile_definitions(CMSISDSPCommon PUBLIC ARM_ALL_FAST_TABLES) \nendif()\n```\n\n----------------------------------------\n\nTITLE: Define USE_VCP_CONNECTION in main.h\nDESCRIPTION: This code snippet explains how to enable the Virtual Com Port (VCP) feature of STLINK for communication between the NUCLEO-H563ZI board and a PC. To use the VCP feature, the `USE_VCP_CONNECTION` define must be set to 1 in the `main.h` file.  Also, the USART communication between the target MCU and ST-LINK MCU needs to be enabled on the HW board.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples/I2C/I2C_TwoBoards_RestartAdvComIT/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nUser has to set USE_VCP_CONNECTION define to 1 in main.h file.\n```\n\n----------------------------------------\n\nTITLE: Append Double Azure IoT JSON Writer C\nDESCRIPTION: Appends a double-precision floating-point number to the JSON payload with a specified number of fractional digits. The function needs a pointer to the JSON writer, the double value, and the number of fractional digits to include. Returns NX_AZURE_IOT_SUCCESS on success.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_25\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_double(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr,\n                                            double value, int32_t fractional_digits);\n```\n\n----------------------------------------\n\nTITLE: Defining a Category 2 ISR body in C\nDESCRIPTION: This code defines a category 2 Interrupt Service Routine (ISR) body using the standard ISR() macro.  It involves declaring an ISRType and defining the ISR body which will contain the interrupt handling logic. The ISR needs to be created during system initialization.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nISRType DemoISR; /* ISR declaration. */\n\n/* ISR body definition. */\nISR(DemoISR)\n{\n    /* ISR body. */\n}\n```\n\n----------------------------------------\n\nTITLE: Add Static Library\nDESCRIPTION: Adds a static library named CMSISDSPFiltering to the project. This creates a static library that can be linked against other projects or applications.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(CMSISDSPFiltering STATIC)\n```\n\n----------------------------------------\n\nTITLE: Adding Distance Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the DistanceFunctions subdirectory and links the CMSISDSPDistance library to the CMSISDSP interface library if the DISTANCE flag is set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_38\n\nLANGUAGE: cmake\nCODE:\n```\nif (DISTANCE)\n  add_subdirectory(DistanceFunctions)\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPDistance)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building ThreadX Library using Make\nDESCRIPTION: This command builds the ThreadX core library. It compiles the ThreadX runtime environment and creates the tx.a library file in the example_build directory. This library must be linked with the application to use ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/linux/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\nmake tx.a\n```\n\n----------------------------------------\n\nTITLE: Setting IoT Hub X.509 Environment Variables - Linux\nDESCRIPTION: This code snippet shows how to set the AZ_IOT_HUB_DEVICE_ID and AZ_IOT_HUB_HOSTNAME environment variables in a Linux environment.  These variables are required for IoT Hub X.509 Certificate samples. Replace `<device-id>` and `<hostname>` with the corresponding values from your Azure IoT Hub.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nexport AZ_IOT_HUB_DEVICE_ID=<device-id>\nexport AZ_IOT_HUB_HOSTNAME=<hostname>\n```\n\n----------------------------------------\n\nTITLE: ISR in C for ThreadX on Cortex-M\nDESCRIPTION: This C code snippet demonstrates the structure of an Interrupt Service Routine (ISR) for ThreadX on Cortex-M processors. The ISR should include all necessary processing and function calls within its body. The ISR is defined as a void function with no arguments, and it is expected to be present in the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/ac5/readme_threadx.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Trigonometric Function Options in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable trigonometric functions (cos, sin, sin_cos) with different data types (f32, q31, q15). These options are used to customize the CMSIS-DSP library by selecting specific trigonometric function implementations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\noption(ARM_COS_F32          \"cos f32\"                           OFF)\noption(ARM_COS_Q31          \"cos q31\"                           OFF)\noption(ARM_COS_Q15          \"cos q15\"                           OFF)\noption(ARM_SIN_F32          \"sin f32\"                           OFF)\noption(ARM_SIN_Q31          \"sin q31\"                           OFF)\noption(ARM_SIN_Q15          \"sin q15\"                           OFF)\noption(ARM_SIN_COS_F32      \"sin cos f32\"                       OFF)\noption(ARM_SIN_COS_Q31      \"sin cos q31\"                       OFF)\n```\n\n----------------------------------------\n\nTITLE: Update-TestResources.ps1 Syntax - Default Parameter Set - PowerShell\nDESCRIPTION: Shows the syntax for using Update-TestResources.ps1 with the Default parameter set.  This allows you to specify the service directory and update the resource group name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/Update-TestResources.ps1.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nUpdate-TestResources.ps1 [-ServiceDirectory] <String> [-BaseName <String>] [-SubscriptionId <String>]\n [-DeleteAfterHours <Int32>] [<CommonParameters>]\n```\n\n----------------------------------------\n\nTITLE: Target-Specific Compile Options\nDESCRIPTION: Sets compile options specifically for the `threadx_smp` target.  These options include various warning flags, code style options, and flags for function and data section placement.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_compile_options(\n  threadx_smp\n  PRIVATE # -Werror\n          -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          # -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal)\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Modification for ThreadX Heap\nDESCRIPTION: This snippet shows the required linker modification for IAR Embedded Workbench (EWARM) to define the memory region for the ThreadX heap. It places the `FREE_MEM` section in the `RAM_region`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ThreadX/Tx_MPU/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Registering Device with Azure IoT Provisioning in C\nDESCRIPTION: Registers the device with the Azure IoT Provisioning service. It requires a pointer to the provisioning client and a wait option specifying the number of ticks to block. The function returns a status code indicating success, pending, or failure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_provisioning_client.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_provisioning_client_register(NX_AZURE_IOT_PROVISIONING_CLIENT *prov_client_ptr, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Include Configuration Files\nDESCRIPTION: Includes configuration files named configLib and configDsp. These files likely contain common configuration settings for libraries and DSP components.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: Linking libraries\nDESCRIPTION: This snippet links the 'arm_signal_convergence_example' executable with the 'CMSISDSP' library as a private dependency.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(arm_signal_convergence_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Linker Configuration for STM32CubeIDE\nDESCRIPTION: This code snippet demonstrates the necessary linker configuration for STM32CubeIDE to provide memory for ThreadX. It defines a new section named ._threadx_heap within the RAM_D1 memory region, allocating 64KB for the ThreadX heap. The ._threadx_heap must be located between the .bss and the ._user_heap_stack sections in the linker script.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/USBPD/USBPD_SNK_UX_Device_HID/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories with CMake\nDESCRIPTION: This CMake code block adds an include directory to the specified target (${PROJECT_NAME}). The include directory contains header files necessary for compiling the source code. The PUBLIC keyword indicates that this include directory will be available to other projects that depend on this target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Generating tx_initialize_low_level.c with bash\nDESCRIPTION: This snippet uses `add_custom_command` to generate the `tx_initialize_low_level.c` file using a bash script `generate_test_file.sh`. It executes the script during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/regression/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${SOURCE_DIR}/tx_initialize_low_level.c\n  COMMAND bash ${CMAKE_CURRENT_LIST_DIR}/generate_test_file.sh\n  COMMENT \"Generating tx_initialize_low_level.c for test\")\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies for ROT_AppliConfig\nDESCRIPTION: This code snippet shows how to install the necessary Python modules for the ROT_AppliConfig tool using pip. These modules are required if the user chooses to switch from the default Windows executable version of ROT_AppliConfig to the Python version. The command reads the requirements.txt file and installs all listed dependencies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Templates/ROT/STiROT_Appli/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Add Include Directory to Target (CMake)\nDESCRIPTION: This CMake code snippet adds the `inc` directory to the target's public include directories. It specifies that the header files are located in the `inc` directory relative to the current CMake list file's directory. The `target_include_directories` command adds include paths to the specified target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_network/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Include Configuration Files\nDESCRIPTION: Includes two custom configuration files, configLib and configDsp, which likely contain project-specific build settings and definitions.  These configurations probably define aspects like compiler flags, target architectures, and feature settings specific to the CMSISDSP library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/BasicMathFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: Including PKEY Subdirectory in CMake\nDESCRIPTION: This command includes the 'pkey' subdirectory in the CMake build process. It enables the compilation and linking of the public key cryptography module as part of the overall project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(pkey)\n```\n\n----------------------------------------\n\nTITLE: Setting TAHI DHCPv6 Test Cases (NetXDuo)\nDESCRIPTION: Defines a set of TAHI DHCPv6 test cases for NetXDuo, conditionally included based on the `NX_DHCPV6_TAHI_ENABLE` build flag. These tests validate DHCPv6 client functionality in a TAHI environment.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_29\n\nLANGUAGE: CMake\nCODE:\n```\nif(PRODUCT STREQUAL netxduo)\n    if(\"-DNX_DHCPV6_TAHI_ENABLE\" IN_LIST ${CMAKE_BUILD_TYPE})\n      set(tahi_dhcpv6_test_cases\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_011.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_036.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_040.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_041.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_037.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_008.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_087.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_013.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_086.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_018.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_071.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_005.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_079.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_082.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_027.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_074.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_003.c\n```\n\n----------------------------------------\n\nTITLE: Allocate Key Prototype - C\nDESCRIPTION: Defines the function prototype for the `allocate_key` entry point in a PSA opaque driver. This function obtains an internal identifier for a key in a secure element with storage. It takes key attributes, a key buffer, and the buffer size as input and returns a PSA status.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_43\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_allocate_key(const psa_key_attributes_t *attributes,\n                               uint8_t *key_buffer,\n                               size_t key_buffer_size);\n```\n\n----------------------------------------\n\nTITLE: Remove Test Resources\nDESCRIPTION: Removes previously created test resources using Remove-TestResources.ps1.  The `-Force` parameter is used to bypass confirmation prompts.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/README.md#_snippet_6\n\nLANGUAGE: PowerShell\nCODE:\n```\nRemove-TestResources.ps1 keyvault -Force\n```\n\n----------------------------------------\n\nTITLE: Including and configuring application\nDESCRIPTION: Includes a configuration file and configures the application using a configApp function. This sets up necessary configurations for the application, likely including board-specific settings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(config)\nconfigApp(arm_matrix_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: CPI Calculation Divider Configuration\nDESCRIPTION: This parameter sets the divider for calculating Cycles Per Instruction (CPI). It is a run-time setting affecting performance monitoring and analysis. Adjusting this value influences the accuracy of CPI calculations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/ARMCM3_config.txt#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\narmcortexm3ct.cpi_div=1\n```\n\n----------------------------------------\n\nTITLE: Setting Target Sources with CMake\nDESCRIPTION: This CMake snippet uses the `target_sources` command to define a list of source files for the specified project. It sets the `PRIVATE` visibility, meaning these sources are only used when building the target and not exposed to other dependent targets. The source files consist of C and assembly files relating to ThreadX thread management and interrupt handling.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_allocate.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_free.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_low_level.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_allocate.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_free.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n)\n```\n\n----------------------------------------\n\nTITLE: Setting up library dependencies for Windows\nDESCRIPTION: This snippet adds `ws2_32` and `bcrypt` to the list of libraries to link against when building on Windows (WIN32). These libraries are necessary for network and cryptography functions on Windows.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif(WIN32)\n    set(libs ${libs} ws2_32 bcrypt)\nendif(WIN32)\n```\n\n----------------------------------------\n\nTITLE: Include Configuration Files\nDESCRIPTION: Includes configuration files named configLib and configDsp. These files likely contain additional configuration settings and definitions required for the CMSISDSPFiltering library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: Conditional compilation options based on architecture CMake\nDESCRIPTION: This snippet conditionally sets compilation options based on the target architecture (32-bit or 64-bit) specified by the environment variable `ENABLE_64`. If `ENABLE_64` is set, the build is configured for 64-bit. Otherwise, it adds 32-bit specific compile and link options. The `NXD_ENABLE_FILE_SERVERS` variable is also set based on the target architecture.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif($ENV{ENABLE_64})\n  message(STATUS \"Building for 64bit\")\n  set(NXD_ENABLE_FILE_SERVERS OFF)\nelse()\n  add_compile_options(-m32)\n  add_link_options(-m32)\n  message(STATUS \"Building for 32bit\")\n  set(NXD_ENABLE_FILE_SERVERS ON)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Add Subdirectories\nDESCRIPTION: This snippet adds subdirectories `netxduo` and `regression` to the build. These subdirectories likely contain source code and CMakeLists.txt files that define the build process for those components. `netxduo` is located relative to the current CMakeLists.txt file, while `regression` is relative to the project source directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nset(NXD_ENABLE_FILE_SERVERS OFF CACHE BOOL \"Includes a dependency on FileX to support 'server' protocol handlers\" FORCE)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../../.. netxduo)\nadd_subdirectory(${PROJECT_SOURCE_DIR}/regression regression)\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration for ThreadX\nDESCRIPTION: This example presents two options for configuring the linker in MDK-ARM to support ThreadX's memory requirements.  The first option is to define the `RW_IRAM1` region in the `.sct` file. The second involves modifying the `tx_initialize_low_level.S` file to align with the memory region being utilized by changing `LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_FreeRTOS_Wrapper/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Getting a Semaphore with tm_semaphore_get in C\nDESCRIPTION: This function gets (acquires) the previously created binary semaphore. The calling thread will block if the semaphore is not available. Returns TM_SUCCESS upon acquiring the semaphore.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nint  tm_semaphore_get(int semaphore_id);\n```\n\n----------------------------------------\n\nTITLE: Define link_to_source Function\nDESCRIPTION: Defines a function to create a symbolic link from a file in the binary directory to the corresponding file in the source directory. On Windows, it copies the file(s) instead of creating a symbolic link.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(link_to_source base_name)\n    set(link \"${CMAKE_CURRENT_BINARY_DIR}/${base_name}\")\n    set(target \"${CMAKE_CURRENT_SOURCE_DIR}/${base_name}\")\n\n    # Linking to non-existent file is not desirable. At best you will have a\n    # dangling link, but when building in tree, this can create a symbolic link\n    # to itself.\n    if (EXISTS ${target} AND NOT EXISTS ${link})\n        if (CMAKE_HOST_UNIX)\n            execute_process(COMMAND ln -s ${target} ${link}\n                RESULT_VARIABLE result\n                ERROR_VARIABLE output)\n\n            if (NOT ${result} EQUAL 0)\n                message(FATAL_ERROR \"Could not create symbolic link for: ${target} --> ${output}\")\n            endif()\n        else()\n            if (IS_DIRECTORY ${target})\n                file(GLOB_RECURSE files FOLLOW_SYMLINKS LIST_DIRECTORIES false RELATIVE ${target} \"${target}/*\")\n                foreach(file IN LISTS files)\n                    configure_file(\"${target}/${file}\" \"${link}/${file}\" COPYONLY)\n                endforeach(file)\n            else()\n                configure_file(${target} ${link} COPYONLY)\n            endif()\n        endif()\n    endif()\nendfunction(link_to_source)\n```\n\n----------------------------------------\n\nTITLE: Modify ST-iRoT Protections\nDESCRIPTION: This command uses the `obscript` tool to modify ST-iRoT protections in a script file. It retrieves values from an XML file based on the `<Name>` tag and updates the option byte protections in the specified script. Options include modifying watermarks, SRAM2 reset behavior, SRAM2 ECC, and write protection areas.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_21\n\nLANGUAGE: text\nCODE:\n```\nobscript --xml STiRoT_Config.xml -ob SRAM2_RST -sp \"SRAM2 erasing in case of reset\" -b \"\" programming.bat\n```\n\n----------------------------------------\n\nTITLE: Python Package Requirements\nDESCRIPTION: Defines python packages required for mbed TLS testing. Specifies exact versions of pylint and mypy for linting and type checking respectively. Also includes cryptography and asn1crypto for test scripts.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/scripts/ci.requirements.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n-r driver.requirements.txt\n\npylint == 2.4.4\nmypy >= 0.780\ncryptography # >= 35.0.0\nasn1crypto\n```\n\n----------------------------------------\n\nTITLE: Define sigwait Function Prototype in C\nDESCRIPTION: Defines the prototype for the `sigwait` function, used for waiting for a signal. It takes a pointer to a signal set and a pointer to an integer to store the signal number.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nINT                   sigwait(const sigset_t *set, int *sig)\n```\n\n----------------------------------------\n\nTITLE: Defining Executables List CMake\nDESCRIPTION: This CMake snippet defines a list of executable targets to be built within the project. These target names are later iterated over in the script to create the executables.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/psa/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(executables\n    aead_demo\n    crypto_examples\n    hmac_demo\n    key_ladder_demo\n    psa_constant_names\n    psa_hash\n)\n```\n\n----------------------------------------\n\nTITLE: Define FreeRTOS Compatibility Layer Library\nDESCRIPTION: Defines a library freertos-threadx that provides a FreeRTOS adaptation layer for ThreadX.  It includes necessary directories and source files, then links this layer against the main ThreadX library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Define the FreeRTOS adaptation layer\nadd_library(freertos-threadx EXCLUDE_FROM_ALL)\ntarget_include_directories(freertos-threadx\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/utility/rtos_compatibility_layers/FreeRTOS\n)\ntarget_sources(freertos-threadx\n    PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/utility/rtos_compatibility_layers/FreeRTOS/tx_freertos.c\n)\ntarget_link_libraries(freertos-threadx PUBLIC threadx)\n```\n\n----------------------------------------\n\nTITLE: Standalone Build Properties Configuration\nDESCRIPTION: This snippet configures properties for the `netxduo` target specifically for the \"standalone_build\". It sets the include directories and clears LINK_LIBRARIES and INTERFACE_LINK_LIBRARIES.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/crypto/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"${CMAKE_BUILD_TYPE}\" STREQUAL \"standalone_build\")\n  set_target_properties(netxduo PROPERTIES INCLUDE_DIRECTORIES\n        \"${CMAKE_CURRENT_SOURCE_DIR}/../../../crypto_libraries/inc\")\n  target_include_directories(netxduo PUBLIC  \"${CMAKE_CURRENT_SOURCE_DIR}/../../../crypto_libraries/ports/${CPU_ARCH}/${COMPILER}/inc\")\n  set_target_properties(netxduo PROPERTIES LINK_LIBRARIES \"\")\n  set_target_properties(netxduo PROPERTIES INTERFACE_LINK_LIBRARIES \"\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. This ensures that the CMake version used to build the project is compatible with the commands and features used in the CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: Key Derivation Verify Bytes Function Prototype (PSA)\nDESCRIPTION: This code snippet defines the function prototype for a key derivation driver's verify bytes entry point. This function compares derived key material with an expected value. It takes the derivation operation context, the expected output, and the expected output length as parameters and returns a PSA status code indicating whether the verification was successful.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_18\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_key_derivation_verify_bytes(\n    acme_key_derivation_operation_t *operation,\n    const uint8_t *expected output, size_t length);\n```\n\n----------------------------------------\n\nTITLE: Include and Configure Application\nDESCRIPTION: This snippet includes a configuration file (config) and then calls a custom function (configApp) to configure the application, passing the executable name and the root directory as arguments. This likely sets up include directories and other project-specific settings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(config)\nconfigApp(arm_graphic_equalizer_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Update Resource Group by Service Directory - PowerShell\nDESCRIPTION: This example demonstrates how to update the 'DeleteAfterHours' property of a resource group identified by its service directory. The script updates the resource group to be deleted after 24 hours.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/Update-TestResources.ps1.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nUpdate-TestResources.ps1 keyvault -DeleteAfterHours 24\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories in CMake\nDESCRIPTION: This snippet adds the include directory (`${CMAKE_CURRENT_LIST_DIR}/inc`) to the specified target (`${PROJECT_NAME}`) as a public include directory. It utilizes the `target_include_directories` command to make the header files available during compilation for other targets that depend on this target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/tsn/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories with CMake\nDESCRIPTION: This snippet uses CMake to set the include directories for the project `${PROJECT_NAME}`. It specifies that the directory `${CMAKE_CURRENT_LIST_DIR}/inc` should be included when compiling the project, ensuring that header files are found during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_device_classes/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Generating and Refreshing SAS Tokens in Azure IoT Hub Client (C)\nDESCRIPTION: This code demonstrates how to generate a Shared Access Signature (SAS) token and password for authenticating with Azure IoT Hub using the `az_iot_hub_client` library.  It uses the `az_iot_hub_client_sas_get_signature` to create the signature and `az_iot_hub_client_sas_get_password` to generate the final password to be used in MQTT connect.  The application is responsible for Base64 encoding the HMAC256 of the signature.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/iot/mqtt_state_machine.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nif(az_result_failed(az_iot_hub_client_sas_get_signature(client, unix_time + 3600, signature, &signature)))\n{\n    // error.\n}\n\n// Application will Base64Encode the HMAC256 of the az_span_ptr(signature) containing az_span_size(signature) bytes with the Shared Access Key.\n\nif(az_result_failed(az_iot_hub_client_sas_get_password(client, NULL, base64_hmac_sha256_signature, password, password_size, &password_length)))\n{\n    // error.\n}\n```\n\n----------------------------------------\n\nTITLE: Nested IRQ Interrupt Handler (Assembly)\nDESCRIPTION: This assembly snippet illustrates how to enable nested IRQ interrupts within a standard IRQ handler. It includes calls to _tx_thread_irq_nesting_start to enable nesting and _tx_thread_irq_nesting_end to disable it before restoring the context.  Requires library to be built with TX_ENABLE_IRQ_NESTING defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac6/readme_threadx.txt#_snippet_2\n\nLANGUAGE: Assembly\nCODE:\n```\n    .global __tx_irq_handler\n    .global __tx_irq_processing_return      \n__tx_irq_handler:\n@\n@    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save\n__tx_irq_processing_return:\n@\n@    /* Enable nested IRQ interrupts. NOTE:  Since this service returns\n@       with IRQ interrupts enabled, all IRQ interrupt sources must be \n@       cleared prior to calling this service.  */\n    BL      _tx_thread_irq_nesting_start\n@    \n@    /* Application ISR call(s) go here!  */\n@\n@    /* Disable nested IRQ interrupts. The mode is switched back to\n@       IRQ mode and IRQ interrupts are disable upon return.  */\n    BL      _tx_thread_irq_nesting_end\n@\n@    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Setting compile options for the product CMake\nDESCRIPTION: This snippet adds specific compile options for the main product. These options include enabling stricter warnings and checks such as `-Werror`, `-Wall`, `-Wextra`, `-pedantic`, and various other warnings to catch potential issues during compilation. It also configures options related to function and data sections, unused code, and potential logical errors.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(\n  ${PRODUCT}\n  PRIVATE -Werror\n          -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal)\n```\n\n----------------------------------------\n\nTITLE: Appending Property with String Value\nDESCRIPTION: Appends a UTF-8 property name and a string value to the JSON writer. Both the property name and the string value are escaped before writing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_property_with_string_value(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr,\n                                                                const UCHAR *property_name, UINT property_name_len,\n                                                                const UCHAR *value, UINT value_len);\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation Definitions\nDESCRIPTION: Adds a compiler definition `ARM_ALL_FAST_TABLES` if the variables `CONFIGTABLE` and `ALLFAST` are both true. This macro likely enables the use of precomputed tables for faster computation of certain functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif (CONFIGTABLE AND ALLFAST)\n    target_compile_definitions(CMSISDSPFastMath PUBLIC ARM_ALL_FAST_TABLES)  \nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources in CMake\nDESCRIPTION: This snippet uses the `target_sources` command to specify the source files for the project. The `${PROJECT_NAME}` variable represents the project's name, and `PRIVATE` indicates that these sources are only used internally within the target. The placeholder comments `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` suggest where specific source files should be listed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m4/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Statistics Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the StatisticsFunctions subdirectory and links the CMSISDSPStatistics library to the CMSISDSP interface library if the STATISTICS flag is set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_32\n\nLANGUAGE: cmake\nCODE:\n```\nif (STATISTICS)\n  add_subdirectory(StatisticsFunctions)\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPStatistics)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Generating error and feature files using Perl/Python\nDESCRIPTION: These snippets use custom commands in CMake to generate error and feature files using Perl and Python scripts.  These generated files are included in the Mbed TLS library. The `DEPENDS` clause ensures that the commands are re-run whenever the source scripts or input files change.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(GEN_FILES)\n    find_package(Perl REQUIRED)\n\n    file(GLOB error_headers ${CMAKE_CURRENT_SOURCE_DIR}/../include/mbedtls/*.h)\n    add_custom_command(\n        OUTPUT\n            ${CMAKE_CURRENT_BINARY_DIR}/error.c\n        COMMAND\n            ${PERL_EXECUTABLE}\n                ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/generate_errors.pl\n                ${CMAKE_CURRENT_SOURCE_DIR}/../include/mbedtls\n                ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/data_files\n                ${CMAKE_CURRENT_BINARY_DIR}/error.c\n        DEPENDS\n            ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/generate_errors.pl\n            ${error_headers}\n            ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/data_files/error.fmt\n    )\n\n    add_custom_command(\n        OUTPUT\n            ${CMAKE_CURRENT_BINARY_DIR}/version_features.c\n        COMMAND\n            ${PERL_EXECUTABLE}\n                ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/generate_features.pl\n                ${CMAKE_CURRENT_SOURCE_DIR}/../include/mbedtls\n                ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/data_files\n                ${CMAKE_CURRENT_BINARY_DIR}/version_features.c\n        DEPENDS\n            ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/generate_features.pl\n            ${CMAKE_CURRENT_SOURCE_DIR}/../include/mbedtls/mbedtls_config.h\n            ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/data_files/version_features.fmt\n    )\n\n    add_custom_command(\n        OUTPUT\n            ${CMAKE_CURRENT_BINARY_DIR}/ssl_debug_helpers_generated.c\n        COMMAND\n            ${MBEDTLS_PYTHON_EXECUTABLE}\n                ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/generate_ssl_debug_helpers.py\n                --mbedtls-root ${CMAKE_CURRENT_SOURCE_DIR}/..\n                ${CMAKE_CURRENT_BINARY_DIR}\n        DEPENDS\n            ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/generate_ssl_debug_helpers.py\n            ${error_headers}\n    )\n\n    add_custom_command(\n        OUTPUT\n            ${CMAKE_CURRENT_BINARY_DIR}/psa_crypto_driver_wrappers.h\n            ${CMAKE_CURRENT_BINARY_DIR}/psa_crypto_driver_wrappers_no_static.c\n        COMMAND\n            ${MBEDTLS_PYTHON_EXECUTABLE}\n                ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/generate_driver_wrappers.py\n                ${CMAKE_CURRENT_BINARY_DIR}\n        DEPENDS\n            ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/generate_driver_wrappers.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/data_files/driver_templates/psa_crypto_driver_wrappers.h.jinja\n            ${CMAKE_CURRENT_SOURCE_DIR}/../scripts/data_files/driver_templates/psa_crypto_driver_wrappers_no_static.c.jinja\n    )\n\n\nelse()\n    link_to_source(error.c)\n    link_to_source(version_features.c)\n    link_to_source(ssl_debug_helpers_generated.c)\n    link_to_source(psa_crypto_driver_wrappers_no_static.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating and Linking Test Utility Library\nDESCRIPTION: Creates a static library named `test_utility` from the files listed in the `test_utility_files` variable. It then links the `test_utility` library to the `azrtos::netxduo` library, adds include directories and defines compiler definitions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/regression/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(test_utility ${test_utility_files})\ntarget_link_libraries(test_utility PUBLIC azrtos::netxduo)\ntarget_include_directories(test_utility PUBLIC ${SOURCE_DIR}/test)\ntarget_compile_definitions(test_utility PUBLIC BATCH_TEST CTEST)\n```\n\n----------------------------------------\n\nTITLE: Semihosting Configuration\nDESCRIPTION: This parameter enables or disables semihosting SVC traps.  If the application doesn't use semihosting, this parameter must be set to '0' to disable it. It is a boolean value configured at initialization.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/ARMCM0_config.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\narmcortexm0ct.semihosting-enable=0\n```\n\n----------------------------------------\n\nTITLE: Inline Function for PSA Algorithm Conversion\nDESCRIPTION: This inline function, `psa_alg_of_md_info`, converts from a legacy hash type encoding (mbedtls_md_info_t) to a PSA algorithm encoding (psa_algorithm_t). This is necessary for integrating with the PSA crypto API. This function enables the use of legacy-style hash algorithms with the newer PSA crypto API. No input parameters are specified, but it implicitly uses the context provided by the `mbedtls_md_info_t` structure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-migration/md-cipher-dispatch.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstatic inline psa_algorithm_t psa_alg_of_md_info(\n    const mbedtls_md_info_t *md_info );\n```\n\n----------------------------------------\n\nTITLE: Syntax - Remove-TestResources ResourceGroup Set - PowerShell\nDESCRIPTION: This snippet defines the syntax for the `Remove-TestResources.ps1` script using the `ResourceGroup` parameter set. It includes parameters for `ResourceGroupName`, `SubscriptionId`, `ServiceDirectory`, `Environment`, `CI`, `Force`, and `RemoveTestResourcesRemainingArguments`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/Remove-TestResources.ps1.md#_snippet_5\n\nLANGUAGE: PowerShell\nCODE:\n```\nRemove-TestResources.ps1 -ResourceGroupName <String> [-SubscriptionId <String>] [[-ServiceDirectory] <String>]\n [-Environment <String>] [-CI] [-Force] [-RemoveTestResourcesRemainingArguments <Object>] [-WhatIf] [-Confirm]\n [<CommonParameters>]\n```\n\n----------------------------------------\n\nTITLE: Define sigfillset Function Prototype in C\nDESCRIPTION: Defines the prototype for the `sigfillset` function, used for initializing a signal set to include all signals. It takes a pointer to the signal set to be filled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nINT                   sigfillset(sigset_t *set)\n```\n\n----------------------------------------\n\nTITLE: Enabling Nested IRQ Interrupts - Assembly\nDESCRIPTION: This assembly code demonstrates how to enable nested IRQ interrupts within a standard IRQ handler. It utilizes `_tx_thread_irq_nesting_start` to enable nesting and `_tx_thread_irq_nesting_end` to disable it.  IRQ interrupt sources must be cleared prior to calling `_tx_thread_irq_nesting_start` as it returns with IRQ interrupts enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac5/readme_threadx.txt#_snippet_3\n\nLANGUAGE: Assembly\nCODE:\n```\n    EXPORT  __tx_irq_handler\n    EXPORT  __tx_irq_processing_return      \n__tx_irq_handler\n;\n;    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save\n__tx_irq_processing_return\n;\n;    /* Enable nested IRQ interrupts. NOTE:  Since this service returns\n;       with IRQ interrupts enabled, all IRQ interrupt sources must be \n;       cleared prior to calling this service.  */\n    BL      _tx_thread_irq_nesting_start\n;    \n;    /* Application ISR call(s) go here!  */\n;\n;    /* Disable nested IRQ interrupts. The mode is switched back to\n;       IRQ mode and IRQ interrupts are disable upon return.  */\n    BL      _tx_thread_irq_nesting_end\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Adding CFFT Radix2 Init F32/F16 source files and definitions in CMake\nDESCRIPTION: Conditionally adds arm_cfft_radix2_init_f32.c, arm_cfft_radix2_init_f16.c  as a private source files to the CMSISDSPTransform library if WRAPPER is defined. Also defines table size compiler definitions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_25\n\nLANGUAGE: cmake\nCODE:\n```\n# For scipy or wrappers or benchmarks\nif (WRAPPER)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix2_init_f32.c)\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix2_init_f16.c)\nendif()\n\n    target_compile_definitions(CMSISDSPTransform PUBLIC ARM_TABLE_BITREV_1024)\n    target_compile_definitions(CMSISDSPTransform PUBLIC ARM_TABLE_TWIDDLECOEF_F32_4096)\n    target_compile_definitions(CMSISDSPTransform PUBLIC ARM_TABLE_TWIDDLECOEF_Q31_4096)\n    target_compile_definitions(CMSISDSPTransform PUBLIC ARM_TABLE_TWIDDLECOEF_Q15_4096)\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\n    target_compile_definitions(CMSISDSPTransform PUBLIC ARM_TABLE_TWIDDLECOEF_F16_4096)\nendif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Target Sources (Complex Magnitude Squared)\nDESCRIPTION: Includes the complex magnitude squared source files (arm_cmplx_mag_squared_f32.c, arm_cmplx_mag_squared_f64.c, arm_cmplx_mag_squared_q15.c, arm_cmplx_mag_squared_q31.c) in the CMSISDSPComplexMath library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_squared_f32.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_squared_f64.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_squared_q15.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_squared_q31.c)\n```\n\n----------------------------------------\n\nTITLE: Install P256-M Headers\nDESCRIPTION: This snippet installs the P256-M header files to the include directory, setting specific permissions for the installed files and directories. The `FILES_MATCHING` option ensures that only files matching the pattern \"*.h\" are installed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/p256-m/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(INSTALL_MBEDTLS_HEADERS)\n\n  install(DIRECTORY :${CMAKE_CURRENT_SOURCE_DIR}\n    DESTINATION include\n    FILE_PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ\n    DIRECTORY_PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE\n    FILES_MATCHING PATTERN \"*.h\")\n\nendif(INSTALL_MBEDTLS_HEADERS)\n```\n\n----------------------------------------\n\nTITLE: Including SSL Subdirectory in CMake\nDESCRIPTION: This command includes the 'ssl' subdirectory in the CMake build process. It enables the compilation and linking of the SSL/TLS module as part of the overall project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(ssl)\n```\n\n----------------------------------------\n\nTITLE: Setting Target Compile Options for NetXDuo\nDESCRIPTION: Defines compile options for the NetXDuo target, including options for error reporting, C standard version, warnings, signed characters, section handling, unused variables, and other code quality checks.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_compile_options(\n  netxduo\n  PRIVATE -Werror\n          -std=c99\n          -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal)\n```\n\n----------------------------------------\n\nTITLE: Toolchain file message\nDESCRIPTION: Displays a status message indicating the toolchain file being used for the build.  The toolchain file specifies the compiler, linker, and other tools used in the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/libs/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation Based on Environment Variable\nDESCRIPTION: This snippet conditionally adds compiler and linker options based on the value of the `ENABLE_64` environment variable. If `ENABLE_64` is set, it indicates a 64-bit build; otherwise, it adds options for a 32-bit build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/crypto/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif($ENV{ENABLE_64})\n  message(STATUS \"Building for 64bit\")\nelse()\n  add_compile_options(-m32)\n  add_link_options(-m32)\n  message(STATUS \"Building for 32bit\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This CMake code configures the target sources for the project, defining which source files are included in the build. The `target_sources` command is used to specify the source files that are part of the `${PROJECT_NAME}` target, scoped as `PRIVATE` to the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/crypto_libraries/ports/cortex_m7/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Including Random Subdirectory in CMake\nDESCRIPTION: This command includes the 'random' subdirectory in the CMake build process. It enables the compilation and linking of the random number generation module as part of the overall project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(random)\n```\n\n----------------------------------------\n\nTITLE: Defining MQTT test cases and source files\nDESCRIPTION: This snippet defines MQTT test cases and their corresponding source files based on the CMAKE_BUILD_TYPE variable. It conditionally includes tests for MQTT subscriber functionality, TLS-enabled subscribers, and multiple subscribers, depending on whether TLS is enabled or disabled. It also sets up file lists for each test case.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt_interoperability/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(\n  SOURCE_DIR\n  ${CMAKE_CURRENT_LIST_DIR}/../../../regression/interoperability_test/mqtt_test\n  ABSOLUTE)\n\nif(NOT \"-DNXD_MQTT_REQUIRE_TLS\" IN_LIST ${CMAKE_BUILD_TYPE})\n  list(APPEND mqtt_test_cases mqtt_subscriber_test)\n  set(mqtt_subscriber_test_file_list\n      ${SOURCE_DIR}/linux_mqtt_subscriber_test_entry.c\n      ${SOURCE_DIR}/linux_mqtt_subscriber_test_server.c\n      ${SOURCE_DIR}/linux_mqtt_subscriber_test_publisher.c\n      ${SOURCE_DIR}/netx_mqtt_subscriber_test.c)\n  list(APPEND mqtt_test_cases mqtt_subscriber_empty_message_test)\n  set(mqtt_subscriber_empty_message_test_file_list\n      ${SOURCE_DIR}/linux_mqtt_subscriber_test_entry.c\n      ${SOURCE_DIR}/linux_mqtt_subscriber_test_server.c\n      ${SOURCE_DIR}/linux_mqtt_subscriber_empty_message_test_publisher.c\n      ${SOURCE_DIR}/netx_mqtt_subscriber_empty_message_test.c)\nendif()\n\nif(\"-DNX_SECURE_ENABLE\" IN_LIST ${CMAKE_BUILD_TYPE})\n  list(APPEND mqtt_test_cases mqtt_tls_subscriber_twice_test)\n  set(mqtt_tls_subscriber_twice_test_file_list\n      ${SOURCE_DIR}/linux_mqtt_tls_subscriber_test_entry.c\n      ${SOURCE_DIR}/linux_mqtt_tls_subscriber_test_server.c\n      ${SOURCE_DIR}/linux_mqtt_tls_subscriber_twice_test_publisher.c\n      ${SOURCE_DIR}/netx_mqtt_tls_subscriber_twice_test.c)\n\n  list(APPEND mqtt_test_cases mqtt_double_subscribers_test)\n  set(mqtt_double_subscribers_test_file_list\n      ${SOURCE_DIR}/linux_mqtt_tls_subscriber_test_entry.c\n      ${SOURCE_DIR}/linux_mqtt_tls_subscriber_test_server.c\n      ${SOURCE_DIR}/linux_mqtt_tls_subscriber_test_publisher.c\n      ${SOURCE_DIR}/netx_mqtt_double_subscribers_test.c)\n\n  list(APPEND mqtt_test_cases mqtt_tls_subscriber_test)\n  set(mqtt_tls_subscriber_test_file_list\n      ${SOURCE_DIR}/linux_mqtt_tls_subscriber_test_entry.c\n      ${SOURCE_DIR}/linux_mqtt_tls_subscriber_test_server.c\n      ${SOURCE_DIR}/linux_mqtt_tls_subscriber_test_publisher.c\n      ${SOURCE_DIR}/netx_mqtt_tls_subscriber_test.c)\n\n  list(APPEND debug_secure_build_mqtt_test_cases mqtt_tls_debug_test)\n  set(mqtt_tls_debug_test_file_list\n      ${SOURCE_DIR}/netx_mqtt_tls_subscriber_test.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Append End Array Azure IoT JSON Writer C\nDESCRIPTION: Appends the end of the current JSON array (']') to the payload. Requires a pointer to the JSON writer. Returns NX_AZURE_IOT_SUCCESS if the array end is appended successfully.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_30\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_end_array(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr);\n```\n\n----------------------------------------\n\nTITLE: Including Azure SDK Headers\nDESCRIPTION: This code snippet shows the necessary header files to include in your VxWorks Real Time Process Project for developing an Azure IoT application. It includes headers for Mosquitto MQTT APIs, Azure SDK APIs, and OpenSSL APIs for SAS token generation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_vxworks.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n/* Moquitto MQTT APIs */\n#include <mosquitto.h>\n\n/* Azure SDK APIs */\n#include <azure/az_core.h>\n#include <azure/az_iot.h>\n\n/* OpenSSL APIs for SAS token generation */\n#include <openssl/bio.h>\n#include <openssl/hmac.h>\n#include <openssl/evp.h>\n#include <openssl/buffer.h>\n```\n\n----------------------------------------\n\nTITLE: Receiving a Message from a Queue with tm_queue_receive in C\nDESCRIPTION: This function receives a message from a previously created queue. It takes the queue_id and a pointer to store the received message. Returns TM_SUCCESS if a message is successfully received.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nint  tm_queue_receive(int queue_id, unsigned long *message_ptr);\n```\n\n----------------------------------------\n\nTITLE: Define Magic Number for Image Verification (C)\nDESCRIPTION: This code defines the magic number used to verify the integrity of the image during the boot process. It consists of a const uint32_t array.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nconst uint32_t boot_img_magic[4] = {\n    0xf395c277,\n    0x7fefd260,\n    0x0f505235,\n    0x8079b62c,\n};\n```\n\n----------------------------------------\n\nTITLE: Run Mbed TLS Tests with Make\nDESCRIPTION: This command executes the test suite for the Mbed TLS library using GNU Make. It requires Python for building the tests and Perl for running them.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\nmake check\n```\n\n----------------------------------------\n\nTITLE: Link Libraries\nDESCRIPTION: Links the 'CMSISDSP' library to the 'arm_fir_example' target. The linking is set to private.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fir_example/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(arm_fir_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Build Examples matching TXM, GCC, Cortex M (PowerShell)\nDESCRIPTION: This command builds all examples matching the keywords 'TXM', 'GCC', and 'Cortex M'. These examples are likely related to ThreadX Modules (TXM) for Cortex M using the GCC compiler. The pwsh -Command prefix facilitates execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_16\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TXM','GCC','Cortex M' -build\n```\n\n----------------------------------------\n\nTITLE: Creating Map File\nDESCRIPTION: This snippet creates a map file for the test executable, aiding in debugging and analysis. The `create_map_file` function is responsible for generating the map file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/hub/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ncreate_map_file(az_iot_hub_test az_iot_hub_test.map)\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker File Modification for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows the modification required in the MDK-ARM linker file (.sct) or the \"tx_low_level_initilize.S\" file to allocate a section of RAM for ThreadX dynamic memory allocation. This involves either defining the RW_IRAM1 region in the .sct file or modifying the line to match the memory region being used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/FX_IAP/IAP_main/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Configuring Package CMake\nDESCRIPTION: This snippet configures and installs package configuration files, writes the package version file, and exports targets for use by other CMake projects.  It also manages CMake policy settings and exports the package.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_28\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT DISABLE_PACKAGE_CONFIG_AND_INSTALL)\n    configure_package_config_file(\n        \"cmake/MbedTLSConfig.cmake.in\"\n        \"cmake/MbedTLSConfig.cmake\"\n            INSTALL_DESTINATION \"cmake\")\n\n    write_basic_package_version_file(\n        \"cmake/MbedTLSConfigVersion.cmake\"\n            COMPATIBILITY SameMajorVersion\n            VERSION 3.6.2)\n\n    install(\n        FILES \"${CMAKE_CURRENT_BINARY_DIR}/cmake/MbedTLSConfig.cmake\"\n              \"${CMAKE_CURRENT_BINARY_DIR}/cmake/MbedTLSConfigVersion.cmake\"\n        DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/MbedTLS\")\n\n    export(\n        EXPORT MbedTLSTargets\n        NAMESPACE MbedTLS::\n        FILE \"cmake/MbedTLSTargets.cmake\")\n\n    install(\n        EXPORT MbedTLSTargets\n        NAMESPACE MbedTLS::\n        DESTINATION \"${CMAKE_INSTALL_LIBDIR}/cmake/MbedTLS\"\n        FILE \"MbedTLSTargets.cmake\")\n\n    if(CMAKE_VERSION VERSION_GREATER 3.15 OR CMAKE_VERSION VERSION_EQUAL 3.15)\n        # Do not export the package by default\n        cmake_policy(SET CMP0090 NEW)\n\n        # Make this package visible to the system\n        export(PACKAGE MbedTLS)\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: License Notice - OpenSSL Toolkit\nDESCRIPTION: This snippet presents the OpenSSL License, under which the OpenSSL toolkit is provided. It outlines conditions for redistribution and use in source and binary forms, including copyright notices and disclaimers.  It also mentions the original SSLeay license.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/NOTICE.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n/* ====================================================================\n * Copyright (c) 1998-2019 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n```\n\n----------------------------------------\n\nTITLE: Running Self Tests\nDESCRIPTION: This snippet demonstrates running a smaller set of self-tests located in the `programs/test` directory.  It is used when the full test suites are disabled but the programs are still enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_10\n\nLANGUAGE: Text\nCODE:\n```\nprograms/test/selftest\n```\n\n----------------------------------------\n\nTITLE: Include Common ThreadX Code\nDESCRIPTION: Includes the common ThreadX code by adding the common subdirectory to the build. This allows the project to compile the core ThreadX functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Pick up the common stuff\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/common)\n```\n\n----------------------------------------\n\nTITLE: Adding NX Secure TLS/DTLS Sources to CMake Target\nDESCRIPTION: This CMake code snippet adds a list of C source files to a target named `${PROJECT_NAME}`. The source files pertain to various aspects of NX Secure TLS and DTLS implementations, including cryptographic methods, DTLS handshake processes, and TLS record processing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/nx_secure/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_method_self_test_3des.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_method_self_test_aes.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_method_self_test_des.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_method_self_test_hmac_md5.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_method_self_test_hmac_sha.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_method_self_test_md5.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_method_self_test_prf.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_method_self_test_rsa.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_method_self_test_sha.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_rng_self_test.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_crypto_table_self_test.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_allocate_handshake_packet.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_client_handshake.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_client_protocol_version_override.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_client_session_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_ecc_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_hash_record.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_packet_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_process_clienthello.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_process_handshake_header.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_process_header.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_process_helloverifyrequest.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_process_record.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_psk_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_receive_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_retransmit.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_retransmit_queue_flush.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_send_clienthello.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_send_handshake_record.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_send_helloverifyrequest.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_send_record.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_send_serverhello.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_ecc_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_handshake.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_local_certificate_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_local_certificate_remove.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_notify_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_protocol_version_override.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_psk_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_session_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_session_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_stop.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_trusted_certificate_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_trusted_certificate_remove.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_x509_client_verify_configure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_server_x509_client_verify_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_cache.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_client_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_end.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_local_certificate_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_local_certificate_remove.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_reset.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_trusted_certificate_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_trusted_certificate_remove.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_sliding_window_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_session_sliding_window_update.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_dtls_verify_mac.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_generate_client_key_exchange.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_generate_master_secret.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_generate_premaster_secret.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_generate_server_key_exchange.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_generate_session_keys.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_module_hash_compute.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_process_client_key_exchange.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_process_server_key_exchange.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_remote_certificate_verify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_session_keys_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_1_3_client_handshake.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_1_3_crypto_init.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_1_3_finished_hash_generate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_1_3_generate_keys.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_1_3_server_handshake.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_1_3_session_keys_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_1_3_transcript_hash_save.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_active_certificate_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_allocate_handshake_packet.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_check_protocol_version.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_ciphersuite_lookup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_client_handshake.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_client_psk_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_ecc_generate_keys.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_ecc_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_find_curve_method.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_finished_hash_generate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_generate_keys.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_generate_premaster_secret.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_handshake_hash_init.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_handshake_hash_update.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_handshake_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_hash_record.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_key_material_init.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_local_certificate_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_local_certificate_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_local_certificate_remove.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_map_error_to_alert.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_metadata_size_calculate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_newest_supported_version.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_packet_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_packet_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_certificate_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_certificate_verify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_changecipherspec.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_client_key_exchange.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_clienthello.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_clienthello_extensions.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_encrypted_extensions.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_finished.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_handshake_header.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_header.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_newsessionticket.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_record.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_remote_certificate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_server_key_exchange.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_serverhello.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_process_serverhello_extensions.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_protocol_version_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_psk_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_psk_binder_generate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_psk_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_psk_identity_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_record_hash_calculate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_record_hash_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_record_hash_update.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_record_payload_decrypt.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_record_payload_encrypt.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_remote_certificate_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_remote_certificate_buffer_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_remote_certificate_free.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_remote_certificate_free_all.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_remote_certificate_verify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_send_alert.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_send_certificate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_send_certificate_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_secure_tls_send_certificate_verify.c\n\n```\n\n----------------------------------------\n\nTITLE: Deploy test resources in an Azure DevOps CI/CD pipeline (PowerShell)\nDESCRIPTION: This example demonstrates how to deploy test resources in an Azure DevOps CI/CD pipeline. It uses pipeline variables for configuration and includes parameters for automatically deleting resources after a set number of hours, continuous integration, and verbose output.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\nNew-TestResources.ps1 `\n    -ServiceDirectory '$(ServiceDirectory)' `\n    -TenantId '$(TenantId)' `\n    -ProvisionerApplicationId '$(ProvisionerId)' `\n    -ProvisionerApplicationSecret '$(ProvisionerSecret)' `\n    -TestApplicationId '$(TestAppId)' `\n    -TestApplicationSecret '$(TestAppSecret)' `\n    -DeleteAfterHours 24 `\n    -CI `\n    -Force `\n    -Verbose\n```\n\n----------------------------------------\n\nTITLE: Configure Application\nDESCRIPTION: This snippet includes a configuration module (`config`) and configures the application using the `configApp` function, passing the executable name and the root directory as arguments. This is assumed to handle target-specific settings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(config)\nconfigApp(arm_dotproduct_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Setting Compile Options with Warnings and Features\nDESCRIPTION: This snippet configures compile options for the usbx target, enabling various warnings (-Werror, -Wall, etc.) and features such as function and data section separation (-ffunction-sections, -fdata-sections) and EXFAT support (DFX_ENABLE_EXFAT).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(\n  usbx\n  PRIVATE -Werror\n          -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal\n          -DFX_ENABLE_EXFAT)\n```\n\n----------------------------------------\n\nTITLE: Specifying Source Files\nDESCRIPTION: This snippet specifies the source files for the executable `arm_fft_bin_example`. The source files are `arm_fft_bin_data.c` and `arm_fft_bin_example_f32.c`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(arm_fft_bin_example PRIVATE arm_fft_bin_data.c arm_fft_bin_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Initialize CMake Project\nDESCRIPTION: This snippet initializes the CMake project, setting the minimum required version and the project language to C. It also sets the CMP0057 policy to NEW, which affects how CMake handles certain commands.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(regression_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Configuring RFFT Options (Single Precision) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Real FFT (RFFT) implementations for single-precision floating-point numbers (f32) with various sizes (128 to 8192). These options are used to customize the CMSIS-DSP library by selecting specific RFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\noption(RFFT_F32_128         \"rfft f32 128\"                      OFF)\noption(RFFT_F32_512         \"rfft f32 512\"                      OFF)\noption(RFFT_F32_2048        \"rfft f32 2048\"                     OFF)\noption(RFFT_F32_8192        \"rfft f32 8192\"                     OFF)\n```\n\n----------------------------------------\n\nTITLE: Defining Executable Targets in CMake\nDESCRIPTION: This snippet defines a list of executables and iterates through it. For each executable, it adds the executable target, links necessary libraries (mbedcrypto and thread libraries), and includes relevant directories. The CMAKE_THREAD_LIBS_INIT variable provides thread libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/cipher/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(executables\n    cipher_aead_demo\n)\n\nforeach(exe IN LISTS executables)\n    add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>)\n    target_link_libraries(${exe} ${mbedcrypto_target} ${CMAKE_THREAD_LIBS_INIT})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Driver Description File Structure (JSON)\nDESCRIPTION: The driver description file is a JSON file that declares the functions the driver implements and the cryptographic mechanisms it supports. The structure of this JSON file is specified in the PSA cryptography driver interface specification.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-developer-guide.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"driver_name\": \"string\",\n  \"driver_type\": \"string\",\n  \"functions\": [\n    {\n      \"name\": \"string\",\n      \"implements\": \"string\"\n    }\n  ],\n  \"header_files\": [\"string\"],\n  \"mbedtls/h_condition\": \"string\",\n  \"mbedtls/c_condition\": \"string\"\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation for Float16\nDESCRIPTION: Conditionally adds source files for half-precision floating-point (f16) distance calculation algorithms to the library. This is done only if the ARMAC5 compiler is not being used and the DISABLEFLOAT16 flag is not set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/DistanceFunctions/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPDistance PRIVATE arm_braycurtis_distance_f16.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_canberra_distance_f16.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_chebyshev_distance_f16.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_cityblock_distance_f16.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_correlation_distance_f16.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_cosine_distance_f16.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_euclidean_distance_f16.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_jensenshannon_distance_f16.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_minkowski_distance_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting CMake minimum version\nDESCRIPTION: Specifies the minimum CMake version required for the project build.  This ensures that the build system has the necessary features and capabilities. The FATAL_ERROR flag ensures that the build will fail if the CMake version is less than the specified version.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/libs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\n```\n\n----------------------------------------\n\nTITLE: Setting Additional C Flags\nDESCRIPTION: Sets additional C compiler flags based on the operating system and architecture. On Windows, it defines preprocessor directives to suppress warnings. On Linux, it adds flags for debugging, code coverage, and disabling specific warnings. Separate flags for Azure Services are also set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# CFLAGS\nif(WIN32)\n  set(ADDITIONAL_C_FLAGS $ENV{CFLAGS} \"/MP -DWIN32 -D_CRT_SECURE_NO_WARNINGS\")\nelse()\n  if(THREADX_ARCH STREQUAL \"linux\")\n    set(ADDITIONAL_C_FLAGS\n        \"$ENV{CFLAGS} -O0 -g3 -ggdb -m32 -gdwarf-2 -fdiagnostics-color -fprofile-arcs -ftest-coverage -Wno-error=misleading-indentation\")\n  endif()\n  set(ADDITIONAL_C_FLAGS_AZURE_SERVICES\n      \"-std=c99 -Werror -Wall -Wextra -pedantic -fmessage-length=0 -fsigned-char -ffunction-sections -fdata-sections -Wunused -Wuninitialized -Wmissing-declarations -Wconversion -Wpointer-arith -Wshadow -Wlogical-op -Wfloat-equal -fprofile-arcs -ftest-coverage -Wjump-misses-init -Wno-error=misleading-indentation\"\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: This snippet adds subdirectories to the project. It adds the 'netxduo' directory, which is located three levels above the current list file, and the 'regression' directory within the current directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../../.. netxduo)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/regression regression)\n```\n\n----------------------------------------\n\nTITLE: Defining Target Sources\nDESCRIPTION: This snippet defines the source files used to build the `arm_linear_interp_example` executable. The `target_sources` command adds the specified C files to the private sources of the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_linear_interp_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(arm_linear_interp_example PRIVATE math_helper.c arm_linear_interp_data.c arm_linear_interp_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Configuring RFFT Options (Q15) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Real FFT (RFFT) implementations for Q15 data types with various sizes (32 to 8192). These options are used to customize the CMSIS-DSP library by selecting specific RFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\noption(RFFT_Q15_32          \"rfft q15 32\"                       OFF)\noption(RFFT_Q15_64          \"rfft q15 64\"                       OFF)\noption(RFFT_Q15_128         \"rfft q15 128\"                      OFF)\noption(RFFT_Q15_256         \"rfft q15 256\"                      OFF)\noption(RFFT_Q15_512         \"rfft q15 512\"                      OFF)\noption(RFFT_Q15_1024        \"rfft q15 1024\"                     OFF)\noption(RFFT_Q15_2048        \"rfft q15 2048\"                     OFF)\noption(RFFT_Q15_4096        \"rfft q15 4096\"                     OFF)\noption(RFFT_Q15_8192        \"rfft q15 8192\"                     OFF)\n```\n\n----------------------------------------\n\nTITLE: ThreadX Interrupt Handler Template (Assembly)\nDESCRIPTION: This assembly code provides a template for a ThreadX managed interrupt handler (ISR). It includes the necessary PUSH and POP instructions to preserve the context and allows access to ThreadX services from within the ISR. The label `__tx_IntHandler` must be placed in the interrupt vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\n .global  __tx_IntHandler\n .thumb_func\n__tx_IntHandler:\n; VOID InterruptHandler (VOID)\n; {\n PUSH    {r0, lr}\n\n; /* Do interrupt handler work here */\n; /* BL <your interrupt routine in C> */\n\n POP     {r0, lr}\n BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Python Requirements Installation\nDESCRIPTION: This snippet shows the command to install the necessary Python modules using pip, as specified in the requirements.txt file. This is needed when switching to the Python version of ROT_AppliConfig.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ROT/STiROT_Appli/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Conditionally Removing File Server Sources (CMake)\nDESCRIPTION: This snippet conditionally removes source files related to file server functionalities (HTTP, FTP, TFTP servers) from the SOURCES list if the NXD_ENABLE_FILE_SERVERS CMake option is disabled. This allows the project to exclude file server capabilities based on the configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT NXD_ENABLE_FILE_SERVERS)\n    list(REMOVE_ITEM SOURCES     \n        \"${CMAKE_CURRENT_LIST_DIR}/web/nx_web_http_server.c\"\n        \"${CMAKE_CURRENT_LIST_DIR}/http/nxd_http_server.c\"\n        \"${CMAKE_CURRENT_LIST_DIR}/ftp/nxd_ftp_server.c\"\n        \"${CMAKE_CURRENT_LIST_DIR}/tftp/nxd_tftp_server.c\"\n    )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Detect Compiler ID\nDESCRIPTION: Detects the compiler ID to determine the compiler being used (e.g., Clang, GNU, IAR, MSVC). This is used to adjust build settings based on the compiler.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif (CMAKE_C_SIMULATE_ID)\n    set(COMPILER_ID ${CMAKE_C_SIMULATE_ID})\nelse()\n    set(COMPILER_ID ${CMAKE_C_COMPILER_ID})\nendif(CMAKE_C_SIMULATE_ID)\n\nstring(REGEX MATCH \"Clang\" CMAKE_COMPILER_IS_CLANG \"${COMPILER_ID}\")\nstring(REGEX MATCH \"GNU\" CMAKE_COMPILER_IS_GNU \"${COMPILER_ID}\")\nstring(REGEX MATCH \"IAR\" CMAKE_COMPILER_IS_IAR \"${COMPILER_ID}\")\nstring(REGEX MATCH \"MSVC\" CMAKE_COMPILER_IS_MSVC \"${COMPILER_ID}\")\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation Configuration for MDK-ARM\nDESCRIPTION: This code snippet shows how to configure the ThreadX memory allocation in tx_initialize_low_level.S for MDK-ARM.  It loads the limit of the RW_IRAM1 region into register r1 to indicate the memory region available for ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_Iperf_wifi/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nLDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Installing Executables and Scripts CMake\nDESCRIPTION: This CMake snippet installs the built executables to the 'bin' directory with specific permissions and installs a shell script.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/psa/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS ${executables}\n        DESTINATION \"bin\"\n        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n\ninstall(PROGRAMS\n            key_ladder_demo.sh\n        DESTINATION \"bin\")\n```\n\n----------------------------------------\n\nTITLE: Add CMSIS DSP Subdirectory\nDESCRIPTION: This snippet adds the subdirectory containing the compiled CMSIS-DSP library. This allows CMake to build and link the library into the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Append Int32 Azure IoT JSON Writer C\nDESCRIPTION: Appends a 32-bit integer value to the JSON payload. It requires a pointer to the JSON writer and the integer value to be appended. Returns NX_AZURE_IOT_SUCCESS on success.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_24\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_int32(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr, int32_t value);\n```\n\n----------------------------------------\n\nTITLE: Modifying XML Tag Content (xmlval)\nDESCRIPTION: This example shows how to replace the content of a specific XML tag with a given string. It filters the XML file by a command and, if the command is found, replaces the content of the specified tag.  This snippet converts to string.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nxmval -v resign -c sign -xml_tag Command --string OEMiRoT_Secure_Code.xml\n```\n\n----------------------------------------\n\nTITLE: Force Parameter\nDESCRIPTION: Forces the creation of resources without prompting for confirmation. This parameter is useful for automated deployments where user interaction is not possible, ensuring resources are created without manual intervention.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\nType: SwitchParameter\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: False\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: C ISR Template - ThreadX Cortex-M85\nDESCRIPTION: This C code snippet provides a template for creating interrupt service routines (ISRs) within a ThreadX environment.  ISRs written in C can access the ThreadX API that is available to ISRs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/ac6/readme_threadx.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Adding CMocka Test\nDESCRIPTION: Adds a CMocka test target named `az_core_test`. This includes specifying source files, compiler options, link libraries (CMocka library, math library on Unix, az_core, PAL, az_nohttp), link options (wrap functions), and include directories for CMocka headers and private folder headers. The `add_cmocka_test` macro is used to configure the unit tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/core/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_cmocka_test(az_core_test SOURCES\n                main.c\n                test_az_base64.c\n                test_az_context.c\n                test_az_http.c\n                test_az_json.c\n                test_az_logging.c\n                test_az_pipeline.c\n                test_az_policy.c\n                test_az_span.c\n                test_az_url_encode.c\n                COMPILE_OPTIONS ${DEFAULT_C_COMPILE_FLAGS} ${NO_CLOBBERED_WARNING}\n                LINK_LIBRARIES ${CMOCKA_LIB} ${MATH_LIB_UNIX} az_core ${PAL} az_nohttp\n                LINK_OPTIONS ${WRAP_FUNCTIONS}  \n                # include cmoka headers and private folder headers\n                INCLUDE_DIRECTORIES ${CMOCKA_INCLUDE_DIR} ${CMAKE_SOURCE_DIR}/sdk/src/azure/core/\n                )\n```\n\n----------------------------------------\n\nTITLE: Setting SNMP Test Cases (NetXDuo)\nDESCRIPTION: Defines a set of SNMP (Simple Network Management Protocol) test cases for NetXDuo. These tests cover SNMP v1, v2, and v3, including buffer overflow vulnerabilities, packet handling, get-bulk requests, unknown OIDs, trap sending, security mechanisms (MD5), object ID handling, and set/get operations for various data types.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_25\n\nLANGUAGE: CMake\nCODE:\n```\nset(snmp_test_cases\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v1_buffer_overwrite_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v1_object_id_buffer_overwrite_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v1_packet_double_release_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_basic_v2_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v2_get_bulk_request_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v2_unknown_oid_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v2_send_trap_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v2_buffer_overwrite_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v3_nosec_traplist_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v3_md5_failed_security_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v3_md5_security_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v3_md5_security_extended_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v3_no_security_function_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v3_buffer_overwrite_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v3_decrypt_pdu_buffer_overwrite_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v3_encrypt_pdu_buffer_overwrite_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v3_encrypt_pdu_padding_buffer_overwrite_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_v3_object_id_buffer_overwrite_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_setget_integers_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_setget_octet_strings_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_setget_ip_address_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_setget_misc_test.c\n    ${SOURCE_DIR}/snmp_test/netx_snmp_abnormal_packet_test.c)\n```\n\n----------------------------------------\n\nTITLE: Enabling VFP Support for a Thread in C\nDESCRIPTION: This C code snippet enables VFP (Vector Floating Point) support for the calling thread.  This API call must be made from the context of the application thread before the thread uses VFP instructions. After this call, VFP registers will be saved/restored upon interrupt-driven preemption.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac6/readme_threadx.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nvoid    tx_thread_vfp_enable(void);\n```\n\n----------------------------------------\n\nTITLE: Setting CMSIS-DSP Path\nDESCRIPTION: Sets the path to the CMSIS-DSP library, using a relative path based on the project's source directory. The ROOT variable is defined when calling cmake to set the path from top level.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_variance_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# Needed to include the configBoot module\n# Define the path to CMSIS-DSP (ROOT is defined on command line when using cmake)\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\n# Add DSP folder to module path\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: Add Static Library\nDESCRIPTION: Adds a static library named CMSISDSPBasicMath and specifies SRCF64 as its initial source files. Additional source files are added in subsequent target_sources commands. Creating a static library allows for linking the math functions directly into other projects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/BasicMathFunctions/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(CMSISDSPBasicMath STATIC ${SRCF64})\n```\n\n----------------------------------------\n\nTITLE: Interrupt Service Routine (ISR) in C\nDESCRIPTION: This code snippet demonstrates how to write an ISR (Interrupt Service Routine) in C for ThreadX using IAR tools. It shows the basic structure of an ISR, where \"your_C_isr\" is an entry in the vector table. Inside the ISR, you can place your ISR processing code, including any needed function calls.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/iar/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Configure tx_user.h File\nDESCRIPTION: Configures the tx_user.h file by either using a default sample or a user-provided file. It copies the selected file to a custom include directory and sets up the necessary include paths and compiler definitions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# If the user provided an override, copy it to the custom directory\nif (NOT TX_USER_FILE)\n    message(STATUS \"Using default tx_user.h file\")\n    set(TX_USER_FILE ${CMAKE_CURRENT_LIST_DIR}/common/inc/tx_user_sample.h)\nelse()\n    message(STATUS \"Using custom tx_user.h file from ${TX_USER_FILE}\")\nendif()    \nconfigure_file(${TX_USER_FILE} ${CUSTOM_INC_DIR}/tx_user.h COPYONLY)\ntarget_include_directories(${PROJECT_NAME} \n    PUBLIC \n    ${CUSTOM_INC_DIR}\n)\ntarget_compile_definitions(${PROJECT_NAME} PUBLIC \"TX_INCLUDE_USER_DEFINE_FILE\" )\n```\n\n----------------------------------------\n\nTITLE: Adding bit reversal source files in CMake\nDESCRIPTION: This snippet adds arm_bitreversal.c and arm_bitreversal2.c as private source files to the CMSISDSPTransform library, providing bit reversal functionality required for FFT operations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPTransform PRIVATE arm_bitreversal.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_bitreversal2.c)\n```\n\n----------------------------------------\n\nTITLE: Setting RTP Test Cases (NetXDuo)\nDESCRIPTION: Defines a set of RTP (Real-time Transport Protocol) test cases for NetXDuo. These tests cover various aspects of RTP, including multi-interface support, session management, packet sending (JPEG, H.264, AAC), UDP port finding, multi-client scenarios, multicast, basic functionality, API testing, and RTCP (RTP Control Protocol) handling.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_22\n\nLANGUAGE: CMake\nCODE:\n```\nset(rtp_test_cases\n    ${SOURCE_DIR}/rtp_test/netx_rtp_multi_interfaces_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtp_session_packet_send_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtp_session_jpeg_send_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtp_session_h264_send_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtp_session_aac_send_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtp_free_udp_port_find_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtp_multi_clients_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtp_multicast_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtp_basic_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtp_api_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtcp_abnormal_packet_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtcp_basic_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtcp_packet_process_test.c\n    ${SOURCE_DIR}/rtp_test/netx_rtcp_packet_send_test.c)\n```\n\n----------------------------------------\n\nTITLE: Defining Project and Setting C Standard\nDESCRIPTION: Defines the CMake project with the name `az_core`, specifying C as the language and setting the project version using the extracted version components. Sets the C standard to C99.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/core/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject (az_core LANGUAGES C VERSION ${AZ_SDK_VERSION_MAJOR}.${AZ_SDK_VERSION_MINOR}.${AZ_SDK_VERSION_PATCH})\nset(CMAKE_C_STANDARD 99)\n```\n\n----------------------------------------\n\nTITLE: ARM Cortex-M3 CPI Divider Configuration\nDESCRIPTION: This parameter sets the divider for calculating Cycles Per Instruction (CPI). It is an integer value configurable at runtime, with a default value of 0x1.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/ARMCM3_config.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.cpi_div=1                               # (int   , run-time ) default = '0x1'    : divider for calculating CPI (Cycles Per Instruction)\n```\n\n----------------------------------------\n\nTITLE: Target Compile Options for NetX Duo\nDESCRIPTION: This snippet adds compile options specific to the NetX Duo library, enabling event tracing and setting the physical header size.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/libs/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(netxduo PRIVATE -DTX_ENABLE_EVENT_TRACE -DNX_PHYSICAL_HEADER=20)\n```\n\n----------------------------------------\n\nTITLE: Initializing RTOS using tm_initialize in C\nDESCRIPTION: This function initializes the RTOS and calls the provided test initialization function. It is typically called from the application's main() function. It requires the RTOS to be set up and ready to start.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid  tm_initialize(void (*test_initialization_function)(void));\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files to the Library\nDESCRIPTION: Adds multiple C source files containing implementations of various distance calculation algorithms to the CMSISDSPDistance library. These files are added as private sources, meaning they are not exposed as part of the library's public interface.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/DistanceFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB SRC \"./*_*.c\")\n\nadd_library(CMSISDSPDistance STATIC)\n\ntarget_sources(CMSISDSPDistance PRIVATE arm_boolean_distance.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_braycurtis_distance_f32.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_canberra_distance_f32.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_chebyshev_distance_f32.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_chebyshev_distance_f64.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_cityblock_distance_f32.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_cityblock_distance_f64.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_correlation_distance_f32.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_cosine_distance_f32.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_cosine_distance_f64.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_dice_distance.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_euclidean_distance_f32.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_euclidean_distance_f64.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_hamming_distance.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_jaccard_distance.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_jensenshannon_distance_f32.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_kulsinski_distance.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_minkowski_distance_f32.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_rogerstanimoto_distance.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_russellrao_distance.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_sokalmichener_distance.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_sokalsneath_distance.c)\ntarget_sources(CMSISDSPDistance PRIVATE arm_yule_distance.c)\n```\n\n----------------------------------------\n\nTITLE: ThreadX Heap Configuration - EWARM\nDESCRIPTION: This configuration is for the IAR Embedded Workbench (EWARM) toolchain. It defines the placement of the ThreadX heap in the RAM region by specifying the `FREE_MEM` section.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Applications/USBX/Ux_Device_CDC_ACM/README.md#_snippet_0\n\nLANGUAGE: EWARM\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows how to configure the MDK-ARM linker file to allocate memory for ThreadX when using dynamic memory allocation. It involves either defining the `RW_IRAM1` region in the `.sct` file or modifying the line in `tx_low_level_initilize.s` to match the memory region being used. This ensures that ThreadX can access the required memory region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBPD/USBPD_SRC/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nLDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Set Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project and sets CMake policies for compatibility.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows how to configure the STM32CubeIDE linker file to allocate a heap for ThreadX. A new section `._threadx_heap` is defined in the linker script within the `RAM_D1` region, with a size of 64KB. The section must be located between `.bss` and `._user_heap_stack`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBPD/USBPD_SRC/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Setting SRAM Size\nDESCRIPTION: This snippet defines the size of the internal SRAM modules (iotss_internal_sram1, iotss_internal_sram2, iotss_internal_sram3) in the FVP MPS2 simulator.  The `size` parameter is set to 0x100000000, representing the memory size in bytes. This determines the addressable memory space for these SRAM modules.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_module/cortex_m23/ac6/example_build/ARMCM23_TZ_config.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nfvp_mps2.sse200.iotss_internal_sram1.size=0x100000000\nfvp_mps2.sse200.iotss_internal_sram2.size=0x100000000\nfvp_mps2.sse200.iotss_internal_sram3.size=0x100000000\n```\n\n----------------------------------------\n\nTITLE: Configuring CFFT Options (Q15) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Complex FFT (CFFT) implementations for Q15 data types with various sizes (16 to 4096). These options are used to customize the CMSIS-DSP library by selecting specific CFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\noption(CFFT_Q15_16          \"cfft q15 16\"                       OFF)\noption(CFFT_Q15_32          \"cfft q15 32\"                       OFF)\noption(CFFT_Q15_64          \"cfft q15 64\"                       OFF)\noption(CFFT_Q15_128         \"cfft q15 128\"                      OFF)\noption(CFFT_Q15_256         \"cfft q15 256\"                      OFF)\noption(CFFT_Q15_512         \"cfft q15 512\"                      OFF)\noption(CFFT_Q15_1024        \"cfft q15 1024\"                     OFF)\noption(CFFT_Q15_2048        \"cfft q15 2048\"                     OFF)\noption(CFFT_Q15_4096        \"cfft q15 4096\"                     OFF)\n```\n\n----------------------------------------\n\nTITLE: Adding Target Sources in CMake\nDESCRIPTION: This snippet uses the `target_sources` command to specify the source files to be compiled for the target `${PROJECT_NAME}`.  It includes assembly and C files related to thread management and timer interrupts, located in the `src` directory. These source files are compiled as part of the private interface.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/iar/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_iar.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S    \n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Set Define with XML File\nDESCRIPTION: This command uses the `setdefine` tool to comment or uncomment a define variable in a header file based on the value extracted from an XML file. It filters the XML file by the tag `<Name>` to find a specific value, compares it to a specified value, and then comments or uncomment the defined variable accordingly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_20\n\nLANGUAGE: text\nCODE:\n```\nsetdefine -xml STiRoT_Config.xml -nxml Number of images managed -n DATA_IMAGE_EN -v 0x02 File.h\n```\n\n----------------------------------------\n\nTITLE: Disable Device Twin Feature in C\nDESCRIPTION: This function disables the device twin feature for the given IoT Hub client. It only takes the hub client pointer as input. Disabling the device twin prevents further device twin interactions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_32\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_device_twin_disable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Persist Environment Variables (PowerShell)\nDESCRIPTION: Example PowerShell commands using setx to persist the environment variables, useful for storing secrets and configuration outside of the script. This allows the variables to be available across sessions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/README.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nsetx KEYVAULT_TENANT_ID ${env:KEYVAULT_TENANT_ID}\nsetx KEYVAULT_CLIENT_ID ${env:KEYVAULT_CLIENT_ID}\nsetx KEYVAULT_CLIENT_SECRET ${env:KEYVAULT_CLIENT_SECRET}\nsetx KEYVAULT_SUBSCRIPTION_ID ${env:KEYVAULT_SUBSCRIPTION_ID}\nsetx KEYVAULT_RESOURCE_GROUP ${env:KEYVAULT_RESOURCE_GROUP}\nsetx KEYVAULT_LOCATION ${env:KEYVAULT_LOCATION}\nsetx KEYVAULT_SKU ${env:KEYVAULT_SKU}\nsetx AZURE_KEYVAULT_URL ${env:AZURE_KEYVAULT_URL}\n```\n\n----------------------------------------\n\nTITLE: Installing CMake on Ubuntu 16.04\nDESCRIPTION: This snippet downloads and installs a specific version of CMake on Ubuntu 16.04 since the default version available via apt-get might be outdated. It downloads the CMake binary, extracts it, and installs it to the /usr directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nwget https://cmake.org/files/v3.18/cmake-3.18.3-Linux-x86_64.sh # Use latest version.\nsudo ./cmake-3.18.3-Linux-x86_64.sh --prefix=/usr\n```\n\n----------------------------------------\n\nTITLE: Add Static Library\nDESCRIPTION: Adds a static library target named CMSISDSPComplexMath.  This creates a library file that can be linked into other projects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(CMSISDSPComplexMath STATIC)\n```\n\n----------------------------------------\n\nTITLE: Configure Include Directories with CMake\nDESCRIPTION: This snippet adds the `${CMAKE_CURRENT_LIST_DIR}/inc` directory to the project's include directories. This allows the compiler to find header files located in that directory. The `PUBLIC` keyword indicates that this include directory is also required by other targets that link to this target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_host_controllers/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Pointer Declaration Style in MBedTLS\nDESCRIPTION: This snippet illustrates the preferred style for declaring pointers in MBedTLS, where the dereferencing operator (*) is prepended to the pointer name rather than appended to the type.  This improves code readability and clarity, especially when dealing with complex pointer types.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/tls13-support.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nmbedtls_ssl_context *ssl;\n```\n\n----------------------------------------\n\nTITLE: Defining Project and Language\nDESCRIPTION: Defines the project name and sets the programming language to C.  This is a fundamental step in setting up a CMake project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/core/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject (az_core_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Initialize CMake Project\nDESCRIPTION: This snippet initializes the CMake project by specifying the minimum required CMake version, setting a CMake policy, and defining the project name with C language support.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(regression_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: RSA Modulus (N) Definition\nDESCRIPTION: Defines the RSA modulus (N) as a hexadecimal string. The modulus is a critical component in RSA cryptography, forming part of both the public and private keys. It is the product of two large prime numbers, P and Q.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/rsa_priv.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nN = A1D46FBA2318F8DCEF16C280948B1CF27966B9B47225ED2989F8D74B45BD36049C0AAB5AD0FF003553BA843C8E12782FC5873BB89A3DC84B883D25666CD22BF3ACD5B675969F8BEBFBCAC93FDD927C7442B178B10D1DFF9398E52316AAE0AF74E594650BDC3C670241D418684593CDA1A7B9DC4F20D2FDC6F66344074003E211\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. This ensures that the CMake version used to build the project is compatible with the CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\n```\n\n----------------------------------------\n\nTITLE: Setting CMSIS-DSP Path\nDESCRIPTION: This snippet defines the paths to the CMSIS-DSP library. ROOT is expected to be defined on the command line during CMake execution. The DSP path is then set relative to the ROOT directory and added to the module path.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_svm_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Needed to include the configBoot module\n# Define the path to CMSIS-DSP (ROOT is defined on command line when using cmake)\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\n# Add DSP folder to module path\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: Adding ThreadX Assembly Sources in CMake\nDESCRIPTION: This CMake snippet defines assembly source files to be compiled and linked into the project. These assembly files implement core ThreadX functionality, including context switching, interrupt management, and timer interrupts. The `target_sources` command adds these files to the specified target, making them part of the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Definitions\nDESCRIPTION: This snippet defines sets of preprocessor definitions based on different features and build configurations, such as security, multipart support, digest authentication, GPTP (Precision Time Protocol), and VLAN support. These definitions are later used to configure the compilation process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/ptp/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(SECURE -DNX_WEB_HTTPS_ENABLE -DNX_TCPSERVER_ENABLE_TLS -DNX_SECURE_ENABLE_CLIENT_CERTIFICATE_VERIFY)\nset(MULTIPART -DNX_WEB_HTTP_MULTIPART_ENABLE)\nset(DIGEST -DNX_WEB_HTTP_DIGEST_ENABLE)\n\nset(GPTP -DNX_ENABLE_GPTP -DNX_PTP_CLIENT_TRANSPORT_UDP=0 -DNX_PTP_CLIENT_TRANSPORT_ETHERNET=1)\nset(VLAN -DNX_ENABLE_VLAN)\nset(gptp_slave_build ${GPTP} ${VLAN})\nset(gptp_master_build ${GPTP} ${VLAN} -DNX_PTP_ENABLE_MASTER)\n```\n\n----------------------------------------\n\nTITLE: Adding Bootutil Library with CMake\nDESCRIPTION: This CMake snippet defines a static library named 'bootutil'. It also specifies include directories for the library and lists the source files that should be compiled into the library. The include directories are split into public and private scopes, controlling their visibility to other libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/boot/bootutil/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(bootutil STATIC)\n\ntarget_include_directories(bootutil\n    PUBLIC\n        include\n    PRIVATE\n        src\n)\n\ntarget_sources(bootutil\n    PRIVATE\n        src/boot_record.c\n        src/bootutil_misc.c\n        src/caps.c\n        src/encrypted.c\n        src/fault_injection_hardening.c\n        src/fault_injection_hardening_delay_rng_mbedtls.c\n        src/image_ec.c\n        src/image_ec256.c\n        src/image_ed25519.c\n        src/image_rsa.c\n        src/image_validate.c\n        src/loader.c\n        src/swap_misc.c\n        src/swap_move.c\n        src/swap_scratch.c\n        src/tlv.c\n)\n```\n\n----------------------------------------\n\nTITLE: Include configLib Module\nDESCRIPTION: Includes the configLib module, which likely contains custom configuration functions for the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(configLib)\n```\n\n----------------------------------------\n\nTITLE: Creating test_utility Library CMake\nDESCRIPTION: Creates a static library named 'test_utility' from the specified source files. This library contains common testing utilities and is linked against all USBX test executables.  It also defines target compile definitions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_29\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(test_utility ${test_utility_files})\ntarget_link_libraries(test_utility PUBLIC azrtos::usbx azrtos::threadx azrtos::netxduo azrtos::filex)\ntarget_compile_definitions(test_utility PUBLIC CTEST FX_ENABLE_EXFAT)\n```\n\n----------------------------------------\n\nTITLE: Configuring static libraries\nDESCRIPTION: This block configures static libraries for Mbed TLS. It creates static libraries for mbedcrypto, mbedx509, and mbedtls, sets their output names, and links them against the necessary libraries and dependencies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\nif(USE_STATIC_MBEDTLS_LIBRARY)\n    add_library(${mbedcrypto_static_target} STATIC ${src_crypto})\n    set_target_properties(${mbedcrypto_static_target} PROPERTIES OUTPUT_NAME mbedcrypto)\n    target_link_libraries(${mbedcrypto_static_target} PUBLIC ${libs})\n\n    if(TARGET ${everest_target})\n        target_link_libraries(${mbedcrypto_static_target} PUBLIC ${everest_target})\n    endif()\n\n    if(TARGET ${p256m_target})\n        target_link_libraries(${mbedcrypto_static_target} PUBLIC ${p256m_target})\n    endif()\n\n    add_library(${mbedx509_static_target} STATIC ${src_x509})\n    set_target_properties(${mbedx509_static_target} PROPERTIES OUTPUT_NAME mbedx509)\n    target_link_libraries(${mbedx509_static_target} PUBLIC ${libs} ${mbedcrypto_static_target})\n\n    add_library(${mbedtls_static_target} STATIC ${src_tls})\n    set_target_properties(${mbedtls_static_target} PROPERTIES OUTPUT_NAME mbedtls)\n    target_link_libraries(${mbedtls_static_target} PUBLIC ${libs} ${mbedx509_static_target})\nendif(USE_STATIC_MBEDTLS_LIBRARY)\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Implementation in ThreadX\nDESCRIPTION: This code snippet demonstrates how to implement an Interrupt Service Routine (ISR) in assembly language that is compatible with ThreadX. The snippet shows the basic structure for an assembly ISR, including pushing and popping registers and branching back to the interrupted code.  It requires the .thumb_func directive for proper label creation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/gnu/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    .global  your_assembly_isr\n    .thumb_func\nyour_assembly_isr:\n    PUSH    {r0, lr}\n;\n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation Configuration for MDK-ARM\nDESCRIPTION: This code snippet demonstrates the memory allocation configuration for ThreadX using MDK-ARM. It suggests either defining the `RW_IRAM1` region in the \".sct\" scatter file or modifying the line in `tx_initialize_low_level.S` to match the memory region being used. This step ensures that ThreadX can access the available RAM.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_WebServer/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version and Policy\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.0.0 and enforces a specific policy (CMP0057) for handling installation prefixes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This CMake command configures the target sources for the specified project.  The PRIVATE keyword indicates that these sources are only used for this target and not exposed to other targets that link against it. The code between the BEGIN and END markers is where the actual source files would be listed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m0/iar/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Compiler Options\nDESCRIPTION: This snippet adds compiler options for the project, including C standard, debugging flags, diagnostics settings, and error handling.  It also includes build type specific compile options.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/crypto/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_compile_options(\n  -std=c99\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  -Werror\n  ${${CMAKE_BUILD_TYPE}})\n```\n\n----------------------------------------\n\nTITLE: Vectored IRQ Handler in Assembly\nDESCRIPTION: This assembly code illustrates an example IRQ handler (__tx_irq_example_handler) for vectored IRQ interrupts as defined in tx_initialize_low_level.s. It saves scratch registers and the SPSR before calling the vectored IRQ context save and restores context after the application ISR call.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/cortex_a7_smp/gnu/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nEXPORT  __tx_irq_example_handler\n__tx_irq_example_handler\n;\n;    /* Call context save to save system context.  */\n\n    STMDB   sp!, {r0-r3}                        ; Save some scratch registers\n    MRS     r0, SPSR                            ; Pickup saved SPSR\n    SUB     lr, lr, #4                          ; Adjust point of interrupt \n    STMDB   sp!, {r0, r10, r12, lr}             ; Store other scratch registers\n    BL      _tx_thread_vectored_context_save    ; Call the vectored IRQ context save\n;\n;    /* At this point execution is still in the IRQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use. Note \n;       that IRQ interrupts are still disabled upon return from the context\n;       save function.  */\n;\n;    /* Application ISR call goes here!  */\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Target Sources (Complex Conjugation)\nDESCRIPTION: Includes the complex conjugation source files (arm_cmplx_conj_f32.c, arm_cmplx_conj_q15.c, arm_cmplx_conj_q31.c) in the CMSISDSPComplexMath library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_conj_f32.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_conj_q15.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_conj_q31.c)\n```\n\n----------------------------------------\n\nTITLE: RTC Clock Source Definition (LSI)\nDESCRIPTION: This code snippet demonstrates how to define the RTC clock source as LSI (Low Speed Internal) oscillator. This is the default configuration, using the internal 32kHz RC oscillator as the clock source for the RTC.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples_LL/RTC/RTC_TimeStamp_Init/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define RTC_CLOCK_SOURCE_LSI\n```\n\n----------------------------------------\n\nTITLE: RSA Initialization with PKCS#1 v1.5 Padding - C\nDESCRIPTION: Illustrates initializing RSA with PKCS#1 v1.5 padding using the modified `mbedtls_rsa_init()` function. The simplified version of `mbedtls_rsa_init()` is used, as the padding parameter is no longer supported. This initialization assumes that the context `ctx` has already been declared.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/3.0-migration-guide.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n    mbedtls_rsa_init(ctx);\n```\n\n----------------------------------------\n\nTITLE: Adding Test Executables CMake\nDESCRIPTION: This code iterates through the `test_cases` list, creates an executable for each test case, links it with the `test_utility` library, and adds a test using CTest.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_40\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(test_case ${test_cases})\n  get_filename_component(test_name ${test_case} NAME_WE)\n  add_executable(${test_name} ${test_case})\n  target_link_libraries(${test_name} PRIVATE test_utility)\n  add_test(${CMAKE_BUILD_TYPE}::${test_name} ${test_name})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Environment Variables Parameter\nDESCRIPTION: Optional key-value pairs of parameters to set as environment variables to the shell. This allows injecting environment variables into the shell context where the scripts are executed, influencing their behavior.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\nType: Hashtable\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: @{}\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Including Configuration and Source Files\nDESCRIPTION: This snippet includes a configuration file named `config` and calls a function `configApp` to configure the application, passing in the executable target name and the ROOT directory. It also specifies the source files to be compiled into the executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_svm_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(config)\nconfigApp(arm_svm_example ${ROOT})\n\ntarget_sources(arm_svm_example PRIVATE arm_svm_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: RTC Clock Source Definition (LSE)\nDESCRIPTION: This code snippet shows how to define the RTC clock source as LSE (Low Speed External) oscillator. Uncommenting this line selects the external 32.768kHz crystal as the RTC clock source. To use LSE, it also requires configuring the STM32CubeMX project accordingly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples_LL/RTC/RTC_TimeStamp_Init/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n/* #define RTC_CLOCK_SOURCE_LSE */\n```\n\n----------------------------------------\n\nTITLE: Adding Compile and Link Options\nDESCRIPTION: This snippet adds compile and link options to the project. It sets options for 32-bit architecture, C99 standard, debugging information, diagnostic colors, and treats warnings as errors. It also includes a user-defined file and applies options based on the build type. Link options are set for 32-bit architecture as well. Testing is enabled for the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_compile_options(\n  -m32\n  -std=c99\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  -Werror\n  -DTX_INCLUDE_USER_DEFINE_FILE\n  ${${CMAKE_BUILD_TYPE}})\nadd_link_options(-m32)\n\nenable_testing()\n```\n\n----------------------------------------\n\nTITLE: Clean All Examples (PowerShell)\nDESCRIPTION: This command executes the azrtos_cicd.ps1 script with the -clean parameter. It removes all generated files from the examples listed in the default database (azrtos_cicd.csv). The pwsh -Command prefix executes the command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -clean\n```\n\n----------------------------------------\n\nTITLE: Create Source ZIP Archive\nDESCRIPTION: Creates a build target that generates a ZIP archive of all the project's source files. The CPACK_SOURCE_IGNORE_FILES variable is used to exclude certain files and directories from the archive, such as .git directories, build directories, and temporary files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# Enable a build target that produces a ZIP file of all sources\nset(CPACK_SOURCE_GENERATOR \"ZIP\")\nset(CPACK_SOURCE_IGNORE_FILES\n  \\\\.git/\n  \\\\.github/\n  _build/\n  \\\\.git\n  \\\\.gitattributes\n  \\\\.gitignore\n  \".*~$\"\n)\nset(CPACK_VERBATIM_VARIABLES YES)\ninclude(CPack)\n```\n\n----------------------------------------\n\nTITLE: Define DSP Source Directory\nDESCRIPTION: Defines the location of the DSP source files and adds it to the CMake module path to enable the use of custom modules.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nSET(DSP ${ROOT}/CMSIS/DSP)\n\nlist(APPEND CMAKE_MODULE_PATH ${DSP}/Source)\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This snippet uses the `target_sources` command in CMake to specify the source files for the project. The `PRIVATE` keyword indicates that these source files are only used within the specified target. The section between `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` is intended to be populated with the actual source file paths.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/linux/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Modify XML Content from Binary File (Bash)\nDESCRIPTION: This command uses the `xmlval` tool to extract a value from a binary file and update the `<Value>` tag of a specified parameter in an XML file. It extracts the value based on index and size parameters, using the `<Name>` tag in XML to find the index and the endianness and size parameter to read from the binary.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n xmlval -b AreaAPayload.bin -b_el_idx 48 -b_d_sz 16 -b_el_sz 64 -b_d_e little -nxml_el_idx \"Flash Layout configuration index\" -n \"NS FileSystem Size\" SMAK_Config_part2.xml\n```\n\n----------------------------------------\n\nTITLE: Minimum Synchronization Level Configuration\nDESCRIPTION: This parameter forces a minimum synchronization level. The values represent different levels of synchronization (0=off, 1=syncState, 2=postInsnIO, 3=postInsnAll). This setting impacts the level of data consistency enforced by the system.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/ARMCM3_config.txt#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\narmcortexm3ct.min_sync_level=3\n```\n\n----------------------------------------\n\nTITLE: Setting certificate path environment variable\nDESCRIPTION: This snippet sets the `AZ_IOT_DEVICE_X509_CERT_PEM_FILE_PATH` environment variable to the absolute path of the `device_cert_store.pem` file. This variable is used by the Azure SDK for Embedded C to locate the device certificate for authentication.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n~/azure-sdk-for-c/sdk/samples/iot$ export AZ_IOT_DEVICE_X509_CERT_PEM_FILE_PATH=$(pwd)/device_cert_store.pem\n```\n\n----------------------------------------\n\nTITLE: Setting Storage TX Test Cases Variable in CMake\nDESCRIPTION: This snippet defines a CMake variable, `ux_device_class_storage_tx_test_cases`, and assigns it a single source file related to storage tests. The file is a C file for storage testing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_device_class_storage_tx_test_cases ${SOURCE_DIR}/usbx_storage_tests.c)\n```\n\n----------------------------------------\n\nTITLE: Creating Test Utility Library CMake\nDESCRIPTION: This code snippet creates a library named `test_utility` from the files listed in the `test_utility_files` variable. It then links the library with the `azrtos::${PRODUCT}` library, sets include directories, and adds compile definitions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_37\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(test_utility ${test_utility_files})\ntarget_link_libraries(test_utility PUBLIC azrtos::${PRODUCT})\ntarget_include_directories(test_utility PUBLIC ${SOURCE_DIR}/test\n                                               ${SOURCE_DIR}/tahi_test)\ntarget_compile_definitions(test_utility PUBLIC BATCH_TEST CTEST)\n```\n\n----------------------------------------\n\nTITLE: Target Sources (Complex Magnitude)\nDESCRIPTION: Includes the complex magnitude source files (arm_cmplx_mag_f32.c, arm_cmplx_mag_f64.c) in the CMSISDSPComplexMath library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_f32.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_f64.c)\n```\n\n----------------------------------------\n\nTITLE: PSA Attributes and Key Import Functions in Mbed TLS (C)\nDESCRIPTION: These functions provide the capability to convert an existing `mbedtls_pk_context` to a PSA key, managing key attributes and importing the key into the PSA keystore.  `mbedtls_pk_get_psa_attributes` extracts the attributes from a PK context, and `mbedtls_pk_import_into_psa` imports the key into PSA, using provided attributes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-migration/psa-legacy-bridges.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nint mbedtls_pk_get_psa_attributes(const mbedtls_pk_context *pk,\n                                  psa_key_usage_flags_t usage,\n                                  psa_key_attributes_t *attributes);\nint mbedtls_pk_import_into_psa(const mbedtls_pk_context *pk,\n                               const psa_key_attributes_t *attributes,\n                               mbedtls_svc_key_id_t *key_id);\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM linker file modification for ThreadX\nDESCRIPTION: This snippet shows the modifications needed in the MDK-ARM linker file (.sct or tx_low_level_initilize.S) to enable dynamic memory allocation for ThreadX. It suggests defining the `RW_IRAM1` region in the .sct file or modifying the `tx_low_level_initilize.S` file to specify the memory region used. This allows ThreadX to manage memory dynamically.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_MultiAccess/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Adding DSP library subdirectory\nDESCRIPTION: This snippet adds the subdirectory '../../../Source' and names the resulting target 'bin_dsp'.  This allows linking against the CMSISDSP library which is built in that source directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project for NetXDuo Samples\nDESCRIPTION: This snippet sets the minimum required CMake version, establishes a CMake policy, and defines a project named 'samples' with the C language enabled. It initializes the source directory and an empty list to hold sample file paths.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/samples/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(samples LANGUAGES C)\n\nset(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../../samples)\n\nset(sample_files)\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker File Configuration for ThreadX Memory\nDESCRIPTION: This snippet describes the configuration needed in MDK-ARM linker file (.sct) or assembly file (tx_low_level_initilize.s) to manage the memory region for ThreadX. It involves defining the RW_IRAM1 region or modifying the assembly code to match the memory region used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_Thread_MsgQueue/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.s to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Define Libraries for Linking (CMake)\nDESCRIPTION: Defines a variable `libs` containing a target representing the mbedcrypto library. This variable is later used to link executables against this library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/util/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(libs\n    ${mbedcrypto_target}\n)\n```\n\n----------------------------------------\n\nTITLE: Define Project and Supported Configurations\nDESCRIPTION: Defines the project name and a list of supported build configurations. The `project` command sets the project name. The `set` command creates a list of build configurations which are then used to set the `CMAKE_CONFIGURATION_TYPES` cache variable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(netxduo_test LANGUAGES C)\n\n# Set build configurations\nset(BUILD_CONFIGURATIONS\n    default_build_coverage\n    dhcp_default_build_coverage\n    dns_default_build_coverage\n    tsn_build_coverage\n    v4_build\n    v4_dns_cache_build\n    v4_no_checksum_build\n    v4_physical_48_build\n    v4_small_build\n    v4_packet_pad_build\n    v4_full_build\n    v4_no_frag_build\n    v4_no_check_build\n    v4_no_reset_disconn_build\n    v4_dual_pool_build\n    v4_no_chain_build\n    v4_link_cap_build\n    v4_address_check_build\n    v6_build\n    v6_only_build\n    v6_only_link_cap_build\n    v6_no_checksum_build\n    v6_dual_pool_build\n    v6_packet_pad_build\n    v6_physical_48_build\n    v6_small_nd_cache_build\n    v6_small_build\n    v6_full_build\n    v6_no_frag_build\n    v6_pmtu_no_frag_build\n    v6_no_chain_build\n    v6_no_dad_build\n    v6_no_check_build\n    v6_no_icmpv6_error_build\n    v6_no_reset_disconn_build\n    v6_link_cap_build\n    v6_address_change_build\n    v6_multicast_build\n    v6_no_rs_build\n    v6_dhcp_tahi_build\n    v6_bsd_raw_build\n    v6_full_secure_build\n    optimize_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.13 and specifies that any errors during this check should be treated as fatal.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/libs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration\nDESCRIPTION: This snippet shows the configuration to add to the STM32CubeIDE linker file (.ld) to define a new section for the ThreadX heap.  It defines a 64KB heap within the RAM_D1 region and sets up the necessary alignment and memory boundary markers. This configuration enables ThreadX to use dynamic memory allocation within a defined memory region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Applications/ThreadX/Tx_LowPower/README.md#_snippet_2\n\nLANGUAGE: Other\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Build ThreadX Libraries\nDESCRIPTION: This snippet defines a custom target to build ThreadX libraries using a shell script.  It executes the `run.sh` script with the `build_libs` argument, making it an 'ALL' target to be built by default. It adds `netxduo` as a dependency and sets include directories and properties for the ThreadX library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh build_libs)\nadd_custom_target(build_libs ALL COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh\n                                         build_libs)\nadd_dependencies(netxduo build_libs)\ntarget_include_directories(netxduo PUBLIC ${CMAKE_BINARY_DIR}/../libs/inc)\nadd_library(threadx SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::threadx\" ALIAS threadx)\nset_target_properties(\n  threadx PROPERTIES IMPORTED_LOCATION\n                     ${CMAKE_BINARY_DIR}/../libs/threadx/libthreadx.so)\n```\n\n----------------------------------------\n\nTITLE: Standard IRQ Handler in ThreadX Assembly\nDESCRIPTION: This assembly code defines the default IRQ handler (__tx_irq_handler) in tx_initialize_low_level.s for ThreadX. It saves the system context and then restores it after the application ISR call(s). This handler manages standard ARM IRQ interrupts by jumping to context save and restore routines.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/cortex_a7_smp/ac5/readme_threadx.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\n    EXPORT  __tx_irq_handler\n    EXPORT  __tx_irq_processing_return      \n__tx_irq_handler\n;\n;    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save             ; Jump to the context save\n__tx_irq_processing_return\n;\n;    /* At this point execution is still in the IRQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use. Note \n;       that IRQ interrupts are still disabled upon return from the context\n;       save function.  */\n;\n;    /* Application ISR call(s) go here!  */\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Set Build Configurations\nDESCRIPTION: Defines the different build configurations supported by the project, such as default, coverage, free sector verify, full, standalone, and builds with new driver interface or cache options. It sets the `CMAKE_CONFIGURATION_TYPES` variable and enforces a valid build type.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(BUILD_CONFIGURATIONS default_build_coverage \n                         free_sector_verify_build \n                         full_build \n                         standalone_build\n                         standalone_free_sector_verify_build\n                         standalone_full_build\n                         new_driver_interface_build\n                         nor_obsolete_cache_build\n                         nor_mapping_cache_build\n                         nor_obsolete_mapping_cache_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: FIQ Interrupt Handler (Assembly)\nDESCRIPTION: This code snippet shows the default FIQ handler defined in tx_initialize_low_level.s when TX_ENABLE_FIQ_SUPPORT is defined. It jumps to context save and restore functions and includes a placeholder for the application's FIQ dispatch.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/iar/readme_threadx.txt#_snippet_4\n\nLANGUAGE: Assembly\nCODE:\n```\n    RSEG    .text:CODE:NOROOT(2)\n    PUBLIC  __tx_fiq_handler\n    RSEG    .text:CODE:NOROOT(2)\n    PUBLIC  __tx_fiq_processing_return\n__tx_fiq_handler\n;\n;    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return:\n;\n;    /* At this point execution is still in the FIQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use.  */\n;\n;    /* Application FIQ dispatch call goes here!  */\n;\n;    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: Removing CMake Cache\nDESCRIPTION: This snippet removes the CMake cache files using the `find` command. This is useful when you need to change compiler flags after an initial CMake invocation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_16\n\nLANGUAGE: Shell\nCODE:\n```\nfind . -iname '*cmake*' -not -name CMakeLists.txt -exec rm -rf {} +\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories\nDESCRIPTION: This snippet sets the include directories for the CMSISDSPController library, adding the `Include` directory located inside the DSP directory. The `PUBLIC` keyword makes this include directory available to other libraries that depend on CMSISDSPController.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ControllerFunctions/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(CMSISDSPController PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Adding RFFT source files (Q31) in CMake\nDESCRIPTION: This snippet conditionally adds Real FFT source files for Q31 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_20\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR RFFT_Q31_32 OR RFFT_Q31_64 OR RFFT_Q31_128 OR RFFT_Q31_256\n     OR RFFT_Q31_512 OR RFFT_Q31_1024 OR RFFT_Q31_2048 OR RFFT_Q31_4096 OR RFFT_Q31_8192)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_init_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_q31.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Dummy Python script to extract payload\nDESCRIPTION: This python script extracts payload from client to server traffic, based on the port number from a tcp dump, and outputs it in a form suitable for corpus generation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/fuzz/README.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nimport sys\nimport binascii\n\nf = open(sys.argv[1])\nfor l in f.readlines():\n    portAndPl=l.split()\n    if len(portAndPl) == 2:\n        # determine client or server based on port\n        if portAndPl[0] == \"4433\":\n            print(binascii.unhexlify(portAndPl[1].replace(\":\",\"\")))\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories using CMake\nDESCRIPTION: This CMake code adds the 'inc' directory within the current list directory to the include directories of the target specified by PROJECT_NAME. This ensures that header files located in the 'inc' directory can be found during compilation of the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_host_classes/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Defining ThreadX Source Files with CMake\nDESCRIPTION: This CMake snippet specifies the source files that are compiled and linked into the project.  It uses the `target_sources` command to add the listed `.c` and `.S` files to the specified project's PRIVATE scope, ensuring they are compiled as part of the project. The `${PROJECT_NAME}` and `${CMAKE_CURRENT_LIST_DIR}` variables provide the project name and current directory, respectively.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_allocate.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_free.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_low_level.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_allocate.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_free.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n)\n```\n\n----------------------------------------\n\nTITLE: Building with CMake - Linux\nDESCRIPTION: This code snippet shows how to build the project using CMake after the build files have been generated. It assumes you are in the build directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ncmake --build .\n```\n\n----------------------------------------\n\nTITLE: Removing XML Parameter by Name (xmlparam)\nDESCRIPTION: This snippet demonstrates how to remove an XML parameter based on its name. It uses the `-o rm` option with the parameter's name to delete it from the XML file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nxmlparam -o rm -n \"Encryption key\" OEMiRoT_Secure_Code.xml\n```\n\n----------------------------------------\n\nTITLE: Setting Target Sources with CMake\nDESCRIPTION: This CMake snippet defines the source files to be included in the target. It sets the PRIVATE property for the source files. The variable CURRENT_DIR is used to define the path to the source files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/ports_smp/linux/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(CURRENT_DIR ${PROJECT_DIR}/ports_smp/linux/gnu)\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CURRENT_DIR}/src/tx_initialize_low_level.c\n\t${CURRENT_DIR}/src/tx_thread_context_restore.c\n\t${CURRENT_DIR}/src/tx_thread_context_save.c\n\t${CURRENT_DIR}/src/tx_thread_interrupt_control.c\n\t${CURRENT_DIR}/src/tx_thread_schedule.c\n\t${CURRENT_DIR}/src/tx_thread_smp_core_get.c\n\t${CURRENT_DIR}/src/tx_thread_smp_core_preempt.c\n\t${CURRENT_DIR}/src/tx_thread_smp_current_state_get.c\n\t${CURRENT_DIR}/src/tx_thread_smp_current_thread_get.c\n\t${CURRENT_DIR}/src/tx_thread_smp_initialize_wait.c\n\t${CURRENT_DIR}/src/tx_thread_smp_low_level_initialize.c\n\t${CURRENT_DIR}/src/tx_thread_smp_protect.c\n\t${CURRENT_DIR}/src/tx_thread_smp_time_get.c\n\t${CURRENT_DIR}/src/tx_thread_smp_unprotect.c\n\t${CURRENT_DIR}/src/tx_thread_stack_build.c\n\t${CURRENT_DIR}/src/tx_thread_system_return.c\n\t${CURRENT_DIR}/src/tx_timer_interrupt.c\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Resuming a Thread with tm_thread_resume in C\nDESCRIPTION: This function resumes a previously created thread. It takes the thread_id as input and returns TM_SUCCESS if the resume operation is successful.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nint  tm_thread_resume(int thread_id);\n```\n\n----------------------------------------\n\nTITLE: Appending Test Utility Files CMake\nDESCRIPTION: This code snippet appends various C source files related to SMTP, SNMP, and MDNS utilities to the `test_utility_files` list. The MDNS utilities are specifically included when the `PRODUCT` variable is set to `netxduo` and `ENABLE_64` is not defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_36\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT \"$ENV{ENABLE_64}\")\n  list(\n    APPEND\n    test_utility_files\n    # SMTP utilities\n    ${SOURCE_DIR}/smtp_test/smtp_server_packets.c\n    # SNMP utilites\n    ${SOURCE_DIR}/snmp_test/get_snmp_v3_request.c\n    ${SOURCE_DIR}/snmp_test/snmp_manager_packets.c\n    ${SOURCE_DIR}/snmp_test/GetSet_Integers_Large_and_Neg_Numbers.c\n    ${SOURCE_DIR}/snmp_test/GetSet_IPv4v6Address.c\n    ${SOURCE_DIR}/snmp_test/GetSet_OctetStrings.c\n    ${SOURCE_DIR}/snmp_test/Get_Miscellaneous_Data_type.c\n    ${SOURCE_DIR}/snmp_test/small_mib_helper.c)\nendif()\n\nif(PRODUCT STREQUAL netxduo)\n  if(NOT \"$ENV{ENABLE_64}\")\n    list(\n      APPEND\n      test_utility_files\n      # MDNS utilities\n      ${SOURCE_DIR}/mdns_test/mdns_address_change_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_announcement_in_multiple_packets_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_basic_ipv6_announcement_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_basic_ipv6_query_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_basic_ipv6_response_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_case_insensitivity_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_client_passive_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_continuous_query_interval_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_continuous_query_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_continuous_query_unique_answer_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_dns_sd_query_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_dns_sd_response_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_duplicate_answer_suppression_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_duplicate_question_suppression_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_known_answer_ignored_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_known_answer_suppression_query_half_ttl_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_known_answer_suppression_query_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_known_answer_suppression_response_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_known_answer_suppression_unique_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_multiple_questions_per_query_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_poof_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_probing_conflict_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_query_and_response_chaos_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_query_during_probing_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_query_http_tcp_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_query_pdl_datastram_tcp_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_query_printer_tcp_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_query_rr_timeout_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_query_smb_tcp_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_query_start_stop_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_query_with_tc_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_response_aggregation_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_response_interval_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_response_in_multiple_packets_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_response_no_delay_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_response_to_address_query_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_response_with_tc_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_server_announcement_with_txt_test.c\n      ${SOURCE_DIR}/mdns_test/mdns_server_interface_reset.c\n      ${SOURCE_DIR}/mdns_test/mdns_server_send_goodbye_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_run_test_case.c\n      # PTP utilities\n      ${SOURCE_DIR}/ptp_test/netx_ptp_utility.c)\n  endif()\n  list(APPEND test_utility_files\n       # TAHI utilities\n       ${SOURCE_DIR}/tahi_test/netx_tahi_run_test_case.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories for CMSISDSP\nDESCRIPTION: This code snippet sets the include directories for the CMSISDSP interface library, allowing dependent targets to find the necessary header files.  `${DSP}/Include` refers to the path of the DSP include directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_40\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(CMSISDSP INTERFACE \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Importing Pre-built Libraries\nDESCRIPTION: This snippet imports pre-built libraries (ThreadX, NetXDuo, FileX) as SHARED libraries. It defines ALIAS targets for these libraries to be used with the azrtos namespace. It also specifies the imported location for each library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(threadx SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::threadx\" ALIAS threadx)\nset_target_properties(\n  threadx PROPERTIES IMPORTED_LOCATION\n                     ${CMAKE_BINARY_DIR}/../libs/threadx/libthreadx.so)\n\nadd_library(netxduo SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::netxduo\" ALIAS netxduo)\nset_target_properties(\n  netxduo PROPERTIES IMPORTED_LOCATION\n                     ${CMAKE_BINARY_DIR}/../libs/netxduo/libnetxduo.so)\n\nadd_library(filex SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::filex\" ALIAS filex)\nset_target_properties(\n  filex PROPERTIES IMPORTED_LOCATION\n                   ${CMAKE_BINARY_DIR}/../libs/filex/libfilex.so)\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories for NetX Crypto in CMake\nDESCRIPTION: This CMake snippet uses `target_include_directories` to specify the include directories for the NetX Crypto library within the specified project.  The `PUBLIC` keyword indicates that the specified include directory should be added to the include paths of any target that links against this target, enabling other parts of the project to find the necessary header files. The include directory is set to the 'inc' directory within the current CMake list directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/crypto_libraries/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} \n    PUBLIC \n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Creating az_iot_hub Library\nDESCRIPTION: Creates a static library named `az_iot_hub` from the specified C source files, sets include directories, and links dependencies. It depends on `az::core` and `az::iot::common`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/iot/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library (az_iot_hub\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_adu_client.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_hub_client.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_hub_client_sas.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_hub_client_telemetry.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_hub_client_c2d.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_hub_client_twin.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_hub_client_methods.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_hub_client_commands.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_hub_client_properties.c\n)\n\ntarget_include_directories (az_iot_hub\n  PUBLIC\n    ${az_SOURCE_DIR}/sdk/inc\n)\n\ntarget_link_libraries(az_iot_hub\n  PUBLIC\n    az::core\n    az::iot::common\n)\n\nadd_library (az::iot::hub ALIAS az_iot_hub)\n```\n\n----------------------------------------\n\nTITLE: Configuring shared libraries\nDESCRIPTION: This block configures shared libraries for Mbed TLS. It creates shared libraries for mbedcrypto, mbedx509, and mbedtls, sets their output names, versions and SOVERSION, and links them against the necessary libraries and dependencies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\nif(USE_SHARED_MBEDTLS_LIBRARY)\n    set(CMAKE_LIBRARY_PATH ${CMAKE_CURRENT_BINARY_DIR})\n    add_library(${mbedcrypto_target} SHARED ${src_crypto})\n    set_target_properties(${mbedcrypto_target} PROPERTIES VERSION 3.6.2 SOVERSION 16)\n    target_link_libraries(${mbedcrypto_target} PUBLIC ${libs})\n\n    if(TARGET ${everest_target})\n        target_link_libraries(${mbedcrypto_target} PUBLIC ${everest_target})\n    endif()\n\n    if(TARGET ${p256m_target})\n        target_link_libraries(${mbedcrypto_target} PUBLIC ${p256m_target})\n    endif()\n\n    add_library(${mbedx509_target} SHARED ${src_x509})\n    set_target_properties(${mbedx509_target} PROPERTIES VERSION 3.6.2 SOVERSION 7)\n    target_link_libraries(${mbedx509_target} PUBLIC ${libs} ${mbedcrypto_target})\n\n    add_library(${mbedtls_target} SHARED ${src_tls})\n    set_target_properties(${mbedtls_target} PROPERTIES VERSION 3.6.2 SOVERSION 21)\n    target_link_libraries(${mbedtls_target} PUBLIC ${libs} ${mbedx509_target})\nendif(USE_SHARED_MBEDTLS_LIBRARY)\n```\n\n----------------------------------------\n\nTITLE: Building No HTTP Client Library\nDESCRIPTION: This snippet builds the 'az_nohttp' static library, which provides a no-op HTTP client implementation. It adds the library source file and links it with the 'az_core' library. It also creates an alias for easier consumption.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/platform/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# HTTP Client\nadd_library (\n  az_nohttp\n    STATIC\n      ${CMAKE_CURRENT_LIST_DIR}/az_nohttp.c\n)\n\ntarget_link_libraries(az_nohttp PRIVATE az_core)\n\n# make sure that users can consume the project as a library.\nadd_library (az::nohttp ALIAS az_nohttp)\n```\n\n----------------------------------------\n\nTITLE: Configure CMSIS-DSP Interpolation Library Settings\nDESCRIPTION: This snippet configures the CMSIS-DSP Interpolation library by calling `configLib` and `configDsp`, passing the library name and the root directory. It also sets the include directories for the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/InterpolationFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nconfigLib(CMSISDSPInterpolation ${ROOT})\nconfigDsp(CMSISDSPInterpolation ${ROOT})\n\n### Includes\ntarget_include_directories(CMSISDSPInterpolation PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Coverage Configuration\nDESCRIPTION: Configures coverage builds by adding compile and link options for code coverage analysis using gcov. This block is executed when the CMAKE_BUILD_TYPE matches \".*_coverage\".\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(levelx PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(levelx PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding DCT4 source files (Q15) in CMake\nDESCRIPTION: This snippet conditionally adds various DCT4 source files for Q15 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR ALLFFT OR DCT4_Q15_128 OR DCT4_Q15_512 OR DCT4_Q15_2048 OR DCT4_Q15_8192)\ntarget_sources(CMSISDSPTransform PRIVATE arm_dct4_init_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_dct4_q15.c)\n\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_init_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_init_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_q15.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Checking AES-CMAC Support (Legacy API)\nDESCRIPTION: This code snippet demonstrates how to check for AES-CMAC support in the legacy Mbed TLS API. It verifies that both AES and CMAC modules are enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nif defined(MBEDTLS_AES_C) && defined(MBEDTLS_CMAC_C)\n```\n\n----------------------------------------\n\nTITLE: Defining Web Test Cases\nDESCRIPTION: This snippet defines a list of C source files that represent the web test cases. These files will be compiled into individual executables and added as tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(web_test_cases\n    ${SOURCE_DIR}/web_test/netx_https_api_test.c\n    ${SOURCE_DIR}/web_test/netx_web_basic_test.c\n    ${SOURCE_DIR}/web_test/netx_web_basic_ecc_test.c\n    ${SOURCE_DIR}/web_test/netx_web_head_basic_test.c\n    ${SOURCE_DIR}/web_test/netx_web_post_basic_test.c\n    ${SOURCE_DIR}/web_test/netx_web_put_basic_test.c\n    ${SOURCE_DIR}/web_test/netx_web_delete_basic_test.c\n    ${SOURCE_DIR}/web_test/netx_web_basic_authenticate_test.c\n    ${SOURCE_DIR}/web_test/netx_web_if_modified_since_test.c\n    ${SOURCE_DIR}/web_test/netx_web_get_content_length_test.c\n    ${SOURCE_DIR}/web_test/netx_web_request_in_multiple_packets_test.c\n    ${SOURCE_DIR}/web_test/netx_web_multipart_fragment_test.c\n    ${SOURCE_DIR}/web_test/netx_web_multipart_underflow_test.c\n    ${SOURCE_DIR}/web_test/netx_web_get_put_referred_URI_test.c\n    ${SOURCE_DIR}/web_test/netx_web_status_404_test.c\n    ${SOURCE_DIR}/web_test/netx_web_multiple_sessions_test.c\n    ${SOURCE_DIR}/web_test/netx_web_multiple_sessions_timeout_test.c\n    ${SOURCE_DIR}/web_test/netx_web_response_in_multiple_packets_test.c\n    ${SOURCE_DIR}/web_test/netx_web_connect_three_times_test.c\n    ${SOURCE_DIR}/web_test/netx_web_keep_alive_test.c\n    ${SOURCE_DIR}/web_test/netx_web_digest_authenticate_test.c\n    ${SOURCE_DIR}/web_test/netx_web_digest_authenticate_test2.c\n    ${SOURCE_DIR}/web_test/netx_web_server_content_process_test.c\n    ${SOURCE_DIR}/web_test/netx_web_concurrent_sessions_test.c\n    ${SOURCE_DIR}/web_test/netx_web_post_long_message_test.c\n    ${SOURCE_DIR}/web_test/netx_web_host_field_test.c\n    ${SOURCE_DIR}/web_test/netx_web_chunked_request_test.c\n    ${SOURCE_DIR}/web_test/netx_web_chunked_request_additional_test.c\n    ${SOURCE_DIR}/web_test/netx_web_chunked_response_test.c\n    ${SOURCE_DIR}/web_test/netx_web_chunked_response_process_test.c\n    ${SOURCE_DIR}/web_test/netx_web_chunked_response_packet_chain_test.c\n    ${SOURCE_DIR}/web_test/netx_web_client_cleanup_test.c\n    ${SOURCE_DIR}/web_test/netx_web_server_chunked_content_process_test.c\n    ${SOURCE_DIR}/web_test/netx_web_packet_allocate_test.c\n    ${SOURCE_DIR}/web_test/netx_web_status_code_test.c\n    ${SOURCE_DIR}/web_test/netx_web_secure_connect_fail_test.c\n    ${SOURCE_DIR}/web_test/netx_web_tcpserver_rst_test.c\n    ${SOURCE_DIR}/web_test/netx_web_tcpserver_two_listen_test.c\n    ${SOURCE_DIR}/web_test/netx_web_abnormal_test.c\n    ${SOURCE_DIR}/web_test/netx_web_client_send_fail_test.c\n    ${SOURCE_DIR}/web_test/netx_web_client_receive_no_packet_test.c\n    ${SOURCE_DIR}/web_test/netx_web_keep_alive_abnormal_test.c\n    ${SOURCE_DIR}/web_test/netx_web_one_session_test.c\n    ${SOURCE_DIR}/web_test/netx_web_server_type_get_extended_test.c\n    ${SOURCE_DIR}/web_test/netx_web_secure_reconnect_test.c\n    ${SOURCE_DIR}/web_test/netx_web_non_block_basic_test.c\n    ${SOURCE_DIR}/web_test/netx_web_non_block_reconnect_test.c\n    ${SOURCE_DIR}/web_test/netx_web_tcpserver_tls_fail_rst_test.c\n    ${SOURCE_DIR}/web_test/netx_web_invalid_release_test.c\n    ${SOURCE_DIR}/web_test/netx_web_certifiacte_verify_test.c\n    ${SOURCE_DIR}/web_test/netx_web_client_rst_test.c\n    ${SOURCE_DIR}/web_test/netx_web_basic_authenticate_empty_test.c\n    ${SOURCE_DIR}/web_test/netx_web_digest_authenticate_timeout_test.c)\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration\nDESCRIPTION: This snippet shows the required modification in the EWARM linker file (.icf) to define the memory region for dynamic memory allocation in ThreadX. The FREE_MEM section is placed in the RAM_region to be used by ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_Dual_Instance/README.md#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Configuring RFFT Fast Options (Single Precision) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Real FFT (RFFT) fast implementations for single-precision floating-point numbers (f32) with various sizes (32 to 4096). These options are used to customize the CMSIS-DSP library by selecting specific RFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\noption(RFFT_FAST_F32_32     \"rfft fast f32 32\"                  OFF)\noption(RFFT_FAST_F32_64     \"rfft fast f32 64\"                  OFF)\noption(RFFT_FAST_F32_128    \"rfft fast f32 128\"                 OFF)\noption(RFFT_FAST_F32_256    \"rfft fast f32 256\"                 OFF)\noption(RFFT_FAST_F32_512    \"rfft fast f32 512\"                 OFF)\noption(RFFT_FAST_F32_1024   \"rfft fast f32 1024\"                OFF)\noption(RFFT_FAST_F32_2048   \"rfft fast f32 2048\"                OFF)\noption(RFFT_FAST_F32_4096   \"rfft fast f32 4096\"                OFF)\n```\n\n----------------------------------------\n\nTITLE: Set Product Variable\nDESCRIPTION: Sets the product variable if it's not already defined. The `if(NOT PRODUCT)` condition checks if the `PRODUCT` variable is not defined. If not, it's set to \"netxduo\".\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT PRODUCT)\n  set(PRODUCT netxduo)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Set Define with image_macros_preprocessed_bl2.c\nDESCRIPTION: This command uses the `setdefine` tool to comment or uncomment a define variable in a header file based on the value of a macro found in `image_macros_preprocessed_bl2.c`. It searches for a specific macro in the file, compares its value to a specified value, and then comments or uncomment the defined variable accordingly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_19\n\nLANGUAGE: text\nCODE:\n```\nsetdefine -l image_macros_preprocessed_bl2.c -m RE_OVER_WRITE -name MCUBOOT_OVERWRITE_ONLY -v 1 File.h\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation for 32-bit or 64-bit\nDESCRIPTION: This snippet checks the environment variable ENABLE_64 to determine whether to build for 64-bit or 32-bit architecture. If building for 32-bit, it adds specific compiler and linker options.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# Control if it's for 64 bit or 32 bit\nif($ENV{ENABLE_64})\n  message(STATUS \"Building for 64bit\")\nelse()\n  add_compile_options(-m32)\n  add_link_options(-m32)\n  message(STATUS \"Building for 32bit\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditional Source File Inclusion for Float16\nDESCRIPTION: This snippet conditionally includes additional source files for float16 support based on the ARMAC5 and DISABLEFLOAT16 flags. If both flags are not set, it includes the float16 versions of the SVM initialization and prediction functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/SVMFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_linear_init_f16.c) \ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_rbf_init_f16.c)\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_linear_predict_f16.c)\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_rbf_predict_f16.c)\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_polynomial_init_f16.c)\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_sigmoid_init_f16.c)\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_polynomial_predict_f16.c)  \ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_sigmoid_predict_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Include ThreadX Port Configuration\nDESCRIPTION: Adds a subdirectory based on the THREADX_CUSTOM_PORT variable, or a default port configuration from the ports directory if THREADX_CUSTOM_PORT is not defined. The default path structure is ports/${THREADX_ARCH}/${THREADX_TOOLCHAIN}.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Pick up the port specific variables and apply them\nif(DEFINED THREADX_CUSTOM_PORT)\n    add_subdirectory(${THREADX_CUSTOM_PORT} threadx_port)\nelse()\n    add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/ports/${THREADX_ARCH}/${THREADX_TOOLCHAIN})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Deploy test resources using an existing service principal (PowerShell)\nDESCRIPTION: This example shows how to deploy test resources and grant ownership to an existing service principal identified by its application ID and secret. It configures the BaseName, ServiceDirectory, SubscriptionId, ResourceGroupName, Location, TestApplicationId, and TestApplicationSecret parameters. It also assumes that Connect-AzAccount has already been run to authenticate.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nConnect-AzAccount -Subscription 'REPLACE_WITH_SUBSCRIPTION_ID'\nNew-TestResources.ps1 `\n    -BaseName 'azsdk' `\n    -ServiceDirectory 'keyvault' `\n    -SubscriptionId 'REPLACE_WITH_SUBSCRIPTION_ID' `\n    -ResourceGroupName 'REPLACE_WITH_NAME_FOR_RESOURCE_GROUP' `\n    -Location 'eastus' `\n    -TestApplicationId 'REPLACE_WITH_TEST_APPLICATION_ID' `\n    -TestApplicationSecret 'REPLACE_WITH_TEST_APPLICATION_SECRET'\n```\n\n----------------------------------------\n\nTITLE: Add Source File to Target (CMake)\nDESCRIPTION: This CMake code snippet adds `ux_network_driver.c` to the target's private source list. It specifies that the source file is located in the `src` directory relative to the current CMake list file's directory. The `target_sources` command links source files to the specified target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_network/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_network_driver.c\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: User Option Bytes Configuration - TrustZone C\nDESCRIPTION: This code shows the User Option Bytes configuration needed to run the example with TrustZone enabled. TZEN enables TrustZone. SECWM1_PSTRT/PEND defines the secure sectors for Bank1, and SECWM2_PSTRT/PEND defines the non-secure sectors for Bank2.  These settings are crucial for memory isolation between secure and non-secure applications.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples/GPIO/GPIO_IOToggle_TrustZone/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n    - TZEN=B4\n    - SECWM1_PSTRT=0x0  SECWM1_PEND=0x7F  meaning all 128 sectors of Bank1 set as secure\n    - SECWM2_PSTRT=0x7F SECWM2_PEND=0x0   meaning all 128 sectors of Bank2 set as non_secure\n```\n\n----------------------------------------\n\nTITLE: Setting vcpkg Environment Variables - Linux\nDESCRIPTION: This code snippet shows how to set the VCPKG_DEFAULT_TRIPLET and VCPKG_ROOT environment variables in a Linux environment. It's crucial for the build process to locate vcpkg dependencies. Replace <FULL PATH to vcpkg> with the actual path to your vcpkg installation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nexport VCPKG_DEFAULT_TRIPLET=x64-linux\nexport VCPKG_ROOT=<FULL PATH to vcpkg>\n```\n\n----------------------------------------\n\nTITLE: Default IRQ Handler in Assembly\nDESCRIPTION: This assembly code defines the default IRQ handler (__tx_irq_handler) in tx_initialize_low_level.S. It jumps to the context save routine (_tx_thread_context_save), and after application-specific ISR calls, jumps to the context restore routine (_tx_thread_context_restore). This handler is used when a standard ARM IRQ occurs, triggered at address 0x18.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac6/readme_threadx.txt#_snippet_0\n\nLANGUAGE: Assembly\nCODE:\n```\n    .global __tx_irq_handler\n    .global __tx_irq_processing_return      \n__tx_irq_handler:\n@\n@    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save             @ Jump to the context save\n__tx_irq_processing_return:\n@\n@    /* At this point execution is still in the IRQ mode. The CPSR, point of\n@       interrupt, and all C scratch registers are available for use. Note \n@       that IRQ interrupts are still disabled upon return from the context\n@       save function.  */\n@\n@    /* Application ISR call(s) go here!  */\n@\n@    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Filtering USBX Sources for Standalone Build\nDESCRIPTION: This CMake code block conditionally filters the source files, include directories, and linked libraries of the `usbx` target based on the `CMAKE_BUILD_TYPE`. It uses `list(FILTER)` to exclude files whose names match the values defined in the `UX_STANDALONE_*_EXCLUDES` variables. It also updates target properties to reflect the changes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES \"standalone.*\")\n  get_target_property(test_utility_SOURCES_LIST test_utility SOURCES)\n  get_target_property(SOURCES_LIST usbx SOURCES)\n  get_target_property(INCLUDES_LIST usbx INCLUDE_DIRECTORIES)\n\n  if(\"${CMAKE_BUILD_TYPE}\" STREQUAL \"standalone_build_coverage\")\n    # TODO: enable when STANDALONE implement is done\n    # Remove files not support STANDALONE yet\n    foreach(EXCLUDE_VAL ${UX_STANDALONE_HOST_EXCLUDES}\n                        ${UX_STANDALONE_DEVICE_EXCLUDES}\n                        ${UX_STANDALONE_UTILITY_EXCLUDES}\n                        ${UX_STANDALONE_PICTBRIDGE_EXCLUDES}\n                        ${UX_STANDALONE_NX_EXCLUDES}\n                        ${UX_STANDALONE_FX_EXCLUDES})\n      list(FILTER test_utility_SOURCES_LIST EXCLUDE REGEX \".*${EXCLUDE_VAL}.*\")\n      list(FILTER SOURCES_LIST EXCLUDE REGEX \".*${EXCLUDE_VAL}.*\")\n    endforeach()\n    # Update includes to remove TX,FX,NX libs\n    list(FILTER INCLUDES_LIST EXCLUDE REGEX \".*externals.*\")\n    list(FILTER INCLUDES_LIST EXCLUDE REGEX \".*/libs/inc.*\")\n    # Update library links to remove TX,FX,NX libs\n    set_target_properties(usbx PROPERTIES LINK_LIBRARIES \"\")\n    set_target_properties(usbx PROPERTIES INTERFACE_LINK_LIBRARIES \"\")\n\n  elseif(\"${CMAKE_BUILD_TYPE}\" STREQUAL \"standalone_device_build_coverage\")\n    # Only device part linked with STANDALONE\n    # Remove files not support STANDALONE yet\n    foreach(EXCLUDE_VAL ${UX_STANDALONE_DEVICE_EXCLUDES})\n      list(FILTER SOURCES_LIST EXCLUDE REGEX \".*${EXCLUDE_VAL}.*\")\n      list(FILTER test_utility_SOURCES_LIST EXCLUDE REGEX \".*${EXCLUDE_VAL}.*\")\n    endforeach()\n\n  elseif(\"${CMAKE_BUILD_TYPE}\" STREQUAL \"standalone_host_build_coverage\")\n    # Only host part linked with STANDALONE\n    # Remove files not support STANDALONE yet\n    foreach(EXCLUDE_VAL ${UX_STANDALONE_HOST_EXCLUDES})\n      list(FILTER SOURCES_LIST EXCLUDE REGEX \".*${EXCLUDE_VAL}.*\")\n      list(FILTER test_utility_SOURCES_LIST EXCLUDE REGEX \".*${EXCLUDE_VAL}.*\")\n    endforeach()\n\n  elseif(\"${CMAKE_BUILD_TYPE}\" STREQUAL \"standalone_otg_build\")\n    # Only some stack file linked with STANDALONE\n    # No file list change for now\n  endif()\n\n  # Commit sources and includes changes\n  set_target_properties(test_utility PROPERTIES SOURCES \"${test_utility_SOURCES_LIST}\")\n  set_target_properties(usbx PROPERTIES SOURCES \"${SOURCES_LIST}\")\n  set_target_properties(usbx PROPERTIES INCLUDE_DIRECTORIES \"${INCLUDES_LIST}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Minimum Synchronization Level Configuration\nDESCRIPTION: This parameter forces a minimum synchronization level, affecting the level of synchronization performed. The options are 0=off=default, 1=syncState, 2=postInsnIO, 3=postInsnAll. It's an integer value configurable at run-time.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/ARMCM3_config.txt#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.min_sync_level=3                        # (int   , run-time ) default = '0x0'    : force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories\nDESCRIPTION: Sets the include directories for the `CMSISDSPFastMath` target.  It specifies the directory containing the header files for the library, allowing other parts of the project to include these headers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(CMSISDSPFastMath PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Creating Executables for Each Test Case\nDESCRIPTION: This snippet iterates through a list of test cases, creates an executable for each, and links it against the `test_utility` library. It extracts the test name from the filename, adds an executable with that name using the test case source, links the `test_utility` library to the executable, and adds a test to CTest.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/regression/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(test_case ${regression_test_cases} ${regression_test_cases_exfat})\n  get_filename_component(test_name ${test_case} NAME_WE)\n  add_executable(${test_name} ${test_case})\n  target_link_libraries(${test_name} PRIVATE test_utility)\n  add_test(${CMAKE_BUILD_TYPE}::${test_name} ${test_name})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries\nDESCRIPTION: Links the CMSISDSP library to the executable target. Ensures that the necessary CMSIS-DSP functions are available at runtime.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_variance_example/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(arm_variance_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Cortex-M ISR in C with ThreadX\nDESCRIPTION: This code snippet demonstrates how to write an Interrupt Service Routine (ISR) in C that is compatible with ThreadX on Cortex-M. The ISR can access ThreadX API functions. The ISR function should be defined as an entry in the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/ac5/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: File Globbing for Source Files\nDESCRIPTION: Uses the file(GLOB) command to find all source files matching specific patterns based on floating-point and integer data types (f64, f32, f16, q31, q15, q7, u32, u16, u8). The found files are stored in variables (SRCF64, SRCF32, etc.) for later use in defining the library sources. This allows for easy inclusion of all relevant source files based on their naming convention.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/BasicMathFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SRCF64 \"./*_f64.c\")\nfile(GLOB SRCF32 \"./*_f32.c\")\nfile(GLOB SRCF16 \"./*_f16.c\")\nfile(GLOB SRCQ31 \"./*_q31.c\")\nfile(GLOB SRCQ15 \"./*_q15.c\")\nfile(GLOB SRCQ7  \"./*_q7.c\")\n\nfile(GLOB SRCU32 \"./*_u32.c\")\nfile(GLOB SRCU16 \"./*_u16.c\")\nfile(GLOB SRCU8  \"./*_u8.c\")\n```\n\n----------------------------------------\n\nTITLE: Define posix_get_pthread_errno Function Prototype in C\nDESCRIPTION: Defines the prototype for the `posix_get_pthread_errno` function. This function retrieves the last generated error code for the specified pthread ID (ptid).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nINT   posix_get_pthread_errno(pthread_t ptid)\n```\n\n----------------------------------------\n\nTITLE: Build Examples Matching Keywords (PowerShell)\nDESCRIPTION: This command builds examples matching the keywords 'TX ', 'ARM compiler v6', and 'Cortex M'.  It targets ThreadX examples for Cortex M using the ARM compiler v6. The pwsh -Command prefix is used for executing this command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_9\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','ARM compiler v6','Cortex M' -build\n```\n\n----------------------------------------\n\nTITLE: Creating Executables and Linking Libraries\nDESCRIPTION: This snippet iterates through the list of sample files, creates an executable for each, and links it against the FileX and LevelX libraries.  It extracts the filename without extension to be used as the executable name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/samples/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(sample_file ${sample_files})\n  get_filename_component(sample_file_name ${sample_file} NAME_WE)\n  add_executable(${sample_file_name} ${sample_file})\n  target_link_libraries(${sample_file_name} PRIVATE azrtos::filex)\n  target_link_libraries(${sample_file_name} PRIVATE azrtos::levelx)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Configuring the Application\nDESCRIPTION: This snippet includes a custom configuration file (config.cmake) and calls the configApp function to configure the arm_convolution_example application. It passes the executable name and the root directory as arguments.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_convolution_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(config)\nconfigApp(arm_convolution_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE linker file modification for ThreadX\nDESCRIPTION: This snippet shows the modification needed in the STM32CubeIDE linker (.ld) file to enable dynamic memory allocation for ThreadX. It adds a new section named `._threadx_heap` in the RAM_D1 region and sets its size to 64KB. The section must be placed between the .bss and ._user_heap_stack sections to ensure proper memory allocation for ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_MultiAccess/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Setting Key Lifetime for Opaque RSA Keys in PSA\nDESCRIPTION: This code snippet demonstrates how to set the key lifetime for an opaque RSA key within the PSA framework. It utilizes `psa_set_key_lifetime` to configure the key's location and persistence, associating it with a specific driver location (MY_RSA_DRIVER_LOCATION) and making it volatile. The key is then handled by the specified driver, enhancing security by isolating the private key.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_44\n\nLANGUAGE: c\nCODE:\n```\npsa_set_key_lifetime(&attributes, PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(\n        PSA_KEY_PERSISTENCE_VOLATILE, MY_RSA_DRIVER_LOCATION));\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker File Modification for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows the modifications needed for the STM32CubeIDE linker file (.ld) to allocate a specific memory section for ThreadX. The snippet defines a new section named ._threadx_heap within the RAM_D1 region, setting its size to 64KB. This allows ThreadX to use dynamic memory allocation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/FX_IAP/IAP_main/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Managed ISR Template in ThreadX Assembly\nDESCRIPTION: This code snippet shows the standard assembly template for managed Interrupt Service Routines (ISRs) in ThreadX for Cortex-M. It includes pushing and popping registers to maintain the context, allowing safe access to ThreadX services from within the ISR. The ISR is declared as a thumb function.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/ac6/readme_threadx.txt#_snippet_0\n\nLANGUAGE: Assembly\nCODE:\n```\n        .global  __tx_IntHandler\n        .thumb_func\n__tx_IntHandler:\n; VOID InterruptHandler (VOID)\n; {\n        PUSH    {r0, lr}\n\n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n        POP     {r0, lr}\n        BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Creating Executables for Each Sample File\nDESCRIPTION: This snippet iterates through the list of sample files. For each file, it extracts the filename, creates an executable with that name, adds the sample file and a regression test driver as sources, sets the compile options to include -DSAMPLE_BUILD, and links the executable to the azrtos::filex library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/samples/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(sample_file ${sample_files})\n  get_filename_component(sample_file_name ${sample_file} NAME_WE)\n  add_executable(${sample_file_name} ${sample_file}\n                 ${CMAKE_CURRENT_LIST_DIR}/../../regression_test/fx_ram_driver_test.c)\n  target_compile_options(${sample_file_name} PRIVATE -DSAMPLE_BUILD)\n  target_link_libraries(${sample_file_name} PRIVATE azrtos::filex)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: MD Light Conditional Definition\nDESCRIPTION: This code snippet demonstrates how the `MBEDTLS_MD_CAN_SHA256` macro is defined based on the availability of either the legacy SHA256 implementation (`MBEDTLS_SHA256_C`) or the PSA crypto SHA-256 algorithm (`PSA_WANT_ALG_SHA_256`) when MD light is enabled (`MBEDTLS_MD_LIGHT`). This allows the MD layer to select the appropriate implementation at compile time.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-migration/md-cipher-dispatch.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#if defined(MBEDTLS_MD_LIGHT)\n#if defined(MBEDTLS_SHA256_C) || \\\n    (defined(MBEDTLS_PSA_CRYPTO_C) && PSA_WANT_ALG_SHA_256)\n#define MBEDTLS_MD_CAN_SHA256\n#endif\n#endif\n```\n\n----------------------------------------\n\nTITLE: ETH Initialization - MAC Address Configuration in C\nDESCRIPTION: This code snippet initializes the Ethernet peripheral (ETH) and configures the MAC address. It sets the MAC address components to specific hexadecimal values.  It's crucial to ensure that the MAC address is unique within the network to avoid traffic conflicts.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/NetXDuo/Nx_SNTP_Client/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid MX_ETH_Init(void)\n{\n\n  /* USER CODE BEGIN ETH_Init 0 */\n\n  /* USER CODE END ETH_Init 0 */\n\n  /* USER CODE BEGIN ETH_Init 1 */\n\n  /* USER CODE END ETH_Init 1 */\n  heth.Instance = ETH;\n  MACAddr[0] = 0x00;\n  MACAddr[1] = 0x80;\n  MACAddr[2] = 0xE1;\n  MACAddr[3] = 0x00;\n  MACAddr[4] = 0x00;\n  MACAddr[5] = 0x00;\n\n```\n\n----------------------------------------\n\nTITLE: Vectored IRQ Handler Example in Assembly\nDESCRIPTION: This assembly code provides an example of a vectored IRQ handler (__tx_irq_example_handler) in tx_initialize_low_level.s.  It saves scratch registers (r0-r3), the saved SPSR, adjusts the point of interrupt, and stores other scratch registers onto the stack. This prepares the system for handling a vectored interrupt.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac5/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nEXPORT  __tx_irq_example_handler\n__tx_irq_example_handler\n;\n;    /* Call context save to save system context.  */\n\n    STMDB   sp!, {r0-r3}                        ; Save some scratch registers\n    MRS     r0, SPSR                            ; Pickup saved SPSR\n    SUB     lr, lr, #4                          ; Adjust point of interrupt \n    STMDB   sp!, {r0, r10, r12, lr}             ; Store other scratch registers\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion - Float16 Functions\nDESCRIPTION: Conditionally includes source files for float16 functions, checking that ARMAC5 is not defined and DISABLEFLOAT16 is not defined. This likely indicates that the ARM architecture is not AC5 and float16 support is not disabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPFastMath PRIVATE arm_vlog_f16.c)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_vexp_f16.c)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_vinverse_f16.c)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_atan2_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Define Executables with CMake\nDESCRIPTION: This snippet defines a list of executables.  The `set` command creates a CMake variable named `executables` and assigns a list of executable names (in this case, `crypt_and_hash`) to it.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/aes/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(executables\n    crypt_and_hash\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Project Name\nDESCRIPTION: Defines the name of the CMake project. This name is used for various purposes within the CMake build system, such as defining targets and generating project files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(CMSISDSPFastMath)\n```\n\n----------------------------------------\n\nTITLE: Project Definition\nDESCRIPTION: Defines the project name as CMSISDSPFiltering. This sets the name of the project within the CMake environment, which can be used for generating build systems.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nproject(CMSISDSPFiltering)\n```\n\n----------------------------------------\n\nTITLE: Configuring RFFT Fast Options (F16) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Real FFT (RFFT) fast implementations for F16 floating-point numbers with various sizes (32 to 4096). These options are used to customize the CMSIS-DSP library by selecting specific RFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_16\n\nLANGUAGE: CMake\nCODE:\n```\noption(RFFT_FAST_F16_32     \"rfft fast f16 32\"                  OFF)\noption(RFFT_FAST_F16_64     \"rfft fast f16 64\"                  OFF)\noption(RFFT_FAST_F16_128    \"rfft fast f16 128\"                 OFF)\noption(RFFT_FAST_F16_256    \"rfft fast f16 256\"                 OFF)\noption(RFFT_FAST_F16_512    \"rfft fast f16 512\"                 OFF)\noption(RFFT_FAST_F16_1024   \"rfft fast f16 1024\"                OFF)\noption(RFFT_FAST_F16_2048   \"rfft fast f16 2048\"                OFF)\noption(RFFT_FAST_F16_4096   \"rfft fast f16 4096\"                OFF)\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Definition for ThreadX with IAR\nDESCRIPTION: This code snippet illustrates the structure of an Interrupt Service Routine (ISR) written in assembly language for use with ThreadX on Cortex-M processors using IAR tools. It showcases the necessary stack manipulation (pushing and popping registers) and the return instruction (BX lr) required for proper ISR execution.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/iar/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nPUBLIC  your_assembly_isr\nyour_assembly_isr:\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation - MDK-ARM\nDESCRIPTION: This snippet presents two options for configuring ThreadX memory in Keil MDK-ARM. It involves either defining the RW_IRAM1 region in the scatter file (.sct) or modifying the tx_initialize_low_level.S file to match the memory region being used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Applications/USBX/Ux_Device_CDC_ACM/README.md#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n        LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Semihosting Enable Configuration\nDESCRIPTION: This parameter enables or disables semihosting SVC traps. Setting it to '0' disables semihosting, which is required for applications that do not use this feature. Semihosting allows the target application to communicate with the host development system for input/output operations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/ARMCM3_config.txt#_snippet_0\n\nLANGUAGE: Configuration\nCODE:\n```\narmcortexm3ct.semihosting-enable=0                    # (bool  , init-time) default = '1'      : Enable semihosting SVC traps. Applications that do not use semihosting must set this parameter to false.\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation: IPv6 Sample\nDESCRIPTION: This snippet adds the DHCPv6 client sample file (`demo_netxduo_dhcpv6_client.c`) to the `sample_files` list if the `-DNX_DISABLE_IPV6` flag is NOT present in the `CMAKE_BUILD_TYPE`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/samples/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT (\"-DNX_DISABLE_IPV6\" IN_LIST ${CMAKE_BUILD_TYPE}))\n  list(APPEND sample_files ${SOURCE_DIR}/demo_netxduo_dhcpv6_client.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Checking AES-CBC-PKCS7 support (Legacy API)\nDESCRIPTION: This code snippet demonstrates how to check if AES-CBC-PKCS7 is supported in the legacy Mbed TLS API. It checks for the definitions of `MBEDTLS_AES_C`, `MBEDTLS_CIPHER_MODE_CBC`, and `MBEDTLS_CIPHER_PADDING_PKCS7`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#if defined(MBEDTLS_AES_C) && \\\n    defined(MBEDTLS_CIPHER_MODE_CBC) && defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n```\n\n----------------------------------------\n\nTITLE: Adding CFFT Radix4 Init Q31 source files in CMake\nDESCRIPTION: This snippet conditionally adds arm_cfft_radix4_init_q31.c as a private source files to the CMSISDSPTransform library if WRAPPER is defined or ARM_CFFT_RADIX4_Q31 is defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_24\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE  OR ALLFFT OR ARM_CFFT_RADIX4_Q31)\n  target_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_init_q31.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Getting the String Value of a JSON Token in C\nDESCRIPTION: Gets the JSON token's string after unescaping it, if required. It requires a pointer to the reader instance, a buffer to copy the string into, the size of the buffer, and a pointer to a variable to store the number of bytes copied. On success, it returns NX_AZURE_IOT_SUCCESS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_9\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_token_string_get(NX_AZURE_IOT_JSON_READER *reader_ptr,\n                                               UCHAR *buffer_ptr, UINT buffer_size, UINT *bytes_copied);\n```\n\n----------------------------------------\n\nTITLE: Reading Version from Header File\nDESCRIPTION: Reads the Azure SDK version from the specified header file (`az_version.h`). It extracts the major, minor, and patch versions, as well as an optional pre-release identifier, using regular expressions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/core/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(AZ_SDK_VERSION_H_FILE \"${az_SOURCE_DIR}/sdk/inc/azure/core/az_version.h\")\n\nif(EXISTS ${AZ_SDK_VERSION_H_FILE})\n    file (STRINGS ${AZ_SDK_VERSION_H_FILE} VERSION_H_CONTENT)\n    message(STATUS \"Read version from ${AZ_SDK_VERSION_H_FILE}\")\n\n    #Find and read the AZ_SDK_VERSION_STRING define\n    string(REGEX MATCHALL \"#define AZ_SDK_VERSION_STRING \\\"([0-9]+)\\.([0-9]+)\\.([0-9]+)(\\-[^\\\"\\-]+)?\\\"\" VERSION_PARTS ${VERSION_H_CONTENT})\n\n    #Ensure we matched as expected.\n    #   MAJOR.AZ_VERSION_MINOR.PATCH are required.\n    #   PRERELEASE is optional.\n    if(NOT CMAKE_MATCH_1 AND NOT CMAKE_MATCH_2 AND NOT CMAKE_MATCH_3)\n        message(FATAL_ERROR \"Unexpected version format in ${AZ_SDK_VERSION_H_FILE}\")\n    endif()\n    set(AZ_SDK_VERSION_MAJOR ${CMAKE_MATCH_1} )\n    set(AZ_SDK_VERSION_MINOR ${CMAKE_MATCH_2} )\n    set(AZ_SDK_VERSION_PATCH ${CMAKE_MATCH_3} )\n    if(CMAKE_MATCH_4)\n        #Trim off the \"-\" from the start of pre-release portion\n        # https://cmake.org/cmake/help/v3.10/command/string.html?highlight=substring#substring\n        string(SUBSTRING ${CMAKE_MATCH_4} 1 -1 PRERELEASE_SUBSTRING )\n        set(AZ_SDK_VERSION_PRERELEASE ${PRERELEASE_SUBSTRING})\n    endif()\n    message(STATUS \"AZ_SDK_VERSION_MAJOR \" ${AZ_SDK_VERSION_MAJOR})\n    message(STATUS \"AZ_SDK_VERSION_MINOR \" ${AZ_SDK_VERSION_MINOR})\n    message(STATUS \"AZ_SDK_VERSION_PATCH \" ${AZ_SDK_VERSION_PATCH})\n    message(STATUS \"AZ_SDK_VERSION_PRERELEASE \" ${AZ_SDK_VERSION_PRERELEASE})\nelse()\n  message(FATAL_ERROR \"Missing Version file ${AZ_SDK_VERSION_H_FILE}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This snippet uses the `target_sources` command in CMake to specify private source files for the project. The `${PROJECT_NAME}` variable refers to the name of the project, and the `PRIVATE` keyword indicates that the specified sources are only used within this target. The section between `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` is intended to be populated with a list of source files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/ports/cortex_m0/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Algorithm specification example (C Macro)\nDESCRIPTION: This set of algorithm specification examples shows different ways to define algorithms using `PSA_ALG_xxx` macros. The algorithm specification defines a string consisting of the `PSA_ALG_xxx` macro that specifies a cryptographic algorithm. Each argument must be an algorithm specification or a decimal or hexadecimal literal with no suffix, depending on the expected type of argument.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nPSA_ALG_SHA_256\nPSA_ALG_HMAC(PSA_ALG_SHA_256)\nPSA_ALG_KEY_AGREEMENT(PSA_ALG_ECDH, PSA_ALG_HKDF(PSA_ALG_SHA_256))\nPSA_ALG_RSA_PSS(PSA_ALG_ANY_HASH)\n```\n\n----------------------------------------\n\nTITLE: Apache License Boilerplate\nDESCRIPTION: This snippet shows the boilerplate text that should be included in your files to apply the Apache 2.0 license. Replace `{yyyy}` with the copyright year and `{name of copyright owner}` with the name of the copyright holder.  Ensure the text is enclosed in the appropriate comment syntax for the file format.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ROT/OEMiROT_Boot/APACHE-2.0.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nCopyright {yyyy} {name of copyright owner}\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Addition (f16)\nDESCRIPTION: This snippet conditionally adds several source files related to f16 data types to the CMSISDSPMatrix target if ARMAC5 is not defined and DISABLEFLOAT16 is not defined.  These source files implement various matrix operations for the f16 data type, such as addition, subtraction, multiplication, and inverse.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/MatrixFunctions/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_add_f16.c)\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_sub_f16.c)\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_trans_f16.c)\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_scale_f16.c)\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_mult_f16.c)\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_vec_mult_f16.c)\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_cmplx_trans_f16.c)\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_cmplx_mult_f16.c)\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_inverse_f16.c)\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_init_f16.c)\ntarget_sources(CMSISDSPMatrix PRIVATE arm_mat_cholesky_f16.c)\n\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditional NAT Test Cases in CMake\nDESCRIPTION: This snippet conditionally defines a list of source files for NAT (Network Address Translation) test cases using CMake. The `if(PRODUCT STREQUAL netxduo)` block ensures these tests are only included when the product is NetX Duo.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nif(PRODUCT STREQUAL netxduo)\n  set(nat_test_cases\n      ${SOURCE_DIR}/nat_test/netx_nat_tcp_fragment_test.c\n      ${SOURCE_DIR}/nat_test/netx_nat_tcp_test1.c\n      ${SOURCE_DIR}/nat_test/netx_nat_tcp_port_test2.c\n      ${SOURCE_DIR}/nat_test/netx_nat_udp_fragment_test.c\n      ${SOURCE_DIR}/nat_test/netx_nat_icmp_test.c\n      ${SOURCE_DIR}/nat_test/netx_nat_udp_test.c\n      ${SOURCE_DIR}/nat_test/netx_nat_tcp_test2.c\n      ${SOURCE_DIR}/nat_test/netx_nat_udp_port_test.c\n      ${SOURCE_DIR}/nat_test/netx_nat_tcp_port_test.c\n      ${SOURCE_DIR}/nat_test/netx_nat_invalid_header_test.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Target and Dependencies for MbedTLS Libraries in CMake\nDESCRIPTION: This CMake code defines a custom target named `${lib_target}` that depends on the individual MbedTLS component targets (`${mbedcrypto_target}`, `${mbedx509_target}`, `${mbedtls_target}`). It also conditionally adds dependencies on static library targets if both static and shared library builds are enabled. The variable `USE_STATIC_MBEDTLS_LIBRARY` and `USE_SHARED_MBEDTLS_LIBRARY` control conditional dependency.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_19\n\nLANGUAGE: cmake\nCODE:\n```\nset(lib_target \"${MBEDTLS_TARGET_PREFIX}lib\")\n\nadd_custom_target(${lib_target} DEPENDS ${mbedcrypto_target} ${mbedx509_target} ${mbedtls_target})\nif(USE_STATIC_MBEDTLS_LIBRARY AND USE_SHARED_MBEDTLS_LIBRARY)\n    add_dependencies(${lib_target} ${mbedcrypto_static_target} ${mbedx509_static_target} ${mbedtls_static_target})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Definitions\nDESCRIPTION: Adds preprocessor definitions to the compiler. These definitions configure various aspects of the Azure IoT Middleware, such as enabling extended notify support, secure features, DNS client options, MQTT Cloud support, SNTP client parameters, IP packet filtering, and Azure IoT ADU agent proxy update count.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\n# Add definitions\nadd_definitions(\n  ${ADDITIONAL_C_FLAGS}\n  ${DRIVER_FLAG}\n  -DNX_PCAP_SOURCE_NAME=\\\"${PCAP_NAME}\\\"\n  -DNX_ENABLE_EXTENDED_NOTIFY_SUPPORT\n  -DNX_SECURE_ENABLE\n  -DNX_DNS_CLIENT_USER_CREATE_PACKET_POOL\n  -DNX_DNS_CLIENT_CLEAR_QUEUE\n  -DNXD_MQTT_CLOUD_ENABLE\n  -DNX_SNTP_CLIENT_MAX_ROOT_DISPERSION=0\n  -DNX_SNTP_CLIENT_MIN_SERVER_STRATUM=3\n  -DNX_ENABLE_IP_PACKET_FILTER\n  -DNX_SECURE_TLS_DISABLE_TLS_1_1\n  -DNXD_MQTT_PING_TIMEOUT_DELAY=500\n  -DNXD_MQTT_SOCKET_TIMEOUT=0\n  -DNXD_MQTT_OVER_WEBSOCKET\n  -DNX_AZURE_IOT_ADU_AGENT_PROXY_UPDATE_COUNT=1\n  ${${CMAKE_BUILD_TYPE}})\n\n```\n\n----------------------------------------\n\nTITLE: Setting include directory for CMSISDSPTransform in CMake\nDESCRIPTION: This snippet sets the include directory for the CMSISDSPTransform library to the specified path, making the header files available for compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_30\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(CMSISDSPTransform PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories in CMake\nDESCRIPTION: This snippet uses the `target_include_directories` command to add include directories for the project.  The `${PROJECT_NAME}` variable is the name of the project, and `PUBLIC` indicates that these include directories are visible to other dependent targets. `${CMAKE_CURRENT_LIST_DIR}/inc` specifies a relative path to the include directory within the current CMake list file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m4/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Define USBX target library\nDESCRIPTION: This snippet defines the target library for the USBX project and creates an alias for it, making it easier to reference in other parts of the project or in dependent projects using the alias \"azrtos::${PROJECT_NAME}\".\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Define our target library and an alias for consumers\nadd_library(${PROJECT_NAME})\nadd_library(\"azrtos::${PROJECT_NAME}\" ALIAS ${PROJECT_NAME})\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files for Regression Tests\nDESCRIPTION: This snippet retrieves the absolute path of the source directory and then defines a variable, `nx_secure_test_cases`, which contains a list of C source files that make up the regression test suite for the NX Secure library. These test cases cover various aspects of TLS, DTLS, and X.509 functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../regression\n                       ABSOLUTE)\n\nset(nx_secure_test_cases\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_session_receive_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_send_record_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_client_handshake_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_finished_hash_generate_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_generate_keys_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_generate_premaster_secret_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_handshake_hash_init_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_ecc_generate_keys_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_session_renegotiate_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_session_keys_set_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_newest_supported_version_coverage_test.c  \n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_verify_mac_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_hash_record_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_certificate_initialize_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_certificate_verify_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_crl_verify_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_parse_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_list_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_store_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_name_check_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_crl_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_error_checking_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_expiration_check_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_key_usage_test.c \n    ${SOURCE_DIR}/nx_secure_test/nx_secure_x509_pkcs7_decode_coverage_test.c \n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_handshake_header_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_session_sni_extension_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_handshake_fragmentation_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_handshake_fragmentation_ecc_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_hash_clone_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_header_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_two_way_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_two_way_test_version_1_1.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_alert_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_error_checking_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_error_checking_2_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_tcp_fragment_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_user_defined_key_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_no_client_cert_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_metadata_size_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_multiple_handshake_msg_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_multithread_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_distinguished_name_compare_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_ciphersuites_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_client_handshake_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_clienthello_extension_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_coverage_2_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_coverage_3_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_handshake_fail_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_packet_chain_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_receive_alert_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_receive_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_record_decrypt_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_record_encrypt_coverage_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_record_layer_version_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_record_length_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_serverhello_extension_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_unrecognized_ciphersuites_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_unsupported_ciphersuites_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_non_blocking_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_ecc_basic_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_ecc_protocol_version_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_ecc_client_cert_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_ecc_ciphersuites_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_ecc_curves_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_ecc_crl_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_ecc_packet_chain_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_ecc_point_format_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_receive_wrong_packet_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_shutdown_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_session_delete_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_cert_verify_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_session_start_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_basic_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_error_checking_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_sliding_window_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_retransmit_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_retransmit_interval_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_retransmit_change_cipher_spec_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_ciphersuites_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_handshake_fail_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_ecjpake_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_multiple_sessions_receive_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_multiple_sessions_connect_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_multiple_sessions_reuse_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_multiple_sessions_connect_fail_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_multiple_sessions_send_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_multiple_sessions_retransmit_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_multiple_sessions_ecjpake_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_multiple_ip_address_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_no_free_sessions_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_concurrent_sessions_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_concurrent_sessions_retransmit_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_abort_waiting_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_fragment_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_abnormal_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_out_of_order_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_version_1_0_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_nxe_api_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_ecc_basic_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_ecc_ciphersuites_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_ecc_curves_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_dtls_ecc_client_cert_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_nxe_api_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_server_handshake_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_cert_callback_fail_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_send_and_receive_record_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_branch_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_crypto_self_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_crypto_cleanup_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_crypto_method_cleanup_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_certificate_verify_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_no_remote_certs_allocated_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_partial_remote_certs_allocated_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_process_certificate_verify_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_process_changecipherspec_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_process_certificate_request_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_process_finished_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_packet_trim_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_process_record_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_rsa_4096_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_rsa_private_key_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_serverhello_session_id_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_version_negotiation_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_handshake_fail_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_ciphersuites_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_clienthello_length_checking_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_key_share_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_provisioned_psk_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_hello_retry_cookie_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_client_ca_select_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_receive_invalid_server_handshake_message_test.c\n    ${SOURCE_DIR}/nx_secure_test/nx_secure_tls_1_3_invalid_client_state_test.c)\n```\n\n----------------------------------------\n\nTITLE: Configuring PPU Revisions\nDESCRIPTION: This code snippet configures the revisions for various Protection and Privilege Unit (PPU) components within the FVP MPS2 simulator.  The `revision` parameter is set to \"r0p0\" for sys_ppu, cpu0core_ppu, cpu0dbg_ppu, cpu1core_ppu, cpu1dbg_ppu, crypto_ppu, cordio_ppu, dbg_ppu, ram0_ppu, ram1_ppu, ram2_ppu, and ram3_ppu.  This setting is used to specify the version of the PPU being simulated.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_module/cortex_m23/ac6/example_build/ARMCM23_TZ_config.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nfvp_mps2.sse200.sys_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.cpu0core_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.cpu0dbg_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.cpu1core_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.cpu1dbg_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.crypto_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.cordio_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.dbg_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.ram0_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.ram1_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.ram2_ppu.revision=\"r0p0\"\nfvp_mps2.sse200.ram3_ppu.revision=\"r0p0\"\n```\n\n----------------------------------------\n\nTITLE: PAKE Driver Get Implicit Key Function Prototype C\nDESCRIPTION: Defines the function prototype for the PAKE driver get implicit key function, `acme_pake_get_implicit_key`. This function retrieves the implicit key resulting from a PAKE operation. It takes the operation context, an output buffer, the size of the output buffer, and a pointer to store the length of the implicit key as parameters.  Returns a `psa_status_t` to indicate the result of the operation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_29\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_pake_get_implicit_key(\n                            acme_pake_operation_t *operation,\n                            uint8_t *output, size_t output_size,\n                            size_t *output_length );\n```\n\n----------------------------------------\n\nTITLE: Set Build Type\nDESCRIPTION: Sets the build type from the configuration types, ensuring a valid build type is selected. The `list(GET ...)` command retrieves the first configuration type. The `if` statement checks if the configured build type is valid and sets it if necessary.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Interactive FIH Test Execution\nDESCRIPTION: These commands demonstrate how to run the FIH tests interactively using a Docker container. First, the docker image is started. Then, `execute_test.sh` is invoked within the container, taking skip size, build type, damage type, and FIH level as parameters.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_21\n\nLANGUAGE: Shell Script\nCODE:\n```\n# Start the docker image with the following command:\n  `docker run -i -t mcuboot/fih-test`.\n# Execute the test with a command similar to the following:\n  `/root/execute_test.sh 8 RELEASE SIGNATURE MEDIUM`\n```\n\n----------------------------------------\n\nTITLE: Enable NOR flash erase in lx_stm32_ospi_driver.h (C)\nDESCRIPTION: This code snippet demonstrates how to enable the NOR flash chip erase operation within the `lx_stm32_ospi_driver.h` file. Enabling the erase allows LevelX and FileX to create a clean FAT filesystem on the NOR flash.  The erase operation is disabled by default to save time during startup. Set the flag to 1 to enable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_NoR_Write_Read_File/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define LX_STM32_OSPI_ERASE                              1\n```\n\n----------------------------------------\n\nTITLE: Include architecture-specific code\nDESCRIPTION: This snippet includes the architecture-specific code for the USBX library. If a custom port is defined, it uses that; otherwise, it defaults to the code in the `ports` directory based on the `THREADX_ARCH` and `THREADX_TOOLCHAIN` variables.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# Pick up the port specific stuff first\nif(DEFINED USBX_CUSTOM_PORT)\n    add_subdirectory(${USBX_CUSTOM_PORT} usbx_port)\nelse()\n    add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/ports/${THREADX_ARCH}/${THREADX_TOOLCHAIN})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Project Definition and Languages\nDESCRIPTION: This snippet defines the project name as 'libs' and specifies that the project uses the C language.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/libs/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(libs LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Modify XML Content from Layout File (Bash)\nDESCRIPTION: This command uses `xmlval` to modify the content of an XML parameter's `<Value>` tag using a value extracted from an image layout file based on a macro definition. It filters by either `<Name>` or `<Command>` in the XML file. It requires the path of the layout file, the macro name, and the command.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nxmlval -l image_macros_preprocessed_bl2.c -m RE_IMAGE_FLASH_SECURE_IMAGE_SIZE -c -S OEMiRoT_Secure_Code.xml\n```\n\n----------------------------------------\n\nTITLE: Initialize CMake Project for Azure IoT Samples\nDESCRIPTION: This snippet initializes the CMake project, sets the minimum required CMake version, specifies the project name, and sets the C standard to C99.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.10)\n\nproject (az_iot_samples LANGUAGES C)\n\nset(CMAKE_C_STANDARD 99)\n```\n\n----------------------------------------\n\nTITLE: Building ThreadX Library\nDESCRIPTION: Conditionally builds the ThreadX library if not in standalone mode.  It executes a script to build the libraries, creates a custom target, and sets include directories and library properties.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT FX_STANDALONE_ENABLE)\n    execute_process(COMMAND ${CMAKE_CURRENT_LIST_DIR}/run.sh build_libs)\n    add_custom_target(build_libs ALL COMMAND ${CMAKE_CURRENT_LIST_DIR}/run.sh\n                                             build_libs)\n    add_dependencies(filex build_libs)\n    target_include_directories(filex PUBLIC ${CMAKE_BINARY_DIR}/../libs/inc)\n    add_library(threadx SHARED IMPORTED GLOBAL)\n    add_library(\"azrtos::threadx\" ALIAS threadx)\n    set_target_properties(\n      threadx PROPERTIES IMPORTED_LOCATION\n                         ${CMAKE_BINARY_DIR}/../libs/threadx/libthreadx.so)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Project with CMake\nDESCRIPTION: This snippet defines the minimum required CMake version and the project name. It also includes custom configuration scripts `configLib` and `configDsp` which are likely project-specific configurations for the library and DSP respectively. This sets up the basic environment for the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ControllerFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n\nproject(CMSISDSPController)\n\ninclude(configLib)\ninclude(configDsp)\n\nadd_library(CMSISDSPController STATIC)\n\nconfigLib(CMSISDSPController ${ROOT})\nconfigDsp(CMSISDSPController ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration\nDESCRIPTION: This snippet shows the required configuration in the MDK-ARM linker (.sct) file or in tx_initialize_low_level.S to properly allocate memory for ThreadX. It involves defining the RW_IRAM1 region or modifying a line to match the memory region being used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_DualClass/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Creating az_iot_adu Library\nDESCRIPTION: Creates a static library named `az_iot_adu` from the specified C source file, and sets include directories.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/iot/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(az_iot_adu\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_adu_client.c\n)\n\ntarget_include_directories (az_iot_adu\n  PUBLIC\n    ${az_SOURCE_DIR}/sdk/inc\n)\n\nadd_library (az::iot::adu ALIAS az_iot_adu)\n```\n\n----------------------------------------\n\nTITLE: Adding Link Options\nDESCRIPTION: This snippet adds link options for the project, specifically the architecture specification (-m32).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/ptp/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_link_options(-m32)\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources in CMake\nDESCRIPTION: This snippet uses the `target_sources` command in CMake to specify the source files for the project. The `PRIVATE` keyword indicates that these sources are only used for building the current target and are not exposed to other targets that depend on it. The `# {{BEGIN_TARGET_SOURCES}}` and `# {{END_TARGET_SOURCES}}` comments suggest that the actual list of source files is dynamically inserted here, likely by a script or tool.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m55/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR for Cortex-M4 with ThreadX\nDESCRIPTION: Defines the structure of an Interrupt Service Routine (ISR) written in assembly language for Cortex-M4 when using ThreadX. The ISR must push and pop registers to maintain the stack and return correctly. The label `your_assembly_isr` should be replaced with the actual ISR name in the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/keil/readme_threadx.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\nEXPORT  your_assembly_isr\nyour_assembly_isr\n\tPUSH    {r0, lr}\n\n\t; ISR processing goes here, including any needed function calls.\n\n\tPOP     {r0, lr}\n\tBX      lr\n```\n\n----------------------------------------\n\nTITLE: Defining Test Utility Files\nDESCRIPTION: This snippet defines a list of utility files used for testing, including the network driver test and HTTPs test control. These files contain helper functions and configurations used by the test cases.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/regression/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(test_utility_files\n    ${SOURCE_DIR}/test/nx_ram_network_driver_test_1500.c\n    ${SOURCE_DIR}/web_test/netx_https_testcontrol.c)\n```\n\n----------------------------------------\n\nTITLE: Defining Win32 Data Structures for Interrupts in C\nDESCRIPTION: Defines the Windows data structures and prototypes necessary to create a simulated interrupt thread. These structures include a handle, ID, and function prototype for the interrupt thread.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/win32/vs_2019/readme_threadx.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nHANDLE       _sample_win32_interrupt_handle;\nDWORD        _sample_win32_interrupt_id;\nDWORD WINAPI _sample_win32_interrupt(LPVOID);\n```\n\n----------------------------------------\n\nTITLE: RTC Clock Source Definition in main.c\nDESCRIPTION: This code snippet shows how to define the RTC clock source as either LSI or LSE. By default, LSI is used. To use LSE, uncomment the `#define RTC_CLOCK_SOURCE_LSE` line and configure LSE in STM32CubeMX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples/RTC/RTC_TimeStamp/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define RTC_CLOCK_SOURCE_LSI\n\n/* #define RTC_CLOCK_SOURCE_LSE */\n```\n\n----------------------------------------\n\nTITLE: Adding Link Options\nDESCRIPTION: Adds linker options, in this case specifying the 32-bit architecture.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_link_options(-m32)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMocka Test with CMake\nDESCRIPTION: This CMake code configures a CMocka test executable named `az_iot_adu_test`. It specifies the source files, compile options, and link libraries needed for the test. It also includes necessary directories and creates a map file for debugging.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/adu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.10)\n\nproject (az_iot_adu_test LANGUAGES C)\n\nset(CMAKE_C_STANDARD 99)\n\ninclude(AddCMockaTest)\n\nadd_cmocka_test(az_iot_adu_test SOURCES\n                main.c\n                test_az_iot_adu.c\n                COMPILE_OPTIONS ${DEFAULT_C_COMPILE_FLAGS} ${NO_CLOBBERED_WARNING}\n                LINK_LIBRARIES ${CMOCKA_LIB}\n                    az_iot_adu\n                    az_iot_hub\n                    az_core\n                INCLUDE_DIRECTORIES ${CMOCKA_INCLUDE_DIR}\n                )\n\ncreate_map_file(az_iot_adu_test az_iot_adu_test.map)\n\nadd_cmocka_test_environment(az_iot_adu_test)\n```\n\n----------------------------------------\n\nTITLE: Building Curl HTTP Client Library\nDESCRIPTION: This snippet conditionally builds the 'az_curl' static library if TRANSPORT_CURL is enabled. It finds the Curl library, adds the library source file, links it with 'az_core' and 'CURL::libcurl', and sets include directories.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/platform/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif (TRANSPORT_CURL)\n  set(CURL_MIN_REQUIRED_VERSION 7.1) #Min curl version to support CURLOPT_HTTPHEADER option\n  find_package(CURL ${CURL_MIN_REQUIRED_VERSION} CONFIG)\n  if(NOT CURL_FOUND)\n    find_package(CURL ${CURL_MIN_REQUIRED_VERSION} REQUIRED)\n  endif()\n\n  add_library (\n    az_curl\n      STATIC\n      ${CMAKE_CURRENT_LIST_DIR}/az_curl.c\n  )\n\n  target_link_libraries(az_curl PRIVATE az_core)\n\n  # make sure that users can consume the project as a library.\n  add_library (az::curl ALIAS az_curl)\n\n  target_link_libraries(az_curl PUBLIC CURL::libcurl)\n  target_include_directories(az_curl INTERFACE ${CURL_INCLUDE_DIR})\n\nendif()\n```\n\n----------------------------------------\n\nTITLE: Add and Link Executables (CMake)\nDESCRIPTION: Iterates through the list of executables. For each executable, it adds the executable target, links it against the libraries defined in `libs`, the `mbedtls_test` object, and thread libraries. It also sets the include directory for the executable to use test headers. This is a central part of the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/util/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(exe IN LISTS executables)\n    add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>)\n    target_link_libraries(${exe} ${libs} ${CMAKE_THREAD_LIBS_INIT})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories in CMake\nDESCRIPTION: This snippet uses the `target_include_directories` command in CMake to specify the include directories for the project. The `PUBLIC` keyword indicates that these include directories are added to the include search path for the current target and also for any other targets that depend on it. `${CMAKE_CURRENT_LIST_DIR}/inc` refers to the `inc` subdirectory within the directory containing the current CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m55/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting HID Test Cases Variable in CMake\nDESCRIPTION: This snippet defines a CMake variable, `ux_class_hid_device_standalone_test_cases`, and assigns it a list of source files related to HID device standalone tests. These source files are assumed to be C files for testing the USBX HID device class.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_hid_device_standalone_test_cases\n    ${SOURCE_DIR}/usbx_hid_mouse_basic_test.c\n    ${SOURCE_DIR}/usbx_hid_keyboard_basic_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_basic_memory_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_control_request_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_read_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_receiver_memory_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_receiver_test.c\n    ${SOURCE_DIR}/usbx_uxe_device_hid_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: Create Azure IoT Sample Common Library\nDESCRIPTION: This snippet creates a static library named `az_iot_sample_common` from the `iot_sample_common.c` file.  It also links the library to internal (az::iot::hub, az::iot::provisioning) and external (eclipse-paho-mqtt-c, OpenSSL) dependencies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library (az_iot_sample_common\n  ${CMAKE_CURRENT_LIST_DIR}/iot_sample_common.c\n)\n\n# Internal deps\ntarget_link_libraries(az_iot_sample_common\n  PUBLIC\n    az::iot::hub\n    az::iot::provisioning\n)\n\n# External deps\ntarget_link_libraries(az_iot_sample_common\n  PUBLIC\n    eclipse-paho-mqtt-c::paho-mqtt3cs-static\n    OpenSSL::SSL\n    OpenSSL::Crypto\n)\n\nadd_library (az::iot::sample::common ALIAS az_iot_sample_common)\n```\n\n----------------------------------------\n\nTITLE: IoTHub Symmetric Key Configuration (C)\nDESCRIPTION: These macros are used to configure the device to connect to Azure IoT Hub using a symmetric key. The placeholders must be replaced with the actual values from the Azure portal. This configuration enables Telemetry, Cloud to Device messages, and Direct Methods by default. Features can be disabled by defining additional macros.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/samples/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define HOST_NAME                                   \"<Hostname from connection string>\"\n#define DEVICE_ID                                   \"<DeviceId from connection string>\"\n#define DEVICE_SYMMETRIC_KEY                        \"<SharedAccessKey from connection string>\"\n```\n\n----------------------------------------\n\nTITLE: Set Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. This ensures that the CMake version used to build the project is compatible with the CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: Adding subdirectories for modules CMake\nDESCRIPTION: This snippet adds subdirectories to the build process for different modules or components of the project. It adds the main product directory, a regression test directory, and a samples directory (conditionally, only if not building for 64-bit). It also includes an additional CMake file if the product is `netxduo` and the build is not for 64-bit.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nenable_testing()\n\nif(\"-DNX_BSD_ENABLE\" IN_LIST ${CMAKE_BUILD_TYPE})\n  set(NXD_ENABLE_BSD ON)\nendif()\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../../.. ${PRODUCT})\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/regression regression)\nif(NOT \"$ENV{ENABLE_64}\")\n  add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/samples samples)\n  if(PRODUCT STREQUAL netxduo)\n    include(additionals.cmake)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Library and DSP Settings\nDESCRIPTION: Calls custom CMake functions `configLib` and `configDsp` to configure the CMSISDSPDistance library, passing the library name and the ROOT variable, presumably to set up library-specific configurations and DSP-related settings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/DistanceFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nconfigLib(CMSISDSPDistance ${ROOT})\nconfigDsp(CMSISDSPDistance ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Project Declaration\nDESCRIPTION: This snippet declares the project name and specifies the languages used (C in this case). It's the entry point for defining a CMake project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/libs/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(libs LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Conditional NEON Source\nDESCRIPTION: Conditionally adds the arm_cl_tables.c source file if either NEON or NEONEXPERIMENTAL is enabled.  This allows the inclusion of the ComputeLibrary source file for NEON optimizations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nif (NEON OR NEONEXPERIMENTAL)\n    target_sources(CMSISDSPCommon PRIVATE \"${DSP}/ComputeLibrary/Source/arm_cl_tables.c\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: RSA Prime Factor (Q) Definition\nDESCRIPTION: Defines the second RSA prime factor (Q) as a hexadecimal string. Q is one of the two large prime numbers that make up the modulus N. This value, along with P, is used in key generation and optimization of decryption.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/rsa_priv.txt#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nQ = CA0EEEA5E710E8E9811A6B846399420E3AE4A4C16647E426DDF8BBBCB11CD3F35CE2E4B6BCAD07AE2C0EC2ECBFCC601B207CDD77B5673E16382B1130BF465261\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration\nDESCRIPTION: This configuration defines a new section named ._threadx_heap in the STM32CubeIDE linker file to provide memory for ThreadX. The memory is allocated in the RAM_D1 region and its size is set to 64KB.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ThreadX/Tx_Thread_Creation/README.md#_snippet_2\n\nLANGUAGE: LD\nCODE:\n```\n._threadx_heap :\n  {\n    . = ALIGN(8);\n    __RAM_segment_used_end__ = .;\n    . = . + 64K;\n    . = ALIGN(8);\n  } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Adding Assembly Source Files with target_sources in CMake\nDESCRIPTION: This snippet uses the `target_sources` command in CMake to add several assembly source files to a target named `${PROJECT_NAME}`. These files implement functionalities related to ThreadX, such as context saving and restoring, interrupt control, thread scheduling, stack building, system return, and timer interrupts. The `PRIVATE` keyword specifies that these sources are only used when building the specified target and are not exposed to dependent projects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration for ThreadX Heap\nDESCRIPTION: This snippet shows the required linker configuration for EWARM to allocate a memory region for the ThreadX heap. It places the FREE_MEM section into the RAM_region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_LowPower/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Linking Mbed TLS Libraries\nDESCRIPTION: This snippet defines a list of Mbed TLS libraries with the specified prefix (`subproject_test_`). It then creates an executable named `cmake_subproject` from the `cmake_subproject.c` source file and links it against the Mbed TLS libraries and the system's thread library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_subproject/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\n# Link against all the Mbed TLS libraries. Verifies that the targets have been\n# created using the specified prefix\nset(libs\n    subproject_test_mbedcrypto\n    subproject_test_mbedx509\n    subproject_test_mbedtls\n)\n\nadd_executable(cmake_subproject cmake_subproject.c)\ntarget_link_libraries(cmake_subproject ${libs} ${CMAKE_THREAD_LIBS_INIT})\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows the configuration needed for MDK-ARM to provide memory for ThreadX dynamic allocation. It involves either defining the `RW_IRAM1` region in the `.sct` file or modifying a line in `tx_initialize_low_level.S` to point to the memory region being used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/USBX/Ux_Device_HID/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Key Size in Bytes Calculation\nDESCRIPTION: Calculates the key size in bytes (`key_bytes`) from the key size in bits (`key_bits`). This calculation ensures that the byte size is rounded up to the nearest whole byte.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_42\n\nLANGUAGE: C\nCODE:\n```\nkey_bytes = ((key_bits + 7) / 8)\n```\n\n----------------------------------------\n\nTITLE: Configure Target Sources with CMake\nDESCRIPTION: This CMake snippet configures the target sources for the project. The `target_sources` command is used to add source files to the specified target. The PRIVATE keyword indicates that these sources are only used when building the target and are not exposed to other targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/ports/linux/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Executables\nDESCRIPTION: Defines the list of executable targets to be built. Each name in the list corresponds to a source file named similarly (e.g., `dtls_client` corresponds to `dtls_client.c`).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/ssl/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(executables\n    dtls_client\n    dtls_server\n    mini_client\n    ssl_client1\n    ssl_client2\n    ssl_context_info\n    ssl_fork_server\n    ssl_mail_client\n    ssl_server\n    ssl_server2\n)\n```\n\n----------------------------------------\n\nTITLE: Cortex-M0 ISR in Assembly with ThreadX API access\nDESCRIPTION: Defines the structure of an Interrupt Service Routine (ISR) written in assembly language for Cortex-M0.  The ISR pushes registers r0 and lr onto the stack, performs ISR processing including any required function calls, pops r0 and r1 from the stack, moves r1 to lr and then returns using the BX instruction.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/ac5/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n    EXPORT  your_assembly_isr\nyour_assembly_isr\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, r1}\n    MOV     lr, r1\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE linker .ld file modification (C)\nDESCRIPTION: This code snippet demonstrates how to modify the STM32CubeIDE linker `.ld` file to reserve memory for the ThreadX heap. It defines a new section `._threadx_heap` within the RAM_D1 region, allocating 64KB of memory for ThreadX's dynamic memory allocation needs.  The heap must be located between the `.bss` and `._user_heap_stack` sections.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_NoR_Write_Read_File/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for MSRC Standalone Tests CMake\nDESCRIPTION: Defines the source file paths for the USBX MSRC test cases that can run in a standalone environment, without an operating system. These tests are self-contained and don't require external dependencies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_24\n\nLANGUAGE: CMake\nCODE:\n```\n  ${SOURCE_DIR}/usbx_msrc_81489_81570_host_cdc_acm_standalone_ac_search_test.c\n  ${SOURCE_DIR}/usbx_msrc_81572_standalone_host_printer_allocated_enum_free_test.c\n  ${SOURCE_DIR}/usbx_msrc_81573_standalone_host_hub_allocated_enum_free_test.c\n  ${SOURCE_DIR}/usbx_msrc_81574_standalone_host_hid_allocated_enum_free_test.c\n  ${SOURCE_DIR}/usbx_msrc_81575_standalone_host_cdc_acm_allocated_enum_free_test.c\n  ${SOURCE_DIR}/usbx_msrc_81691_standalone_host_stack_enum_double_free_test.c\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories Conditionally in CMake\nDESCRIPTION: These snippets conditionally add subdirectories to the project based on the CMake options defined earlier. If an option is enabled (ON), the corresponding subdirectory is added using the add_subdirectory command. This allows for modular compilation of the CMSIS-NN library, where only the necessary functions are included in the build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif (BASICMATHSNN)\n  add_subdirectory(BasicMathFunctions)\nendif()\n\nif (CONCATENATION)\n  add_subdirectory(ConcatenationFunctions)\nendif()\n\nif (FULLYCONNECTED)\n  add_subdirectory(FullyConnectedFunctions)\nendif()\n\nif (CONVOLUTION)\n  add_subdirectory(ConvolutionFunctions)\nendif()\n\nif (ACTIVATION)\n  add_subdirectory(ActivationFunctions)\nendif()\n\nif (POOLING)\n  add_subdirectory(PoolingFunctions)\nendif()\n\nif (SOFTMAX)\n  add_subdirectory(SoftmaxFunctions)\nendif()\n\nif (SVDF)\n  add_subdirectory(SVDFunctions)\nendif()\n\nif (RESHAPE)\n  add_subdirectory(ReshapeFunctions)\nendif()\n\n# Keep NNSUPPORT at the end\nif (NNSUPPORT)\n  add_subdirectory(NNSupportFunctions)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Coverage Configuration\nDESCRIPTION: This snippet configures compile and link options for coverage builds. If the CMAKE_BUILD_TYPE matches a coverage build, it adds the -fprofile-arcs and -ftest-coverage flags to the compile and link options for the netxduo target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/ptp/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(netxduo PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(netxduo PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This CMake snippet uses `target_sources` to define the private source files for the specified project. The `PRIVATE` keyword indicates that these sources are only used within the project's own compilation units. The `PROJECT_NAME` variable should be defined elsewhere in the CMake configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m4/iar/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Set Compile Options for NetXDuo\nDESCRIPTION: This snippet sets compile options for the `netxduo` target, including warning flags, pedantic mode, and other options to improve code quality and catch potential errors.  It uses the PRIVATE keyword, limiting visibility to the target itself.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(\n  netxduo\n  PRIVATE -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal\n          -std=c99)\n```\n\n----------------------------------------\n\nTITLE: Message Toolchain File Status\nDESCRIPTION: This snippet displays the path to the CMake toolchain file using the STATUS message type.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/libs/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: Add Private Sources\nDESCRIPTION: Adds arm_const_structs.c and arm_const_structs_f16.c as private source files to the CMSISDSPCommon library. These files are only used within the library and are not exposed to external projects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPCommon PRIVATE arm_const_structs.c)\ntarget_sources(CMSISDSPCommon PRIVATE arm_const_structs_f16.c)\n```\n\n----------------------------------------\n\nTITLE: Setting up library dependencies for PThread\nDESCRIPTION: This snippet adds the pthread library to the list of libraries to link if LINK_WITH_PTHREAD is set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nif(LINK_WITH_PTHREAD)\n    set(libs ${libs} ${CMAKE_THREAD_LIBS_INIT})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Export Key Prototype - C\nDESCRIPTION: Defines the function prototype for the `export_key` entry point in a PSA opaque driver. This function exports a key from the driver. It takes key attributes, a key buffer, its size, a data buffer, its size, and a pointer to store the data length as input, and returns a PSA status.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_47\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_export_key(const psa_key_attributes_t *attributes,\n                             const uint8_t *key_buffer,\n                             size_t key_buffer_size,\n                             uint8_t *data,\n                             size_t data_size,\n                             size_t *data_length);\n```\n\n----------------------------------------\n\nTITLE: Conditional PTP Test Cases\nDESCRIPTION: This CMake snippet conditionally defines the `ptp_test_cases` variable based on whether the product is NetXDuo and IPv4 is not disabled.  It lists C source files containing PTP (Precision Time Protocol) test cases for NetX. These tests involve client announce timeout, API testing, basic functionality, and calibration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_20\n\nLANGUAGE: CMake\nCODE:\n```\nif(PRODUCT STREQUAL netxduo)\n  if(NOT \"-DNX_DISABLE_IPV4\" IN_LIST ${CMAKE_BUILD_TYPE})\n    set(ptp_test_cases\n        ${SOURCE_DIR}/ptp_test/netx_ptp_client_announce_timeout_test.c\n        ${SOURCE_DIR}/ptp_test/netx_ptp_client_api_test.c\n        ${SOURCE_DIR}/ptp_test/netx_ptp_client_basic_test.c\n        ${SOURCE_DIR}/ptp_test/netx_ptp_client_calibrate_test.c\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Testing\nDESCRIPTION: This snippet enables testing in the project using CMake's built-in testing framework.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/ptp/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nenable_testing()\n```\n\n----------------------------------------\n\nTITLE: PAKE Driver Input Function Prototype C\nDESCRIPTION: Defines the function prototype for the PAKE driver input function, `acme_pake_input`. This function handles input data for PAKE operations, including the operation context, the current step in the PAKE protocol, the input buffer, and the input size. It returns a `psa_status_t` indicating the success or failure of the operation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_28\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_pake_input(acme_pake_operation_t *operation,\n                             psa_crypto_driver_pake_step_t step,\n                             uint8_t *input,\n                             size_t input_size);\n```\n\n----------------------------------------\n\nTITLE: Coverage Configuration\nDESCRIPTION: Enables code coverage if the build type contains '_coverage' in its name. This adds compile and link options for generating coverage data.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\n# Coverage\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(threadx PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(threadx PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Enabling Testing Subdirectory CMake\nDESCRIPTION: This snippet enables testing if the `ENABLE_TESTING` variable is set, and adds the `tests` subdirectory to the build. It also provides additional convenience targets for Unix-based systems, like coverage and memory check.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_27\n\nLANGUAGE: CMake\nCODE:\n```\nif(ENABLE_TESTING)\n    enable_testing()\n\n    add_subdirectory(tests)\n\n    # additional convenience targets for Unix only\n    if(UNIX)\n\n        # For coverage testing:\n        # 1. Build with:\n        #         cmake -D CMAKE_BUILD_TYPE=Coverage /path/to/source && make\n        # 2. Run the relevant tests for the part of the code you're interested in.\n        #    For the reference coverage measurement, see\n        #    tests/scripts/basic-build-test.sh\n        # 3. Run scripts/lcov.sh to generate an HTML report.\n        ADD_CUSTOM_TARGET(lcov\n            COMMAND scripts/lcov.sh\n        )\n\n        ADD_CUSTOM_TARGET(memcheck\n            COMMAND sed -i.bak s+/usr/bin/valgrind+`which valgrind`+ DartConfiguration.tcl\n            COMMAND ctest -O memcheck.log -D ExperimentalMemCheck\n            COMMAND tail -n1 memcheck.log | grep 'Memory checking results:' > /dev/null\n            COMMAND rm -f memcheck.log\n            COMMAND mv DartConfiguration.tcl.bak DartConfiguration.tcl\n        )\n    endif(UNIX)\n\n    # Make scripts needed for testing available in an out-of-source build.\n    if (NOT ${CMAKE_CURRENT_BINARY_DIR} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR})\n        link_to_source(scripts)\n        # Copy (don't link) DartConfiguration.tcl, needed for memcheck, to\n        # keep things simple with the sed commands in the memcheck target.\n        configure_file(${CMAKE_CURRENT_SOURCE_DIR}/DartConfiguration.tcl\n                    ${CMAKE_CURRENT_BINARY_DIR}/DartConfiguration.tcl COPYONLY)\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Add Custom Command\nDESCRIPTION: This snippet adds a custom command that executes a bash script to generate the `tx_initialize_low_level.c` file. This file is used for low-level initialization in the test environment. The bash script `generate_test_file.sh` is responsible for creating the C file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/regression/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_command(\n  OUTPUT ${SOURCE_DIR}/tx_initialize_low_level.c\n  COMMAND bash ${CMAKE_CURRENT_LIST_DIR}/generate_test_file.sh\n  COMMENT \"Generating tx_initialize_low_level.c for test\")\n```\n\n----------------------------------------\n\nTITLE: Semihosting Configuration\nDESCRIPTION: This parameter enables or disables semihosting SVC traps. Applications not using semihosting should set this to '0'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/ARMCM3_config.txt#_snippet_0\n\nLANGUAGE: Configuration\nCODE:\n```\narmcortexm3ct.semihosting-enable=0\n```\n\n----------------------------------------\n\nTITLE: Target Sources (Complex Dot Product)\nDESCRIPTION: Includes the complex dot product source files (arm_cmplx_dot_prod_f32.c, arm_cmplx_dot_prod_q15.c, arm_cmplx_dot_prod_q31.c) in the CMSISDSPComplexMath library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_dot_prod_f32.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_dot_prod_q15.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_dot_prod_q31.c)\n```\n\n----------------------------------------\n\nTITLE: Enabling/Disabling Device-Active Signal for PPUs\nDESCRIPTION: This snippet controls the use of the device-active signal for specific Protection and Privilege Units (PPUs) within the FVP MPS2 simulation. The `use_active_signal` parameter is set to 0 (disabled) for cpu1core_ppu, cpu1dbg_ppu, crypto_ppu, cordio_ppu, dbg_ppu, ram0_ppu, ram1_ppu, ram2_ppu and ram3_ppu. This setting determines whether the PPU asserts a signal indicating its activity.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_module/cortex_m23/ac6/example_build/ARMCM23_TZ_config.txt#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nfvp_mps2.sse200.cpu1core_ppu.use_active_signal=0\nfvp_mps2.sse200.cpu1dbg_ppu.use_active_signal=0\nfvp_mps2.sse200.crypto_ppu.use_active_signal=0\nfvp_mps2.sse200.cordio_ppu.use_active_signal=0\nfvp_mps2.sse200.dbg_ppu.use_active_signal=0\nfvp_mps2.sse200.ram0_ppu.use_active_signal=0\nfvp_mps2.sse200.ram1_ppu.use_active_signal=0\nfvp_mps2.sse200.ram2_ppu.use_active_signal=0\nfvp_mps2.sse200.ram3_ppu.use_active_signal=0\n```\n\n----------------------------------------\n\nTITLE: Setting C Standard\nDESCRIPTION: Sets the C standard to C99. This ensures that the code is compiled using the C99 standard, providing a consistent and well-defined language environment.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/core/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_C_STANDARD 99)\n```\n\n----------------------------------------\n\nTITLE: Set Project Root Directory\nDESCRIPTION: Sets the project root directory to the current source directory. This provides a convenient variable for referencing files and directories within the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset(MBEDTLS_DIR ${CMAKE_CURRENT_SOURCE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Adding NetXDuo Source Files to CMake Target\nDESCRIPTION: This CMake snippet defines a target (likely an executable or library) and adds a list of C source files to it.  The source files are specified using the `${CMAKE_CURRENT_LIST_DIR}` variable to ensure correct path resolution. The `PRIVATE` keyword indicates that these sources are only used for this target and are not exposed to other targets that link against it.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/common/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_announce_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_dynamic_entries_invalidate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_dynamic_entry_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_dynamic_entry_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_entry_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_entry_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_gratuitous_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_hardware_address_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_interface_entries_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_ip_address_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_packet_deferred_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_packet_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_packet_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_periodic_update.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_probe_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_queue_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_queue_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_static_entries_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_static_entry_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_static_entry_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_arp_static_entry_delete_internal.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_http_proxy_client.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmp_cleanup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmp_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmp_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmp_interface_ping.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmp_interface_ping6.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmp_packet_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmp_packet_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmp_ping.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmp_ping6.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmp_queue_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv4_packet_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv4_process_echo_reply.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv4_process_echo_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv4_send_error_message.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_DAD_clear_NDCache_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_DAD_failure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_dest_table_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_dest_table_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_destination_table_periodic_update.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_packet_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_perform_DAD.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_process_echo_reply.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_process_echo_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_process_na.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_process_ns.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_process_packet_too_big.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_process_ra.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_process_redirect.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_send_error_message.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_send_ns.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_send_queued_packets.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_send_rs.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_validate_neighbor_message.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_validate_options.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_icmpv6_validate_ra.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_interface_report_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_loopback_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_loopback_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_multicast_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_multicast_interface_join.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_multicast_interface_join_internal.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_multicast_interface_leave.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_multicast_interface_leave_internal.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_multicast_join.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_multicast_leave.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_packet_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_packet_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_periodic_processing.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_igmp_queue_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_invalidate_destination_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_address_change_notify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_address_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_address_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_auxiliary_packet_pool_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_checksum_compute.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_deferred_link_status_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_delete_queue_clear.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_dispatch_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_driver_deferred_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_driver_deferred_processing.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_driver_deferred_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_driver_direct_command.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_driver_interface_direct_command.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_driver_link_status_event.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_driver_packet_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_fast_periodic_timer_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_forward_packet_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_forwarding_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_forwarding_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_fragment_assembly.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_fragment_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_fragment_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_fragment_forward_packet.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_fragment_packet.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_fragment_timeout_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_gateway_address_clear.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_gateway_address_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_gateway_address_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_header_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_address_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_address_mapping_configure.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_address_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_attach.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_capability_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_capability_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_detach.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_mtu_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_physical_address_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_physical_address_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_interface_status_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_link_status_change_notify_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_max_payload_size_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_packet_checksum_compute.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_packet_deferred_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_packet_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_packet_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_periodic_timer_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_raw_packet_cleanup.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_raw_packet_disable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_raw_packet_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_raw_packet_filter_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_raw_packet_processing.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_raw_packet_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_raw_packet_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_raw_packet_source_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_raw_receive_queue_max_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_route_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_static_route_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_static_route_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_status_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ip_thread_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv4_multicast_interface_join.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv4_multicast_interface_leave.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv4_option_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv4_packet_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_fragment_process.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_header_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_multicast_join.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_multicast_leave.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_option_error.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_packet_copy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_packet_receive.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_packet_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_prefix_list_add_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_prefix_list_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_prefix_list_delete_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_process_fragment_option.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_process_hop_by_hop_option.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_process_routing_option.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_ipv6_util.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_link.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_md5.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_nd_cache_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_nd_cache_add_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_nd_cache_delete_internal.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_nd_cache_fast_periodic_update.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_nd_cache_find_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/nx_nd_cache_find_entry_by_mac_addr.c\n\n```\n\n----------------------------------------\n\nTITLE: Modifying Linker Variable from C Macro (linker)\nDESCRIPTION: This snippet shows how to modify a linker variable in an ICF file based on a macro value from a C source file. It extracts the value of `RE_IMAGE_FLASH_NON_SECURE_IMAGE_SIZE` from `image_macros_preprocessed_bl2.c` and assigns it to the `S_CODE_SIZE` variable in the linker file `stm32h573xx_flash_s.icf`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nlinker -l image_macros_preprocessed_bl2.c -m RE_IMAGE_FLASH_NON_SECURE_IMAGE_SIZE -link S_CODE_SIZE stm32h573xx_flash_s.icf\n```\n\n----------------------------------------\n\nTITLE: Initialize CMake Project\nDESCRIPTION: This snippet initializes the CMake project and sets the minimum required CMake version. It also includes configuration files for general libraries and DSP specific settings, which define various compiler flags and other configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/QuaternionMathFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n\nproject(CMSISDSPQuaternionMath)\n\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: Adding a custom command and executable for C++ dummy build (CMake)\nDESCRIPTION: Creates a custom command to generate a dummy C++ file if `TEST_CPP` is enabled. It also creates an executable named `cpp_dummy_build` using the generated file.  Include directories and link libraries are set for the target executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(TEST_CPP)\n    set(cpp_dummy_build_cpp \"${CMAKE_CURRENT_BINARY_DIR}/cpp_dummy_build.cpp\")\n    set(generate_cpp_dummy_build \"${CMAKE_CURRENT_SOURCE_DIR}/generate_cpp_dummy_build.sh\")\n    add_custom_command(\n        OUTPUT \"${cpp_dummy_build_cpp}\"\n        COMMAND \"${generate_cpp_dummy_build}\" \"${cpp_dummy_build_cpp}\"\n        DEPENDS \"${generate_cpp_dummy_build}\"\n        WORKING_DIRECTORY \"${CMAKE_CURRENT_SOURCE_DIR}\"\n    )\n    add_executable(cpp_dummy_build \"${cpp_dummy_build_cpp}\")\n    target_include_directories(cpp_dummy_build PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../include)\n    target_link_libraries(cpp_dummy_build ${mbedcrypto_target} ${CMAKE_THREAD_LIBS_INIT})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources CMake\nDESCRIPTION: This code configures the target sources for the specified project.  The actual source files are expected to be listed between the `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` comments. No external dependencies are explicitly defined in the provided code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/crypto_libraries/ports/cortex_m4/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Define Preprocessor Definitions for Build Configurations\nDESCRIPTION: This snippet defines preprocessor definitions for various build configurations, enabling or disabling specific features and functionalities within the NetX Secure library. These definitions are used during compilation to tailor the library's behavior for different use cases.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(default_build_coverage -DNX_SECURE_ENABLE_CLIENT_CERTIFICATE_VERIFY -DNX_DISABLE_ASSERT)\nset(psk_build_coverage\n    -DNX_SECURE_ENABLE_PSK_CIPHERSUITES -DNX_SECURE_ENABLE_AEAD_CIPHER\n    -DNX_SECURE_X509_DISABLE_CRL)\nset(tls_1_3_enable_build_coverage\n    -DNX_SECURE_TLS_ENABLE_TLS_1_3\n    -DNX_SECURE_ENABLE_CLIENT_CERTIFICATE_VERIFY\n    -DNX_SECURE_ENABLE_PSK_CIPHERSUITES)\nset(tls_1_1_enable_build -DNX_SECURE_TLS_ENABLE_TLS_1_1\n                         -DNX_SECURE_ENABLE_CLIENT_CERTIFICATE_VERIFY)\nset(tls_1_0_enable_build\n    -DNX_SECURE_TLS_ENABLE_TLS_1_0 -DNX_SECURE_TLS_ENABLE_TLS_1_1\n    -DNX_SECURE_ENABLE_CLIENT_CERTIFICATE_VERIFY)\nset(client_disable_build -DNX_SECURE_TLS_CLIENT_DISABLED)\nset(server_disable_build -DNX_SECURE_TLS_SERVER_DISABLED)\nset(tls_1_3_client_disable_build -DNX_SECURE_TLS_ENABLE_TLS_1_3 -DNX_SECURE_TLS_CLIENT_DISABLED)\nset(tls_1_3_server_disable_build -DNX_SECURE_TLS_ENABLE_TLS_1_3 -DNX_SECURE_TLS_SERVER_DISABLED)\nset(dtls_build_coverage\n    -DNX_SECURE_ENABLE_DTLS -DNX_SECURE_ENABLE_PSK_CIPHERSUITES\n    -DNX_SECURE_ENABLE_CLIENT_CERTIFICATE_VERIFY -DNX_SECURE_TLS_ENABLE_TLS_1_1)\nset(ecjpake_build\n    -DNX_SECURE_ENABLE_DTLS -DNX_SECURE_ENABLE_ECJPAKE_CIPHERSUITE\n    -DNX_SECURE_ENABLE_CLIENT_CERTIFICATE_VERIFY)\nset(eal4_build_coverage\n    -DNX_SECURE_KEY_CLEAR -DNX_SECURE_POWER_ON_SELF_TEST_MODULE_INTEGRITY_CHECK\n    -DCERT_BUILD -DNX_SECURE_DISABLE_ECC_CIPHERSUITE)\nset(sesip_build_coverage\n    -DNX_SECURE_KEY_CLEAR -DNX_SECURE_POWER_ON_SELF_TEST_MODULE_INTEGRITY_CHECK\n    -DNX_SECURE_TLS_DISABLE_SECURE_RENEGOTIATION -DNX_SECURE_TLS_ENABLE_TLS_1_3)\nset(no_ecc_build_coverage\n    -DNX_SECURE_DISABLE_ECC_CIPHERSUITE\n    -DNX_SECURE_ENABLE_CLIENT_CERTIFICATE_VERIFY\n    -DNX_SECURE_ENABLE_PSK_CIPHERSUITES\n    -DNX_SECURE_ENABLE_AEAD_CIPHER\n    -DNX_SECURE_TLS_ENABLE_TLS_1_0\n    -DNX_SECURE_ENABLE_DTLS\n    -DNX_SECURE_ENABLE_ECJPAKE_CIPHERSUITE)\nset(no_renegotiation_build -DNX_SECURE_TLS_DISABLE_SECURE_RENEGOTIATION -DNX_SECURE_TLS_SNI_EXTENSION_DISABLED -DNX_SECURE_TLS_USE_SCSV_CIPHPERSUITE)\nset(no_client_renegotiation_build -DNX_SECURE_TLS_DISABLE_CLIENT_INITIATED_RENEGOTIATION)\nset(no_x509_build\n    -DNX_SECURE_ENABLE_PSK_CIPHERSUITES -DNX_SECURE_ENABLE_AEAD_CIPHER\n    -DNX_SECURE_DISABLE_X509 -DNX_SECURE_DISABLE_ECC_CIPHERSUITE)\nset(hash_clone_build -DNX_SECURE_INCLUDE_USER_DEFINE_FILE -DHASH_CLONE_BUILD)\nset(curve25519_448_build\n    -DNX_CRYPTO_ENABLE_CURVE25519_448\n    -DNX_SECURE_TLS_ENABLE_TLS_1_3\n    -DNX_SECURE_ENABLE_CLIENT_CERTIFICATE_VERIFY\n    -DNX_SECURE_ENABLE_PSK_CIPHERSUITES)\n```\n\n----------------------------------------\n\nTITLE: IRQ Interrupt Handler Structure (Assembly)\nDESCRIPTION: This code snippet shows the structure of a typical IRQ interrupt handler in ThreadX. It includes jumps to context save and restore functions, along with calls to enable or disable interrupt nesting, and placeholders for the application's ISR dispatch.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/iar/readme_threadx.txt#_snippet_3\n\nLANGUAGE: Assembly\nCODE:\n```\n;    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save\n__tx_irq_processing_return\n;\n;    /* At this point execution is still in the IRQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use. Note \n;       that IRQ interrupts are still disabled upon return from the context\n;       save function.  */\n;\n;    /* Interrupt nesting is allowed after calling _tx_thread_irq_nesting_start \n;       from IRQ mode with interrupts disabled. This routine switches to the\n;       system mode and returns with IRQ interrupts enabled. \n;       \n;       NOTE:  It is very important to ensure all IRQ interrupts are cleared \n;       prior to enabling nested IRQ interrupts. */\n;\n    BL      _tx_thread_irq_nesting_start\n\n;    /* Application ISR dispatch call goes here!  */\n;\n;    /* If interrupt nesting was started earlier, the end of interrupt nesting\n;       service must be called before returning to _tx_thread_context_restore. \n;       This routine returns in processing in IRQ mode with interrupts disabled.  */\n;\n    BL      _tx_thread_irq_nesting_end\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Definition - IAR EWARM\nDESCRIPTION: Defines an Interrupt Service Routine (ISR) written in assembly language for Cortex-M using IAR EWARM. This example shows the basic structure of an assembly ISR and includes placeholder for ISR-specific processing. It pushes and pops registers to maintain context.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/iar/readme_threadx.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\n        PUBLIC  your_assembly_isr\nyour_assembly_isr:\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Executing HASH HAL Migrator Script\nDESCRIPTION: This command executes the HASH_HAL_Migrator script, specifying the project path to be migrated. The script will then parse the HASH structures, APIs, and macros in the provided project directory and update the code to use the new HAL HASH drivers, renaming the original files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/HASH_HAL_Migrator/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npy HASH_HAL_Migrator.py -p \"__PROJECT_PATH_\"\n```\n\n----------------------------------------\n\nTITLE: OutFile Parameter\nDESCRIPTION: Saves test environment settings into a .env file next to the test resources template. The file contents are protected using the .NET Data Protection API (DPAPI), supported only on Windows. The environment file is scoped to the current service directory, and named after the template.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\nType: SwitchParameter\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: False\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Setting target sources\nDESCRIPTION: This snippet defines the source files for the 'arm_signal_convergence_example' executable. The specified .c files are added as private sources to the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(arm_signal_convergence_example PRIVATE math_helper.c arm_signal_converge_data.c arm_signal_converge_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Configuring CFFT Options (Q31) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Complex FFT (CFFT) implementations for Q31 data types with various sizes (16 to 4096). These options are used to customize the CMSIS-DSP library by selecting specific CFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\noption(CFFT_Q31_16          \"cfft q31 16\"                       OFF)\noption(CFFT_Q31_32          \"cfft q31 32\"                       OFF)\noption(CFFT_Q31_64          \"cfft q31 64\"                       OFF)\noption(CFFT_Q31_128         \"cfft q31 128\"                      OFF)\noption(CFFT_Q31_256         \"cfft q31 256\"                      OFF)\noption(CFFT_Q31_512         \"cfft q31 512\"                      OFF)\noption(CFFT_Q31_1024        \"cfft q31 1024\"                     OFF)\noption(CFFT_Q31_2048        \"cfft q31 2048\"                     OFF)\noption(CFFT_Q31_4096        \"cfft q31 4096\"                     OFF)\n```\n\n----------------------------------------\n\nTITLE: Set Environment Variables for Device ID and Hostname (PowerShell)\nDESCRIPTION: These commands set the `AZ_IOT_HUB_DEVICE_ID` and `AZ_IOT_HUB_HOSTNAME` environment variables. These variables are required by the Azure IoT Hub samples to connect to the IoT Hub and identify the device. Replace 'myiothub.azure-devices.net' with your actual hostname.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_8\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS C:\\azure-sdk-for-c\\sdk\\samples\\iot> $env:AZ_IOT_HUB_DEVICE_ID='paho-sample-device1'\nPS C:\\azure-sdk-for-c\\sdk\\samples\\iot> $env:AZ_IOT_HUB_HOSTNAME='myiothub.azure-devices.net' # Use the your hostname instead.\n```\n\n----------------------------------------\n\nTITLE: Adding Compile Options\nDESCRIPTION: This snippet adds compile options for the project, including architecture specification (-m32), C standard (-std=c99), debugging information (-ggdb, -g3, -gdwarf-2), diagnostics colorization, treating warnings as errors (-Werror), ThreadX include file, and configuration-specific options.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/ptp/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_compile_options(\n  -m32\n  -std=c99\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  -Werror\n  -DTX_INCLUDE_USER_DEFINE_FILE\n  ${${CMAKE_BUILD_TYPE}})\n```\n\n----------------------------------------\n\nTITLE: Adding and Linking Regression Test Executables\nDESCRIPTION: This CMake code iterates through the defined test cases, creates an executable for each, links them against the azrtos::filex and azrtos::levelx libraries, defines the BATCH_TEST compile definition, and adds the executables as tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(test_case ${regression_test_cases} ${regression_test_cases_exfat})\n  get_filename_component(test_name ${test_case} NAME_WE)\n  add_executable(${test_name} ${test_case})\n  target_link_libraries(${test_name} PRIVATE azrtos::filex)\n  target_link_libraries(${test_name} PRIVATE azrtos::levelx)\n  target_compile_definitions(${test_name} PRIVATE BATCH_TEST)\n  add_test(${CMAKE_BUILD_TYPE}::${test_name} ${test_name})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Running Azure IoT Samples on VxWorks Shell\nDESCRIPTION: This snippet demonstrates how to execute the Azure provisioning and client samples in the VxWorks command shell.  The working directory is changed to /romfs, and then the executable files are run. Requires VxWorks environment to be setup and the sample applications compiled and located in /romfs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_vxworks.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n-> cmd\n[vxWorks *]# cd /romfs\n[vxWorks *]# ./azureProvisioningClientSample\n[vxWorks *]# ./azureClientSample\n```\n\n----------------------------------------\n\nTITLE: Defining Utility Files and Library (CMake)\nDESCRIPTION: This snippet defines a list of utility files (`test_utility_files`) and creates a library named `test_utility` from these files.  It then links this library with `azrtos::netxduo` and sets include directories and compile definitions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/regression/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nset(test_utility_files\n    ${SOURCE_DIR}/netxtestcontrol.c\n    ${SOURCE_DIR}/nx_crypto_ciphersuites_regression.c\n    ${SOURCE_DIR}/nx_ram_network_driver_test_1500.c\n    ${SOURCE_DIR}/nx_secure_fips_test_utility.c)\n\nadd_library(test_utility ${test_utility_files})\ntarget_link_libraries(test_utility PUBLIC azrtos::netxduo)\ntarget_include_directories(test_utility PUBLIC ${UTILITY_SOURCE_DIR})\ntarget_compile_definitions(test_utility PUBLIC BATCH_TEST CTEST)\n```\n\n----------------------------------------\n\nTITLE: IRQ Handler with Context Save/Restore - Assembly\nDESCRIPTION: This assembly code shows a basic IRQ handler that saves the system context, performs application-specific ISR processing, and then restores the system context. It uses `_tx_thread_context_save` to save the context and `_tx_thread_context_restore` to restore it.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac5/readme_threadx.txt#_snippet_2\n\nLANGUAGE: Assembly\nCODE:\n```\n    EXPORT  __tx_irq_handler\n    EXPORT  __tx_irq_processing_return      \n__tx_irq_handler\n;\n;    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save\n__tx_irq_processing_return\n;\n;    /* Application ISR call goes here!  */\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Interrupt Service Routine (ISR) in Assembly with ThreadX\nDESCRIPTION: This assembly code demonstrates the structure of an Interrupt Service Routine (ISR) for Cortex-M processors using IAR tools. The ISR saves registers r0 and lr on the stack, performs ISR processing, and then restores the registers before returning. This ISR also has access to the ThreadX API.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/iar/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n        PUBLIC  your_assembly_isr\nyour_assembly_isr:\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation: BSD Socket Samples\nDESCRIPTION: This snippet conditionally appends BSD socket-related sample files to the `sample_files` list if the `-DNX_BSD_ENABLE` flag is present in the `CMAKE_BUILD_TYPE`. It adds `demo_bsd_raw.c`, `demo_bsd_tcp.c`, and `demo_bsd_udp.c` to the compilation if the condition is met.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/samples/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"-DNX_BSD_ENABLE\" IN_LIST ${CMAKE_BUILD_TYPE})\n  list(APPEND sample_files ${SOURCE_DIR}/demo_bsd_raw.c\n       ${SOURCE_DIR}/demo_bsd_tcp.c ${SOURCE_DIR}/demo_bsd_udp.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuration Parameters for armcortexm0ct\nDESCRIPTION: This configuration snippet defines parameters for the armcortexm0ct module, including semihosting enablement (armcortexm0ct.semihosting-enable), CPI calculation multipliers and dividers (armcortexm0ct.cpi_div, armcortexm0ct.cpi_mul), and minimum synchronization level (armcortexm0ct.min_sync_level). These parameters are used to customize the behavior of the module.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/ARMCM0_config.txt#_snippet_0\n\nLANGUAGE: config\nCODE:\n```\narmcortexm0ct.semihosting-enable=0\narmcortexm0ct.cpi_div=1\narmcortexm0ct.cpi_mul=1\narmcortexm0ct.min_sync_level=3\n```\n\n----------------------------------------\n\nTITLE: Including Cipher Subdirectory in CMake\nDESCRIPTION: This command includes the 'cipher' subdirectory in the CMake build process. It enables the compilation and linking of the cipher module as part of the overall project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(cipher)\n```\n\n----------------------------------------\n\nTITLE: Library Installation Directory Configuration CMake\nDESCRIPTION: This snippet sets the installation directory for libraries (`CMAKE_INSTALL_LIBDIR`) to the value of `LIB_INSTALL_DIR` if `LIB_INSTALL_DIR` is defined. This allows customization of the library installation location.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_22\n\nLANGUAGE: cmake\nCODE:\n```\nif(LIB_INSTALL_DIR)\n    set(CMAKE_INSTALL_LIBDIR \"${LIB_INSTALL_DIR}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Apache License Boilerplate Example\nDESCRIPTION: This is the boilerplate code that should be added to your files to apply the Apache 2.0 license. Replace {yyyy} with the year and {name of copyright owner} with the appropriate name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ROT/OEMiROT_Boot/APACHE-2.0.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nCopyright {yyyy} {name of copyright owner}\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Target Compile Options for ThreadX\nDESCRIPTION: This snippet adds compile options specific to the ThreadX library. It enables event tracing (`-DTX_ENABLE_EVENT_TRACE`) and conditionally disables the Linux no-idle feature (`-DTX_LINUX_NO_IDLE_ENABLE`) if `ENV{ENABLE_IDLE}` is not defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/libs/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(threadx PRIVATE -DTX_ENABLE_EVENT_TRACE)\nif(NOT DEFINED ENV{ENABLE_IDLE})\n  target_compile_options(threadx PRIVATE -DTX_LINUX_NO_IDLE_ENABLE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Compiling fuzz targets without oss-fuzz\nDESCRIPTION: This script configures, builds, and compiles the code with the compiler flags of the wished sanitizer to be used without oss-fuzz.  It requires perl, cmake and make to be installed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/fuzz/README.md#_snippet_1\n\nLANGUAGE: Shell Script\nCODE:\n```\nperl scripts/config.py set MBEDTLS_PLATFORM_TIME_ALT\nmkdir build\ncd build\ncmake ..\nmake\n```\n\n----------------------------------------\n\nTITLE: Project Definition\nDESCRIPTION: Defines the project name as CMSISDSPComplexMath. This is the top-level project name used by CMake.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nproject(CMSISDSPComplexMath)\n```\n\n----------------------------------------\n\nTITLE: Enabling Source ZIP Generation\nDESCRIPTION: Configures CPack to generate a ZIP archive containing the project's source code.  It defines patterns for files and directories to exclude from the archive using regular expressions.  CPACK_SOURCE_GENERATOR is set to \"ZIP\" to select the ZIP archive generator.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(CPACK_SOURCE_GENERATOR \"ZIP\")\nset(CPACK_SOURCE_IGNORE_FILES\n  \\\\.git/\n  \\\\.github/\n  _build/\n  \\\\.git\n  \\\\.gitattributes\n  \\\\.gitignore\n  \".*~$\"\n)\nset(CPACK_VERBATIM_VARIABLES YES)\ninclude(CPack)\n```\n\n----------------------------------------\n\nTITLE: Get Key Derivation Input Type Function (C)\nDESCRIPTION: This function retrieves the type of a key derivation input for a specific step. It takes a pointer to the `psa_crypto_driver_key_derivation_inputs_t` structure and a `psa_key_derivation_step_t` as input and returns a `psa_crypto_driver_key_derivation_input_type_t` indicating the input type.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\npsa_crypto_driver_key_derivation_input_type_t psa_crypto_driver_key_derivation_get_input_type(\n    const psa_crypto_driver_key_derivation_inputs_t *inputs,\n    psa_key_derivation_step_t step);\n```\n\n----------------------------------------\n\nTITLE: Project Setup and Options (CMake)\nDESCRIPTION: This snippet sets the minimum CMake version, defines the project name and languages (C and ASM), and introduces options to enable LevelX in standalone mode and include FileX dependencies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\n\n# Set up the project\nproject(levelx\n    LANGUAGES C ASM\n)\n\noption(LX_STANDALONE_ENABLE \"Enable LevelX in standalone mode\" OFF)\noption(LX_ENABLE_FILE_SERVERS \"Includes a dependency on FileX\" ON)\n```\n\n----------------------------------------\n\nTITLE: Configuring FileX C Source Files with CMake\nDESCRIPTION: This CMake snippet configures the target sources for the FileX library. It specifies a list of C source files located in the `src` directory to be included in the compilation process. The `target_sources` command associates these files with the specified project name, ensuring they are compiled and linked into the resulting library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/common/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_attributes_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_attributes_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_default_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_default_get_copy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_default_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_entry_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_entry_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_exFAT_entry_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_exFAT_entry_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_exFAT_free_search.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_exFAT_unicode_entry_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_first_entry_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_first_full_entry_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_free_search.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_information_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_local_path_clear.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_local_path_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_local_path_get_copy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_local_path_restore.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_local_path_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_long_name_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_long_name_get_extended.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_name_extract.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_name_test.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_next_entry_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_next_full_entry_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_rename.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_search.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_short_name_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_directory_short_name_get_extended.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_add_FAT_log.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_add_bitmap_log.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_add_checksum_log.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_add_dir_log.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_apply_logs.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_calculate_checksum.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_cleanup_FAT_chain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_create_log_file.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_read_FAT.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_read_directory_sector.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_read_log_file.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_recover.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_reset_log_file.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_set_FAT_chain.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_transaction_end.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_transaction_fail.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_transaction_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_fault_tolerant_write_log_file.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_attributes_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_attributes_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_best_effort_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_close.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_date_time_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_extended_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_extended_best_effort_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_extended_relative_seek.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_extended_seek.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_extended_truncate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_extended_truncate_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_open.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_relative_seek.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_rename.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_seek.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_truncate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_truncate_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_file_write_notify_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_boot_info_extract.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_cache_invalidate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_check_FAT_chain_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_check_lost_cluster_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_close.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_close_notify_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_exFAT_format.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_extended_space_available.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_flush.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_format.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_format_oem_name_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_format_type_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_format_volume_id_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_open.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_open_notify_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_space_available.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_volume_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_volume_get_extended.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_volume_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_media_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_partition_offset_calculate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_ram_driver.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_system_date_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_system_date_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_system_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_system_time_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_system_time_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_system_timer_entry.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_trace_event_insert.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_trace_event_update.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_trace_object_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_trace_object_unregister.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_directory_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_directory_entry_change.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_directory_entry_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_directory_rename.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_directory_search.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_file_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_file_rename.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_length_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_length_get_extended.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_name_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_name_get_extended.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_short_name_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_unicode_short_name_get_extended.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_16_unsigned_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_16_unsigned_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_32_unsigned_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_32_unsigned_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_64_unsigned_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_64_unsigned_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_FAT_entry_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_FAT_entry_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_FAT_flush.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_FAT_map_flush.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_FAT_sector_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_absolute_path_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_allocate_new_cluster.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_bitmap_cache_prepare.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_bitmap_cache_update.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_bitmap_flush.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_bitmap_free_cluster_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_bitmap_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_bitmap_start_sector_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_cluster_free.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_cluster_state_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_cluster_state_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_geometry_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_name_hash_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_size_calculate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_system_area_checksum_verify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_system_area_checksum_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_system_area_format.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_system_sector_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_unicode_name_hash_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_exFAT_upcase_table.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_logical_sector_cache_entry_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_logical_sector_flush.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_logical_sector_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_logical_sector_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_memory_copy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_memory_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_string_length_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_utility_token_length_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fxe_directory_attributes_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fxe_directory_attributes_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fxe_directory_create.c\n```\n\n----------------------------------------\n\nTITLE: Iterating and Configuring Executables\nDESCRIPTION: This CMake snippet iterates through the lists of executables, sets source files, and includes conditional logic. It appends 'onefile.c' if FUZZINGENGINE_LIB is not found, 'common.c' if the executable is in the 'executables_with_common_c' list, adds the executable, sets include directories, and links libraries based on the presence of FUZZINGENGINE_LIB.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/fuzz/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(exe IN LISTS executables_no_common_c executables_with_common_c)\n\n    set(exe_sources ${exe}.c $<TARGET_OBJECTS:mbedtls_test>)\n    if(NOT FUZZINGENGINE_LIB)\n        list(APPEND exe_sources onefile.c)\n    endif()\n\n    # This emulates \"if ( ... IN_LIST ... )\" which becomes available in CMake 3.3\n    list(FIND executables_with_common_c ${exe} exe_index)\n    if(${exe_index} GREATER -1)\n        list(APPEND exe_sources common.c)\n    endif()\n\n    add_executable(${exe} ${exe_sources})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\n\n    if (NOT FUZZINGENGINE_LIB)\n        target_link_libraries(${exe} ${libs})\n    else()\n        target_link_libraries(${exe} ${libs} FuzzingEngine)\n        SET_TARGET_PROPERTIES(${exe} PROPERTIES LINKER_LANGUAGE CXX)\n    endif()\n\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Modify XML Content from Another XML (Bash)\nDESCRIPTION: This command employs `xmlval` to copy the value of a parameter from one XML file to another, filtering by `<Name>` in the source XML and by `<Command>` in the destination XML. It modifies the `<Value>` tag in the destination XML with the value found in the source XML. Requires specifying both xml files and the filter parameters.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nxmlval -xml OEMiRoT_Secure_Code.xml -nxml Firmware area size -c S OEMiRoT_NonSecure_Code.xml\n```\n\n----------------------------------------\n\nTITLE: Conditional Mbed TLS Header Installation CMake\nDESCRIPTION: This snippet conditionally installs Mbed TLS and PSA headers to the include directories. It uses the `INSTALL_MBEDTLS_HEADERS` option to determine whether to install the headers.  It defines the destination directory and file permissions for the installation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/include/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\noption(INSTALL_MBEDTLS_HEADERS \"Install Mbed TLS headers.\" ON)\n\nif(INSTALL_MBEDTLS_HEADERS)\n\n    file(GLOB headers \"mbedtls/*.h\")\n    file(GLOB psa_headers \"psa/*.h\")\n\n    install(FILES ${headers}\n        DESTINATION include/mbedtls\n        PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ)\n\n    install(FILES ${psa_headers}\n        DESTINATION include/psa\n        PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ)\n\nendif(INSTALL_MBEDTLS_HEADERS)\n```\n\n----------------------------------------\n\nTITLE: Define Target Include Directories CMake\nDESCRIPTION: This snippet defines the target include directories for the project using the `target_include_directories` command in CMake. The `PUBLIC` keyword indicates that these directories are exposed to other projects that might depend on it. `${CMAKE_CURRENT_LIST_DIR}/inc` specifies that the include directory is located in the `inc` subdirectory of the current CMake list file's directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/crypto_libraries/ports/cortex_m3/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Key Derivation Driver Output Bytes Function Prototype (PSA)\nDESCRIPTION: This code snippet defines the function prototype for a key derivation driver's output bytes entry point. This function is called by the PSA core to retrieve derived key material as a byte stream. It takes the operation context, a pointer to the output buffer, and the desired output length as parameters and returns a PSA status code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_16\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_key_derivation_output_bytes(\n    acme_key_derivation_operation_t *operation,\n    uint8_t *output, size_t length);\n```\n\n----------------------------------------\n\nTITLE: Create Executable for IoT Hub Twin Sample\nDESCRIPTION: This snippet creates an executable named `paho_iot_hub_twin_sample` from the `paho_iot_hub_twin_sample.c` file and links it against the common library. It then defines a map file using the create_map_file macro.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable (paho_iot_hub_twin_sample\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_hub_twin_sample.c\n)\n\ntarget_link_libraries(paho_iot_hub_twin_sample\n  PRIVATE\n    az::iot::sample::common\n)\n\ncreate_map_file(paho_iot_hub_twin_sample paho_iot_hub_twin_sample.map)\n```\n\n----------------------------------------\n\nTITLE: Receiving Cloud-to-Device Message in C\nDESCRIPTION: This function receives a cloud-to-device (C2D) message from Azure IoT Hub. It blocks until a message is received or the timeout expires. The function requires a pointer to the IoT Hub client, a pointer to a packet pointer to store the received message, and a wait option specifying the timeout in ticks. The caller takes ownership of the returned packet.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_21\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_cloud_message_receive(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                   NX_PACKET **packet_pptr,\n                                                   UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Enum for Key Derivation Input Types (C)\nDESCRIPTION: Defines the enumeration for different types of key derivation inputs, which can be invalid, omitted, bytes, key, or integer.  The `psa_crypto_driver_key_derivation_get_input_type()` function uses this enum to determine the type of input for a given derivation step.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nenum psa_crypto_driver_key_derivation_input_type_t {\n    PSA_KEY_DERIVATION_INPUT_TYPE_INVALID = 0,\n    PSA_KEY_DERIVATION_INPUT_TYPE_OMITTED,\n    PSA_KEY_DERIVATION_INPUT_TYPE_BYTES,\n    PSA_KEY_DERIVATION_INPUT_TYPE_KEY,\n    PSA_KEY_DERIVATION_INPUT_TYPE_INTEGER,\n    // Implementations may add other values, and may freely choose the\n    // numerical values for each identifer except as explicitly specified\n    // above.\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Driver via CMake (CMake)\nDESCRIPTION: This snippet shows how to enable a custom driver at compile time using CMake, passing the `CFLAGS` variable when invoking CMake. This ensures that the compiler includes the custom driver's code during the build process.  The path to the source code needs to be included.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-driver-example-and-guide.md#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nCFLAGS=\"-DDRIVER_PREFIX_ENABLED\" cmake path/to/source\n```\n\n----------------------------------------\n\nTITLE: RSA PSS Signature Algorithm Constructors in PSA\nDESCRIPTION: Uses the `PSA_ALG_RSA_PSS(hash)` or `PSA_ALG_RSA_PSS_ANY_SALT(hash)` macros for RSA-PSS signatures. The `hash` parameter corresponds to the `md_alg` parameter passed to the legacy API and is used for hashing the message, creating the salted hash, and generating the mask with MGF1.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_40\n\nLANGUAGE: C\nCODE:\n```\nPSA_ALG_RSA_PSS(PSA_ALG_SHA256)\nPSA_ALG_RSA_PSS_ANY_SALT(PSA_ALG_SHA256)\n```\n\n----------------------------------------\n\nTITLE: Executing Build Operation\nDESCRIPTION: This command executes the build operation on all GHS and IAR example projects. The azrtos_cicd.old.bat script is called with the 'build' parameter, followed by the target framework ('tx') and the toolchains ('ghs' and 'iar'). This will compile the specified example projects using the GHS and IAR toolchains.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.old.md#_snippet_0\n\nLANGUAGE: batch\nCODE:\n```\nazrtos_cicd.old.bat build tx ghs iar\n```\n\n----------------------------------------\n\nTITLE: Selecting RTC Clock Source in main.c (C)\nDESCRIPTION: This code snippet demonstrates how to select either LSI or LSE as the RTC clock source in the main.c file.  The user can uncomment the appropriate `#define` to choose the desired clock source. LSI is a 32 kHz RC oscillator, while LSE is a 32.768 kHz crystal oscillator. Choosing LSE requires additional configuration in STM32CubeMX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples_LL/RTC/RTC_Calendar_Init/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n/* #define RTC_CLOCK_SOURCE_LSI */\n\n/* #define RTC_CLOCK_SOURCE_LSE */\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources in CMake\nDESCRIPTION: This CMake code snippet adds source files to the specified target (`${PROJECT_NAME}`). The actual source files should be placed between the `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` markers. This snippet uses the `target_sources` command with the `PRIVATE` keyword, meaning these sources are only used for building the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/win32/vs_2019/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Cortex-M ISR in Assembly with ThreadX\nDESCRIPTION: This code snippet demonstrates how to write an Interrupt Service Routine (ISR) in assembly language that is compatible with ThreadX on Cortex-M.  The ISR must preserve the register state and return using BX lr.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/ac5/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    EXPORT  your_assembly_isr\nyour_assembly_isr\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Define Target Sources CMake\nDESCRIPTION: This snippet defines the target sources for the project using the `target_sources` command in CMake. The `PRIVATE` keyword indicates that these sources are only used internally by the project and are not exposed to other projects that might depend on it. Currently, the source list is empty, indicated by the comments.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/crypto_libraries/ports/cortex_m3/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Setting DNS Test Cases\nDESCRIPTION: This snippet defines a list of C source files that represent the DNS regression tests. These tests cover various aspects of DNS client functionality, including request processing, error handling, and API usage.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nset(dns_test_cases\n    ${SOURCE_DIR}/dns_test/netx_dns_coverage_test.c\n    ${SOURCE_DIR}/dns_test/netx_dns_function_test.c\n    ${SOURCE_DIR}/dns_test/netx_dns_request_a_response_cname_a_smtp_live_com_test.c\n    ${SOURCE_DIR}/dns_test/netx_dns_invalid_name_unencode_test.c\n    ${SOURCE_DIR}/dns_test/netx_dns_invalid_resource_get_test.c\n    ${SOURCE_DIR}/dns_test/netx_dns_abnormal_packet_test.c\n    ${SOURCE_DIR}/dns_test/netx_dns_source_port_test.c\n    ${SOURCE_DIR}/dns_test/netx_dns_non_blocking_a_test.c\n    ${SOURCE_DIR}/dns_test/netx_dns_nxe_api_test.c\n    ${SOURCE_DIR}/dns_test/netx_dns_fake_response_test.c\n    ${SOURCE_DIR}/dns_test/netx_dns_packet_double_release_test.c)\n```\n\n----------------------------------------\n\nTITLE: Sector Swap States\nDESCRIPTION: Defines the four states that each sector index transitions through during a swap operation. These states describe the location of images (image 0, image 1) in the primary slot, secondary slot, and scratch area.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n0. primary slot: image 0,   secondary slot: image 1,   scratch: N/A\n1. primary slot: image 0,   secondary slot: N/A,       scratch: image 1 (1->s, erase 1)\n2. primary slot: N/A,       secondary slot: image 0,   scratch: image 1 (0->1, erase 0)\n3. primary slot: image 1,   secondary slot: image 0,   scratch: N/A     (s->0)\n```\n\n----------------------------------------\n\nTITLE: Destroying Key PSA\nDESCRIPTION: This code snippet shows how to free the resources used by a key object using the `psa_destroy_key` function. This function should be called after all operations with the key are finished to avoid resource leaks.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_16\n\nLANGUAGE: C\nCODE:\n```\npsa_destroy_key\n```\n\n----------------------------------------\n\nTITLE: Define sigdelset Function Prototype in C\nDESCRIPTION: Defines the prototype for the `sigdelset` function, used for deleting a signal from a signal set. It takes a pointer to a signal set and the signal number to delete.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nINT                   sigdelset(sigset_t *set, int signo)\n```\n\n----------------------------------------\n\nTITLE: Building ThreadX Library Conditionally\nDESCRIPTION: This snippet conditionally builds the ThreadX library using a shell script. If the build type is not \"standalone_build\", it executes the `run.sh` script to build the libraries, adds a custom target for building libraries, adds a dependency on this target for the netxduo target and sets include directories and imports the threadx library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/crypto/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"standalone_build\"))\n  execute_process(COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh build_libs)\n  add_custom_target(build_libs ALL COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh\n                                           build_libs)\n  add_dependencies(netxduo build_libs)\n  target_include_directories(netxduo PUBLIC ${CMAKE_BINARY_DIR}/../libs/inc)\n  add_library(threadx SHARED IMPORTED GLOBAL)\n  add_library(\"azrtos::threadx\" ALIAS threadx)\n  set_target_properties(\n    threadx PROPERTIES IMPORTED_LOCATION\n                       ${CMAKE_BINARY_DIR}/../libs/threadx/libthreadx.so)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories with CMake\nDESCRIPTION: This CMake snippet sets the include directories for the project. It uses the `target_include_directories` command with the `PUBLIC` scope, meaning these include directories are available to other targets that depend on this one. `${CMAKE_CURRENT_LIST_DIR}/inc` specifies the 'inc' directory within the directory containing the current CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/ports/linux/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Root Variable in CMake\nDESCRIPTION: This snippet sets the ROOT variable to the path specified by the CMSIS_PATH variable. This variable is used as the base path for locating various CMSIS components, such as NN, Core, and DSP.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nSET(ROOT ${CMSIS_PATH})\n```\n\n----------------------------------------\n\nTITLE: Size of Dynamically Allocated Key Context\nDESCRIPTION: Illustrates how to calculate the size of a dynamically allocated key context based on the `size_function` property in the driver specification. The size is determined by calling the function named in `size_function` with the key type and key size as arguments.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_38\n\nLANGUAGE: C\nCODE:\n```\nsize_function(key_type, key_bits)\n```\n\n----------------------------------------\n\nTITLE: Getting Bytes Used\nDESCRIPTION: Returns the length of the JSON text written to the underlying buffer by the JSON writer.  This function is helpful for determining the size of the JSON data that has been created.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_19\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_json_writer_get_bytes_used(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr);\n```\n\n----------------------------------------\n\nTITLE: Enable Testing and Add Subdirectories\nDESCRIPTION: Enables testing for the project and adds subdirectories for the ThreadX library, regression tests, and examples.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nenable_testing()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../../.. threadx)\nadd_subdirectory(regression)\nadd_subdirectory(samples)\n```\n\n----------------------------------------\n\nTITLE: Setting target names\nDESCRIPTION: This snippet defines the target names for the mbedtls, mbedx509, and mbedcrypto libraries, optionally adding a prefix. These target names are used later in the CMake configuration to create the corresponding libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\nset(mbedtls_target    \"${MBEDTLS_TARGET_PREFIX}mbedtls\")\nset(mbedx509_target   \"${MBEDTLS_TARGET_PREFIX}mbedx509\")\nset(mbedcrypto_target \"${MBEDTLS_TARGET_PREFIX}mbedcrypto\")\n\nset(mbedtls_target    ${mbedtls_target}    PARENT_SCOPE)\nset(mbedx509_target   ${mbedx509_target}   PARENT_SCOPE)\nset(mbedcrypto_target ${mbedcrypto_target} PARENT_SCOPE)\n```\n\n----------------------------------------\n\nTITLE: Adding RFFT FAST source files (float16) in CMake\nDESCRIPTION: This snippet conditionally adds various Real FFT Fast (RFFT_FAST) source files for float16 data type based on configuration options to the CMSISDSPTransform library. It requires DISABLEFLOAT16 to NOT be defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_17\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT DISABLEFLOAT16))\nif (NOT CONFIGTABLE OR ALLFFT OR RFFT_FAST_F16_32 OR RFFT_FAST_F16_64 OR RFFT_FAST_F16_128\n   OR RFFT_FAST_F16_256 OR RFFT_FAST_F16_512 OR RFFT_FAST_F16_1024 OR RFFT_FAST_F16_2048\n   OR RFFT_FAST_F16_4096 )\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_fast_f16.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_fast_init_f16.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_f16.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_f16.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix8_f16.c)\nendif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Include Directories with CMake\nDESCRIPTION: This snippet uses the `target_include_directories` command in CMake to specify the include directories for the project.  The `inc` directory is added as a public include directory, making its header files available to other targets that link to this one. This ensures that necessary header files for ThreadX are accessible during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/iar/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Image Header Flags\nDESCRIPTION: This code defines flags used in the `ih_flags` field of the image header. These flags indicate various characteristics of the image, such as whether it is position-independent (`IMAGE_F_PIC`), non-bootable (`IMAGE_F_NON_BOOTABLE`), or loaded into RAM (`IMAGE_F_RAM_LOAD`).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n/*\n * Image header flags.\n */\n#define IMAGE_F_PIC                      0x00000001 /* Not supported. */\n#define IMAGE_F_NON_BOOTABLE             0x00000010 /* Split image app. */\n#define IMAGE_F_RAM_LOAD                 0x00000020\n```\n\n----------------------------------------\n\nTITLE: C ISR Definition - IAR EWARM\nDESCRIPTION: Defines an Interrupt Service Routine (ISR) written in C for Cortex-M using IAR EWARM. This example showcases the basic structure of a C ISR that can be placed in the vector table. It does not require context save/restore functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/iar/readme_threadx.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Setting IoT Provisioning X.509 Environment Variables - Linux\nDESCRIPTION: This code snippet shows how to set the AZ_IOT_PROVISIONING_REGISTRATION_ID and AZ_IOT_PROVISIONING_ID_SCOPE environment variables in a Linux environment.  These variables are necessary for the IoT Provisioning X.509 Certificate sample. Replace `<registration-id>` and `<id-scope>` with the values from your Azure IoT Hub Device Provisioning Service.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nexport AZ_IOT_PROVISIONING_REGISTRATION_ID=<registration-id>\nexport AZ_IOT_PROVISIONING_ID_SCOPE=<id-scope>\n```\n\n----------------------------------------\n\nTITLE: Modify WRP and HDP Protections\nDESCRIPTION: This command uses the `setob` tool to modify WRP (Write Protection) and HDP (Hardware Data Protection) settings in a script file. It calculates protection values based on macro symbols found in the `image_macros_preprocessed_bl2.c` file and updates the specified protection value in the script.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_22\n\nLANGUAGE: text\nCODE:\n```\nsetob --layout image_macros_preprocessed_bl2.c -b wrpgrp1 -ms RE_BL2_WRP_START -me RE_BL2_WRP_END -msec RE_FLASH_PAGE_NBR -d 0x8000  ob_flash_programming.bat\n```\n\n----------------------------------------\n\nTITLE: Adding Bayes Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the BayesFunctions subdirectory and links the CMSISDSPBayes library to the CMSISDSP interface library if the BAYES flag is set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_37\n\nLANGUAGE: cmake\nCODE:\n```\nif (BAYES)\n  add_subdirectory(BayesFunctions)\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPBayes)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing OpenSSL on Linux\nDESCRIPTION: This snippet installs OpenSSL and its development libraries on a Linux system using the apt-get package manager. This provides cryptographic functionalities for the development environment.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install openssl libssl-dev\n```\n\n----------------------------------------\n\nTITLE: Getting the Int32 Value of a JSON Token in C\nDESCRIPTION: Gets the JSON token's number as a 32-bit signed integer. It requires a pointer to the reader instance and a pointer to a variable to store the signed integer value. On success, it returns NX_AZURE_IOT_SUCCESS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_token_int32_get(NX_AZURE_IOT_JSON_READER *reader_ptr,\n                                              int32_t *value_ptr);\n```\n\n----------------------------------------\n\nTITLE: Install Executables CMake\nDESCRIPTION: Installs the generated executables to the 'bin' directory with specific permissions. The permissions set the owner to read, write, and execute; the group to read and execute; and the world to read and execute.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/hash/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS ${executables}\n        DESTINATION \"bin\"\n        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n```\n\n----------------------------------------\n\nTITLE: Disabling Command Message Receiving - C\nDESCRIPTION: This function disables the reception of command messages from IoT Hub.  It requires a pointer to a valid `NX_AZURE_IOT_HUB_CLIENT` instance and returns a status code indicating success or failure. Potential failure reasons include invalid parameters, MQTT connection problems, lack of available packets, or TCP/TLS related communication errors.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_28\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_command_disable(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Nested IRQ Handler in ThreadX Assembly\nDESCRIPTION: This assembly code shows how to enable nested IRQ interrupts in a standard IRQ handler (__tx_irq_handler) within ThreadX. It calls _tx_thread_irq_nesting_start to enable nested interrupts (switching to SYS mode) and _tx_thread_irq_nesting_end to disable them (switching back to IRQ mode). Building the library with TX_ENABLE_IRQ_NESTING defined makes these functions available.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/cortex_a7_smp/ac5/readme_threadx.txt#_snippet_2\n\nLANGUAGE: assembly\nCODE:\n```\n    EXPORT  __tx_irq_handler\n    EXPORT  __tx_irq_processing_return      \n__tx_irq_handler\n;\n;    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save\n__tx_irq_processing_return\n;\n;    /* Enable nested IRQ interrupts. NOTE:  Since this service returns\n;       with IRQ interrupts enabled, all IRQ interrupt sources must be \n;       cleared prior to calling this service.  */\n    BL      _tx_thread_irq_nesting_start\n;    \n;    /* Application ISR call(s) go here!  */\n;\n;    /* Disable nested IRQ interrupts. The mode is switched back to\n;       IRQ mode and IRQ interrupts are disable upon return.  */\n    BL      _tx_thread_irq_nesting_end\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Adding RFFT source files (float32) in CMake\nDESCRIPTION: This snippet conditionally adds Real FFT source files for float32 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_18\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR RFFT_F32_128 OR RFFT_F32_512 OR RFFT_F32_2048 OR RFFT_F32_8192)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_init_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_init_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_f32.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration\nDESCRIPTION: This snippet shows how to configure the linker file in MDK-ARM to define the RW_IRAM1 region or modify tx_initialize_low_level.S to match the memory region being used by ThreadX. This enables ThreadX to properly manage memory allocation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Applications/ThreadX/Tx_CMSIS_Wrapper/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S\" to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Setting compiler flags for Clang\nDESCRIPTION: This snippet sets the C compiler flags to include `-Wmissing-declarations`, `-Wdocumentation`, `-Wno-documentation-deprecated-sync`, and `-Wunreachable-code` when the compiler is Clang.  These flags enable warnings for missing declarations, documentation issues, and unreachable code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_COMPILER_IS_CLANG)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wmissing-declarations -Wdocumentation -Wno-documentation-deprecated-sync -Wunreachable-code\")\nendif(CMAKE_COMPILER_IS_CLANG)\n```\n\n----------------------------------------\n\nTITLE: Defining Executable Target\nDESCRIPTION: Defines the executable target for the project. Specifies the name of the executable that will be built.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_variance_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(arm_variance_example)\n```\n\n----------------------------------------\n\nTITLE: Syntax - Remove-TestResources ResourceGroup+Provisioner Set - PowerShell\nDESCRIPTION: This snippet defines the syntax for the `Remove-TestResources.ps1` script using the `ResourceGroup+Provisioner` parameter set. It includes parameters for `ResourceGroupName`, `TenantId`, `SubscriptionId`, `ProvisionerApplicationId`, `ProvisionerApplicationSecret`, `ServiceDirectory`, `Environment`, `CI`, `Force`, and `RemoveTestResourcesRemainingArguments`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/Remove-TestResources.ps1.md#_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\nRemove-TestResources.ps1 -ResourceGroupName <String> -TenantId <String> [-SubscriptionId <String>]\n -ProvisionerApplicationId <String> -ProvisionerApplicationSecret <String> [[-ServiceDirectory] <String>]\n [-Environment <String>] [-CI] [-Force] [-RemoveTestResourcesRemainingArguments <Object>] [-WhatIf] [-Confirm]\n [<CommonParameters>]\n```\n\n----------------------------------------\n\nTITLE: Export Public Key Prototype - C\nDESCRIPTION: Defines the function prototype for the `export_public_key` entry point in a PSA opaque driver. This function exports the public key from a key pair. It takes key attributes, a key buffer, its size, a data buffer, its size, and a pointer to store the data length as input, and returns a PSA status.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_48\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_export_public_key(const psa_key_attributes_t *attributes,\n                                    const uint8_t *key_buffer,\n                                    size_t key_buffer_size,\n                                    uint8_t *data,\n                                    size_t data_size,\n                                    size_t *data_length);\n```\n\n----------------------------------------\n\nTITLE: Setting Model ID for Azure IoT Hub Client (C)\nDESCRIPTION: This function sets the model ID in the Azure IoT Hub client to enable Plug and Play (PnP) functionality. It takes a pointer to the client instance, a pointer to the model ID string, and the length of the model ID as input.  A successful operation sets the model ID to the IoTHub client; otherwise, it fails due to an invalid parameter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_model_id_set(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                          const UCHAR *model_id_ptr, UINT model_id_length);\n```\n\n----------------------------------------\n\nTITLE: Create Build Directory and Configure with CMake (PowerShell)\nDESCRIPTION: These commands create a `build` directory, navigate into it, and then use CMake to configure the build process. The `-DTRANSPORT_PAHO=ON` option enables the PAHO MQTT transport.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_9\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS C:\\azure-sdk-for-c\\sdk\\samples\\iot> cd ../../..\nPS C:\\azure-sdk-for-c> mkdir build\nPS C:\\azure-sdk-for-c> cd build\nPS C:\\azure-sdk-for-c\\build> cmake -DTRANSPORT_PAHO=ON ..\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration\nDESCRIPTION: This snippet shows how to add a section to the EWARM linker (.icf) file to define the memory region for dynamic memory allocation in ThreadX. The `place in RAM_region { last section FREE_MEM };` line ensures that the last section of free memory is placed in the RAM region, making it available for dynamic allocation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Device_CDC_ECM/README.md#_snippet_0\n\nLANGUAGE: Other\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE ThreadX Heap Section\nDESCRIPTION: This code snippet defines a `._threadx_heap` section in the STM32CubeIDE linker file (`.ld`). This section allocates 64KB of memory for the ThreadX heap, located between the `.bss` and `._user_heap_stack` sections. `__RAM_segment_used_end__` symbol is used to mark the end of used RAM.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/NetXDuo/Nx_Iperf/README.md#_snippet_3\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n{\n   . = ALIGN(8);\n   __RAM_segment_used_end__ = .;\n   . = . + 64K;\n   . = ALIGN(8);\n} >RAM AT> RAM\n```\n\n----------------------------------------\n\nTITLE: Delete After Hours Parameter\nDESCRIPTION: Specifies the number of hours from the current time to set the 'DeleteAfter' tag on the created resource group.  This is used for automated cleanup, where resource groups with expired 'DeleteAfter' timestamps can be automatically deleted, commonly used in CI automation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nType: Int32\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: 120\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows how to add a new section in the STM32CubeIDE linker (.ld) file to define memory for ThreadX. It creates a `._threadx_heap` section of 64KB within the `RAM_D1` region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/USBX/Ux_Device_HID/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n{\n   . = ALIGN(8);\n   __RAM_segment_used_end__ = .;  \n   . = . + 64K;\n   . = ALIGN(8);\n} >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Add Include Directories with CMake\nDESCRIPTION: This snippet adds include directories to the project using CMake's `target_include_directories` command. It defines the include directory as `PUBLIC`, meaning it will be added to the include paths of the current target and any other target that links against it. The include directory is the 'inc' directory located relative to the current CMake list file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m55/ac6/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Include FFT Configuration\nDESCRIPTION: Includes the fft CMake script to configure FFT-related settings for the CMSISDSPCommon library. This script handles specific configurations related to Fast Fourier Transform (FFT) functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(fft)\nfft(CMSISDSPCommon)\n```\n\n----------------------------------------\n\nTITLE: ARM Cortex-M3 Semihosting Configuration\nDESCRIPTION: This parameter enables or disables semihosting SVC traps. Applications not using semihosting should set this to false. The default value is 1 (enabled).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/ARMCM3_config.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.semihosting-enable=0                    # (bool  , init-time) default = '1'      : Enable semihosting SVC traps. Applications that do not use semihosting must set this parameter to false.\n```\n\n----------------------------------------\n\nTITLE: Constant Definition: Max Persistent Key Identifier (Mbed Crypto 0.1.0)\nDESCRIPTION: This C preprocessor definition specifies the upper bound for persistent key identifiers in Mbed Crypto version 0.1.0. Although named 'MAX_PERSISTENT_KEY_IDENTIFIER', the value represents one plus the actual maximum permitted key identifier. It's used internally to validate key IDs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/mbed-crypto-storage-specification.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define PSA_MAX_PERSISTENT_KEY_IDENTIFIER 0xffff0000\n```\n\n----------------------------------------\n\nTITLE: Create Executables for Each Sample\nDESCRIPTION: This snippet iterates through the defined sample files, creates an executable for each, and links it against the 'azrtos::threadx_smp' library. It extracts the sample name and adds a 'fake.c' file during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/samples/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(sample_file ${sample_files})\n  get_filename_component(sample_file_name ${sample_file} NAME_WE)\n  add_executable(${sample_file_name} ${sample_file} ${CMAKE_CURRENT_LIST_DIR}/fake.c)\n  target_link_libraries(${sample_file_name} PRIVATE azrtos::threadx_smp)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Setting CMake project and policies\nDESCRIPTION: This snippet sets the minimum required CMake version, and declares the project name and language.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(regression_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Setting vcpkg environment variables in PowerShell\nDESCRIPTION: This PowerShell script sets the VCPKG_DEFAULT_TRIPLET and VCPKG_ROOT environment variables. The VCPKG_DEFAULT_TRIPLET variable specifies the target architecture and operating system (in this case, x64-windows-static), while the VCPKG_ROOT variable specifies the location of the vcpkg installation directory. These environment variables are required for CMake to find the vcpkg-installed libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS C:\\> $env:VCPKG_DEFAULT_TRIPLET='x64-windows-static'\nPS C:\\> $env:VCPKG_ROOT='C:\\vcpkg'\n```\n\n----------------------------------------\n\nTITLE: Linking against CMSISDSP\nDESCRIPTION: Links the arm_matrix_example executable against the CMSISDSP library. This allows the application to use the CMSIS-DSP functions and data structures.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(arm_matrix_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Creating Code Coverage Targets\nDESCRIPTION: Creates code coverage targets for the `az_core` library using the `create_code_coverage_targets` macro. This enables code coverage analysis during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/core/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\ncreate_code_coverage_targets(az_core)\n```\n\n----------------------------------------\n\nTITLE: Adding DCT4 source files (Q31) in CMake\nDESCRIPTION: This snippet conditionally adds various DCT4 source files for Q31 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR DCT4_Q31_128 OR DCT4_Q31_512 OR DCT4_Q31_2048 OR DCT4_Q31_8192)\ntarget_sources(CMSISDSPTransform PRIVATE arm_dct4_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_dct4_init_q31.c)\n\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_init_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_init_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_q31.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Globbing Source Files with CMake\nDESCRIPTION: This CMake snippet uses the `file(GLOB)` command to find all C source files matching the patterns `./*_s8*.c` and `./*_s16*.c`. The found files are stored in the `SRC` and `SRC_S16` variables, respectively, which are later used to add these files to the `cmsis-nn` target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/ConvolutionFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SRC \"./*_s8*.c\")\nfile(GLOB SRC_S16 \"./*_s16*.c\")\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This snippet shows how to modify the MDK-ARM linker configuration file (.sct) or the tx_initialize_low_level.S file to allocate memory for ThreadX. It either defines the RW_IRAM1 region or modifies the line in tx_initialize_low_level.S to match the memory region used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_CDC_ACM/README.md#_snippet_1\n\nLANGUAGE: MDK-ARM Linker/Assembly\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Cortex-M ISR in C using IAR EWARM\nDESCRIPTION: This code snippet demonstrates the structure of an Interrupt Service Routine (ISR) written in C for Cortex-M processors using the IAR EWARM toolchain. The ISR does not require explicit context saving or restoring calls, allowing direct access to ThreadX APIs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/iar/readme_threadx.txt#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Test Utility Library with Source Files\nDESCRIPTION: This snippet adds a static library named `test_utility` and includes source files `fx_ram_driver_test.c` and `filextestcontrol.c`. The `test_utility` library is linked with the `azrtos::filex` library, and it defines the compilation definitions `BATCH_TEST` and `CTEST`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/regression/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(test_utility ${SOURCE_DIR}/fx_ram_driver_test.c\n                         ${SOURCE_DIR}/filextestcontrol.c)\ntarget_link_libraries(test_utility PUBLIC azrtos::filex)\ntarget_compile_definitions(test_utility PUBLIC BATCH_TEST CTEST)\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories in CMake\nDESCRIPTION: This CMake snippet uses `target_include_directories` to add include directories to the project.  `${PROJECT_NAME}` is the project's name, `PUBLIC` makes these directories available to other projects that depend on this one, and `${CMAKE_CURRENT_LIST_DIR}/inc` adds the 'inc' directory in the current CMake list file's directory to the include path.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m3/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: Adds subdirectories for different components of the SDK.  It includes the core library, IoT components, and platform abstraction layer (PAL). These subdirectories contain their own CMakeLists.txt files that define how to build those components.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(sdk/src/azure/core)\n\n# SDK Clients\nadd_subdirectory(sdk/src/azure/iot)\n\n#PAL (Hardware + HTTP)\nadd_subdirectory(sdk/src/azure/platform)\n```\n\n----------------------------------------\n\nTITLE: Cortex-M ISR in Assembly using IAR EWARM\nDESCRIPTION: This code snippet shows the structure of an ISR written in assembly language for Cortex-M processors using the IAR EWARM toolchain. It demonstrates how to push and pop registers from the stack before and after ISR processing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/iar/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n        PUBLIC  your_assembly_isr\nyour_assembly_isr:\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Configuring Deprecated CFFT Options (Q15) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable deprecated Complex FFT (CFFT) implementations for Q15 data types using radix-2 and radix-4 algorithms. These options are included for backward compatibility but are marked as deprecated.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_22\n\nLANGUAGE: CMake\nCODE:\n```\noption(ARM_CFFT_RADIX2_Q15   \"deprecated q15 radix2 cfft\"       OFF)\noption(ARM_CFFT_RADIX4_Q15   \"deprecated q15 radix4 cfft\"       OFF)\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version and Project Details\nDESCRIPTION: This snippet sets the minimum required CMake version and defines the project name and version.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_linear_interp_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_linear_interp_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: Creating and Building with CMake\nDESCRIPTION: This snippet shows how to create a build directory, navigate into it, and then use CMake to generate build files from the Mbed TLS source. Finally, it builds the project using the generated build files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nmkdir /path/to/build_dir && cd /path/to/build_dir\ncmake /path/to/mbedtls_source\ncmake --build .\n```\n\n----------------------------------------\n\nTITLE: Defining types-Jinja2 Dependency with Version Constraint\nDESCRIPTION: This line defines a dependency on the `types-Jinja2` package, which provides type annotations for Jinja2. Version 2.11.9 or greater is required to provide accurate type hinting.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/scripts/driver.requirements.txt#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ntypes-Jinja2 >= 2.11.9\n```\n\n----------------------------------------\n\nTITLE: Typedef for Key Derivation Inputs (C)\nDESCRIPTION: Defines an opaque data structure used to convey initial inputs for key derivation to a driver. The specific implementation of this type is driver-dependent.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\ntypedef ... psa_crypto_driver_key_derivation_inputs_t; // implementation-specific type\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Version and Policies\nDESCRIPTION: This snippet sets the minimum required CMake version and defines CMake policies for compatibility and behavior during the build process. It specifies the minimum CMake version to be 3.13 and sets three CMake policies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo_fast/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\ncmake_policy(SET CMP0077 NEW)\n```\n\n----------------------------------------\n\nTITLE: Configuring DCT4 Options (Single Precision) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Discrete Cosine Transform Type IV (DCT4) implementations for single-precision floating-point numbers (f32) with various sizes (128 to 8192). These options are used to customize the CMSIS-DSP library by selecting specific DCT4 implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\noption(DCT4_F32_128          \"dct4 f32 128\"                     OFF)\noption(DCT4_F32_512          \"dct4 f32 512\"                     OFF)\noption(DCT4_F32_2048         \"dct4 f32 2048\"                    OFF)\noption(DCT4_F32_8192         \"dct4 f32 8192\"                    OFF)\n```\n\n----------------------------------------\n\nTITLE: Initialize CMake and Project\nDESCRIPTION: This snippet initializes the CMake environment by specifying the minimum required version and setting a policy. It then declares a C project named 'regression_test'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(regression_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Building ThreadX SMP core library\nDESCRIPTION: This command builds the ThreadX SMP core library from the makefile. The resulting library file tx.a must be linked with your application to use ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/linux/gnu/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\nmake tx.a\n```\n\n----------------------------------------\n\nTITLE: Target Sources (Complex Multiplication)\nDESCRIPTION: Includes the complex multiplication source files (arm_cmplx_mult_cmplx_f32.c, arm_cmplx_mult_cmplx_f64.c, arm_cmplx_mult_cmplx_q15.c, arm_cmplx_mult_cmplx_q31.c) in the CMSISDSPComplexMath library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_15\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mult_cmplx_f32.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mult_cmplx_f64.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mult_cmplx_q15.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mult_cmplx_q31.c)\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories with CMake\nDESCRIPTION: This snippet adds include directories to the project using the `target_include_directories` command in CMake. The `${CMAKE_CURRENT_LIST_DIR}/inc` path specifies the location of header files that should be included during compilation. The `PUBLIC` keyword makes these include directories available to other targets that depend on this project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m85/ac6/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Section Placement\nDESCRIPTION: This snippet shows how to place the `FREE_MEM` section in the RAM region within an EWARM `.icf` linker file. This ensures proper memory allocation for dynamic memory management in ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/NetXDuo/Nx_Iperf/README.md#_snippet_1\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories with CMake\nDESCRIPTION: This CMake command configures the include directories for the target, making the header files in the `inc` subdirectory publicly available for other targets that depend on this one. `${CMAKE_CURRENT_LIST_DIR}` resolves to the directory where the current CMakeLists.txt file is located.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m7/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories in CMake\nDESCRIPTION: This CMake snippet adds an include directory to the project's target. The include directory is specified as `${CMAKE_CURRENT_LIST_DIR}/inc`, which typically contains header files for the project. This allows the compiler to find the necessary header files during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/crypto_libraries/ports/linux/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting DHCPv6 Test Case Sources CMake\nDESCRIPTION: This snippet sets the source files for DHCPv6 tests in the CMake configuration. It defines a variable `netx_dhcpv6_test_cases` and assigns it a list of C source files located under the `${SOURCE_DIR}/tahi_test/` directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_30\n\nLANGUAGE: CMake\nCODE:\n```\nset(netx_dhcpv6_test_cases\n            ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_014.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_032.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_026.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_023.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_052.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_015.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_056.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_017.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_009.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_021.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_089.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_008.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_081.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_007.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_021.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_042.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_022.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_053.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_020.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_072.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_019.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_095.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_020.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_027.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_088.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_091.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_019.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_092.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_076.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_058.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_048.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_002.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_025.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_096.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_044.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_030.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_019.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_066.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_043.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_011.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_007.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_045.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_009.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_065.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_004.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_012.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_060.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_014.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_093.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_003.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_005.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_028.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_012.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_013.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_018.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_016.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_061.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_017.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_085.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_038.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_003.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_063.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_025.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_004.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_069.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_005.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_022.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_024.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_007.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_023.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_027.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_067.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_031.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_039.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_010.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_012.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_034.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_020.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_062.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_002.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_014.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_059.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_057.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_021.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_070.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_002.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_054.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_084.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_006.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_010.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_035.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_008.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_006.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_004.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_077.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_064.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_075.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_098.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_046.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_097.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_073.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_050.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_013.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_015.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_009.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_016.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_047.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_024.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_083.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_080.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_026.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_029.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_04_010.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_022.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_026.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_090.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_055.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_049.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_078.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_033.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_051.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_094.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_07_006.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_068.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_dhcpv6_test_01_099.c)\n    endif()\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Interpolation Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the InterpolationFunctions subdirectory and links the CMSISDSPInterpolation library to the CMSISDSP interface library if the INTERPOLATION flag is set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_39\n\nLANGUAGE: cmake\nCODE:\n```\nif (INTERPOLATION)\n  add_subdirectory(InterpolationFunctions)\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPInterpolation)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Deriving Key PSA\nDESCRIPTION: This code snippet shows how to derive a key from other material using the `psa_key_derivation_output_key` function. This function is used in key derivation scenarios.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_15\n\nLANGUAGE: C\nCODE:\n```\npsa_key_derivation_output_key\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion in CMake\nDESCRIPTION: This CMake function, `target_sources_if_not_overridden`, checks if a file has been overridden. It uses `list(FIND)` to determine if `filename` exists in `TX_SRC_OVERRIDES`. If not overridden, the function adds the original source file from the `common/src` directory to the specified target. This ensures that customized files are used if they exist, otherwise the default files are included.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/common/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfunction(target_sources_if_not_overridden filename)\n    list(FIND TX_SRC_OVERRIDES ${filename} OVERRIDE_FOUND)\n    if( OVERRIDE_FOUND EQUAL -1 )\n        # message(STATUS \"** Using original ${filename} from common/src **\")\n        target_sources(${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_LIST_DIR}/src/${filename})\n    endif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Header File Symbolic Linking\nDESCRIPTION: This snippet creates symbolic links to the header files in the ThreadX include directories to a common include directory within the build directory. This simplifies including header files in other parts of the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/libs/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nget_target_property(dirs threadx INCLUDE_DIRECTORIES)\nexecute_process(COMMAND mkdir -p ${CMAKE_BINARY_DIR}/inc)\nforeach(dir ${dirs})\n  file(GLOB header_files ${dir}/*.h)\n  foreach(header_file ${header_files})\n    execute_process(COMMAND ln -sf ${header_file} ${CMAKE_BINARY_DIR}/inc)\n  endforeach()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Setting ThreadX Target Sources in CMake\nDESCRIPTION: This CMake snippet sets the target sources for the ThreadX component. It uses the `target_sources` command to link C and assembly source files from the current directory to the specified project name (`${PROJECT_NAME}`). These source files implement various thread-related functionalities such as secure stack allocation, context switching, interrupt control, scheduling, and timer interrupts.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/ac6/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_allocate.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_free.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_low_level.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_allocate.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_free.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n)\n```\n\n----------------------------------------\n\nTITLE: Include Interpolation Configuration\nDESCRIPTION: Includes the interpolation configuration file. This configuration is used to setup interpolation related functionalities for the CMSISDSPComplexMath library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(interpol)\ninterpol(CMSISDSPComplexMath)\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration for ThreadX Memory\nDESCRIPTION: This code snippet provides two options for configuring the MDK-ARM linker file (.sct) for ThreadX dynamic memory allocation. It allows either defining the RW_IRAM1 region in the .sct file or modifying the line in \"tx_initialize_low_level.S\" to match the memory region being used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_TCP_Echo_Server/README.md#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_initialize_low_level.S\" to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Project and C Standard\nDESCRIPTION: This snippet sets the minimum required CMake version, defines the project name as 'az_platform' with the C language, and specifies the C standard as C99.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/platform/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.10)\n\nproject(az_platform LANGUAGES C)\nset(CMAKE_C_STANDARD 99)\n```\n\n----------------------------------------\n\nTITLE: Conditional Test Case Selection based on CMAKE_BUILD_TYPE CMake\nDESCRIPTION: Selects the appropriate test cases based on the CMAKE_BUILD_TYPE variable. This allows for different test suites to be built based on the target environment (e.g., RTOS, standalone). The logic supports MSRC, standalone, nofx, memory_management, optimized builds, and default configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_30\n\nLANGUAGE: CMake\nCODE:\n```\nif (CMAKE_BUILD_TYPE MATCHES \"msrc_rtos_build\")\n  set(test_cases\n    ${ux_msrc_test_cases}\n    ${ux_msrc_test_cases_rtos}\n  )\nelif (CMAKE_BUILD_TYPE MATCHES \"msrc_standalone_build\")\n  set(test_cases\n    ${ux_msrc_test_cases}\n    ${ux_msrc_test_cases_standalone}\n  )\nelif(NOT (CMAKE_BUILD_TYPE MATCHES \"standalone.*\"))\n  if (CMAKE_BUILD_TYPE MATCHES \"nofx_.*\")\n    set(test_cases\n      ${ux_class_storage_test_cases}\n    )\n  elseif (CMAKE_BUILD_TYPE MATCHES \"memory_management_.*\")\n    set(test_cases\n      ${ux_class_memory_management_test_cases}\n    )\n  else()\n    set(test_cases\n      ${ux_basic_test_cases}\n      ${ux_utility_test_cases}\n      ${ux_utility_os_test_cases}\n      ${ux_stack_test_cases}\n      ${ux_dpump_test_cases}\n      ${ux_class_hub_test_cases}\n      ${ux_device_class_storage_tx_test_cases}\n      ${ux_class_dfu_test_cases}\n      ${ux_class_print_test_cases}\n      ${ux_class_ccid_test_cases}\n      )\n    if(NOT (CMAKE_BUILD_TYPE MATCHES \"optimized.*\"))\n      list(APPEND test_cases\n        ${ux_stack_test_cases_hid}\n        ${ux_stack_test_cases_cdc}\n        ${ux_stack_cdc_acm_test_cases}\n        ${ux_class_cdc_acm_test_cases}\n        ${ux_class_audio_test_cases}\n        ${ux_class_rndis_test_cases}\n        ${ux_class_cdc_ecm_test_cases}\n        ${ux_class_hid_test_cases}\n        ${ux_class_video_test_cases}\n        ${ux_class_storage_test_cases}\n        ${ux_class_pima_test_cases}\n        ${ux_class_gser_test_cases}\n        ${ux_class_prolific_test_cases}\n        ${ux_class_swar_test_cases}\n        ${ux_msrc_test_cases}\n        )\n    endif()\n  endif()\nelse()\n  set(test_cases\n      ${ux_basic_test_cases}\n      ${ux_utility_test_cases}\n      ${ux_dpump_test_cases}\n    )\n  if (CMAKE_BUILD_TYPE MATCHES \"standalone_device.*\"))\n    list(APPEND test_cases\n      ${ux_utility_os_test_cases}\n      ${ux_class_storage_device_standalone_test_cases}\n      ${ux_class_cdc_acm_device_standalone_test_cases}\n      ${ux_class_video_device_standalone_test_cases}\n      ${ux_class_hid_device_standalone_test_cases}\n      ${ux_class_dfu_test_cases}\n      ${ux_msrc_test_cases}\n      ${ux_class_printer_device_standalone_test_cases}\n      ${ux_class_audio_device_standalone_test_cases}\n      ${ux_class_ccid_test_cases}\n      )\n  elseif (CMAKE_BUILD_TYPE MATCHES \"standalone_host.*\"))\n    list(APPEND test_cases\n      ${ux_utility_os_test_cases}\n      ${ux_class_storage_host_standalone_test_cases}\n      ${ux_class_cdc_acm_host_standalone_test_cases}\n      ${ux_class_hid_host_standalone_test_cases}\n      ${ux_class_print_test_cases}\n      ${ux_class_hub_standalone_test_cases}\n    )\n  else ()\n    list(APPEND test_cases\n      ${ux_class_dfu_test_cases}\n    )\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding DCT4 source files (float32) in CMake\nDESCRIPTION: This snippet conditionally adds various DCT4 source files for float32 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR DCT4_F32_128 OR DCT4_F32_512 OR DCT4_F32_2048 OR DCT4_F32_8192)\ntarget_sources(CMSISDSPTransform PRIVATE arm_dct4_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_dct4_init_f32.c)\n\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_init_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_init_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_f32.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding API Documentation Target CMake\nDESCRIPTION: This snippet adds a custom target for generating API documentation using Doxygen. It defines the command to execute Doxygen and specifies the working directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_26\n\nLANGUAGE: CMake\nCODE:\n```\nADD_CUSTOM_TARGET(${MBEDTLS_TARGET_PREFIX}apidoc\n    COMMAND doxygen mbedtls.doxyfile\n    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/doxygen)\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker File Configuration for ThreadX Heap\nDESCRIPTION: This snippet shows the configuration required in the STM32CubeIDE linker file (.ld) to define a dedicated heap section for ThreadX.  It defines a section named '_threadx_heap' with a specified size (64KB in this case) and location in RAM.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_Thread_MsgQueue/README.md#_snippet_2\n\nLANGUAGE: linker script\nCODE:\n```\n._threadx_heap :\n  {\n    . = ALIGN(8);\n    __RAM_segment_used_end__ = .;\n    . = . + 64K;\n    . = ALIGN(8);\n  } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Master/Slave Selection via Preprocessor Definition in main.h (C)\nDESCRIPTION: This code snippet explains how to configure the board as either an I2C Master or Slave by commenting or uncommenting the `#define SLAVE_BOARD` preprocessor definition in the `main.h` file. This selection determines the behavior of the I2C peripheral and the associated communication logic.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples_LL/I2C/I2C_TwoBoards_MasterTx_SlaveRx_DMA_Init/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n// Comment \"#define SLAVE_BOARD\" to select Master board.\n// Uncomment \"#define SLAVE_BOARD\" to select Slave board.\n```\n\n----------------------------------------\n\nTITLE: Shared Data TLV Header Structure in C\nDESCRIPTION: Defines the structure of the TLV header used at the beginning of the shared data area. It contains a magic number (`tlv_magic`) for identification and the total length (`tlv_tot_len`) of the shared TLV area, including the header itself. All fields are little-endian.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_17\n\nLANGUAGE: C\nCODE:\n```\n/** Shared data TLV header.  All fields in little endian. */\nstruct shared_data_tlv_header {\n    uint16_t tlv_magic;\n    uint16_t tlv_tot_len; /* size of whole TLV area (including this header) */\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Target Sources (CMake)\nDESCRIPTION: This snippet sets the target sources for the project, making the source files defined in the SOURCES variable available for compilation. The sources are added as PRIVATE to the target, meaning they are only used within the target itself and not exposed to other targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE ${SOURCES})\n```\n\n----------------------------------------\n\nTITLE: Install P256-M Library Target\nDESCRIPTION: This snippet installs the P256-M library target to the specified library directory (CMAKE_INSTALL_LIBDIR) with specific permissions and exports it as part of the MbedTLSTargets export set. It makes the library available for use by other projects that depend on mbedTLS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/p256-m/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS ${p256m_target}\nEXPORT MbedTLSTargets\nDESTINATION ${CMAKE_INSTALL_LIBDIR}\nPERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ)\n```\n\n----------------------------------------\n\nTITLE: Include Directories based on Build Type\nDESCRIPTION: This snippet includes additional directories based on the `CMAKE_BUILD_TYPE`. Specifically, if the build type is `hash_clone_build`, it includes the directory containing hash clone test files. This allows CMake to find necessary header files and source code for the build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"s${CMAKE_BUILD_TYPE}\" STREQUAL \"shash_clone_build\")\n  include_directories(${CMAKE_CURRENT_LIST_DIR}/../../regression/nx_secure_test/hash_clone)\nendif()\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation Configuration - MDK-ARM\nDESCRIPTION: This code snippet shows how to configure memory allocation for ThreadX in MDK-ARM, requiring either defining the `RW_IRAM1` region in the `.sct` file or modifying the `tx_low_level_initilize.s` file to match the memory region being used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBPD/USBPD_SRC_UX_Host_MSC/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nLDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Defining Include Directories in CMake\nDESCRIPTION: This CMake snippet defines the include directories for the target. It uses the `target_include_directories` command to specify the include directory under the `PUBLIC` scope, meaning it is available to other targets that depend on this one. The include directory is located in the `inc` directory and contains header files for the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/iar/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Enabling Master Board in C\nDESCRIPTION: The #define MASTER_BOARD directive in the main.c file determines whether the board operates in master or slave mode. To configure the board as a master, this directive must be uncommented. This allows for the inclusion of master-specific code, such as initiating I2C communication and sending commands to the slave device.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples/I2C/I2C_TwoBoards_AdvComIT/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n#define MASTER_BOARD\n```\n\n----------------------------------------\n\nTITLE: Setting Target Include Directories with CMake\nDESCRIPTION: This CMake snippet defines the include directories for the target. It sets the PUBLIC property, meaning that these directories are available to other targets that depend on this target. The variable CURRENT_DIR is used to define the path to the include directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/ports_smp/linux/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CURRENT_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Target Sources with CMake\nDESCRIPTION: This CMake snippet defines the target sources for the project. The actual source files are intended to be added between the `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` placeholders. It uses the `target_sources` command with the `PRIVATE` scope, meaning these sources are only used when building this target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/ports/linux/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Controller Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the ControllerFunctions subdirectory and links the CMSISDSPController library to the CMSISDSP interface library if the CONTROLLER flag is set. It also sets compile definitions for fast tables if CONFIGTABLE is enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_28\n\nLANGUAGE: cmake\nCODE:\n```\nif (CONTROLLER)\n  add_subdirectory(ControllerFunctions)\n  # Fast tables inclusion is allowed\n  if (CONFIGTABLE)\n    target_compile_definitions(CMSISDSPController PUBLIC ARM_FAST_ALLOW_TABLES)\n  endif()\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPController)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Globbing Source Files in CMake\nDESCRIPTION: This snippet uses the `file(GLOB)` command to find source files ending with `_s8.c` and `_s16.c` in the current directory and stores the results in the `SRC` and `SRC_S16` variables respectively.  These variables are later used to include these files in the `cmsis-nn` target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/PoolingFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB SRC \"./*_s8.c\")\nfile(GLOB SRC_S16 \"./*_s16.c\")\n```\n\n----------------------------------------\n\nTITLE: Adding ThreadX Subdirectory\nDESCRIPTION: This snippet adds the ThreadX library as a subdirectory to the current project. It also disables the idle thread if the ENABLE_IDLE environment variable is not defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/libs/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nget_filename_component(\n  externals ${CMAKE_CURRENT_SOURCE_DIR}/../.. ABSOLUTE)\n  add_subdirectory(${externals}/threadx threadx)\nif(NOT DEFINED ENV{ENABLE_IDLE})\n  target_compile_options(threadx PRIVATE -DTX_LINUX_NO_IDLE_ENABLE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: RTC Clock Source Definition in main.h (C)\nDESCRIPTION: This code snippet shows how to define the RTC clock source in the main.h file. The user can choose between LSI and LSE as the RTC clock source by uncommenting the appropriate line. This selection influences the RTC's accuracy and power consumption.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Examples/RTC/RTC_Calendar/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define RTC_CLOCK_SOURCE_LSI  \n\n/* #define RTC_CLOCK_SOURCE_LSE */\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries\nDESCRIPTION: This snippet links the `arm_svm_example` executable with the `CMSISDSP` library. This ensures that the necessary CMSIS-DSP functions are available to the executable at runtime.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_svm_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(arm_svm_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: This snippet adds subdirectories for the ThreadX, NetX Duo, and FileX libraries. The `externals` variable is calculated to point to the root of these libraries, which are then included in the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/libs/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(externals ${CMAKE_CURRENT_SOURCE_DIR}/../../../externals\n                       ABSOLUTE)\nadd_subdirectory(${externals}/threadx threadx)\nadd_subdirectory(${externals}/netxduo netxduo)\nadd_subdirectory(${externals}/filex filex)\n```\n\n----------------------------------------\n\nTITLE: ThreadX heap configuration for MDK-ARM\nDESCRIPTION: This code snippet describes how to define the RW_IRAM1 region in the MDK-ARM's '.sct' file or modify the 'tx_initialize_low_level.S' file to match the used memory region for ThreadX.  It shows where to find the memory limit address.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_MSC/README.md#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\nLDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Adding CFFT Radix2 Init Q15 source files in CMake\nDESCRIPTION: This snippet conditionally adds arm_cfft_radix2_init_q15.c as a private source files to the CMSISDSPTransform library if WRAPPER is defined or ARM_CFFT_RADIX2_Q15 is defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_21\n\nLANGUAGE: cmake\nCODE:\n```\nif (WRAPPER OR ARM_CFFT_RADIX2_Q15)\n  target_sources(CMSISDSPTransform PRIVATE arm_cfft_radix2_init_q15.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Receive Writable Properties from Azure IoT Hub (C)\nDESCRIPTION: This snippet demonstrates the prototype for the `nx_azure_iot_hub_client_writable_properties_receive` function. It receives writable properties from the Azure IoT Hub. The function requires a pointer to an `NX_AZURE_IOT_HUB_CLIENT`, a pointer to an `NX_PACKET` to store the writable properties, and a timeout value.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_44\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_writable_properties_receive(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                         NX_PACKET **packet_pptr,\n                                                         UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Defining Image TLV Structure\nDESCRIPTION: This code defines the structure for an image TLV (Type-Length-Value) record (`image_tlv`).  Each TLV record contains a type (`it_type`), padding (`_pad`), and the length of the data in bytes (`it_len`). All fields in little endian.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nstruct image_tlv {\n    uint8_t  it_type;   /* IMAGE_TLV_[...]. */\n    uint8_t  _pad;\n    uint16_t it_len;    /* Data length (not including TLV header). */\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Build Tools on Linux\nDESCRIPTION: This snippet installs essential build tools and utilities on a Linux system using the apt-get package manager. It updates the package list and installs build-essential, curl, zip, unzip, tar, and pkg-config. This is a common step for setting up a development environment on Debian-based Linux distributions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update\nsudo apt-get install build-essential curl zip unzip tar pkg-config\n```\n\n----------------------------------------\n\nTITLE: Installing Executables with CMake\nDESCRIPTION: This snippet installs the defined executables to the 'bin' directory. It specifies file permissions for the owner, group, and world, allowing read, write, and execute permissions for the owner, and read and execute permissions for the group and world. The DESTINATION parameter specifies where the executables will be installed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/cipher/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS ${executables}\n        DESTINATION \"bin\"\n        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n```\n\n----------------------------------------\n\nTITLE: Defining Flash Area IDs\nDESCRIPTION: This code defines the flash area IDs used by the bootloader to identify different regions of flash memory. These areas include the bootloader itself, a scratch area for image swapping, and primary and secondary image slots. The primary and secondary area IDs are redefined depending on the active image number.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_9\n\nLANGUAGE: c\nCODE:\n```\n/* Independent from multiple image boot */\n#define FLASH_AREA_BOOTLOADER         0\n#define FLASH_AREA_IMAGE_SCRATCH      3\n```\n\nLANGUAGE: c\nCODE:\n```\n/* If the boot loader is working with the first image */\n#define FLASH_AREA_IMAGE_PRIMARY      1\n#define FLASH_AREA_IMAGE_SECONDARY    2\n```\n\nLANGUAGE: c\nCODE:\n```\n/* If the boot loader is working with the second image */\n#define FLASH_AREA_IMAGE_PRIMARY      5\n#define FLASH_AREA_IMAGE_SECONDARY    6\n```\n\n----------------------------------------\n\nTITLE: Verifying Hash with PSA API\nDESCRIPTION: This snippet explains the function used to verify an already calculated hash using the PSA API. It uses `psa_verify_hash` and describes the key usage requirements (`PSA_KEY_USAGE_VERIFY_HASH`). It also highlights that the function requires the input hash to have the correct length.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_23\n\n\n\n----------------------------------------\n\nTITLE: Receive All Properties from Azure IoT Hub (C)\nDESCRIPTION: This snippet demonstrates the prototype for the `nx_azure_iot_hub_client_properties_receive` function. It receives all properties from the Azure IoT Hub. The function requires a pointer to an `NX_AZURE_IOT_HUB_CLIENT`, a pointer to an `NX_PACKET` to store the properties, and a timeout value.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_43\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_properties_receive(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                                NX_PACKET **packet_pptr,\n                                                UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Checking AES-CBC-PKCS7 support (PSA API)\nDESCRIPTION: This code snippet demonstrates how to check if AES-CBC-PKCS7 is supported in the PSA API. It checks for the definitions of `PSA_WANT_KEY_TYPE_AES` and `PSA_WANT_ALG_CBC_PKCS7`. The key type and algorithm must both be supported for the mechanism to work.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#if PSA_WANT_KEY_TYPE_AES && PSA_WANT_ALG_CBC_PKCS7\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for MSRC Tests CMake\nDESCRIPTION: Defines the source file paths for the USBX MSRC (Microsoft Security Response Center) test cases. These tests cover specific security-related issues and vulnerabilities. They are split into RTOS and standalone builds.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_22\n\nLANGUAGE: CMake\nCODE:\n```\n  ${SOURCE_DIR}/usbx_msrc_69702_dfu_dnload_test.c\n  ${SOURCE_DIR}/usbx_msrc_71934_dfu_upload_test.c\n```\n\n----------------------------------------\n\nTITLE: Linking CMSISDSP Library\nDESCRIPTION: This snippet links the CMSISDSP library (created when adding the subdirectory) to the executable. The `PRIVATE` keyword indicates that `CMSISDSP` is only needed by `arm_fft_bin_example` and not exposed to other targets that might link against it.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(arm_fft_bin_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Setting Build Configurations\nDESCRIPTION: This snippet defines available build configurations (default_build_coverage, disable_precondition_build, disable_security_module_build) and sets CMAKE_CONFIGURATION_TYPES. It retrieves the first configuration type or uses BUILD_TYPE if CMAKE_BUILD_TYPE is not properly set, forcing the CMAKE_BUILD_TYPE to the retrieved or set value.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT WIN32)\nset(BUILD_CONFIGURATIONS\n    default_build_coverage disable_precondition_build disable_security_module_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                              ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                    CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Target Sources in CMake\nDESCRIPTION: This CMake snippet defines the source files to be compiled for the target. It uses the `target_sources` command to specify the source files under the `PRIVATE` scope, meaning they are only used for building this specific target. The source files are located in the `src` directory and include C and assembly files for ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m4/iar/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_iar.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S    \n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources in CMake\nDESCRIPTION: This CMake snippet configures the target sources for the project. The actual source files are intended to be added between the BEGIN_TARGET_SOURCES and END_TARGET_SOURCES comments. Currently, the section is empty indicating that no sources are defined within the CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/crypto_libraries/ports/linux/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Set Compile Definitions\nDESCRIPTION: This snippet sets compile definitions based on whether FileX is running in standalone mode or not. If not in standalone mode, it defines FX_INCLUDE_USER_DEFINE_FILE. Otherwise, it defines both FX_INCLUDE_USER_DEFINE_FILE and FX_STANDALONE_ENABLE.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT FX_STANDALONE_ENABLE)\n    target_compile_definitions(${PROJECT_NAME} PUBLIC \"FX_INCLUDE_USER_DEFINE_FILE\" )\nelse()\n    target_compile_definitions(${PROJECT_NAME} PUBLIC \"FX_INCLUDE_USER_DEFINE_FILE\" -DFX_STANDALONE_ENABLE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditional Full Build TFTP and TCP Test Inclusion CMake\nDESCRIPTION: This snippet conditionally appends large data TFTP and TCP congestion window test cases to the `tftp_test_cases` list.  If the `full_build` string is in the `CMAKE_BUILD_TYPE` list, the `netx_tftp_large_data_test.c` and `netx_tcp_cwnd_test.c` files are added to the TFTP test suite.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_34\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"full_build\" IN_LIST CMAKE_BUILD_TYPE)\n  # For test cases requires huge CPU resoures, run for full build only\n  list(APPEND tftp_test_cases\n       ${SOURCE_DIR}/tftp_test/netx_tftp_large_data_test.c\n       ${SOURCE_DIR}/netxduo_test/netx_tcp_cwnd_test.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Build Examples matching TX, GCC, ARMv8-A (PowerShell)\nDESCRIPTION: This command builds all examples matching the keywords 'TX ', 'GCC', and 'ARMv8-A'.  The pwsh -Command prefix is used for executing the PowerShell script from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_24\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','GCC','ARMv8-A' -build\n```\n\n----------------------------------------\n\nTITLE: Configuring DCT4 Options (Q31) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Discrete Cosine Transform Type IV (DCT4) implementations for Q31 data types with various sizes (128 to 8192). These options are used to customize the CMSIS-DSP library by selecting specific DCT4 implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_20\n\nLANGUAGE: CMake\nCODE:\n```\noption(DCT4_Q31_128          \"dct4 q31 128\"                     OFF)\noption(DCT4_Q31_512          \"dct4 q31 512\"                     OFF)\noption(DCT4_Q31_2048         \"dct4 q31 2048\"                    OFF)\noption(DCT4_Q31_8192         \"dct4 q31 8192\"                    OFF)\n```\n\n----------------------------------------\n\nTITLE: Define Source Sets for USB Audio Class Tests\nDESCRIPTION: This snippet defines a variable `ux_class_audio_test_cases` that contains a list of C source files for USB Audio class tests. These files are located in the specified `SOURCE_DIR`. The tests cover both audio 1.0 and audio 2.0.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_audio_test_cases\n    ${SOURCE_DIR}/usbx_audio10_device_basic_test.c\n    ${SOURCE_DIR}/usbx_audio10_device_feedback_test.c\n    ${SOURCE_DIR}/usbx_audio10_iad_device_basic_test.c\n    ${SOURCE_DIR}/usbx_audio10_iad_device_control_test.c\n    ${SOURCE_DIR}/usbx_audio10_iad_device_interrupt_test.c\n    ${SOURCE_DIR}/usbx_audio20_device_basic_test.c\n    ${SOURCE_DIR}/usbx_audio20_device_controls_test.c\n    ${SOURCE_DIR}/usbx_audio20_device_feedback_test.c\n    ${SOURCE_DIR}/usbx_audio10_iad_host_basic_test.c\n    ${SOURCE_DIR}/usbx_audio20_host_basic_test.c\n    ${SOURCE_DIR}/usbx_uxe_device_audio_test.c\n    ${SOURCE_DIR}/usbx_uxe_host_audio_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: Modifying Linker Variable with Expression (linker)\nDESCRIPTION: This snippet demonstrates how to modify a linker variable in an ICF file using a mathematical expression. It extracts values from an XML file based on the specified name, applies a given formula, and updates the linker variable. Multiple xml names are used in this example.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nlinker -xml OEMiRoT_Secure_Code.xml -nxml Firmware area size -nxml Firmware area size -e \"(val1 + val2)/cons1\" -c 0x50 -n CODE_SIZE stm32h573xx_flash_s.icf\n```\n\n----------------------------------------\n\nTITLE: Semihosting Enable Parameter\nDESCRIPTION: This parameter enables or disables semihosting SVC traps. Applications that do not use semihosting should set this to false.  It's a boolean value configurable at init-time.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/ARMCM3_config.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.semihosting-enable=0                    # (bool  , init-time) default = '1'      : Enable semihosting SVC traps. Applications that do not use semihosting must set this parameter to false.\n```\n\n----------------------------------------\n\nTITLE: IAR Thread-safe Library Initialization\nDESCRIPTION: This code snippet shows the line that should be added to the linker control file to enable thread-safe support for the IAR tools when using ThreadX. It initializes a section named `__DLIB_PERTHREAD` by copying, with packing set to none. This is required in a multi-threaded application.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/iar/readme_threadx.txt#_snippet_2\n\nLANGUAGE: linker control file\nCODE:\n```\ninitialize by copy with packing = none { section __DLIB_PERTHREAD }; // Required in a multi-threaded application\n```\n\n----------------------------------------\n\nTITLE: Defining ThreadX Target Sources with CMake\nDESCRIPTION: This CMake code snippet defines the source files for the ThreadX target.  It uses the `target_sources` command to link the specified C and assembly files to the project. The `${PROJECT_NAME}` variable refers to the project name defined elsewhere in the CMake configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/ac6/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_allocate.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_free.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_low_level.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_allocate.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_free.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n)\n```\n\n----------------------------------------\n\nTITLE: Globbing and Linking C Source Files with CMake\nDESCRIPTION: This CMake snippet uses the `file(GLOB)` command to find all C source files matching the pattern `./*_*.c`. It then uses `target_sources` to add these source files to the `cmsis-nn` target as private sources, meaning they are not exposed to other targets that link against `cmsis-nn`. This ensures proper encapsulation and avoids symbol conflicts.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/ConcatenationFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SRC \"./*_*.c\")\ntarget_sources(cmsis-nn PRIVATE ${SRC})\n```\n\n----------------------------------------\n\nTITLE: Set CMAKE_BUILD_TYPE\nDESCRIPTION: Sets the `CMAKE_BUILD_TYPE` variable with a longer list of available build types. This allows the user to select different build configurations (e.g., Debug, Release, Coverage).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)\n    set(CMAKE_BUILD_TYPE ${CMAKE_BUILD_TYPE}\n        CACHE STRING \"Choose the type of build: None Debug Release Coverage ASan ASanDbg MemSan MemSanDbg Check CheckFull TSan TSanDbg\"\n        FORCE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Matrix Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the MatrixFunctions subdirectory and links the CMSISDSPMatrix library to the CMSISDSP interface library if the MATRIX flag is set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_31\n\nLANGUAGE: cmake\nCODE:\n```\nif (MATRIX)\n  add_subdirectory(MatrixFunctions)\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPMatrix)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Iperf log output example\nDESCRIPTION: This is example output from an iperf client showing bandwidth statistics over a 10-second period, indicating the data transfer rate in Mbits/sec. It shows the interval, transfer amount, and bandwidth.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_Iperf_wifi/README.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n------------------------------------------------------------\nClient connecting to 192.168.137.188, TCP port 5001\nTCP window size: 64.0 KByte (default)\n------------------------------------------------------------\n[  3] local 192.168.137.1 port 64429 connected with 192.168.137.188 port 5001\n[ ID] Interval       Transfer     Bandwidth\n[  3]  0.0- 1.0 sec   896 KBytes  7.34 Mbits/sec\n[  3]  1.0- 2.0 sec   896 KBytes  7.34 Mbits/sec\n[  3]  2.0- 3.0 sec   896 KBytes  7.34 Mbits/sec\n[  3]  3.0- 4.0 sec   896 KBytes  7.34 Mbits/sec\n[  3]  4.0- 5.0 sec   896 KBytes  7.34 Mbits/sec\n[  3]  5.0- 6.0 sec   896 KBytes  7.34 Mbits/sec\n[  3]  6.0- 7.0 sec   896 KBytes  7.34 Mbits/sec\n[  3]  7.0- 8.0 sec   896 KBytes  7.34 Mbits/sec\n[  3]  8.0- 9.0 sec   896 KBytes  7.34 Mbits/sec\n[  3]  9.0-10.0 sec   896 KBytes  7.34 Mbits/sec\n[  3]  0.0-10.1 sec  8.88 MBytes  7.40 Mbits/sec\n```\n\n----------------------------------------\n\nTITLE: Deterministic ECDSA signature capability example (JSON)\nDESCRIPTION: This JSON snippet demonstrates a capability declaration for a driver that can perform deterministic ECDSA signatures using any hash algorithm and curve supported by the core. The `entry_points` array specifies that the driver implements the `sign_hash` function, and the `algorithms` array indicates that it supports `PSA_ALG_DETERMINISTIC_ECDSA` with any hash algorithm.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"entry_points\": [\"sign_hash\"],\n    \"algorithms\": [\"PSA_ALG_DETERMINISTIC_ECDSA(PSA_ALG_ANY_HASH)\"],\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Compile Options Based on Build Type\nDESCRIPTION: This snippet defines compile options based on the selected build type. It uses conditional definitions for secure, multipart, and digest authentication based on the build configuration.  It adds compile options like standard C99, debugging information, and enables extended notify support if specified in the build type.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(SECURE -DNX_WEB_HTTPS_ENABLE -DNX_TCPSERVER_ENABLE_TLS -DNX_SECURE_ENABLE_CLIENT_CERTIFICATE_VERIFY)\nset(MULTIPART -DNX_WEB_HTTP_MULTIPART_ENABLE)\nset(DIGEST -DNX_WEB_HTTP_DIGEST_ENABLE)\n\nset(default_build_coverage ${SECURE} ${MULTIPART} -DNX_ENABLE_EXTENDED_NOTIFY_SUPPORT)\nset(no_tls_build_coverage ${MULTIPART})\nset(digest_authenticate_build ${SECURE} ${MULTIPART} ${DIGEST})\n```\n\n----------------------------------------\n\nTITLE: Setting Target Sources with CMake\nDESCRIPTION: This CMake snippet configures the source files for the specified target, which is the project name. It uses the `target_sources` command to include a set of C files located in the `src` directory. These source files are related to ThreadX, including initialization, context switching, scheduling and interrupt handling.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/linux/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_low_level.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.c\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Build Examples matching TX, ARM compiler v6, SMP (PowerShell)\nDESCRIPTION: This command builds all examples matching the keywords 'TX ', 'ARM compiler v6', and 'SMP'.  These examples are likely ThreadX examples for SMP (Symmetric Multiprocessing) using the ARM compiler v6. The pwsh -Command prefix ensures proper execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_20\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','ARM compiler v6','SMP' -build\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation: Disabling Samples\nDESCRIPTION: This snippet clears the `sample_files` list if the `-DNX_BSD_RAW_SUPPORT` flag is present in `CMAKE_BUILD_TYPE`. This effectively disables compilation of all samples.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/samples/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"-DNX_BSD_RAW_SUPPORT\" IN_LIST ${CMAKE_BUILD_TYPE})\n  set(sample_files \"\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Application\nDESCRIPTION: This snippet includes the `config` module and calls `configApp` function to configure the executable. `configApp` likely sets compiler flags, include paths, etc. based on the target application.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(config)\nconfigApp(arm_fft_bin_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories for Source Files\nDESCRIPTION: This snippet adds subdirectories to include source files for different NetXDuo components, including port-specific files (based on NETXDUO_CUSTOM_PORT, THREADX_ARCH, and THREADX_TOOLCHAIN), common files, add-ons, crypto libraries, nx_secure components, utilities, and the TSN link layer. add_subdirectory commands ensure that these directories are included in the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# A place for generated/copied include files (no need to change)\nset(CUSTOM_INC_DIR ${CMAKE_CURRENT_BINARY_DIR}/custom_inc)\n\n# Pick up the port specific stuff first\nif(DEFINED NETXDUO_CUSTOM_PORT)\n    add_subdirectory(${NETXDUO_CUSTOM_PORT} netxduo_port)\nelse()\n    add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/ports/${THREADX_ARCH}/${THREADX_TOOLCHAIN})\nendif()\n\n# Then the common files\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/common)\n\n# Pick up the apps directory containing the protocol and app-layer components\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/addons)\n\n# Network security and crypto components\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/crypto_libraries)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/nx_secure)\n\n# Utility components\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/utility)\n\n# Link layer\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/tsn)\n```\n\n----------------------------------------\n\nTITLE: Add CMocka Test Environment\nDESCRIPTION: This snippet adds a CMocka test environment for the `az_iot_provisioning_test` target, which can be used to set up and tear down the test environment before and after running the tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/provisioning/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_cmocka_test_environment(az_iot_provisioning_test)\n```\n\n----------------------------------------\n\nTITLE: Adding RFFT source files (Q15) in CMake\nDESCRIPTION: This snippet conditionally adds Real FFT source files for Q15 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_19\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR RFFT_Q15_32 OR RFFT_Q15_64 OR RFFT_Q15_128 OR RFFT_Q15_256\n     OR RFFT_Q15_512 OR RFFT_Q15_1024 OR RFFT_Q15_2048 OR RFFT_Q15_4096 OR RFFT_Q15_8192)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_init_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_q15.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Project Root Directory\nDESCRIPTION: This snippet sets the `MBEDTLS_DIR` variable if it's not already defined. This is useful when the tests folder is included directly without including the top-level CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/tests/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT DEFINED MBEDTLS_DIR)\n    set(MBEDTLS_DIR ${CMAKE_SOURCE_DIR})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Hashing binary content with tail data using command-line tool\nDESCRIPTION: This example demonstrates how to compute the SHA256 hash of a binary file's content, append tail data and update another binary file with the hash and tail data. It involves specifying the input data file, the tail data, and the output file to update.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_34\n\nLANGUAGE: text\nCODE:\n```\nhashcontent --tail AABBCCDDEEFF -i user_password.bin password.bin\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories in CMake\nDESCRIPTION: This snippet uses the `target_include_directories` command to add the include directory `${CMAKE_CURRENT_LIST_DIR}/inc` to the target `${PROJECT_NAME}`. This allows the compiler to find the necessary header files during compilation. The include directory is added as a public interface, making it available to dependent targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/iar/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version and Policies\nDESCRIPTION: This snippet sets the minimum required CMake version and configures CMake policies to ensure consistent behavior across different CMake versions. The minimum version is set to 3.13, and policies CMP0054, CMP0057, and CMP0077 are set to NEW.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/crypto/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\ncmake_policy(SET CMP0077 NEW)\n```\n\n----------------------------------------\n\nTITLE: Conditional 32/64-bit compilation options\nDESCRIPTION: Conditionally sets compiler and linker options based on whether the `ENABLE_64` variable is defined. If `ENABLE_64` is not defined (implying a 32-bit build), it adds compiler and linker options to target a 32-bit architecture (-m32).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/libs/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(ENABLE_64)\n  message(STATUS \"Building for 64bit\")\nelse()\n  add_compile_options(-m32)\n  add_link_options(-m32)\n  message(STATUS \"Building for 32bit\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Starting ECDSA Interruptible Verification in PSA\nDESCRIPTION: Starts an interruptible ECDSA signature verification operation using `psa_verify_hash_start`. It takes the public key object, the hash, and the signature to be verified as input. The operation might not complete immediately, requiring subsequent calls to `psa_verify_hash_complete`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_32\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t status = psa_verify_hash_start(&operation, key, alg, hash, hash_length, signature, signature_length);\n```\n\n----------------------------------------\n\nTITLE: Remove Test Resources with BaseName - PowerShell\nDESCRIPTION: This example demonstrates how to remove test resources using the `BaseName` parameter, which is used in the resource group name ('rg-<baseName>'). It assumes the user is currently logged in and uses the `-Force` parameter to bypass confirmation prompts.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/Remove-TestResources.ps1.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nRemove-TestResources.ps1 keyvault -Force\nUse the currently logged-in account to delete the resources created for Key Vault testing.\n```\n\n----------------------------------------\n\nTITLE: Configuring LMS Normalization Options in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable LMS (Least Mean Squares) normalization with different data types (q31, q15). These options are used to customize the CMSIS-DSP library by selecting specific LMS normalization implementations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\noption(ARM_LMS_NORM_Q31     \"lms norm q31\"                      OFF)\noption(ARM_LMS_NORM_Q15     \"lms norm q15\"                      OFF)\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation - EWARM\nDESCRIPTION: This snippet shows how to define a memory section for ThreadX in the IAR Embedded Workbench (EWARM) linker configuration file (.icf). It places the last section FREE_MEM into the RAM region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Applications/USBX/Ux_Device_CDC_ACM/README.md#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Set Registration Payload - C\nDESCRIPTION: This function sets the registration payload for the Azure IoT Provisioning Client. It accepts a pointer to the `NX_AZURE_IOT_PROVISIONING_CLIENT`, a pointer to the payload (JSON object), and the length of the payload. The function returns a status indicating success or an invalid parameter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_provisioning_client.md#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_provisioning_client_registration_payload_set(NX_AZURE_IOT_PROVISIONING_CLIENT *prov_client_ptr,\n                                                               const UCHAR *payload_ptr, UINT payload_length);\n```\n\n----------------------------------------\n\nTITLE: Clean, Build, and Test Examples for ARM compiler v6, Cortex-A35 (PowerShell)\nDESCRIPTION: This command cleans, builds, and tests all examples matching the keywords 'ARM compiler v6' and 'Cortex-A35'.  The pwsh -Command prefix is used for executing the PowerShell script from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_31\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'ARM compiler v6','Cortex-A35' -clean -build -test\n```\n\n----------------------------------------\n\nTITLE: Minimum Sync Level Configuration\nDESCRIPTION: This parameter forces a minimum synchronization level. It's an integer value that can be configured at runtime. The available options are: 0 (off/default), 1 (syncState), 2 (postInsnIO), 3 (postInsnAll).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/ARMCM0_config.txt#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\narmcortexm0ct.min_sync_level=3\n```\n\n----------------------------------------\n\nTITLE: Project Definition\nDESCRIPTION: Defines the project name as CMSISDSPBasicMath.  This name is used for the generated library and other build artifacts. The project command is essential for establishing the scope and context for the CMake build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/BasicMathFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(CMSISDSPBasicMath)\n```\n\n----------------------------------------\n\nTITLE: Create Symbolic Links for Header Files\nDESCRIPTION: This snippet iterates through the ThreadX and FileX libraries, retrieves their include directories, and creates symbolic links to all header files in those directories within a common 'inc' directory in the build directory. This allows easy access to all library headers during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/libs/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(lib threadx filex)\n  get_target_property(dirs ${lib} INCLUDE_DIRECTORIES)\n  execute_process(COMMAND mkdir -p ${CMAKE_BINARY_DIR}/inc)\n  foreach(dir ${dirs})\n    file(GLOB header_files ${dir}/*.h)\n    foreach(header_file ${header_files})\n      execute_process(COMMAND ln -sf ${header_file} ${CMAKE_BINARY_DIR}/inc)\n    endforeach()\n  endforeach()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Adding CMSIS-NN Sources with CMake GLOB\nDESCRIPTION: This CMake snippet uses the `file(GLOB)` command to find all C source files matching the pattern `./*_s8.c`. These files, along with explicitly specified files such as `arm_softmax_s8_s16.c`, `arm_softmax_s16.c`, and `arm_nn_softmax_common_s8.c`, are then added to the `cmsis-nn` target as private source files. The `target_sources` command associates these source files with the specified target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/SoftmaxFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB SRC \"./*_s8.c\")\ntarget_sources(cmsis-nn PRIVATE ${SRC} arm_softmax_s8_s16.c\n                                       arm_softmax_s16.c\n                                       arm_nn_softmax_common_s8.c)\n```\n\n----------------------------------------\n\nTITLE: Key Store Abstraction Set Definition\nDESCRIPTION: This defines the set of keys accessible to a thread holding the key store mutex. It includes keys that are fully loaded in the key slots and whose attributes match a given key ID.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-thread-safety/psa-thread-safety.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n{mbedtls_svc_key_id_t k : (\\exists slot := &global_data.key_slots[i]) [\n                                  (slot->state == PSA_SLOT_FULL) &&\n                                  (slot->attr.id == k)]}\n```\n\n----------------------------------------\n\nTITLE: Configuring Library\nDESCRIPTION: Calls custom CMake functions `configLib` and `configDsp` to configure the newly created library target. These functions likely set compiler flags, define preprocessor macros, and configure other build settings based on the target platform and project configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nconfigLib(CMSISDSPFastMath ${ROOT})\nconfigDsp(CMSISDSPFastMath ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: ThreadX Compile Options\nDESCRIPTION: This snippet adds compile options to the ThreadX target. It enables event tracing by defining TX_ENABLE_EVENT_TRACE and optionally disables the Linux idle feature by defining TX_LINUX_NO_IDLE_ENABLE if the ENABLE_IDLE environment variable is not defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/libs/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(threadx PRIVATE -DTX_ENABLE_EVENT_TRACE)\nif(NOT DEFINED ENV{ENABLE_IDLE})\n  target_compile_options(threadx PRIVATE -DTX_LINUX_NO_IDLE_ENABLE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Enabling IAR Thread-safe Library Support\nDESCRIPTION: This configuration snippet shows the required line for the IAR linker control file to enable thread-safe support for the IAR tools when using ThreadX. It also mentions the required ThreadX compile flag.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/iar/readme_threadx.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\ninitialize by copy with packing = none { section __DLIB_PERTHREAD }; // Required in a multi-threaded application\n```\n\n----------------------------------------\n\nTITLE: ARM Cortex-M3 Configuration Parameters\nDESCRIPTION: These parameters configure the ARM Cortex-M3 core for debugging and tracing. `semihosting-enable` controls semihosting, `cpi_div` and `cpi_mul` are used for CPI calculation, and `min_sync_level` forces a minimum synchronization level.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_linear_interp_example/ARMCM3_config.txt#_snippet_0\n\nLANGUAGE: properties\nCODE:\n```\narmcortexm3ct.semihosting-enable=0\narmcortexm3ct.cpi_div=1\narmcortexm3ct.cpi_mul=1\narmcortexm3ct.min_sync_level=3\n```\n\n----------------------------------------\n\nTITLE: PAKE Output Driver Entry Point Prototype in C\nDESCRIPTION: Defines the function prototype for the `acme_pake_output` entry point in a PSA cryptography driver for PAKE operations.  This function is responsible for generating cryptographic material at specified step of PAKE. This function is responsible for generating cryptographic material at the specified PAKE step and writing it to the output buffer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_27\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_pake_output(acme_pake_operation_t *operation,\n\t\t\t\t\t\t\t\t\t psa_crypto_driver_pake_step_t step,\n\t\t\t\t\t\t\t\t\t uint8_t *output,\n\t\t\t\t\t\t\t\t\t size_t output_size,\n\t\t\t\t\t\t\t\t\t size_t *output_length);\n```\n\n----------------------------------------\n\nTITLE: Setting Target Compile Definitions with CMake\nDESCRIPTION: This CMake snippet sets compile definitions for the target. It uses `target_compile_definitions` to define `_GNU_SOURCE` and `TX_LINUX_DEBUG_ENABLE`. `_GNU_SOURCE` enables GNU extensions, and `TX_LINUX_DEBUG_ENABLE` enables ThreadX debug features, likely for a Linux-based debugging environment.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/linux/gnu/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${PROJECT_NAME} PUBLIC \"-D_GNU_SOURCE -DTX_LINUX_DEBUG_ENABLE\")\n```\n\n----------------------------------------\n\nTITLE: Test Examples matching TX, GCC, Cortex-A35 (PowerShell)\nDESCRIPTION: This command tests examples matching the keywords 'TX ', 'GCC', and 'Cortex-A35'. The pwsh -Command prefix allows the execution of the PowerShell script from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_30\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','GCC','Cortex-A35' -test\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories CMake\nDESCRIPTION: This snippet sets the include directories for the project. It adds the 'inc' directory located in the current CMake list directory to the project's public include paths. This allows the compiler to find header files within the specified directory during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/crypto_libraries/ports/cortex_m4/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Downloading and Installing ADU Update in C\nDESCRIPTION: This code snippet shows the prototype for initiating the download and installation of a new update using the ADU agent. It requires a pointer to the ADU agent.  This function triggers the download and installation process based on the update manifest received.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_adu_agent.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_adu_agent_update_download_and_install(NX_AZURE_IOT_ADU_AGENT *adu_agent_ptr);\n```\n\n----------------------------------------\n\nTITLE: HAL MSP Initialization for SPI\nDESCRIPTION: The HAL_SPI_MspInit() function configures the microcontroller-specific peripherals (clocks and GPIO pins) required by the SPI instance. This function is called by HAL_SPI_Init() and should be updated to change SPI configuration according to used hardware.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples_MIX/SPI/SPI_FullDuplex_ComPolling_Slave/README.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nHAL_SPI_MspInit(...);\n```\n\n----------------------------------------\n\nTITLE: C++ Standard and Flags for Check Build Type CMake\nDESCRIPTION: This code snippet sets the C++ standard to 11, requires it, and disables extensions when the build type is \"Check\" and `TEST_CPP` is enabled. Additionally, it adds the `-pedantic` flag if the compiler is Clang or GCC, enforcing stricter C++ standard compliance.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_20\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_BUILD_TYPE STREQUAL \"Check\" AND TEST_CPP)\n    set(CMAKE_CXX_STANDARD 11)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\n    set(CMAKE_CXX_EXTENSIONS OFF)\n    if(CMAKE_COMPILER_IS_CLANG OR CMAKE_COMPILER_IS_GNU)\n        set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -pedantic\")\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configure Library and DSP\nDESCRIPTION: Configures the CMSISDSPFiltering library using configLib and configDsp functions, passing the root directory as an argument. These functions likely set up compiler flags, include directories, and other settings based on the target platform and DSP configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nconfigLib(CMSISDSPFiltering ${ROOT})\nconfigDsp(CMSISDSPFiltering ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Conditional Compile Definitions (HELIUM/MVE)\nDESCRIPTION: Conditionally defines ARM_FAST_ALLOW_TABLES if CONFIGTABLE is true and either HELIUM, MVEF, or MVEI is true. This ensures fast tables are allowed if using vectorized code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nif (CONFIGTABLE AND (HELIUM OR MVEF OR MVEI))\n    target_compile_definitions(CMSISDSPComplexMath PUBLIC ARM_FAST_ALLOW_TABLES)  \nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories for CMSIS DSP Library\nDESCRIPTION: This snippet sets the include directories for the `CMSISDSPSupport` library, making the header files located in the `${DSP}/Include` directory available during compilation. It uses the `target_include_directories` command to specify a public include directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/SupportFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(CMSISDSPSupport PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Creating symbolic links for header files\nDESCRIPTION: Creates symbolic links for header files from the ThreadX include directories into a dedicated include directory within the binary output directory. This simplifies header file inclusion for other parts of the project.  It uses `file(GLOB)` to find all `.h` files within each include directory and creates symbolic links to them in `${CMAKE_BINARY_DIR}/inc`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/libs/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nget_target_property(dirs threadx INCLUDE_DIRECTORIES)\nexecute_process(COMMAND mkdir -p ${CMAKE_BINARY_DIR}/inc)\nforeach(dir ${dirs})\n  file(GLOB header_files ${dir}/*.h)\n  foreach(header_file ${header_files})\n    execute_process(COMMAND ln -sf ${header_file} ${CMAKE_BINARY_DIR}/inc)\n  endforeach()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Simulated Interrupt Data Structures\nDESCRIPTION: This code snippet shows how to define the Linux data structures and prototypes necessary to create a simulated interrupt thread using pthreads. It includes the pthread_t for the thread and a function prototype for the interrupt entry point.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/linux/gnu/readme_threadx.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\npthread_t    _sample_linux_interrupt_thread;\nvoid        *_sample_linux_interrupt_entry(void *p);\n```\n\n----------------------------------------\n\nTITLE: Creating CMSISDSPTransform static library in CMake\nDESCRIPTION: This snippet creates a static library named CMSISDSPTransform and configures it by including library-specific and DSP-specific configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(CMSISDSPTransform STATIC)\nconfigLib(CMSISDSPTransform ${ROOT})\nconfigDsp(CMSISDSPTransform ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Add CMocka Test\nDESCRIPTION: This snippet adds a CMocka test target named `az_iot_provisioning_test`. It specifies the source files, compile options, link libraries, and include directories required for the test. It includes the CMocka library, Azure IoT Common, Azure IoT Provisioning, and Azure Core libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/provisioning/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(AddCMockaTest)\n\nadd_cmocka_test(az_iot_provisioning_test SOURCES\n                main.c\n                test_az_iot_provisioning_client.c\n                test_az_iot_provisioning_client_sas.c\n                test_az_iot_provisioning_client_parser.c\n                test_az_iot_provisioning_client_register_get_request_payload.c\n                COMPILE_OPTIONS \n                    ${DEFAULT_C_COMPILE_FLAGS} \n                    ${NO_CLOBBERED_WARNING} \n                LINK_LIBRARIES ${CMOCKA_LIB}\n                    az_iot_common\n                    az_iot_provisioning\n                    az_core\n                INCLUDE_DIRECTORIES ${CMOCKA_INCLUDE_DIR}\n                )\n```\n\n----------------------------------------\n\nTITLE: Define Standalone Source Sets for USB Audio Class Tests\nDESCRIPTION: This snippet defines a variable `ux_class_audio_device_standalone_test_cases` that contains a list of C source files for standalone USB Audio class tests. These files are located in the specified `SOURCE_DIR`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_audio_device_standalone_test_cases\n    ${SOURCE_DIR}/usbx_audio10_device_basic_test.c\n    ${SOURCE_DIR}/usbx_audio20_device_basic_test.c\n    ${SOURCE_DIR}/usbx_audio10_device_feedback_test.c\n    ${SOURCE_DIR}/usbx_audio20_device_feedback_test.c\n    ${SOURCE_DIR}/usbx_audio10_iad_device_interrupt_test.c\n)\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Example\nDESCRIPTION: Example of an Interrupt Service Routine (ISR) written in assembly language for ThreadX on Cortex-M85.  It shows the necessary PUSH and POP operations to preserve registers and the use of .thumb_func directive for creating thumb labels.  The label '__tx_IntHandler' needs to be inserted in the correct location in the interrupt vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/gnu/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    .global  your_assembly_isr\n    .thumb_func\nyour_assembly_isr:\n    PUSH    {r0, lr}\n;\n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories for Tests and Samples\nDESCRIPTION: This snippet adds subdirectories for regression tests and samples. The regression tests are skipped for 'generic_build' and a fake test is added instead. The samples directory is skipped for 'standalone' builds.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nenable_testing()\n\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../../../ usbx)\nif(CMAKE_BUILD_TYPE STREQUAL \"generic_build\")\n  add_test(fake_test true)\nelse()\n  add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/regression regression)\nendif()\n\n# TODO: Unmask after adding sample for STANDALONE\nif(NOT (CMAKE_BUILD_TYPE MATCHES \"standalone.*\"))\n  add_subdirectory(../usbx/samples samples)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Writing Early and Standard Data with Mbed TLS\nDESCRIPTION: This snippet demonstrates writing data as early data first, and then as standard post-handshake application data if early data writing is not fully utilized. It calls `write_early_data` and `write_data` sequentially, handling potential errors after each call. `data_to_write` is the buffer containing the data, and `data_to_write_len` is the length of the data.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/tls13-early-data.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nret = write_early_data(ssl,\n                       data_to_write,\n                       data_to_write_len,\n                       &early_data_written);\nif (ret < 0 &&\n    ret != MBEDTLS_ERR_SSL_CANNOT_WRITE_EARLY_DATA) {\n    goto error;\n}\n\nret = write_data(ssl,\n                 data_to_write + early_data_written,\n                 data_to_write_len - early_data_written,\n                 &data_written);\nif (ret < 0) {\n    goto error;\n}\n\ndata_written += early_data_written;\n```\n\n----------------------------------------\n\nTITLE: Semihosting Enable Configuration\nDESCRIPTION: This parameter enables or disables semihosting SVC traps. Semihosting allows the target application to communicate with the host development environment for debugging and I/O operations. Setting this parameter to '0' disables semihosting, which is recommended for production applications.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/ARMCM3_config.txt#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.semihosting-enable=0\n```\n\n----------------------------------------\n\nTITLE: Swap Status Record Values\nDESCRIPTION: Illustrates the mapping of sector-state pairs to record values. Each state is represented by a set of three records (rec0, rec1, rec2), with specific byte values (0xff, 0x01, 0x02, 0x03) indicating the current state.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_14\n\nLANGUAGE: text\nCODE:\n```\n            | rec0 | rec1 | rec2\n    --------+------+------+------\n    state 0 | 0xff | 0xff | 0xff\n    state 1 | 0x01 | 0xff | 0xff\n    state 2 | 0x01 | 0x02 | 0xff\n    state 3 | 0x01 | 0x02 | 0x03\n```\n\n----------------------------------------\n\nTITLE: Linking CMSIS-DSP Library\nDESCRIPTION: This snippet links the CMSISDSP library to the `arm_linear_interp_example` executable. The `target_link_libraries` command adds the specified library as a private dependency.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_linear_interp_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(arm_linear_interp_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Including and Configuring Application\nDESCRIPTION: Includes the configuration file and configures the application with the specified root directory. Allows customized configuration of the application based on environment.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_variance_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(config)\nconfigApp(arm_variance_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: PSA Crypto Configuration Symbol Definition\nDESCRIPTION: A PSA Crypto configuration symbol starts with `PSA_WANT_`. If the symbol is not defined, the corresponding feature is not included. If defined to 1, the feature is included.  Other values are reserved for future use.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-conditional-inclusion-c.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nPSA_WANT_xxx\n```\n\n----------------------------------------\n\nTITLE: Create RSA Self-Signed Certificates (Shell)\nDESCRIPTION: These commands generate RSA self-signed certificates using OpenSSL. It includes generating a private key, creating a certificate signing request, and converting the key and certificate to DER format for use in embedded systems.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/samples/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n# Generate private key and certificate (public key).\nopenssl genrsa -out privkey.pem 2048\nopenssl req -new -days 365 -nodes -x509 -key privkey.pem -out cert.pem -config x509_config.cfg -subj \"/CN=<Same as device Id>\"\n\n# Convert format from key to der.\nopenssl rsa -outform der -in privkey.pem -out privkey.der \n\n# Convert format from cert pem to der.\nopenssl x509 -outform der -in cert.pem -out cert.der\n```\n\n----------------------------------------\n\nTITLE: Clean Examples matching TX, GCC, Cortex-A35 (PowerShell)\nDESCRIPTION: This command cleans examples matching the keywords 'TX ', 'GCC', and 'Cortex-A35'.  The pwsh -Command prefix is used for executing the PowerShell script from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_26\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','GCC','Cortex-A35' -clean\n```\n\n----------------------------------------\n\nTITLE: Building the Libraries\nDESCRIPTION: Launches the underlying build system (e.g., make, Visual Studio) to compile the libraries. This command compiles the Azure SDK for Embedded C based on the generated build files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncmake --build .\n```\n\n----------------------------------------\n\nTITLE: Valgrind Memory Trace Generation\nDESCRIPTION: This command uses Valgrind to execute a program and generate a trace of every memory access, including the address and data width, to a log file. The `lackey` tool is used to produce a detailed memory trace.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-shared-memory.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvalgrind --tool=lackey --trace-mem=yes --log-file=logfile ./myprogram\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories CMake\nDESCRIPTION: This CMake snippet configures the include directories for the target using `target_include_directories`. It specifies the `${CMAKE_CURRENT_LIST_DIR}/inc` directory as a location to find header files during compilation. The `PUBLIC` keyword indicates that these include directories are also available to other targets that depend on this target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/win32/vs_2019/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Configuration\nDESCRIPTION: This snippet shows how to add a ._threadx_heap section to the .ld linker file in STM32CubeIDE to allocate memory for ThreadX. It includes aligning the section, defining the start and end of the RAM segment, and setting the heap size. Also modifies \"tx_initialize_low_level.S\" to enable the \"USE_DYNAMIC_MEMORY_ALLOCATION\" flag.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Applications/ThreadX/Tx_CMSIS_Wrapper/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Conditional Header Inclusion (C)\nDESCRIPTION: This snippet demonstrates how to conditionally include header files required by the custom driver within `psa_crypto_driver_wrappers.h`. This ensures that the driver's dependencies are only included when the driver is enabled, preventing compilation errors when the driver is not present.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-driver-example-and-guide.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n#if defined(DRIVER_PREFIX_ENABLED)\n#include ...\n#endif\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories with CMake\nDESCRIPTION: This snippet utilizes the `target_include_directories` CMake command to define the include directories for the target `${PROJECT_NAME}`. The `PUBLIC` keyword signifies that these include directories are not only used by the specified target but also exposed to other targets that depend on it. In this case, the `inc` directory in the project root is added to the include paths.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    inc\n)\n```\n\n----------------------------------------\n\nTITLE: Finding Threads Package\nDESCRIPTION: This CMake command attempts to locate the Threads package. It is essential for conditional compilation and linking the thread library if available.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/ssl/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(Threads)\n```\n\n----------------------------------------\n\nTITLE: Coverage Configuration\nDESCRIPTION: Conditionally sets compile and link options for code coverage if the build type includes the word 'coverage'.  This enables the generation of code coverage reports during testing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(threadx_smp PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(threadx_smp PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Updating STM32CubeH5 Repository\nDESCRIPTION: Updates an existing STM32CubeH5 repository to the latest version. The `git pull` command fetches and merges the latest changes from the remote repository, while `git submodule update` initializes and updates the submodules to their latest versions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\ngit submodule update --init --recursive\n```\n\n----------------------------------------\n\nTITLE: Adding Default NetXDuo Sample Files\nDESCRIPTION: This snippet populates the `sample_files` variable with a list of default NetXDuo sample C source files. These files represent various networking protocols and functionalities, such as DNS, FTP, HTTP, SNMP, SNTP, Telnet, TFTP, TCP, and UDP.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/samples/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(sample_files\n    ${SOURCE_DIR}/demo_netxduo_dns.c\n    ${SOURCE_DIR}/demo_netxduo_ftp.c\n    ${SOURCE_DIR}/demo_netxduo_http.c\n    ${SOURCE_DIR}/demo_netxduo_snmp.c\n    ${SOURCE_DIR}/demo_netxduo_sntp_client.c\n    ${SOURCE_DIR}/demo_netxduo_telnet.c\n    ${SOURCE_DIR}/demo_netxduo_tftp.c\n    ${SOURCE_DIR}/demo_netx_duo_tcp.c\n    ${SOURCE_DIR}/demo_netx_duo_udp.c)\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories to CMake Target (STM32CubeH5)\nDESCRIPTION: This CMake snippet adds the 'inc' directory as a public include directory for the specified target. This allows other targets that depend on this target to automatically find the header files located in the 'inc' directory. Header files are located in the 'inc' directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/ac6/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    inc\n)\n```\n\n----------------------------------------\n\nTITLE: Adding ThreadX subdirectory\nDESCRIPTION: Adds the ThreadX directory as a subdirectory to the current build. This incorporates the ThreadX real-time operating system into the project build process.  It assumes that the `threadx` directory is located one level up from the current source directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/libs/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/../threadx threadx)\n```\n\n----------------------------------------\n\nTITLE: Setting Target Compile Definitions with CMake\nDESCRIPTION: This CMake snippet defines compile definitions for the target. It sets the PUBLIC property, meaning that these definitions are visible to dependent targets. Defines _GNU_SOURCE and TX_LINUX_DEBUG_ENABLE.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/ports_smp/linux/gnu/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_definitions(${PROJECT_NAME} PUBLIC \"-D_GNU_SOURCE -DTX_LINUX_DEBUG_ENABLE\")\n```\n\n----------------------------------------\n\nTITLE: Generate Test File (Bash Script)\nDESCRIPTION: Placeholder for the bash script that generates `tx_initialize_low_level.c`. The actual content of the bash script is unknown, but it's purpose is to create a C file that contains low-level initialization code needed by the tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/regression/CMakeLists.txt#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Placeholder for generate_test_file.sh\n# The actual script content is unknown, but it generates tx_initialize_low_level.c\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for Printer Class Tests CMake\nDESCRIPTION: Defines the source file paths for the USBX printer class test cases. These tests cover both device and host sides of the USB printer class functionality and include basic tests and error handling tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_20\n\nLANGUAGE: CMake\nCODE:\n```\n   ${SOURCE_DIR}/usbx_class_printer_basic_tests.c\n    ${SOURCE_DIR}/usbx_uxe_device_printer_test.c\n    ${SOURCE_DIR}/usbx_uxe_host_printer_test.c\n```\n\n----------------------------------------\n\nTITLE: RSA PKCS#1 v1.5 Signature RAW Algorithm Constructor in PSA\nDESCRIPTION: Uses the `PSA_ALG_RSA_PKCS1V15_SIGN_RAW` macro, which takes the hash directly as input, bypassing the DigestInfo structure. This is equivalent to setting `md_alg=MBEDTLS_MD_NONE` in the legacy Mbed TLS functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_39\n\nLANGUAGE: C\nCODE:\n```\nPSA_ALG_RSA_PKCS1V15_SIGN_RAW\n```\n\n----------------------------------------\n\nTITLE: Creating az_iot_common Library\nDESCRIPTION: Creates a static library named `az_iot_common` from the specified C source file, sets include directories, and links dependencies. It depends on `az::core`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/iot/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library (az_iot_common\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_common.c\n)\n\ntarget_include_directories (az_iot_common\n  PUBLIC\n    ${az_SOURCE_DIR}/sdk/inc\n)\n\ntarget_link_libraries(az_iot_common\n  PUBLIC\n    az::core\n)\n\nadd_library (az::iot::common ALIAS az_iot_common)\n```\n\n----------------------------------------\n\nTITLE: Build Examples matching TX, GCC, Cortex-A35 (PowerShell)\nDESCRIPTION: This command builds examples matching the keywords 'TX ', 'GCC', and 'Cortex-A35'. The pwsh -Command prefix ensures execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_28\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','GCC','Cortex-A35' -build\n```\n\n----------------------------------------\n\nTITLE: Initializing ECDSA Interruptible Signature Operation in PSA\nDESCRIPTION: Creates and initializes an operation object for interruptible ECDSA signature using `psa_sign_hash_interruptible_operation_t`. This object is then used with `psa_sign_hash_start` and `psa_sign_hash_complete` to perform the signature operation in a restartable manner.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_28\n\nLANGUAGE: C\nCODE:\n```\npsa_sign_hash_interruptible_operation_t operation;\nmemset(&operation, 0, sizeof(operation)); /* Or use the INIT macro */\n```\n\n----------------------------------------\n\nTITLE: Standalone Build Configuration\nDESCRIPTION: Configures standalone builds of LevelX and FileX by setting cache variables based on the CMAKE_BUILD_TYPE. It defines LX_STANDALONE_ENABLE and FX_STANDALONE_ENABLE when the build type matches \"standalone.*\".\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES \"standalone.*\")\n  set(LX_STANDALONE_ENABLE \n      ON \n      CACHE BOOL \"LevelX standalone enabled(No Azure RTOS ThreadX)\" FORCE)\n  set(FX_STANDALONE_ENABLE \n      ON \n      CACHE BOOL \"FileX standalone enabled(No Azure RTOS ThreadX)\" FORCE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Requiring a library build type\nDESCRIPTION: This snippet checks if neither static nor shared library build types were selected. If that is the case, it throws a fatal error, requiring the user to choose one.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nif (NOT USE_STATIC_MBEDTLS_LIBRARY AND NOT USE_SHARED_MBEDTLS_LIBRARY)\n    message(FATAL_ERROR \"Need to choose static or shared mbedtls build!\")\nendif(NOT USE_STATIC_MBEDTLS_LIBRARY AND NOT USE_SHARED_MBEDTLS_LIBRARY)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup and Library Creation\nDESCRIPTION: This snippet sets up the CMake project, includes configuration files for library and DSP settings, and creates a static library named `CMSISDSPSupport` from the specified source files. It uses GLOB to include C source files matching a pattern and then calls custom CMake functions `configLib` and `configDsp` for further configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/SupportFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n\nproject(CMSISDSPSupport)\n\ninclude(configLib)\ninclude(configDsp)\n\nfile(GLOB SRC \"./*_*.c\")\n\nadd_library(CMSISDSPSupport STATIC ${SRC})\n\nconfigLib(CMSISDSPSupport ${ROOT})\nconfigDsp(CMSISDSPSupport ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation Definitions\nDESCRIPTION: Adds compile definitions based on CMake options. If `PRECONDITIONS` is OFF, it defines `AZ_NO_PRECONDITION_CHECKING`. If `LOGGING` is OFF, it defines `AZ_NO_LOGGING`. These definitions are used to conditionally compile code based on the enabled features.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT PRECONDITIONS)\n  add_compile_definitions(AZ_NO_PRECONDITION_CHECKING)\nendif()\n\nif (NOT LOGGING)\n  add_compile_definitions(AZ_NO_LOGGING)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Shared Data TLV Entry Structure in C\nDESCRIPTION: Defines the structure of a TLV entry header within the shared data area. It contains the type (`tlv_type`) of the data entry, which identifies the consumer and subtype, and the length (`tlv_len`) of the data in bytes, excluding the header. All fields are little-endian.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_18\n\nLANGUAGE: C\nCODE:\n```\n/** Shared data TLV entry header format. All fields in little endian. */\nstruct shared_data_tlv_entry {\n    uint16_t tlv_type;\n    uint16_t tlv_len; /* TLV data length (not including this header). */\n};\n```\n\n----------------------------------------\n\nTITLE: Toolchain File Status Message\nDESCRIPTION: This snippet prints a status message indicating the toolchain file being used for the build. The `CMAKE_TOOLCHAIN_FILE` variable is expected to be set externally, pointing to the desired toolchain file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/libs/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: CMake Target Compile Options\nDESCRIPTION: Sets compile options for the 'threadx' target.  `-DTX_ENABLE_EVENT_TRACE` enables event tracing, and `-DTX_LINUX_NO_IDLE_ENABLE` disables idle mode if `ENV{ENABLE_IDLE}` is not defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/libs/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(threadx PRIVATE -DTX_ENABLE_EVENT_TRACE)\nif(NOT DEFINED ENV{ENABLE_IDLE})\n  target_compile_options(threadx PRIVATE -DTX_LINUX_NO_IDLE_ENABLE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating an OSEK Task in C\nDESCRIPTION: This C code demonstrates the function signature to create an OSEK task using CreateTask. It requires parameters such as name, entry function, priority, maximum activation count, stack size, scheduling policy, autostart, task type, and application mode.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nTaskType CreateTask(CHAR *name, \n                        void(*entry_function)(), \n                        UINT priority, \n                        UINT max_activation, \n                        ULONG stack_size, \n                        SCHEDULE policy, \n                        AUTOSTART start, \n                        UINT type, \n                        AppModeType mode);\n```\n\n----------------------------------------\n\nTITLE: Set Compile/Link Options for Coverage\nDESCRIPTION: This snippet conditionally adds compile and link options for code coverage if the `CMAKE_BUILD_TYPE` matches a pattern containing `_coverage`. It adds `-fprofile-arcs` and `-ftest-coverage` to both the compile and link options for the `netxduo` target, enabling GCC's code coverage instrumentation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(netxduo PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(netxduo PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Minimum Sync Level Configuration\nDESCRIPTION: This parameter forces the minimum synchronization level.  0 is off/default, 1=syncState, 2=postInsnIO, 3=postInsnAll.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/ARMCM3_config.txt#_snippet_3\n\nLANGUAGE: Configuration\nCODE:\n```\narmcortexm3ct.min_sync_level=3\n```\n\n----------------------------------------\n\nTITLE: Setting Volatile Key Lifetime with PSA in C\nDESCRIPTION: This code snippet shows how to declare a volatile key using the PSA Cryptography API. It sets the key lifetime with a specific location (`PSA_KEY_LOCATION_foo`) and persistence level (`PSA_KEY_PERSISTENCE_VOLATILE`).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_53\n\nLANGUAGE: C\nCODE:\n```\npsa_set_key_lifetime(&attributes, PSA_KEY_LIFETIME_FROM_PERSISTENCE_AND_LOCATION(\n        PSA_KEY_LOCATION_foo,\n        PSA_KEY_PERSISTENCE_VOLATILE));\n```\n\n----------------------------------------\n\nTITLE: EWARM linker .icf file modification (C)\nDESCRIPTION: This code shows how to modify the EWARM linker `.icf` file to allocate memory for ThreadX. This ensures that ThreadX can use dynamic memory allocation by defining the end of used RAM.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/Fx_NoR_Write_Read_File/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Defining jsonschema Dependency with Version Constraint\nDESCRIPTION: This line defines a dependency on the `jsonschema` package, specifying that the version must be greater than or equal to 3.2.0. This package is used for validating JSON data structures.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/scripts/driver.requirements.txt#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\njsonschema >= 3.2.0\n```\n\n----------------------------------------\n\nTITLE: Conditional Compile Definitions (ALLFAST)\nDESCRIPTION: Conditionally defines ARM_ALL_FAST_TABLES if CONFIGTABLE is true and ALLFAST is also true.  This likely enables the use of fast lookup tables for certain calculations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif (CONFIGTABLE AND ALLFAST)\n    target_compile_definitions(CMSISDSPComplexMath PUBLIC ARM_ALL_FAST_TABLES)  \nendif()\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration\nDESCRIPTION: This snippet shows how to modify the .icf linker file in EWARM to provide memory for ThreadX by placing the FREE_MEM section in the RAM region. This ensures that ThreadX can access the necessary memory for its heap.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Applications/ThreadX/Tx_CMSIS_Wrapper/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Set Source Directory\nDESCRIPTION: This snippet retrieves the absolute path of the source directory containing the regression test files. It uses the CMAKE_CURRENT_LIST_DIR variable to determine the location of the current CMakeLists.txt file and constructs the path accordingly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../regression\n                       ABSOLUTE)\n```\n\n----------------------------------------\n\nTITLE: Configuring Library Properties and DSP Includes\nDESCRIPTION: This snippet configures the CMSISDSPSVM library properties using `configLib` and `configDsp`, setting the ROOT variable. It also sets the include directories for the library to include the DSP headers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/SVMFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nconfigLib(CMSISDSPSVM ${ROOT})\nconfigDsp(CMSISDSPSVM ${ROOT})\n\n### Includes\ntarget_include_directories(CMSISDSPSVM PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Creating Executable and Including Configuration\nDESCRIPTION: This snippet creates an executable named `arm_linear_interp_example` and includes a configuration file. The `configApp` function configures the application using the specified executable name and the ROOT directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_linear_interp_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(arm_linear_interp_example)\n\n\ninclude(config)\nconfigApp(arm_linear_interp_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Setting Up Coverage Testing\nDESCRIPTION: This snippet configures code coverage for builds that include '_coverage' in their name. It adds compile and link options to the 'netxduo' target to enable profiling for coverage analysis.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(netxduo PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(netxduo PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Filename Extension Removal Function CMake\nDESCRIPTION: This CMake function `get_name_without_last_ext` removes the last extension from a filename. It splits the filename into parts using '.' as a delimiter, removes the last part, and then joins the remaining parts back together. The result is stored in the specified destination variable using `PARENT_SCOPE` to make it available outside the function's scope. It takes the destination variable name and the full filename as input.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_17\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(get_name_without_last_ext dest_var full_name)\n    # Split into a list on '.' (but a cmake list is just a ';'-separated string)\n    string(REPLACE \".\" \";\" ext_parts \"${full_name}\")\n    # Remove the last item if there are more than one\n    list(LENGTH ext_parts ext_parts_len)\n    if (${ext_parts_len} GREATER \"1\")\n        math(EXPR ext_parts_last_item \"${ext_parts_len} - 1\")\n        list(REMOVE_AT ext_parts ${ext_parts_last_item})\n    endif()\n    # Convert back to a string by replacing separators with '.'\n    string(REPLACE \";\" \".\" no_ext_name \"${ext_parts}\")\n    # Copy into the desired variable\n    set(${dest_var} ${no_ext_name} PARENT_SCOPE)\nendfunction(get_name_without_last_ext)\n```\n\n----------------------------------------\n\nTITLE: Defining Build Configurations\nDESCRIPTION: Defines the available build configurations for the project, including default, coverage, exFAT, and fault-tolerant variations.  These configurations affect compiler options and preprocessor definitions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_CONFIGURATIONS\n    default_build_coverage no_cache_build exfat_build exfat_no_cache_build\n    exfat_no_check_build exfat_build_4096 no_cache_standalone_build\n    fault_tolerant_build_coverage fault_tolerant_exfat_build no_check_build no_cache_fault_tolerant_build\n    standalone_build_coverage exfat_standalone_build_coverage exfat_standalone_build_2048\n    standalone_fault_tolerant_build_coverage exfat_standalone_fault_tolerant_build_coverage\n    standalone_no_cache_fault_tolerant_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Add Executable Tests\nDESCRIPTION: This snippet iterates through the list of test case files, creates an executable for each, links it against the `test_utility` library, and adds it as a CTest test. The loop retrieves the filename component without the extension for use as the executable name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/regression/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(test_case ${regression_test_cases})\n  get_filename_component(test_name ${test_case} NAME_WE)\n  add_executable(${test_name} ${test_case})\n  target_link_libraries(${test_name} PRIVATE test_utility)\n  add_test(${CMAKE_BUILD_TYPE}::${test_name} ${test_name})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Set Minimum CMake Version and Project Details\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.14 and defines the project name as 'arm_bayes_example' with a version of 0.1. These are fundamental settings for any CMake project, defining the build environment and project identification.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_bayes_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_bayes_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: Function Parameter Grouping in MBedTLS\nDESCRIPTION: This snippet illustrates the preferred way of grouping related function parameters together, particularly when they span multiple lines.  This convention improves code readability and emphasizes the logical relationships between parameters passed to a function.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/tls13-support.md#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nmbedtls_ssl_start_handshake_msg( ssl, hs_type,\n                                     buf, buf_len );\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project for FileX Samples\nDESCRIPTION: This snippet sets the minimum required CMake version, sets a CMake policy, and creates a project named 'samples' using the C language. It initializes the foundation for building the FileX sample applications.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/samples/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(samples LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Build Examples matching TX, GCC, SMP (PowerShell)\nDESCRIPTION: This command builds all examples matching the keywords 'TX ', 'GCC', and 'SMP'.  These examples are likely ThreadX examples for SMP (Symmetric Multiprocessing) using the GCC compiler. The pwsh -Command prefix facilitates execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_22\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','GCC','SMP' -build\n```\n\n----------------------------------------\n\nTITLE: Defining Image Version Structure\nDESCRIPTION: This code defines a structure `image_version` to represent the version of an image.  It includes fields for major, minor, revision, and build number, allowing the bootloader to determine the image's version.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nstruct image_version {\n    uint8_t iv_major;\n    uint8_t iv_minor;\n    uint16_t iv_revision;\n    uint32_t iv_build_num;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining data structures for simulated interrupt\nDESCRIPTION: This code snippet shows the data structures and prototypes necessary to create a simulated interrupt thread. It includes a pthread_t for the thread and a function prototype for the interrupt entry point.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/linux/gnu/readme_threadx.txt#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\npthread_t    _sample_linux_interrupt_thread;\nvoid        *_sample_linux_interrupt_entry(void *p);\n```\n\n----------------------------------------\n\nTITLE: Filtering Source Files for Crypto Libraries\nDESCRIPTION: This snippet filters the source files for the `netxduo` target, keeping only those from the `crypto_libraries` directory, while excluding `nx_crypto_module_start` and `nx_crypto_generic_ciphersuites` (when building standalone).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/crypto/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nget_target_property(SOURCES_LIST netxduo SOURCES)\nset(NEW_SOURCES_LIST \"\")\nforeach(SOURCE ${SOURCES_LIST})\n  if((\"${SOURCE}\" MATCHES \".*crypto_libraries/.*\")\n     AND NOT ((\"${SOURCE}\" MATCHES \".*nx_crypto_module_start.*\")\n              OR ((\"${SOURCE}\" MATCHES \".*nx_crypto_generic_ciphersuites.*\")\n                  AND (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"standalone_build\"))))\n    list(APPEND NEW_SOURCES_LIST ${SOURCE})\n  endif()\nendforeach()\nset_target_properties(netxduo PROPERTIES SOURCES \"${NEW_SOURCES_LIST}\")\n```\n\n----------------------------------------\n\nTITLE: Define CMSIS-DSP Path\nDESCRIPTION: This snippet defines the path to the CMSIS-DSP library using variables for the root directory and DSP directory. This is needed to include and link the library correctly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Needed to include the configBoot module\n# Define the path to CMSIS-DSP (ROOT is defined on command line when using cmake)\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows the required linker configuration for the EWARM toolchain to allocate memory for ThreadX.  It adds a section to the .icf file that places the last FREE_MEM section in the RAM_region. This is necessary for ThreadX to manage its memory pool correctly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_Network_Basics_wifi/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Adding and configuring executable tests\nDESCRIPTION: This snippet iterates through a list of MQTT test cases and configures each one. It adds an executable for each test case using source files from the '${test_case}_file_list' variable and the PCAP source file. It then configures the network for each test case by calling the 'network_config' function and linking required libraries (test_utility and pcap). Finally, it defines a test command using bash that sets up network interfaces, captures network traffic using tcpdump, executes the test, and cleans up the network interfaces after the test is complete. It also checks the exit code of the test and reports any errors.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt_interoperability/regression/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(test_case ${mqtt_test_cases})\n  add_executable(${test_case} ${${test_case}_file_list} ${PCAP_SOURCE})\n  network_config(${test_case})\n  target_link_libraries(${test_case} PRIVATE test_utility pcap)\n  add_test(\n    NAME ${CMAKE_BUILD_TYPE}::${test_case}\n    COMMAND\n      bash -c\n      \"export PATH=${SOURCE_DIR}/test_scripts/:$PATH;\n       ip link del ${${test_case}_interface}>/dev/null 2>&1;\n       ip link add ${${test_case}_interface} type veth peer name ${${test_case}_remote_interface} || exit 1;\n       ifconfig ${${test_case}_interface} up || { ip link del ${${test_case}_interface}; exit 1; };\n       ifconfig ${${test_case}_remote_interface} ${${test_case}_remote_ip} up netmask ${TEST_NETMASK} || { ip link del ${${test_case}_interface};exit 1; };\n       ethtool --offload ${${test_case}_remote_interface} tx off || { ip link del ${${test_case}_interface}; exit 1; };\n       tcpdump -i ${${test_case}_remote_interface} -s 0 -w ${CMAKE_CURRENT_BINARY_DIR}/${test_case}.pcap& ;\n       pid=$!\n       ${CMAKE_CURRENT_BINARY_DIR}/${test_case};\n       exit_code=$?\n       sleep 1;\n       kill -TERM $pid\n       ip link del ${${test_case}_interface} || exit 1;\n       [[ $exit_code = 0 ]] || [[ $exit_code = 233 ]] || { echo Exit code: $exit_code; exit $exit_code; };\"\n    WORKING_DIRECTORY ${SOURCE_DIR})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Creating the executable\nDESCRIPTION: This snippet adds an executable named 'arm_signal_convergence_example'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(arm_signal_convergence_example)\n```\n\n----------------------------------------\n\nTITLE: Link CMSISDSP Library\nDESCRIPTION: This snippet links the `arm_dotproduct_example` executable against the `CMSISDSP` library. The `target_link_libraries` command adds the `CMSISDSP` library as a private dependency, meaning it's only required for building this target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(arm_dotproduct_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: Add Link Options\nDESCRIPTION: Adds link options for the project, specifying the target architecture.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_link_options(-m32)\n```\n\n----------------------------------------\n\nTITLE: Creating az_iot_provisioning Library\nDESCRIPTION: Creates a static library named `az_iot_provisioning` from the specified C source files, sets include directories, and links dependencies.  It depends on `az::core` and `az::iot::common`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/iot/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library (az_iot_provisioning\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_provisioning_client.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_iot_provisioning_client_sas.c\n)\n\ntarget_include_directories (az_iot_provisioning\n  PUBLIC\n    ${az_SOURCE_DIR}/sdk/inc\n)\n\ntarget_link_libraries(az_iot_provisioning\n  PUBLIC\n    az::core\n    az::iot::common\n)\n\nadd_library (az::iot::provisioning ALIAS az_iot_provisioning)\n```\n\n----------------------------------------\n\nTITLE: Getting the UInt32 Value of a JSON Token in C\nDESCRIPTION: Gets the JSON token's number as a 32-bit unsigned integer. It requires a pointer to the reader instance and a pointer to a variable to store the unsigned integer value. On success, it returns NX_AZURE_IOT_SUCCESS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_token_uint32_get(NX_AZURE_IOT_JSON_READER *reader_ptr,\n                                               uint32_t *value_ptr);\n```\n\n----------------------------------------\n\nTITLE: Defining Paths for CMSIS-DSP\nDESCRIPTION: This snippet defines the paths to the CMSIS-DSP library, which contains DSP functions used in the ARM linear interpolation example. The ROOT variable is defined externally, and the DSP variable points to the CMSIS/DSP directory relative to the ROOT.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_linear_interp_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Needed to include the configBoot module\n# Define the path to CMSIS-DSP (ROOT is defined on command line when using cmake)\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\n# Add DSP folder to module path\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Commands for Data Generation\nDESCRIPTION: This snippet adds custom commands to generate the data files. These commands execute Python scripts with specific arguments and dependencies. The `GEN_FILES` variable controls whether these commands are added.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/tests/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(GEN_FILES)\n    add_custom_command(\n        OUTPUT\n            ${bignum_generated_data_files}\n        WORKING_DIRECTORY\n            ${CMAKE_CURRENT_SOURCE_DIR}/..\n        COMMAND\n            ${MBEDTLS_PYTHON_EXECUTABLE}\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_bignum_tests.py\n            --directory ${CMAKE_CURRENT_BINARY_DIR}/suites\n        DEPENDS\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_bignum_tests.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/bignum_common.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/bignum_core.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/bignum_mod_raw.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/bignum_mod.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/test_case.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/test_data_generation.py\n    )\n    add_custom_command(\n        OUTPUT\n            ${config_generated_data_files}\n        WORKING_DIRECTORY\n            ${CMAKE_CURRENT_SOURCE_DIR}/..\n        COMMAND\n            ${MBEDTLS_PYTHON_EXECUTABLE}\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_config_tests.py\n            --directory ${CMAKE_CURRENT_BINARY_DIR}/suites\n        DEPENDS\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_config_tests.py\n            # Do not declare the configuration files as dependencies: they\n            # change too often in ways that don't affect the result\n            # ((un)commenting some options).\n    )\n    add_custom_command(\n        OUTPUT\n            ${ecp_generated_data_files}\n        WORKING_DIRECTORY\n            ${CMAKE_CURRENT_SOURCE_DIR}/..\n        COMMAND\n            ${MBEDTLS_PYTHON_EXECUTABLE}\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_ecp_tests.py\n            --directory ${CMAKE_CURRENT_BINARY_DIR}/suites\n        DEPENDS\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_ecp_tests.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/bignum_common.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/ecp.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/test_case.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/test_data_generation.py\n    )\n    add_custom_command(\n        OUTPUT\n            ${psa_generated_data_files}\n        WORKING_DIRECTORY\n            ${CMAKE_CURRENT_SOURCE_DIR}/..\n        COMMAND\n            ${MBEDTLS_PYTHON_EXECUTABLE}\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_psa_tests.py\n            --directory ${CMAKE_CURRENT_BINARY_DIR}/suites\n        DEPENDS\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/generate_psa_tests.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/crypto_data_tests.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/crypto_knowledge.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/macro_collector.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/psa_information.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/psa_storage.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/test_case.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../framework/scripts/mbedtls_framework/test_data_generation.py\n            ${CMAKE_CURRENT_SOURCE_DIR}/../include/psa/crypto_config.h\n            ${CMAKE_CURRENT_SOURCE_DIR}/../include/psa/crypto_values.h\n            ${CMAKE_CURRENT_SOURCE_DIR}/../include/psa/crypto_extra.h\n    )\n\nelse()\n    foreach(file ${all_generated_data_files})\n        link_to_source(${file})\n    endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Opaque Key for TLS 1.2 EC J-PAKE\nDESCRIPTION: The function `mbedtls_ssl_set_hs_ecjpake_password_opaque()` registers a PSA key for use with the TLS 1.2 EC J-PAKE key exchange. It allows isolation of long-term secrets.  The application needs to register the key using this API.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/use-psa-crypto.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nmbedtls_ssl_set_hs_ecjpake_password_opaque()\n```\n\n----------------------------------------\n\nTITLE: Create Executables and Add Tests\nDESCRIPTION: This snippet iterates through the list of MQTT test cases, creates an executable for each test case, links it with the test utility library, and adds it as a test.  The test name is derived from the filename of the test case.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/regression/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(\n  test_case\n  ${mqtt_test_cases})\n  get_filename_component(test_name ${test_case} NAME_WE)\n  add_executable(${test_name} ${test_case})\n  target_link_libraries(${test_name} PRIVATE test_utility)\n  add_test(${CMAKE_BUILD_TYPE}::${test_name} ${test_name})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Building POSIX Platform Library\nDESCRIPTION: This snippet conditionally builds the 'az_posix' static library if AZ_PLATFORM_IMPL is set to 'POSIX'. It adds the library source file and links it with the 'az_core' library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/platform/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nelseif(AZ_PLATFORM_IMPL STREQUAL \"POSIX\")\n  # build linux platform\n  add_library(az_posix STATIC\n      ${CMAKE_CURRENT_LIST_DIR}/az_posix.c\n  )\n\n  target_link_libraries(az_posix\n    PRIVATE\n      az_core\n  )\n\n```\n\n----------------------------------------\n\nTITLE: Defining Image Trailer TLV Types\nDESCRIPTION: This code defines the types of TLV (Type-Length-Value) records that can be included in the image trailer. These TLV types represent metadata such as key hashes, SHA256 checksums, RSA signatures, ECDSA signatures, and encryption keys, allowing the bootloader to verify the integrity and authenticity of the image.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n/*\n * Image trailer TLV types.\n */\n#define IMAGE_TLV_KEYHASH           0x01   /* hash of the public key */\n#define IMAGE_TLV_SHA256            0x10   /* SHA256 of image hdr and body */\n#define IMAGE_TLV_RSA2048_PSS       0x20   /* RSA2048 of hash output */\n#define IMAGE_TLV_ECDSA224          0x21   /* ECDSA of hash output */\n#define IMAGE_TLV_ECDSA256          0x22   /* ECDSA of hash output */\n#define IMAGE_TLV_RSA3072_PSS       0x23   /* RSA3072 of hash output */\n#define IMAGE_TLV_ED25519           0x24   /* ED25519 of hash output */\n#define IMAGE_TLV_ENC_RSA2048       0x30   /* Key encrypted with RSA-OAEP-2048 */\n#define IMAGE_TLV_ENC_KW128         0x31   /* Key encrypted with AES-KW-128 */\n#define IMAGE_TLV_ENC_EC256         0x32   /* Key encrypted with ECIES-P256 */\n#define IMAGE_TLV_ENC_X25519        0x33   /* Key encrypted with ECIES-X25519 */\n#define IMAGE_TLV_DEPENDENCY        0x40   /* Image depends on other image */\n#define IMAGE_TLV_SEC_CNT           0x50   /* security counter */\n```\n\n----------------------------------------\n\nTITLE: Completing ECDSA Interruptible Signature in PSA\nDESCRIPTION: Completes an interruptible ECDSA signature operation using `psa_sign_hash_complete`.  This function must be called repeatedly until it returns a status other than `PSA_OPERATION_INCOMPLETE`. It outputs the signature.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_30\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t status = psa_sign_hash_complete(&operation, signature, signature_size, &signature_length);\n```\n\n----------------------------------------\n\nTITLE: Disabling VFP Support - C\nDESCRIPTION: This C code shows how to disable VFP register saving for a thread. Calling `tx_thread_vfp_disable()` prevents VFP registers from being saved/restored when the thread is preempted.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac5/readme_threadx.txt#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nvoid    tx_thread_vfp_disable(void);\n```\n\n----------------------------------------\n\nTITLE: Build ThreadX Library\nDESCRIPTION: Executes a script to build the ThreadX library and adds a custom target to ensure it's built before LevelX. It also sets include directories for LevelX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nexecute_process(COMMAND ${CMAKE_CURRENT_LIST_DIR}/run.sh build_libs)\nadd_custom_target(build_libs ALL COMMAND ${CMAKE_CURRENT_LIST_DIR}/run.sh\n                                             build_libs)\nadd_dependencies(levelx build_libs)\ntarget_include_directories(levelx PUBLIC ${CMAKE_BINARY_DIR}/../libs/inc)\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake and Project\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.0.0 and declares a CMake policy.  It then defines the project name as 'regression_test' with C as the primary language.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(regression_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for Printer Device Standalone Tests CMake\nDESCRIPTION: Defines the source file paths for the USBX printer device class standalone test cases. These tests are designed to run independently and test the basic standalone functionalities of the printer device class.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_21\n\nLANGUAGE: CMake\nCODE:\n```\n  ${SOURCE_DIR}/usbx_class_printer_device_standalone_basic_tests.c\n  ${SOURCE_DIR}/usbx_uxe_device_printer_test.c\n```\n\n----------------------------------------\n\nTITLE: Initializing JSON Writer with Packet\nDESCRIPTION: Initializes an Azure IoT JSON writer to write JSON data into an NX_PACKET. The function requires a pointer to the JSON writer instance, a pointer to the NX_PACKET, and a wait option for allocating the next packet.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_json_writer_init(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr,\n                                   NX_PACKET *packet_ptr, UINT wait_option);\n```\n\n----------------------------------------\n\nTITLE: Checking out Specific Firmware Version\nDESCRIPTION: Checks out a specific version of the STM32CubeH5 firmware. Replace `vX.Y.Z` with the desired version tag. This command allows you to work with a specific release of the firmware, ensuring compatibility and reproducibility.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout vX.Y.Z # Specify the targeted vX.Y.Z version\n```\n\n----------------------------------------\n\nTITLE: Target Compile Options for LevelX\nDESCRIPTION: Sets specific compile options for the LevelX target, including warnings and flags for code style and safety.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_compile_options(\n  levelx\n  PRIVATE -Werror\n          -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal)\n```\n\n----------------------------------------\n\nTITLE: Building with CMake - Windows\nDESCRIPTION: This code snippet indicates how to build the project on Windows using Visual Studio. It assumes you have already run CMake and generated the az.sln solution file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_25\n\nLANGUAGE: powershell\nCODE:\n```\n.\\az.sln\n```\n\n----------------------------------------\n\nTITLE: Open Visual Studio Solution (PowerShell)\nDESCRIPTION: This command opens the generated Visual Studio solution file (`az.sln`) in Visual Studio. This allows compiling and running the Azure SDK for Embedded C samples.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_10\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS C:\\azure-sdk-for-c\\build> .\\az.sln\n```\n\n----------------------------------------\n\nTITLE: CPI Calculation Multiplier Configuration\nDESCRIPTION: This parameter sets the multiplier for calculating Cycles Per Instruction (CPI). It is a run-time setting influencing performance measurements. This value, along with the divider, determines the final CPI value.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/ARMCM3_config.txt#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\narmcortexm3ct.cpi_mul=1\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This snippet utilizes the `target_sources` command in CMake to specify the private source files for the project. The `${PROJECT_NAME}` variable represents the name of the project. The `# {{BEGIN_TARGET_SOURCES}}` and `# {{END_TARGET_SOURCES}}` comments act as placeholders where source file paths can be added.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m3/iar/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Conditional TLS 1.3 Test Case Definition (CMake)\nDESCRIPTION: This snippet conditionally defines TLS 1.3 related test cases if the `-DNX_SECURE_TLS_ENABLE_TLS_1_3` flag is present in the `CMAKE_BUILD_TYPE`. It uses `list(APPEND)` and `set` to manage test case names and their corresponding file lists.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/regression/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif(\"-DNX_SECURE_TLS_ENABLE_TLS_1_3\" IN_LIST ${CMAKE_BUILD_TYPE})\n  list(APPEND nx_secure_test_cases\n       tls_1_3_openssl_echo_server_nx_secure_echo_client_test)\n  set(tls_1_3_openssl_echo_server_nx_secure_echo_client_test_file_list\n      ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_test.c\n      ${SOURCE_DIR}/tls_1_3_openssl_echo_server_entry.c\n      ${SOURCE_DIR}/tls_1_3_nx_secure_echo_client_entry.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Cloning Azure SDK for Embedded C repository\nDESCRIPTION: This snippet clones the Azure SDK for Embedded C repository from GitHub.  This repository contains the source code, samples, and documentation for the SDK. This allows the user to work with the source code for the azure-sdk-for-c project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n~$ git clone https://github.com/Azure/azure-sdk-for-c.git\n```\n\n----------------------------------------\n\nTITLE: Install Python Dependencies\nDESCRIPTION: This command installs the required Python modules for the ROT_AppliConfig tool from the requirements.txt file. This is necessary when switching from the Windows executable version to the Python version.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Applications/ROT/OEMiROT_Appli/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Include Platform Specific Code\nDESCRIPTION: This snippet adds the platform-specific code for FileX based on the THREADX_ARCH and THREADX_TOOLCHAIN variables. If FILEX_CUSTOM_PORT is defined, it adds that subdirectory instead.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\n# Pick up the port specific stuff first\nif(DEFINED FILEX_CUSTOM_PORT)\n    add_subdirectory(${FILEX_CUSTOM_PORT} filex_port)\nelse()\n    add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/ports/${THREADX_ARCH}/${THREADX_TOOLCHAIN})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Sample Files\nDESCRIPTION: This snippet defines a list of C source files that will be compiled into separate executables. Each file corresponds to a specific sample application.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/samples/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(sample_files\n    ${SOURCE_DIR}/demo_filex_nand_flash.c\n    ${SOURCE_DIR}/demo_filex_nor_flash.c)\n```\n\n----------------------------------------\n\nTITLE: Setting MbedCrypto Executables List (CMake)\nDESCRIPTION: Defines a list of MbedCrypto executables. This list is later used to create the executables using CMake.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(executables_mbedcrypto\n    dh_genprime\n    ecdh_curve25519\n    ecdsa\n    gen_key\n    key_app\n    key_app_writer\n    mpi_demo\n    pk_encrypt\n    pk_decrypt\n    pk_sign\n    pk_verify\n    rsa_decrypt\n    rsa_encrypt\n    rsa_genkey\n    rsa_sign\n    rsa_sign_pss\n    rsa_verify\n    rsa_verify_pss\n)\n```\n\n----------------------------------------\n\nTITLE: Set Source Directory\nDESCRIPTION: This snippet sets the source directory for the regression tests. It defines the variable `SOURCE_DIR` which points to the directory containing the C source files for the tests, relative to the current CMake list file directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../regression_test)\n```\n\n----------------------------------------\n\nTITLE: Add Include Directories CMake\nDESCRIPTION: Adds the `${CURRENT_DIR}/inc` directory to the include path for the target `PROJECT_NAME`. This makes the header files in that directory available for inclusion in the project's source code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/common_smp/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} \n    PUBLIC \n    ${CURRENT_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker Configuration\nDESCRIPTION: This code snippet shows how to configure the linker file for EWARM to allocate memory for ThreadX dynamic memory allocation. It places the `FREE_MEM` section in the `RAM_region`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/USBX/Ux_Device_HID_CDC_ACM/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: ARM Cortex-M3 CPI Multiplier Configuration\nDESCRIPTION: This parameter sets the multiplier for calculating Cycles Per Instruction (CPI). It is an integer value configurable at runtime, with a default value of 0x1.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/ARMCM3_config.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.cpi_mul=1                               # (int   , run-time ) default = '0x1'    : multiplier for calculating CPI (Cycles Per Instruction)\n```\n\n----------------------------------------\n\nTITLE: Compiler Options Configuration\nDESCRIPTION: This snippet configures compiler and linker options based on the ENABLE_64 environment variable to build for either 32-bit or 64-bit architecture.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/libs/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(DEFINED ENV{ENABLE_64})\n  message(STATUS \"Building for 64bit\")\nelse()\n  add_compile_options(-m32)\n  add_link_options(-m32)\n  message(STATUS \"Building for 32bit\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake and Project\nDESCRIPTION: This snippet sets the minimum required CMake version, sets CMake policies for compatibility, and initializes the project with the name `netx_test` using the C language.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo64/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\ncmake_policy(SET CMP0077 NEW)\n\nproject(netx_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories\nDESCRIPTION: Sets the include directories for the CMSISDSPDistance library. It adds the DSP/Include directory as a public include directory and the current directory (.) as a private include directory. This allows the library to find necessary header files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/DistanceFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(CMSISDSPDistance PUBLIC \"${DSP}/Include\")\ntarget_include_directories(CMSISDSPDistance PRIVATE \".\")\n```\n\n----------------------------------------\n\nTITLE: Connect to Azure Account\nDESCRIPTION: Connects to the Azure account using Connect-AzAccount and specifies the subscription ID. The Subscription parameter is optional but recommended. The example shows connecting to Azure with a specific subscription.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/README.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nConnect-AzAccount -Subscription 'YOUR SUBSCRIPTION ID'\neng\\common\\TestResources\\New-TestResources.ps1 keyvault\n```\n\n----------------------------------------\n\nTITLE: CPI Divider Configuration\nDESCRIPTION: This parameter sets the divider for calculating Cycles Per Instruction (CPI). CPI is a metric used to assess the performance of the application. Adjusting the divider impacts the calculated CPI value, affecting performance analysis.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/ARMCM3_config.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.cpi_div=1\n```\n\n----------------------------------------\n\nTITLE: Define ThreadX Library Target\nDESCRIPTION: Defines the ThreadX library and creates an alias for consumers. This allows other parts of the project or other projects to link against ThreadX using a more user-friendly name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Define our target library and an alias for consumers\nadd_library(${PROJECT_NAME})\nadd_library(\"azrtos::${PROJECT_NAME}\" ALIAS ${PROJECT_NAME})\n```\n\n----------------------------------------\n\nTITLE: Building ThreadX and FileX Libraries\nDESCRIPTION: This snippet executes a shell script to build the ThreadX libraries. It adds a custom target 'build_libs' that depends on the shell script execution, and the 'netxduo' target depends on 'build_libs'. The ThreadX and FileX libraries are imported as shared libraries, and target properties are set with their locations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\n# Build ThreadX library once\nexecute_process(COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh build_libs)\nadd_custom_target(build_libs ALL COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/run.sh\n                                         build_libs)\nadd_dependencies(netxduo build_libs)\ntarget_include_directories(netxduo PUBLIC ${CMAKE_BINARY_DIR}/../libs/inc)\nadd_library(threadx SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::threadx\" ALIAS threadx)\nset_target_properties(\n  threadx PROPERTIES IMPORTED_LOCATION\n                     ${CMAKE_BINARY_DIR}/../libs/threadx/libthreadx.so)\nadd_library(filex SHARED IMPORTED GLOBAL)\nadd_library(\"azrtos::filex\" ALIAS filex)\nset_target_properties(\n  filex PROPERTIES IMPORTED_LOCATION\n                   ${CMAKE_BINARY_DIR}/../libs/filex/libfilex.so)\ntarget_link_libraries(netxduo PUBLIC filex)\n```\n\n----------------------------------------\n\nTITLE: Add Include Directories with CMake\nDESCRIPTION: This CMake snippet adds include directories to the project. The `target_include_directories` command is used to specify directories where the compiler should look for header files. The PUBLIC keyword indicates that these include directories are also exposed to other targets that depend on this target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/ports/linux/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Setting User File and Including NetX Duo\nDESCRIPTION: This section defines the path to the user-specific NetX configuration file (`nx_user.h`) and includes the CMake configuration for NetX Duo from its respective directory. This incorporates the NetX Duo library into the current project build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo64/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(NX_USER_FILE ${CMAKE_CURRENT_SOURCE_DIR}/nx_user.h)\ninclude(${CMAKE_CURRENT_SOURCE_DIR}/../netxduo/CMakeLists.txt)\n```\n\n----------------------------------------\n\nTITLE: Adding PictBridge Source Files to Target in CMake\nDESCRIPTION: This snippet defines the source files to be compiled and linked into the specified target, ${PROJECT_NAME}.  It uses the target_sources CMake command to add multiple C source files located within the ${CMAKE_CURRENT_LIST_DIR}/src/ directory. These files are related to the PictBridge protocol and its various functionalities, including DPS client/host implementations and XML parsing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_pictbridge/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_array_element_to_array_hexa.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_data.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_api_abortjob.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_api_capability.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_api_configure_print_service.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_api_continuejob.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_api_device_status.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_api_startjob.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_input_object_abortjob.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_input_object_configure_print_service.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_input_object_continuejob.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_input_object_get_capability.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_input_object_prepare.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_input_object_startjob.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_object_data_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_object_data_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_object_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_object_handles_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_object_info_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_object_info_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_object_number_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_register_event_callback_function.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpsclient_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_input_object_notify_device_status.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_input_object_notify_job_status.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_input_object_send.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_notification_callback.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_object_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_output_object_configure_print_service.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_output_object_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_output_object_get_capability.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_output_object_get_device_status.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_response_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_start.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_startjob.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_dpshost_thread.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_element_to_decimal.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_element_to_hexa.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_hexa_to_decimal_string.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_hexa_to_element.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_hexa_to_major_minor.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_object_parse.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_output_object_tag_line_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_tag_name_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_tag_name_scan.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_getcapability_capability_layouts.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_getcapability_capability_papertypes.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_notifydevicestatus_capabilitychanged.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_notifydevicestatus_disconnectenable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_notifydevicestatus_dpsprintservicestatus.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_notifydevicestatus_errorreason.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_notifydevicestatus_errorstatus.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_notifydevicestatus_jobendreason.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_notifydevicestatus_newjobok.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_jobconfig_cropping.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_jobconfig_dateprint.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_jobconfig_filenameprint.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_jobconfig_filetype.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_jobconfig_fixedsize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_jobconfig_imageoptimize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_jobconfig_layout.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_jobconfig_papersize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_jobconfig_papertype.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_jobconfig_quality.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_printinfo.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_printinfo_copies.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_printinfo_copyid.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_printinfo_croppingarea.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_printinfo_date.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_printinfo_fileid.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_printinfo_filename.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_printinfo_filepath.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_input_startjob_printinfo_prtid.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_null.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getcapability_capability_croppings.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getcapability_capability_dateprints.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getcapability_capability_filenameprints.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getcapability_capability_filetypes.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getcapability_capability_fixedsizes.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getcapability_capability_imageoptimizes.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getcapability_capability_layouts.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getcapability_capability_papersizes.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getcapability_capability_papertypes.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getcapability_capability_qualities.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getdevicestatus_capabilitychanged.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getdevicestatus_disconnectenable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getdevicestatus_dpsprintservicestatus.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getdevicestatus_errorreason.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getdevicestatus_errorstatus.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getdevicestatus_jobendreason.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_getdevicestatus_newjobok.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_output_result.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_root_dps.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_root_input.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_root_output.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_pictbridge_xml_function_root_xml.c\n\n    # {{END_TARGET_SOURCES}})\n\n```\n\n----------------------------------------\n\nTITLE: Key Derivation Output Key Function Prototype (PSA)\nDESCRIPTION: This code snippet defines the function prototype for a key derivation driver's output key entry point when dealing with opaque keys. The function is responsible for deriving a key and writing the key material into the provided buffer. It takes key attributes, the derivation operation context, a buffer for the key, the buffer size, and a pointer to store the actual key length as parameters.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_17\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_key_derivation_output_key(\n    const psa_key_attributes_t *attributes,\n    acme_key_derivation_operation_t *operation,\n    uint8_t *key_buffer, size_t key_buffer_size, size_t *key_buffer_length);\n```\n\n----------------------------------------\n\nTITLE: Configure Application\nDESCRIPTION: Includes a configuration file ('config') and configures the application using the 'configApp' function, passing the executable name and root directory. This step likely involves setting compiler flags and other build options.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(config)\nconfigApp(arm_class_marks_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Enable FileX Standalone Mode\nDESCRIPTION: This snippet defines an option to enable FileX in standalone mode.  If enabled, certain dependencies are not required.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\noption(FX_STANDALONE_ENABLE \"Enable Filex in standalone mode\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Clean Examples matching TXM, GCC, Cortex M (PowerShell)\nDESCRIPTION: This command cleans all examples matching the keywords 'TXM', 'GCC', and 'Cortex M'. These examples are likely related to ThreadX Modules (TXM) for Cortex M using the GCC compiler. The pwsh -Command prefix allows the execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_13\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TXM','GCC','Cortex M' -clean\n```\n\n----------------------------------------\n\nTITLE: Sleeping a Thread with tm_thread_sleep in C\nDESCRIPTION: This function suspends the calling thread for the specified number of seconds.  It requires a timer or scheduling mechanism to wake the thread up after the specified duration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nvoid  tm_thread_sleep(int seconds);\n```\n\n----------------------------------------\n\nTITLE: Adding CMSIS-DSP as Subdirectory\nDESCRIPTION: This snippet adds the CMSIS-DSP source directory as a subdirectory to the project, creating a library target named bin_dsp.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_convolution_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Configure Application\nDESCRIPTION: This snippet includes a 'config' file and calls a 'configApp' function, likely to configure specific application settings based on the ROOT directory. It's likely a custom function defined elsewhere.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_bayes_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(config)\nconfigApp(arm_bayes_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Configure Library and DSP\nDESCRIPTION: Calls the configLib and configDsp macros/functions to configure the CMSISDSPComplexMath library using the specified root directory. This likely sets up include paths, compiler flags, etc.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nconfigLib(CMSISDSPComplexMath ${ROOT})\nconfigDsp(CMSISDSPComplexMath ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Create Executable\nDESCRIPTION: Creates the executable target 'arm_class_marks_example'. This defines the main application that will be built by CMake.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(arm_class_marks_example)\n```\n\n----------------------------------------\n\nTITLE: Example of Code Grouping in MBedTLS\nDESCRIPTION: This snippet illustrates the preferred style of grouping related statements together in MBedTLS by avoiding blank lines between them.  It shows a sequence of operations where the result of a function call is checked, and if successful, a pointer is incremented. This improves code readability by visually linking related operations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/tls13-support.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nret = ssl_tls13_write_client_hello_cipher_suites( ssl, buf, end, &output_len );\nif( ret != 0 )\n    return( ret );\nbuf += output_len;\n```\n\n----------------------------------------\n\nTITLE: Locating MbedTLS Package with find_package CMake\nDESCRIPTION: This snippet modifies `CMAKE_PREFIX_PATH` to include the Mbed TLS installation directory and then uses `find_package` to locate and load the Mbed TLS package. This step is essential for making Mbed TLS available for linking to other projects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_package_install/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nlist(INSERT CMAKE_PREFIX_PATH 0 \"${MbedTLS_INSTALL_DIR}\")\nfind_package(MbedTLS REQUIRED)\n```\n\n----------------------------------------\n\nTITLE: Linking Mbed TLS Libraries in CMake\nDESCRIPTION: This snippet demonstrates how to link the Mbed TLS libraries (mbedtls, mbedcrypto, mbedx509) to an executable target using `target_link_libraries`.  It utilizes the imported targets defined by the MbedTLS package.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_19\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(xyz)\n\ntarget_link_libraries(xyz\n    PUBLIC MbedTLS::mbedtls\n           MbedTLS::mbedcrypto\n           MbedTLS::mbedx509)\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Test Cases in CMake\nDESCRIPTION: This snippet defines a list of source files for HTTP (Hypertext Transfer Protocol) test cases using CMake's `set` command.  These tests likely cover various HTTP methods (GET, PUT, POST, DELETE, HEAD) and authentication schemes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nset(http_test_cases\n    ${SOURCE_DIR}/http_test/netx_http_get_put_referred_URI_test.c\n    ${SOURCE_DIR}/http_test/netx_http_if_modified_since_test.c\n    ${SOURCE_DIR}/http_test/netx_http_client_change_connect_port_test.c\n    ${SOURCE_DIR}/http_test/netx_http_post_basic_test.c\n    ${SOURCE_DIR}/http_test/netx_http_get_contentlength_packetleak_test.c\n    ${SOURCE_DIR}/http_test/netx_http_status_404_test.c\n    ${SOURCE_DIR}/http_test/netx_http_basic_test.c\n    ${SOURCE_DIR}/http_test/netx_http_basic_authenticate_test.c\n    ${SOURCE_DIR}/http_test/netx_http_get_content_length_test.c\n    ${SOURCE_DIR}/http_test/netx_http_request_in_multiple_packets_test.c\n    ${SOURCE_DIR}/http_test/netx_http_head_basic_test.c\n    ${SOURCE_DIR}/http_test/netx_http_delete_basic_test.c\n    ${SOURCE_DIR}/http_test/netx_http_multipart_fragment_test.c\n    ${SOURCE_DIR}/http_test/netx_http_multipart_underflow_test.c\n    ${SOURCE_DIR}/http_test/netx_http_digest_authenticate_test.c\n    ${SOURCE_DIR}/http_test/netx_http_server_type_retrieve_test.c\n    ${SOURCE_DIR}/http_test/netx_http_digest_authenticate_timeout_test.c)\n```\n\n----------------------------------------\n\nTITLE: FIQ Handler with Context Save/Restore - Assembly\nDESCRIPTION: This assembly code represents a basic FIQ handler, saving and restoring the system context using `_tx_thread_fiq_context_save` and `_tx_thread_fiq_context_restore` respectively. Application-specific FIQ handlers can be called between these calls.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac5/readme_threadx.txt#_snippet_4\n\nLANGUAGE: Assembly\nCODE:\n```\n    EXPORT  __tx_fiq_handler\n    EXPORT  __tx_fiq_processing_return\n__tx_fiq_handler\n;\n;    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return:\n;\n;    /* At this point execution is still in the FIQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use.  */\n;\n;    /* Application FIQ handlers can be called here!  */\n;\n;    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: Adding aliases for all targets.\nDESCRIPTION: Adds aliases to the target libraries.  This allows targets to be used as imported targets in other CMake projects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(target IN LISTS target_libraries)\n    add_library(MbedTLS::${target} ALIAS ${target})  # add_subdirectory support\n    # Include public header files from /include and other directories\n    # declared by /3rdparty/**/CMakeLists.txt. Include private header files\n    # from /library and others declared by /3rdparty/**/CMakeLists.txt.\n    # /library needs to be listed explicitly when building .c files outside\n\n```\n\n----------------------------------------\n\nTITLE: Set Target Sources\nDESCRIPTION: Specifies the source files for the 'arm_class_marks_example' executable. 'arm_class_marks_example_f32.c' is added as a private source file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(arm_class_marks_example PRIVATE arm_class_marks_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Add CMSIS-DSP Subdirectory\nDESCRIPTION: Adds the CMSIS-DSP source directory as a subdirectory to the project, creating a build target named 'bin_dsp'. This integrates the DSP library into the project's build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Define Test Utility Files\nDESCRIPTION: This snippet defines the source files for the test utility library. These utilities provide common functions and definitions used by the MQTT test cases.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/regression/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset(test_utility_files\n    ${SOURCE_DIR}/test/nx_ram_network_driver_test_1500.c\n    ${SOURCE_DIR}/mqtt_test/netx_mqtt_testcontrol.c)\n```\n\n----------------------------------------\n\nTITLE: Setting DPUMP Test Cases Variable in CMake\nDESCRIPTION: This snippet defines a CMake variable, `ux_dpump_test_cases`, and assigns it a single source file related to DPUMP tests.  This file is a C file to test the USBX DPUMP functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_dpump_test_cases ${SOURCE_DIR}/usbx_dpump_basic_test.c)\n```\n\n----------------------------------------\n\nTITLE: Creating an OSEK Event in C\nDESCRIPTION: This C code displays the CreateEvent function's signature. It creates an event, which is returned if successful. An absolute maximum of 32 events can be created per the OSEK specification.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_7\n\nLANGUAGE: C\nCODE:\n```\nEventMaskType CreateEvent(void);\n```\n\n----------------------------------------\n\nTITLE: Completing ECDSA Interruptible Verification in PSA\nDESCRIPTION: Completes an interruptible ECDSA signature verification operation using `psa_verify_hash_complete`. This function must be called repeatedly until it returns a status other than `PSA_OPERATION_INCOMPLETE`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_33\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t status = psa_verify_hash_complete(&operation);\n```\n\n----------------------------------------\n\nTITLE: Getting the Double Value of a JSON Token in C\nDESCRIPTION: Gets the JSON token's number as a `double`. It requires a pointer to the reader instance and a pointer to a variable to store the double value. On success, it returns NX_AZURE_IOT_SUCCESS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_token_double_get(NX_AZURE_IOT_JSON_READER *reader_ptr,\n                                               double *value_ptr);\n```\n\n----------------------------------------\n\nTITLE: Initializing JSON Reader with Packet in C\nDESCRIPTION: Initializes an NX_AZURE_IOT_JSON_READER to read a JSON payload contained within an NX_PACKET. It requires a pointer to the reader instance and a pointer to the NX_PACKET. On success, it returns NX_AZURE_IOT_SUCCESS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_init(NX_AZURE_IOT_JSON_READER *reader_ptr,\n                                   NX_PACKET *packet_ptr);\n```\n\n----------------------------------------\n\nTITLE: Set Directory Variable CMake\nDESCRIPTION: Sets the `CURRENT_DIR` variable to the path of the `common_smp` directory within the project. This variable is used to specify the location of source and include files related to ThreadX SMP.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/common_smp/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(CURRENT_DIR ${PROJECT_DIR}/common_smp)\n```\n\n----------------------------------------\n\nTITLE: Initialize CMSIS-DSP Interpolation project with CMake\nDESCRIPTION: This snippet initializes the CMake project for the CMSIS-DSP Interpolation library. It sets the minimum CMake version, defines the project name, and includes configuration files for the library and DSP functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/InterpolationFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n\nproject(CMSISDSPInterpolation)\n\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: CMake Add Subdirectories\nDESCRIPTION: Adds the threadx and filex directories as subdirectories to the project if LX_STANDALONE_ENABLE is not defined. This makes the libraries available for linking and use within the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/libs/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT LX_STANDALONE_ENABLE)\n    add_subdirectory(${externals}/threadx threadx)\nendif()\nadd_subdirectory(${externals}/filex filex)\n```\n\n----------------------------------------\n\nTITLE: Getting the Boolean Value of a JSON Token in C\nDESCRIPTION: Gets the boolean value of the current JSON token. It requires a pointer to the reader instance and a pointer to a variable to store the boolean value.  On success, it returns NX_AZURE_IOT_SUCCESS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_token_bool_get(NX_AZURE_IOT_JSON_READER *reader_ptr,\n                                             UINT *value_ptr);\n```\n\n----------------------------------------\n\nTITLE: CMake External Path\nDESCRIPTION: Gets the absolute path to the 'externals' directory which is assumed to be one level above the current source directory. This path is used to locate the external libraries (threadx and filex).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/libs/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(\n  externals ${CMAKE_CURRENT_SOURCE_DIR}/.. ABSOLUTE)\n```\n\n----------------------------------------\n\nTITLE: CMake Architecture Selection\nDESCRIPTION: Conditionally sets compiler and linker options for 32-bit or 64-bit architecture based on the environment variable ENABLE_64. The -m32 flag is used to compile and link for a 32-bit target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/libs/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif($ENV{ENABLE_64})\n  message(STATUS \"Building for 64bit\")\nelse()\n  add_compile_options(-m32)\n  add_link_options(-m32)\n  message(STATUS \"Building for 32bit\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories for PictBridge in CMake\nDESCRIPTION: This snippet uses the `target_include_directories` CMake command to add an include directory to the target ${PROJECT_NAME}.  The `PUBLIC` keyword makes this include directory available to other targets that link against ${PROJECT_NAME}. The directory being added is `${CMAKE_CURRENT_LIST_DIR}/inc`, which is expected to contain header files required for the PictBridge implementation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/usbx_pictbridge/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n\n```\n\n----------------------------------------\n\nTITLE: Including Azure RTOS Tests CMake\nDESCRIPTION: Conditionally includes the `azure_rtos_tests.cmake` file if tests are not disabled and the system is UNIX-based, likely for setting up and running tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nif((NOT DISABLE_TEST) AND UNIX)\n  # Include tests cmake\n  include(configs/azure_rtos_tests.cmake)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining and Running Tests with Bash Script (CMake)\nDESCRIPTION: This CMake code adds a test for each test case using the `add_test` command. The command executes a bash script that sets up a virtual network interface, captures network traffic with `tcpdump`, runs the test executable, and validates the exit code. Error handling is included to manage potential failures during the setup or execution phases.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/regression/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nadd_test(\n    NAME ${CMAKE_BUILD_TYPE}::${test_case}\n    COMMAND\n      bash -c\n      \"export PATH=${SOURCE_DIR}/test_scripts/:$PATH; \\\n       ip link del ${${test_case}_interface}>/dev/null 2>&1; \\\n       ip link add ${${test_case}_interface} type veth peer name ${${test_case}_remote_interface} || exit 1; \\\n       ifconfig ${${test_case}_interface} up || { ip link del ${${test_case}_interface}; exit 1; }; \\\n       ifconfig ${${test_case}_remote_interface} ${${test_case}_remote_ip} up netmask ${TEST_NETMASK} || { ip link del ${${test_case}_interface};exit 1; }; \\\n       ethtool --offload ${${test_case}_remote_interface} tx off || { ip link del ${${test_case}_interface}; exit 1; }; \\\n       tcpdump -i ${${test_case}_remote_interface} -s 0 -w ${CMAKE_CURRENT_BINARY_DIR}/${test_case}.pcap& \\\n       pid=$! \\\n       ${CMAKE_CURRENT_BINARY_DIR}/${test_case}; \\\n       exit_code=$?; \\\n       sleep 1; \\\n       kill -TERM $pid \\\n       [[ $exit_code = 0 ]] || [[ $exit_code = 233 ]] || { echo Exit code: $exit_code; exit $exit_code; };\"\n    WORKING_DIRECTORY ${SOURCE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Aborting ECDSA Interruptible Verification in PSA\nDESCRIPTION: Aborts an ongoing interruptible ECDSA signature verification operation, freeing any resources allocated. Use `psa_verify_hash_abort` to stop the operation if it is no longer needed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_35\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t status = psa_verify_hash_abort(&operation);\n```\n\n----------------------------------------\n\nTITLE: Integrating Azure Vcpkg\nDESCRIPTION: Integrates with the vcpkg package manager to manage dependencies.  It includes the `AzureVcpkg` module and then calls the `az_vcpkg_integrate()` function to set up vcpkg for the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(AzureVcpkg)\naz_vcpkg_integrate()\n```\n\n----------------------------------------\n\nTITLE: CPI Divider Configuration\nDESCRIPTION: This parameter sets the divider for calculating Cycles Per Instruction (CPI). It's an integer value that can be configured at run-time.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/ARMCM3_config.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.cpi_div=1                               # (int   , run-time ) default = '0x1'    : divider for calculating CPI (Cycles Per Instruction)\n```\n\n----------------------------------------\n\nTITLE: Initializing JSON Writer with Buffer\nDESCRIPTION: Initializes an Azure IoT JSON writer to write JSON data into a pre-allocated buffer. The function requires a pointer to the JSON writer instance, a pointer to the buffer, and the length of the buffer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_json_writer_with_buffer_init(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr,\n                                               UCHAR *buffer_ptr, UINT buffer_len);\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker File Modification\nDESCRIPTION: This snippet shows how to modify the EWARM linker file (.icf) to define a memory region for ThreadX dynamic memory allocation.  It places the FREE_MEM section in the RAM_region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Applications/ThreadX/Tx_Thread_Creation/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: This snippet sets the minimum required CMake version for the project. It ensures that the CMake version is at least 3.13 and generates a fatal error if it is not.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/libs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Configuration\nDESCRIPTION: This snippet sets the minimum required CMake version, project name, and programming languages. It ensures the project uses a compatible CMake version and sets a CMake policy.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/samples/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(samples LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: CPI Multiplier Configuration\nDESCRIPTION: This parameter sets the multiplier used for calculating the Cycles Per Instruction (CPI). It's an integer value that can be configured at runtime. Default value is '0x1'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/ARMCM0_config.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\narmcortexm0ct.cpi_mul=1\n```\n\n----------------------------------------\n\nTITLE: Add CMSISDSP as Subdirectory\nDESCRIPTION: This snippet adds the CMSISDSP source directory as a subdirectory to the project. The add_subdirectory command makes the CMSISDSP library available for linking with the main executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_bayes_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Define Source Files for Samples\nDESCRIPTION: This snippet defines the source directory and lists the sample C files to be compiled. The SOURCE_DIR variable points to the location of the sample source files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/samples/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../../ports_smp/linux/gnu/example_build)\n\nset(sample_files\n    ${SOURCE_DIR}/sample_threadx.c)\n```\n\n----------------------------------------\n\nTITLE: Setting C Standard\nDESCRIPTION: This snippet specifies the C standard to be used for compiling the project. It sets the C standard to C99, ensuring that the code is compiled according to the C99 standard.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/hub/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_C_STANDARD 99)\n```\n\n----------------------------------------\n\nTITLE: Adding CMSIS-NN Source Files with CMake\nDESCRIPTION: This CMake snippet uses the `file(GLOB)` command to find all C source files matching the pattern `./*_s8.c`. These files are then added to the `cmsis-nn` target as private sources using the `target_sources` command. This ensures that these files are compiled and linked into the `cmsis-nn` library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/ActivationFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SRC \"./*_s8.c\")\ntarget_sources(cmsis-nn PRIVATE ${SRC})\n```\n\n----------------------------------------\n\nTITLE: ES WiFi Module Driver for NetXDuo\nDESCRIPTION: This driver enables WiFi functionality using the es_wifi module within the NetXDuo environment on STM32. It handles the communication and data transfer between the STM32 and the es_wifi module.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/README.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n**es_wifi/nx_driver_ism43362.c**\n```\n\n----------------------------------------\n\nTITLE: Add DTLS Test Cases with Source Files (Conditional)\nDESCRIPTION: This snippet conditionally adds DTLS test cases if the `-DNX_SECURE_ENABLE_DTLS` flag is present in the CMAKE_BUILD_TYPE.  It demonstrates how to conditionally include tests based on build configurations. Similar to the TLS tests, it appends test cases to the nx_secure_test_cases list and sets the associated source files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/regression/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(\"-DNX_SECURE_ENABLE_DTLS\" IN_LIST ${CMAKE_BUILD_TYPE})\n  list(APPEND nx_secure_test_cases demo_dtls_test)\n  set(demo_dtls_test_file_list ${SOURCE_DIR}/demo_dtls_test.c\n                               ${SOURCE_DIR}/demo_dtls_test_server.c)\n\n  list(APPEND nx_secure_test_cases\n       dtls_openssl_echo_server_nx_secure_echo_client_test)\n  set(dtls_openssl_echo_server_nx_secure_echo_client_test_file_list\n      ${SOURCE_DIR}/dtls_openssl_echo_server_entry.c\n      ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_test.c\n      ${SOURCE_DIR}/nx_secure_dtls_echo_client_entry.c)\n\n  list(APPEND nx_secure_test_cases\n       dtls_reuse_nx_secure_server_openssl_client_test)\n  set(dtls_reuse_nx_secure_server_openssl_client_test_file_list\n      ${SOURCE_DIR}/dtls_two_instance_test.c\n      ${SOURCE_DIR}/dtls_reuse_nx_secure_server_entry.c\n      ${SOURCE_DIR}/dtls_reuse_openssl_client_entry.c)\n\n  list(APPEND nx_secure_test_cases dtls_rsa_aes128_sha_ciphersuite_test)\n  set(dtls_rsa_aes128_sha_ciphersuite_test_file_list\n      ${SOURCE_DIR}/dtls_two_instance_test.c\n      ${SOURCE_DIR}/dtls_nx_secure_server_entry.c\n      ${SOURCE_DIR}/dtls_rsa_aes128_sha_openssl_client_entry.c)\n\n  list(APPEND nx_secure_test_cases dtls_rsa_aes256_sha_ciphersuite_test)\n  set(dtls_rsa_aes256_sha_ciphersuite_test_file_list\n      ${SOURCE_DIR}/dtls_two_instance_test.c\n      ${SOURCE_DIR}/dtls_nx_secure_server_entry.c\n      ${SOURCE_DIR}/dtls_rsa_aes256_sha_openssl_client_entry.c)\n\n  list(APPEND nx_secure_test_cases dtls_rsa_aes128_gcm_ciphersuite_test)\n  set(dtls_rsa_aes128_gcm_ciphersuite_test_file_list\n      ${SOURCE_DIR}/dtls_two_instance_test.c\n      ${SOURCE_DIR}/dtls_nx_secure_server_entry.c\n      ${SOURCE_DIR}/dtls_rsa_aes128_gcm_openssl_client_entry.c)\n\n  list(APPEND nx_secure_test_cases dtls_rsa_aes128_gcm_ciphersuite_client_test)\n  set(dtls_rsa_aes128_gcm_ciphersuite_client_test_file_list\n      ${SOURCE_DIR}/dtls_two_instance_test.c\n      ${SOURCE_DIR}/dtls_openssl_server_entry.c\n      ${SOURCE_DIR}/dtls_aes128_gcm_nx_secure_client_entry.c)\n\n  list(APPEND nx_secure_test_cases dtls_client_certificate_verify_client_test)\n  set(dtls_client_certificate_verify_client_test_file_list\n      ${SOURCE_DIR}/openssl_echo_server_nx_secure_echo_client_test.c\n      ${SOURCE_DIR}/dtls_openssl_client_certificate_verify_test_server_entry.c\n      ${SOURCE_DIR}/dtls_nx_secure_client_certificate_verify_test_client_entry.c\n  )\n\n  list(APPEND nx_secure_test_cases dtls_client_certificate_verify_server_test)\n  set(dtls_client_certificate_verify_server_test_file_list\n      ${SOURCE_DIR}/dtls_two_instance_test.c\n      ${SOURCE_DIR}/dtls_openssl_client_certificate_verify_test_client_entry.c\n      ${SOURCE_DIR}/dtls_nx_secure_client_certificate_verify_test_server_entry.c\n  )\n\n  list(APPEND nx_secure_test_cases dtls_version_1_0_server_test)\n  set(dtls_version_1_0_server_test_file_list\n      ${SOURCE_DIR}/dtls_two_instance_test.c\n      ${SOURCE_DIR}/dtls_version_1_0_openssl_client_entry.c\n      ${SOURCE_DIR}/dtls_nx_secure_server_entry.c)\n\n  list(APPEND nx_secure_test_cases dtls_version_1_0_client_test)\n  set(dtls_version_1_0_client_test_file_list\n```\n\n----------------------------------------\n\nTITLE: Creating CMSISDSP Library Interface\nDESCRIPTION: This code snippet creates an interface library named CMSISDSP. Interface libraries are used to propagate usage requirements, like include directories and compile definitions, to dependent targets without producing any output files themselves.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_24\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(CMSISDSP INTERFACE)\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources in CMake\nDESCRIPTION: This CMake snippet uses `target_sources` to configure the private source files for the project. The `${PROJECT_NAME}` variable refers to the project's name, and the `PRIVATE` keyword specifies that these sources are only used within the project itself.  The section between `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` is likely where the list of source files would be added.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m3/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Adding SVM Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the SVMFunctions subdirectory and links the CMSISDSPSVM library to the CMSISDSP interface library if the SVM flag is set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_36\n\nLANGUAGE: cmake\nCODE:\n```\nif (SVM)\n  add_subdirectory(SVMFunctions)\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPSVM)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Add Compile Options\nDESCRIPTION: Adds compile options for the project, including architecture, C standard, debugging information, diagnostics color, and error reporting.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_compile_options(\n  -m32\n  -std=c99\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  -Werror\n  ${${CMAKE_BUILD_TYPE}})\n```\n\n----------------------------------------\n\nTITLE: Set Custom Include Directory\nDESCRIPTION: This snippet sets the CUSTOM_INC_DIR variable to the binary directory where generated or copied include files are placed. This simplifies the management of include directories.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\n# A place for generated/copied include files (no need to change)\nset(CUSTOM_INC_DIR ${CMAKE_CURRENT_BINARY_DIR}/custom_inc)\n```\n\n----------------------------------------\n\nTITLE: Install Everest Headers in CMake\nDESCRIPTION: This snippet installs the Everest headers to the specified include directory during the installation process.  It uses the `install` command with the `DIRECTORY` option to copy the header files, and sets permissions for the installed files and directories.  The installation is conditional on the `INSTALL_MBEDTLS_HEADERS` variable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/everest/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif(INSTALL_MBEDTLS_HEADERS)\n\n  install(DIRECTORY include/everest\n    DESTINATION include\n    FILE_PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ\n    DIRECTORY_PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE\n    FILES_MATCHING PATTERN \"*.h\")\n\nendif(INSTALL_MBEDTLS_HEADERS)\n```\n\n----------------------------------------\n\nTITLE: Adding CMSIS-DSP as a Subdirectory\nDESCRIPTION: This snippet adds the CMSIS-DSP source code as a subdirectory to the project, allowing the DSP library to be built as part of the project build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_linear_interp_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Add CMSIS-DSP Module Path\nDESCRIPTION: This snippet adds the CMSIS-DSP folder to the CMake module path, allowing CMake to find modules and configuration files within that directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\n# Add DSP folder to module path\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: Link CMSISDSP Library\nDESCRIPTION: This snippet links the CMSISDSP library to the `arm_graphic_equalizer_example` executable. This allows the application to use functions from the CMSIS-DSP library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(arm_graphic_equalizer_example PRIVATE CMSISDSP)\n```\n\n----------------------------------------\n\nTITLE: CMake Minimum Version\nDESCRIPTION: Specifies the minimum required CMake version for the project. This ensures that the CMake version used to build the project is compatible with the CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: Coverage Configuration for USBX\nDESCRIPTION: This snippet enables code coverage for USBX by adding compile and link options if the CMAKE_BUILD_TYPE matches a 'coverage' build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\n# Coverage\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(usbx PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(usbx PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining ThreadX Source Files with CMake\nDESCRIPTION: This snippet uses the `target_sources` CMake command to specify a list of C and assembly source files that will be compiled and linked into the target specified by `${PROJECT_NAME}`. The `PRIVATE` keyword indicates that these source files are only used by this target and not exposed to other targets. The source files are located within the `src` subdirectory of the current list directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_allocate.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/txe_thread_secure_stack_free.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_low_level.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_allocate.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_secure_stack_free.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories in CMake\nDESCRIPTION: This snippet adds an include directory to the project using the `target_include_directories` command. The `${CMAKE_CURRENT_LIST_DIR}/inc` path specifies the location of the header files to be included during compilation. This allows the project to find and use the necessary header files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/ports/cortex_m7/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Programs Subdirectory CMake\nDESCRIPTION: This snippet conditionally adds the `programs` subdirectory to the build, enabling the inclusion of example programs or utilities that are part of the MbedTLS project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_25\n\nLANGUAGE: CMake\nCODE:\n```\nif(ENABLE_PROGRAMS)\n    add_subdirectory(programs)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building executables from lists (CMake)\nDESCRIPTION: Iterates through the `executables_libs` and `executables_mbedcrypto` lists and creates an executable for each item.  It sets include directories, C standard version, and links against the appropriate libraries. Specific adjustments are made for `query_compile_time_config` executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(exe IN LISTS executables_libs executables_mbedcrypto)\n    set(extra_sources \"\")\n    if(exe STREQUAL \"query_compile_time_config\")\n        list(APPEND extra_sources\n            ${CMAKE_CURRENT_SOURCE_DIR}/query_config.h\n            ${CMAKE_CURRENT_BINARY_DIR}/query_config.c)\n    endif()\n    add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>\n        ${extra_sources})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../library)\n    if(exe STREQUAL \"query_compile_time_config\")\n        target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})\n    endif()\n\n    # Request C11, required for memory poisoning\n    set_target_properties(${exe} PROPERTIES C_STANDARD 11)\n\n    # This emulates \"if ( ... IN_LIST ... )\" which becomes available in CMake 3.3\n    list(FIND executables_libs ${exe} exe_index)\n    if (${exe_index} GREATER -1)\n        target_link_libraries(${exe} ${libs} ${CMAKE_THREAD_LIBS_INIT})\n    else()\n        target_link_libraries(${exe} ${mbedcrypto_target} ${CMAKE_THREAD_LIBS_INIT})\n    endif()\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Define PPP Test Cases\nDESCRIPTION: This CMake snippet defines `ppp_test_cases`, a variable containing a list of C source files that implement tests for the NetX PPP (Point-to-Point Protocol) functionality.  The tests cover various aspects of PPP, including PAP and CHAP authentication, IPCP configuration, LCP management, and option negotiation (PFC, ACFC).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_18\n\nLANGUAGE: CMake\nCODE:\n```\nset(ppp_test_cases\n    ${SOURCE_DIR}/ppp_test/netx_ppp_PAP_bad_password_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_check_boundary_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_IPCP_timeout.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_request_dns_server_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_chap_bad_secret_passed_on_retry_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_chap_bad_secret_failed_retry_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_LCP_timeout.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_PAP_bad_username_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_pap_null_name_password_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_LCP_invalid_packet_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_IPCP_abnormal_packet_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_IPCP_nak_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_IPCP_retransmit_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_pap_basic_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_pfc_option_test.c\n    ${SOURCE_DIR}/ppp_test/netx_ppp_acfc_option_test.c)\n\n```\n\n----------------------------------------\n\nTITLE: Setting build configurations based on feature flags CMake\nDESCRIPTION: This snippet sets various build configurations based on feature flags such as IPv4/IPv6 support, security, and specific networking features. Each `set` command defines a variable containing a list of flags to be used for a specific build configuration. This allows different versions of NetXDuo to be built with specific features enabled or disabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(v4_dual_pool_build ${IPV4} ${DUAL_POOL})\nset(v4_no_chain_build ${IPV4} ${NO_CHAIN} ${MDNS_NO_SERVER})\nset(v4_link_cap_build ${IPV4} ${LINK_CAP} ${RX_INTERFACE_CAPABILITY}\n                      ${MULTI_INTERFACE} ${TCPIP_OFFLOAD})\nset(v4_address_check_build ${IPV4} ${ADDRESS_CHECK})\nset(v6_build ${IPV6})\nset(v6_only_build ${IPV6} ${NO_IPV4} ${TRACE} ${MDNS_NO_CLIENT})\nset(v6_only_link_cap_build ${IPV6} ${NO_IPV4} ${LINK_CAP})\nset(v6_no_checksum_build ${IPV6} ${DISABLE_TX_CHECKSUM} ${DISABLE_RX_CHECKSUM})\nset(v6_dual_pool_build ${IPV6} ${DUAL_POOL})\nset(v6_packet_pad_build ${IPV6} ${PACKET_PAD})\nset(v6_physical_48_build ${IPV6} ${PHY_HEADER} ${MDNS_NO_SERVER} ${PPPOE} ${PPPOE_CONTROL})\nset(v6_small_nd_cache_build ${IPV6} ${MULTI_INTERFACE} ${ND_CACHE_LIMIT}\n                            ${NO_PURGE_UNUSED_CACHE} ${LARGE_DEST_TABLE})\nset(v6_small_build\n    ${IPV6}\n    ${NO_INFO}\n    ${NO_FRAG}\n    ${NO_DAD}\n    ${NO_CHECK}\n    ${NO_ICMPV6_ERROR}\n    ${NO_RESET_DISCONNECT}\n    ${NO_REDIRECT_PROCESS}\n    ${NO_RA_PROCESS}\n    ${NO_RS}\n    ${NO_PURGE_UNUSED_CACHE}\n    ${IMME_ACK}\n    ${NO_LOOPBACK}\n    ${NO_RX_SIZE_CHECK}\n    ${PACKET_ALIGNMENT}\n    ${PREFIX_LIMIT}\n    ${MDNS_NO_SERVER}\n    ${RAND_ID})\nset(v6_full_build\n    ${IPV6}\n    ${IPV6_PMTU_DISCOVERY}\n    ${TCP_KEEPALIVE}\n    ${TCP_KEEPALIVE_INITIAL}\n    ${TCP_KEEPALIVE_RETRY}\n    ${TCP_KEEPALIVE_RETRIES}\n    ${TCP_WINDOW}\n    ${IP_STATIC_ROUTING}\n    ${TAHI}\n    ${BSD}\n    ${MULTI_INTERFACE}\n    ${STATELESS_AC}\n    ${IMME_FRAG_ASSEMBLY}\n    ${MSS_CHECK}\n    ${TCP_QUEUE_NOTIFY}\n    ${RAW_FILTER}\n    ${RAW_ALL_STACK}\n    ${ADDRESS_CHANGE_NOTIFY}\n    ${MULTIPART}\n    ${NAT}\n    ${PACKET_DEBUG}\n    ${DUAL_POOL}\n    ${IP_PACKET_FILTER}\n    ${DHCP_ARP_PROBE}\n    ${MDNS_IPV6}\n    ${HTTP_DIGEST}\n    ${DHCP_RESTORE}\n    ${DNS_CACHE}\n    ${TCPIP_OFFLOAD}\n    ${ARP}\n    ${HTTP_PROXY}\n    ${PPP_COMPRESSION})\nset(v6_full_secure_build\n    ${v6_full_build}\n    -DNX_SECURE_ENABLE)\nset(v6_no_frag_build ${IPV6} ${NO_FRAG})\nset(v6_pmtu_no_frag_build ${v6_no_frag_build} ${IPV6_PMTU_DISCOVERY})\nset(v6_no_chain_build ${IPV6} ${NO_CHAIN} ${MDNS_NO_CLIENT})\nset(v6_no_dad_build ${IPV6} ${NO_DAD})\nset(v6_no_check_build ${IPV6} ${NO_CHECK} ${TAHI} ${IPV6_PMTU_DISCOVERY})\nset(v6_no_icmpv6_error_build ${IPV6} ${NO_ICMPV6_ERROR})\nset(v6_no_reset_disconn_build ${IPV6} ${NO_RESET_DISCONNECT} ${TAHI}\n                              ${IPV6_PMTU_DISCOVERY})\nset(v6_link_cap_build ${IPV6} ${LINK_CAP} ${TX_RX_INTERFACE_CAPABILITY}\n                      ${MULTI_INTERFACE})\nset(v6_address_change_build ${IPV6} ${ADDRESS_CHANGE_NOTIFY} ${MDNS_NO_SERVER})\nset(v6_multicast_build ${IPV6} ${MULTICAST} ${MULTI_INTERFACE})\nset(v6_no_rs_build ${IPV6} ${STATELESS_AC} ${NO_RS})\nset(v6_dhcp_tahi_build ${IPV6} ${ADDRESS_CHANGE_NOTIFY} ${DHCPV6_TAHI} ${TAHI}\n                       ${IPV6_PMTU_DISCOVERY})\nset(v6_bsd_raw_build ${IPV6} ${BSD_RAW} ${MULTI_INTERFACE} ${RAW_ALL_STACK})\nset(default_build_coverage -DNX_TAHI_ENABLE -DNX_MAX_PHYSICAL_INTERFACES=4 -DNX_ENABLE_IPV6_PATH_MTU_DISCOVERY)\nset(optimize_build ${default_build_coverage} -O3)\nset(dhcp_default_build_coverage ${default_build_coverage} -DNX_DHCP_CLIENT_USER_CREATE_PACKET_POOL -DNX_DISABLE_ASSERT)\nset(dns_default_build_coverage ${default_build_coverage}  -DNX_DNS_CLIENT_USER_CREATE_PACKET_POOL -DNX_DNS_CLIENT_CLEAR_QUEUE)\nset(tsn_build_coverage ${default_build_coverage} ${PHY_HEADER} -DNX_ENABLE_VLAN)\n```\n\n----------------------------------------\n\nTITLE: Linker Switches for ThreadX Demo\nDESCRIPTION: These linker switches define the output file name, generate a map file, specify the target architecture, and specify the loader control file used for linking the ThreadX demonstration system.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/gnu/readme_threadx.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n-o sample_threadx.out     Specifies output file\n-M > sample_threadx.map   Specifies demo map file\n-A cortex-a7            Specifies target architecture\n-T sample_threadx.ld      Specifies the loader control file\n```\n\n----------------------------------------\n\nTITLE: Cloning Azure SDK for C Repo\nDESCRIPTION: Clones the Azure SDK for C repository from GitHub, optionally checking out a specific tag for a particular version. This command is used to obtain the source code of the SDK for building and integration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/Azure/azure-sdk-for-c\ngit checkout <tag_name>\n```\n\n----------------------------------------\n\nTITLE: Adding C source files to a CMake target\nDESCRIPTION: This CMake snippet uses the file(GLOB) command to find all C source files matching the pattern './*_*.c' and stores them in the SRC variable. It then uses the target_sources command to add these source files to the 'cmsis-nn' target as private sources. This means these sources are only used for building the 'cmsis-nn' target and are not exposed to other targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/BasicMathFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SRC \"./*_*.c\")\ntarget_sources(cmsis-nn PRIVATE ${SRC})\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This CMake code snippet configures the target sources for the project. It defines the private source files that will be used to build the project. The `target_sources` command associates these source files with the specified project name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m0/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Adding IoT Samples\nDESCRIPTION: Conditionally adds the IoT samples subdirectory. If the environment variable `AZ_SDK_C_NO_SAMPLES` is not defined and the `TRANSPORT_PAHO` option is enabled, the `sdk/samples/iot` subdirectory is added, which contains example code using Paho MQTT.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT DEFINED ENV{AZ_SDK_C_NO_SAMPLES})\n  if(TRANSPORT_PAHO)\n    add_subdirectory(sdk/samples/iot)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting PTP Test Cases (NetXDuo)\nDESCRIPTION: Defines a set of PTP (Precision Time Protocol) test cases for NetXDuo. These tests are likely focused on validating the implementation of PTP client functionality within NetXDuo, including IPv6 support, master selection, and two-step offset calculation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_21\n\nLANGUAGE: CMake\nCODE:\n```\nset(ptp_test_cases\n          ${SOURCE_DIR}/ptp_test/netx_ptp_client_ipv6_test.c\n        ${SOURCE_DIR}/ptp_test/netx_ptp_client_master_selection_test.c\n        ${SOURCE_DIR}/ptp_test/netx_ptp_client_two_steps_off_test.c)\n```\n\n----------------------------------------\n\nTITLE: Configuring Tamper Protection in OEMiROT_Boot (C)\nDESCRIPTION: This code snippet demonstrates how to configure the anti-tamper feature in the OEMiROT_Boot application.  It shows the different levels of tamper protection that can be enabled (NO_TAMPER, INTERNAL_TAMPER_ONLY, ALL_TAMPER) and defines the OEMIROT_TAMPER_ENABLE macro to select the desired configuration. Changing OEMIROT_TAMPER_ENABLE to ALL_TAMPER requires specific hardware connections for the tamper pins to function correctly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ROT/OEMiROT_Boot/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#define NO_TAMPER            (0)                   /*!< No tamper activated */\n#define INTERNAL_TAMPER_ONLY (1)                   /*!< Only Internal tamper activated */\n#define ALL_TAMPER           (2)                   /*!< Internal and External tamper activated */\n#define OEMIROT_TAMPER_ENABLE INTERNAL_TAMPER_ONLY /*!< TAMPER configuration flag  */\n```\n\n----------------------------------------\n\nTITLE: Creating a Category 2 ISR in C\nDESCRIPTION: This code snippet demonstrates how to create a category 2 ISR during system initialization using the CreateISR function. It takes the ISR name, entry function, category, and stack size as parameters. The DemoISR variable from the previous example is assigned the result of CreateISR.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nDemoISR = CreateISR(\"Demo ISR\", ISREntry(DemoISR), CATEGORY2, 1024);\n```\n\n----------------------------------------\n\nTITLE: Getting Maximum Operations for Interruptible Operations in PSA\nDESCRIPTION: Retrieves the current maximum number of basic operations allowed per call to `psa_sign_hash_complete` or `psa_verify_hash_complete` using `psa_interruptible_get_max_ops`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_37\n\nLANGUAGE: C\nCODE:\n```\nsize_t max_ops = psa_interruptible_get_max_ops();\n```\n\n----------------------------------------\n\nTITLE: Including Test Subdirectory in CMake\nDESCRIPTION: This command includes the 'test' subdirectory in the CMake build process. It enables the compilation and linking of the testing framework module as part of the overall project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(test)\n```\n\n----------------------------------------\n\nTITLE: Conditional Target Sources (arm_cmplx_mag_q15.c)\nDESCRIPTION: Conditionally includes the arm_cmplx_mag_q15.c source file based on similar conditions as arm_cmplx_mag_q31.c.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_CMPLX_MAG_Q15 OR (NOT HELIUM AND NOT MVEI))\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_q15.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Cypress WHD WiFi Driver for NetXDuo\nDESCRIPTION: This driver provides support for Cypress WiFi modules within the NetXDuo middleware on STM32. It likely uses SPI or SDIO for communication with the WiFi module.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n**cypress/nx_stm32_cypress_whd_driver.c**\n```\n\n----------------------------------------\n\nTITLE: Creating Code Coverage Targets\nDESCRIPTION: Invokes the `create_code_coverage_targets` macro for each of the Azure IoT libraries (ADU, Common, Hub, and Provisioning).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/iot/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\ncreate_code_coverage_targets(az_iot_adu)\ncreate_code_coverage_targets(az_iot_common)\ncreate_code_coverage_targets(az_iot_hub)\ncreate_code_coverage_targets(az_iot_provisioning)\n```\n\n----------------------------------------\n\nTITLE: Append Begin Object Azure IoT JSON Writer C\nDESCRIPTION: Appends the beginning of a JSON object ('{') to the payload.  Requires a pointer to the JSON writer. Returns NX_AZURE_IOT_SUCCESS if the object start is appended successfully.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_27\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_begin_object(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr);\n```\n\n----------------------------------------\n\nTITLE: Project definition with C language\nDESCRIPTION: Defines the project name and specifies that the project primarily uses the C programming language.  This is a fundamental step in setting up the CMake project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/libs/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(libs LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Setting Build Configurations\nDESCRIPTION: This snippet sets the build configurations for the project, using the name `default_build_coverage`. It's used later for specific build operations or conditional compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo64/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(BUILD_CONFIGURATIONS default_build_coverage)\n```\n\n----------------------------------------\n\nTITLE: Defining Project Properties\nDESCRIPTION: Defines the project name, version, and supported languages (C and Assembly).  The project name is set to 'threadx_smp' with a version of 6.0.0.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(threadx_smp\n    VERSION 6.0.0 \n    LANGUAGES C ASM\n)\n```\n\n----------------------------------------\n\nTITLE: Conditional Library Building (Static vs. Shared)\nDESCRIPTION: This snippet checks the environment variable USBX_STATIC to determine whether to build USBX as a static or shared library. It also includes code coverage flags if building static libraries and the build type includes \"_coverage\".\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\n# Control if USBX is static or shared\nif($ENV{USBX_STATIC})\n  message(STATUS \"Building STATIC usbx\")\n  set(BUILD_SHARED_LIBS OFF)\nelse()\n  message(STATUS \"Building usbx BUILD_SHARED_LIBS: ${BUILD_SHARED_LIBS}\")\nendif()\nif(NOT BUILD_SHARED_LIBS)\n  if(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n    add_link_options(-fprofile-arcs)\n    add_link_options(-lgcov)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Initialize Ethernet Interface in C\nDESCRIPTION: This code snippet initializes the Ethernet interface (ETH) with a predefined MAC address. The heth.Instance is set to ETH, and the MAC address bytes are assigned. This ensures the STM32 device can communicate on the network using the specified MAC address.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_TCP_Echo_Server/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid MX_ETH_Init(void)\n{\n\n  /* USER CODE BEGIN ETH_Init 0 */\n\n  /* USER CODE END ETH_Init 0 */\n\n  /* USER CODE BEGIN ETH_Init 1 */\n\n  /* USER CODE END ETH_Init 1 */\n  heth.Instance = ETH;\n  heth.Init.MACAddr[0] =   0x00;\n  heth.Init.MACAddr[1] =   0x80;\n  heth.Init.MACAddr[2] =   0xE1;\n  heth.Init.MACAddr[3] =   0x00;\n  heth.Init.MACAddr[4] =   0x00;\n  heth.Init.MACAddr[5] =   0x00;\n```\n\n----------------------------------------\n\nTITLE: Additional Parameters\nDESCRIPTION: Optional key-value pairs of parameters to pass to the ARM template(s) and pre-post scripts. These parameters offer a way to configure both the ARM template deployment and related scripts, offering comprehensive customization.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nType: Hashtable\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: None\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Define Source Directory\nDESCRIPTION: This snippet defines the source directory where the regression test files are located, using the CMAKE_CURRENT_LIST_DIR variable to construct an absolute path.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../regression)\n```\n\n----------------------------------------\n\nTITLE: Adding Link Options\nDESCRIPTION: Adds linker options to the project, specifically targeting the 32-bit architecture. This ensures the correct linking behavior for the target environment.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_link_options(-m32)\n```\n\n----------------------------------------\n\nTITLE: Setting Coverage Exclusion\nDESCRIPTION: Sets coverage exclusion paths for the `az_core` library to prevent coverage metrics from showing up outside of the `iot` context.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/iot/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nset(COV_EXCLUDE\n  ${az_SOURCE_DIR}/sdk/inc/azure/core/*\n  ${az_SOURCE_DIR}/sdk/inc/azure/core/internal/*)\n```\n\n----------------------------------------\n\nTITLE: Installing Python Requirements\nDESCRIPTION: Installs the required Python modules for the ROT_AppliConfig tool using pip. This is necessary if switching to the Python version of the ROT_AppliConfig tool.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ROT/OEMiROT_Appli_TrustZone/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Deinitializing Azure IoT Provisioning Client in C\nDESCRIPTION: De-initializes the Azure IoT Provisioning client instance. It requires a pointer to the provisioning client. The function returns a status code indicating success or failure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_provisioning_client.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_provisioning_client_deinitialize(NX_AZURE_IOT_PROVISIONING_CLIENT *prov_client_ptr);\n```\n\n----------------------------------------\n\nTITLE: Skipping Children in JSON Reader in C\nDESCRIPTION: Reads and skips over any nested JSON elements. It requires a pointer to the reader instance. On success, it returns NX_AZURE_IOT_SUCCESS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_skip_children(NX_AZURE_IOT_JSON_READER *reader_ptr);\n```\n\n----------------------------------------\n\nTITLE: Create Symbolic Links for Testing CMake\nDESCRIPTION: This snippet creates symbolic links to the source directory for mbedtls and psa, used when testing is enabled and the binary and source directories are different. This makes mbedtls_config.h available in an out-of-source build, as required by ssl-opt.sh. It relies on a `link_to_source` function being defined elsewhere.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/include/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif (ENABLE_TESTING AND NOT ${CMAKE_CURRENT_BINARY_DIR} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR})\n    link_to_source(mbedtls)\n    link_to_source(psa)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Build Configurations\nDESCRIPTION: This snippet sets the build configuration to 'v6_full_build'. This configuration can be used to define specific build settings or flags for the project during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo_fast/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(BUILD_CONFIGURATIONS v6_full_build)\n```\n\n----------------------------------------\n\nTITLE: Conditional MDNS Test Cases in CMake\nDESCRIPTION: This snippet conditionally defines a list of source files for MDNS (Multicast DNS) test cases using CMake. The `if(PRODUCT STREQUAL netxduo)` block ensures these tests are only included when the product is NetX Duo. The nested `if(NOT \"-DNX_DISABLE_IPV4\" IN_LIST ${CMAKE_BUILD_TYPE})` conditionally appends a test case based on whether IPv4 is disabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nif(PRODUCT STREQUAL netxduo)\n  set(mdns_test_cases\n      ${SOURCE_DIR}/mdns_test/netx_mdns_announcement_repeat_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_bad_packet_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_buffer_size_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_create_delete_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_domain_name_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_interface_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_second_interface_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_internal_function_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_local_cache_continuous_query_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_local_cache_one_shot_query_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_multiple_answers_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_name_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_one_shot_query_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_responder_cooperating_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_response_with_question_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_service_add_delete_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_service_lookup_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_source_address_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_source_port_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_ttl_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_two_buffer_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_txt_notation_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_txt_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_peer_service_change_notify_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_ipv6_string_test.c\n      ${SOURCE_DIR}/mdns_test/netx_mdns_read_overflow_test.c)\n  if(NOT \"-DNX_DISABLE_IPV4\" IN_LIST ${CMAKE_BUILD_TYPE})\n    list(APPEND mdns_test_cases ${SOURCE_DIR}/mdns_test/netx_mdns_ram_test.c)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Including CMake Modules\nDESCRIPTION: Includes several CMake modules that provide additional functionality. `global_compile_options.cmake` likely sets global compiler options, and `create_map_file` probably creates a map file for debugging purposes. `CreateCodeCoverageTargets` configures code coverage targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(eng/cmake/global_compile_options.cmake)\ninclude(create_map_file)\n\n# Include function for creating code coverage targets\ninclude(CreateCodeCoverageTargets)\n```\n\n----------------------------------------\n\nTITLE: Install Executables to the bin Directory (CMake)\nDESCRIPTION: This snippet installs the generated executables to the \"bin\" directory with specified permissions: owner read/write/execute, group read/execute, and world read/execute.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/random/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(TARGETS ${executables}\n        DESTINATION \"bin\"\n        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup and Policy Settings\nDESCRIPTION: This snippet sets the minimum required CMake version, defines the project name, and sets several CMake policies for compatibility and behavior. It ensures consistent behavior across different CMake versions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\ncmake_policy(SET CMP0077 NEW)\n\nproject(usbx_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Setting Target Sources\nDESCRIPTION: Specifies the source files for the executable target. Defines which source files are compiled and linked into the executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_variance_example/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(arm_variance_example PRIVATE arm_variance_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: ThreadX Low-Level Initialization (Assembly)\nDESCRIPTION: The tx_initialize_low_level.S file is responsible for setting up system data structures, the vector area, and a periodic timer interrupt source. It also determines the first available address for application use, passed to tx_application_define.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/gnu/readme_threadx.txt#_snippet_2\n\nLANGUAGE: Assembly\nCODE:\n```\ntx_initialize_low_level.S\n```\n\n----------------------------------------\n\nTITLE: Specify Source Files\nDESCRIPTION: This snippet specifies the source files to be included in the `arm_graphic_equalizer_example` executable.  These sources contain the application's logic and data.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(arm_graphic_equalizer_example PRIVATE math_helper.c arm_graphic_equalizer_data.c arm_graphic_equalizer_example_q31.c)\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files to Target using CMake\nDESCRIPTION: This snippet uses CMake commands to find source files matching the pattern '*_s8.c' and adds them to the 'cmsis-nn' target. It uses the GLOB command to locate the files and target_sources to link them as private sources, along with the 'arm_fully_connected_s16.c' file, ensuring that only the target has access to these sources during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/FullyConnectedFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SRC \"./*_s8.c\")\ntarget_sources(cmsis-nn PRIVATE ${SRC} arm_fully_connected_s16.c)\n```\n\n----------------------------------------\n\nTITLE: Minimum Synchronization Level Configuration\nDESCRIPTION: This parameter forces a minimum synchronization level for debugging. Synchronization levels control the granularity of data synchronization between the target and the debugger. Higher levels provide more detailed synchronization at the cost of performance, while lower levels improve performance but reduce synchronization accuracy.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/ARMCM3_config.txt#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.min_sync_level=3\n```\n\n----------------------------------------\n\nTITLE: Defining Image TLV Magic Numbers\nDESCRIPTION: These definitions specify the magic numbers for the image TLV (Type-Length-Value) info header and protected TLV info header. These magic numbers help identify the presence and type of TLV data associated with the image.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#define IMAGE_TLV_INFO_MAGIC        0x6907\n#define IMAGE_TLV_PROT_INFO_MAGIC   0x6908\n```\n\n----------------------------------------\n\nTITLE: Adding Link Options for Linux\nDESCRIPTION: Adds linker options specifically for the Linux platform, including flags for code coverage.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(THREADX_ARCH STREQUAL \"linux\")\n  add_link_options(-m32 -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configure Target Sources with CMake\nDESCRIPTION: This CMake snippet configures the target sources for the project.  It uses the `target_sources` command to specify the source files to be included in the build process. The source files are expected to be listed between the `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` markers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/ports/cortex_m3/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Mock Testing Compiler Check\nDESCRIPTION: Checks compiler compatibility when `UNIT_TESTING_MOCKS` is enabled. It issues a fatal error if `UNIT_TESTING_MOCKS` is used with a compiler other than GNU GCC.  It also issues a warning if `UNIT_TESTING_MOCKS` is enabled but `UNIT_TESTING` is not.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\nif(UNIT_TESTING_MOCKS)\n  if(UNIT_TESTING)\n    if(NOT CMAKE_C_COMPILER_ID MATCHES \"GNU\")\n      # Fail generation when asking for MOCK without GCC\n      message(FATAL_ERROR \"Unsupported Compiler Option.\\nOption `UNIT_TESTING_MOCKS` is not supported on ${CMAKE_C_COMPILER_ID}. It is only supported by GNU gcc.\\nRemove option `UNIT_TESTING_MOCKS` to build tests without using MOCK.\")\n    endif()\n  else()\n    # Mention MOCK is ignored\n    message(WARNING \"UNIT_TESTING_MOCKS will be ignored because UNIT_TESTING is not enabled.\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Targets for Test Data\nDESCRIPTION: This snippet adds custom targets that depend on the generated data files. These targets ensure that the data files are generated before the tests that use them are built.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/tests/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(test_suite_bignum_generated_data DEPENDS ${bignum_generated_data_files})\nadd_custom_target(test_suite_config_generated_data DEPENDS ${config_generated_data_files})\nadd_custom_target(test_suite_ecp_generated_data DEPENDS ${ecp_generated_data_files})\nadd_custom_target(test_suite_psa_generated_data DEPENDS ${psa_generated_data_files})\n```\n\n----------------------------------------\n\nTITLE: Vectored IRQ Handler in ThreadX (Assembly)\nDESCRIPTION: This assembly code defines an example vectored IRQ handler (__tx_example_vectored_irq_handler) within ThreadX. It saves scratch registers and the SPSR, adjusts the return address, and then calls `_tx_thread_vectored_context_save` to save the context. After the application ISR, it calls `_tx_thread_context_restore` to restore the system context. This handler is specific to a vectored interrupt setup.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/iar/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    RSEG    .text:CODE:NOROOT(2)\n    PUBLIC  __tx_example_vectored_irq_handler\n__tx_example_vectored_irq_handler\n;\n;    /* Jump to context save to save system context.  */\n    STMDB   sp!, {r0-r3}                    ; Save some scratch registers\n    MRS     r0, SPSR                        ; Pickup saved SPSR\n    SUB     lr, lr, #4                      ; Adjust point of interrupt \n    STMDB   sp!, {r0, r10, r12, lr}         ; Store other registers\n    BL      _tx_thread_vectored_context_save\n;\n;    /* At this point execution is still in the IRQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use. Note \n;       that IRQ interrupts are still disabled upon return from the context\n;       save function.  */\n;\n;    /* Application ISR dispatch call goes here!  */\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Build Examples matching TX, IAR, SMP (PowerShell)\nDESCRIPTION: This command builds all examples matching the keywords 'TX ', 'IAR', and 'SMP'. These examples are likely ThreadX examples for SMP (Symmetric Multiprocessing) using the IAR compiler. The pwsh -Command prefix is used to execute the command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_21\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','IAR','SMP' -build\n```\n\n----------------------------------------\n\nTITLE: Example HASH HAL Migrator Execution\nDESCRIPTION: This is an example of how to execute the HASH_HAL_Migrator script with a specific project path. The script will analyze the project located at '/c/STM32Cube_FW_H7_V1.2.0/Projects/STM32H747I-EVAL/Examples/HASH/HASH_SHA224SHA256_DMA/' and update the legacy HASH APIs to the new HAL HASH drivers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/HASH_HAL_Migrator/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npy HASH_HAL_Migrator.py -p \"/c/STM32Cube_FW_H7_V1.2.0/Projects/STM32H747I-EVAL/Examples/HASH/HASH_SHA224SHA256_DMA/\"\n```\n\n----------------------------------------\n\nTITLE: Adding CMSIS DSP Subdirectory\nDESCRIPTION: Adds the CMSIS DSP library as a subdirectory to the project build. The source code for the library is located in '../../../Source', and the resulting binaries will be placed in the 'bin_dsp' directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_sin_cos_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Setting Cloud Test Cases (Conditional)\nDESCRIPTION: This snippet defines a list of cloud-related test cases. It checks if the `PRODUCT` variable is equal to `netxduo`. If the condition is met, the `cloud_test_cases` variable is populated with a list of C source files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(PRODUCT STREQUAL netxduo)\n  set(cloud_test_cases\n      ${SOURCE_DIR}/cloud_test/netx_cloud_api_test.c\n      ${SOURCE_DIR}/cloud_test/netx_cloud_basic_test.c\n      ${SOURCE_DIR}/cloud_test/netx_cloud_module_event_test.c\n      ${SOURCE_DIR}/cloud_test/netx_cloud_module_register_deregister_test.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Start CLI for Cortex M7 Examples (PowerShell)\nDESCRIPTION: This command starts a CLI environment for all ThreadX for Cortex M7 examples. The environment is preconfigured for developing and debugging these examples. The pwsh -Command prefix enables the execution of the command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_10\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','Cortex M7' -StartCLI\n```\n\n----------------------------------------\n\nTITLE: Initializing an Empty az_span in C\nDESCRIPTION: This code snippet demonstrates how to initialize an empty `az_span` in C. An `az_span` is a structure that wraps a byte buffer and stores its pointer and size. An empty span has a size of 0.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\naz_span empty_span = AZ_SPAN_EMPTY; // size = 0\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required CMake version for the project. This ensures that the project can be built with compatible CMake versions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\n```\n\n----------------------------------------\n\nTITLE: Appending Property with Boolean Value\nDESCRIPTION: Appends a UTF-8 property name and a boolean value to the JSON writer. The property name is escaped before writing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_17\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_property_with_bool_value(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr,\n                                                              const UCHAR *property_name, UINT property_name_len,\n                                                              UINT value);\n```\n\n----------------------------------------\n\nTITLE: Creating Map File\nDESCRIPTION: Creates a map file for the `az_core_test` target. Map files are useful for debugging and analyzing the memory layout of the executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/core/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\ncreate_map_file(az_core_test az_core_test.map)\n```\n\n----------------------------------------\n\nTITLE: Statically Allocated Key Context Size - Public Key\nDESCRIPTION: Illustrates how to calculate the size of a statically allocated key context for a public key. It calculates the size using `base_size` and `public_key_size`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_40\n\nLANGUAGE: C\nCODE:\n```\nbase_size + public_key_size\n```\n\n----------------------------------------\n\nTITLE: Building Mbed TLS In-Place\nDESCRIPTION: This snippet builds Mbed TLS in the source directory by running CMake and make commands. Note that this overwrites existing Makefiles.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\ncmake .\nmake\n```\n\n----------------------------------------\n\nTITLE: Configure and Build Mbed TLS\nDESCRIPTION: Configures and builds Mbed TLS using CMake. It disables programs and testing, and enables the generation of files. The resulting build is placed in the specified binary directory. This ensures MbedTLS is built without examples or tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_package/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nexecute_process(\n    COMMAND \"${CMAKE_COMMAND}\"\n        \"-H${MbedTLS_SOURCE_DIR}\"\n        \"-B${MbedTLS_BINARY_DIR}\"\n        \"-DENABLE_PROGRAMS=NO\"\n        \"-DENABLE_TESTING=NO\"\n        # Turn on generated files explicitly in case this is a release\n        \"-DGEN_FILES=ON\")\n\nexecute_process(\n    COMMAND \"${CMAKE_COMMAND}\"\n        --build \"${MbedTLS_BINARY_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Adding Library with Source Files\nDESCRIPTION: Adds a library named `az_core` to the project. Specifies the list of source files that make up the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/core/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library (\n  az_core\n  ${CMAKE_CURRENT_LIST_DIR}/az_base64.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_context.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_http_pipeline.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_http_policy.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_http_policy_logging.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_http_policy_retry.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_http_request.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_http_response.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_json_reader.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_json_token.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_json_writer.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_log.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_precondition.c\n  ${CMAKE_CURRENT_LIST_DIR}/az_span.c\n)\n```\n\n----------------------------------------\n\nTITLE: Dynamically Allocated Key Context Size Function Prototype\nDESCRIPTION: Specifies the prototype for the size function used to determine the required size for a dynamically allocated key context. This function receives the key type and key size in bits as inputs and returns the number of bytes needed for the key context. It's used when dynamic allocation is supported and the `size_function` property is defined in the driver specification.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_37\n\nLANGUAGE: C\nCODE:\n```\nsize_t size_function(psa_key_type_t key_type, size_t key_bits);\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. This ensures that the CMake features used in the script are supported.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/core/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Include Interpolation Configuration\nDESCRIPTION: Includes the interpol CMake script to configure interpolation-related settings for the CMSISDSPCommon library. This script manages specific configurations related to interpolation algorithms.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(interpol)\ninterpol(CMSISDSPCommon)\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: This snippet adds subdirectories to the project for the NetXDuo networking stack and regression tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/ptp/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../../.. netxduo)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/regression regression)\n```\n\n----------------------------------------\n\nTITLE: Include Configuration Scripts\nDESCRIPTION: Includes external CMake scripts configLib and configDsp. These scripts likely contain common configuration settings and definitions used throughout the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: Adding Library\nDESCRIPTION: Adds a static library target named `CMSISDSPFastMath`. This command tells CMake to build a static library from the specified source files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(CMSISDSPFastMath STATIC)\n```\n\n----------------------------------------\n\nTITLE: Adding sources to executable\nDESCRIPTION: Specifies the source files that will be compiled into the arm_matrix_example executable. These source files contain the application's logic and functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(arm_matrix_example PRIVATE math_helper.c arm_matrix_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Defining the System Counter in C\nDESCRIPTION: This C code demonstrates how to assign a counter to be used as the system counter using the DefineSystemCounter function. The function takes a CounterType as parameter and returns a StatusType.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_12\n\nLANGUAGE: C\nCODE:\n```\nStatusType DefineSystemCounter(CounterType cntr);\n```\n\n----------------------------------------\n\nTITLE: Confirm Parameter\nDESCRIPTION: Prompts for confirmation before running the cmdlet.  This standard PowerShell parameter adds a layer of safety by requiring explicit confirmation before executing potentially destructive operations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_21\n\nLANGUAGE: yaml\nCODE:\n```\nType: SwitchParameter\nParameter Sets: (All)\nAliases: cf\n\nRequired: False\nPosition: Named\nDefault value: None\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Include Directories and User File Configuration (CMake)\nDESCRIPTION: This snippet sets up the include directories for the project. It configures and copies a user-defined header file ('lx_user.h') to a custom include directory. The location of the custom include directory is then added to the target's include directories.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# A place for generated/copied include files (no need to change)\nset(CUSTOM_INC_DIR ${CMAKE_CURRENT_BINARY_DIR}/custom_inc)\n\n# Pick up the common stuff\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/common)\n\n# Include the user's override file if required\nif (NOT LX_USER_FILE)\n    message(STATUS \"Using default lx_user.h file\")\n    set(LX_USER_FILE ${CMAKE_CURRENT_LIST_DIR}/common/inc/lx_user_sample.h)\nelse()\n    message(STATUS \"Using custom lx_user.h file from ${LX_USER_FILE}\")\nendif()\nconfigure_file(${LX_USER_FILE} ${CUSTOM_INC_DIR}/lx_user.h COPYONLY)\ntarget_include_directories(${PROJECT_NAME} \n    PUBLIC \n    ${CUSTOM_INC_DIR}\n)\n```\n\n----------------------------------------\n\nTITLE: Define Executables to Build (CMake)\nDESCRIPTION: Defines a list of executable names to be built.  This list will be iterated over to create the executables.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/util/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(executables\n    pem2der\n    strerror\n)\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Example for ThreadX on Cortex-M33\nDESCRIPTION: This code snippet demonstrates the structure of an Interrupt Service Routine (ISR) written in assembly language for use with ThreadX on the Cortex-M33. It includes the necessary directives and instructions for proper execution in the ThreadX environment, ensuring correct context switching and exception handling.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/ac6/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    .global  your_assembly_isr\n    .thumb_func\nyour_assembly_isr:\n; VOID your_assembly_isr(VOID)\n; {\n    PUSH    {r0, lr}\n;       \n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n    POP     {r0, lr}\n    BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Vectored IRQ Handler in ThreadX Assembly\nDESCRIPTION: This assembly code defines an example IRQ handler (__tx_irq_example_handler) in tx_initialize_low_level.s for ThreadX vectored interrupts. It saves scratch registers and the SPSR, calls the vectored IRQ context save function, and then restores the system context after the application ISR call. The code prepares for interrupt handling by saving context information.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/cortex_a7_smp/ac5/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    EXPORT  __tx_irq_example_handler\n__tx_irq_example_handler\n;\n;    /* Call context save to save system context.  */\n\n    STMDB   sp!, {r0-r3}                        ; Save some scratch registers\n    MRS     r0, SPSR                            ; Pickup saved SPSR\n    SUB     lr, lr, #4                          ; Adjust point of interrupt \n    STMDB   sp!, {r0, r10, r12, lr}             ; Store other scratch registers\n    BL      _tx_thread_vectored_context_save    ; Call the vectored IRQ context save\n;\n;    /* At this point execution is still in the IRQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use. Note \n;       that IRQ interrupts are still disabled upon return from the context\n;       save function.  */\n;\n;    /* Application ISR call goes here!  */\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories in CMake\nDESCRIPTION: This snippet uses CMake to add the 'inc' directory to the include paths for the project. This allows the compiler to find header files required by the source code. Specifically, the include directory contains header files for the USB host stack.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/core/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Including configuration and setting application configuration\nDESCRIPTION: This snippet includes the 'config' file and calls the 'configApp' function, passing the executable name and root directory as parameters. This likely configures application-specific settings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(config)\nconfigApp(arm_signal_convergence_example ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Configuring DCT4 Options (Q15) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Discrete Cosine Transform Type IV (DCT4) implementations for Q15 data types with various sizes (128 to 8192). These options are used to customize the CMSIS-DSP library by selecting specific DCT4 implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_21\n\nLANGUAGE: CMake\nCODE:\n```\noption(DCT4_Q15_128          \"dct4 q15 128\"                     OFF)\noption(DCT4_Q15_512          \"dct4 q15 512\"                     OFF)\noption(DCT4_Q15_2048         \"dct4 q15 2048\"                    OFF)\noption(DCT4_Q15_8192         \"dct4 q15 8192\"                    OFF)\n```\n\n----------------------------------------\n\nTITLE: Built-in Key Retrieval Entry Point in C\nDESCRIPTION: This is the prototype for the `get_builtin_key` entry point that drivers supporting built-in keys must provide. The core calls this entry point to retrieve key data and metadata. The `slot_number` identifies the key, `attributes` will be populated with key attributes, and `key_buffer` with the key context.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_50\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_get_builtin_key(psa_drv_slot_number_t slot_number,\n                                  psa_key_attributes_t *attributes,\n                                  uint8_t *key_buffer,\n                                  size_t key_buffer_size,\n                                  size_t *key_buffer_length);\n```\n\n----------------------------------------\n\nTITLE: Deploy test resources with default settings (PowerShell)\nDESCRIPTION: This example demonstrates how to deploy test resources to Azure using the default settings. It connects to the Azure account and then runs the New-TestResources.ps1 script against a specified service directory.  It assumes that Connect-AzAccount has already been run to authenticate.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nConnect-AzAccount -Subscription 'REPLACE_WITH_SUBSCRIPTION_ID'\nNew-TestResources.ps1 keyvault\n```\n\n----------------------------------------\n\nTITLE: Set Target Sources\nDESCRIPTION: Sets the source files for the 'arm_fir_example' target, making them private to the target.  These source files are arm_fir_data.c, math_helper.c, and arm_fir_example_f32.c.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fir_example/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(arm_fir_example PRIVATE arm_fir_data.c math_helper.c arm_fir_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Defining Target Sources in CMake\nDESCRIPTION: This CMake snippet defines the target sources for the project. It uses the `target_sources` command to specify the source files that should be compiled and linked into the project's target. The `PRIVATE` keyword indicates that these sources are only used internally by the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/ports/cortex_m4/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Update-TestResources.ps1 Syntax - ResourceGroup Parameter Set - PowerShell\nDESCRIPTION: Shows the syntax for using Update-TestResources.ps1 with the ResourceGroup parameter set. This allows you to specify the resource group name directly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/Update-TestResources.ps1.md#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\nUpdate-TestResources.ps1 [-ResourceGroupName <String>] [-SubscriptionId <String>] [-DeleteAfterHours <Int32>]\n [<CommonParameters>]\n```\n\n----------------------------------------\n\nTITLE: Defining test utility files\nDESCRIPTION: This snippet defines a list of utility files used for testing, including network driver test files and crypto cipher suites regression tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt_interoperability/regression/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(test_utility_files\n    ${SOURCE_DIR}/netxtestcontrol.c\n    ${SOURCE_DIR}/nx_crypto_ciphersuites_regression.c\n    ${SOURCE_DIR}/nx_ram_network_driver_test_1500.c\n    ${SOURCE_DIR}/nx_secure_fips_test_utility.c)\n```\n\n----------------------------------------\n\nTITLE: Installing MbedTLS and MbedCrypto Executables (CMake)\nDESCRIPTION: Installs the MbedTLS and MbedCrypto executables to the 'bin' directory. It sets specific permissions for the owner, group, and world to read, write (owner only), and execute the files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(TARGETS ${executables_mbedtls} ${executables_mbedcrypto}\n        DESTINATION \"bin\"\n        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n```\n\n----------------------------------------\n\nTITLE: Build Examples matching TX, ARM compiler v6, ARMv8-A (PowerShell)\nDESCRIPTION: This command builds all examples matching the keywords 'TX ', 'ARM compiler v6', and 'ARMv8-A'. The pwsh -Command prefix allows for the execution of the script from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_23\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','ARM compiler v6','ARMv8-A' -build\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker File Modification for ThreadX Memory Allocation\nDESCRIPTION: This code snippet shows the modification required in the EWARM linker file (.icf) to allocate a section of RAM for ThreadX dynamic memory allocation. This involves adding a line to the .icf file to specify that the last section FREE_MEM should be placed in the RAM_region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/FileX/FX_IAP/IAP_main/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Set Include Directories\nDESCRIPTION: Sets the include directories for the CMSISDSPComplexMath library. The include directory is set to the value of the DSP variable, which is expected to contain path to the Include folder.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_18\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(CMSISDSPComplexMath PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: CMake Project Definition\nDESCRIPTION: Defines the project name and specifies that the project uses C as the primary language.  This sets up the basic project environment for compiling C code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/libs/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(libs LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Define Target Include Directories CMake\nDESCRIPTION: This CMake snippet configures the target include directories for the project using target_include_directories. It adds the 'inc' directory located in the current list directory (CMAKE_CURRENT_LIST_DIR) to the public include paths. This allows the project to find necessary header files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m85/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: Adds the FileX core library, regression tests, and sample applications as subdirectories to the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../.. filex)\nadd_subdirectory(regression)\nadd_subdirectory(samples)\n```\n\n----------------------------------------\n\nTITLE: Globbing Source Files with CMake\nDESCRIPTION: This snippet uses the `file(GLOB)` command in CMake to find all C source files matching the pattern `./*_s8.c` in the current directory. The resulting list of files is stored in the variable `SRC`. This is typically used to automatically include all relevant source files in a build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/NNSupportFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SRC \"./*_s8.c\")\n```\n\n----------------------------------------\n\nTITLE: Creating an OSEK Counter in C\nDESCRIPTION: This C code displays the function signature for creating a counter using the CreateCounter function. It takes the counter name, maximum allowed value, ticks per base, minimum cycle, and start value as parameters.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_11\n\nLANGUAGE: C\nCODE:\n```\nCounterType CreateCounter(CHAR *name, \n                              TickType max_allowed_value, \n                              TickType ticks_per_base, \n                              TickType min_cycle, \n                              TickType start_value);\n```\n\n----------------------------------------\n\nTITLE: Defining the Project and Language\nDESCRIPTION: This snippet defines the project name as 'regression_test' and specifies that the primary language used is C.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(regression_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Generate Configuration-Independent Files (Unix)\nDESCRIPTION: This shell script command generates the configuration-independent files required for the Mbed TLS development branch. It uses the `check-generated-files.sh` script with the `-u` option to update the generated files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\ntests/scripts/check-generated-files.sh -u\n```\n\n----------------------------------------\n\nTITLE: Including X509 Subdirectory in CMake\nDESCRIPTION: This command includes the 'x509' subdirectory in the CMake build process. It enables the compilation and linking of the X.509 certificate handling module as part of the overall project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(x509)\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation Configuration for EWARM\nDESCRIPTION: This code snippet shows how to configure memory allocation for ThreadX using EWARM.  It involves adding a section to the .icf linker file to place the `FREE_MEM` section in the `RAM_region`. This allows ThreadX to manage memory dynamically.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_WebServer/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Registering and Unregistering Key Slot Readers\nDESCRIPTION: Functions like `psa_register_read` and `psa_unregister_read` increment and decrement the reader count of a key slot, respectively. The `psa_get_and_lock_key_slot_X` functions are used to register a read operation, and after reading, `psa_unregister_read` signals completion. These primitives manage concurrent access to key slots by tracking active readers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-thread-safety/psa-thread-safety.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\npsa_register_read\npsa_unregister_read\npsa_get_and_lock_key_slot_X\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: Sets the minimum required CMake version and defines the project name and version.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fir_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_fir_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: Appending String\nDESCRIPTION: Appends a UTF-8 encoded string value to the JSON writer. The string value is escaped before writing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_20\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_string(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr,\n                                            const UCHAR *value, UINT value_len);\n```\n\n----------------------------------------\n\nTITLE: De-initializing JSON Writer\nDESCRIPTION: De-initializes an Azure IoT JSON writer instance. This function releases any resources held by the JSON writer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_json_writer_deinit(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr);\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: Specifies the minimum required CMake version and sets CMake policies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\n```\n\n----------------------------------------\n\nTITLE: Source Inclusion - Logarithmic and Exponential Functions\nDESCRIPTION: Includes source files for vector logarithmic and exponential functions for f32 and f64 data types unconditionally.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(CMSISDSPFastMath PRIVATE arm_vlog_f32.c)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_vlog_f64.c)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_vexp_f32.c)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_vexp_f64.c)\n```\n\n----------------------------------------\n\nTITLE: Compile Definitions Based on Standalone Mode (CMake)\nDESCRIPTION: This code snippet defines compile definitions based on whether LevelX is in standalone mode or integrated with Azure RTOS. If not in standalone mode, it defines 'LX_INCLUDE_USER_DEFINE_FILE'. Otherwise, it also defines 'LX_STANDALONE_ENABLE' and 'FX_STANDALONE_ENABLE'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT LX_STANDALONE_ENABLE)\n    target_compile_definitions(${PROJECT_NAME} PUBLIC \"LX_INCLUDE_USER_DEFINE_FILE\" )\nelse()\n    # Enable LevelX and FileX standalone support (No Azure RTOS support)\n    set(FX_STANDALONE_ENABLE ON CACHE BOOL \"Standalone enable\")\n    target_compile_definitions(${PROJECT_NAME} PUBLIC \"LX_INCLUDE_USER_DEFINE_FILE\" -DLX_STANDALONE_ENABLE -DFX_STANDALONE_ENABLE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting up CMake Project and Policies\nDESCRIPTION: Initializes the CMake environment, specifying the minimum required version, setting policies for compatibility, and declaring the project with the C language enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\ncmake_policy(SET CMP0077 NEW)\n\nproject(mqtt_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Adding CMocka Test\nDESCRIPTION: This snippet adds a CMocka test executable.  It defines the source files, compile options, link libraries, and include directories required for the test. It links the CMocka library, Azure IoT Hub library, Azure Core library, and Azure IoT Common Library to the test executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/hub/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(AddCMockaTest)\n\nadd_cmocka_test(az_iot_hub_test SOURCES\n                main.c\n                test_az_iot_hub_client_sas.c\n                test_az_iot_hub_client_telemetry.c\n                test_az_iot_hub_client_c2d.c\n                test_az_iot_hub_client.c\n                test_az_iot_hub_client_twin.c\n                test_az_iot_hub_client_methods.c\n                test_az_iot_hub_client_commands.c\n                test_az_iot_hub_client_properties.c\n                COMPILE_OPTIONS ${DEFAULT_C_COMPILE_FLAGS} ${NO_CLOBBERED_WARNING}\n                LINK_LIBRARIES ${CMOCKA_LIB}\n                    az_iot_common\n                    az_iot_hub\n                    az_core\n                INCLUDE_DIRECTORIES ${CMOCKA_INCLUDE_DIR}\n                )\n```\n\n----------------------------------------\n\nTITLE: De-initializing JSON Reader in C\nDESCRIPTION: De-initializes an NX_AZURE_IOT_JSON_READER.  It requires a pointer to the reader instance. On success, it returns NX_AZURE_IOT_SUCCESS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_deinit(NX_AZURE_IOT_JSON_READER *reader_ptr);\n```\n\n----------------------------------------\n\nTITLE: Build Examples matching TXM, ARM compiler v6, Cortex M (PowerShell)\nDESCRIPTION: This command builds all examples matching all the keywords 'TXM', 'ARM compiler v6', and 'Cortex M'. These examples are likely related to ThreadX Modules (TXM) for Cortex M using ARM compiler v6. The pwsh -Command prefix enables execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_14\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TXM','ARM compiler v6','Cortex M' -build\n```\n\n----------------------------------------\n\nTITLE: Define CMSIS-DSP Path\nDESCRIPTION: This snippet defines the path to the CMSIS-DSP library, which is necessary for including the library's header files and linking against it. It sets the ROOT variable based on the current source directory and defines the DSP variable pointing to the CMSIS/DSP directory within the CMSIS pack.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: CMake project initialization\nDESCRIPTION: Initializes the CMake project, specifying the minimum required CMake version and project details like name and version.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_matrix_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: Set Include Directories for Everest Target in CMake\nDESCRIPTION: This snippet sets the include directories for the Everest library target. It defines both public and private include directories using `target_include_directories`. Public include directories are exposed to users of the library, while private include directories are only used during the library's compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/everest/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${everest_target}\n  PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n         $<BUILD_INTERFACE:${MBEDTLS_DIR}/include>\n         $<INSTALL_INTERFACE:include>\n  PRIVATE include/everest\n          include/everest/kremlib\n          ${MBEDTLS_DIR}/library/)\n```\n\n----------------------------------------\n\nTITLE: Test Assumption on PSA_MAX_KEY_BITS\nDESCRIPTION: This comment documents an assumption made by the test regarding the value of `PSA_MAX_KEY_BITS`. Specifically, it assumes that `PSA_MAX_KEY_BITS` is less than the maximum output size from the HKDF-SHA512 algorithm. This assumption is relevant for ensuring the test's validity and preventing unexpected behavior if `PSA_MAX_KEY_BITS` were to change significantly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/testing/invasive-testing.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n# This test assumes that PSA_MAX_KEY_BITS (currently 65536-8 bits = 8191 bytes\n# and not expected to be raised any time soon) is less than the maximum\n# output from HKDF-SHA512 (255*64 = 16320 bytes).\n```\n\n----------------------------------------\n\nTITLE: Conditional Target Sources (arm_cmplx_mag_fast_q15.c)\nDESCRIPTION: Conditionally includes the arm_cmplx_mag_fast_q15.c source file based on similar conditions as arm_cmplx_mag_q31.c.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_CMPLX_MAG_FAST_Q15 OR (NOT HELIUM AND NOT MVEI))\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_fast_q15.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation: IPv4 Samples\nDESCRIPTION: This snippet conditionally adds several IPv4-related sample files to the `sample_files` list if the `-DNX_DISABLE_IPV4` flag is NOT present in the `CMAKE_BUILD_TYPE`. The files include SMTP client, multihome DHCP client, PPP, PTP client, DHCP server, POP3 client, and Auto IP examples.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/samples/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT \"-DNX_DISABLE_IPV4\" IN_LIST ${CMAKE_BUILD_TYPE})\n  list(\n    APPEND\n    sample_files\n    ${SOURCE_DIR}/demo_netxduo_smtp_client.c\n    ${SOURCE_DIR}/demo_netxduo_multihome_dhcp_client.c\n    ${SOURCE_DIR}/demo_netx_ppp.c\n    ${SOURCE_DIR}/demo_netx_duo_ptp_client.c\n    ${SOURCE_DIR}/demo_netxduo_dhcp.c\n    ${SOURCE_DIR}/demo_netxduo_pop3_client.c\n    ${SOURCE_DIR}/demo_netx_auto_ip.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Hash Clone Test Utility (Hash Clone Build)\nDESCRIPTION: Conditionally adds hash clone related utility files if the `CMAKE_BUILD_TYPE` is set to `hash_clone_build`. This includes files to test the cloning and cleanup of cryptographic hash objects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/regression/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif(\"s${CMAKE_BUILD_TYPE}\" STREQUAL \"shash_clone_build\")\nlist(APPEND test_utility_files\n    ${SOURCE_DIR}/nx_secure_test/hash_clone/nx_crypto_clone_cleanup_test.c\n    ${SOURCE_DIR}/nx_secure_test/hash_clone/nx_crypto_hash_clone_test.c\n    ${SOURCE_DIR}/nx_secure_test/hash_clone/nx_crypto_ciphersuites_hc.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Compile Options for NetX Duo\nDESCRIPTION: This snippet adds several compile options to the 'netxduo' target. These options include enabling warnings as errors, enabling various warning types, setting message length, and enabling function and data sections for linking.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(\n  netxduo\n  PRIVATE -Werror\n          -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal)\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation: PPPoE Samples\nDESCRIPTION: This snippet conditionally includes PPPoE client and server sample files (`demo_netx_pppoe_client.c` and `demo_netx_pppoe_server.c`) if `-DNX_PPP_PPPOE_ENABLE` is in `CMAKE_BUILD_TYPE` and `-DNX_PPPOE_CLIENT_INITIALIZE_DRIVER_ENABLE` is not.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/samples/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif((\"-DNX_PPP_PPPOE_ENABLE\" IN_LIST ${CMAKE_BUILD_TYPE})\n   AND NOT (\"-DNX_PPPOE_CLIENT_INITIALIZE_DRIVER_ENABLE\" IN_LIST\n            ${CMAKE_BUILD_TYPE}))\n  list(APPEND sample_files ${SOURCE_DIR}/demo_netx_pppoe_client.c\n       ${SOURCE_DIR}/demo_netx_pppoe_server.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Running fuzz targets with oss-fuzz\nDESCRIPTION: This script shows how to run the fuzz targets using oss-fuzz. It clones the oss-fuzz repository, builds the necessary image and fuzzers, and then runs a specific fuzzer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/fuzz/README.md#_snippet_0\n\nLANGUAGE: Shell Script\nCODE:\n```\ngit clone https://github.com/google/oss-fuzz\ncd oss-fuzz\npython infra/helper.py build_image mbedtls\npython infra/helper.py build_fuzzers --sanitizer address mbedtls\npython infra/helper.py run_fuzzer mbedtls fuzz_client\n```\n\n----------------------------------------\n\nTITLE: Adding Transform Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the TransformFunctions subdirectory and links the CMSISDSPTransform library to the CMSISDSP interface library if the TRANSFORM flag is set. It also sets compile definitions for FFT tables if CONFIGTABLE is enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_34\n\nLANGUAGE: cmake\nCODE:\n```\nif (TRANSFORM)\n  add_subdirectory(TransformFunctions)\n  # FFT tables inclusion is allowed\n  if (CONFIGTABLE)\n    target_compile_definitions(CMSISDSPTransform PUBLIC ARM_FFT_ALLOW_TABLES)\n  endif()\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPTransform)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Define Build Options\nDESCRIPTION: Defines various build options using the `option` command. These options allow users to customize the build process, such as enabling programs, allowing unsafe builds, treating warnings as errors, and disabling package configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\noption(ENABLE_PROGRAMS \"Build Mbed TLS programs.\" ON)\n\noption(UNSAFE_BUILD \"Allow unsafe builds. These builds ARE NOT SECURE.\" OFF)\noption(MBEDTLS_FATAL_WARNINGS \"Compiler warnings treated as errors\" ON)\nif(CMAKE_HOST_WIN32)\n    # N.B. The comment on the next line is significant! If you change it,\n    # edit the sed command in prepare_release.sh that modifies\n    # CMakeLists.txt.\n    option(GEN_FILES \"Generate the auto-generated files as needed\" OFF) # off in development\nelse()\n    option(GEN_FILES \"Generate the auto-generated files as needed\" OFF)\nendif()\n\noption(DISABLE_PACKAGE_CONFIG_AND_INSTALL \"Disable package configuration, target export and installation\" ${MBEDTLS_AS_SUBPROJECT})\n```\n\n----------------------------------------\n\nTITLE: Key Derivation Setup Entry Point (C)\nDESCRIPTION: Defines the function signature for the key derivation setup entry point. This function is called to initialize the key derivation operation with the algorithm and initial inputs. It takes a pointer to an operation object, the algorithm, and the initial inputs.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_13\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_key_derivation_setup(\n    acme_key_derivation_operation_t *operation,\n    psa_algorithm_t alg,\n    const psa_crypto_driver_key_derivation_inputs_t *inputs);\n```\n\n----------------------------------------\n\nTITLE: Set Everest Target Name in CMake\nDESCRIPTION: This snippet sets the name of the Everest target based on the MbedTLS target prefix. The target name is stored in the `everest_target` variable for later use in defining the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/everest/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(everest_target \"${MBEDTLS_TARGET_PREFIX}everest\")\n```\n\n----------------------------------------\n\nTITLE: Including network configuration\nDESCRIPTION: This snippet includes a separate CMake file named 'network_config.cmake', presumably responsible for configuring network-related settings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt_interoperability/regression/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(network_config.cmake)\n```\n\n----------------------------------------\n\nTITLE: Conditional Target Sources (arm_cmplx_mag_q31.c)\nDESCRIPTION: Conditionally includes the arm_cmplx_mag_q31.c source file in the CMSISDSPComplexMath library if CONFIGTABLE is false, ALLFAST is true, ARM_CMPLX_MAG_Q31 is true, or both HELIUM and MVEI are false.  This allows excluding the file based on configuration.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_CMPLX_MAG_Q31 OR (NOT HELIUM AND NOT MVEI))\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mag_q31.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Determine Subproject Status\nDESCRIPTION: Determines if Mbed TLS is being built as a subproject using add_subdirectory().  If it is not defined, it is set to ON unless the current source and build directories are equal. This is used to configure build behavior differently for standalone builds vs. subprojects.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT DEFINED MBEDTLS_AS_SUBPROJECT)\n  set(MBEDTLS_AS_SUBPROJECT ON)\n  if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n    set(MBEDTLS_AS_SUBPROJECT OFF)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Project Initialization\nDESCRIPTION: Initializes the CMake project, specifying the project name and supported programming languages (C).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nproject(levelx_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Defining Project and Languages\nDESCRIPTION: Defines the project name as `AzureIoTMiddleware` and specifies that the project uses C and Assembly languages.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\n# Project\nproject(AzureIoTMiddleware LANGUAGES C ASM)\n```\n\n----------------------------------------\n\nTITLE: Including Code Coverage Configuration\nDESCRIPTION: Includes a CMake module named `CheckAndIncludeCodeCov` for setting up code coverage targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/core/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(CheckAndIncludeCodeCov)\n```\n\n----------------------------------------\n\nTITLE: Including Interpolation Configuration\nDESCRIPTION: Includes a custom CMake script named `interpol` and calls it to configure interpolation-related settings for the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(interpol)\ninterpol(CMSISDSPFastMath)\n```\n\n----------------------------------------\n\nTITLE: MXCHIP EMW3080 WiFi Driver for NetXDuo\nDESCRIPTION: This driver integrates the MXCHIP emw3080 WiFi module with the NetXDuo middleware on STM32. It manages the communication protocol and data exchange required for WiFi operation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/README.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\n**mxchip/nx_driver_emw3080.c**\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for PIMA Class Tests CMake\nDESCRIPTION: Defines the source file paths for the USBX PIMA (Picture Transfer Protocol) class test cases. These tests cover PIMA functionality and include both device and host side testing, as well as PictBridge functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_27\n\nLANGUAGE: CMake\nCODE:\n```\n  ${SOURCE_DIR}/usbx_pima_basic_test.c\n  ${SOURCE_DIR}/usbx_pictbridge_basic_test.c\n  ${SOURCE_DIR}/usbx_uxe_device_pima_test.c\n  ${SOURCE_DIR}/usbx_uxe_host_pima_test.c\n```\n\n----------------------------------------\n\nTITLE: Create Executable\nDESCRIPTION: This snippet creates the executable named 'arm_bayes_example'.  It initializes the executable target in CMake, preparing it to be populated with source files and linked against libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_bayes_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(arm_bayes_example)\n```\n\n----------------------------------------\n\nTITLE: Generating Code Coverage Reports\nDESCRIPTION: These commands generate code coverage reports for a specific project in the Azure SDK for Embedded C after running unit tests.  It requires gcc, gcovr, lcov, and a debug build. The AZ_SDK_CODE_COV environment variable must be set to enable building code coverage.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# from source code root, create a new folder to build project:\nmkdir build\ncd build\n\n# set env variable to enable building code coverage\nexport AZ_SDK_CODE_COV=1\n# generate cmake files with Debug and cmocka unit tests enabled\ncmake -DUNIT_TESTING=ON -DCMAKE_BUILD_TYPE=Debug ..\n# build\ncmake --build .\n\n## There are 3 available reports to generate for each project:\n# 1. using lcov. Html files grouped by folders. Make sure lcov\n# is installed.\nmake ${project_name}_cov //i.e. az_core_cov or az_iot_common_cov\n\n# 2. using gcov. Html page with all results in one page. Make sure\n# gcov is installed.\nmake ${project_name}_cov_html //i.e. az_core_cov_html or az_iot_common_cov_html\n\n# 3. using gcov. XML file with all results. Make sure\n# gcov is installed.\nmake ${project_name}_cov_xml //i.e. az_core_cov_xml or az_iot_common_cov_xml\n```\n\n----------------------------------------\n\nTITLE: Statically Allocated Key Context Size - Key Pair\nDESCRIPTION: Demonstrates how to calculate the size of a statically allocated key context for a key pair. It uses `base_size`, `key_pair_size`, and a `public_key_overhead` term that depends on the `store_public_key` property. `public_key_overhead` is calculated using `PSA_EXPORT_PUBLIC_KEY_MAX_SIZE` if `store_public_key` is true, otherwise it's 0.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_39\n\nLANGUAGE: C\nCODE:\n```\nbase_size + key_pair_size + public_key_overhead\n```\n\n----------------------------------------\n\nTITLE: Create Executable\nDESCRIPTION: This snippet creates an executable named `arm_dotproduct_example`.  The `add_executable` command defines a target that produces an executable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(arm_dotproduct_example)\n```\n\n----------------------------------------\n\nTITLE: Adding Fast Math Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the FastMathFunctions subdirectory and links the CMSISDSPFastMath library to the CMSISDSP interface library if the FASTMATH flag is set. It also sets compile definitions for fast tables if CONFIGTABLE is enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_29\n\nLANGUAGE: cmake\nCODE:\n```\nif (FASTMATH)\n  add_subdirectory(FastMathFunctions)\n  # Fast tables inclusion is allowed\n  if (CONFIGTABLE)\n    target_compile_definitions(CMSISDSPFastMath PUBLIC ARM_FAST_ALLOW_TABLES)\n  endif()\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPFastMath)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files to CMSIS-NN Target\nDESCRIPTION: This CMake snippet adds the source files collected in the `SRC` and `SRC_S16` variables to the `cmsis-nn` target as private sources. This means these source files are only used when building the `cmsis-nn` target and are not exposed for linking with other targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/ConvolutionFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(cmsis-nn PRIVATE ${SRC} ${SRC_S16})\n```\n\n----------------------------------------\n\nTITLE: Standard IRQ Handler in Assembly\nDESCRIPTION: This code snippet shows the default IRQ handler (__tx_irq_handler) in tx_initialize_low_level.s. It saves the system context, allows for application-specific ISR calls, and restores the system context.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/cortex_a7_smp/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\nEXPORT  __tx_irq_handler\nEXPORT  __tx_irq_processing_return\n__tx_irq_handler\n;\n;    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save             ; Jump to the context save\n__tx_irq_processing_return\n;\n;    /* At this point execution is still in the IRQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use. Note \n;       that IRQ interrupts are still disabled upon return from the context\n;       save function.  */\n;\n;    /* Application ISR call(s) go here!  */\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Appending Property with Double Value\nDESCRIPTION: Appends a UTF-8 property name and a double value to the JSON writer. The property name is escaped before writing. The number of fractional digits to include can be specified.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_property_with_double_value(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr,\n                                                                const UCHAR *property_name, UINT property_name_len,\n                                                                double value, UINT fractional_digits);\n```\n\n----------------------------------------\n\nTITLE: Define Executable Source Files\nDESCRIPTION: This snippet defines the source files for the executable 'arm_bayes_example'. The arm_bayes_example_f32.c file is specified as a PRIVATE source, meaning it's only used by this target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_bayes_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(arm_bayes_example PRIVATE arm_bayes_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Building No Platform Library\nDESCRIPTION: This snippet builds the 'az_noplatform' static library if AZ_PLATFORM_IMPL is not 'WIN32' or 'POSIX'. It adds the library source file and links it with the 'az_core' library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/platform/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nelse()\n  #noplatform\n  add_library(az_noplatform STATIC\n    ${CMAKE_CURRENT_LIST_DIR}/az_noplatform.c\n  )\n\n  target_link_libraries(az_noplatform\n    PRIVATE\n      az_core\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories in CMake\nDESCRIPTION: This CMake code adds several subdirectories to the current project. Each subdirectory corresponds to a specific USB component, allowing modular building and organization of the project. The ${CMAKE_CURRENT_LIST_DIR} variable provides the path to the current CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/core)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/usbx_device_classes)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/usbx_host_classes)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/usbx_host_controllers)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/usbx_network)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/usbx_pictbridge)\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler via CMake\nDESCRIPTION: This snippet sets the compiler during CMake configuration.  The CC environment variable must be set before invoking cmake.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nCC=your_cc cmake /path/to/mbedtls_source\n```\n\n----------------------------------------\n\nTITLE: Find Python Interpreter\nDESCRIPTION: Finds the Python 3 interpreter (or Python Interp for older CMake versions) and sets the `MBEDTLS_PYTHON_EXECUTABLE` variable. Python is used for checking configuration warnings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_VERSION VERSION_LESS 3.15.0)\n    set(Python3_FIND_STRATEGY LOCATION)\n    find_package(Python3 COMPONENTS Interpreter)\n    if(Python3_Interpreter_FOUND)\n        set(MBEDTLS_PYTHON_EXECUTABLE ${Python3_EXECUTABLE})\n    endif()\nelse()\n    find_package(PythonInterp 3)\n    if(PYTHONINTERP_FOUND)\n        set(MBEDTLS_PYTHON_EXECUTABLE ${PYTHON_EXECUTABLE})\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: UART console menu display example\nDESCRIPTION: This code snippet shows the expected output on the UART console after the application starts. It presents a main menu with options, including starting the bootloader.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ROT/STiROT_Appli_TrustZone/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n=================== Main Menu =============================\n Start BootLoader -------------------------------------- 1\n Selection :\n```\n\n----------------------------------------\n\nTITLE: Adding Float16 bit reversal source file in CMake\nDESCRIPTION: This snippet conditionally adds arm_bitreversal_f16.c as a private source file to the CMSISDSPTransform library if ARMAC5 is not defined and DISABLEFLOAT16 is not defined. This enables float16 support.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPTransform PRIVATE arm_bitreversal_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuration-Specific Compile Options\nDESCRIPTION: Sets compile options based on the selected build configuration (e.g., disabling notify callbacks, enabling stack checking, or enabling event tracing).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(default_build_coverage \"\")\nset(disable_notify_callbacks_build -DTX_DISABLE_NOTIFY_CALLBACKS)\nset(stack_checking_build -DTX_ENABLE_STACK_CHECKING)\nset(stack_checking_rand_fill_build -DTX_ENABLE_STACK_CHECKING -DTX_ENABLE_RANDOM_NUMBER_STACK_FILLING)\nset(trace_build -DTX_ENABLE_EVENT_TRACE)\n```\n\n----------------------------------------\n\nTITLE: Adding OpenSSL to PATH in PowerShell\nDESCRIPTION: This PowerShell script adds the OpenSSL directory to the system's PATH environment variable. OpenSSL is installed as a dependency by vcpkg for Eclipse Paho. It's important to note that the documentation explicitly states that OpenSSL is NOT recommended for production-level code on Windows or macOS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\n# NOT RECOMMENDED to use for production-level code.\nPS C:\\> $env:PATH=$env:PATH + ';C:\\vcpkg\\installed\\x64-windows-static\\tools\\openssl' # Update complete path as needed.\n```\n\n----------------------------------------\n\nTITLE: CMake Minimum Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. This ensures that the CMake version used is compatible with the commands and features used in the CMakeLists.txt file.  It's crucial for build environment consistency.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/BasicMathFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: Setting up Libraries\nDESCRIPTION: This CMake snippet sets up the libraries required for the target, which includes the mbedtls target and any thread libraries defined by CMAKE_THREAD_LIBS_INIT.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/fuzz/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(libs\n    ${mbedtls_target}\n    ${CMAKE_THREAD_LIBS_INIT}\n)\n```\n\n----------------------------------------\n\nTITLE: Conditionally Add f16 Interpolation Sources\nDESCRIPTION: This snippet conditionally adds the source files for f16 interpolation (arm_bilinear_interp_f16.c and arm_linear_interp_f16.c) if the ARMAC5 compiler is not used and the DISABLEFLOAT16 flag is not set. This allows for including half-precision floating-point interpolation implementations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/InterpolationFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_bilinear_interp_f16.c)\ntarget_sources(CMSISDSPInterpolation PRIVATE arm_linear_interp_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. Ensures compatibility with the CMake features used in the build script.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_variance_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: Set Public Include Directories\nDESCRIPTION: Adds the directory specified by the DSP variable's Include subdirectory as a public include directory for the CMSISDSPCommon library. This allows external projects to include header files from this directory when using the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(CMSISDSPCommon PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Clean Examples Matching Keywords (PowerShell)\nDESCRIPTION: This command cleans examples matching the keywords 'TX ', 'ARM compiler v6', and 'Cortex M'.  It targets ThreadX examples for Cortex M using the ARM compiler v6. The pwsh -Command prefix is used for executing this command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_8\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','ARM compiler v6','Cortex M' -clean\n```\n\n----------------------------------------\n\nTITLE: Sending C2D Messages via Azure CLI\nDESCRIPTION: This snippet shows how to send cloud-to-device (C2D) messages to the device using the Azure CLI. The --device-id and --hub-name parameters need to be replaced with the actual device ID and IoT Hub name. Requires Azure CLI to be installed and configured.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_vxworks.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\naz iot device c2d-message send --device-id [Device ID] --hub-name [IoT Hub Name] --data \"hello world\"\n```\n\n----------------------------------------\n\nTITLE: Master/Slave Selection via Define in main.c\nDESCRIPTION: This code snippet shows how to select between Master and Slave mode by commenting or uncommenting a preprocessor definition in the main.c file. This choice determines which I2C functions are used for transmission and reception.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples/I2C/I2C_WakeUpFromStop/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n/* Master Board: \n - The HAL_I2C_Master_Receive_IT() and the HAL_I2C_Master_Transmit_IT() functions \n allow respectively the reception and the transmission of a predefined data buffer\n in Master mode using interrupt.\n\n- Slave Board: \n - The HAL_I2C_Slave_Receive_IT() and the HAL_I2C_Slave_Transmit_IT() functions \n allow respectively the reception and the transmission of a predefined data buffer\n in Slave mode using interrupt.\n\nThe user can choose between Master and Slave through \"#define MASTER_BOARD\"\nin the \"main.c\" file:\n\n- If the Master board is used, the \"#define MASTER_BOARD\" must be uncommented.\n- If the Slave board is used the \"#define MASTER_BOARD\" must be commented.*/\n```\n\n----------------------------------------\n\nTITLE: Globbing and Adding CMSIS-NN Source Files (CMake)\nDESCRIPTION: This snippet uses the `file(GLOB)` command to find all C source files matching the pattern `*_s8.c` in the current directory and stores the list of files in the variable `SRC`. Then, it uses the `target_sources` command to add these files as private sources to the `cmsis-nn` target, ensuring they are compiled and linked into the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/SVDFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SRC \"./*_s8.c\")\ntarget_sources(cmsis-nn PRIVATE ${SRC})\n```\n\n----------------------------------------\n\nTITLE: Create Executable\nDESCRIPTION: This snippet creates the executable target for the ARM graphic equalizer example.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(arm_graphic_equalizer_example)\n```\n\n----------------------------------------\n\nTITLE: Installing Executables\nDESCRIPTION: Installs the built executables to the `bin` directory with specific permissions, allowing the owner to read, write, and execute, and granting read and execute permissions to the group and the world.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/ssl/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS ${executables}\n        DESTINATION \"bin\"\n        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n```\n\n----------------------------------------\n\nTITLE: Defining Project and Including Files\nDESCRIPTION: This code snippet defines the project name as 'netx_test' with C language support, sets a variable for a user-defined header file, and includes an external CMakeLists.txt file. It sets the project language and includes the CMakeLists.txt from the netxduo directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo_fast/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nproject(netx_test LANGUAGES C)\n\nset(NX_USER_FILE ${CMAKE_CURRENT_SOURCE_DIR}/nx_user.h)\ninclude(${CMAKE_CURRENT_SOURCE_DIR}/../netxduo/CMakeLists.txt)\n```\n\n----------------------------------------\n\nTITLE: Define Regression Test Cases\nDESCRIPTION: This snippet defines a list of C source files for the FileX regression tests. The `regression_test_cases` variable is set to a list of file paths, each pointing to a specific regression test case within the `SOURCE_DIR`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/regression/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nset(regression_test_cases\n    ${SOURCE_DIR}/filex_directory_attributes_read_set_test.c\n    ${SOURCE_DIR}/filex_directory_create_delete_test.c\n    ${SOURCE_DIR}/filex_directory_default_path_get_set_test.c\n    ${SOURCE_DIR}/filex_directory_duplicate_entries_test.c\n    ${SOURCE_DIR}/filex_directory_first_next_find_test.c\n    ${SOURCE_DIR}/filex_directory_local_path_test.c\n    ${SOURCE_DIR}/filex_directory_long_short_get_test.c\n    ${SOURCE_DIR}/filex_directory_naming_test.c\n    ${SOURCE_DIR}/filex_directory_rename_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_corrupted_log_file_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_delete_large_data_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_directory_attributes_set_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_directory_attributes_set_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_directory_create_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_directory_create_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_directory_delete_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_directory_delete_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_directory_rename_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_directory_rename_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_enable_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_enable_1_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_enable_2_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_enable_3_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_enable_4_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_media_check_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_seek_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_random_seek_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_allocate_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_allocate_fat_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_allocate_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_allocate_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_allocate_undo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_attributes_set_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_attributes_set_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_best_allocate_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_best_allocate_fat_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_best_allocate_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_best_allocate_undo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_create_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_create_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_delete_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_delete_fat_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_delete_fat_multiple_sectors_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_delete_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_delete_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_delete_undo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_rename_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_rename_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_truncate_release_available_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_truncate_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_truncate_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_truncate_release_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_truncate_release_fat_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_truncate_release_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_truncate_release_undo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_write_available_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_write_data_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_write_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_write_fat_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_write_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_write_undo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_corruption_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_log_full_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_log_recover_directory_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_log_recover_fat_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_long_directory_create_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_long_directory_create_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_long_directory_rename_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_long_directory_rename_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_long_directory_rename_io_error_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_long_file_create_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_long_file_create_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_loop_write_data_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_media_full_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_write_large_data_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_write_large_data_fat_chain_cleanup_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_write_large_data_fat_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_write_large_data_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_write_large_data_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_write_large_data_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_write_large_data_undo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_recover_fail_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_unicode_directory_create_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_unicode_directory_create_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_unicode_directory_rename_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_unicode_directory_rename_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_unicode_file_create_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_unicode_file_create_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_unicode_file_rename_directory_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_unicode_file_rename_redo_log_interrupt_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_write_fat_crossover_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_write_fat_crossover_2_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_allocate_fat_crossover_test.c\n    ${SOURCE_DIR}/filex_fault_tolerant_file_best_effort_allocate_fat_crossover_test.c\n    ${SOURCE_DIR}/filex_file_allocate_truncate_test.c\n    ${SOURCE_DIR}/filex_file_allocate_test.c\n    ${SOURCE_DIR}/filex_file_attributes_read_set_test.c\n    ${SOURCE_DIR}/filex_file_create_delete_test.c\n    ${SOURCE_DIR}/filex_file_date_time_set_test.c\n    ${SOURCE_DIR}/filex_file_naming_test.c\n    ${SOURCE_DIR}/filex_file_read_write_test.c\n    ${SOURCE_DIR}/filex_file_rename_test.c\n    ${SOURCE_DIR}/filex_file_seek_test.c\n    ${SOURCE_DIR}/filex_file_name_test.c\n    ${SOURCE_DIR}/filex_media_abort_test.c\n    ${SOURCE_DIR}/filex_media_cache_invalidate_test.c\n    ${SOURCE_DIR}/filex_media_check_test.c\n    ${SOURCE_DIR}/filex_media_flush_test.c\n    ${SOURCE_DIR}/filex_media_format_open_close_test.c\n    ${SOURCE_DIR}/filex_media_multiple_open_close_test.c\n    ${SOURCE_DIR}/filex_media_read_write_sector_test.c\n    ${SOURCE_DIR}/filex_media_volume_directory_entry_test.c\n    ${SOURCE_DIR}/filex_media_volume_get_set_test.c\n    ${SOURCE_DIR}/filex_media_hidden_sectors_test.c\n    ${SOURCE_DIR}/filex_system_date_time_test.c\n    ${SOURCE_DIR}/filex_unicode_directory_rename_test.c\n    ${SOURCE_DIR}/filex_unicode_file_directory_rename_extra_test.c\n    ${SOURCE_DIR}/filex_unicode_file_directory_rename_extra_2_test.c\n    ${SOURCE_DIR}/filex_unicode_file_rename_test.c\n    ${SOURCE_DIR}/filex_unicode_test.c\n    ${SOURCE_DIR}/filex_unicode_2_test.c\n    ${SOURCE_DIR}/filex_unicode_3_test.c\n    ${SOURCE_DIR}/filex_unicode_4_test.c\n    ${SOURCE_DIR}/filex_unicode_name_string_test.c\n    ${SOURCE_DIR}/filex_unicode_directory_entry_test.c\n    ${SOURCE_DIR}/filex_unicode_directory_entry_2_test.c\n    ${SOURCE_DIR}/filex_unicode_directory_entry_change_test.c\n    ${SOURCE_DIR}/filex_unicode_fat_entry_test.c\n    ${SOURCE_DIR}/filex_unicode_fat_entry_1_test.c\n    ${SOURCE_DIR}/filex_unicode_fat_entry_2_test.c\n    ${SOURCE_DIR}/filex_unicode_fat_entry_3_test.c\n    ${SOURCE_DIR}/filex_file_write_seek_test.c\n    ${SOURCE_DIR}/filex_file_write_notify_test.c\n    ${SOURCE_DIR}/filex_file_write_available_cluster_test.c\n    ${SOURCE_DIR}/filex_utility_test.c\n    ${SOURCE_DIR}/filex_utility_fat_flush_test.c)\n```\n\n----------------------------------------\n\nTITLE: Listing USB Host Stack Source Files\nDESCRIPTION: This code snippet lists the C source files that make up the USB host stack for the STM32CubeH5 project. Each file corresponds to a specific module or functionality within the USB host stack, such as stack initialization, transfer management, utility functions, and thread management. The C files contain the implementation details for the respective USB host functionalities.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/common/core/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_role_swap.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_transfer_request.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_transfer_request_abort.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_transfer_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_host_stack_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_system_error_handler.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_system_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_system_tasks_run.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_system_uninitialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_trace_event_insert.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_trace_event_update.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_trace_object_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_trace_object_unregister.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_debug_callback_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_debug_log.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_delay_ms.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_descriptor_pack.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_descriptor_parse.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_error_callback_register.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_event_flags_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_event_flags_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_event_flags_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_event_flags_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_long_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_long_get_big_endian.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_long_put.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_long_put_big_endian.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_allocate_add_safe.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_allocate_mulc_safe.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_allocate_mulv_safe.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_compare.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_copy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_free.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_free_block_best_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_byte_pool_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_byte_pool_search.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_memory_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_mutex_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_mutex_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_mutex_off.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_mutex_on.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_pci_class_scan.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_pci_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_pci_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_physical_address.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_semaphore_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_semaphore_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_semaphore_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_semaphore_put.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_set_interrupt_handler.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_short_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_short_get_big_endian.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_short_put.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_short_put_big_endian.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_string_length_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_string_length_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_string_to_unicode.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_thread_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_thread_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_thread_identify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_thread_relinquish.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_thread_resume.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_thread_schedule_other.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_thread_sleep.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_thread_suspend.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_timer_create.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_timer_delete.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_unicode_to_string.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/ux_utility_virtual_address.c\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories for Architecture and Toolchain\nDESCRIPTION: Adds subdirectories based on the THREADX_ARCH and THREADX_TOOLCHAIN variables. These subdirectories contain port-specific configurations and build settings. The common_smp subdirectory is added for common code shared across architectures and toolchains.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/ports_smp/${THREADX_ARCH}/${THREADX_TOOLCHAIN})\n\n# Pick up the common stuff\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/common_smp)\n```\n\n----------------------------------------\n\nTITLE: Installing Executables in CMake\nDESCRIPTION: This snippet installs the executables defined in the `executables` list to the `bin` directory. It also sets the file permissions for the installed executables to allow read, write, and execute permissions for the owner, read and execute permissions for the group, and read and execute permissions for others.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/x509/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(TARGETS ${executables}\n        DESTINATION \"bin\"\n        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n```\n\n----------------------------------------\n\nTITLE: Define Conditional Source Function CMake\nDESCRIPTION: Defines a CMake function `target_sources_if_not_overridden` that conditionally adds a source file to the target `PROJECT_NAME`.  It checks if the filename is present in the `TX_SRC_OVERRIDES` list. If not found, it adds the file to the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/common_smp/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(target_sources_if_not_overridden filename)\n    list(FIND TX_SRC_OVERRIDES ${filename} OVERRIDE_FOUND)\n    if( OVERRIDE_FOUND EQUAL -1 )\n        # message(STATUS \"** Using original ${filename} from common/src **\")\n        target_sources(${PROJECT_NAME} PRIVATE ${CURRENT_DIR}/src/${filename})\n    endif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: CPI Divider Configuration\nDESCRIPTION: This parameter sets the divider used for calculating the Cycles Per Instruction (CPI). It's an integer value that can be configured at runtime. Default value is '0x1'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/ARMCM0_config.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\narmcortexm0ct.cpi_div=1\n```\n\n----------------------------------------\n\nTITLE: Set CMake Minimum Required Version\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.13 and configures CMake policies for compatibility and desired behavior. These policies ensure that the project behaves consistently across different CMake versions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\ncmake_policy(SET CMP0077 NEW)\n```\n\n----------------------------------------\n\nTITLE: Build All Examples (PowerShell)\nDESCRIPTION: This command executes the azrtos_cicd.ps1 script with the -build parameter. It compiles all examples listed in the default database (azrtos_cicd.csv). The pwsh -Command prefix ensures the command runs correctly from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -build\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Target Dependency CMake\nDESCRIPTION: This CMake snippet defines a custom target to ensure that the generated C source file is created before the psa_constant_names executable is built, establishing a build dependency.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/psa/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(psa_constant_names PRIVATE ${CMAKE_CURRENT_BINARY_DIR})\nif(GEN_FILES)\n    add_custom_target(generate_psa_constant_names_generated_c\n        DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/psa_constant_names_generated.c)\n    add_dependencies(psa_constant_names generate_psa_constant_names_generated_c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Target Library and Alias\nDESCRIPTION: Creates a library target with the name defined by the PROJECT_NAME variable.  Also creates an alias for the library, allowing consumers to reference it via \"azrtos::${PROJECT_NAME}\".\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(${PROJECT_NAME})\nadd_library(\"azrtos::${PROJECT_NAME}\" ALIAS ${PROJECT_NAME})\n```\n\n----------------------------------------\n\nTITLE: Define RAM address and size for image execution in C\nDESCRIPTION: These definitions are required when RAM loading is enabled. They specify the start address and size of the RAM area where the image will be copied and executed. The platform must define these parameters for ram-load to function correctly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_10\n\nLANGUAGE: c\nCODE:\n```\n#define IMAGE_EXECUTABLE_RAM_START    <area_base_addr>\n#define IMAGE_EXECUTABLE_RAM_SIZE     <area_size_in_bytes>\n```\n\n----------------------------------------\n\nTITLE: Adding and Linking Executables in CMake\nDESCRIPTION: This snippet iterates through the `executables` list, adding each as an executable target with its corresponding `.c` file and the `mbedtls_test` object library. It then links each executable against the libraries defined in the `libs` variable and the CMAKE thread libraries, also sets the include directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/x509/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(exe IN LISTS executables)\n    add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>)\n    target_link_libraries(${exe} ${libs} ${CMAKE_THREAD_LIBS_INIT})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This snippet sets the minimum required CMake version and defines the project name and version for the ARM graphic equalizer example.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_graphic_equalizer_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: Adding Complex FFT source files (float32) in CMake\nDESCRIPTION: This snippet conditionally adds various complex FFT (CFFT) source files for float32 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR CFFT_F32_16 OR CFFT_F32_32 OR CFFT_F32_64 OR CFFT_F32_128 OR CFFT_F32_256 OR CFFT_F32_512 \n    OR CFFT_F32_1024 OR CFFT_F32_2048 OR CFFT_F32_4096)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix2_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix8_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_f32.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Display Help for azrtos_cicd.ps1 (PowerShell)\nDESCRIPTION: This command uses the Get-Help cmdlet to display the help documentation embedded within the azrtos_cicd.ps1 PowerShell script. It provides information on the script's parameters and usage. The pwsh -Command prefix is used to execute the command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command Get-Help .\\azrtos_cicd.ps1\n```\n\n----------------------------------------\n\nTITLE: RTC Clock Source Selection\nDESCRIPTION: This code snippet allows the user to select either LSE or LSI as the RTC clock source by commenting/uncommenting the appropriate #define. LSE uses a 32.768 kHz crystal while LSI is delivered by a 32 kHz RC oscillator.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples_LL/RTC/RTC_ExitStandbyWithWakeUpTimer_Init/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n        #define RTC_CLOCK_SOURCE_LSE\n        /* #define RTC_CLOCK_SOURCE_LSI */\n```\n\n----------------------------------------\n\nTITLE: Setting Target Include Directories with CMake\nDESCRIPTION: This CMake snippet sets the include directories for the specified target. It uses the `target_include_directories` command to add the `inc` directory to the include path. This allows the compiler to find header files required by the source code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/linux/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Add Compile and Link Options\nDESCRIPTION: Adds common compile options for the project, including architecture, C standard, debugging information, and compiler warnings. It also defines regression test and stack size macros. Link options are also added.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_compile_options(\n  -m32\n  -std=c99\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  -Werror\n  -DTX_REGRESSION_TEST\n  -DTEST_STACK_SIZE_PRINTF=4096\n  ${${CMAKE_BUILD_TYPE}})\nadd_link_options(-m32)\n```\n\n----------------------------------------\n\nTITLE: Enable Testing\nDESCRIPTION: Enables the testing framework within CMake.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nenable_testing()\n```\n\n----------------------------------------\n\nTITLE: Adding Complex FFT source files (float64) in CMake\nDESCRIPTION: This snippet conditionally adds various complex FFT (CFFT) source files for float64 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR CFFT_F64_16 OR CFFT_F64_32 OR CFFT_F64_64 OR CFFT_F64_128 OR CFFT_F64_256 OR CFFT_F64_512 \n    OR CFFT_F64_1024 OR CFFT_F64_2048 OR CFFT_F64_4096)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_f64.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_f64.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting SMTP Test Cases (NetXDuo)\nDESCRIPTION: Defines a set of SMTP (Simple Mail Transfer Protocol) test cases for NetXDuo. These tests cover various authentication mechanisms (NONE, LOGON), handling of EHLO messages, basic functionality, abnormal packet handling, and invalid release scenarios.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_24\n\nLANGUAGE: CMake\nCODE:\n```\nset(smtp_test_cases\n    ${SOURCE_DIR}/smtp_test/netx_smtp_auth_none_test.c\n    ${SOURCE_DIR}/smtp_test/netx_smtp_missing_last_250_EHLO_message_test.c\n    ${SOURCE_DIR}/smtp_test/netx_smtp_auth_logon_function_test.c\n    ${SOURCE_DIR}/smtp_test/netx_smtp_auth_no_type_test.c\n    ${SOURCE_DIR}/smtp_test/netx_smtp_two_packet_EHLO_auth_last_message_test.c\n    ${SOURCE_DIR}/smtp_test/netx_smtp_basic_function_test.c\n    ${SOURCE_DIR}/smtp_test/netx_smtp_two_packet_EHLO_message_test.c\n    ${SOURCE_DIR}/smtp_test/netx_smtp_abnormal_packet_test.c\n    ${SOURCE_DIR}/smtp_test/netx_smtp_invalid_release_test.c)\n```\n\n----------------------------------------\n\nTITLE: ThreadX Memory Allocation Configuration - EWARM\nDESCRIPTION: This code snippet shows how to modify the linker file for EWARM to provide memory for ThreadX dynamic memory allocation by placing the `FREE_MEM` section in the `RAM_region`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBPD/USBPD_SRC_UX_Host_MSC/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Adding MFCC source files (Q15) in CMake\nDESCRIPTION: This snippet adds MFCC (Mel-Frequency Cepstral Coefficients) source files for Q15 data type to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_28\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPTransform PRIVATE arm_mfcc_init_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_mfcc_q15.c)\n```\n\n----------------------------------------\n\nTITLE: Setting archive creation flags for AppleClang\nDESCRIPTION: This snippet overrides the archive creation and finishing commands for AppleClang compilers. This might be necessary to avoid warnings related to missing symbols when creating static libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_C_COMPILER_ID MATCHES \"AppleClang\")\n    set(CMAKE_C_ARCHIVE_CREATE   \"<CMAKE_AR> Scr <TARGET> <LINK_FLAGS> <OBJECTS>\")\n    set(CMAKE_C_ARCHIVE_FINISH   \"<CMAKE_RANLIB> -no_warning_for_no_symbols -c <TARGET>\")\nendif()\nif(CMAKE_CXX_COMPILER_ID MATCHES \"AppleClang\")\n    set(CMAKE_CXX_ARCHIVE_CREATE \"<CMAKE_AR> Scr <TARGET> <LINK_FLAGS> <OBJECTS>\")\n    set(CMAKE_CXX_ARCHIVE_FINISH \"<CMAKE_RANLIB> -no_warning_for_no_symbols -c <TARGET>\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Running the ThreadX SMP application\nDESCRIPTION: This command executes the ThreadX SMP application from the command line, requiring the application to be run with privilege due to pthread_setschedparam().\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/linux/gnu/readme_threadx.txt#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n./sample_threadx\n```\n\n----------------------------------------\n\nTITLE: Enabling Testing and Adding Subdirectories\nDESCRIPTION: This snippet enables testing using `enable_testing()` and adds subdirectories for the `netxduo` and `regression` projects, making their targets available in the current build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/crypto/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nenable_testing()\n\nset(NXD_ENABLE_FILE_SERVERS\n    OFF\n    CACHE BOOL\n          \"Includes a dependency on FileX to support 'server' protocol handlers\"\n          FORCE)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../../.. netxduo)\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/regression regression)\n```\n\n----------------------------------------\n\nTITLE: Define Executables for Entropy and Random Number Generation (CMake)\nDESCRIPTION: This snippet defines a list of executable names: `gen_entropy` and `gen_random_ctr_drbg`. These names are later used to create executable targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/random/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(executables\n    gen_entropy\n    gen_random_ctr_drbg\n)\n```\n\n----------------------------------------\n\nTITLE: Create ZIP Archive of Sources\nDESCRIPTION: This snippet configures CPack to create a ZIP archive of the FileX source code. It defines the generator, files to ignore, and includes the CPack module.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\n# Enable a build target that produces a ZIP file of all sources\nset(CPACK_SOURCE_GENERATOR \"ZIP\")\nset(CPACK_SOURCE_IGNORE_FILES\n  \\\\.git/\n  \\\\.github/\n  _build/\n  \\\\.git\n  \\\\.gitattributes\n  \\\\.gitignore\n  \".*~$\"\n)\nset(CPACK_VERBATIM_VARIABLES YES)\ninclude(CPack)\n```\n\n----------------------------------------\n\nTITLE: Define sigaddset Function Prototype in C\nDESCRIPTION: Defines the prototype for the `sigaddset` function, used for adding a signal to a signal set. It takes a pointer to a signal set and the signal number to add.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nINT                   sigaddset(sigset_t *set, int signo)\n```\n\n----------------------------------------\n\nTITLE: Adding Compile Options\nDESCRIPTION: Adds compile options such as standard, debugging information, diagnostics, and build-type specific options.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nadd_compile_options(\n  -m32\n  -std=c99\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  -Werror\n  -DFX_REGRESSION_TEST\n  ${${CMAKE_BUILD_TYPE}})\n```\n\n----------------------------------------\n\nTITLE: Conditional Compile Definitions for FFT Tables\nDESCRIPTION: Conditionally adds the ARM_ALL_FFT_TABLES compile definition if both CONFIGTABLE and ALLFFT are true. This enables the inclusion of all FFT tables during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif (CONFIGTABLE AND ALLFFT)\n    target_compile_definitions(CMSISDSPCommon PUBLIC ARM_ALL_FFT_TABLES) \nendif()\n```\n\n----------------------------------------\n\nTITLE: Modify Script Variable Value with image_macros_preprocessed_bl2.c\nDESCRIPTION: This command uses the `flash` tool to modify a variable value in a script file based on a macro found in `image_macros_preprocessed_bl2.c`. It searches for the specified macro in the file and updates the target variable in the script with its value.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_23\n\nLANGUAGE: text\nCODE:\n```\nflash --layout image_macros_preprocessed_bl2.c -m RE_BL2_BOOT_ADDRESS -b nsbootadd hardening.bat\n```\n\n----------------------------------------\n\nTITLE: Example Fingerprint Output (PowerShell)\nDESCRIPTION: This is an example of the output from the command that generates the SHA1 fingerprint of the certificate. The fingerprint is used to register the device in Azure IoT Hub.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_windows.md#_snippet_12\n\nLANGUAGE: PowerShell\nCODE:\n```\n87B4BAEE5F21CE235A887D703C66FD054AD96701\n```\n\n----------------------------------------\n\nTITLE: Clean, Build, and Test All Examples (PowerShell)\nDESCRIPTION: This command executes the azrtos_cicd.ps1 script with the -clean, -build, and -test parameters.  It first cleans, then builds, and finally tests all examples in the default database. The pwsh -Command prefix enables execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -clean -build -test\n```\n\n----------------------------------------\n\nTITLE: Configuring tx_user.h File\nDESCRIPTION: Copies or configures the tx_user.h file, allowing users to provide a custom configuration or use a default sample.  The TX_USER_FILE variable specifies the input file, and it's copied to ${CUSTOM_INC_DIR}/tx_user.h.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/threadx_smp/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif (NOT TX_USER_FILE)\n    message(STATUS \"Using default tx_user.h file\")\n    set(TX_USER_FILE ${PROJECT_DIR}/common_smp/inc/tx_user_sample.h)\nelse()\n    message(STATUS \"Using custom tx_user.h file from ${TX_USER_FILE}\")\nendif()    \nconfigure_file(${TX_USER_FILE} ${CUSTOM_INC_DIR}/tx_user.h COPYONLY)\ntarget_include_directories(${PROJECT_NAME} \n    PUBLIC \n    ${CUSTOM_INC_DIR}\n)\ntarget_compile_definitions(${PROJECT_NAME} PUBLIC \"TX_INCLUDE_USER_DEFINE_FILE\" )\n```\n\n----------------------------------------\n\nTITLE: Including Hash Subdirectory in CMake\nDESCRIPTION: This command includes the 'hash' subdirectory in the CMake build process. It enables the compilation and linking of the hash module as part of the overall project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(hash)\n```\n\n----------------------------------------\n\nTITLE: Fatal Warnings Configuration CMake\nDESCRIPTION: This snippet configures whether warnings are treated as errors. If `MBEDTLS_FATAL_WARNINGS` is enabled, the code sets the `/WX` flag for MSVC and the `-Werror` flag for Clang and GCC.  It also conditionally disables errors for specific code in `UNSAFE_BUILD` mode when using Clang or GCC, specifically for C preprocessor directives. It enables `--warnings_are_errors` for IAR.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_19\n\nLANGUAGE: cmake\nCODE:\n```\nif(MBEDTLS_FATAL_WARNINGS)\n    if(CMAKE_COMPILER_IS_MSVC)\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} /WX\")\n    endif(CMAKE_COMPILER_IS_MSVC)\n\n    if(CMAKE_COMPILER_IS_CLANG OR CMAKE_COMPILER_IS_GNU)\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Werror\")\n        if(UNSAFE_BUILD)\n            set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wno-error=cpp\")\n            set(CMAKE_C_FLAGS_ASAN \"${CMAKE_C_FLAGS_ASAN} -Wno-error=cpp\")\n            set(CMAKE_C_FLAGS_ASANDBG \"${CMAKE_C_FLAGS_ASANDBG} -Wno-error=cpp\")\n        endif(UNSAFE_BUILD)\n    endif(CMAKE_COMPILER_IS_CLANG OR CMAKE_COMPILER_IS_GNU)\n\n    if (CMAKE_COMPILER_IS_IAR)\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} --warnings_are_errors\")\n    endif(CMAKE_COMPILER_IS_IAR)\nendif(MBEDTLS_FATAL_WARNINGS)\n```\n\n----------------------------------------\n\nTITLE: Configuring CFFT Options (Single Precision) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Complex FFT (CFFT) implementations for single-precision floating-point numbers (f32) with various sizes (16 to 4096). These options are used to customize the CMSIS-DSP library by selecting specific CFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\noption(CFFT_F32_16          \"cfft f32 16\"                       OFF)\noption(CFFT_F32_32          \"cfft f32 32\"                       OFF)\noption(CFFT_F32_64          \"cfft f32 64\"                       OFF)\noption(CFFT_F32_128         \"cfft f32 128\"                      OFF)\noption(CFFT_F32_256         \"cfft f32 256\"                      OFF)\noption(CFFT_F32_512         \"cfft f32 512\"                      OFF)\noption(CFFT_F32_1024        \"cfft f32 1024\"                     OFF)\noption(CFFT_F32_2048        \"cfft f32 2048\"                     OFF)\noption(CFFT_F32_4096        \"cfft f32 4096\"                     OFF)\n```\n\n----------------------------------------\n\nTITLE: Define CMSISDSPStatistics Library and Source Files\nDESCRIPTION: This snippet defines a static library named `CMSISDSPStatistics` and adds various C source files to it.  These source files implement different statistical functions such as entropy, Kullback-Leibler divergence, logsumexp, max, min, mean, power, RMS, standard deviation, variance, and absolute maximum/minimum for different data types.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/StatisticsFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(CMSISDSPStatistics STATIC)\n\ntarget_sources(CMSISDSPStatistics PRIVATE arm_entropy_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_entropy_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_kullback_leibler_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_kullback_leibler_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_logsumexp_dot_prod_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_logsumexp_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_no_idx_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_no_idx_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_no_idx_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_no_idx_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_q7.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_no_idx_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_no_idx_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_no_idx_q7.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mean_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mean_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mean_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mean_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mean_q7.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_q7.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_no_idx_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_no_idx_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_no_idx_q7.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_power_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_power_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_power_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_power_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_power_q7.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_rms_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_rms_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_rms_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_std_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_std_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_std_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_std_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_var_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_var_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_var_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_var_q31.c)\n\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_q7.c)\n\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_q7.c)\n\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_no_idx_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_no_idx_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_no_idx_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_no_idx_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_no_idx_q7.c)\n\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_no_idx_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_no_idx_f64.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_no_idx_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_no_idx_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_no_idx_q7.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mse_q7.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mse_q15.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mse_q31.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mse_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mse_f32.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mse_f64.c)\n```\n\n----------------------------------------\n\nTITLE: Setting OpenSSL Path on Windows (Not Recommended)\nDESCRIPTION: This snippet shows how to add the OpenSSL directory to the PATH environment variable on Windows. It is NOT recommended to use OpenSSL in production-level code on Windows or macOS. This is only included for demonstration purposes and should be avoided in production environments.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\n# NOT RECOMMENDED to use for production-level code.\n$env:PATH=$env:PATH + ';<FULL PATH to vcpkg>\\installed\\x64-windows-static\\tools\\openssl' # Update complete path as needed.\n```\n\n----------------------------------------\n\nTITLE: Globbing Source Files\nDESCRIPTION: This snippet uses the file(GLOB) command to find all source files matching specific patterns (e.g., *_f64.c, *_f32.c). These source files are categorized based on data types (f64, f32, f16, q31, q15, q7, u32, u16, u8).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/MatrixFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nfile(GLOB SRCF64 \"./*_f64.c\")\nfile(GLOB SRCF32 \"./*_f32.c\")\nfile(GLOB SRCF16 \"./*_f16.c\")\nfile(GLOB SRCQ31 \"./*_q31.c\")\nfile(GLOB SRCQ15 \"./*_q15.c\")\nfile(GLOB SRCQ7  \"./*_q7.c\")\n\nfile(GLOB SRCU32 \"./*_u32.c\")\nfile(GLOB SRCU16 \"./*_u16.c\")\nfile(GLOB SRCU8  \"./*_u8.c\")\n```\n\n----------------------------------------\n\nTITLE: Including FFT configuration in CMake\nDESCRIPTION: This snippet includes the FFT configuration for the CMSISDSPTransform library, making the FFT-related functions available.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(fft)\nfft(CMSISDSPTransform)\n```\n\n----------------------------------------\n\nTITLE: Define Source Sets for USB HID Class Tests\nDESCRIPTION: This snippet defines a variable `ux_class_hid_test_cases` that contains a list of C source files for USB HID (Human Interface Device) class tests. These files are located in the specified `SOURCE_DIR`. The tests cover various HID functionalities, including reports, descriptors, and device/host interactions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_hid_test_cases\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_basic_memory_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_activate_test2.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_activate_test3.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_control_request_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_initialize_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_interrupt_thread_test2.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_read_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_receiver_memory_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_receiver_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_report_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_report_set_test2.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_idle_rate_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_hid_wMaxPacketSize_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_client_register_test2.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_deactivate_test3.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_report_descriptor_get_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_report_descriptor_get_test4.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_idle_get_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_interrupt_endpoint_search_int_out_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_interrupt_endpoint_search_test2.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_keyboard_callback_test2.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_keyboard_ioctl_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_main_item_parse_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_main_item_parse_test2.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_mouse_entry_test2.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_mouse_entry_test3.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_periodic_report_start_test2.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_remote_control_activate_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_remote_control_activate_test2.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_remote_control_entry_test2.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_remote_control_entry_test3.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_report_get_test2.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_transfer_request_completed_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_deactivate_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_descriptor_parse_coverage_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_descriptor_parse_test2.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_descriptor_parse_test4.c\n    ${SOURCE_DIR}/usbx_ux_host_class_hid_descriptor_parse_test5.c\n)\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion for Sine/Cosine\nDESCRIPTION: This snippet conditionally adds the source files for sine and cosine functions to the CMSISDSPController library, depending on the configuration flags `CONFIGTABLE`, `ALLFAST`, `ARM_SIN_COS_F32` and `ARM_SIN_COS_Q31`. It adds floating-point (f32) and Q31 fixed-point versions of the functions. The check likely prevents inclusion of these source files if they are already available through other means or disabled via config.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ControllerFunctions/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_SIN_COS_F32)\ntarget_sources(CMSISDSPController PRIVATE arm_sin_cos_f32.c)\nendif()\n\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_SIN_COS_Q31)\ntarget_sources(CMSISDSPController PRIVATE arm_sin_cos_q31.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: IoTHub X509 Configuration (C)\nDESCRIPTION: These macros are used to configure the device to connect to Azure IoT Hub using an X.509 certificate for authentication. The certificate and private key must be generated and registered with the device identity in IoT Hub.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/samples/README.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n#define HOST_NAME                                   \"<Hostname from connection string>\"\n#define DEVICE_ID                                   \"<DeviceId from connection string>\"\n#define USE_DEVICE_CERTIFICATE                      1\n#define DEVICE_KEY_TYPE                             NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER /* NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER for RSA, NX_SECURE_X509_KEY_TYPE_EC_DER for ECC */\n```\n\n----------------------------------------\n\nTITLE: Include CMake Modules\nDESCRIPTION: Includes necessary CMake modules for package configuration, printing variables, and other build-related tasks. These modules provide additional functionality to the CMake build system.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(CMakePackageConfigHelpers)\ninclude(CMakePrintHelpers)\n```\n\n----------------------------------------\n\nTITLE: Pass-through MbedTLS Config Files in CMake\nDESCRIPTION: This snippet passes through the `MBEDTLS_CONFIG_FILE` and `MBEDTLS_USER_CONFIG_FILE` definitions to the Everest target.  It checks if these variables are defined and, if so, adds them as compile definitions for the target. This ensures that the Everest library uses the same configuration as MbedTLS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/everest/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(MBEDTLS_CONFIG_FILE)\n    target_compile_definitions(${everest_target}\n        PUBLIC MBEDTLS_CONFIG_FILE=\"${MBEDTLS_CONFIG_FILE}\")\nendif()\nif(MBEDTLS_USER_CONFIG_FILE)\n    target_compile_definitions(${everest_target}\n        PUBLIC MBEDTLS_USER_CONFIG_FILE=\"${MBEDTLS_USER_CONFIG_FILE}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Compile Options for USBX\nDESCRIPTION: This snippet adds compile options for the USBX project, including C standard, debugging information, diagnostics, and preprocessor definitions based on the CMAKE_BUILD_TYPE.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nadd_compile_options(\n  -std=c99\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  -DUX_USE_IO_INSTRUCTIONS\n  #-DUX_DEVICE_CLASS_DFU_CUSTOM_REQUEST_ENABLE\n  #-DUX_DEVICE_CLASS_DFU_STATUS_MODE=1\n  ${${CMAKE_BUILD_TYPE}})\n```\n\n----------------------------------------\n\nTITLE: Define Source Sets for USB CDC ECM Class Tests\nDESCRIPTION: This snippet defines a variable `ux_class_cdc_ecm_test_cases` that contains a list of C source files for USB CDC ECM (Ethernet Control Model) class tests. These files are located in the specified `SOURCE_DIR`. The tests cover various ECM functionalities and error conditions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_cdc_ecm_test_cases\n    ${SOURCE_DIR}/usbx_cdc_ecm_basic_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_basic_ipv6_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_nx_packet_chain_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_disconnect_and_reconnect_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_alternate_setting_change_to_zero_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_ecm_transmission_callback_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_bulko_transfer_arming_during_link_dn_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_bulk_out_transfer_fail_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_bulki_arm_err_dueto_link_dn_thread_wait_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_non_ip_packet_received_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_bulk_in_transfer_fail_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_thread_link_down_before_transfer_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_thread_packet_allocate_fail_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_thread_packet_append_fail_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_mac_address_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_mac_address_invalid_length_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_no_functional_descriptor_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_ecm_mac_address_get_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_bulk_in_transfer_arming_during_link_down_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_ecm_interrupt_notification_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_ecm_entry_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_bulk_in_transfer_arming_during_deactivate_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_first_interrupt_transfer_fail_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_packet_pool_create_fail_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_thread_create_fail_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_int_notification_semaphore_create_fail_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_bulk_out_semaphore_create_fail_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_host_bulk_in_semaphore_create_fail_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_control_interface_no_interrupt_endpoint_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_data_iface_non_bulko_and_non_bulki_endpt_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_basic_memory_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_data_interface_setting_select_fails_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_non_data_iface_after_zero_endpt_data_iface_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_invalid_alt_setting_after_zero_endpt_data_iface_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_default_data_interface_setting_with_endpoints_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_one_data_interface_with_no_endpoints_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_no_control_interface_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_interface_before_control_interface_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_data_interface_no_bulk_out_endpoint_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_data_interface_no_bulk_in_endpoint_test.c\n    ${SOURCE_DIR}/usbx_cdc_ecm_link_down_while_ongoing_transfers_test.c\n    ${SOURCE_DIR}/usbx_ux_host_class_cdc_ecm_write_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_ecm_activate_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_ecm_bulkin_thread_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_ecm_bulkout_thread_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_ecm_control_request_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_ecm_change_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_ecm_entry_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_ecm_deactivate_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_ecm_initialize_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_ecm_interrupt_thread_test.c\n    ${SOURCE_DIR}/usbx_ux_device_class_cdc_ecm_uninitialize_test.c)\n```\n\n----------------------------------------\n\nTITLE: Including AES Subdirectory in CMake\nDESCRIPTION: This command includes the 'aes' subdirectory in the CMake build process. It enables the compilation and linking of the AES module as part of the overall project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(aes)\n```\n\n----------------------------------------\n\nTITLE: Copying Configuration Files with CMake\nDESCRIPTION: This snippet demonstrates how to use CMake to copy configuration files from one directory to another. It first creates a directory and then uses `configure_file` with the `COPYONLY` option to duplicate the files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Use customized ux_user.h\nset(UX_USER_FILE ${CMAKE_CURRENT_SOURCE_DIR}/ux_user.h)\n\n# Copy files instead of using symlink\n# libs/ -> ../libs/\nfile(MAKE_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/libs)\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/../libs/CMakeLists.txt\n               ${CMAKE_CURRENT_SOURCE_DIR}/libs/CMakeLists.txt COPYONLY)\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/../libs/nx_user.h\n               ${CMAKE_CURRENT_SOURCE_DIR}/libs/nx_user.h COPYONLY)\n```\n\n----------------------------------------\n\nTITLE: Key Derivation Set Capacity Entry Point (C)\nDESCRIPTION: Defines the function signature for the key derivation set capacity entry point. This function is called to set the capacity of the key derivation operation, ensuring the output does not exceed a certain limit.  It takes the operation object and the capacity as input.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_15\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_key_derivation_set_capacity(\n    acme_key_derivation_operation_t *operation,\n    size_t capacity);\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This snippet uses the `target_sources` command in CMake to specify the source files for the project. It includes various source files related to ThreadX, such as `tx_iar.c` and assembly files for thread context management and interrupt control. These files are added as private sources to the target, meaning they are only used within the specified target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m7/iar/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_iar.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n    ${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_disable.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_restore.S    \n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Configure Library and DSP\nDESCRIPTION: Calls the configLib and configDsp CMake functions, passing the CMSISDSPCommon library and the ROOT variable as arguments. These functions likely configure the library and DSP-related settings based on the specified root directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nconfigLib(CMSISDSPCommon ${ROOT})\nconfigDsp(CMSISDSPCommon ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Including PSA Subdirectory in CMake\nDESCRIPTION: This command includes the 'psa' subdirectory in the CMake build process. It enables the compilation and linking of the PSA (Platform Security Architecture) cryptography module as part of the overall project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(psa)\n```\n\n----------------------------------------\n\nTITLE: Setting CMSIS-DSP paths\nDESCRIPTION: Defines the paths to the CMSIS-DSP library, using the provided ROOT directory. This allows the project to locate and include the necessary CMSIS-DSP headers and source files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: Disabling Tests in CMake Configuration\nDESCRIPTION: This snippet shows how to disable the test suites during CMake configuration if Python or Perl are not available. This prevents errors during the build process related to missing test dependencies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\ncmake -DENABLE_TESTING=Off /path/to/mbedtls_source\n```\n\n----------------------------------------\n\nTITLE: Define clock_settime Function Prototype in C\nDESCRIPTION: Defines the prototype for the `clock_settime` function, used for setting the time of a specified clock. It takes a `clockid_t` specifying the clock and a pointer to a constant `timespec` structure containing the new time.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nINT                   clock_settime(clockid_t t, const struct timespec * tspec)\n```\n\n----------------------------------------\n\nTITLE: Add Everest Library in CMake\nDESCRIPTION: This snippet creates the Everest library using CMake's `add_library` command. It specifies the source files (`everest.c`, `x25519.c`, `Hacl_Curve25519_joined.c`) that make up the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/everest/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(${everest_target}\n  library/everest.c\n  library/x25519.c\n  library/Hacl_Curve25519_joined.c)\n```\n\n----------------------------------------\n\nTITLE: Coverage Configuration\nDESCRIPTION: This snippet configures compiler and linker options for coverage builds.  If the CMAKE_BUILD_TYPE contains *_coverage then it adds the flags -fprofile-arcs and -ftest-coverage to both the compile and link options for the netxduo target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/crypto/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(netxduo PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(netxduo PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Globbing and Adding Source Files to Target in CMake\nDESCRIPTION: This CMake snippet uses the `file(GLOB)` command to find all C source files matching the pattern `./*_*.c` and stores them in the `SRC` variable.  It then uses `target_sources` to add these files as private sources to the `cmsis-nn` target. This means these sources will be compiled and linked only for the `cmsis-nn` target and not exposed to other targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/Source/ReshapeFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB SRC \"./*_*.c\")\ntarget_sources(cmsis-nn PRIVATE ${SRC})\n```\n\n----------------------------------------\n\nTITLE: Adding CMocka Test Environment\nDESCRIPTION: Adds a CMocka test environment for the `az_core_test` target. This likely sets up common resources or configurations needed for the tests to run correctly.  The specific functionality depends on the `add_cmocka_test_environment` macro's implementation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/core/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nadd_cmocka_test_environment(az_core_test)\n```\n\n----------------------------------------\n\nTITLE: Target Sources (Filtering Algorithms)\nDESCRIPTION: Adds numerous C source files implementing various filtering algorithms (Biquad, Convolution, Correlation, FIR, IIR, LMS, Levinson-Durbin) to the CMSISDSPFiltering library. These files provide the core implementations of the signal processing algorithms included in the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_32x64_init_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_32x64_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_fast_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_fast_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_init_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_init_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df1_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df2T_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df2T_f64.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df2T_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_df2T_init_f64.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_stereo_df2T_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_biquad_cascade_stereo_df2T_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_fast_opt_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_fast_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_fast_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_opt_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_opt_q7.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_partial_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_partial_fast_opt_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_partial_fast_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_partial_fast_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_partial_opt_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_partial_opt_q7.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_partial_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_partial_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_partial_q7.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_conv_q7.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_f64.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_fast_opt_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_fast_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_fast_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_opt_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_opt_q7.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_correlate_q7.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_decimate_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_decimate_fast_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_decimate_fast_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_decimate_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_decimate_init_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_decimate_init_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_decimate_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_decimate_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_f64.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_fast_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_fast_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_init_f64.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_init_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_init_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_init_q7.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_interpolate_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_interpolate_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_interpolate_init_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_interpolate_init_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_interpolate_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_interpolate_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_lattice_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_lattice_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_lattice_init_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_lattice_init_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_lattice_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_lattice_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_q7.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_sparse_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_sparse_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_sparse_init_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_sparse_init_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_sparse_init_q7.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_sparse_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_sparse_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_fir_sparse_q7.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_iir_lattice_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_iir_lattice_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_iir_lattice_init_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_iir_lattice_init_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_iir_lattice_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_iir_lattice_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_init_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_init_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_norm_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_norm_init_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_norm_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_norm_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_q15.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_q31.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_levinson_durbin_f32.c)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_levinson_durbin_q31.c)\n```\n\n----------------------------------------\n\nTITLE: Running CMake to Generate Build Files\nDESCRIPTION: Runs CMake to generate the build files for the project. The '..' argument specifies that the CMakeLists.txt file is located in the parent directory, which is the root of the repository.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncmake ..\n```\n\n----------------------------------------\n\nTITLE: Setting RTSP Test Cases (NetXDuo)\nDESCRIPTION: Defines a set of RTSP (Real-Time Streaming Protocol) test cases for NetXDuo.  These tests cover API functionality, basic RTP integration, IPv6 RTP support, multicast RTP support, handling multiple requests and clients, client timeout scenarios, error response handling, and handling deletion before setup.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_23\n\nLANGUAGE: CMake\nCODE:\n```\nset(rtsp_test_cases\n    ${SOURCE_DIR}/rtsp_test/netx_rtsp_api_test.c\n    ${SOURCE_DIR}/rtsp_test/netx_rtsp_rtp_basic_test.c\n    ${SOURCE_DIR}/rtsp_test/netx_rtsp_rtp_ipv6_basic_test.c\n    ${SOURCE_DIR}/rtsp_test/netx_rtsp_rtp_multicast_test.c\n    ${SOURCE_DIR}/rtsp_test/netx_rtsp_rtp_ipv6_multicast_test.c\n    ${SOURCE_DIR}/rtsp_test/netx_rtsp_multiple_request_test.c\n    ${SOURCE_DIR}/rtsp_test/netx_rtsp_multiple_clients_test.c\n    ${SOURCE_DIR}/rtsp_test/netx_rtsp_client_timeout_test.c\n    ${SOURCE_DIR}/rtsp_test/netx_rtsp_error_response_test.c\n    ${SOURCE_DIR}/rtsp_test/netx_rtsp_delete_beforehand_test.c)\n```\n\n----------------------------------------\n\nTITLE: Installing the executables (CMake)\nDESCRIPTION: Installs the executables defined in `executables_libs` and `executables_mbedcrypto` to the `bin` directory. It sets the file permissions for the installed executables to allow read, write, and execute access for the owner, read and execute access for the group, and read and execute access for the world.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(TARGETS ${executables_libs} ${executables_mbedcrypto}\n        DESTINATION \"bin\"\n        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n```\n\n----------------------------------------\n\nTITLE: List of Python dependencies\nDESCRIPTION: This snippet defines a list of python packages needed for Mbed TLS maintenance. It includes packages for CI, source code analysis (clang), and building test vectors.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/scripts/maintainer.requirements.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n-r ci.requirements.txt\n\n# For source code analyses\nclang\n\n# For building some test vectors\npycryptodomex\npycryptodome-test-vectors\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for MSRC RTOS Tests CMake\nDESCRIPTION: Defines the source file paths for the USBX MSRC test cases that require a real-time operating system (RTOS). These tests are designed to be run within an RTOS environment. They include various fixes and tests for different classes and issues.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_23\n\nLANGUAGE: CMake\nCODE:\n```\n  ${SOURCE_DIR}/usbx_msrc_66679_test.c\n  ${SOURCE_DIR}/usbx_msrc_72427_ecm_host_mac_test.c\n  ${SOURCE_DIR}/usbx_msrc_72525_host_pima_obj_handles_get_test.c\n  ${SOURCE_DIR}/usbx_msrc_72619_host_pima_stor_ids_get_test.c\n  ${SOURCE_DIR}/usbx_msrc_72526_pictbridge_dps_host_start_test.c\n  ${SOURCE_DIR}/usbx_msrc_72227_host_pima_read_test.c\n  ${SOURCE_DIR}/usbx_msrc_73386_host_storage_media_open_buffer_test.c\n  ${SOURCE_DIR}/usbx_msrc_73716_cdc_ecm_mac_get_desc_check.c\n  ${SOURCE_DIR}/usbx_msrc_73492_host_vc_header_parse.c\n  ${SOURCE_DIR}/usbx_msrc_80947_device_cdc_ecm_rx_length_less_than_14.c\n  ${SOURCE_DIR}/usbx_msrc_81024_host_cdc_ecm_rx_length_less_than_14.c\n  ${SOURCE_DIR}/usbx_msrc_80991_device_rndis_rx_length_less_than_14_test.c\n  ${SOURCE_DIR}/usbx_msrc_81251_host_hid_report_add_fail_mem_test.c\n  ${SOURCE_DIR}/usbx_msrc_81206_81225_ecm_multiple_data_reject_test.c\n  ${SOURCE_DIR}/usbx_msrc_81230_host_asix_inst_free_tests.c\n  ${SOURCE_DIR}/usbx_msrc_81231_host_prolific_inst_free_tests.c\n  ${SOURCE_DIR}/usbx_msrc_81232_host_gser_inst_free_tests.c\n  ${SOURCE_DIR}/usbx_msrc_81233_host_swar_inst_free_tests.c\n  ${SOURCE_DIR}/usbx_msrc_81112_host_cdc_ecm_endpoints_get_tests.c\n  ${SOURCE_DIR}/usbx_msrc_81142_host_storage_endpoints_get_tests.c\n  ${SOURCE_DIR}/usbx_msrc_81143_host_cdc_acm_endpoints_get_tests.c\n  ${SOURCE_DIR}/usbx_msrc_81108_pictbridge_object_parse_test.c\n  ${SOURCE_DIR}/usbx_msrc_81325_host_hid_remote_control_free_callback_test.c\n  ${SOURCE_DIR}/usbx_msrc_81326_host_hid_keyboard_free_callback_test.c\n  ${SOURCE_DIR}/usbx_msrc_81327_host_hid_mouse_free_callback_test.c\n  ${SOURCE_DIR}/usbx_msrc_81109_pictbridge_array_element_to_hexa_test.c\n  ${SOURCE_DIR}/usbx_msrc_81292_host_pima_deactivate_semaphore_test.c\n  ${SOURCE_DIR}/usbx_msrc_81323_host_pima_deactivate_no_int_ep_test.c\n  ${SOURCE_DIR}/usbx_msrc_81184_host_audio_desc_validate_test.c\n  ${SOURCE_DIR}/usbx_msrc_81426_host_audio_type_get_fail_ac_link_test.c\n  ${SOURCE_DIR}/usbx_msrc_81428_81429_host_audio_ac_search_test.c\n```\n\n----------------------------------------\n\nTITLE: Creating Symbolic Link for Git Hook (Linux)\nDESCRIPTION: This command creates a symbolic link named 'pre-push' in the .git/hooks directory, pointing to the pre-push.sh script located in the tests/git-scripts directory. This enables the pre-push git hook on Linux systems within the Mbed TLS project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/tests/git-scripts/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nln -s ../../tests/git-scripts/pre-push.sh pre-push\n```\n\n----------------------------------------\n\nTITLE: Configure Library and DSP\nDESCRIPTION: Calls the configLib and configDsp functions to further configure the CMSISDSPBasicMath library, passing the library name and ROOT variable as arguments. These functions likely perform additional configuration steps based on the overall project setup and DSP settings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/BasicMathFunctions/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nconfigLib(CMSISDSPBasicMath ${ROOT})\nconfigDsp(CMSISDSPBasicMath ${ROOT})\n```\n\n----------------------------------------\n\nTITLE: Define CMSIS-DSP Paths\nDESCRIPTION: This snippet defines the paths to the CMSIS-DSP library.  It sets the root directory and the DSP directory. ROOT is assumed to be defined on the command line during CMake invocation. This allows including the necessary modules and libraries for signal processing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_bayes_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: Conditional Wrapper Compile Definitions\nDESCRIPTION: Conditionally adds compile definitions related to wrapper functionality when the WRAPPER option is enabled. It defines the ARM_TABLE_BITREV_1024, ARM_TABLE_TWIDDLECOEF_F32_4096, ARM_TABLE_TWIDDLECOEF_Q31_4096, ARM_TABLE_TWIDDLECOEF_Q15_4096.  If ARMAC5 and DISABLEFLOAT16 are both not set then the ARM_TABLE_TWIDDLECOEF_F16_4096 is defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nif (WRAPPER)\n    target_compile_definitions(CMSISDSPCommon PUBLIC ARM_TABLE_BITREV_1024)\n    target_compile_definitions(CMSISDSPCommon PUBLIC ARM_TABLE_TWIDDLECOEF_F32_4096)\n    target_compile_definitions(CMSISDSPCommon PUBLIC ARM_TABLE_TWIDDLECOEF_Q31_4096)\n    target_compile_definitions(CMSISDSPCommon PUBLIC ARM_TABLE_TWIDDLECOEF_Q15_4096)\n    if ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\n    target_compile_definitions(CMSISDSPCommon PUBLIC ARM_TABLE_TWIDDLECOEF_F16_4096)\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This snippet initializes the CMake project, sets the minimum required CMake version, and defines the project name and version.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_dotproduct_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This CMake snippet configures the target sources for the project.  It defines the source files to be compiled into the project. The `target_sources` command adds the specified source files to the given target (`${PROJECT_NAME}`).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m33/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Set Target Sources (PRIVATE)\nDESCRIPTION: Uses the target_sources command to add source files to the CMSISDSPBasicMath library with PRIVATE visibility. This means that these source files are only used when building the library itself and are not exposed to projects that link against it.  Different data types (f32, f16, q31, q15, q7, u32, u16, u8) are handled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/BasicMathFunctions/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(CMSISDSPBasicMath PRIVATE ${SRCF32})\n\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPBasicMath PRIVATE ${SRCF16})\nendif()\n\ntarget_sources(CMSISDSPBasicMath PRIVATE ${SRCQ31})\ntarget_sources(CMSISDSPBasicMath PRIVATE ${SRCQ15})\ntarget_sources(CMSISDSPBasicMath PRIVATE ${SRCQ7})\n\ntarget_sources(CMSISDSPBasicMath PRIVATE ${SRCU32})\ntarget_sources(CMSISDSPBasicMath PRIVATE ${SRCU16})\ntarget_sources(CMSISDSPBasicMath PRIVATE ${SRCU8})\n```\n\n----------------------------------------\n\nTITLE: Configuring MbedTLS with CMake\nDESCRIPTION: This snippet uses `execute_process` to run CMake and configure Mbed TLS. It specifies the source and binary directories, disables programs and testing, enables generated files, and sets the installation prefix.  Dependencies include CMake itself.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_package_install/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(\n    COMMAND \"${CMAKE_COMMAND}\"\n        \"-H${MbedTLS_SOURCE_DIR}\"\n        \"-B${MbedTLS_BINARY_DIR}\"\n        \"-DENABLE_PROGRAMS=NO\"\n        \"-DENABLE_TESTING=NO\"\n        # Turn on generated files explicitly in case this is a release\n        \"-DGEN_FILES=ON\"\n        \"-DCMAKE_INSTALL_PREFIX=${MbedTLS_INSTALL_DIR}\")\n```\n\n----------------------------------------\n\nTITLE: Setting CMake project properties\nDESCRIPTION: This snippet sets the minimum required CMake version, sets a CMake policy, and defines the project name and language.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt_interoperability/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(regression_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Setting up Test Utility Files\nDESCRIPTION: Defines the list of utility files required for the tests. These files contain common functions, network drivers, and ciphersuite definitions used across multiple test cases.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/regression/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nset(test_utility_files\n    ${SOURCE_DIR}/nx_secure_test/netxtestcontrol.c\n    ${SOURCE_DIR}/nx_secure_test/nx_crypto_ciphersuites_regression.c\n    ${SOURCE_DIR}/test/nx_ram_network_driver_test_1500.c)\n```\n\n----------------------------------------\n\nTITLE: Install Everest Target in CMake\nDESCRIPTION: This snippet installs the Everest library target to the specified destination directory (`${CMAKE_INSTALL_LIBDIR}`). It also exports the target for use by other CMake projects via the `MbedTLSTargets` export set, and sets file permissions for the installed library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/everest/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(TARGETS ${everest_target}\n  EXPORT MbedTLSTargets\n  DESTINATION ${CMAKE_INSTALL_LIBDIR}\n  PERMISSIONS OWNER_READ OWNER_WRITE GROUP_READ WORLD_READ)\n```\n\n----------------------------------------\n\nTITLE: Clean Examples matching TX, ARM compiler v6, Cortex-A35 (PowerShell)\nDESCRIPTION: This command cleans examples matching the keywords 'TX ', 'ARM compiler v6', and 'Cortex-A35'. The pwsh -Command prefix enables the execution of the command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_25\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','ARM compiler v6','Cortex-A35' -clean\n```\n\n----------------------------------------\n\nTITLE: Defining Image Header Size\nDESCRIPTION: This defines the standard size, in bytes, of the image header structure.  The header contains metadata about the image, such as load address, image size, and flags. The size is used by the bootloader to locate the start of the image payload.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define IMAGE_HEADER_SIZE           32\n```\n\n----------------------------------------\n\nTITLE: PSA Crypto ITS Implementation Specific Test\nDESCRIPTION: This comment indicates that the following test file is specifically designed for the ITS (Internal Trusted Storage) implementation within PSA Crypto, particularly when it's layered on top of standard I/O (stdio). It relies on understanding how file names are determined based on keystore names in this particular implementation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/testing/invasive-testing.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n/* This test file is specific to the ITS implementation in PSA Crypto\n * on top of stdio. It expects to know what the stdio name of a file is\n * based on its keystore name.\n */\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories with CMake\nDESCRIPTION: This snippet sets the include directories for the STM32CubeH5 project using CMake. The `target_include_directories` command adds the project's include directory (`${CMAKE_CURRENT_LIST_DIR}/inc`) to the project's include paths. This ensures that the compiler can find the necessary header files during compilation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/ports/cortex_m3/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Memory Pool with tm_memory_pool_create in C\nDESCRIPTION: This function creates a memory pool capable of satisfying at least one 128-byte block of memory. It takes a pool_id as input and returns TM_SUCCESS if successful.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_12\n\nLANGUAGE: C\nCODE:\n```\nint  tm_memory_pool_create(int pool_id);\n```\n\n----------------------------------------\n\nTITLE: Setting FX_STANDALONE_ENABLE based on build type\nDESCRIPTION: Sets the FX_STANDALONE_ENABLE cache variable to ON if the build type contains 'standalone'. This enables FileX in standalone mode.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES \".*standalone.*\")\n  set(FX_STANDALONE_ENABLE\n      ON\n      CACHE BOOL \"Enable Filex in standalone mode\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Key Derivation Abort Function in C\nDESCRIPTION: This snippet shows the definition of the `acme_key_derivation_abort` function and the corresponding `acme_key_derivation_operation_t` type, required for drivers (prefix 'acme') that implement the `key_derivation` entry point family. The abort function is always the last entry point to be called.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\ntypedef ... acme_key_derivation_operation_t;\npsa_status_t acme_key_derivation_abort(acme_key_derivation_operation_t *operation);\n```\n\n----------------------------------------\n\nTITLE: Including Code Coverage Configuration\nDESCRIPTION: Includes a custom CMake module for setting up code coverage targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/iot/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(CheckAndIncludeCodeCov)\n```\n\n----------------------------------------\n\nTITLE: Defining Image Magic Number\nDESCRIPTION: This code defines the magic number used to identify a valid image. It's a constant that must be present in the image header for the bootloader to recognize it as a valid bootable image. Its value is a hexadecimal representation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define IMAGE_MAGIC                 0x96f3b83d\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. This ensures that the CMake scripts are compatible with the available CMake features.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/core/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: Define and Build P256-M Library\nDESCRIPTION: This snippet defines the P256-M library target, specifies its source files, and sets up include directories for both the library itself and mbedTLS. It configures the build interface to include necessary headers and the private directory for mbedTLS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/p256-m/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(p256m_target ${MBEDTLS_TARGET_PREFIX}p256m)\n\nadd_library(${p256m_target}\n    p256-m_driver_entrypoints.c\n    p256-m/p256-m.c)\n\ntarget_include_directories(${p256m_target}\n  PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>\n         $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/p256-m>\n         $<BUILD_INTERFACE:${MBEDTLS_DIR}/include>\n         $<INSTALL_INTERFACE:include>\n  PRIVATE ${MBEDTLS_DIR}/library/)\n```\n\n----------------------------------------\n\nTITLE: Python Dependencies from requirements.txt\nDESCRIPTION: Specifies that the Python dependencies are listed in the `driver.requirements.txt` file. These dependencies are necessary for (re-)generating source files in the Mbed TLS build process. The `-r` flag indicates that the file should be used to install the requirements.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/scripts/basic.requirements.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n-r driver.requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Setting the Logging Message Callback in C\nDESCRIPTION: This code snippet shows how to set the logging message callback function using `az_log_set_message_callback`. The provided function will be invoked whenever the SDK wants to send a log message.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/docs/core/README.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nvoid az_log_set_message_callback(az_log_message_fn log_message_callback);\n```\n\n----------------------------------------\n\nTITLE: Set Minimum CMake Version\nDESCRIPTION: Sets the minimum required CMake version for the project. Ensures that the project is built with a compatible CMake version.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_package/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5.1)\n```\n\n----------------------------------------\n\nTITLE: Define CMSIS-DSP Path\nDESCRIPTION: Defines the path to the CMSIS-DSP library. ROOT is assumed to be passed from command line, and is used to locate the DSP directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fir_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n```\n\n----------------------------------------\n\nTITLE: Project Definition\nDESCRIPTION: Defines the project name as CMSISDSPCommon. This sets the project's name for CMake's internal use and can be used in other CMake commands.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nproject(CMSISDSPCommon)\n```\n\n----------------------------------------\n\nTITLE: CPI Divider Configuration\nDESCRIPTION: This parameter sets the divider for calculating CPI (Cycles Per Instruction). CPI is a measure of processor performance, representing the average number of clock cycles required to execute one instruction. The default value is 0x1.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/ARMCM3_config.txt#_snippet_1\n\nLANGUAGE: Configuration\nCODE:\n```\narmcortexm3ct.cpi_div=1                               # (int   , run-time ) default = '0x1'    : divider for calculating CPI (Cycles Per Instruction)\n```\n\n----------------------------------------\n\nTITLE: PAKE Inputs Type Definition in C\nDESCRIPTION: Defines the opaque type `psa_crypto_driver_pake_inputs_t` which is used to pass inputs to a PAKE operation. The actual structure definition is implementation-specific. This structure is passed to PAKE driver entry points to provide access to the password, user ID, peer ID, and cipher suite used for the PAKE operation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_24\n\nLANGUAGE: C\nCODE:\n```\ntypedef ... psa_crypto_driver_pake_inputs_t; // implementation-specific type\n```\n\n----------------------------------------\n\nTITLE: Set up USBX project\nDESCRIPTION: This snippet defines the minimum CMake version and sets up the USBX project, specifying C and ASM as the programming languages used in the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\n\n# Set up the project\nproject(usbx\n    LANGUAGES C ASM\n)\n```\n\n----------------------------------------\n\nTITLE: RSA Public Exponent (E) Definition\nDESCRIPTION: Defines the RSA public exponent (E) as a hexadecimal string. The public exponent is typically a small prime number, commonly 65537 (0x010001). It is used for encryption and signature verification.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/rsa_priv.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nE = 010001\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories with CMake\nDESCRIPTION: This CMake snippet utilizes `target_include_directories` to add an include directory to the project. The `PUBLIC` keyword indicates that this include directory should be visible to other projects that depend on this one. `${CMAKE_CURRENT_LIST_DIR}/inc` specifies a relative path to the `inc` directory in the current list directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m4/iar/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Jinja2 Dependency with Version Constraints Based on Python Version\nDESCRIPTION: These lines define a dependency on the `Jinja2` package with version constraints based on the Python version. Jinja2 version 2.10.1 or greater is required for Python versions less than 3.10, while Jinja2 version 2.10.3 or greater is required for Python versions 3.10 and above.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/scripts/driver.requirements.txt#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nJinja2 >= 2.10.1; python_version <  '3.10'\nJinja2 >= 2.10.3; python_version >= '3.10'\n```\n\n----------------------------------------\n\nTITLE: Enable MPU Fault Generation (C)\nDESCRIPTION: This code snippet, when uncommented in the \"stm32_mpu.c\" file, triggers an MPU memory fault exception due to an access right error. It attempts to write to a privileged read-only memory location, causing the fault.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples/CORTEX/CORTEXM_MPU/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n//PrivilegedReadOnlyArray[0] = 'e';\n```\n\n----------------------------------------\n\nTITLE: Build Examples Matching 'Modules' and 'IAR' (PowerShell)\nDESCRIPTION: This command uses the azrtos_cicd.ps1 script with the -MatchName parameter to build examples that match either 'Modules' or 'IAR' in their name.  The pwsh -Command prefix is used for executing this command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_6\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchName 'Modules','IAR' -build\n```\n\n----------------------------------------\n\nTITLE: Clean Examples matching TX, ARM compiler v6, SMP (PowerShell)\nDESCRIPTION: This command cleans all examples matching the keywords 'TX ', 'ARM compiler v6', and 'SMP'.  These examples are likely ThreadX examples for SMP (Symmetric Multiprocessing) using ARM compiler v6. The pwsh -Command prefix is used to execute the script from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_17\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','ARM compiler v6','SMP' -clean\n```\n\n----------------------------------------\n\nTITLE: Enabling Driver via Make (Makefile)\nDESCRIPTION: This snippet demonstrates how to enable a custom driver by defining a driver-specific macro at compile time using Make. The `CFLAGS` variable is used to pass the definition to the compiler, ensuring that the driver's code is included in the build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-driver-example-and-guide.md#_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\nmake CFLAGS=\"-DDRIVER_PREFIX_ENABLED\"\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This snippet sets the minimum CMake version, sets a CMake policy, and defines the project name. It also retrieves the absolute path of the source directory. This sets up the basic CMake project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/regression/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(regression_test LANGUAGES C)\n\nget_filename_component(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../regression\n                       ABSOLUTE)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Configuration\nDESCRIPTION: This snippet sets up the CMSIS-NN project using CMake. It defines the minimum required CMake version, sets the project name to CMSISNN, defines a variable CMSIS_PATH pointing to the parent directory, and optionally includes the Source subdirectory if BUILD_CMSIS_NN_FUNCTIONS is enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/NN/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.15.6)\n\nproject(CMSISNN)\n\nset(CMSIS_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/../..\")\n\noption(BUILD_CMSIS_NN_FUNCTIONS \"Build CMSIS-NN Source.\" ON)\n\nif(BUILD_CMSIS_NN_FUNCTIONS)\n    add_subdirectory(Source)\nendif()\n```\n\n----------------------------------------\n\nTITLE: CMake Minimum Version and Target Prefix Setup\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.5.1 and defines a prefix `subproject_test_` for renaming the Mbed TLS targets during the build process. This allows for easier management and avoidance of naming conflicts when Mbed TLS is integrated as a subproject.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_subproject/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5.1)\n\n# Test the target renaming support by adding a prefix to the targets built\nset(MBEDTLS_TARGET_PREFIX subproject_test_)\n```\n\n----------------------------------------\n\nTITLE: Including Util Subdirectory in CMake\nDESCRIPTION: This command includes the 'util' subdirectory in the CMake build process. It enables the compilation and linking of the utility functions module as part of the overall project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(util)\n```\n\n----------------------------------------\n\nTITLE: Adding MFCC source files (float32) in CMake\nDESCRIPTION: This snippet adds MFCC (Mel-Frequency Cepstral Coefficients) source files for float32 data type to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_26\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPTransform PRIVATE arm_mfcc_init_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_mfcc_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version and Project\nDESCRIPTION: This snippet sets the minimum required CMake version and defines the project name with C as the language. This ensures that the CMake version used is compatible and defines the project's basic properties.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/hub/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.10)\n\nproject (az_iot_hub_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This snippet sets the minimum required CMake version, defines project policies, and declares the project name with C as the language. It also defines build configurations and makes them available to the user.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/ptp/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\ncmake_policy(SET CMP0077 NEW)\n\nproject(web_test LANGUAGES C)\n\n# Set build configurations\nset(BUILD_CONFIGURATIONS default_build_coverage\n                         gptp_slave_build\n                         gptp_master_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n\nif(NOT PRODUCT)\n  set(PRODUCT netxduo)\nendif()\n\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: Adding Everest Subdirectory\nDESCRIPTION: This CMake command adds the 'everest' subdirectory to the current CMake project.  CMake will look for a CMakeLists.txt file within the 'everest' directory and process it as part of the build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(everest)\n```\n\n----------------------------------------\n\nTITLE: EchoTool command line usage example\nDESCRIPTION: This is an example of how to use the EchoTool utility from the command line.  It specifies the protocol (tcp) and the server port to connect to.  The example connects to port 6000.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_TCP_Echo_Client/README.md#_snippet_4\n\nLANGUAGE: other\nCODE:\n```\nc:\\> .\\echotool.exe /p tcp /s <TCP_SERVER_PORT>\n\nExample : c:\\> .\\echotool.exe /p tcp /s 6000\n```\n\n----------------------------------------\n\nTITLE: Deploy test resources using a provisioner application (PowerShell)\nDESCRIPTION: This example demonstrates how to deploy test resources using a provisioner application for authentication.  This allows the script to be executed with a different principal than the caller. It sets parameters such as BaseName, ServiceDirectory, SubscriptionId, ResourceGroupName, Location, ProvisionerApplicationId, ProvisionerApplicationSecret, TestApplicationId, TestApplicationOid and TestApplicationSecret.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\nNew-TestResources.ps1 `\n    -BaseName 'azsdk' `\n    -ServiceDirectory 'keyvault' `\n    -SubscriptionId 'REPLACE_WITH_SUBSCRIPTION_ID' `\n    -ResourceGroupName 'REPLACE_WITH_NAME_FOR_RESOURCE_GROUP' `\n    -Location 'eastus' `\n    -ProvisionerApplicationId 'REPLACE_WITH_PROVISIONER_APPLICATION_ID' `\n    -ProvisionerApplicationSecret 'REPLACE_WITH_PROVISIONER_APPLICATION_ID' `\n    -TestApplicationId 'REPLACE_WITH_TEST_APPLICATION_ID' `\n    -TestApplicationOid 'REPLACE_WITH_TEST_APPLICATION_OBJECT_ID' `\n    -TestApplicationSecret 'REPLACE_WITH_TEST_APPLICATION_SECRET'\n```\n\n----------------------------------------\n\nTITLE: Set Minimum CMake Version\nDESCRIPTION: Specifies the minimum required version of CMake for the project. This ensures that the CMake features used in the build script are supported.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.5.1)\n```\n\n----------------------------------------\n\nTITLE: Configuration-Specific Definitions\nDESCRIPTION: Defines variables that hold compiler flags specific to different build configurations.  These flags are then used later in the `add_compile_options` command.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(default_build_coverage \"\")\nset(disable_notify_callbacks_build -DTX_DISABLE_NOTIFY_CALLBACKS)\nset(stack_checking_build -DTX_ENABLE_STACK_CHECKING)\nset(stack_checking_rand_fill_build -DTX_ENABLE_STACK_CHECKING -DTX_ENABLE_RANDOM_NUMBER_STACK_FILLING)\nset(trace_build -DTX_ENABLE_EVENT_TRACE)\n```\n\n----------------------------------------\n\nTITLE: Defining Project Metadata for Package Configuration with CMake\nDESCRIPTION: This CMake snippet sets the project description and homepage URL for Mbed TLS. These values are manually defined because the minimum CMake version required for DESCRIPTION and HOMEPAGE_URL usage in the project() command is not met.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/pkgconfig/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(PKGCONFIG_PROJECT_DESCRIPTION \"Mbed TLS is a C library that implements cryptographic primitives, X.509 certificate manipulation and the SSL/TLS and DTLS protocols. Its small code footprint makes it suitable for embedded systems.\")\nset(PKGCONFIG_PROJECT_HOMEPAGE_URL \"https://www.trustedfirmware.org/projects/mbed-tls/\")\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake and Project\nDESCRIPTION: Initializes the CMake environment and defines the project name as CMSISDSPDistance. It also includes configuration files for library and DSP settings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/DistanceFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n\nproject(CMSISDSPDistance)\n\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: C ISR Template for ThreadX on Cortex-M0\nDESCRIPTION: This C code snippet shows the basic structure for creating an Interrupt Service Routine (ISR) within the ThreadX environment on a Cortex-M0 processor. It demonstrates the required function signature and a placeholder for the ISR's processing logic. It assumes the ISR entry is already present in the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/ac6/readme_threadx.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid    your_C_isr(void)\n{\n\n    /* ISR processing goes here, including any needed function calls.  */\n}\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker File Configuration for ThreadX Memory\nDESCRIPTION: This snippet shows the required modification in the EWARM linker file (.icf) to allocate memory for ThreadX.  It specifies where the 'FREE_MEM' section should be placed in the 'RAM_region'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_Thread_MsgQueue/README.md#_snippet_0\n\nLANGUAGE: linker script\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Add Static Library\nDESCRIPTION: Adds a static library named CMSISDSPCommon and specifies the source files to be included in the library. arm_common_tables.c and arm_common_tables_f16.c are the source files for this library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(CMSISDSPCommon STATIC arm_common_tables.c arm_common_tables_f16.c)\n```\n\n----------------------------------------\n\nTITLE: Setting up Source Code Archive Generation\nDESCRIPTION: This snippet configures CPack to generate a ZIP archive of the source code. It specifies the generator as ZIP, defines a list of files and directories to ignore, and sets the `CPACK_VERBATIM_VARIABLES` option to YES. Finally, it includes the CPack module to enable the packaging process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n# Enable a build target that produces a ZIP file of all sources\nset(CPACK_SOURCE_GENERATOR \"ZIP\")\nset(CPACK_SOURCE_IGNORE_FILES\n  \\.git/\n  \\.github/\n  _build/\n  \\.git\n  \\.gitattributes\n  \\.gitignore\n  \".*~$\"\n)\nset(CPACK_VERBATIM_VARIABLES YES)\ninclude(CPack)\n```\n\n----------------------------------------\n\nTITLE: Adding Compile Options for NetXDuo\nDESCRIPTION: This snippet adds compile options specifically for the 'netxduo' target, including treating warnings as errors, enabling various warnings, setting the message length, using signed characters, enabling function and data sections, and more.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/ptp/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(\n  netxduo\n  PRIVATE -Werror\n          -Wall\n          -Wextra\n          -pedantic\n          -fmessage-length=0\n          -fsigned-char\n          -ffunction-sections\n          -fdata-sections\n          -Wunused\n          -Wuninitialized\n          -Wmissing-declarations\n          -Wconversion\n          -Wpointer-arith\n          -Wshadow\n          -Wlogical-op\n          -Waggregate-return\n          -Wfloat-equal)\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler and Building After Cache Removal\nDESCRIPTION: This snippet sets the compiler via the CC environment variable and then runs CMake and Make after removing the cache. This ensures that changes to the compiler are applied correctly.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\nCC=your_cc cmake .\nmake\n```\n\n----------------------------------------\n\nTITLE: Configure Library and DSP Settings\nDESCRIPTION: This snippet calls custom configuration functions `configLib` and `configDsp` to set up library-specific and DSP-specific configurations.  It also defines the include directories for the library, allowing access to the header files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/StatisticsFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nconfigLib(CMSISDSPStatistics ${ROOT})\nconfigDsp(CMSISDSPStatistics ${ROOT})\n\n### Includes\ntarget_include_directories(CMSISDSPStatistics PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Semihosting Enable Configuration\nDESCRIPTION: This parameter enables or disables semihosting SVC traps. Applications not utilizing semihosting must set this parameter to '0'. This setting affects how the application interacts with the host system during debugging.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_graphic_equalizer_example/ARMCM3_config.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\narmcortexm3ct.semihosting-enable=0\n```\n\n----------------------------------------\n\nTITLE: Setting up library dependencies for Haiku\nDESCRIPTION: This snippet adds `network` to the list of libraries to link against when building on Haiku. This library is necessary for network functions on Haiku.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(HAIKU)\n    set(libs ${libs} network)\nendif(HAIKU)\n```\n\n----------------------------------------\n\nTITLE: Adding Proxy Update to ADU Agent in C\nDESCRIPTION: This code snippet shows the prototype for adding a proxy update to the ADU agent. It allows for updating devices with updates that may be targeted at other devices and require a proxy device to perform the update. The function takes pointers to the ADU agent, manufacturer, model, and installed criteria, as well as the lengths of the manufacturer, model, and installed criteria strings.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_adu_agent.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_adu_agent_proxy_update_add(NX_AZURE_IOT_ADU_AGENT *adu_agent_ptr,\n                                             const UCHAR *manufacturer, UINT manufacturer_length,\n                                             const UCHAR *model, UINT model_length,\n                                             const UCHAR *installed_criteria, UINT installed_criteria_length,\n                                             VOID (*adu_agent_driver)(NX_AZURE_IOT_ADU_AGENT_DRIVER *));\n```\n\n----------------------------------------\n\nTITLE: Target Include Directories\nDESCRIPTION: Adds the directory \"${DSP}/Include\" as a public include directory for the CMSISDSPFiltering library. This allows other projects that link against this library to include header files from the specified directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(CMSISDSPFiltering PUBLIC \"${DSP}/Include\")\n```\n\n----------------------------------------\n\nTITLE: Creating static target names\nDESCRIPTION: If a static library is selected, this sets new variables equal to the target names.  If static and shared are selected, it appends `_static` to the static names.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_14\n\nLANGUAGE: CMake\nCODE:\n```\nif (USE_STATIC_MBEDTLS_LIBRARY)\n    set(mbedtls_static_target    ${mbedtls_target})\n    set(mbedx509_static_target   ${mbedx509_target})\n    set(mbedcrypto_static_target ${mbedcrypto_target})\nendif()\n\nset(target_libraries ${mbedcrypto_target} ${mbedx509_target} ${mbedtls_target})\n\nif(USE_STATIC_MBEDTLS_LIBRARY AND USE_SHARED_MBEDTLS_LIBRARY)\n    string(APPEND mbedtls_static_target    \"_static\")\n    string(APPEND mbedx509_static_target   \"_static\")\n    string(APPEND mbedcrypto_static_target \"_static\")\n\n    list(APPEND target_libraries\n        ${mbedcrypto_static_target}\n        ${mbedx509_static_target}\n        ${mbedtls_static_target})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Test Cases CMake\nDESCRIPTION: This code snippet sets the `test_cases` variable based on several environment variables. It concatenates different lists of test cases depending on whether `ENABLE_64`, `DHCP_ONLY`, `DNS_ONLY`, or `PTP_ONLY` are set. If none of those environment variables are set, a default list of test cases is used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_39\n\nLANGUAGE: cmake\nCODE:\n```\nif($ENV{ENABLE_64})\n  set(test_cases ${netxduo_test_cases} ${dhcp_test_cases} ${dns_test_cases})\nelif($ENV{DHCP_ONLY})\n  set(test_cases ${dhcp_test_cases})\nelif($ENV{DNS_ONLY})\n  set(test_cases ${dns_test_cases})\nelif($ENV{PTP_ONLY})\n  set(test_cases ${ptp_test_cases})\nelse()\n  set(test_cases\n      ${auto_ip_test_cases}\n      ${bsd_test_cases}\n      ${cloud_test_cases}\n      ${dhcp_test_cases}\n      ${dns_test_cases}\n      ${ftp_test_cases}\n      ${http_test_cases}\n      ${ipsec_test_cases}\n      ${mdns_test_cases}\n      ${nat_test_cases}\n      ${netxduo_test_cases}\n      ${websocket_test_cases}\n      ${pop3_test_cases}\n      ${ppp_test_cases}\n      ${pppoe_test_cases}\n      ${ptp_test_cases}\n      ${rtp_test_cases}\n      ${rtsp_test_cases}\n      ${smtp_test_cases}\n      ${snmp_test_cases}\n      ${sntp_test_cases}\n      ${tahi_test_cases}\n      ${tahi_dhcpv6_test_cases}\n      ${telnet_test_cases}\n      ${tftp_test_cases}\n      ${tsn_test_cases})\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configure User-Defined Header File\nDESCRIPTION: This snippet configures the user-defined header file (fx_user.h). If the FX_USER_FILE variable is not set, it uses the default fx_user_sample.h file. It then copies the selected file to the custom include directory and adds that directory to the target include directories.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\n# Include the user's override file if required\nif (NOT FX_USER_FILE)\nmessage(STATUS \"Using default fx_user.h file\")\nset(FX_USER_FILE ${CMAKE_CURRENT_LIST_DIR}/common/inc/fx_user_sample.h)\nelse()\n    message(STATUS \"Using custom fx_user.h file from ${FX_USER_FILE}\")\nendif()\nconfigure_file(${FX_USER_FILE} ${CUSTOM_INC_DIR}/fx_user.h COPYONLY)\ntarget_include_directories(${PROJECT_NAME} \n    PUBLIC \n    ${CUSTOM_INC_DIR}\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Support Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the SupportFunctions subdirectory and links the CMSISDSPSupport library to the CMSISDSP interface library if the SUPPORT flag is set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_33\n\nLANGUAGE: cmake\nCODE:\n```\nif (SUPPORT)\n  add_subdirectory(SupportFunctions)\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPSupport)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Project and Version\nDESCRIPTION: Defines the project name and version. Sets the overall context for the build process and allows for versioning the generated artifacts.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_variance_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nproject (arm_variance_example VERSION 0.1)\n```\n\n----------------------------------------\n\nTITLE: Setting Build Configurations and Types\nDESCRIPTION: This snippet defines different build configurations, including those for coverage testing and authentication.  It sets the `CMAKE_CONFIGURATION_TYPES` variable to control the available build types, and ensures `CMAKE_BUILD_TYPE` is correctly set. It also prints the build type and toolchain file being used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# Set build configurations\nset(BUILD_CONFIGURATIONS default_build_coverage no_tls_build_coverage\n                         digest_authenticate_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources with CMake\nDESCRIPTION: This snippet configures the target sources for the project using the `target_sources` command in CMake. It specifies the source files that should be included in the project's build process. The `PRIVATE` keyword indicates that these sources are only used within the specified target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/ports/cortex_m85/ac6/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Set Config File Paths\nDESCRIPTION: Makes `MBEDTLS_CONFIG_FILE` and `MBEDTLS_USER_CONFIG_FILE` into FILEPATH cache variables, allowing them to be easily set by the user. These are used to specify Mbed TLS configuration files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\nset(MBEDTLS_CONFIG_FILE \"\" CACHE FILEPATH \"Mbed TLS config file (overrides default).\")\nset(MBEDTLS_USER_CONFIG_FILE \"\" CACHE FILEPATH \"Mbed TLS user config file (appended to default).\")\n```\n\n----------------------------------------\n\nTITLE: Cloning Specific Firmware Version Directly\nDESCRIPTION: Clones a specific version of the STM32CubeH5 firmware directly. Replace `vX.Y.Z` with the desired version tag. This method clones only the specified version and skips the download of previous commits, potentially saving time and bandwidth. The `--depth 1` parameter achieves this.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recursive  --depth 1 --branch vX.Y.Z https://github.com/STMicroelectronics/STM32CubeH5.git\n```\n\n----------------------------------------\n\nTITLE: Adding MbedTLS Test Library CMake\nDESCRIPTION: This snippet conditionally adds a test library (`mbedtls_test`) and associated helper libraries, and creates custom commands to generate test files. It also defines include directories and compiler definitions for the test libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_24\n\nLANGUAGE: CMake\nCODE:\n```\nif(ENABLE_TESTING OR ENABLE_PROGRAMS)\n    file(GLOB MBEDTLS_TEST_FILES\n         ${CMAKE_CURRENT_SOURCE_DIR}/tests/src/*.c\n         ${CMAKE_CURRENT_SOURCE_DIR}/tests/src/drivers/*.c)\n    add_library(mbedtls_test OBJECT ${MBEDTLS_TEST_FILES})\n    if(GEN_FILES)\n        add_custom_command(\n            OUTPUT\n                ${CMAKE_CURRENT_SOURCE_DIR}/tests/src/test_keys.h\n            WORKING_DIRECTORY\n                ${CMAKE_CURRENT_SOURCE_DIR}/tests\n            COMMAND\n                \"${MBEDTLS_PYTHON_EXECUTABLE}\"\n                \"${CMAKE_CURRENT_SOURCE_DIR}/framework/scripts/generate_test_keys.py\"\n                \"--output\"\n                \"${CMAKE_CURRENT_SOURCE_DIR}/tests/src/test_keys.h\"\n            DEPENDS\n                ${CMAKE_CURRENT_SOURCE_DIR}/framework/scripts/generate_test_keys.py\n        )\n        add_custom_target(test_keys_header DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/tests/src/test_keys.h)\n        add_custom_command(\n            OUTPUT\n                ${CMAKE_CURRENT_SOURCE_DIR}/tests/src/test_certs.h\n            WORKING_DIRECTORY\n                ${CMAKE_CURRENT_SOURCE_DIR}/tests\n            COMMAND\n                \"${MBEDTLS_PYTHON_EXECUTABLE}\"\n                \"${CMAKE_CURRENT_SOURCE_DIR}/framework/scripts/generate_test_cert_macros.py\"\n                \"--output\"\n                \"${CMAKE_CURRENT_SOURCE_DIR}/tests/src/test_certs.h\"\n            DEPENDS\n                ${CMAKE_CURRENT_SOURCE_DIR}/framework/scripts/generate_test_cert_macros.py\n        )\n        add_custom_target(test_certs_header DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/tests/src/test_certs.h)\n        add_dependencies(mbedtls_test test_keys_header test_certs_header)\n    endif()\n    target_include_directories(mbedtls_test\n        PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/tests/include\n        PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include\n        PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/library)\n    # Request C11, needed for memory poisoning tests\n    set_target_properties(mbedtls_test PROPERTIES C_STANDARD 11)\n\n    file(GLOB MBEDTLS_TEST_HELPER_FILES\n         ${CMAKE_CURRENT_SOURCE_DIR}/tests/src/test_helpers/*.c)\n    add_library(mbedtls_test_helpers OBJECT ${MBEDTLS_TEST_HELPER_FILES})\n    target_include_directories(mbedtls_test_helpers\n        PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/tests/include\n        PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include\n        PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/library\n        PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/3rdparty/everest/include)\n\n    # Pass-through MBEDTLS_CONFIG_FILE and MBEDTLS_USER_CONFIG_FILE\n    if(MBEDTLS_CONFIG_FILE)\n        target_compile_definitions(mbedtls_test\n            PUBLIC MBEDTLS_CONFIG_FILE=\"${MBEDTLS_CONFIG_FILE}\")\n        target_compile_definitions(mbedtls_test_helpers\n            PUBLIC MBEDTLS_CONFIG_FILE=\"${MBEDTLS_CONFIG_FILE}\")\n    endif()\n    if(MBEDTLS_USER_CONFIG_FILE)\n        target_compile_definitions(mbedtls_test\n            PUBLIC MBEDTLS_USER_CONFIG_FILE=\"${MBEDTLS_USER_CONFIG_FILE}\")\n        target_compile_definitions(mbedtls_test_helpers\n            PUBLIC MBEDTLS_USER_CONFIG_FILE=\"${MBEDTLS_USER_CONFIG_FILE}\")\n    endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Default FIQ Handler (Assembly)\nDESCRIPTION: This assembly code snippet shows the default FIQ (Fast Interrupt Request) handler defined in `tx_initialize_low_level.S` for ThreadX. It saves the FIQ context using `_tx_thread_fiq_context_save`, allows for application-specific FIQ handlers to be called, and then restores the FIQ context using `_tx_thread_fiq_context_restore`. The code assumes that the ThreadX library is built with TX_ENABLE_FIQ_SUPPORT defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/gnu/readme_threadx.txt#_snippet_6\n\nLANGUAGE: assembly\nCODE:\n```\n    .global __tx_fiq_handler\n    .global __tx_fiq_processing_return\n__tx_fiq_handler:\n@\n@    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return:\n@\n@    /* At this point execution is still in the FIQ mode. The CPSR, point of\n@       interrupt, and all C scratch registers are available for use.  */\n@\n@    /* Application FIQ handlers can be called here!  */\n@\n@    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: Configuring Target Sources in CMake\nDESCRIPTION: This snippet configures the private source files for the project using the `target_sources` command in CMake. The `${PROJECT_NAME}` variable represents the name of the project. Placeholders `{{BEGIN_TARGET_SOURCES}}` and `{{END_TARGET_SOURCES}}` likely denote sections where source files will be automatically inserted or managed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/ports/cortex_m7/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Default IRQ Handler in Assembly\nDESCRIPTION: This assembly code defines the default IRQ handler (__tx_irq_handler) and the return point (__tx_irq_processing_return) for standard ARM IRQ interrupts in tx_initialize_low_level.s. It saves the system context by jumping to _tx_thread_context_save, provides a space for application-specific ISR calls, and restores the system context by jumping to _tx_thread_context_restore. The handler assumes that IRQ interrupts are disabled upon return from the context save function.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac5/readme_threadx.txt#_snippet_0\n\nLANGUAGE: assembly\nCODE:\n```\nEXPORT  __tx_irq_handler\nEXPORT  __tx_irq_processing_return      \n__tx_irq_handler\n;\n;    /* Jump to context save to save system context.  */\n    B       _tx_thread_context_save             ; Jump to the context save\n__tx_irq_processing_return\n;\n;    /* At this point execution is still in the IRQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use. Note \n;       that IRQ interrupts are still disabled upon return from the context\n;       save function.  */\n;\n;    /* Application ISR call(s) go here!  */\n;\n;    /* Jump to context restore to restore system context.  */\n    B       _tx_thread_context_restore\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Build Type\nDESCRIPTION: This snippet shows how to set the CMake build type to 'Debug', which enables debug information and disables code optimization. This is useful for debugging Mbed TLS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\ncmake -D CMAKE_BUILD_TYPE=Debug /path/to/mbedtls_source\n```\n\n----------------------------------------\n\nTITLE: Include Common Files\nDESCRIPTION: This snippet adds the common files for FileX, which are located in the \"common\" subdirectory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\n# Then the common files\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/common)\n```\n\n----------------------------------------\n\nTITLE: Modify Script Variable Value with XML and Expression\nDESCRIPTION: This command uses the `flash` tool to modify a variable in a script file based on values extracted from an XML file and a mathematical expression. It filters the XML file by the `<Name>` tag to find specific values, performs a calculation using these values, and updates the specified variable in the script file with the result.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_25\n\nLANGUAGE: text\nCODE:\n```\nflash -xml OEMiRoT_Secure_Code.xml -n \"Firmware area size\" -nxml \"Firmware area size\" -e \"(val1 * val2)/0x500\" -b s_code_image ob_flash_programming.bat\n```\n\n----------------------------------------\n\nTITLE: Adding Quaternion Math Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the QuaternionMathFunctions subdirectory and links the CMSISDSPQuaternionMath library to the CMSISDSP interface library if the QUATERNIONMATH flag is set. This includes quaternion math functions in the DSP library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_27\n\nLANGUAGE: cmake\nCODE:\n```\nif (QUATERNIONMATH)\n  add_subdirectory(QuaternionMathFunctions)\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPQuaternionMath)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Clean Examples matching TXM, ARM compiler v6, Cortex M (PowerShell)\nDESCRIPTION: This command cleans all examples matching all the keywords 'TXM', 'ARM compiler v6', and 'Cortex M'. These examples are likely related to ThreadX Modules (TXM) for Cortex M using ARM compiler v6. The pwsh -Command prefix allows execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_11\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TXM','ARM compiler v6','Cortex M' -clean\n```\n\n----------------------------------------\n\nTITLE: Setting Target Sources\nDESCRIPTION: This snippet sets the source files for the arm_convolution_example executable target, marking them as PRIVATE.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_convolution_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(arm_convolution_example PRIVATE arm_convolution_example_f32.c math_helper.c)\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake and Project\nDESCRIPTION: This snippet sets the minimum required CMake version and defines the project name as CMSISDSPMatrix. It also includes configLib and configDsp, which are likely custom configuration files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/MatrixFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n\nproject(CMSISDSPMatrix)\n\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories\nDESCRIPTION: Adds subdirectories containing the ThreadX SMP library, regression tests, and example code to the build process. This organizes the project and allows CMake to manage dependencies between different parts of the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/smp/cmake/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(threadx_smp)\nadd_subdirectory(regression)\nadd_subdirectory(samples)\n```\n\n----------------------------------------\n\nTITLE: ThreadX compile options\nDESCRIPTION: Sets compile options for the ThreadX target.  `-DTX_ENABLE_EVENT_TRACE` enables event tracing, and `-DTX_LINUX_NO_IDLE_ENABLE` disables idle thread management (likely for a Linux-like environment).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/libs/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(threadx PRIVATE -DTX_ENABLE_EVENT_TRACE -DTX_LINUX_NO_IDLE_ENABLE)\n```\n\n----------------------------------------\n\nTITLE: Defining Target Sources for NAND/NOR Flash in CMake\nDESCRIPTION: This snippet uses the `target_sources` CMake command to specify the C source files that should be included when building the target. The source files are related to NAND and NOR flash memory management.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/common/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME} PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_nand_flash_simulated_driver.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/fx_nor_flash_simulator_driver.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_256byte_ecc_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_256byte_ecc_compute.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_block_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_block_data_move.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_block_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_block_mapping_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_block_status_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_close.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_data_page_copy.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_defragment.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_driver_block_erase.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_driver_block_erased_verify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_driver_block_status_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_driver_block_status_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_driver_page_erased_verify.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_erase_count_set.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_extended_cache_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_format.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_free_block_list_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_mapped_block_list_add.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_mapped_block_list_get.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_mapped_block_list_remove.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_memory_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_metadata_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_metadata_build.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_metadata_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_open.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_page_ecc_check.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_page_ecc_compute.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_partial_defragment.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_sectors_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_sectors_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_sectors_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_sector_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_sector_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_sector_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_simulator.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nand_flash_system_error.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_block_reclaim.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_close.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_defragment.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_driver_block_erase.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_driver_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_driver_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_extended_cache_enable.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_initialize.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_logical_sector_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_next_block_to_erase_find.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_open.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_partial_defragment.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_physical_sector_allocate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_sector_mapping_cache_invalidate.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_sector_read.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_sector_release.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_sector_write.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_simulator.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/lx_nor_flash_system_error.c\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Queue with tm_queue_create in C\nDESCRIPTION: This function creates a queue with a capacity to hold at least one 16-byte message. It takes a queue_id as input and returns TM_SUCCESS if successful.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nint  tm_queue_create(int queue_id);\n```\n\n----------------------------------------\n\nTITLE: Modifying XML Value with Expression (xmlval)\nDESCRIPTION: This snippet demonstrates how to modify the value of a specific XML tag based on a mathematical expression. It takes a value and constants as input and applies the provided expression. The modified value replaces the content of the specified XML tag.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nxmlval -v 0x6500 -c -S -e \"(value + cons1 + cons2)/cons3\" -cons 0x50 -cons 0x200 -cons 0x2  OEMiRoT_Secure_Code.xml\n```\n\n----------------------------------------\n\nTITLE: Disabling Test Projects\nDESCRIPTION: Allows disabling test projects via the `DISABLE_TEST` cache variable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/azure_iot/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(DISABLE_TEST\n    OFF\n    CACHE BOOL \"Disable test projects (default is OFF)\")\n```\n\n----------------------------------------\n\nTITLE: Adding and Configuring Executable Tests\nDESCRIPTION: Iterates through the `nx_secure_test_cases` list, creating an executable for each test case. The executable is linked to the `test_utility` library, and a CTest test is created to run the executable in a specific working directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/regression/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(test_case ${nx_secure_test_cases})\n  get_filename_component(test_name ${test_case} NAME_WE)\n  add_executable(${test_name} ${test_case})\n  target_link_libraries(${test_name} PRIVATE test_utility)\n  add_test(\n    NAME ${CMAKE_BUILD_TYPE}::${test_name}\n    COMMAND ${test_name}\n    WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/..)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This snippet sets the minimum required CMake version and defines the project name with C language support.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/libs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\n\nproject(libs LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: CSV file snippet after modification\nDESCRIPTION: This is the modified CSV file showing the 'OPTSR_PRG' value updated with the shifted value extracted from the XML file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_29\n\nLANGUAGE: text\nCODE:\n```\nOPTSR_PRG,0x30f0c6f8\n```\n\n----------------------------------------\n\nTITLE: Building and Installing MbedTLS with CMake\nDESCRIPTION: This snippet uses `execute_process` to build and install Mbed TLS. It calls CMake with the `--build` and `--target install` options, using the previously configured binary directory. It relies on the successful configuration from the prior snippet.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_package_install/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nexecute_process(\n    COMMAND \"${CMAKE_COMMAND}\"\n        --build \"${MbedTLS_BINARY_DIR}\"\n        --target install)\n```\n\n----------------------------------------\n\nTITLE: Create Executable for IoT PnP with Provisioning Sample\nDESCRIPTION: This snippet creates an executable named `paho_iot_pnp_with_provisioning_sample` from C files and links it against the common library.  A map file is then created.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable (paho_iot_pnp_with_provisioning_sample\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_pnp_with_provisioning_sample.c\n  ${CMAKE_CURRENT_LIST_DIR}/paho_iot_pnp_sample_common.c\n)\n\ntarget_link_libraries(paho_iot_pnp_with_provisioning_sample\n  PRIVATE\n    az::iot::sample::common\n)\n\ncreate_map_file(paho_iot_pnp_with_provisioning_sample paho_iot_pnp_with_provisioning_sample.map)\n```\n\n----------------------------------------\n\nTITLE: Project Definition\nDESCRIPTION: Defines the project name and specifies the programming languages used.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(threadx_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Skip Mbed TLS Test Build\nDESCRIPTION: This command builds the Mbed TLS library without building the tests. This is useful if Python or Perl are not installed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_3\n\nLANGUAGE: Makefile\nCODE:\n```\nmake no_test\n```\n\n----------------------------------------\n\nTITLE: Specify Source Files\nDESCRIPTION: This snippet specifies the source files for the executable `arm_dotproduct_example`. The `target_sources` command adds the `arm_dotproduct_example_f32.c` file as a private source to the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(arm_dotproduct_example PRIVATE arm_dotproduct_example_f32.c)\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Definition Example\nDESCRIPTION: This code snippet shows how to define an Interrupt Service Routine (ISR) in Assembly language for ThreadX on Cortex-M55. The ISR 'your_assembly_isr' is defined using assembly directives and includes pushing and popping registers for context preservation, followed by the interrupt handler logic and a return.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m55/ac6/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\n    .global  your_assembly_isr\n    .thumb_func\nyour_assembly_isr:\n; VOID your_assembly_isr(VOID)\n; {\n    PUSH    {r0, lr}\n;       \n;    /* Do interrupt handler work here */\n;    /* BL <your interrupt routine in C> */\n\n    POP     {r0, lr}\n    BX      lr\n; }\n```\n\n----------------------------------------\n\nTITLE: Conditional TFTP IPv6 Test Case Inclusion CMake\nDESCRIPTION: This snippet conditionally appends an IPv6 TFTP test case to the `tftp_test_cases` list.  If the `-DNX_DISABLE_IPV6` flag is not in the `CMAKE_BUILD_TYPE` list, the `netx_tftp_ipv6_basic_test.c` file is added to the TFTP test suite.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_33\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT \"-DNX_DISABLE_IPV6\" IN_LIST ${CMAKE_BUILD_TYPE})\n  list(APPEND tftp_test_cases\n       ${SOURCE_DIR}/tftp_test/netx_tftp_ipv6_basic_test.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Target Library Definition and Dependencies (CMake)\nDESCRIPTION: This snippet defines the target library, its alias, and links necessary dependencies based on the configured options.  It checks for undefined ThreadX architecture/toolchain, adds dependencies to ThreadX and FileX if standalone mode is disabled or FileX is enabled respectively.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT DEFINED THREADX_ARCH)\n    message(FATAL_ERROR \"Error: THREADX_ARCH not defined\")\nendif()\nif(NOT DEFINED THREADX_TOOLCHAIN)\n    message(FATAL_ERROR \"Error: THREADX_TOOLCHAIN not defined\")\nendif()\n\n\n# Define our target library and an alias for consumers\nadd_library(${PROJECT_NAME})\nadd_library(\"azrtos::${PROJECT_NAME}\" ALIAS ${PROJECT_NAME})\n\n# Define any required dependencies between this library and others\nif(NOT LX_STANDALONE_ENABLE)\n    target_link_libraries(${PROJECT_NAME} PUBLIC \n        \"azrtos::threadx\")\nendif()\n\nif(LX_ENABLE_FILE_SERVERS)\n    message(STATUS \"LX_ENABLE_FILE_SERVERS - defined\")\n    target_link_libraries(${PROJECT_NAME} PUBLIC \"azrtos::filex\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Secure Control Register Block\nDESCRIPTION: This snippet configures the secure control register block within the FVP MPS2 simulator, specifically for the STM32CubeH5 project. It sets parameters for Flash and SRAM block sizes (`FLASH_BLOCK_CFG`, `SRAM_BLOCK_CFG`) and enables/disables watermark support for Flash and SRAM (`FLASH_WATERMARK_SUPPORTED`, `SRAM_WATERMARK_SUPPORTED`).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_module/cortex_m23/ac6/example_build/ARMCM23_TZ_config.txt#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nfvp_mps2.sse200.secure_control_register_block.FLASH_BLOCK_CFG=0x3\nfvp_mps2.sse200.secure_control_register_block.SRAM_BLOCK_CFG=0x3\nfvp_mps2.sse200.secure_control_register_block.FLASH_WATERMARK_SUPPORTED=1\nfvp_mps2.sse200.secure_control_register_block.SRAM_WATERMARK_SUPPORTED=1\n```\n\n----------------------------------------\n\nTITLE: Configuring DMA Security Modifier Behavior\nDESCRIPTION: This code configures the behavior of DMA security modifiers (dma0_securitymodifier, dma1_securitymodifier, dma2_securitymodifier) when Non-Secure (NS) transactions target Secure (S) memory space.  The `behaviour_ns_to_s` parameter is set to 0x0 for each DMA, which indicates that NS transactions to S space should be blocked. Other possible values include transmitting or converting the transaction to Secure.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_module/cortex_m23/ac6/example_build/ARMCM23_TZ_config.txt#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nfvp_mps2.dma0_securitymodifier.behaviour_ns_to_s=0x0\nfvp_mps2.dma1_securitymodifier.behaviour_ns_to_s=0x0\nfvp_mps2.dma2_securitymodifier.behaviour_ns_to_s=0x0\n```\n\n----------------------------------------\n\nTITLE: Adding Complex FFT source files (float16) in CMake\nDESCRIPTION: This snippet conditionally adds various complex FFT (CFFT) source files for float16 data type based on configuration options to the CMSISDSPTransform library.  It requires ARMAC5 not to be defined and DISABLEFLOAT16 not to be defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\nif (NOT CONFIGTABLE OR ALLFFT OR CFFT_F16_16 OR CFFT_F16_32 OR CFFT_F16_64 OR CFFT_F16_128 OR CFFT_F16_256 OR CFFT_F16_512 \n    OR CFFT_F16_1024 OR CFFT_F16_2048 OR CFFT_F16_4096)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix2_f16.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_f16.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_f16.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_f16.c)\nendif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Constant Definition Using Macros in MBedTLS\nDESCRIPTION: This snippet demonstrates the recommended way to define constants using macros in MBedTLS, especially when the constant is used in multiple functions or locations throughout the code.  It provides an example of defining the length of the client hello random value. Using macros promotes code maintainability and reduces the risk of inconsistencies.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/tls13-support.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#define CLIENT_HELLO_RANDOM_LEN 32\n```\n\n----------------------------------------\n\nTITLE: Adding CMSIS-DSP Subdirectory\nDESCRIPTION: Adds the CMSIS-DSP library as a subdirectory to the build. This allows CMake to manage the compilation and linking of the CMSIS-DSP library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_variance_example/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Project Declaration and C Standard\nDESCRIPTION: Declares the project name as `az_iot` and sets the C standard to C99.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/iot/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nproject (az_iot LANGUAGES C)\n\nset(CMAKE_C_STANDARD 99)\n```\n\n----------------------------------------\n\nTITLE: Target Sources (Complex Multiplication by Real)\nDESCRIPTION: Includes the complex multiplication by real source files (arm_cmplx_mult_real_f32.c, arm_cmplx_mult_real_q15.c, arm_cmplx_mult_real_q31.c) in the CMSISDSPComplexMath library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ComplexMathFunctions/CMakeLists.txt#_snippet_16\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mult_real_f32.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mult_real_q15.c)\ntarget_sources(CMSISDSPComplexMath PRIVATE arm_cmplx_mult_real_q31.c)\n```\n\n----------------------------------------\n\nTITLE: FIQ Context Restore in ARM Assembly\nDESCRIPTION: This code snippet demonstrates jumping to the FIQ context restore routine in ARM assembly. This routine is responsible for restoring the system context after an FIQ interrupt has been handled. It assumes execution is currently in FIQ mode.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac6/readme_threadx.txt#_snippet_4\n\nLANGUAGE: assembly\nCODE:\n```\nB       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: Modifying Define Value from C Macro (definevalue)\nDESCRIPTION: This snippet demonstrates how to modify a define variable in a header file based on a macro value extracted from a C source file. It searches for the specified macro in the C source file and updates the corresponding variable in the header file with the macro's value.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ndefinevalue -l image_macros_preprocessed_bl2.c -m RE_IMAGE_FLASH_ADDRESS_SECURE -n FLASH_ADDRESS_SECURE rot_variables.h\n```\n\n----------------------------------------\n\nTITLE: Clean Examples matching TXM, IAR, Cortex M (PowerShell)\nDESCRIPTION: This command cleans all examples matching all the keywords 'TXM', 'IAR', and 'Cortex M'. These examples are likely related to ThreadX Modules (TXM) for Cortex M using the IAR compiler. The pwsh -Command prefix ensures execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_12\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TXM','IAR','Cortex M' -clean\n```\n\n----------------------------------------\n\nTITLE: Shared Data Base and Size Definition in C\nDESCRIPTION: Defines the base address and size of the shared memory area used for measured boot and data sharing between the bootloader and the runtime firmware. These parameters are required if either `MCUBOOT_MEASURED_BOOT` or `MCUBOOT_DATA_SHARING` options are enabled. The area must be large enough to store the TLV header and all shared data entries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_16\n\nLANGUAGE: C\nCODE:\n```\n#define MCUBOOT_SHARED_DATA_BASE    <area_base_addr>\n#define MCUBOOT_SHARED_DATA_SIZE    <area_size_in_bytes>\n```\n\n----------------------------------------\n\nTITLE: PSA API Implementation Sketch in C\nDESCRIPTION: This code snippet illustrates the general structure of a PSA API implementation in Mbed TLS. It demonstrates the pre-driver interface call processing, the call to the driver interface, and the post-driver interface call processing. The `psa_driver_wrapper_<entry_point>` function is responsible for dispatching the cryptographic operations to the appropriate PSA drivers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-crypto-implementation-structure.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t psa_api( ... )\n{\n    psa_status_t status;\n\n    /* Pre driver interface call processing: validation of arguments, building\n     * of arguments for the call to the driver interface, ... */\n\n    ...\n\n    /* Call to the driver interface */\n    status = psa_driver_wrapper_<entry_point>( ... );\n    if( status != PSA_SUCCESS )\n        return( status );\n\n    /* Post driver interface call processing: validation of the values returned\n     * by the driver, finalization of the values to return to the caller,\n     * clean-up in case of error ... */\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling IAR Thread-Safe Library Support in Linker\nDESCRIPTION: This code snippet demonstrates the linker configuration required to enable thread-safe support for the IAR library when using ThreadX. It is essential to include this line in the linker control file to ensure proper handling of thread-specific data within the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m85/iar/readme_threadx.txt#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\ninitialize by copy with packing = none { section __DLIB_PERTHREAD }; // Required in a multi-threaded application\n```\n\n----------------------------------------\n\nTITLE: Generate Configuration-Independent Files (Windows)\nDESCRIPTION: This batch script generates the configuration-independent files required for the Mbed TLS development branch on Windows systems. It executes the `make_generated_files.bat` script.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nscripts\\make_generated_files.bat\n```\n\n----------------------------------------\n\nTITLE: Setting up library dependencies for Trusted Storage\nDESCRIPTION: This snippet adds the trusted_storage library to the list of libraries to link if LINK_WITH_TRUSTED_STORAGE is set.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nif(LINK_WITH_TRUSTED_STORAGE)\n    set(libs ${libs} trusted_storage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting mbedtls library variables with CMake\nDESCRIPTION: Defines CMake variables `libs`, `executables_libs`, and `executables_mbedcrypto` to manage mbedtls libraries and executables.  `libs` stores the mbedtls target. The other two variables are lists of executable names used later for building.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(libs\n    ${mbedtls_target}\n)\n\nset(executables_libs\n    metatest\n    query_included_headers\n    selftest\n    udp_proxy\n)\n\nset(executables_mbedcrypto\n    benchmark\n    query_compile_time_config\n    zeroize\n)\n```\n\n----------------------------------------\n\nTITLE: CSV file snippet before modification\nDESCRIPTION: This code snippet shows the initial content of a CSV file before modification. The modification process uses a value extracted from an XML file and shifts its bits.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_27\n\nLANGUAGE: text\nCODE:\n```\nOPTSR_PRG,0x30f0edf8\n```\n\n----------------------------------------\n\nTITLE: Slave Board Transmit and Receive using Interrupts in C\nDESCRIPTION: The HAL_I2C_Slave_Transmit_IT() and HAL_I2C_Slave_Receive_IT() functions are used on the slave board to manage data transmission and reception through I2C communication using interrupts. These functions allow the slave to handle I2C requests asynchronously, improving the overall responsiveness of the system. The functions require the I2C handle, data buffer, and data size as input.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Examples/I2C/I2C_TwoBoards_AdvComIT/README.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nHAL_I2C_Slave_Receive_IT()\nHAL_I2C_Slave_Transmit_IT()\n```\n\n----------------------------------------\n\nTITLE: Deploy test resources with custom name and location (PowerShell)\nDESCRIPTION: This example demonstrates how to deploy test resources to Azure with a custom resource group name and location.  It sets the BaseName, ServiceDirectory, SubscriptionId, ResourceGroupName, and Location parameters. It also assumes that Connect-AzAccount has already been run to authenticate.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nConnect-AzAccount -Subscription 'REPLACE_WITH_SUBSCRIPTION_ID'\nNew-TestResources.ps1 `\n    -BaseName 'azsdk' `\n    -ServiceDirectory 'keyvault' `\n    -SubscriptionId 'REPLACE_WITH_SUBSCRIPTION_ID' `\n    -ResourceGroupName 'REPLACE_WITH_NAME_FOR_RESOURCE_GROUP' `\n    -Location 'eastus'\n```\n\n----------------------------------------\n\nTITLE: Setting Device Certificate in C\nDESCRIPTION: Sets the device certificate for the Azure IoT Provisioning client. It requires a pointer to the provisioning client and a pointer to the client's X.509 certificate. The function allows setting up a certificate chain and returns a status code.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_provisioning_client.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_provisioning_client_device_cert_set(NX_AZURE_IOT_PROVISIONING_CLIENT *prov_client_ptr,\n                                                      NX_SECURE_X509_CERT *client_x509_cert);\n```\n\n----------------------------------------\n\nTITLE: Adding Complex Math Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the ComplexMathFunctions subdirectory and links the CMSISDSPComplexMath library to the CMSISDSP interface library if the COMPLEXMATH flag is set. This enables the inclusion of complex math functionality.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_26\n\nLANGUAGE: cmake\nCODE:\n```\nif (COMPLEXMATH)\n  add_subdirectory(ComplexMathFunctions)\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPComplexMath)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Clean Examples matching TX, GCC, SMP (PowerShell)\nDESCRIPTION: This command cleans all examples matching the keywords 'TX ', 'GCC', and 'SMP'. These are likely ThreadX examples for SMP (Symmetric Multiprocessing) using the GCC compiler. The pwsh -Command prefix enables execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_19\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','GCC','SMP' -clean\n```\n\n----------------------------------------\n\nTITLE: Configuring SMSC 91c111 Ethernet Controller\nDESCRIPTION: This section configures the SMSC 91c111 Ethernet controller within the FVP MPS2 simulation environment. It includes settings for enabling/disabling the host interface connection (`enabled`), setting the MAC address (`mac_address`), and enabling/disabling promiscuous mode (`promiscuous`).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_module/cortex_m23/ac6/example_build/ARMCM23_TZ_config.txt#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nfvp_mps2.smsc_91c111.enabled=0\nfvp_mps2.smsc_91c111.mac_address=\"00:02:f7:ef:48:c5\"\nfvp_mps2.smsc_91c111.promiscuous=1\n```\n\n----------------------------------------\n\nTITLE: Setting Math Library on Unix\nDESCRIPTION: Sets the math library link flag for Unix systems.  This ensures that the math library is linked correctly when building on Unix-like platforms. It checks if the system is UNIX and if so defines `MATH_LIB_UNIX` to `m` for the math library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/core/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(MATH_LIB_UNIX \"\")\nif (UNIX)\n    set(MATH_LIB_UNIX \"m\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: XML file snippet\nDESCRIPTION: This is a snippet of an XML file containing a Name-Value pair. The 'Value' from this XML will be used to update a value in a CSV file, after being shifted.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_28\n\nLANGUAGE: xml\nCODE:\n```\n<List>\n    <Name>Product state minimal allowed</Name>\n    <Value>0xC6</Value>\n    .....\n    ....\n</List>\n```\n\n----------------------------------------\n\nTITLE: Adding Filtering Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the FilteringFunctions subdirectory and links the CMSISDSPFiltering library to the CMSISDSP interface library if the FILTERING flag is set. It also sets compile definitions for fast tables if CONFIGTABLE is enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_30\n\nLANGUAGE: cmake\nCODE:\n```\nif (FILTERING)\n  add_subdirectory(FilteringFunctions)\n  # Fast tables inclusion is allowed\n  if (CONFIGTABLE)\n    target_compile_definitions(CMSISDSPFiltering PUBLIC ARM_FAST_ALLOW_TABLES)\n  endif()\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPFiltering)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Basic Math Functions Subdirectory\nDESCRIPTION: This code snippet conditionally adds the BasicMathFunctions subdirectory and links the CMSISDSPBasicMath library to the CMSISDSP interface library if the BASICMATH flag is set. This allows for modular inclusion of basic math functions in the DSP library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_25\n\nLANGUAGE: cmake\nCODE:\n```\nif (BASICMATH)\n  add_subdirectory(BasicMathFunctions)\n  target_link_libraries(CMSISDSP INTERFACE CMSISDSPBasicMath)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Add ThreadX and FileX Libraries\nDESCRIPTION: Adds the ThreadX and FileX libraries as imported targets or as subdirectories for standalone builds. This conditional logic handles the different ways of including these libraries based on the LX_STANDALONE_ENABLE flag.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT LX_STANDALONE_ENABLE)\n    add_library(threadx SHARED IMPORTED GLOBAL)\n    add_library(\"azrtos::threadx\" ALIAS threadx)\n    set_target_properties(\n      threadx PROPERTIES IMPORTED_LOCATION\n                         ${CMAKE_BINARY_DIR}/../libs/threadx/libthreadx.so)\n    add_library(filex SHARED IMPORTED GLOBAL)\n    add_library(\"azrtos::filex\" ALIAS filex)\n    set_target_properties(filex PROPERTIES IMPORTED_LOCATION\n                   ${CMAKE_BINARY_DIR}/../libs/filex/libfilex.so)\nelse()\n    get_filename_component(\n    externals ${CMAKE_CURRENT_SOURCE_DIR} ABSOLUTE)\n    add_subdirectory(${externals}/filex filex)\n    add_library(\"azrtos::filex\" ALIAS filex)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Source Inclusion - Logarithmic Functions for Fixed-Point Types\nDESCRIPTION: Includes source files for vector logarithmic functions for q31 and q15 fixed-point data types unconditionally.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(CMSISDSPFastMath PRIVATE arm_vlog_q31.c)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_vlog_q15.c)\n```\n\n----------------------------------------\n\nTITLE: Define NetXDuo Test Cases\nDESCRIPTION: This snippet defines a CMake variable `netxduo_test_cases` containing a list of C source files. Each file represents a specific test case for NetXDuo functionality, covering areas like ICMPv6, TCP, UDP, ARP, and IPv6.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\nset(netxduo_test_cases\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_destination_table_periodic_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_send_fail_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_forward_udp_fragment_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_transmit_not_done_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_4_25_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_entry_abnormal_operation_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_udp_port_table_udpate_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_overlapping_packet_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_fragmentation_order_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_1_27_04_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_forward_tcp_test_2.c\n    ${SOURCE_DIR}/netxduo_test/netx_23_02_04_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_overlapping_packet_test_7.c\n    ${SOURCE_DIR}/netxduo_test/netx_4_27_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_socket_unbind_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_udp_branch_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_fragmentation_dispatch_fail_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_1_26_01_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_address_change_notify_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_12_20_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_12_17_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_nd_cache_under_interface_detach_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmp_invalid_source_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_client_socket_bind_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_client_packet_leak_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_8_29_01_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_3_19_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_packet_debug_info_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_ra_lifetime_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_simultaneous_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_12_04_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_hop_by_hop_fragment_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_102_23_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_wrapping_sequence_test4.c\n    ${SOURCE_DIR}/netxduo_test/netx_nd_cache_add_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_rarp_branch_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_igmp_multicast_basic_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_default_router_api_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_reset_during_send_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_packet_data_append_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_igmp_interface_indirect_report_send_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_17_17_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_out_of_window_control_packet_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_1_04_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_10_25_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_fragment_fail_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_invalid_option_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_invalid_option_test2.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_redirect_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_redirect_buffer_overwrite_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmp_ping6_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_branch_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_new_reno_algorithm_test3.c\n    ${SOURCE_DIR}/netxduo_test/netx_3_01_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_dropped_packet_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_12_25_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_delete_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_packet_allocate_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_solicitated_ra_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_fragmentation_disable_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_data_transfer_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_odd_window_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_multicast_basic_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmp_loopback_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_overlapping_packet_test_6.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_static_route_add_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_raw_nxe_api_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_4_21_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_ra_slla_changed_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_102_21_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_11_19_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_nd_cache_with_own_address_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_8_17_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_socket_relisten_test2.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_dynamic_entry_set_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_arp_dynamic_entry_timeout_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_packet_leak_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmp_tunnel_ipv6_ipv4_ping_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_tunnel_ipv4_ipv6_basic_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_1_19_02_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_fragmentation_error_test1.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_new_reno_algorithm_test1.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_interface_detachment_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_8_01_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ip_fragmentation_packet_drop_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_socket_state_wait_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_1_26_02_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_9_17_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_multicast_ping_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_multicast_ping_test1.c\n    ${SOURCE_DIR}/netxduo_test/netx_forward_tcp_test_3.c\n    ${SOURCE_DIR}/netxduo_test/netx_forward_multicast_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_tunnel_ipv4_ipv6_big_packet_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_udp_random_port_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_invalid_message_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_ipv6_packet_chain_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_ra_invalid_length_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_ra_buffer_overwrite_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_invalid_length_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_large_data_transfer_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_utility_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_ns_with_small_packet_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_ns_buffer_overwrite_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_small_packet_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_advertised_window_update_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_invalid_ra_option_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_icmpv6_too_big_buffer_overwrite_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_race_condition_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_race_condition_test2.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_socket_receive_rst_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_tcp_invalid_packet_chain_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_http_proxy_basic_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_http_proxy_non_block_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_http_proxy_multiple_response_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_http_proxy_error_response_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_http_proxy_disconnect_test.c\n    ${SOURCE_DIR}/netxduo_test/netx_http_proxy_data_fin_test.c)\n\n```\n\n----------------------------------------\n\nTITLE: Force Enable/Disable XML Command (Bash)\nDESCRIPTION: This command uses the `xmlen` tool to forcibly enable or disable an XML parameter by setting the `<Enable>` tag to a specified value (0 or 1). The command filters the XML by the `<Command>` tag, modifying the `<Enable>` tag of the matching parameters.  It requires specifying the enable value and the XML file to modify.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nxmlen -e 0 -c E OEMiRoT_Secure_Code.xml\n```\n\n----------------------------------------\n\nTITLE: Source Inclusion - Division Functions\nDESCRIPTION: Includes source files for division functions for q15 and q31 fixed-point data types.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(CMSISDSPFastMath PRIVATE arm_divide_q15.c)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_divide_q31.c)\n```\n\n----------------------------------------\n\nTITLE: Aborting ECDSA Interruptible Signature in PSA\nDESCRIPTION: Aborts an ongoing interruptible ECDSA signature operation, freeing any resources allocated. Use `psa_sign_hash_abort` to stop the operation if it is no longer needed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_34\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t status = psa_sign_hash_abort(&operation);\n```\n\n----------------------------------------\n\nTITLE: Initializing CMSISDSPTransform project with CMake\nDESCRIPTION: This snippet initializes the CMake project for the CMSISDSPTransform library, setting the minimum required CMake version and including configuration files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n\nproject(CMSISDSPTransform)\n\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: Set CMSIS-DSP Paths\nDESCRIPTION: Defines the paths to the CMSIS-DSP library by setting the ROOT and DSP variables based on the current source directory. This allows the project to find the necessary DSP library files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Needed to include the configBoot module\n# Define the path to CMSIS-DSP (ROOT is defined on command line when using cmake)\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\n# Add DSP folder to module path\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: Adding RFFT FAST source files (float64) in CMake\nDESCRIPTION: This snippet conditionally adds various Real FFT Fast (RFFT_FAST) source files for float64 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_16\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR RFFT_FAST_F64_32 OR RFFT_FAST_F64_64 OR RFFT_FAST_F64_128\n   OR RFFT_FAST_F64_256 OR RFFT_FAST_F64_512 OR RFFT_FAST_F64_1024 OR RFFT_FAST_F64_2048\n   OR RFFT_FAST_F64_4096 )\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_fast_f64.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_fast_init_f64.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Tenant ID Parameter\nDESCRIPTION: Specifies the tenant ID for a service principal when a provisioner is defined. This tenant ID is used for both the Test Application and Provisioner Application.  The value is passed to the ARM template as 'tenantId'. This parameter is essential when using a provisioner application.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nType: String\nParameter Sets: Provisioner\nAliases:\n\nRequired: True\nPosition: Named\nDefault value: None\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Linking to MbedTLS Targets CMake\nDESCRIPTION: This snippet creates an executable named `cmake_package_install` and links it against the Mbed TLS libraries (`mbedcrypto`, `mbedtls`, and `mbedx509`) using the imported targets provided by the Mbed TLS package. It assumes that the Mbed TLS package has already been located using `find_package`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_package_install/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(cmake_package_install cmake_package_install.c)\ntarget_link_libraries(cmake_package_install\n    MbedTLS::mbedcrypto MbedTLS::mbedtls MbedTLS::mbedx509)\n```\n\n----------------------------------------\n\nTITLE: Default FIQ Handler in Assembly\nDESCRIPTION: This is the default FIQ handler (__tx_fiq_handler) in tx_initialize_low_level.S, used when TX_ENABLE_FIQ_SUPPORT is defined during the build. The handler jumps to the fiq context save routine (_tx_thread_fiq_context_save) before application-specific FIQ processing.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_a7/ac6/readme_threadx.txt#_snippet_3\n\nLANGUAGE: Assembly\nCODE:\n```\n    .global __tx_fiq_handler\n    .global __tx_fiq_processing_return\n__tx_fiq_handler:\n@\n@    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return:\n@\n```\n\n----------------------------------------\n\nTITLE: Remove Test Resources using ResourceGroupName in Azure DevOps Pipeline - PowerShell\nDESCRIPTION: This example shows how to remove a resource group within an Azure DevOps pipeline. It uses the `ResourceGroupName` parameter along with `TenantId`, `ProvisionerApplicationId`, and `ProvisionerApplicationSecret` to authenticate a service principal. The `-Force` and `-Verbose` parameters are also used for automation and detailed output.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/Remove-TestResources.ps1.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nRemove-TestResources.ps1 `\n    -ResourceGroupName \"${env:AZURE_RESOURCEGROUP_NAME}\" `\n    -TenantId '$(TenantId)' `\n    -ProvisionerApplicationId '$(AppId)' `\n    -ProvisionerApplicationSecret '$(AppSecret)' `\n    -Force `\n    -Verbose `\nWhen run in the context of an Azure DevOps pipeline, this script removes the\nresource group whose name is stored in the environment variable\nAZURE_RESOURCEGROUP_NAME.\n```\n\n----------------------------------------\n\nTITLE: Statically Allocated Key Context Size - Symmetric Key\nDESCRIPTION: Illustrates how to calculate the size of a statically allocated key context for a symmetric key.  It calculates the size using `base_size`, `symmetric_factor`, and `key_bytes`, where `key_bytes` is the key size in bytes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_41\n\nLANGUAGE: C\nCODE:\n```\nbase_size + symmetric_factor * key_bytes\n```\n\n----------------------------------------\n\nTITLE: CMake Minimum Version and Policy Settings\nDESCRIPTION: This snippet sets the minimum required CMake version and configures CMake policies to ensure compatibility and consistency during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/tx/cmake/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\n```\n\n----------------------------------------\n\nTITLE: Remove Addons from Sources\nDESCRIPTION: This snippet removes source files containing 'addons' in their path from the `netxduo` target. This is done by iterating through the existing source list, filtering out any files matching the pattern, and then updating the target's source property with the filtered list.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\nget_target_property(SOURCES_LIST netxduo SOURCES)\nset(NEW_SOURCES_LIST \"\")\nforeach(SOURCE ${SOURCES_LIST})\n  if(NOT (\"${SOURCE}\" MATCHES \".*addons.*\"))\n    list(APPEND NEW_SOURCES_LIST ${SOURCE})\n  endif()\nendforeach()\nset_target_properties(netxduo PROPERTIES SOURCES \"${NEW_SOURCES_LIST}\")\n```\n\n----------------------------------------\n\nTITLE: Install Python dependencies for ROT_AppliConfig\nDESCRIPTION: This command installs the necessary Python modules for the ROT_AppliConfig tool using pip. It reads the dependencies from the requirements.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/ROT/STiROT_Appli_TrustZone/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Deriving File Paths for Generated Data\nDESCRIPTION: This snippet derives the full file paths for the generated data files, placing them in the `suites/` subdirectory of the build directory. It uses `string(REGEX REPLACE)` to prepend `suites/` to each base filename. It then uses loops to define specific file paths for bignum, config, ecp, and psa tests.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/tests/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(base_generated_data_files\n    ${base_bignum_generated_data_files} ${base_config_generated_data_files}\n    ${base_ecp_generated_data_files} ${base_psa_generated_data_files})\nstring(REGEX REPLACE \"([^;]+)\" \"suites/\\\\1\"\n       all_generated_data_files \"${base_generated_data_files}\")\nset(bignum_generated_data_files \"\")\nset(config_generated_data_files \"\")\nset(ecp_generated_data_files \"\")\nset(psa_generated_data_files \"\")\nforeach(file ${base_bignum_generated_data_files})\n    list(APPEND bignum_generated_data_files ${CMAKE_CURRENT_BINARY_DIR}/suites/${file})\nendforeach()\nforeach(file ${base_config_generated_data_files})\n    list(APPEND config_generated_data_files ${CMAKE_CURRENT_BINARY_DIR}/suites/${file})\nendforeach()\nforeach(file ${base_ecp_generated_data_files})\n    list(APPEND ecp_generated_data_files ${CMAKE_CURRENT_BINARY_DIR}/suites/${file})\nendforeach()\nforeach(file ${base_psa_generated_data_files})\n    list(APPEND psa_generated_data_files ${CMAKE_CURRENT_BINARY_DIR}/suites/${file})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Configuring Include Directories in CMake\nDESCRIPTION: This CMake snippet defines the include directories for the target named ${PROJECT_NAME}. It uses the target_include_directories command with the PUBLIC keyword to specify that the include directory should be exposed to other targets that depend on this one. This allows other parts of the project to include header files from the 'inc' directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/iar/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Complex FFT source files (Q15) in CMake\nDESCRIPTION: This snippet conditionally adds various complex FFT (CFFT) source files for Q15 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR CFFT_Q15_16 OR CFFT_Q15_32 OR CFFT_Q15_64 OR CFFT_Q15_128 OR CFFT_Q15_256 OR CFFT_Q15_512 \n    OR CFFT_Q15_1024 OR CFFT_Q15_2048 OR CFFT_Q15_4096)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix2_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_q15.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_q15.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Exclusive Monitors\nDESCRIPTION: This configuration pertains to exclusive monitors for memory regions (PSRAM, ZBTSRAM1, ZBTSRAM2) within the FVP MPS2 simulator.  It enables the component (`enable_component`), sets the number of monitors (`number_of_monitors`), configures the log2 of address granule size (`log2_granule_size`), specifies whether to monitor non-exclusive stores (`monitor_non_excl_stores`), indicates whether to match secure state (`match_secure_state`), defines the shareability domain (`shareability_domain`), and determines if access width criteria should be applied to non-exclusive stores (`apply_access_width_criteria_to_non_excl_stores`).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_module/cortex_m23/ac6/example_build/ARMCM23_TZ_config.txt#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nfvp_mps2.exclusive_monitor_psram.enable_component=1\nfvp_mps2.exclusive_monitor_psram.number_of_monitors=0x8\nfvp_mps2.exclusive_monitor_psram.log2_granule_size=0x0\nfvp_mps2.exclusive_monitor_psram.monitor_non_excl_stores=0\nfvp_mps2.exclusive_monitor_psram.match_secure_state=1\nfvp_mps2.exclusive_monitor_psram.shareability_domain=0x3\nfvp_mps2.exclusive_monitor_psram.apply_access_width_criteria_to_non_excl_stores=1\nfvp_mps2.exclusive_monitor_zbtsram1.enable_component=1\nfvp_mps2.exclusive_monitor_zbtsram1.number_of_monitors=0x8\nfvp_mps2.exclusive_monitor_zbtsram1.log2_granule_size=0x0\nfvp_mps2.exclusive_monitor_zbtsram1.monitor_non_excl_stores=0\nfvp_mps2.exclusive_monitor_zbtsram1.match_secure_state=1\nfvp_mps2.exclusive_monitor_zbtsram1.shareability_domain=0x3\nfvp_mps2.exclusive_monitor_zbtsram1.apply_access_width_criteria_to_non_excl_stores=1\nfvp_mps2.exclusive_monitor_zbtsram2.enable_component=1\nfvp_mps2.exclusive_monitor_zbtsram2.number_of_monitors=0x8\nfvp_mps2.exclusive_monitor_zbtsram2.log2_granule_size=0x0\nfvp_mps2.exclusive_monitor_zbtsram2.monitor_non_excl_stores=0\nfvp_mps2.exclusive_monitor_zbtsram2.match_secure_state=1\nfvp_mps2.exclusive_monitor_zbtsram2.shareability_domain=0x3\nfvp_mps2.exclusive_monitor_zbtsram2.apply_access_width_criteria_to_non_excl_stores=1\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories with CMake\nDESCRIPTION: This snippet adds include directories to the project using the `target_include_directories` CMake command. It sets the include directory to `${CMAKE_CURRENT_LIST_DIR}/inc` as a public include directory, allowing other targets to access header files located there.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/ports/cortex_m4/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Moving to the Next JSON Token in C\nDESCRIPTION: Reads the next token in the JSON text and updates the reader state. It requires a pointer to the reader instance. On success, it returns NX_AZURE_IOT_SUCCESS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_reader_next_token(NX_AZURE_IOT_JSON_READER *reader_ptr);\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion - Sine Functions\nDESCRIPTION: Conditionally includes source files for sine functions based on configuration flags similar to the cosine functions.  It checks if `CONFIGTABLE` is false, `ALLFAST` is true, or a specific data type's sine function (e.g., `ARM_SIN_F32`) is enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_SIN_F32)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_sin_f32.c)\nendif()\n\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_SIN_Q15)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_sin_q15.c)\nendif()\n\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_SIN_Q31)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_sin_q31.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting up MbedTLS Directory Variables CMake\nDESCRIPTION: This snippet defines variables pointing to the Mbed TLS source, installation, and binary directories, crucial for configuring and building the library within the test environment. It sets the stage for subsequent CMake commands to operate on the Mbed TLS project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_package_install/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(MbedTLS_SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../../..\")\nset(MbedTLS_INSTALL_DIR \"${CMAKE_CURRENT_BINARY_DIR}/mbedtls\")\nset(MbedTLS_BINARY_DIR \"${MbedTLS_INSTALL_DIR}${CMAKE_FILES_DIRECTORY}\")\n```\n\n----------------------------------------\n\nTITLE: Define nanosleep Function Prototype in C\nDESCRIPTION: Defines the prototype for the `nanosleep` function, used for pausing execution for a specified time. It takes pointers to `timespec` structures for the requested sleep time and the remaining sleep time (if interrupted).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nINT                   nanosleep(struct timespec *req, struct timespec *rem)\n```\n\n----------------------------------------\n\nTITLE: Shell Script Execution\nDESCRIPTION: This snippet is part of the CMake configuration, responsible for executing a shell script ('run.sh') located in the current source directory. This shell script is used to build ThreadX and FileX libraries.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/ptp/CMakeLists.txt#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n${CMAKE_CURRENT_SOURCE_DIR}/run.sh build_libs\n```\n\n----------------------------------------\n\nTITLE: Memory Copy with Poisoning Hooks in C\nDESCRIPTION: This C code snippet demonstrates a function `copy_to_user` that copies data from an input buffer to a copy buffer. It includes optional test hooks to poison and unpoison the memory before and after the `memcpy` operation, allowing for validation of memory access during testing. The hooks are enabled when `MBEDTLS_TEST_HOOKS` is defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-shared-memory.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nstatic void copy_to_user(void *copy_buffer, void *const input_buffer, size_t length) {\n#if defined(MBEDTLS_TEST_HOOKS)\n    if (memory_poison_hook != NULL) {\n        memory_poison_hook(copy_buffer, length);\n    }\n#endif\n    memcpy(copy_buffer, input_buffer, length);\n#if defined(MBEDTLS_TEST_HOOKS)\n    if (memory_unpoison_hook != NULL) {\n        memory_unpoison_hook(copy_buffer, length);\n    }\n#endif\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Installing mbedtls.pc with CMake\nDESCRIPTION: This CMake snippet configures the mbedtls.pc.in file, replacing variables with their values, and then installs the generated mbedtls.pc file into the pkgconfig directory within the library installation directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/pkgconfig/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nconfigure_file(mbedtls.pc.in mbedtls.pc @ONLY)\ninstall(FILES\n    ${CMAKE_CURRENT_BINARY_DIR}/mbedtls.pc\n    DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\n```\n\n----------------------------------------\n\nTITLE: Python Package Installation\nDESCRIPTION: This command installs the required Python packages for Mbed TLS development using pip. The `--user` flag installs the packages in the user's home directory. Omitting it installs packages system-wide.  Invoke `python` instead of `python3` if needed.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\npython3 -m pip install --user -r scripts/basic.requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories in CMake\nDESCRIPTION: This snippet shows how to add an include directory to a CMake project. The `target_include_directories` command is used to specify the `${CMAKE_CURRENT_LIST_DIR}/inc` directory as a public include directory for the target `${PROJECT_NAME}`. This makes the header files in the specified directory available to other targets that depend on this project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/common/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} \n    SYSTEM\n    PUBLIC \n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: IoT Plug and Play JSON Response\nDESCRIPTION: This JSON payload is the expected response from the device upon invoking the `getMaxMinReport` direct method. It includes the maximum, minimum, and average temperatures, along with the start and end times for the report.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/samples/README.md#_snippet_9\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"maxTemp\": 20,\n  \"minTemp\": 20,\n  \"avgTemp\": 20,\n  \"startTime\": \"<ISO8601 time>\",\n  \"endTime\": \"<ISO8601 time>\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Installing mbedcrypto.pc with CMake\nDESCRIPTION: This CMake snippet configures the mbedcrypto.pc.in file, replacing variables with their values, and then installs the generated mbedcrypto.pc file into the pkgconfig directory within the library installation directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/pkgconfig/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nconfigure_file(mbedcrypto.pc.in mbedcrypto.pc @ONLY)\ninstall(FILES\n    ${CMAKE_CURRENT_BINARY_DIR}/mbedcrypto.pc\n    DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\n```\n\n----------------------------------------\n\nTITLE: Update Test Resource Expiration\nDESCRIPTION: Updates the expiration time of a test resource group using Update-TestResources.ps1. It requires the service name and extends the deletion time.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/README.md#_snippet_5\n\nLANGUAGE: PowerShell\nCODE:\n```\nUpdate-TestResources.ps1 keyvault\n```\n\n----------------------------------------\n\nTITLE: File Naming with sprintf in stdio - C\nDESCRIPTION: Demonstrates how `sprintf` is used to construct file names for keys or non-key files in the stdio storage backend, incorporating the `PSA_ITS_STORAGE_PREFIX` and the key identifier.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/mbed-crypto-storage-specification.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nsprintf(PSA_ITS_STORAGE_PREFIX \"%016llx.psa_its\", key_id)\n```\n\n----------------------------------------\n\nTITLE: Setting compiler flags for GCC\nDESCRIPTION: This snippet sets the C compiler flags to include `-Wmissing-declarations` when the compiler is GNU GCC. This flag enables warnings for missing declarations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/library/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_COMPILER_IS_GNUCC)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wmissing-declarations\")\nendif(CMAKE_COMPILER_IS_GNUCC)\n```\n\n----------------------------------------\n\nTITLE: RSA DQ Definition\nDESCRIPTION: Defines DQ as a hexadecimal string, representing D mod (Q-1). This parameter is used in CRT (Chinese Remainder Theorem) based RSA implementations for faster decryption.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/rsa_priv.txt#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nDQ = 269CEBE6305DFEE4809377F078C814E37B45AE6677114DFC4F76F5097E1F3031D592567AC55B9B98213B40ECD54A4D2361F5FAACA1B1F51F71E4690893C4F081\n```\n\n----------------------------------------\n\nTITLE: Checking HMAC Support (Legacy API)\nDESCRIPTION: This code snippet demonstrates how to check for HMAC support in the legacy Mbed TLS API. It verifies that both message digest and SHA-256 modules are enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\n#if defined(MBEDTLS_MD_C) && defined(MBEDTLS_SHA256_C)\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Paths for CCID Class Tests CMake\nDESCRIPTION: Defines the source file paths for the USBX CCID (Circuit Card Interface Device) class test cases. These tests are designed to verify the functionality of the CCID class, which is used for smart card readers.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_25\n\nLANGUAGE: CMake\nCODE:\n```\n   ${SOURCE_DIR}/usbx_device_class_ccid_basic_tests.c\n    ${SOURCE_DIR}/usbx_device_class_ccid_busy_abort_tests.c\n    ${SOURCE_DIR}/usbx_uxe_device_ccid_test.c\n```\n\n----------------------------------------\n\nTITLE: Include GNU Install Dirs Module\nDESCRIPTION: Includes the GNUInstallDirs module, which provides standard directory variables for installation paths. This ensures consistent installation locations across different platforms.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(GNUInstallDirs)\n```\n\n----------------------------------------\n\nTITLE: Setting vcpkg environment variables\nDESCRIPTION: This snippet sets the `VCPKG_DEFAULT_TRIPLET` and `VCPKG_ROOT` environment variables, which are required for vcpkg to function correctly. `VCPKG_DEFAULT_TRIPLET` specifies the target architecture (x64-linux), and `VCPKG_ROOT` specifies the location where vcpkg is installed.  These variables must be set in each new terminal session.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_linux.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n~$ export VCPKG_DEFAULT_TRIPLET=x64-linux\n~$ export VCPKG_ROOT=~/vcpkg\n```\n\n----------------------------------------\n\nTITLE: Configure Table Inclusion\nDESCRIPTION: Defines options to control the inclusion of configuration tables. When CONFIGTABLE is ON, it allows selecting whether all interpolation or FFT tables must be included.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\noption(CONFIGTABLE          \"Configuration of table allowed\"    OFF)\n\n# When CONFIGTABLE is ON, select if all interpolation tables must be included\noption(ALLFAST              \"All interpolation tables included\" OFF)\n# When CONFIGTABLE is ON, select if all FFT tables must be included\noption(ALLFFT               \"All fft tables included\"           OFF)\n```\n\n----------------------------------------\n\nTITLE: Copyright Notice Boilerplate - Apache License 2.0\nDESCRIPTION: This snippet provides a boilerplate copyright notice for applying the Apache License 2.0 to a work. It requires replacing the bracketed fields with the copyright year and the name of the copyright owner. The text should be enclosed in appropriate comment syntax for the file format.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/NOTICE.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nCopyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Version\nDESCRIPTION: Sets the minimum required CMake version for the project. This ensures that the CMake version used to build the project is compatible with the commands and features used in the CMakeLists.txt file. The minimum required version is set to 3.10.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.10)\n```\n\n----------------------------------------\n\nTITLE: STM32 Ethernet Driver Initialization\nDESCRIPTION: This driver is based on the STM32 HAL/ETH API and facilitates communication with Ethernet hardware.  It requires the nx_stm32_phy_driver.c driver for physical layer interaction.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n**nx_stm32_eth_driver.c**\n```\n\n----------------------------------------\n\nTITLE: STM32CubeIDE Linker Script Modification for ThreadX\nDESCRIPTION: This code snippet illustrates how to modify the STM32CubeIDE linker script (.ld) to allocate memory for the ThreadX heap.  A new section, `._threadx_heap`, is defined within the `RAM_D1` region, specifying a 64KB heap size. It is crucial to place this section between `.bss` and `._user_heap_stack`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_FreeRTOS_Wrapper/README.md#_snippet_2\n\nLANGUAGE: linker\nCODE:\n```\n._threadx_heap :\n  {\n     . = ALIGN(8);\n     __RAM_segment_used_end__ = .;\n     . = . + 64K;\n     . = ALIGN(8);\n   } >RAM_D1 AT> RAM_D1\n```\n\n----------------------------------------\n\nTITLE: Activating a Simulated Interrupt Thread in C++\nDESCRIPTION: Resumes the simulated interrupt thread, allowing it to execute. This is typically done after initialization is complete and ThreadX is ready to schedule threads using the `ResumeThread` function.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/win32/vs_2019/readme_threadx.txt#_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n        ResumeThread(_sample_win32_interrupt_handle);\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation for Float16 Support\nDESCRIPTION: This snippet conditionally adds source files for Float16 support based on compiler flags. If `ARMAC5` is not defined and `DISABLEFLOAT16` is not defined, it includes Float16 versions of statistical functions such as max, min, mean, power, RMS, standard deviation, variance, entropy, Kullback-Leibler divergence, logsumexp, and absolute maximum/minimum.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/StatisticsFunctions/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_mean_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_power_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_rms_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_std_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_var_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_entropy_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_kullback_leibler_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_logsumexp_dot_prod_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_logsumexp_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_max_no_idx_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_min_no_idx_f16.c)\n\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmax_no_idx_f16.c)\ntarget_sources(CMSISDSPStatistics PRIVATE arm_absmin_no_idx_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Coverage Options\nDESCRIPTION: Sets compile and link options for code coverage if the build type includes '_coverage'.  This adds flags to enable profiling during compilation and linking.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/test/cmake/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(filex PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(filex PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting TAHI Test Cases (NetXDuo)\nDESCRIPTION: Defines a set of TAHI test cases for NetXDuo, conditionally included based on `NX_TAHI_ENABLE` and `NX_ENABLE_IPV6_PATH_MTU_DISCOVERY` build flags.  These tests appear to be specific conformance tests, likely for IPv6.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_28\n\nLANGUAGE: CMake\nCODE:\n```\nif(PRODUCT STREQUAL netxduo)\n  if(\"-DNX_TAHI_ENABLE\" IN_LIST ${CMAKE_BUILD_TYPE})\n    if(\"-DNX_ENABLE_IPV6_PATH_MTU_DISCOVERY\" IN_LIST ${CMAKE_BUILD_TYPE})\n      set(tahi_test_cases\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_15.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_40.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_12.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_33.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_18.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_16.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_15.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_22.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_5.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_35.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_19.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_09.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_16.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_7.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_03.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_04.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_05.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_10.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_10.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_01.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_05.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_11.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_29.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_34.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_2.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_39.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_10.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_04.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_12.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_1.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_3.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_02.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_01.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_20.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_02.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_37.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_5.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_42.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_13.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_11.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_21.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_41.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_06.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_09.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_4.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_6.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_32.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_24.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_14.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_06.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_07.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_17.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_30.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_07.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_27.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_9.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_31.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_28.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_14.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_13.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_38.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_25.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_11.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_08.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_4_8.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_23.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_36.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_2_03.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_08.c\n          ${SOURCE_DIR}/tahi_test/netx_tahi_test_3_26.c)\n```\n\n----------------------------------------\n\nTITLE: Initializing Ethernet MAC Address in STM32 HAL\nDESCRIPTION: This code initializes the Ethernet MAC address. It sets the MACAddr array elements with specific hexadecimal values. This is typically done during the ETH initialization process to configure the device's unique network identifier.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/NetXDuo/Nx_MQTT_Client/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid MX_ETH_Init(void)\n{\n\n  /* USER CODE BEGIN ETH_Init 0 */\n\n  /* USER CODE END ETH_Init 0 */\n\n  /* USER CODE BEGIN ETH_Init 1 */\n\n  /* USER CODE END ETH_Init 1 */\n  heth.Instance = ETH;\n  MACAddr[0] = 0x00;\n  MACAddr[1] = 0x80;\n  MACAddr[2] = 0xE1;\n  MACAddr[3] = 0x00;\n  MACAddr[4] = 0x00;\n  MACAddr[5] = 0x00;\n```\n\n----------------------------------------\n\nTITLE: Build Examples matching TX, ARM compiler v6, Cortex-A35 (PowerShell)\nDESCRIPTION: This command builds examples matching the keywords 'TX ', 'ARM compiler v6', and 'Cortex-A35'.  The pwsh -Command prefix allows execution from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_27\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','ARM compiler v6','Cortex-A35' -build\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies\nDESCRIPTION: This code snippet shows how to install the required Python modules for the ROT_AppliConfig tool using pip. These modules are necessary when switching from the default Windows executable version of the tool to the Python version.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H533RE/Templates/ROT/STiROT_Appli/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Setting Wrap Functions for Mocking\nDESCRIPTION: Conditionally sets wrap functions for mocking if `UNIT_TESTING_MOCKS` is enabled. This allows for replacing specific functions with mock implementations during unit testing, enabling better isolation and control over test execution. The `-Wl,--wrap` flag is a linker option to wrap functions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/core/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif(UNIT_TESTING_MOCKS)\n    set(WRAP_FUNCTIONS \"-Wl,--wrap=az_platform_clock_msec -Wl,--wrap=az_platform_sleep_msec\")\nelse()\n    set(WRAP_FUNCTIONS \"\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Modify Script Variable Value with XML\nDESCRIPTION: This command uses the `flash` tool to modify a variable value in a script file based on a value extracted from an XML file. It filters the XML file by the `<Name>` tag to find the desired value and updates the target variable in the script with it.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_24\n\nLANGUAGE: text\nCODE:\n```\nflash -xml OEMiRoT_Secure_Code.xml -n \"Image output file\" -b s_code_image ob_flash_programming.bat\n```\n\n----------------------------------------\n\nTITLE: Conditional Array Allocation in C\nDESCRIPTION: This code snippet demonstrates how to conditionally allocate an array based on a preprocessor macro. It checks if the `ACME_FOO_SIZE` macro is not equal to 0 before allocating the `foo` array. This is useful to prevent allocating a zero-sized array.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_55\n\nLANGUAGE: C\nCODE:\n```\n#if ACME_FOO_SIZE != 0\n    uint8_t foo[ACME_FOO_SIZE];\n#endif\n```\n\n----------------------------------------\n\nTITLE: Adding P256-M Subdirectory\nDESCRIPTION: This CMake command adds the 'p256-m' subdirectory to the current CMake project. CMake will search for a CMakeLists.txt file within the 'p256-m' directory and process it as part of the overall project build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/3rdparty/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(p256-m)\n```\n\n----------------------------------------\n\nTITLE: ARM Cortex-M3 Minimum Synchronization Level Configuration\nDESCRIPTION: This parameter forces the minimum synchronization level for debugging. The levels range from 0 (off) to 3 (postInsnAll).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/ARMCM3_config.txt#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.min_sync_level=3                        # (int   , run-time ) default = '0x0'    : force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)\n```\n\n----------------------------------------\n\nTITLE: Setting Target Sources CMake\nDESCRIPTION: This CMake snippet configures the source files for the target using `target_sources`. It defines a list of C source files within the `${CMAKE_CURRENT_LIST_DIR}/src/` directory that are to be compiled into the final executable or library. The `PRIVATE` keyword indicates that these sources are only used internally by the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/win32/vs_2019/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_initialize_low_level.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.c\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.c\n\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Adding CMSIS DSP as subdirectory\nDESCRIPTION: Adds the CMSIS DSP library as a subdirectory to the project. This makes the library's targets available for linking. The target created in the subdirectory is named bin_dsp.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_matrix_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Pre-Scheduler Initialization Macro in tx_user.h (C)\nDESCRIPTION: This code snippet defines a preprocessor definition that should be added to `tx_user.h` when auto-initialization is enabled. This prevents any other calls prior to the kernel being started by calling `vTaskStartScheduler()`\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/FreeRTOS/readme.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\n#define TX_PORT_SPECIFIC_PRE_SCHEDULER_INITIALIZATION return;\n```\n\n----------------------------------------\n\nTITLE: Append Null Azure IoT JSON Writer C\nDESCRIPTION: Appends a JSON null literal to the payload.  The function takes a pointer to the JSON writer as input. Returns NX_AZURE_IOT_SUCCESS if the null value is appended successfully.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_26\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_null(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr);\n```\n\n----------------------------------------\n\nTITLE: Adding CFFT Radix2 Init Q31 source files in CMake\nDESCRIPTION: This snippet conditionally adds arm_cfft_radix2_init_q31.c as a private source files to the CMSISDSPTransform library if WRAPPER is defined or ARM_CFFT_RADIX2_Q31 is defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_23\n\nLANGUAGE: cmake\nCODE:\n```\nif (WRAPPER OR ARM_CFFT_RADIX2_Q31)\n  target_sources(CMSISDSPTransform PRIVATE arm_cfft_radix2_init_q31.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Add Executable Target\nDESCRIPTION: Adds an executable target named 'arm_fir_example'.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fir_example/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(arm_fir_example)\n```\n\n----------------------------------------\n\nTITLE: Monitoring Telemetry Messages via Azure CLI\nDESCRIPTION: This snippet demonstrates how to monitor telemetry messages (D2C) from the device using the Azure CLI. The --hub-name parameter must be replaced with the actual name of the IoT Hub.  Requires Azure CLI to be installed and configured.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_vxworks.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\naz iot hub monitor-events --hub-name [IoT Hub Name] --output table\n```\n\n----------------------------------------\n\nTITLE: Set Compile Definitions\nDESCRIPTION: Defines compile-time definitions based on the selected build configuration.  These definitions control feature flags and behaviors within the LevelX library.  The definitions are set using `-D` flags in CMake.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(FX_FAULT_TOLERANT_DEFINITIONS\n    -DFX_ENABLE_FAULT_TOLERANT -DFX_UPDATE_FILE_SIZE_ON_ALLOCATE\n    -DFX_FAULT_TOLERANT_TRANSACTION_FAIL_FUNCTION)\nset(default_build_coverage \"\")\nset(free_sector_verify_build -DLX_FREE_SECTOR_DATA_VERIFY)\nset(full_build -DLX_FREE_SECTOR_DATA_VERIFY\n               -DLX_DIRECT_READ\n               -DLX_NAND_FLASH_DIRECT_MAPPING_CACHE\n               -DLX_NOR_DISABLE_EXTENDED_CACHE\n               -DLX_THREAD_SAFE_ENABLE)\n# For Standalone builds LX_STANADLONE_ENABLE is defined in line 61\nset(standalone_build -DLX_STANDALONE_ENABLE)\nset(standalone_free_sector_verify_build -DLX_STANDALONE_ENABLE ${free_sector_verify_build})\nset(standalone_full_build -DLX_STANDALONE_ENABLE ${full_build})\nset(new_driver_interface_build -DLX_NOR_ENABLE_CONTROL_BLOCK_FOR_DRIVER_INTERFACE\n                               -DLX_NAND_ENABLE_CONTROL_BLOCK_FOR_DRIVER_INTERFACE)\nset(nor_obsolete_cache_build   -DLX_NOR_ENABLE_OBSOLETE_COUNT_CACHE)\nset(nor_mapping_cache_build -DLX_NOR_ENABLE_MAPPING_BITMAP)\nset(nor_obsolete_mapping_cache_build -DLX_NOR_ENABLE_MAPPING_BITMAP\n                               -DLX_NOR_ENABLE_OBSOLETE_COUNT_CACHE)\n```\n\n----------------------------------------\n\nTITLE: Adding MFCC source files (Q31) in CMake\nDESCRIPTION: This snippet adds MFCC (Mel-Frequency Cepstral Coefficients) source files for Q31 data type to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_27\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources(CMSISDSPTransform PRIVATE arm_mfcc_init_q31.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_mfcc_q31.c)\n```\n\n----------------------------------------\n\nTITLE: Test Examples matching TX, ARM compiler v6, Cortex-A35 (PowerShell)\nDESCRIPTION: This command tests examples matching the keywords 'TX ', 'ARM compiler v6', and 'Cortex-A35'. The pwsh -Command prefix executes the PowerShell script from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_29\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'TX ','ARM compiler v6','Cortex-A35' -test\n```\n\n----------------------------------------\n\nTITLE: Setting Telnet Test Case Sources CMake\nDESCRIPTION: This snippet defines the source files for Telnet tests in CMake. The `netx_telnet_test_cases` variable is assigned a list of C files related to Telnet functionality, located in the `${SOURCE_DIR}/telnet_test/` directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_31\n\nLANGUAGE: CMake\nCODE:\n```\nset(telnet_test_cases\n    ${SOURCE_DIR}/telnet_test/netx_telnet_activity_timeout_test.c\n    ${SOURCE_DIR}/telnet_test/netx_telnet_max_connections_test.c\n    ${SOURCE_DIR}/telnet_test/netx_telnet_create_packet_pool_test.c\n    ${SOURCE_DIR}/telnet_test/netx_telnet_server_options_negotiate_test.c\n    ${SOURCE_DIR}/telnet_test/netx_telnet_basic_test.c\n    ${SOURCE_DIR}/telnet_test/netx_telnet_server_bad_option_reply_test.c\n    ${SOURCE_DIR}/telnet_test/netx_telnet_rst_test.c\n    ${SOURCE_DIR}/telnet_test/netx_telnet_two_listen_test.c)\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake and Setting Project\nDESCRIPTION: This snippet initializes the minimum CMake version and sets CMake policies. It then defines the project name as 'web_test' and specifies that it uses the C language.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\ncmake_policy(SET CMP0077 NEW)\n\nproject(web_test LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Appending Test Cases to Lists\nDESCRIPTION: This snippet demonstrates how test case names are appended to the `nx_secure_test_cases` list and how file lists are associated with each test case using the `set` command. This is a common pattern for managing test configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/regression/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND nx_secure_test_cases dtls_ecc_server_test)\nset(dtls_ecc_server_test_file_list\n    ${SOURCE_DIR}/dtls_two_instance_test.c\n    ${SOURCE_DIR}/dtls_openssl_ecc_test_client_entry.c\n    ${SOURCE_DIR}/dtls_nx_secure_ecc_test_server_entry.c)\n```\n\n----------------------------------------\n\nTITLE: C Compiler Flag Settings CMake\nDESCRIPTION: This snippet configures the C compiler flags based on the compiler being used (GNU, Clang, IAR, or MSVC).  It sets default flags, standard, and extensions. For GCC and Clang, it sets various warning flags and optimization levels depending on the build type (Release, Debug, Coverage, ASAN, TSAN, Check). It checks the GCC version to enable specific warnings and define flags for different sanitizers (AddressSanitizer, ThreadSanitizer). For IAR and MSVC, it sets compiler-specific warning options and character set configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_18\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(CheckCCompilerFlag)\n\nset(CMAKE_C_EXTENSIONS OFF)\nset(CMAKE_C_STANDARD 99)\n\nif(CMAKE_COMPILER_IS_GNU)\n    # some warnings we want are not available with old GCC versions\n    # note: starting with CMake 2.8 we could use CMAKE_C_COMPILER_VERSION\n    execute_process(COMMAND ${CMAKE_C_COMPILER} -dumpversion\n                    OUTPUT_VARIABLE GCC_VERSION)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wall -Wextra -Wwrite-strings -Wmissing-prototypes\")\n    if (GCC_VERSION VERSION_GREATER 3.0 OR GCC_VERSION VERSION_EQUAL 3.0)\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wformat=2 -Wno-format-nonliteral\")\n    endif()\n    if (GCC_VERSION VERSION_GREATER 4.3 OR GCC_VERSION VERSION_EQUAL 4.3)\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wvla\")\n    endif()\n    if (GCC_VERSION VERSION_GREATER 4.5 OR GCC_VERSION VERSION_EQUAL 4.5)\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wlogical-op\")\n    endif()\n    if (GCC_VERSION VERSION_GREATER 4.8 OR GCC_VERSION VERSION_EQUAL 4.8)\n        set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wshadow\")\n    endif()\n    if (GCC_VERSION VERSION_GREATER 5.0)\n        CHECK_C_COMPILER_FLAG(\"-Wformat-signedness\" C_COMPILER_SUPPORTS_WFORMAT_SIGNEDNESS)\n        if(C_COMPILER_SUPPORTS_WFORMAT_SIGNEDNESS)\n            set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wformat-signedness\")\n        endif()\n    endif()\n    if (GCC_VERSION VERSION_GREATER 7.0 OR GCC_VERSION VERSION_EQUAL 7.0)\n      set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wformat-overflow=2 -Wformat-truncation\")\n    endif()\n    set(CMAKE_C_FLAGS_RELEASE     \"-O2\")\n    set(CMAKE_C_FLAGS_DEBUG       \"-O0 -g3\")\n    set(CMAKE_C_FLAGS_COVERAGE    \"-O0 -g3 --coverage\")\n    set(CMAKE_C_FLAGS_ASAN        \"-fsanitize=address -fno-common -fsanitize=undefined -fno-sanitize-recover=all -O3\")\n    set(CMAKE_C_FLAGS_ASANDBG     \"-fsanitize=address -fno-common -fsanitize=undefined -fno-sanitize-recover=all -O1 -g3 -fno-omit-frame-pointer -fno-optimize-sibling-calls\")\n    set(CMAKE_C_FLAGS_TSAN        \"-fsanitize=thread -O3\")\n    set(CMAKE_C_FLAGS_TSANDBG     \"-fsanitize=thread -O1 -g3 -fno-omit-frame-pointer -fno-optimize-sibling-calls\")\n    set(CMAKE_C_FLAGS_CHECK       \"-Os\")\n    set(CMAKE_C_FLAGS_CHECKFULL   \"${CMAKE_C_FLAGS_CHECK} -Wcast-qual\")\nendif(CMAKE_COMPILER_IS_GNU)\n\nif(CMAKE_COMPILER_IS_CLANG)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wall -Wextra -Wwrite-strings -Wmissing-prototypes -Wpointer-arith -Wimplicit-fallthrough -Wshadow -Wvla -Wformat=2 -Wno-format-nonliteral\")\n    set(CMAKE_C_FLAGS_RELEASE     \"-O2\")\n    set(CMAKE_C_FLAGS_DEBUG       \"-O0 -g3\")\n    set(CMAKE_C_FLAGS_COVERAGE    \"-O0 -g3 --coverage\")\n    set(CMAKE_C_FLAGS_ASAN        \"-fsanitize=address -fno-common -fsanitize=undefined -fno-sanitize-recover=all -O3\")\n    set(CMAKE_C_FLAGS_ASANDBG     \"-fsanitize=address -fno-common -fsanitize=undefined -fno-sanitize-recover=all -O1 -g3 -fno-omit-frame-pointer -fno-optimize-sibling-calls\")\n    set(CMAKE_C_FLAGS_MEMSAN      \"-fsanitize=memory -O3\")\n    set(CMAKE_C_FLAGS_MEMSANDBG   \"-fsanitize=memory -O1 -g3 -fno-omit-frame-pointer -fno-optimize-sibling-calls -fsanitize-memory-track-origins=2\")\n    set(CMAKE_C_FLAGS_TSAN        \"-fsanitize=thread -O3\")\n    set(CMAKE_C_FLAGS_TSANDBG     \"-fsanitize=thread -O1 -g3 -fno-omit-frame-pointer -fno-optimize-sibling-calls\")\n    set(CMAKE_C_FLAGS_CHECK       \"-Os\")\nendif(CMAKE_COMPILER_IS_CLANG)\n\nif(CMAKE_COMPILER_IS_IAR)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} --warn_about_c_style_casts\")\n    set(CMAKE_C_FLAGS_RELEASE     \"-Ohz\")\n    set(CMAKE_C_FLAGS_DEBUG       \"--debug -On\")\nendif(CMAKE_COMPILER_IS_IAR)\n\nif(CMAKE_COMPILER_IS_MSVC)\n    # Strictest warnings, UTF-8 source and execution charset\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} /W3 /utf-8\")\nendif(CMAKE_COMPILER_IS_MSVC)\n```\n\n----------------------------------------\n\nTITLE: Target Sources (LMS Normalization)\nDESCRIPTION: Conditionally adds source files for LMS normalization initialization (arm_lms_norm_init_q31.c and arm_lms_norm_init_q15.c) to the CMSISDSPFiltering library if CONFIGTABLE is false, ALLFAST is true, or ARM_LMS_NORM_Q31/ARM_LMS_NORM_Q15 is true. This includes the C source files required for specific LMS normalization functionality when certain conditions are met.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_LMS_NORM_Q31)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_norm_init_q31.c)\nendif()\n\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_LMS_NORM_Q15)\ntarget_sources(CMSISDSPFiltering PRIVATE arm_lms_norm_init_q15.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: CPI Multiplier Configuration\nDESCRIPTION: This parameter sets the multiplier for calculating Cycles Per Instruction (CPI). The default value is 0x1.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/ARMCM3_config.txt#_snippet_2\n\nLANGUAGE: Configuration\nCODE:\n```\narmcortexm3ct.cpi_mul=1\n```\n\n----------------------------------------\n\nTITLE: Toolchain File Setup\nDESCRIPTION: This snippet displays the toolchain file path in the build status messages. It helps to verify the correct toolchain is being used for the build.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/libs/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: JSON Parameters for Test Resources\nDESCRIPTION: JSON configuration snippet from `test-resources.json` defining parameters for deploying Azure resources. It allows the test-resources.json to consume parameters generated by a pre-script.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/README.md#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"$schema\": \"https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#\",\n  \"contentVersion\": \"1.0.0.0\",\n  \"parameters\": {\n    \"_comment\": \"Other required parameters would go here... (this is not part of the actual test-resources.json)\",\n    \"ConfidentialLedgerPrincipalPEM\": {\n      \"type\": \"string\",\n      \"metadata\": {\n        \"description\": \"The certificate to configure as a certBasedSecurityPrincipal.\"\n      }\n    },\n    \"ConfidentialLedgerPrincipalPEMPK\": {\n      \"type\": \"string\",\n      \"metadata\": {\n        \"description\": \"The certificate to configure as a certBasedSecurityPrincipal.\"\n      }\n    }\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Coverage Targets File\nDESCRIPTION: Creates an empty file named `coverage_targets.txt` in the build directory. This file will be used to list the targets for code coverage analysis. The `file(WRITE)` command overwrites the file if it already exists, ensuring it starts empty.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nfile(WRITE ${CMAKE_BINARY_DIR}/coverage_targets.txt \"\")\n```\n\n----------------------------------------\n\nTITLE: Setting Source Files with CMake\nDESCRIPTION: This snippet defines a list of source files for protocol handlers using the `set` command in CMake. The source files are for nx_shaper.c, nx_mrp.c, nx_mvrp.c, nx_srp.c, and nx_msrp.c. The variable `SOURCES` is then used to add these files to a target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/tsn/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SOURCES \n    # {{BEGIN_TARGET_SOURCES}}\n    ${CMAKE_CURRENT_LIST_DIR}/src/nx_shaper.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/nx_mrp.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/nx_mvrp.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/nx_srp.c\n    ${CMAKE_CURRENT_LIST_DIR}/src/nx_msrp.c\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Trusted Certificate in C\nDESCRIPTION: This code snippet demonstrates adding a trusted certificate to the Azure IoT Hub client using `nx_azure_iot_hub_client_trusted_cert_add`.  The function takes the hub client pointer and a pointer to the trusted certificate as input. This function can be called multiple times to add multiple trusted certificates.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_hub_client.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_hub_client_trusted_cert_add(NX_AZURE_IOT_HUB_CLIENT *hub_client_ptr,\n                                              NX_SECURE_X509_CERT *trusted_certificate);\n```\n\n----------------------------------------\n\nTITLE: Setting Source Directory\nDESCRIPTION: This snippet defines the source directory where the sample files are located, using a relative path from the current CMake list file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/samples/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../samples)\n```\n\n----------------------------------------\n\nTITLE: Building Win32 Platform Library\nDESCRIPTION: This snippet conditionally builds the 'az_win32' static library if AZ_PLATFORM_IMPL is set to 'WIN32'. It adds the library source file and links it with the 'az_core' library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/src/azure/platform/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(AZ_PLATFORM_IMPL STREQUAL \"WIN32\")\n  # build windows platform\n  add_library(az_win32 STATIC\n    ${CMAKE_CURRENT_LIST_DIR}/az_win32.c\n  )\n\n  target_link_libraries(az_win32\n    PRIVATE\n      az_core\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating Executable Tests and Linking to Utility Library CMake\nDESCRIPTION: Iterates through the list of test cases, creating an executable target for each test case and linking it against the 'test_utility' library. It also adds each test case to the CTest test suite.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_31\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(test_case ${test_cases})\n  get_filename_component(test_name ${test_case} NAME_WE)\n  add_executable(${test_name} ${test_case})\n  target_link_libraries(${test_name} PRIVATE test_utility)\n  add_test(${CMAKE_BUILD_TYPE}::${test_name} ${test_name})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Add Subdirectories\nDESCRIPTION: Adds subdirectories for the LevelX library, regression tests, and samples. These subdirectories contain additional CMakeLists.txt files that define their own build processes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../.. levelx)\nadd_subdirectory(regression)\nadd_subdirectory(samples)\n```\n\n----------------------------------------\n\nTITLE: Define Source Sets for USB RNDIS Class Tests\nDESCRIPTION: This snippet defines a variable `ux_class_rndis_test_cases` that contains a list of C source files for USB RNDIS class tests. These files are located in the specified `SOURCE_DIR`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/regression/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset(ux_class_rndis_test_cases ${SOURCE_DIR}/usbx_rndis_basic_test.c)\n```\n\n----------------------------------------\n\nTITLE: Syntax - Remove-TestResources Default+Provisioner Set - PowerShell\nDESCRIPTION: This snippet defines the syntax for the `Remove-TestResources.ps1` script using the `Default+Provisioner` parameter set. It includes parameters for `BaseName`, `TenantId`, `SubscriptionId`, `ProvisionerApplicationId`, `ProvisionerApplicationSecret`, `ServiceDirectory`, `Environment`, `Force`, and `RemoveTestResourcesRemainingArguments`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/Remove-TestResources.ps1.md#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\nRemove-TestResources.ps1 -BaseName <String> -TenantId <String> [-SubscriptionId <String>]\n -ProvisionerApplicationId <String> -ProvisionerApplicationSecret <String> [[-ServiceDirectory] <String>]\n [-Environment <String>] [-Force] [-RemoveTestResourcesRemainingArguments <Object>] [-WhatIf] [-Confirm]\n [<CommonParameters>]\n```\n\n----------------------------------------\n\nTITLE: CMake Header Symlink Creation\nDESCRIPTION: Creates symbolic links for all header files in the include directories of the threadx and filex libraries into a common `inc` directory within the build directory, as long as neither LX_STANDALONE_ENABLE nor FX_STANDALONE_ENABLE are defined.  This simplifies header inclusion for other components.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/libs/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif((NOT LX_STANDALONE_ENABLE) OR (NOT FX_STANDALONE_ENABLE))\n    foreach(lib threadx filex)\n      get_target_property(dirs ${lib} INCLUDE_DIRECTORIES)\n      execute_process(COMMAND mkdir -p ${CMAKE_BINARY_DIR}/inc)\n      foreach(dir ${dirs})\n        file(GLOB header_files ${dir}/*.h)\n        foreach(header_file ${header_files})\n          execute_process(COMMAND ln -sf ${header_file} ${CMAKE_BINARY_DIR}/inc)\n        endforeach()\n      endforeach()\n    endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Swap Status Location Based on Image Trailers\nDESCRIPTION: These tables define the location of the swap status region based on the magic and copy-done fields in the primary slot and scratch area image trailers. The \"source\" field indicates where the swap status region can be found (none, primary slot, or scratch).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mcuboot/docs/design.md#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\n              | primary slot | scratch      |\n    ----------+--------------+--------------|\n        magic | Good         | Any          |\n    copy-done | 0x01         | N/A          |\n    ----------+--------------+--------------'\n    source: none                            |\n    ----------------------------------------'\n\n              | primary slot | scratch      |\n    ----------+--------------+--------------|\n        magic | Good         | Any          |\n    copy-done | 0xff         | N/A          |\n    ----------+--------------+--------------'\n    source: primary slot                    |\n    ----------------------------------------'\n\n              | primary slot | scratch      |\n    ----------+--------------+--------------|\n        magic | Any          | Good         |\n    copy-done | Any          | N/A          |\n    ----------+--------------+--------------'\n    source: scratch                         |\n    ----------------------------------------'\n\n              | primary slot | scratch      |\n    ----------+--------------+--------------|\n        magic | Unset        | Any          |\n    copy-done | 0xff         | N/A          |\n    ----------+--------------+--------------|\n    source: primary slot                    |\n    ----------------------------------------+------------------------------+\n    This represents one of two cases:                                      |\n    o No swaps ever (no status to read, so no harm in checking).           |\n    o Mid-revert; status in the primary slot.                              |\n    For this reason we assume the primary slot as source, to trigger a     |\n    check of the status area and find out if there was swapping under way. |\n    -----------------------------------------------------------------------'\n```\n\n----------------------------------------\n\nTITLE: Managing NetX Duo Sources\nDESCRIPTION: This snippet retrieves the list of source files and the source directory from the `netxduo` target. It then iterates through a list of directories to exclude, removing their source files from the build to create a more focused build tailored for testing. It utilizes `aux_source_directory` to identify source files in excluded directories, and `list(REMOVE_ITEM)` to remove those files from the overall source list.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo64/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nget_target_property(SOURCES_LIST netxduo SOURCES)\nget_target_property(SOURCE_DIR netxduo SOURCE_DIR)\n# Remove files not needed from netxduo\nforeach(\n  EXCLUDE_DIR\n  nx_secure/src\n  crypto_libraries/src\n  addons/auto_ip\n  addons/cloud\n  addons/ftp\n  addons/http\n  addons/mdns\n  addons/mqtt\n  addons/nat\n  addons/pop3\n  addons/ppp\n  addons/pppoe\n  addons/ptp\n  addons/rtp\n  addons/rtsp\n  addons/smtp\n  addons/snmp\n  addons/sntp\n  addons/telnet\n  addons/tftp\n  addons/web\n  addons/websocket\n  utility/iperf)\n  aux_source_directory(${SOURCE_DIR}/${EXCLUDE_DIR} EXCLUDE_SOURCES)\n  list(REMOVE_ITEM SOURCES_LIST ${EXCLUDE_SOURCES})\nendforeach()\n# list(REMOVE_ITEM SOURCES_LIST ${SOURCE_DIR}/addons/dhcp/nxd_dhcpv6_client.c\n#      ${SOURCE_DIR}/addons/dhcp/nxd_dhcpv6_server.c)\nset_target_properties(netxduo PROPERTIES SOURCES \"${SOURCES_LIST}\")\n```\n\n----------------------------------------\n\nTITLE: RSA Public Exponent Declaration\nDESCRIPTION: Defines the RSA public exponent (E) as a hexadecimal value.  The exponent is the other part of the public key and is used along with the modulus for encryption and signature verification. A common value for the public exponent is 65537 (0x10001).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/rsa_pub.txt#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nE = 010001\n```\n\n----------------------------------------\n\nTITLE: Adding RFFT FAST source files (float32) in CMake\nDESCRIPTION: This snippet conditionally adds various Real FFT Fast (RFFT_FAST) source files for float32 data type based on configuration options to the CMSISDSPTransform library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_15\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFFT OR RFFT_FAST_F32_32 OR RFFT_FAST_F32_64 OR RFFT_FAST_F32_128\n   OR RFFT_FAST_F32_256 OR RFFT_FAST_F32_512 OR RFFT_FAST_F32_1024 OR RFFT_FAST_F32_2048\n   OR RFFT_FAST_F32_4096 )\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_fast_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_rfft_fast_init_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_init_f32.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix8_f32.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Define Overridable ThreadX Sources with CMake\nDESCRIPTION: These CMake commands conditionally add source files for thread deletion and resetting. The `target_sources_if_not_overridden` macro is used to check if the source file has already been overridden by a variable list named `TX_SRC_OVERRIDES`. If not overridden, the specified C source file is added to the target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/common/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources_if_not_overridden(\"tx_thread_delete.c\")\ntarget_sources_if_not_overridden(\"tx_thread_reset.c\")\n```\n\n----------------------------------------\n\nTITLE: Coverage Flags for Coverage Build Type CMake\nDESCRIPTION: This snippet sets the shared linker flags to `--coverage` when the build type is set to \"Coverage\" and the compiler is either GNU or Clang. This ensures that the build includes necessary information for generating code coverage reports.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/CMakeLists.txt#_snippet_21\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_BUILD_TYPE STREQUAL \"Coverage\")\n    if(CMAKE_COMPILER_IS_GNU OR CMAKE_COMPILER_IS_CLANG)\n        set(CMAKE_SHARED_LINKER_FLAGS \"--coverage\")\n    endif(CMAKE_COMPILER_IS_GNU OR CMAKE_COMPILER_IS_CLANG)\nendif(CMAKE_BUILD_TYPE STREQUAL \"Coverage\")\n```\n\n----------------------------------------\n\nTITLE: CI Template Usage\nDESCRIPTION: Shows examples of using the deploy-test-resources.yml and remove-test-resources.yml templates in a CI pipeline. These templates are used for automated resource management in CI/CD.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/README.md#_snippet_8\n\nLANGUAGE: YAML\nCODE:\n```\n- template: /eng/common/TestResources/deploy-test-resources.yml\n  parameters:\n    ServiceDirectory: '${{ parameters.ServiceDirectory }}'\n\n# Run tests\n\n- template: /eng/common/TestResources/remove-test-resources.yml\n```\n\n----------------------------------------\n\nTITLE: Project Definition and Subdirectory Inclusion\nDESCRIPTION: This snippet defines the project name as 'nx_secure_test' with the C language enabled. It then includes another CMakeLists.txt file from the '../nx_secure/' directory, allowing the current project to incorporate configurations and targets defined in the included file. This enables modularity and reusability of CMake configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nproject(nx_secure_test LANGUAGES C)\ninclude(${CMAKE_CURRENT_SOURCE_DIR}/../nx_secure/CMakeLists.txt)\n```\n\n----------------------------------------\n\nTITLE: Defining Executables in CMake\nDESCRIPTION: This snippet defines a list of executables (`cert_app`, `cert_req`, `cert_write`, `crl_app`, `load_roots`, `req_app`) that will be built by CMake.  These are intended to be certificate management utilities.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/x509/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(executables\n    cert_app\n    cert_req\n    cert_write\n    crl_app\n    load_roots\n    req_app\n)\n```\n\n----------------------------------------\n\nTITLE: Add Compile Options\nDESCRIPTION: This snippet adds compile options to the project, including debugging flags, diagnostic settings, and preprocessor definitions. These options control the compiler's behavior during the build process and can affect the generated code's performance, size, and debugging capabilities.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_compile_options(\n  -ggdb\n  -g3\n  -gdwarf-2\n  -fdiagnostics-color\n  -Werror\n  -DTX_INCLUDE_USER_DEFINE_FILE\n  -DNX_SECURE_X509_STRICT_NAME_COMPARE\n  -DNX_SECURE_ALLOW_SELF_SIGNED_CERTIFICATES\n  -DNX_ENABLE_EXTENDED_NOTIFY_SUPPORT\n  ${${CMAKE_BUILD_TYPE}})\n```\n\n----------------------------------------\n\nTITLE: Configure Mbed TLS Build Directory\nDESCRIPTION: Sets the source and binary directories for Mbed TLS.  These directories are used in subsequent CMake commands to configure and build the library. `CMAKE_CURRENT_SOURCE_DIR` and `CMAKE_CURRENT_BINARY_DIR` are CMake variables.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_package/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nset(MbedTLS_SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../../..\")\nset(MbedTLS_BINARY_DIR \"${CMAKE_CURRENT_BINARY_DIR}/mbedtls\")\n```\n\n----------------------------------------\n\nTITLE: Check for THREADX_ARCH and THREADX_TOOLCHAIN Definitions\nDESCRIPTION: This snippet checks if the THREADX_ARCH and THREADX_TOOLCHAIN variables are defined. If not, it will throw a fatal error causing the cmake configuration to halt.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/filex/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT DEFINED THREADX_ARCH)\n    message(FATAL_ERROR \"Error: THREADX_ARCH not defined\")\nendif()\nif(NOT DEFINED THREADX_TOOLCHAIN)\n    message(FATAL_ERROR \"Error: THREADX_TOOLCHAIN not defined\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Including Configuration Scripts\nDESCRIPTION: Includes custom CMake scripts named `configLib` and `configDsp`. These scripts likely contain project-specific configuration settings and helper functions to be used throughout the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: Creating Build Directory\nDESCRIPTION: Creates a directory named 'build' where the build artifacts will be stored.  This helps in keeping the source directory clean and organized during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmkdir build\n```\n\n----------------------------------------\n\nTITLE: Building the demonstration application\nDESCRIPTION: This command builds the demonstration application. It compiles sample_threadx.c and links it with tx.a to create the executable file DEMO.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/linux/gnu/readme_threadx.txt#_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\nmake sample_threadx\n```\n\n----------------------------------------\n\nTITLE: Defining PCAP source file\nDESCRIPTION: This snippet sets the path to the PCAP network driver source file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt_interoperability/regression/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(PCAP_SOURCE\n  ${CMAKE_CURRENT_LIST_DIR}/../../../regression/interoperability_test/nx_pcap_network_driver.c\n)\n```\n\n----------------------------------------\n\nTITLE: Clean, Build, and Test Examples for GCC, Cortex-A35 (PowerShell)\nDESCRIPTION: This command cleans, builds, and tests all examples matching the keywords 'GCC' and 'Cortex-A35'. The pwsh -Command prefix ensures correct execution of the command from the Windows Command Interpreter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.md#_snippet_32\n\nLANGUAGE: PowerShell\nCODE:\n```\npwsh -Command .\\azrtos_cicd.ps1 -MatchKeywords 'GCC','Cortex-A35' -clean -build -test\n```\n\n----------------------------------------\n\nTITLE: Define Source Directory\nDESCRIPTION: This snippet defines the source directory by using the get_filename_component command to get the absolute path of the directory containing the nx_secure test files. The path is based on the location of the current CMake list file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/regression/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nget_filename_component(\n  SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/../../../regression/interoperability_test/nx_secure_test\n  ABSOLUTE)\n```\n\n----------------------------------------\n\nTITLE: CMake Minimum Version\nDESCRIPTION: Specifies the minimum required CMake version for the project. This ensures that the CMake version used to build the project is compatible with the commands and features used in the CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CommonTables/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n```\n\n----------------------------------------\n\nTITLE: Cipher Setup with PSA (Deprecated)\nDESCRIPTION: The function `mbedtls_cipher_setup_psa()` sets up a cipher context that will call PSA to store the key and perform the operations. This function is now deprecated and it is recommended to use `psa_cipher_xxx()` or `psa_aead_xxx()` functions directly instead.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/use-psa-crypto.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nmbedtls_cipher_setup_psa()\n```\n\n----------------------------------------\n\nTITLE: Building Mbed TLS with PSA Drivers (Makefile)\nDESCRIPTION: This command builds the Mbed TLS library, incorporating the specified PSA drivers. It uses the `PSA_DRIVERS` Make variable to specify the paths to the driver description files in JSON format.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-integration-guide.md#_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\ncd /path/to/mbedtls\nmake PSA_DRIVERS=\"/path/to/acme/driver.json /path/to/nadir/driver.json\" lib\n```\n\n----------------------------------------\n\nTITLE: Adding/Removing XML Parameter (xmlparam)\nDESCRIPTION: This snippet demonstrates how to add or remove an entire XML parameter based on a macro value from a C source file. It reads a macro value from a specified layout file and adds or removes the XML parameter in the target XML file. The parameter is added if RE_CRYPTO_SCHEME is non-zero, otherwise removed if it's zero.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nxmlparam -l  image_macros_preprocessed_bl2.c -m RE_CRYPTO_SCHEME -n \"Encryption key\" -link GetPublic -t File -c -E -h 0 OEMiRoT_Secure_Code.xml\n```\n\n----------------------------------------\n\nTITLE: Finding FuzzingEngine Library\nDESCRIPTION: This CMake snippet attempts to find the FuzzingEngine library. If found, it defines a project named 'fuzz' that uses C++.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/fuzz/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nfind_library(FUZZINGENGINE_LIB FuzzingEngine)\nif(FUZZINGENGINE_LIB)\n    project(fuzz CXX)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Finding and Requiring Paho MQTT and OpenSSL\nDESCRIPTION: This snippet uses the `find_package` command to locate the eclipse-paho-mqtt-c and OpenSSL libraries.  It also uses `REQUIRED` to ensure that the build fails if the dependencies cannot be found.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(eclipse-paho-mqtt-c CONFIG)\nif(NOT eclipse-paho-mqtt-c_FOUND)\n  find_package(eclipse-paho-mqtt-c REQUIRED)\nendif()\n\nfind_package(OpenSSL CONFIG)\nif(NOT OpenSSL_FOUND)\n  find_package(OpenSSL REQUIRED)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Build Configurations in CMake\nDESCRIPTION: Defines various build configurations including default, secure, queue depth, and cloud-enabled builds, and configures CMake to recognize these as valid build types. It then selects the appropriate build type based on the CMAKE_BUILD_TYPE variable.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n# Set build configurations\nset(BUILD_CONFIGURATIONS\n    default_build_coverage secure_build_coverage require_secure_build queue_depth_build\n    cloud_default_build_coverage cloud_secure_build_coverage\n    cloud_require_secure_build cloud_queue_depth_build\n    websocket_secure_build)\nset(CMAKE_CONFIGURATION_TYPES\n    ${BUILD_CONFIGURATIONS}\n    CACHE STRING \"list of supported configuration types\" FORCE)\nset_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS\n                                             ${CMAKE_CONFIGURATION_TYPES})\nlist(GET CMAKE_CONFIGURATION_TYPES 0 BUILD_TYPE)\nif((NOT CMAKE_BUILD_TYPE) OR (NOT (\"${CMAKE_BUILD_TYPE}\" IN_LIST\n                                   CMAKE_CONFIGURATION_TYPES)))\n  set(CMAKE_BUILD_TYPE\n      \"${BUILD_TYPE}\"\n      CACHE STRING \"Build Type of the project\" FORCE)\nendif()\n\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\nmessage(STATUS \"Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.\")\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable (Windows)\nDESCRIPTION: This snippet shows how to set an environment variable in PowerShell. Replace ENV_VARIABLE_NAME with the desired variable name and VALUE with the corresponding value.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_11\n\nLANGUAGE: powershell\nCODE:\n```\n$env:ENV_VARIABLE_NAME='VALUE'\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: Sets the minimum required CMake version, project name, and version for the 'arm_sin_cos_example' project. It also defines paths to the CMSIS-DSP library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_sin_cos_example/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\nproject (arm_sin_cos_example VERSION 0.1)\n\n\n# Needed to include the configBoot module\n# Define the path to CMSIS-DSP (ROOT is defined on command line when using cmake)\nset(ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../../../../..)\nset(DSP ${ROOT}/CMSIS/DSP)\n\n# Add DSP folder to module path\nlist(APPEND CMAKE_MODULE_PATH ${DSP})\n```\n\n----------------------------------------\n\nTITLE: ClientHello Cipher Suites Example (C)\nDESCRIPTION: This code snippet illustrates the naming conventions for variables related to vectors in TLS 1.3, specifically for the 'cipher_suites' vector in the ClientHello message.  It defines variables for the length of the vector, a pointer to the length, and a pointer to the value.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/tls13-support.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nsize_t cipher_suites_len;\nunsigned char *p_cipher_suites_len;\nunsigned char *cipher_suites;\n```\n\n----------------------------------------\n\nTITLE: PAKE Driver Entry Points and Type Definition in C\nDESCRIPTION: Defines the type definition for `acme_pake_operation_t` and the function prototype for the `acme_pake_abort` entry point in a PSA cryptography driver for PAKE operations.  This also serves as example showcasing naming convention for PAKE driver interfaces. The `acme_pake_abort` function is responsible for aborting a PAKE operation and cleaning up any resources allocated during the operation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_23\n\nLANGUAGE: C\nCODE:\n```\ntypedef ... acme_pake_operation_t;\npsa_status_t acme_pake_abort( acme_pake_operation_t *operation );\n```\n\n----------------------------------------\n\nTITLE: Test Application Object ID Parameter\nDESCRIPTION: Defines the Service Principal Object ID of the AAD Test Application. This ID is used for assigning permissions to the application, enabling it to access features on live test resources.  The parameter is passed to the ARM template as 'testApplicationOid'. If not specified, the script attempts to query the ID from Azure Active Directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nType: String\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: None\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: IAR project postbuild action configuration\nDESCRIPTION: This XML snippet shows how to configure a post-build action in an IAR project to execute a command-line tool for image creation. It involves specifying the path to the executable and passing relevant parameters, such as the configuration XML file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_31\n\nLANGUAGE: xml\nCODE:\n```\n<settings>\n    <name>BUILDACTION</name>\n    <archiveVersion>1</archiveVersion>\n    <data>\n        <prebuild></prebuild>\n        \\<postbuild\\>\"STM32TrustedPackageCreator_CLI.exe\" -pb \"OEMiRoT_S_Code_Image.xml\"\\</postbuild\\>\n    </data>\n</settings>\n```\n\n----------------------------------------\n\nTITLE: Configuring Deprecated CFFT Options (Q31) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable deprecated Complex FFT (CFFT) implementations for Q31 data types using radix-2 and radix-4 algorithms. These options are included for backward compatibility but are marked as deprecated.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_23\n\nLANGUAGE: CMake\nCODE:\n```\noption(ARM_CFFT_RADIX2_Q31   \"deprecated q31 radix2 cfft\"       OFF)\noption(ARM_CFFT_RADIX4_Q31   \"deprecated q31 radix4 cfft\"       OFF)\n```\n\n----------------------------------------\n\nTITLE: Setting Coverage Options\nDESCRIPTION: Enables code coverage by adding compiler and linker flags if the build type includes 'coverage'. This is done by checking for '.*_coverage' in CMAKE_BUILD_TYPE.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/mqtt/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\n# Coverage\nif(CMAKE_BUILD_TYPE MATCHES \".*_coverage\")\n  target_compile_options(netxduo PRIVATE -fprofile-arcs -ftest-coverage)\n  target_link_options(netxduo PRIVATE -fprofile-arcs -ftest-coverage)\nendif()\n```\n\n----------------------------------------\n\nTITLE: CPI Multiplier Configuration\nDESCRIPTION: This parameter sets the multiplier for calculating CPI (Cycles Per Instruction). Combined with the divider, it allows for precise CPI calculation. The default value is 0x1.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/ARMCM3_config.txt#_snippet_2\n\nLANGUAGE: Configuration\nCODE:\n```\narmcortexm3ct.cpi_mul=1                               # (int   , run-time ) default = '0x1'    : multiplier for calculating CPI (Cycles Per Instruction)\n```\n\n----------------------------------------\n\nTITLE: Function Parameter Alignment in MBedTLS\nDESCRIPTION: This snippet demonstrates the recommended style for aligning function parameters vertically in MBedTLS, improving code readability when functions have many parameters that span multiple lines. Proper alignment makes it easier to visually scan and understand the function's signature.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/tls13-support.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nint mbedtls_ssl_start_handshake_msg( mbedtls_ssl_context *ssl,\n                                         unsigned hs_type,\n                                         unsigned char **buf,\n                                         size_t *buf_len );\n```\n\n----------------------------------------\n\nTITLE: XML Parameter Example (XML)\nDESCRIPTION: This example demonstrates a specific XML parameter with predefined values for its attributes. It showcases the typical structure of an individual parameter, including its name, type, command, hidden state, enable state, and default value.  Note that the Enable close tag is malformed, `<Enable>`.  It should be `</Enable>`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n\t<Param>\n\t\t<Name>Header Size</Name>\n\t\t<Type>Data</Type>\n\t\t<Command>-H</Command>\n\t\t<Hidden>1</Hidden>\n\t\t<Enable>1<Enable>\n\t\t<Default>0x400</Default>\n\t</Param>\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion - Square Root Functions\nDESCRIPTION: Conditionally includes source files for square root functions based on configuration flags. It checks if `CONFIGTABLE` is false, `ALLFAST` is true, or a specific data type's square root function (e.g., `ARM_SQRT_Q31`) is enabled.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FastMathFunctions/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_SQRT_Q31)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_sqrt_q31.c)\nendif()\n\nif (NOT CONFIGTABLE OR ALLFAST OR ARM_SQRT_Q15)\ntarget_sources(CMSISDSPFastMath PRIVATE arm_sqrt_q15.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting MbedTLS Executables List (CMake)\nDESCRIPTION: Defines a list of MbedTLS executables. This list is later used to create the executables using CMake.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(executables_mbedtls\n    dh_client\n    dh_server\n)\n```\n\n----------------------------------------\n\nTITLE: Append Begin Array Azure IoT JSON Writer C\nDESCRIPTION: Appends the beginning of a JSON array ('[') to the payload.  The function takes a pointer to the JSON writer. Returns NX_AZURE_IOT_SUCCESS if the array start is appended successfully.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/docs/azure_rtos_iot_json.md#_snippet_28\n\nLANGUAGE: C\nCODE:\n```\nUINT nx_azure_iot_json_writer_append_begin_array(NX_AZURE_IOT_JSON_WRITER *json_writer_ptr);\n```\n\n----------------------------------------\n\nTITLE: Setting Package Configuration Directories with CMake\nDESCRIPTION: This CMake snippet determines the include and library installation directories based on a prefix and stores them in PKGCONFIG_INCLUDEDIR and PKGCONFIG_LIBDIR variables. It relies on the JoinPaths.cmake module to correctly handle path concatenation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/pkgconfig/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT DISABLE_PACKAGE_CONFIG_AND_INSTALL)\n  include(JoinPaths.cmake)\n  join_paths(PKGCONFIG_INCLUDEDIR \"${prefix}\" \"${CMAKE_INSTALL_INCLUDEDIR}\")\n  join_paths(PKGCONFIG_LIBDIR \"${prefix}\" \"${CMAKE_INSTALL_LIBDIR}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Install Executables with CMake\nDESCRIPTION: This snippet installs the executables to the 'bin' directory.  It sets the permissions for the owner, group, and world to read, write, and execute, respectively. This ensures the executables are properly installed and accessible.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/aes/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(TARGETS ${executables}\n        DESTINATION \"bin\"\n        PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This snippet sets up the CMake project, defines source files, and creates a static library. It includes configuration files for the library and DSP, and sets include directories.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/BayesFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n\nproject(CMSISDSPBayes)\n\ninclude(configLib)\ninclude(configDsp)\n\nfile(GLOB SRC \"./*_*.c\")\n\nadd_library(CMSISDSPBayes STATIC)\n\ntarget_sources(CMSISDSPBayes PRIVATE arm_gaussian_naive_bayes_predict_f32.c)\n\nconfigLib(CMSISDSPBayes ${ROOT})\nconfigDsp(CMSISDSPBayes ${ROOT})\n\n### Includes\ntarget_include_directories(CMSISDSPBayes PUBLIC \"${DSP}/Include\")\n\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPBayes PRIVATE arm_gaussian_naive_bayes_predict_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Location Parameter\nDESCRIPTION: Optional location where resources should be created. If not specified, the default location is determined by the cloud environment (e.g., 'westus' for AzureCloud). This ensures resources are created in the appropriate geographic region.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nType: String\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: None\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Managed Interrupt Handler in Assembly for Cortex-M0 ThreadX\nDESCRIPTION: This code snippet shows an example of an Interrupt Service Routine (ISR) written in assembly language for Cortex-M0 targets using ThreadX. The ISR pushes and pops registers r0 and lr for context preservation before performing ISR-specific operations.  'your_assembly_isr' is an entry point defined for the vector table.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m0/keil/readme_threadx.txt#_snippet_1\n\nLANGUAGE: Assembly\nCODE:\n```\nEXPORT  your_assembly_isr\nyour_assembly_isr\n\tPUSH    {r0, lr}\n\n\t; ISR processing goes here, including any needed function calls.\n\n\tPOP     {r0, r1}\n\tMOV     lr, r1\n\tBX      lr\n```\n\n----------------------------------------\n\nTITLE: Assembly ISR Definition for ThreadX with IAR\nDESCRIPTION: This assembly code snippet defines an Interrupt Service Routine (ISR) for use with ThreadX in an IAR environment. It demonstrates the basic structure for an assembly ISR, including pushing and popping registers from the stack, as well as branching back using `BX lr`. The `PUBLIC` directive makes the ISR accessible from other parts of the program.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m33/iar/readme_threadx.txt#_snippet_1\n\nLANGUAGE: assembly\nCODE:\n```\n    PUBLIC  your_assembly_isr\nyour_assembly_isr:\n\n    PUSH    {r0, lr}\n\n    ; ISR processing goes here, including any needed function calls.\n\n    POP     {r0, lr}\n    BX      lr\n```\n\n----------------------------------------\n\nTITLE: Example of Buffer Manipulation with Macros in MBedTLS\nDESCRIPTION: This snippet demonstrates the use of macros for buffer manipulation in MBedTLS. It checks for available space in a buffer using `MBEDTLS_SSL_CHK_BUF_PTR`, writes a 16-bit value to the buffer using `MBEDTLS_PUT_UINT16_BE`, and then increments the buffer pointer. This pattern ensures that data is written safely and efficiently within the allocated buffer.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/tls13-support.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nMBEDTLS_SSL_CHK_BUF_PTR( cipher_suites_iter, end, 2 );\nMBEDTLS_PUT_UINT16_BE( cipher_suite, cipher_suites_iter, 0 );\ncipher_suites_iter += 2;\n```\n\n----------------------------------------\n\nTITLE: Executing Clean Operation\nDESCRIPTION: This command executes the clean operation on all ThreadX examples. The azrtos_cicd.old.bat script is called with the 'clean' parameter, followed by the target framework ('tx') and 'all', indicating that all toolchains should be cleaned. This will remove all build-generated files from the specified examples.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.old.md#_snippet_1\n\nLANGUAGE: batch\nCODE:\n```\nazrtos_cicd.old.bat clean tx all\n```\n\n----------------------------------------\n\nTITLE: Define signal Function Prototype in C\nDESCRIPTION: Defines the prototype for the `signal` function, used for setting a handler for a specific signal. It takes the signal number and a function pointer to the signal handler.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_10\n\nLANGUAGE: c\nCODE:\n```\nINT                   signal(int signo, void (*func)(int))\n```\n\n----------------------------------------\n\nTITLE: Define sigemptyset Function Prototype in C\nDESCRIPTION: Defines the prototype for the `sigemptyset` function, used for initializing a signal set to be empty. It takes a pointer to the signal set to be cleared.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nINT                   sigemptyset(sigset_t *set)\n```\n\n----------------------------------------\n\nTITLE: Add CMSIS DSP Subdirectory\nDESCRIPTION: This snippet adds the CMSIS DSP source directory as a subdirectory to the project, allowing the CMSISDSP library to be built. The `add_subdirectory` command includes the CMakeLists.txt file in the specified source directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_dotproduct_example/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(../../../Source bin_dsp)\n```\n\n----------------------------------------\n\nTITLE: Setting ThreadX Include Directories with CMake\nDESCRIPTION: This CMake snippet adds the include directory for ThreadX header files. The `target_include_directories` command makes the header files located in the specified directory accessible to the project during compilation, allowing the project to use ThreadX functionalities. The specified include directory is publicly available for other dependent targets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/gnu/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME}\n    PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Adding and Linking MbedCrypto Executables (CMake)\nDESCRIPTION: Iterates through the `executables_mbedcrypto` list, adds each executable by specifying its source file, links the necessary libraries (mbedcrypto target and thread libraries), and includes the required directories. It assumes the source file name matches the executable name.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/pkey/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(exe IN LISTS executables_mbedcrypto)\n    add_executable(${exe} ${exe}.c $<TARGET_OBJECTS:mbedtls_test>)\n    target_link_libraries(${exe} ${mbedcrypto_target} ${CMAKE_THREAD_LIBS_INIT})\n    target_include_directories(${exe} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../../tests/include)\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Subscription ID Parameter\nDESCRIPTION: An optional subscription ID to use for new resources when logging in as a provisioner. This parameter allows specifying the Azure subscription to use for resource creation. If not provided and the user is not logged in, Connect-AzAccount selects a subscription automatically.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nType: String\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: None\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Configuring ThreadX Assembly Sources with CMake\nDESCRIPTION: This CMake snippet configures the assembly source files required for ThreadX within the STM32CubeH5 project.  It uses the `target_sources` command to add the specified assembly files related to thread management and interrupt handling to the project's build process. These files are compiled as part of the project during the build process.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/cortex_m3/gnu/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(${PROJECT_NAME}\n    PRIVATE\n    # {{BEGIN_TARGET_SOURCES}}\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_restore.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_context_save.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_interrupt_control.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_schedule.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_stack_build.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_thread_system_return.S\n\t${CMAKE_CURRENT_LIST_DIR}/src/tx_timer_interrupt.S\n    # {{END_TARGET_SOURCES}}\n)\n```\n\n----------------------------------------\n\nTITLE: Including PSA Crypto Header\nDESCRIPTION: This snippet shows how to include the necessary header file for using the PSA Crypto API in your application. It's essential for accessing the PSA cryptographic functions and data structures.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include <psa/crypto.h>\n```\n\n----------------------------------------\n\nTITLE: FIQ Interrupt Handler Default Implementation Assembly\nDESCRIPTION: This code snippet demonstrates the default implementation of a FIQ interrupt handler in assembly. It jumps to the _tx_thread_fiq_context_save function to save the system context and, after FIQ processing, jumps to _tx_thread_fiq_context_restore to restore the system context.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/cortex_a7_smp/gnu/readme_threadx.txt#_snippet_3\n\nLANGUAGE: Assembly\nCODE:\n```\nEXPORT  __tx_fiq_handler\nEXPORT  __tx_fiq_processing_return\n__tx_fiq_handler\n;\n;    /* Jump to fiq context save to save system context.  */\n    B       _tx_thread_fiq_context_save\n__tx_fiq_processing_return:\n;\n;    /* At this point execution is still in the FIQ mode. The CPSR, point of\n;       interrupt, and all C scratch registers are available for use.  */\n;\n;    /* Application FIQ handlers can be called here!  */\n;\n;    /* Jump to fiq context restore to restore system context.  */\n    B       _tx_thread_fiq_context_restore\n```\n\n----------------------------------------\n\nTITLE: Linking cert_app in CMake\nDESCRIPTION: This snippet explicitly links the `cert_app` executable target against the `mbedtls_target` library. This ensures the application has access to the mbedtls functionalities.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/x509/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(cert_app ${mbedtls_target})\n```\n\n----------------------------------------\n\nTITLE: Creating the CMSISDSPSVM Static Library\nDESCRIPTION: This snippet creates a static library named CMSISDSPSVM using CMake. It defines the library and adds the source files for the library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/SVMFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(CMSISDSPSVM STATIC)\n\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_linear_init_f32.c) \ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_rbf_init_f32.c)\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_linear_predict_f32.c)\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_rbf_predict_f32.c)\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_polynomial_init_f32.c)\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_sigmoid_init_f32.c)\ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_polynomial_predict_f32.c)  \ntarget_sources(CMSISDSPSVM PRIVATE arm_svm_sigmoid_predict_f32.c)\n```\n\n----------------------------------------\n\nTITLE: CMake Minimum Version and Policy Settings\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.13 and configures several CMake policies to 'NEW'. These policies control how CMake handles certain behaviors and ensure compatibility across different CMake versions.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/nx_secure_interoperability/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\ncmake_policy(SET CMP0054 NEW)\ncmake_policy(SET CMP0057 NEW)\ncmake_policy(SET CMP0077 NEW)\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker File Modification for ThreadX\nDESCRIPTION: This code snippet shows the required modification to the EWARM linker file (.icf) to allocate memory for ThreadX.  It places the `FREE_MEM` section within the `RAM_region` to provide ThreadX with a memory area for dynamic allocation.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_FreeRTOS_Wrapper/README.md#_snippet_0\n\nLANGUAGE: linker\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: Syntax - Remove-TestResources Default Set - PowerShell\nDESCRIPTION: This snippet defines the syntax for the `Remove-TestResources.ps1` script using the `Default` parameter set. It includes parameters for `BaseName`, `SubscriptionId`, `ServiceDirectory`, `Environment`, `Force`, and `RemoveTestResourcesRemainingArguments`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/Remove-TestResources.ps1.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nRemove-TestResources.ps1 [-BaseName <String>] [-SubscriptionId <String>] [-ServiceDirectory] <String>\n [-Environment <String>] [-Force] [-RemoveTestResourcesRemainingArguments <Object>] [-WhatIf] [-Confirm]\n [<CommonParameters>]\n```\n\n----------------------------------------\n\nTITLE: RTC Clock Source Definition\nDESCRIPTION: This code snippet defines the RTC clock source. By default, the LSI oscillator is used, but the user can uncomment the line to use the LSE oscillator instead.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Examples/RTC/RTC_Alarm/README.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n      #define RTC_CLOCK_SOURCE_LSI\n\t  \n     /* #define RTC_CLOCK_SOURCE_LSE */\n```\n\n----------------------------------------\n\nTITLE: CMake Minimum Version\nDESCRIPTION: Specifies the minimum CMake version required for the project. This ensures compatibility with the CMake features used in the script and stops the build if the version is too old.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/libs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13 FATAL_ERROR)\n```\n\n----------------------------------------\n\nTITLE: Setting Mbed TLS Directory\nDESCRIPTION: This snippet sets the `MBEDTLS_DIR` variable to the parent Mbed TLS directory.  This is necessary for CMake to find the Mbed TLS configuration files. The path is defined relative to the current CMakeLists.txt file.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/test/cmake_subproject/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\n# We use the parent Mbed TLS directory as the MBEDTLS_DIR for this test. Other\n# projects that use Mbed TLS as a subproject are likely to add by their own\n# relative paths.\nset(MBEDTLS_DIR ../../../)\n```\n\n----------------------------------------\n\nTITLE: Installing GCC Multilib on Ubuntu\nDESCRIPTION: This command installs the GCC multilib package on an Ubuntu system. This package is required for building the ThreadX SMP run-time library.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/linux/gnu/readme_threadx.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsudo apt-get install gcc-multilib\n```\n\n----------------------------------------\n\nTITLE: Define sleep Function Prototype in C\nDESCRIPTION: Defines the prototype for the `sleep` function, used for pausing execution for a specified number of seconds. It takes an unsigned long integer representing the number of seconds to sleep.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/posix/readme_threadx_posix.txt#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nINT                   sleep(ULONG seconds)\n```\n\n----------------------------------------\n\nTITLE: Enabling USBX Standalone Mode in ux_user.h\nDESCRIPTION: This code snippet shows how to enable the standalone variant of USBX by defining the UX_STANDALONE flag in the ux_user.h header file. This configuration allows USBX to operate without ThreadX, suitable for bare-metal environments.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Host_HID_Standalone/README.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define UX_STANDALONE\n```\n\n----------------------------------------\n\nTITLE: CPI Divider Configuration\nDESCRIPTION: This parameter sets the divider for calculating Cycles Per Instruction (CPI). The default value is 0x1.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_fft_bin_example/ARMCM3_config.txt#_snippet_1\n\nLANGUAGE: Configuration\nCODE:\n```\narmcortexm3ct.cpi_div=1\n```\n\n----------------------------------------\n\nTITLE: Minimum Synchronization Level Configuration\nDESCRIPTION: This parameter forces the minimum synchronization level. It controls the level of synchronization between the debugger and the target. The available levels are off (default), syncState, postInsnIO, and postInsnAll.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_class_marks_example/ARMCM3_config.txt#_snippet_3\n\nLANGUAGE: Configuration\nCODE:\n```\narmcortexm3ct.min_sync_level=3                        # (int   , run-time ) default = '0x0'    : force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)\n```\n\n----------------------------------------\n\nTITLE: Installing CMake on Ubuntu 18.04/20.04\nDESCRIPTION: This snippet installs CMake on Ubuntu 18.04 or 20.04 using the apt-get package manager. CMake is a cross-platform build system generator used to manage the build process of the project.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/README.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install cmake\n```\n\n----------------------------------------\n\nTITLE: MDK-ARM Linker Configuration for ThreadX Dynamic Memory Allocation\nDESCRIPTION: This snippet demonstrates two methods for configuring the MDK-ARM linker file (.sct or tx_low_level_initilize.s) to enable dynamic memory allocation for ThreadX. It involves either defining the RW_IRAM1 region in the .sct file or modifying the tx_low_level_initilize.s file to match the memory region being used, by setting the limit to |Image$$RW_IRAM1$$ZI$$Limit|.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/STM32H573I-DK/Applications/USBX/Ux_Device_DFU/README.md#_snippet_1\n\nLANGUAGE: Other\nCODE:\n```\neither define the RW_IRAM1 region in the \".sct\" file\nor modify the line below in \"tx_low_level_initilize.s to match the memory region being used\n    LDR r1, =|Image$$RW_IRAM1$$ZI$$Limit|\n```\n\n----------------------------------------\n\nTITLE: Define POP3 Test Cases\nDESCRIPTION: This CMake snippet defines the variable `pop3_test_cases`, listing the C source files that implement test cases for the NetX POP3 client.  These tests focus on mail reception, handling end markers, and processing abnormal packets.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_17\n\nLANGUAGE: CMake\nCODE:\n```\nset(pop3_test_cases\n    ${SOURCE_DIR}/pop3_test/netx_pop3_two_mails_received_test.c\n    ${SOURCE_DIR}/pop3_test/netx_pop3_mail_receive_test.c\n    ${SOURCE_DIR}/pop3_test/netx_pop3_packet_with_endmarker_test.c\n    ${SOURCE_DIR}/pop3_test/netx_pop3_abnormal_packet_test.c)\n\n```\n\n----------------------------------------\n\nTITLE: Passing Additional Parameters\nDESCRIPTION: Example usage of passing additional parameters to New-TestResources.ps1. These parameters are used to further configure resource deployment options.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/README.md#_snippet_7\n\nLANGUAGE: PowerShell\nCODE:\n```\nNew-TestResources.ps1 keyvault -AdditionalParameters @{enableHsm = $true}\n```\n\n----------------------------------------\n\nTITLE: CMake Project Setup\nDESCRIPTION: This snippet sets up the CMake project, specifying the minimum required CMake version, setting a CMake policy, and defining the project name. It initializes the C language support.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/test/cmake/samples/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.0.0 FATAL_ERROR)\ncmake_policy(SET CMP0057 NEW)\n\nproject(samples LANGUAGES C)\n```\n\n----------------------------------------\n\nTITLE: Create Map File\nDESCRIPTION: This snippet creates a map file named `az_iot_provisioning_test.map` for the `az_iot_provisioning_test` executable, which is useful for debugging and analyzing the memory layout of the application.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/provisioning/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ncreate_map_file(az_iot_provisioning_test az_iot_provisioning_test.map)\n```\n\n----------------------------------------\n\nTITLE: Generate PowerShell Help\nDESCRIPTION: Uses platyPS to generate markdown documentation for PowerShell scripts. This documentation is then converted to help files.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/README.md#_snippet_9\n\nLANGUAGE: PowerShell\nCODE:\n```\nInstall-Module platyPS -Scope CurrentUser -Force\nNew-MarkdownHelp -Command .\\New-TestResources.ps1 -OutputFolder . -Force\n```\n\n----------------------------------------\n\nTITLE: Transparent Cooked Key Derivation Type Definition (PSA)\nDESCRIPTION: This code snippet defines an opaque type definition for memory used by a transparent driver during cooked key derivation, if the 'memory' property in the driver capability is true. The actual type is driver-specific. This memory object is allocated by the core and passed to the derive_key function for state management between calls.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_20\n\nLANGUAGE: C\nCODE:\n```\ntypedef ... acme_derive_key_memory_t; // only if the \"memory\" property is true\n```\n\n----------------------------------------\n\nTITLE: Arm Cortex M3 CT Configuration Parameters\nDESCRIPTION: Defines configuration parameters for the ARM Cortex M3 CT component. Parameters control semihosting, cycle calculation (CPI), and synchronization levels. These settings allow for customization of the debugging and performance analysis capabilities.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_variance_example/ARMCM3_config.txt#_snippet_0\n\nLANGUAGE: config\nCODE:\n```\narmcortexm3ct.semihosting-enable=0                    # (bool  , init-time) default = '1'      : Enable semihosting SVC traps. Applications that do not use semihosting must set this parameter to false.\narmcortexm3ct.cpi_div=1                               # (int   , run-time ) default = '0x1'    : divider for calculating CPI (Cycles Per Instruction)\narmcortexm3ct.cpi_mul=1                               # (int   , run-time ) default = '0x1'    : multiplier for calculating CPI (Cycles Per Instruction)\narmcortexm3ct.min_sync_level=3                        # (int   , run-time ) default = '0x0'    : force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)\n```\n\n----------------------------------------\n\nTITLE: CPI Multiplier Configuration\nDESCRIPTION: This parameter sets the multiplier for calculating Cycles Per Instruction (CPI). CPI is a metric used to assess the performance of the application. Adjusting the multiplier impacts the calculated CPI value, affecting performance analysis.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Examples/ARM/arm_signal_converge_example/ARMCM3_config.txt#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\narmcortexm3ct.cpi_mul=1\n```\n\n----------------------------------------\n\nTITLE: Defining types-jsonschema Dependency with Version Constraint\nDESCRIPTION: This line defines a dependency on the `types-jsonschema` package, which provides type annotations for jsonschema. Version 3.2.0 or greater is required.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/scripts/driver.requirements.txt#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ntypes-jsonschema >= 3.2.0\n```\n\n----------------------------------------\n\nTITLE: Adding CMocka Test Environment\nDESCRIPTION: This snippet adds a CMocka test environment, setting up any necessary environment variables or configurations required for the CMocka tests to run correctly. The `add_cmocka_test_environment` macro configures the test environment for the specified test target.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/hub/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_cmocka_test_environment(az_iot_hub_test)\n```\n\n----------------------------------------\n\nTITLE: Update Resource Group by Name and Subscription - PowerShell\nDESCRIPTION: This example demonstrates how to update the 'DeleteAfterHours' property of a resource group identified by its name and subscription ID. The script updates the resource group to be deleted after 48 hours from now if a clean-up script is running against the specified subscription.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/Update-TestResources.ps1.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nUpdate-TestResources.ps1 -ResourceGroupName rg-userkeyvault -Subscription fa9c6912-f641-4226-806c-5139584b89ca\n```\n\n----------------------------------------\n\nTITLE: Conditional Compile Definitions\nDESCRIPTION: This conditional statement adds a compile definition if both `CONFIGTABLE` and `ALLFAST` flags are enabled. This allows for optimized code generation based on selected configurations, potentially enabling faster table lookups. The `ARM_ALL_FAST_TABLES` macro likely controls the use of precomputed tables.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ControllerFunctions/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif (CONFIGTABLE AND ALLFAST)\n    target_compile_definitions(CMSISDSPController PUBLIC ARM_ALL_FAST_TABLES)  \nendif()\n```\n\n----------------------------------------\n\nTITLE: CMake Configuration Example\nDESCRIPTION: This snippet demonstrates how to define MBEDTLS_CONFIG_FILE using CMake. It first removes CMake cache files, then sets the CFLAGS variable similar to the Makefile example, including the path to the custom configuration file and defining the MBEDTLS_CONFIG_FILE macro, before running CMake and Make. This allows users to keep their custom configuration outside the Mbed TLS tree.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/configs/README.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfind . -iname '*cmake*' -not -name CMakeLists.txt -exec rm -rf {} +\nCFLAGS=\"-I$PWD/configs -DMBEDTLS_CONFIG_FILE='<foo.h>'\" cmake .\nmake\n```\n\n----------------------------------------\n\nTITLE: Initialize CMake Project\nDESCRIPTION: This snippet initializes the CMake project, sets the minimum required CMake version, specifies the C language standard, and sets the project name to `az_iot_provisioning_test`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/tests/iot/provisioning/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.10)\n\nproject (az_iot_provisioning_test LANGUAGES C)\n\nset(CMAKE_C_STANDARD 99)\n```\n\n----------------------------------------\n\nTITLE: Setting System Time on VxWorks Shell\nDESCRIPTION: This snippet shows how to set the system date and time in the VxWorks command shell. Setting the correct time is crucial for server certificate verification. Requires INCLUDE_IPCOM_USE_TIME_CMD VIP component to be included in the VxWorks image.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/sdk/samples/iot/docs/how_to_iot_hub_samples_vxworks.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n[vxWorks *]# date 2021-09-06\nok\n[vxWorks *]# time 17:00:00\nok\n[vxWorks *]# date\nMon Sep  6 17:00:01 2021\n```\n\n----------------------------------------\n\nTITLE: Creating Simulated Interrupt Thread\nDESCRIPTION: This code snippet shows how to create a simulated interrupt thread in Linux using pthread_create and set its priority using pthread_setschedparam with SCHED_FIFO scheduling policy.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports_smp/linux/gnu/readme_threadx.txt#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nstruct sched_param sp;\n\n       /* Create the ISR thread */\n       pthread_create(&_sample_linux_interrupt_thread, NULL, _sample_linux_interrupt_entry, &_sample_linux_interrupt_thread);\n\n       /* Set up the ISR priority */\n       sp.sched_priority = TX_LINUX_PRIORITY_ISR;\n       pthread_setschedparam(_sample_linux_interrupt_thread, SCHED_FIFO, &sp);\n```\n\n----------------------------------------\n\nTITLE: Suppress VSO Commands Parameter\nDESCRIPTION: Suppresses the output of secrets to logs with Azure Pipelines log commands, preventing redaction.  This flag is useful for CI environments that don't support these commands, avoiding issues in environments like stress test clusters.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_19\n\nLANGUAGE: yaml\nCODE:\n```\nType: SwitchParameter\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: ($null -eq $env:SYSTEM_TEAMPROJECTID)\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Destroy Key Prototype - C\nDESCRIPTION: Defines the function prototype for the `destroy_key` entry point in a PSA opaque driver. This function invalidates the internal identifier and destroys the associated key material in a secure element with storage. It takes key attributes, a key buffer, and the buffer size as input and returns a PSA status.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/proposed/psa-driver-interface.md#_snippet_44\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t acme_destroy_key(const psa_key_attributes_t *attributes,\n                              const uint8_t *key_buffer,\n                              size_t key_buffer_size);\n```\n\n----------------------------------------\n\nTITLE: Registering an ISR to a Resource in C\nDESCRIPTION: This C code demonstrates how to register an ISR to a resource using the RegisterISRtoResource function. The ISR cannot be a category 1 ISR. The function takes the resource and the ISR ID as parameters, and returns a StatusType.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_10\n\nLANGUAGE: C\nCODE:\n```\nStatusType RegisterISRtoResource(ResourceType Resource, \n                                     ISRType ISRID);\n```\n\n----------------------------------------\n\nTITLE: Defining Driver Availability in Header File (C)\nDESCRIPTION: This snippet shows how to define a macro that indicates whether the custom driver is enabled, including defining `PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT` if not already defined. This enables conditional compilation of driver-specific code within Mbed TLS.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-driver-example-and-guide.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#if defined(DRIVER_PREFIX_ENABLED)\n#ifndef PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT\n#define PSA_CRYPTO_ACCELERATOR_DRIVER_PRESENT\n#endif\n\n// other definitions here\n\n#endif\n```\n\n----------------------------------------\n\nTITLE: Executing Build Operation (ThreadX Modules)\nDESCRIPTION: This command executes the build operation on all ThreadX Modules IAR examples. The azrtos_cicd.old.bat script is called with the 'build' parameter, followed by the target framework ('txm') and the toolchain ('iar'). This will compile the specified example projects using the IAR toolchain.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/test/ports/README.old.md#_snippet_2\n\nLANGUAGE: batch\nCODE:\n```\nazrtos_cicd.old.bat build txm iar\n```\n\n----------------------------------------\n\nTITLE: Adding MFCC source files (float16) in CMake\nDESCRIPTION: This snippet adds MFCC (Mel-Frequency Cepstral Coefficients) source files for float16 data type to the CMSISDSPTransform library if ARMAC5 is not defined and DISABLEFLOAT16 is not defined.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_29\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\ntarget_sources(CMSISDSPTransform PRIVATE arm_mfcc_init_f16.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_mfcc_f16.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Creating a Thread with tm_thread_create in C\nDESCRIPTION: This function creates a thread with the specified priority. Priority 1 is the highest, and 16 is the lowest. Returns TM_SUCCESS if successful, TM_ERROR otherwise. The created thread is not started automatically.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nint  tm_thread_create(int thread_id, int priority, void (*entry_function)(void));\n```\n\n----------------------------------------\n\nTITLE: UART Console Menu Display\nDESCRIPTION: This code snippet represents the menu displayed on the UART console after the application starts. It allows the user to select options such as starting the bootloader or displaying data.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H503RB/Applications/ROT/OEMiROT_Appli/README.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n=================== Main Menu =============================\n Start BootLoader -------------------------------------- 1\n Display Data ------------------------------------------ 2\n Selection :\n```\n\n----------------------------------------\n\nTITLE: Using psa_constant_names to Convert PSA Constants\nDESCRIPTION: This example shows how to use the `psa_constant_names` program to convert various PSA constants like error codes, key types, and algorithms to a programmer-friendly representation. It's useful for debugging and understanding the meaning of these constants.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/psa-transition.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ programs/psa/psa_constant_names error -138\nPSA_ERROR_BUFFER_TOO_SMALL\n$ programs/psa/psa_constant_names type 0x7112\nPSA_KEY_TYPE_ECC_KEY_PAIR(PSA_ECC_FAMILY_SECP_R1)\n$ programs/psa/psa_constant_names alg 0x06000609\nPSA_ALG_ECDSA(PSA_ALG_SHA_256)\n```\n\n----------------------------------------\n\nTITLE: Simulated Interrupt Thread Template in C\nDESCRIPTION: Provides a template for a simulated interrupt thread that executes periodically. It includes sleeping for a desired time, saving and restoring the ThreadX context, and calling the application's ISR (Interrupt Service Routine).\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/ports/win32/vs_2019/readme_threadx.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nDWORD WINAPI _sample_win32_interrupt(LPVOID *ptr)\n{\n\n\n    while(1)\n    {\n\n        /* Sleep for the desired time.  */\n        Sleep(18);\n\n        /* Call ThreadX context save for interrupt preparation.  */\n        _tx_thread_context_save();\n\n        /* Call application ISR here!  */\n\n        /* Call ThreadX context restore for interrupt completion.  */\n        _tx_thread_context_restore();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: EWARM Linker File Modification\nDESCRIPTION: This code snippet shows how to modify the EWARM linker file (.icf) to define the location of the free memory for dynamic memory allocation used by ThreadX.  It places the 'FREE_MEM' section in the 'RAM_region' so ThreadX can access it for heap management. This is a prerequisite for using dynamic memory allocation within ThreadX.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Projects/NUCLEO-H563ZI/Applications/ThreadX/Tx_SecureLEDToggle_TrustZone/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nplace in RAM_region    { last section FREE_MEM };\n```\n\n----------------------------------------\n\nTITLE: PSA Algorithm Conversion\nDESCRIPTION: This inline function converts an `mbedtls_md_info_t` structure to a `psa_algorithm_t`. It checks for a NULL pointer and returns `PSA_ALG_NONE` if the input is NULL. Otherwise, it combines the `PSA_ALG_CATEGORY_HASH` category with the `type` field of the `mbedtls_md_info_t` structure to create the `psa_algorithm_t`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-migration/md-cipher-dispatch.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nstatic inline psa_algorithm_t psa_alg_of_md_info(\n    const mbedtls_md_info_t *md_info )\n{\n    if( md_info == NULL )\n        return( PSA_ALG_NONE );\n    return( PSA_ALG_CATEGORY_HASH | md_info->type );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Executable Lists\nDESCRIPTION: This CMake snippet defines two lists of executables: one that does not use the 'common.c' source file and another that does. This separation allows for differentiated build configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/programs/fuzz/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(executables_no_common_c\n    fuzz_pubkey\n    fuzz_x509crl\n    fuzz_x509crt\n    fuzz_x509csr\n    fuzz_pkcs7\n)\n\nset(executables_with_common_c\n    fuzz_privkey\n    fuzz_client\n    fuzz_dtlsclient\n    fuzz_dtlsserver\n    fuzz_server\n)\n```\n\n----------------------------------------\n\nTITLE: Adding Executables and Tests\nDESCRIPTION: This snippet iterates through the list of web test cases, creates an executable for each test case, links the `test_utility` library to each executable, and adds each executable as a test to the CTest test suite. The test name is derived from the filename of the test case.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/web/regression/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nforeach(\n  test_case\n  ${web_test_cases})\n  get_filename_component(test_name ${test_case} NAME_WE)\n  add_executable(${test_name} ${test_case})\n  target_link_libraries(${test_name} PRIVATE test_utility)\n  add_test(${CMAKE_BUILD_TYPE}::${test_name} ${test_name})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: License Notice - zlib Compression Library\nDESCRIPTION: This snippet contains the full license notice for the zlib compression library, version 1.2.11. It grants permission to use, alter, and redistribute the software freely, subject to specific restrictions regarding the origin of the software and the inclusion of the license notice.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/NOTICE.txt#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n/* zlib.h -- interface of the 'zlib' general purpose compression library\n  version 1.2.11, January 15th, 2017\n\n  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Jean-loup Gailly        Mark Adler\n  jloup@gzip.org          madler@alumni.caltech.edu\n\n*/\n```\n\n----------------------------------------\n\nTITLE: Auto-initialization Configuration in FreeRTOSConfig.h (C)\nDESCRIPTION: This code snippet enables the auto-initialization feature. When this configuration is set to 1 and the corresponding preprocessor definition is added to `tx_user.h`, the adaptation layer will be automatically initialized by the first call to an object create function.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/FreeRTOS/readme.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n#define TX_FREERTOS_AUTO_INIT 1\n```\n\n----------------------------------------\n\nTITLE: Configuring RFFT Options (Double Precision) in CMake\nDESCRIPTION: This code snippet defines CMake options to enable or disable Real FFT (RFFT) implementations for double-precision floating-point numbers (f64) with various sizes (128 to 8192). These options are used to customize the CMSIS-DSP library by selecting specific RFFT implementations for different sizes.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/CMakeLists.txt#_snippet_15\n\nLANGUAGE: CMake\nCODE:\n```\noption(RFFT_F64_128         \"rfft f64 128\"                      OFF)\noption(RFFT_F64_512         \"rfft f64 512\"                      OFF)\noption(RFFT_F64_2048        \"rfft f64 2048\"                     OFF)\noption(RFFT_F64_8192        \"rfft f64 8192\"                     OFF)\n```\n\n----------------------------------------\n\nTITLE: Filtering USBX Sources for Optimized Build\nDESCRIPTION: This CMake code block conditionally filters the source files of the `usbx` target when the `CMAKE_BUILD_TYPE` is set to `optimized_build`. It removes files specified in the `UX_OPTIMIZED_EXCLUDES` variable from the source lists using `list(FILTER)` and updates the target properties.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/usbx/test/cmake/usbx/CMakeLists.txt#_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\nset(UX_OPTIMIZED_EXCLUDES\n  ux_device_class_rndis # buffer smaller than message size\n)\nif(CMAKE_BUILD_TYPE STREQUAL \"optimized_build\")\n  get_target_property(test_utility_SOURCES_LIST test_utility SOURCES)\n  get_target_property(SOURCES_LIST usbx SOURCES)\n\n  # Remove files not support STANDALONE yet\n  foreach(EXCLUDE_VAL ${UX_OPTIMIZED_EXCLUDES})\n    list(FILTER test_utility_SOURCES_LIST EXCLUDE REGEX \".*${EXCLUDE_VAL}.*\")\n    list(FILTER SOURCES_LIST EXCLUDE REGEX \".*${EXCLUDE_VAL}.*\")\n  endforeach()\n\n  # Commit sources and includes changes\n  set_target_properties(test_utility PROPERTIES SOURCES \"${test_utility_SOURCES_LIST}\")\n  set_target_properties(usbx PROPERTIES SOURCES \"${SOURCES_LIST}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Complex FFT Radix 4 init source file (float16) in CMake\nDESCRIPTION: This snippet conditionally adds arm_cfft_radix4_init_f16.c and arm_cfft_radix4_f16.c as private source files to the CMSISDSPTransform library if ARMAC5 is not defined and DISABLEFLOAT16 is not defined and based on Real FFT configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/TransformFunctions/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nif ((NOT ARMAC5) AND (NOT DISABLEFLOAT16))\nif (NOT CONFIGTABLE OR ALLFFT OR RFFT_F16_128 OR RFFT_F16_512 OR RFFT_F16_2048 OR RFFT_F16_8192)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_init_f16.c)\ntarget_sources(CMSISDSPTransform PRIVATE arm_cfft_radix4_f16.c)\nendif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting OSEK Hook Routines in C\nDESCRIPTION: This code snippet demonstrates how to set various hook routines available within OSEK during initialization by setting the handler members of the APPLICATION_INFO structure passed to osek_initialize(). It shows assignment of ErrorHook, StartupHook, ShutdownHook, PreTaskHook and PostTaskHook.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/rtos_compatibility_layers/OSEK/threadx_osek_readme.txt#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\napp.error_hook_handler = ErrorHook;\napp.startup_hook_handler = StartupHook;\napp.shutdown_hook_handler = ShutdownHook;\napp.pretask_hook_handler = PreTaskHook;\napp.posttask_hook_handler = PostTaskHook;\n```\n\n----------------------------------------\n\nTITLE: Moving Context Objects in Memory\nDESCRIPTION: This code demonstrates how a context object should be able to be moved in memory. This ensures that applications that populate a context on the stack of an inner function and then copy the context upwards through the call chain, or applications written in a language with automatic memory management that can move objects on the heap will still work.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/alternative-implementations.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nmbedtls_xxx_context ctx1, ctx2;\nmbedtls_xxx_init(&ctx1);\nmbedtls_xxx_setup(&ctx1, …);\nctx2 = ctx1;\nmemset(&ctx1, 0, sizeof(ctx1));\nmbedtls_xxx_do_stuff(&ctx2, …);\nmbedtls_xxx_free(&ctx2);\n```\n\n----------------------------------------\n\nTITLE: Memory Poisoning Wrapper Function in C\nDESCRIPTION: This C code defines a wrapper function, `mem_poison_psa_aead_update`, around `psa_aead_update` for memory poisoning during testing. It poisons input and output buffers before calling the original function and unpoisons them afterward. A macro then redefines the original function to call the wrapper, enabling transparent memory poisoning during tests. It leverages `mbedtls_test_memory_poison` and `mbedtls_test_memory_unpoison` to perform the poisoning/unpoisoning.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/docs/architecture/psa-shared-memory.md#_snippet_6\n\nLANGUAGE: C\nCODE:\n```\npsa_status_t mem_poison_psa_aead_update(psa_aead_operation_t *operation,\n                                        const uint8_t *input,\n                                        size_t input_length,\n                                        uint8_t *output,\n                                        size_t output_size,\n                                        size_t *output_length)\n{\n    mbedtls_test_memory_poison(input, input_length);\n    mbedtls_test_memory_poison(output, output_size);\n    psa_status_t status = psa_aead_update(operation, input, input_length,\n                                          output, output_size, output_length);\n    mbedtls_test_memory_unpoison(input, input_length);\n    mbedtls_test_memory_unpoison(output, output_size);\n\n    return status;\n}\n\n#define psa_aead_update(...) mem_poison_psa_aead_update(__VA_ARGS__)\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation: Secure TLS Sample\nDESCRIPTION: This snippet adds the secure TLS sample file (`demo_netx_secure_tls.c`) to the `sample_files` list if both `-DNX_DISABLE_IPV4` and `-DNX_DISABLE_PACKET_CHAIN` are NOT present in the `CMAKE_BUILD_TYPE`.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/samples/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif((NOT \"-DNX_DISABLE_IPV4\" IN_LIST ${CMAKE_BUILD_TYPE})\n    AND NOT (\"-DNX_DISABLE_PACKET_CHAIN\" IN_LIST ${CMAKE_BUILD_TYPE}))\n  list(APPEND sample_files ${SOURCE_DIR}/demo_netx_secure_tls.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Target Compile Definitions (ALLFAST)\nDESCRIPTION: Conditionally adds a compile definition ARM_ALL_FAST_TABLES to the CMSISDSPFiltering library if both CONFIGTABLE and ALLFAST are true. This definition likely enables the use of precomputed tables for faster computation, potentially at the cost of memory usage.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif (CONFIGTABLE AND ALLFAST)\ntarget_compile_definitions(CMSISDSPFiltering PUBLIC ARM_ALL_FAST_TABLES)  \nendif()\n```\n\n----------------------------------------\n\nTITLE: Include Interpolation\nDESCRIPTION: Includes and applies an interpolation function to the CMSISDSPFiltering library. This likely involves generating or modifying code based on some template or rule.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/FilteringFunctions/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(interpol)\ninterpol(CMSISDSPFiltering)\n```\n\n----------------------------------------\n\nTITLE: Include Interpolation Module\nDESCRIPTION: This snippet includes an interpolation module, likely containing CMake functions to handle interpolation-related configuration for the CMSISDSPController library. `interpol()` is called to apply those configurations.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/ControllerFunctions/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(interpol)\ninterpol(CMSISDSPController)\n```\n\n----------------------------------------\n\nTITLE: CMake Minimum Version and Project Setup\nDESCRIPTION: This snippet sets the minimum required CMake version to 3.14 and defines the project name as CMSISDSPSVM. It also includes configLib and configDsp.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Drivers/CMSIS/DSP/Source/SVMFunctions/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required (VERSION 3.14)\n\nproject(CMSISDSPSVM)\n\ninclude(configLib)\ninclude(configDsp)\n```\n\n----------------------------------------\n\nTITLE: Setting TFTP Test Case Sources CMake\nDESCRIPTION: This snippet defines the source files for TFTP tests in CMake.  The `tftp_test_cases` variable is assigned a list of C files related to TFTP functionality, located in the `${SOURCE_DIR}/tftp_test/` directory.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/test/cmake/netxduo/regression/CMakeLists.txt#_snippet_32\n\nLANGUAGE: CMake\nCODE:\n```\nset(tftp_test_cases\n    ${SOURCE_DIR}/tftp_test/netx_tftp_basic_test.c\n    ${SOURCE_DIR}/tftp_test/netx_tftp_write_interaction_test.c\n    ${SOURCE_DIR}/tftp_test/netx_tftp_error_file_name_test.c\n    ${SOURCE_DIR}/tftp_test/netx_tftp_read_interaction_test.c\n    ${SOURCE_DIR}/tftp_test/netx_tftp_error_destionation_port_test.c\n    ${SOURCE_DIR}/tftp_test/netx_tftp_malformed_packet_test.c)\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories in CMake\nDESCRIPTION: This snippet uses the `target_include_directories` CMake command to specify the include directories that should be used when compiling the target. This allows the compiler to find the header files for the NAND and NOR flash memory management.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/levelx/common/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(${PROJECT_NAME} PUBLIC \n    ${CMAKE_CURRENT_LIST_DIR}/inc\n)\n```\n\n----------------------------------------\n\nTITLE: Project Definition and Testing\nDESCRIPTION: Defines the project name as \"az\" and enables testing. The `project()` command sets the project name, and `enable_testing()` enables the CTest testing framework.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nproject(az LANGUAGES C)\nenable_testing ()\n```\n\n----------------------------------------\n\nTITLE: Suspending a Thread with tm_thread_suspend in C\nDESCRIPTION: This function suspends a previously created thread. It takes the thread_id as input and returns TM_SUCCESS if the suspend operation is successful.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/threadx/utility/benchmarks/thread_metric/thread_metric_readme.txt#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nint  tm_thread_suspend(int thread_id);\n```\n\n----------------------------------------\n\nTITLE: CI Parameter\nDESCRIPTION: Indicates whether the script is being run as part of a Continuous Integration / Continuous Deployment (CI/CD) build.  This parameter is used to adjust the script's behavior based on whether it is running in a CI/CD environment, specifically Azure Pipelines.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\nType: SwitchParameter\nParameter Sets: (All)\nAliases:\n\nRequired: False\nPosition: Named\nDefault value: ($null -ne $env:SYSTEM_TEAMPROJECTID)\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: XML File Structure Example (Bash)\nDESCRIPTION: This snippet shows the basic structure of an XML parameter used by the Trust Package Creator (TPC) tool. Each `<Param>` element contains tags such as `<Name>`, `<Link>`, `<Type>`, `<Command>`, `<Hidden>`, `<Enable>`, `<Info>`, and `<Default>`, which define various attributes of the parameter.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/ROT_AppliConfig/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n\t<Param>\n\t\t<Name></Name>\n\t\t<Link></Link>\n\t\t<Type></Type>\n\t\t<Command></Command>\n\t\t<Hidden></Hidden>\n\t\t<Enable></Enable>\n\t\t<Info></Info>\n\t\t<Default></Default>\n\t</Param>\n```\n\n----------------------------------------\n\nTITLE: WhatIf Parameter\nDESCRIPTION: Shows what would happen if the cmdlet runs, without actually running it. This is a standard PowerShell parameter for previewing the effects of a command.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\nType: SwitchParameter\nParameter Sets: (All)\nAliases: wi\n\nRequired: False\nPosition: Named\nDefault value: None\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: Provisioner Application Secret Parameter\nDESCRIPTION: The service principal secret (password) to use for provisioning test resources when a provisioner is specified. This secret enables the provisioner application to authenticate and perform actions within Azure. This value is not passed to the ARM template.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/ST/netxduo/addons/azure_iot/azure-sdk-for-c/eng/common/TestResources/New-TestResources.ps1.md#_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nType: String\nParameter Sets: Provisioner\nAliases:\n\nRequired: True\nPosition: Named\nDefault value: None\nAccept pipeline input: False\nAccept wildcard characters: False\n```\n\n----------------------------------------\n\nTITLE: HASH HAL Migrator Usage Example (Python)\nDESCRIPTION: This is an example of how to use the HASH_HAL_Migrator.py script. It requires the -p argument to specify the project workspace path. The --verbose option is optional and prints debug information.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Utilities/PC_Software/HASH_HAL_Migrator/Resources/script_usage.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nHASH_HAL_Migrator.py -p \"Project_Location\"\n```\n\n----------------------------------------\n\nTITLE: Cloning STM32CubeH5 Repository\nDESCRIPTION: Clones the STM32CubeH5 repository with all submodules. The `--recursive` option ensures that all submodules are initialized and cloned along with the main repository. This is the recommended method for obtaining the complete package.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recursive https://github.com/STMicroelectronics/STM32CubeH5.git\n```\n\n----------------------------------------\n\nTITLE: Listing CMake Options\nDESCRIPTION: This snippet shows how to list the available CMake options using the `-LH` flag. This provides a comprehensive overview of configurable parameters.\nSOURCE: https://github.com/stmicroelectronics/stm32cubeh5/blob/main/Middlewares/Third_Party/mbed-crypto/README.md#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\ncmake -LH\n```"
  }
]