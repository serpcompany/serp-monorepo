[
  {
    "owner": "matrix-org",
    "repo": "matrix-rust-sdk",
    "content": "TITLE: Initializing and Using Matrix Client in Rust\nDESCRIPTION: Demonstrates how to create a Matrix client instance asynchronously using the matrix-rust-sdk crate, login a user via username and password, register an event handler for incoming room messages, and perform continuous synchronization with a Matrix homeserver. Dependencies include Tokio for async runtime and anyhow for error handling. The key parameters are the user ID, password, and SyncSettings to control syncing behavior. The input is a Matrix user ID and password, producing a running client that outputs received message events to the console. The example also highlights the use of the builder pattern and event handler closure. Error-prone actions return a Result type to propagate failures.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse matrix_sdk::{\n    Client, config::SyncSettings,\n    ruma::{user_id, events::room::message::SyncRoomMessageEvent},\n};\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let alice = user_id!(\"@alice:example.org\");\n    let client = Client::builder().server_name(alice.server_name()).build().await?;\n\n    // First we need to log in.\n    client.matrix_auth().login_username(alice, \"password\").send().await?;\n\n    client.add_event_handler(|ev: SyncRoomMessageEvent| async move {\n        println!(\"Received a message {:?}\", ev);\n    });\n\n    // Syncing is important to synchronize the client state with the server.\n    // This method will never return unless there is an error.\n    client.sync(SyncSettings::default()).await?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Full Sliding Sync Example\nDESCRIPTION: This comprehensive example illustrates the complete process of setting up and using Sliding Sync, including list creation, stream handling, and room update subscriptions.  It demonstrates how to define sync lists with various sync modes and state requirements, and how to integrate room update streams.  Dependencies: `matrix_sdk`, `ruma`, `tracing`, `futures_util`, and `url`.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/src/sliding_sync/README.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(feature = \"client\")]\n# use matrix_sdk::{Client, sliding_sync::{SlidingSyncList, SlidingSyncMode, Version}};\n# use ruma::{api::client::sync::sync_events::v5 as http, assign, events::StateEventType};\n# use tracing::{warn, error, info, debug};\n# use futures_util::{pin_mut, StreamExt};\n# use url::Url;\n# use std::future::ready;\n# async {\n# let homeserver = Url::parse(\"http://example.com\")?;\n# let client = Client::new(homeserver).await?;\nlet full_sync_list_name = \"full-sync\".to_owned();\nlet active_list_name = \"active-list\".to_owned();\nlet sliding_sync_builder = client\n    .sliding_sync(\"main-sync\")?\n    .version(Version::Native)\n    .with_account_data_extension(\n        assign!(http::request::AccountData::default(), { enabled: Some(true) }),\n    ) // we enable the account-data extension\n    .with_e2ee_extension(assign!(http::request::E2EE::default(), { enabled: Some(true) })) // and the e2ee extension\n    .with_to_device_extension(\n        assign!(http::request::ToDevice::default(), { enabled: Some(true) }),\n    );\n\nlet full_sync_list = SlidingSyncList::builder(&full_sync_list_name)\n    .sync_mode(SlidingSyncMode::Growing { batch_size: 50, maximum_number_of_rooms_to_fetch: Some(500) }) // sync up by growing the window\n    .required_state(vec![\n        (StateEventType::RoomEncryption, \"\".to_owned())\n     ]); // only want to know if the room is encrypted\n\nlet active_list = SlidingSyncList::builder(&active_list_name) // the active window\n    .sync_mode(SlidingSyncMode::new_selective().add_range(0..=9))  // sync up the specific range only, first 10 items\n    .timeline_limit(5u32) // add the last 5 timeline items for room preview and faster timeline loading\n    .required_state(vec![ // we want to know immediately:\n        (StateEventType::RoomEncryption, \"\".to_owned()), // is it encrypted\n        (StateEventType::RoomTopic, \"\".to_owned()),      // any topic if known\n        (StateEventType::RoomAvatar, \"\".to_owned()),     // avatar if set\n     ]);\n\nlet sliding_sync = sliding_sync_builder\n    .add_list(active_list)\n    .add_list(full_sync_list)\n    .build()\n    .await?;\n\ntokio::spawn(async move {\n    // subscribe to rooms updates\n    let (_rooms, rooms_stream) = client.rooms_stream();\n    // do something with `_rooms`\n\n    pin_mut!(rooms_stream);\n    while let Some(_room) = rooms_stream.next().await {\n        info!(\"a room has been updated\");\n    }\n});\n\nlet stream = sliding_sync.sync();\n\n// continuously poll for updates\npin_mut!(stream);\nloop {\n    let update = match stream.next().await {\n        Some(Ok(u)) => {\n            info!(\"Received an update. Summary: {u:?}\");\n        },\n        Some(Err(e)) => {\n             error!(\"loop was stopped by client error processing: {e}\");\n        }\n        None => {\n            error!(\"Streaming loop ended unexpectedly\");\n            break;\n        }\n    };\n}\n\n# anyhow::Ok(())\n# };\n```\n\n----------------------------------------\n\nTITLE: Creating and enabling Key Backup in Matrix Rust SDK\nDESCRIPTION: Example showing how to create a new key backup and enable it for future encryption keys. This demonstrates the basic implementation pattern for setting up a key backup system in a Matrix client.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk-ui/README.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\n// Use some good entropy for the RecoveryKey\nlet recovery_key = RecoveryKey::new();\n\n// Store this somewhere (safely)!\nlet key_as_string = recovery_key.to_base58();\n\n// Create a new backup\nlet version = client.encryption().backup().create_backup(recovery_key).await?;\n\nlog::info!(\"Created backup version: {}\", version);\n\n// This version is now the \"current\" one\n// Enable the backup to start backing up keys\nclient.encryption().backup().enable_backup().await?;\n```\n```\n\n----------------------------------------\n\nTITLE: Importing existing room keys to Key Backup in Matrix Rust SDK\nDESCRIPTION: Example demonstrating how to back up existing room keys to a key backup. This is useful when setting up key backup for the first time on a client that already has encryption keys.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk-ui/README.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```\n// Use some good entropy for the RecoveryKey\nlet recovery_key = RecoveryKey::new();\n\n// Store this somewhere (safely)!\nlet key_as_string = recovery_key.to_base58();\n\n// Create a new backup\nlet version = client.encryption().backup().create_backup(recovery_key).await?;\n\n// Assuming we have existing room keys, back those up\nclient.encryption().backup().back_up_room_keys(None).await?;\n\n// Enable the backup to start backing up future keys\nclient.encryption().backup().enable_backup().await?;\n```\n```\n\n----------------------------------------\n\nTITLE: Diagram Visualizing Cross-Signing User Identities and Trusted Devices - text\nDESCRIPTION: This diagram demonstrates cross signing by showing user identities for Alice and Bob linked to their devices. Cross signing reduces verification complexity by allowing mutual verification of user identities that then implicitly verify all associated devices, simplifying trust establishment in E2EE.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/src/docs/encryption.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n\n           ┌─────────────────────────────────────────────────────────────────────────────────┐\n           │   ┌────────────────────────────────────────────────────────────│   │\n           ▼   │                                         ▼   │\n    ┌───────────────────────────────────────└\n    │┌────────────────────────│                   │  ┌──────────────────────────┐\n    ││Alice UserIdentity││                   │  │Bob UserIdentity│  │\n    │└─└─────────────└─────────│                   │  └─└────────────└─────────┐\n    │    │         │     │                   │    │           │     │\n    │    ▼         ▼     │                   │    ▼           ▼     │\n    │┌─────────│ ┌──────────│                   │┌───────────│  ┌─────────────│  │\n    ││ Alice │ │ Alice  ││                   ││  Bob  │  │   Bob   ││\n    ││ Phone │ │ Laptop ││                   ││ Phone │  │ Desktop ││\n    │└─────────│ └──────────│                   │└─────────────││\n    ┐─────────────────────────────────────────────────────┘\n\n\n```\n\n----------------------------------------\n\nTITLE: Recovering room keys from Key Backup in Matrix Rust SDK\nDESCRIPTION: Example showing how to recover room keys from a backup using the recovery key. This is used when restoring encryption keys on a new device or after a data loss.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk-ui/README.md#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n```\n// The RecoveryKey the user saved someplace safe\nlet recovery_key = RecoveryKey::from_base58(&key_as_string)?;\n\n// Either get the latest version...\nlet version = client.encryption().backup().latest_backup_info().await?\n    .ok_or_else(|| anyhow!(\"No backup exists!\"))?;\n\n// or a specific version\n// let version = client.encryption().backup().backup_info(\"some_version_id\").await?;\n\n// Verify the backup has a valid signature (optional)\nif !client.encryption().backup().verify_backup(&version, None).await? {\n    return Err(anyhow!(\"Backup signature invalid!\"));\n}\n\n// Check the recovery key is valid for this backup\nif !backup::recovery_key_matches(&recovery_key, &version) {\n    return Err(anyhow!(\"Recovery key doesn't match this backup!\"));\n}\n\n// Now download the actual keys\nlet room_keys = client.encryption().backup().room_keys(&version, &recovery_key).await?;\n\n// Import them\nlet result = client.encryption().import_room_keys(\n    room_keys.values().flatten().cloned().collect(), false, |_, _, _| {}\n).await;\n\nlog::info!(\n    \"Key import result: imported: {}, total: {}\",\n    result.imported_count, result.total_count\n);\n```\n```\n\n----------------------------------------\n\nTITLE: Pushing and Pulling Encryption State Changes with matrix-sdk-crypto in Rust\nDESCRIPTION: This Rust snippet demonstrates how to initialize an OlmMachine for a Matrix user device, then push encryption-related state changes retrieved from a homeserver sync response into the state machine. It also shows how to asynchronously pull outgoing requests that need to be sent back to the homeserver. Dependencies include matrix-sdk-crypto for the OlmMachine and Ruma for Matrix identifiers. The snippet handles keys counts, device lists, and batch tokens and expects to process sync events without network IO internally. The example uses Tokio for async runtime and handles potential OlmError failures.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk-crypto/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::BTreeMap;\n\nuse matrix_sdk_crypto::{EncryptionSyncChanges, OlmMachine, OlmError};\nuse ruma::{\n    api::client::sync::sync_events::{v3::ToDevice, DeviceLists},\n    device_id, user_id,\n};\n\n#[tokio::main]\nasync fn main() -> Result<(), OlmError> {\n    let alice = user_id!(\"@alice:example.org\");\n    let machine = OlmMachine::new(&alice, device_id!(\"DEVICEID\")).await;\n\n    let changed_devices = DeviceLists::default();\n    let one_time_key_counts = BTreeMap::default();\n    let unused_fallback_keys = Some(Vec::new());\n    let next_batch_token = \"T0K3N\".to_owned();\n\n    // Push changes that the server sent to us in a sync response.\n    let decrypted_to_device = machine.receive_sync_changes(EncryptionSyncChanges {\n        to_device_events: vec![],\n        changed_devices: &changed_devices,\n        one_time_keys_counts: &one_time_key_counts,\n        unused_fallback_keys: unused_fallback_keys.as_deref(),\n        next_batch_token: Some(next_batch_token),\n    }).await?;\n\n    // Pull requests that we need to send out.\n    let outgoing_requests = machine.outgoing_requests().await?;\n\n    // Send the requests here out and call machine.mark_request_as_sent().\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Matrix SDK with IndexedDB and E2E Encryption Features in Cargo.toml for Rust\nDESCRIPTION: This snippet shows how to configure the matrix-sdk dependency in Cargo.toml to enable the IndexedDB backend and end-to-end encryption features when compiling for wasm32 targets. It uses feature flags to disable default features and selectively enable 'indexeddb' and 'e2e-encryption'. The configuration ensures compatibility with web environments leveraging WebAssembly and the matrix-sdk-indexedddb crate.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk-indexeddb/README.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[target.'cfg(target_arch = \"wasm32\")'.dependencies]\nmatrix-sdk = { version = \"0.5, default-features = false, features = [\"indexeddb\", \"e2e-encryption\"] }\n```\n\n----------------------------------------\n\nTITLE: Polling Sliding Sync for Updates\nDESCRIPTION: This code demonstrates how to set up a sliding sync session, acquire the sync stream, and continuously poll for updates.  It shows how to handle successful updates and potential errors during the streaming process, which is crucial for real-time synchronization.  Dependencies: `matrix_sdk`, `futures_util`, `tracing`, `url`.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/src/sliding_sync/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(feature = \"client\")]\n# use futures_util::{pin_mut, StreamExt};\n# use matrix_sdk::Client;\n# use tracing::{error, info};\n# use url::Url;\n# async {\n# let homeserver = Url::parse(\"http://example.com\")?;\n# let client = Client::new(homeserver).await?;\nlet sliding_sync = client\n    .sliding_sync(\"main-sync\")?\n    // any lists you want are added here.\n    .build()\n    .await?;\n\nlet stream = sliding_sync.sync();\n\n// continuously poll for updates\npin_mut!(stream);\n\nloop {\n    let update = match stream.next().await {\n        Some(Ok(u)) => {\n            info!(\"Received an update. Summary: {u:?}\");\n        }\n        Some(Err(e)) => {\n            error!(\"loop was stopped by client error processing: {e}\");\n        }\n        None => {\n            error!(\"Streaming loop ended unexpectedly\");\n            break;\n        }\n    };\n}\n\n# anyhow::Ok(())\n# };\n```\n\n----------------------------------------\n\nTITLE: Visualizing End-to-End Encrypted Message Flow Using ASCII Diagram - text\nDESCRIPTION: This snippet shows an ASCII flowchart of messages encrypted end-to-end, meaning data is encrypted on the sender's device, remains encrypted on the homeserver, and is only decrypted on the recipient's device. It highlights that the server does not access plaintext messages.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/src/docs/encryption.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n                              ┌──────────────────────────────────────────┐\n                              │  Homeserver  │\n     ┌───────── │                │              │                ┌──────── │\n     │ Alice │≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡│\n     └──────┘   encrypted    │   ──────────────────────────│   encrypted    └──────┘\n                              ┘─────────────────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Visual Diagram of Encryption and Decryption Roles in Megolm Room Key Sessions - text\nDESCRIPTION: This snippet visually delineates the two parts of a Megolm session used for room key encryption: the outbound group session used for encrypting messages (kept private on sender's device), and the inbound group session shared with devices for decrypting messages, emphasizing the separation of encryption and decryption keys.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/src/docs/encryption.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n            ┌────────────────────────┬─────────────────────────┤───────────────────┤\n            │       Encryption       │      Decryption       │\n            ├────────────────────────┼─────────────────────────┤\n            │ Outbound group session │ Inbound group session │\n            └────────────────────────┴─────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Using StoreCipher for Encrypted Key/Value Storage in Rust\nDESCRIPTION: This snippet demonstrates initializing a StoreCipher for secure key/value storage, exporting the cipher with a passphrase, encrypting and decrypting a serde_json::Value, and hashing keys for table-specific obfuscation using Rust. Dependencies include matrix_sdk_store_encryption, serde_json, and anyhow. Input includes a JSON value and string keys; outputs are encrypted/decrypted data and hashed representations of keys, with output integrity verified through assertions. Limitations include the crate's warning that it is a low-level primitive not intended for direct application use, and users must adopt periodic key rotation and chunking for non-Matrix data to avoid security issues.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk-store-encryption/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse matrix_sdk_store_encryption::StoreCipher;\nuse serde_json::{json, value::Value};\n\nfn main() -> anyhow::Result<()> {\n    let store_cipher = StoreCipher::new()?;\n\n    // Export the store cipher and persist it in your key/value store\n    let export = store_cipher.export(\"secret-passphrase\")?;\n\n    let value = json!({\n        \"some\": \"data\",\n    });\n\n    let encrypted = store_cipher.encrypt_value(&value)?;\n    let decrypted: Value = store_cipher.decrypt_value(&encrypted)?;\n\n    assert_eq!(value, decrypted);\n\n    let key = \"bulbasaur\";\n\n    // Hash the key so people don't know which pokemon we have collected.\n    let hashed_key = store_cipher.hash_key(\"list-of-pokemon\", key.as_ref());\n    let another_table = store_cipher.hash_key(\"my-starter\", key.as_ref());\n    let same_key = store_cipher.hash_key(\"my-starter\", key.as_ref());\n\n    assert_ne!(key.as_ref(), hashed_key);\n    assert_ne!(hashed_key, another_table);\n    assert_eq!(another_table, same_key);\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Diagram Depicting Manual Device-to-Device Verification Between Users - text\nDESCRIPTION: This ASCII diagram visualizes the complexity arising from the requirement that each device (end) of one user must independently verify each device of the other user to establish trust in encrypted communication. It shows devices of Alice and Bob with verification arrows representing trust relationships necessary for secure messaging.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/src/docs/encryption.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n\n              ┌─────────────────────────────────────────────┐\n              ▼                                           │\n        ┌───────────────────────────────────────────────────│\n      ►│Alice Phone│││││││││││││││││││││││││││││││││││││││││││││►│Bob Phone│◄──┐\n      │ └───┼─────┘                                └───┼─────┘   │\n      │       ▼                                            ▼       │\n      │ ┌────────────────────────│                               ┌──────────────────────┐ │\n      └────────│Alice Laptop││││││││││││││││││││││►│Bob Desktop│─└\n        └───────────────────────────────┘                               └────┼─────┘\n              ▲                                            │\n              ┐──────────────────────────────┘\n\n\n```\n\n----------------------------------------\n\nTITLE: Encoding Matrix Verification Data to QR Code with matrix-sdk-qrcode (Rust)\nDESCRIPTION: This Rust snippet encodes verification data into a QR code image using the matrix-sdk-qrcode crate. It constructs a byte array following the Matrix QR code specification, parses it into a QrVerificationData object, generates a QR code, and renders it to an image using the image crate. Requires the matrix_sdk_qrcode and image crates; input is a binary buffer and output is a rendered image. Errors may occur if the input data does not conform to the expected Matrix QR code format.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk-qrcode/README.md#_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse matrix_sdk_qrcode::{QrVerificationData, DecodingError};\nuse image::Luma;\n\nfn main() -> Result<(), DecodingError> {\n    let data = b\"MATRIX\\\n        \\x02\\x02\\x00\\x07\\\n        FLOW_ID\\\n        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\n        BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\\\n        SHARED_SECRET\";\n\n    let data = QrVerificationData::from_bytes(data)?;\n    let encoded = data.to_qr_code().unwrap();\n    let image = encoded.render::<Luma<u8>>().build();\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a List with Filters in Sliding Sync\nDESCRIPTION: Demonstrates how to create a list configuration that filters for invite rooms and displays the top 10 most recent conversations, which is a common UI pattern for client applications.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/src/sliding_sync/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet list_builder = SlidingSyncList::builder(\"main_list\")\n    .sync_mode(SlidingSyncMode::new_selective().add_range(0..=9))\n    .filters(Some(assign!(\n        http::request::ListFilters::default(), { is_invite: Some(true)}\n    )));\n```\n\n----------------------------------------\n\nTITLE: Building Full SDK XCFramework (Rust/Shell)\nDESCRIPTION: Executes the `build-framework` task via `cargo xtask` to compile the `matrix-sdk-ffi` libraries for Apple targets (iOS, simulator, macOS), `lipo` them, run `uniffi` for language bindings, and finally `xcodebuild` to generate the `MatrixSDKFFI.xcframework`. Requires Rust toolchain, Apple targets, `xcodebuild`, and `lipo`. Can take `--profile=reldbg` for debugging or `--release` for optimization/stripping.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/apple/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncargo xtask swift build-framework\n```\n\n----------------------------------------\n\nTITLE: Initializing Rust logging with tracing-subscriber\nDESCRIPTION: Provides the minimal code snippet to initialize logging using the tracing-subscriber crate in a Rust application. This enables capturing and formatting log events so that the matrix-rust-sdk and dependent components can output runtime information. The code requires adding tracing-subscriber as a dependency and calling fmt::init() early in main or similar initialization code to enable log output. Log verbosity is controlled externally via the RUST_LOG environment variable.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntracing_subscriber::fmt::init();\n```\n\n----------------------------------------\n\nTITLE: Observing Events with Client and Observer\nDESCRIPTION: This snippet demonstrates how to use the `observe_events` function to subscribe to events using a reactive programming pattern. It retrieves an observer, subscribes to it, and then uses the subscriber as a `Stream` to process incoming events. The example targets `SyncRoomMessageEvent` and `(Room, Vec<Action>)`, indicating the room and push actions.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/CHANGELOG.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// Get an observer.\nlet observer =\n    client.observe_events::<SyncRoomMessageEvent, (Room, Vec<Action>)>();\n\n// Subscribe to the observer.\nlet mut subscriber = observer.subscribe();\n\n// Use the subscriber as a `Stream`.\nlet (message_event, (room, push_actions)) = subscriber.next().await.unwrap();\n```\n\n----------------------------------------\n\nTITLE: Renaming and Updating Room Context Functions\nDESCRIPTION: The `Room::push_context()` function has been renamed to `Room::push_condition_room_ctx()`. A new `Room::push_context` now returns a `matrix_sdk::Room::PushContext` for computing push actions. `Room::decrypt_event()` now requires a `matrix_sdk::Room::PushContext` to compute push notifications.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/CHANGELOG.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Replacing `Room::is_encrypted` with `Room::latest_encryption_state`\nDESCRIPTION: The `Room::is_encrypted` method is replaced by `Room::latest_encryption_state`, which returns an `EncryptionState` enum. A non-async `Room::encryption_state` is added to retrieve the `EncryptionState` without calling `Room::request_encryption_state`.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/CHANGELOG.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nroom.is_encrypted().await?\n```\n\nLANGUAGE: rust\nCODE:\n```\nroom.latest_encryption_state().await?.is_encrypted()\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Target for Android Cross-Compilation (Shell)\nDESCRIPTION: Installs the necessary Rust toolchain target for cross-compiling the project to the `aarch64-linux-android` architecture. This command uses `rustup`, the Rust toolchain manager.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/matrix-sdk-crypto-ffi/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n# rustup target add aarch64-linux-android\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for Android Cross-Compilation (TOML)\nDESCRIPTION: Configures Cargo in its configuration file (`$HOME/.cargo/config` or `%USERPROFILE%\\.cargo\\config.toml`) to use the specific Android NDK archiver (`ar`) and linker (`linker`) when building for the `aarch64-linux-android` target. Replace `NDK_HOME` with the actual path to your Android NDK installation.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/matrix-sdk-crypto-ffi/README.md#_snippet_1\n\nLANGUAGE: TOML\nCODE:\n```\n[target.aarch64-linux-android]\nar = \"NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/ar\"\nlinker = \"NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android30-clang\"\n```\n\n----------------------------------------\n\nTITLE: Setting Android NDK Environment Variable (Shell)\nDESCRIPTION: Sets the `ANDROID_NDK` environment variable to point to the location of the installed Android NDK. This variable is required by the `olm-sys` crate during the build process to correctly compile the underlying `libolm` C library. The path shown is an example and should be adjusted to match the user's NDK installation path.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/matrix-sdk-crypto-ffi/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ export ANDROID_NDK=$HOME/Android/Sdk/ndk/22.0.7026061/\n```\n\n----------------------------------------\n\nTITLE: Push Release Branch (Git)\nDESCRIPTION: This command pushes the release branch 'release-x.y.z' to the remote repository (origin) and sets it as the upstream branch.  This allows for creating a pull request against the main branch.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/RELEASING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit push --set-upstream origin/release-x.y.z\n```\n\n----------------------------------------\n\nTITLE: Building Bindings for a Specific Target (Shell)\nDESCRIPTION: Compiles the Rust project (including the Uniffi bindings) specifically for the `aarch64-linux-android` target using Cargo. This command requires the Rust target to be installed, Cargo to be configured, and the `ANDROID_NDK` environment variable to be set.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/matrix-sdk-crypto-ffi/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\n$ cargo build --target aarch64-linux-android\n```\n\n----------------------------------------\n\nTITLE: Copying Built Library to Android Project (Shell)\nDESCRIPTION: Copies the compiled shared library (`libmatrix_crypto.so`) from the Cargo build output directory to the `jniLibs` directory of a specific Android project (Element Android in this example). The library is also renamed to `libuniffi_olm.so` as expected by that project. Both source and destination paths may need adjustment based on the actual build output location and the target Android project structure.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/matrix-sdk-crypto-ffi/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n$ cp ../../target/aarch64-linux-android/debug/libmatrix_crypto.so \\\n     /home/example/matrix-sdk-android/src/main/jniLibs/aarch64/libuniffi_olm.so\n```\n\n----------------------------------------\n\nTITLE: Building Crypto-Only XCFramework (Shell)\nDESCRIPTION: Executes a shell script to build the `matrix-sdk-crypto-ffi` libraries for iOS and the iOS simulator, `lipo` them, run `uniffi`, and `xcodebuild` to generate the `MatrixSDKCryptoFFI.xcframework`. Requires Rust toolchain, Apple targets, `xcodebuild`, and `lipo`. Used for distributing the crypto module separately, often via CocoaPods.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/apple/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nbuild_crypto_xcframework.sh\n```\n\n----------------------------------------\n\nTITLE: Installing Testing Dependencies for matrix-rust-sdk Using Bash\nDESCRIPTION: This Bash snippet installs required dependencies for executing CI tests in the matrix-rust-sdk project, including components like clippy for linting and tools like cargo-nextest, typos-cli, and wasm-pack for advanced testing and WASM support. It uses rustup and cargo package manager commands to prepare the development environment for running the `cargo xtask ci` command.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustup component add clippy\ncargo install cargo-nextest typos-cli wasm-pack\n```\n\n----------------------------------------\n\nTITLE: Example of a Security-Related Changelog Entry in Markdown\nDESCRIPTION: This detailed Markdown changelog entry highlights a security fix that introduces a constant-time Base64 encoder to mitigate side-channel attacks leaking secret key material. It documents impact, CVE identifier, and a GitHub advisory link to provide comprehensive security metadata for auditing and user awareness.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n- Use a constant-time Base64 encoder for secret key material to mitigate\n  side-channel attacks leaking secret key material ([#156](https://github.com/matrix-org/vodozemac/pull/156)) (Low, [CVE-2024-40640](https://www.cve.org/CVERecord?id=CVE-2024-40640), [GHSA-j8cm-g7r6-hfpq](https://github.com/matrix-org/vodozemac/security/advisories/GHSA-j8cm-g7r6-hfpq)).\n```\n\n----------------------------------------\n\nTITLE: Installing cargo-insta Tool for Snapshot Testing on Unix Systems\nDESCRIPTION: This Bash command installs the cargo-insta tool, which facilitates snapshot testing for Rust projects, on Unix-like operating systems. It uses a curl command to fetch and execute an installation script from the insta.rs website. Installation of this tool is recommended to enhance review workflows involving snapshot tests, although it is not mandatory.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LsSf https://insta.rs/install.sh | sh\n```\n\n----------------------------------------\n\nTITLE: Interactive Git Rebase with Autosquash to Clean Commit History\nDESCRIPTION: This command initiates an interactive rebase on the main branch with the autosquash option enabled, allowing fixup and squash commits to be reordered and combined automatically. It is used to tidy up the commit history before merging a pull request, especially after multiple fixup commits have been created to address review comments.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit rebase main --interactive --autosquash\n```\n\n----------------------------------------\n\nTITLE: Initializing Logging for matrix-sdk-crypto with tracing-subscriber\nDESCRIPTION: This minimal non-Rust snippet shows how to initialize logging for applications using the matrix-sdk-crypto crate. The initialization requires adding the tracing-subscriber crate as a dependency and calling the provided initialization function at the start of the application. Log output is controlled via the RUST_LOG environment variable supporting levels from error to trace and allows granular filtering by crate. The logged output is emitted to stdout. This setup facilitates debugging encryption operations within the Matrix Rust SDK ecosystem.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk-crypto/README.md#_snippet_1\n\nLANGUAGE: no_compile\nCODE:\n```\ntracing_subscriber::fmt::init();\n```\n\n----------------------------------------\n\nTITLE: Switch to Release Branch (Git)\nDESCRIPTION: This command switches the local git repository to a new branch named 'release-x.y.z'. This branch is specifically intended for preparing and submitting a new release of the SDK.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/RELEASING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit switch -c release-x.y.z\n```\n\n----------------------------------------\n\nTITLE: Prepare Release (cargo-xtask)\nDESCRIPTION: This command uses a custom cargo-xtask to prepare a new release. It updates the README.md, sets versions in CHANGELOG.md, and bumps the version in the Cargo.toml file. The '--execute' flag specifies the type of release (minor, patch, or rc).\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/RELEASING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo xtask release prepare --execute minor|patch|rc\n```\n\n----------------------------------------\n\nTITLE: Publish Release (cargo-xtask)\nDESCRIPTION: This command creates tags for the new release, publishes the release to crates.io, and pushes the tags to the remote repository. It is executed after merging the release branch to main.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/RELEASING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Switch to main first.\ngit switch main\n# Pull in the now-merged release commit(s).\ngit pull\n# Create tags, publish the release on crates.io, and push the tags.\ncargo xtask release publish --execute\n```\n\n----------------------------------------\n\nTITLE: Starting Synapse Docker Compose Services for Tests\nDESCRIPTION: Commands to launch the Synapse backend environment required for running integration tests, using Docker Compose with the specified configuration file. Ensures the server is up and logs can be monitored.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/testing/matrix-sdk-integration-testing/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ndocker compose -f assets/docker-compose.yml up -d\ndocker compose -f assets/docker-compose.yml logs --tail 100 -f\n```\n\n----------------------------------------\n\nTITLE: Stopping and Removing Docker Compose Services with Volumes\nDESCRIPTION: Command to gracefully shut down the Docker services, remove orphan containers, and delete associated volumes to clean environment state, preparing for fresh deployment or teardown.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/testing/matrix-sdk-integration-testing/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ndocker compose -f assets/docker-compose.yml down --volumes --remove-orphans -t 0\n```\n\n----------------------------------------\n\nTITLE: Rebuilding the Synapse Docker Image\nDESCRIPTION: Command to rebuild the custom Synapse Docker image, pulling latest changes and ensuring the container uses the updated build, useful after version upgrades or configuration changes.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/testing/matrix-sdk-integration-testing/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ndocker compose -f assets/docker-compose.yml build --pull synapse\n```\n\n----------------------------------------\n\nTITLE: Restarting the Synapse Service After Rebuild\nDESCRIPTION: Command to start or restart the Synapse container after rebuilding, ensuring the service runs with the latest image and configuration changes.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/testing/matrix-sdk-integration-testing/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\ndocker compose -f assets/docker-compose.yml up -d synapse\n```\n\n----------------------------------------\n\nTITLE: Adding DCO Sign-off Line to Commits\nDESCRIPTION: Example format for the 'Signed-off-by' line required in commit messages or pull request comments to indicate agreement with the DCO. Replace 'Your Name' and 'your@email.example.org' with your actual name and email configured in Git. This line can be added automatically using `git commit -s`.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nSigned-off-by: Your Name <your@email.example.org>\n```\n\n----------------------------------------\n\nTITLE: Running Snapshot Tests and Reviewing Results Using cargo-insta\nDESCRIPTION: These shell commands demonstrate the typical workflow to first run snapshot tests and then review the test output using the cargo-insta tool. `cargo insta test` executes the snapshot tests, while `cargo insta review` opens an interactive interface for verifying or updating snapshots to reflect intentional changes. This workflow helps maintain serialization integrity for structs or enums that derive Serialize and Deserialize.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo insta test\ncargo insta review\n```\n\n----------------------------------------\n\nTITLE: Initializing Sliding Sync with a Client in Rust\nDESCRIPTION: Creates a new Sliding Sync builder from an authenticated client with a unique identifier and specifies the protocol version to use.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/src/sliding_sync/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet sliding_sync_builder = client\n    .sliding_sync(\"main-sync\")?\n    .version(Version::Native);\n```\n\n----------------------------------------\n\nTITLE: Running Swift Package Tests (Swift/Shell)\nDESCRIPTION: Executes the test suite defined in the `Package.swift` file. Requires the Swift package to be correctly configured and linked to the generated static library and Swift files, which are produced by `cargo xtask swift build-library` (mentioned in text). Currently only works on macOS.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/apple/README.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nswift test\n```\n\n----------------------------------------\n\nTITLE: Writing Conventional Commit Fixup Commits Using Git Bash\nDESCRIPTION: This Git command creates a fixup commit that is tied to a specific previous commit identified by `<commit-hash>`. It facilitates incremental corrections to earlier commits by marking changes as amendments. This helps maintain a clean commit history that can later be autosquashed and rebased for a more streamlined review and merge process.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit commit --fixup=<commit-hash>\n```\n\n----------------------------------------\n\nTITLE: Example of a Bad Changelog Entry in Markdown\nDESCRIPTION: This snippet shows a minimalistic and vague changelog entry example that lacks details and context, which is discouraged for documenting changes clearly.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n- Fixed a panic.\n```\n\n----------------------------------------\n\nTITLE: Example of a Good Changelog Entry in Markdown with PR Link\nDESCRIPTION: This Markdown snippet illustrates a well-documented changelog entry describing the implementation details of a fallback mechanism for room summary requests in the matrix-rust-sdk. It includes a pull request link for additional context, providing clarity for users and maintainers.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n- Use the inviter's server name and the server name from the room alias as\n  fallback values for the via parameter when requesting the room summary from\n  the homeserver. This ensures requests succeed even when the room being\n  previewed is hosted on a federated server.\n  ([#4357](https://github.com/matrix-org/matrix-rust-sdk/pull/4357))\n```\n\n----------------------------------------\n\nTITLE: Developer Certificate of Origin (DCO) Text\nDESCRIPTION: The full text of the Developer Certificate of Origin (DCO) Version 1.1. This document outlines the terms under which contributions are made, certifying the contributor's rights to submit the work under the project's open source license.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nDeveloper Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n660 York Street, Suite 102,\nSan Francisco, CA 94110 USA\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n```\n\n----------------------------------------\n\nTITLE: Signing Off Existing Commits with Git Rebase (Bash)\nDESCRIPTION: A Git command using rebase to retrospectively add the 'Signed-off-by' line to commits in the current branch history, up to the common ancestor with 'origin/main'. This is useful for signing off commits made prior to learning about the DCO requirement. Requires Git version 2.17 or newer.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngit rebase --signoff origin/main\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with Cargo Bench\nDESCRIPTION: Provides commands to execute performance benchmarks on the crypto layer using Cargo's bench command, with options for profiling and specific benchmarks. It also describes how to view the generated HTML report post-run.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/benchmarks/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo bench\n\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo bench --profile profiling\n\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo bench --bench crypto_bench -- # Your options go here\n\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo bench --bench crypto_bench \"Room key sharing/\"\n\n```\n\n----------------------------------------\n\nTITLE: Using Baselines for Benchmark Comparisons\nDESCRIPTION: Commands to create and compare against baselines for benchmarks using '--save-baseline' and '--baseline' options, which help track improvements over multiple runs.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/benchmarks/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo bench --bench crypto_bench -- --save-baseline libolm\n\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo bench --bench crypto_bench -- --baseline libolm\n\n```\n\n----------------------------------------\n\nTITLE: Generating Flame Graphs During Profiling\nDESCRIPTION: Enables flame graph profiling, requiring root permissions or adjusted perf_event_paranoid settings, and saves the visual profiling data as SVG files in specified directories. Use the '--profile-time' flag to set profiling duration.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/benchmarks/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ echo -1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo bench --bench crypto_bench -- --profile-time=5\n\n```\n\n----------------------------------------\n\nTITLE: Searching Crypto FFI Git Tags (Shell)\nDESCRIPTION: Lists all local git tags and filters them to find tags starting with `matrix-sdk-crypto-ffi`. Provides an alternative way to find previous release versions of the crypto module during the distribution process.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/apple/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\ngit tag | grep matrix-sdk-crypto-ffi\n```\n\n----------------------------------------\n\nTITLE: Visualizing Homeserver Message Encryption Flow Using ASCII Diagram - text\nDESCRIPTION: This snippet illustrates the difference between messages sent to the homeserver unencrypted versus encrypted end-to-end. The first diagram shows message transmission unencrypted on the server, while the second demonstrates encrypted messages both at the sender, homeserver, and recipient ends. This helps conceptualize how E2EE protects message content from the server.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/crates/matrix-sdk/src/docs/encryption.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n                              ┌──────────────────────────────────────────┐\n                              │  Homeserver  │\n     ┌───────── │                │  ───────── │                ┌──────── │\n     │ Alice │════════════════════════════════════════════════█│\n     └──────┘   encrypted    │              │  unencrypted │─────────█│   encrypted    └──────┘\n                              ┘─────────────────────────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Searching CocoaPods Spec Version (Shell)\nDESCRIPTION: Updates the local CocoaPods repository index and then searches for the `MatrixSDKCrypto` pod to find its latest published version. Used during the distribution process to determine the current version before incrementing the local `podspec`.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/apple/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\npod repo update && pod search MatrixSDKCrypto\n```\n\n----------------------------------------\n\nTITLE: Publishing CocoaPods Spec (Shell)\nDESCRIPTION: Pushes the `MatrixSDKCrypto.podspec` file to the CocoaPods trunk repository, making a new version of the pod available publicly. Requires the podspec version to be incremented locally before execution. The `--allow-warnings` flag permits pushing even if there are warnings during validation.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/bindings/apple/README.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\npod trunk push MatrixSDKCrypto.podspec --allow-warnings\n```\n\n----------------------------------------\n\nTITLE: Installing cargo-insta Tool for Snapshot Testing on Windows PowerShell\nDESCRIPTION: This PowerShell command installs the cargo-insta snapshot testing tool on Windows environments. It retrieves the installation script from the insta.rs website and executes it inline using PowerShell's execution capabilities. This tool improves the experience of managing and reviewing snapshot tests in Rust projects.\nSOURCE: https://github.com/matrix-org/matrix-rust-sdk/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\npowershell -c \"irm https://insta.rs/install.ps1 | iex\"\n```"
  }
]