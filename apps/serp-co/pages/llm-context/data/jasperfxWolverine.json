[
  {
    "owner": "jasperfx",
    "repo": "wolverine",
    "content": "TITLE: Injecting IMessageBus into Wolverine Handlers via Method Argument in C#\nDESCRIPTION: Illustrates the recommended approach for obtaining an `IMessageBus` instance within a Wolverine message handler by injecting it directly as a method parameter. This keeps the handler method self-contained regarding its dependencies for message publishing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/best-practices.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task HandleAsync(MyMessage message, IMessageBus messageBus)\n{\n    // handle the message..;\n}\n```\n\n----------------------------------------\n\nTITLE: Using IMessageBus for Message Handling Operations (C#)\nDESCRIPTION: Demonstrates the core IMessageBus methods in Wolverine for dispatching commands, requesting responses, sending, publishing, and scheduling messages in C#. Dependencies include a registered IMessageBus implementation and message contract classes such as DebitAccount and AccountStatus. The snippet exemplifies asynchronous message execution, fire-and-forget publish/send, and how to schedule messages both by explicit time and by delay.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task use_message_bus(IMessageBus bus)\\n{\\n    // Execute this command message right now! And wait until\\n    // it's completed or acknowledged\\n    await bus.InvokeAsync(new DebitAccount(1111, 100));\\n\\n    // Execute this message right now, but wait for the declared response\\n    var status = await bus.InvokeAsync<AccountStatus>(new DebitAccount(1111, 250));\\n\\n    // Send the message expecting there to be at least one subscriber to be executed later, but\\n    // don't wait around\\n    await bus.SendAsync(new DebitAccount(1111, 250));\\n\\n    // Or instead, publish it to any interested subscribers,\\n    // but don't worry about it if there are actually any subscribers\\n    // This is probably best for raising event messages\\n    await bus.PublishAsync(new DebitAccount(1111, 300));\\n\\n    // Send a message to be sent or executed at a specific time\\n    await bus.ScheduleAsync(new DebitAccount(1111, 100), DateTimeOffset.UtcNow.AddDays(1));\\n\\n    // Or do the same, but this time express the time as a delay\\n    await bus.ScheduleAsync(new DebitAccount(1111, 225), 1.Days());\\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Item Ready Command with AggregateHandler Middleware - C#\nDESCRIPTION: This snippet illustrates using Wolverine's [AggregateHandler] attribute to create a functional command handler for the MarkItemReady event in C#. The static handle method solely contains the domain logic: it yields events to be appended based on input and aggregate state, using simple validation and business conditions. Required dependencies are Wolverine's attribute middleware and Marten for event publishing. Inputs are the command and aggregate; outputs are a set of domain events for Marten persistence. The method is streamlined by moving infrastructure responsibilities into middleware, and is limited to business logic yielding events.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[AggregateHandler]\npublic static IEnumerable<object> Handle(MarkItemReady command, Order order)\n{\n    if (order.Items.TryGetValue(command.ItemName, out var item))\n    {\n        // Not doing this in a purist way here, but just\n        // trying to illustrate the Wolverine mechanics\n        item.Ready = true;\n\n        // Mark that the this item is ready\n        yield return new ItemReady(command.ItemName);\n    }\n    else\n    {\n        // Some crude validation\n        throw new InvalidOperationException($\"Item {command.ItemName} does not exist in this order\");\n    }\n\n    // If the order is ready to ship, also emit an OrderReady event\n    if (order.IsReadyToShip())\n    {\n        yield return new OrderReady();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Messages and Handler for Request/Response Pattern (C#)\nDESCRIPTION: Defines message and response record types and a message handler for implementing a request/reply pattern with Wolverine's IMessageBus. Dependencies include C# 9.0+ for record types. The NumbersHandler returns a Results object upon processing a Numbers message, making it compatible with InvokeAsync<T>. Key parameters are arithmetic inputs X and Y; outputs are both their sum and product. This snippet illustrates the contract required for request/response flows.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic record Numbers(int X, int Y);\\n\\npublic record Results(int Sum, int Product);\\n\\npublic static class NumbersHandler\\n{\\n    public static Results Handle(Numbers numbers)\\n    {\\n        return new Results(numbers.X + numbers.Y, numbers.X * numbers.Y);\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping with EF Core Transactions and Wolverine (C#)\nDESCRIPTION: Shows how to use HostApplicationBuilder and Wolverine for application setup, integrating EF Core (SQL Server) and Wolverine's auto transaction policies. Demonstrates dependency registration with AddDbContextWithWolverineIntegration, enabling transactional messaging, and policy configuration for auto-attaching transaction middleware. Dependencies include Wolverine, EF Core, and corresponding database providers. Accepts a configuration provider for connection strings and outputs a running host.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/configuration.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\\nbuilder.UseWolverine(opts =>\\n{\\n    var connectionString = builder.Configuration.GetConnectionString(\"database\");\\n\\n    opts.Services.AddDbContextWithWolverineIntegration<SampleDbContext>(x =>\\n    {\\n        x.UseSqlServer(connectionString);\\n    });\\n\\n    opts.UseEntityFrameworkCoreTransactions();\\n\\n    // Add the auto transaction middleware attachment policy\\n    opts.Policies.AutoApplyTransactions();\\n});\\n\\nusing var host = builder.Build();\\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing Wolverine Aggregate Handler Returning Updated State in C#\nDESCRIPTION: Demonstrates a static `Handle` method marked with `[AggregateHandler]` for processing a `MarkItemReady` command against an `Order` aggregate. It conditionally generates events (`ItemReady`, `OrderReady`) and returns a tuple containing `UpdatedAggregate` (a directive to fetch the latest state post-event application) and the `Events` collection to be appended. This pattern relies on Wolverine.Marten extensions and the target aggregate/event types.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\n[AggregateHandler]\npublic static (\n    // Just tells Wolverine to use Marten's FetchLatest API to respond with\n    // the updated version of Order that reflects whatever events were appended\n    // in this command\n    UpdatedAggregate, \n    \n    // The events that should be appended to the event stream for this order\n    Events) Handle(OrderEventSourcingSample.MarkItemReady command, Order order)\n{\n    var events = new Events();\n    \n    if (order.Items.TryGetValue(command.ItemName, out var item))\n    {\n        // Not doing this in a purist way here, but just\n        // trying to illustrate the Wolverine mechanics\n        item.Ready = true;\n\n        // Mark that the this item is ready\n        events.Add(new ItemReady(command.ItemName));\n    }\n    else\n    {\n        // Some crude validation\n        throw new InvalidOperationException($\"Item {command.ItemName} does not exist in this order\");\n    }\n\n    // If the order is ready to ship, also emit an OrderReady event\n    if (order.IsReadyToShip())\n    {\n        events.Add(new OrderReady());\n    }\n\n    return (new UpdatedAggregate(), events);\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Cascading Messages from Wolverine Handlers in C#\nDESCRIPTION: Demonstrates recommended ways to publish subsequent messages from a Wolverine message handler. The first example uses cascading messages by returning the next message object. The second example explicitly injects `IMessageBus` and calls `PublishAsync`. The third example shows conditional cascading by returning a message or null based on logic executed within the handler or delegated to a service.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/best-practices.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Using cascading messages is certainly fine\npublic static SecondMessage Handle(FirstMessage message, IService1 service1)\n{\n    return new SecondMessage();\n}\n\n// This is fine too if you prefer the more explicit code model and don't mind\n// the tighter coupling\npublic static async ValueTask<SecondMessage> Handle(FirstMessage message, IService1 service1, IMessageBus bus)\n{\n    // Little more coupling, but some folks will prefer the more explicit style\n    await bus.PublishAsync(new SecondMessage());\n}\n\n\npublic static SecondMessage? Handle(FirstMessage message, IService1 service1)\n{\n    // Call into another service to *decide* whether or not to send\n    // the cascading service\n    if (service1.ComplicatedLogicTest(message))\n    {\n        return BuildUpComplicatedMessage();\n    }\n    \n    return null; // no cascading message\n}\n```\n\n----------------------------------------\n\nTITLE: Order Creation via Minimal API with Marten Outbox Integration - C#\nDESCRIPTION: Illustrates a Minimal API route in ASP.NET Core that processes POST requests, creates a new Order, stores it with Marten, and registers an OrderCreated message with Wolverine's outbox for deferred publishing. Dependencies must include Marten, Wolverine, and Minimal API support. The handler receives a CreateOrder command and required services, ensuring outbound message reliability by coupling publishing to transaction success.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/outbox.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\napp.MapPost(\"/orders/create3\", async (CreateOrder command, IDocumentSession session, IMartenOutbox outbox) =>\n{\n    var order = new Order\n    {\n        Description = command.Description\n    };\n\n    // Register the new document with Marten\n    session.Store(order);\n\n    // Don't worry, this message doesn't go out until\n    // after the Marten transaction succeeds\n    await outbox.PublishAsync(new OrderCreated(order.Id));\n\n    // Commit the Marten transaction\n    await session.SaveChangesAsync();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining POST Endpoint for Creating Todo with Marten and Wolverine Messaging (C#)\nDESCRIPTION: Defines a static HTTP POST endpoint at `/todoitems` to create a new `Todo` item. It accepts a `CreateTodo` command object (presumably deserialized from the request body), injects Marten's `IDocumentSession` to store the new `Todo`, and injects Wolverine's `IMessageBus` to publish a `TodoCreated` event. Due to the `IDocumentSession` dependency and Wolverine configuration, this endpoint automatically uses Marten's transactional middleware and Wolverine's transactional outbox, ensuring the event is published only if the database transaction succeeds. It returns a 201 Created response with the location and representation of the new resource.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\n[WolverinePost(\"/todoitems\")]\npublic static async Task<IResult> Create(CreateTodo command, IDocumentSession session, IMessageBus bus)\n{\n    var todo = new Todo { Name = command.Name };\n    session.Store(todo);\n\n    // Going to raise an event within out system to be processed later\n    await bus.PublishAsync(new TodoCreated(todo.Id));\n\n    return Results.Created($\"/todoitems/{todo.Id}\", todo);\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Message Command Interface for Middleware Filtering in Wolverine (C#)\nDESCRIPTION: Defines the IAccountCommand interface with an AccountId property, used as a marker for applying middleware selectively in Wolverine. Facilitates type-based middleware registration, ensuring that specific middleware is only invoked for relevant message types. Requires implementations to expose a Guid property.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IAccountCommand\n{\n    Guid AccountId { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Asynchronous Message Publishing with Wolverine Tracked Sessions in C#\nDESCRIPTION: Provides a complete example of using Wolverine's tracked sessions to test a scenario where a message is published asynchronously (simulating a file system watcher). It defines a message record (`FileAdded`), a simple handler, a class (`RandomFileChange`) that simulates the asynchronous event and sends the message via `IMessageBus`, and an Xunit test class (`When_message_is_sent`). The test uses `TrackActivity().ExecuteAndWaitAsync()` to wrap the asynchronous operation, ensuring the test waits for the message to be sent before making assertions on the `TrackedSession`'s `Sent` messages collection.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\npublic record FileAdded(string FileName);\n\npublic class FileAddedHandler\n{\n    public Task Handle(\n        FileAdded message\n    ) =>\n        Task.CompletedTask;\n}\n\npublic class RandomFileChange\n{\n    private readonly IMessageBus _messageBus;\n\n    public RandomFileChange(\n        IMessageBus messageBus\n    ) => _messageBus = messageBus;\n\n    public async Task SimulateRandomFileChange()\n    {\n        // Delay task with a random number of milliseconds\n        // Here would be your FileSystemWatcher / IFileProvider\n        await Task.Delay(\n            TimeSpan.FromMilliseconds(\n                new Random().Next(100, 1000)\n            )\n        );\n        var randomFileName = Path.GetRandomFileName();\n        await _messageBus.SendAsync(new FileAdded(randomFileName));\n    }\n}\n\npublic class When_message_is_sent : IAsyncLifetime\n{\n    private IHost _host;\n\n    public async Task InitializeAsync()\n    {\n        var hostBuilder = Host.CreateDefaultBuilder();\n        hostBuilder.ConfigureServices(\n            services => { services.AddSingleton<RandomFileChange>(); }\n        );\n        hostBuilder.UseWolverine();\n\n        _host = await hostBuilder.StartAsync();\n    }\n\n    [Fact]\n    public async Task should_be_in_session()\n    {\n        var randomFileChange = _host.Services.GetRequiredService<RandomFileChange>();\n\n        var session = await _host\n            .TrackActivity()\n            .Timeout(2.Seconds())\n            .ExecuteAndWaitAsync(\n                (Func<IMessageContext, Task>)( \n                    async (\n                        _\n                    ) => await randomFileChange.SimulateRandomFileChange()\n                )\n            );\n\n        session\n            .Sent\n            .AllMessages()\n            .Count()\n            .ShouldBe(1);\n        \n        session\n            .Sent\n            .AllMessages()\n            .First()\n            .ShouldBeOfType<FileAdded>();\n    }\n\n    public async Task DisposeAsync() => await _host.StopAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Opting into Event Forwarding with Marten and Wolverine in C#\nDESCRIPTION: This snippet demonstrates how to configure an ASP.NET Core application's service collection to use Marten projections, integrate Wolverine for persistent outbox messaging, and enable event forwarding during SaveChangesAsync(). Dependencies include Marten, Wolverine, and various projections. The configuration establishes asynchronous and inline projections, sets up a background daemon for async processing, and chains AddMarten() with EventForwardingToWolverine(). Requires connection strings for database configuration. Inputs are builder.Services and projections; outputs are fully configured services. Intended for application composition at startup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-forwarding.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddMarten(opts =>\n    {\n        var connString = builder\n            .Configuration\n            .GetConnectionString(\"marten\");\n\n        opts.Connection(connString);\n\n        // There will be more here later...\n\n        opts.Projections\n            .Add<AppointmentDurationProjection>(ProjectionLifecycle.Async);\n\n        // OR ???\n\n        // opts.Projections\n        //     .Add<AppointmentDurationProjection>(ProjectionLifecycle.Inline);\n\n        opts.Projections.Add<AppointmentProjection>(ProjectionLifecycle.Inline);\n        opts.Projections\n            .Snapshot<ProviderShift>(SnapshotLifecycle.Async);\n    })\n\n    // This adds a hosted service to run\n    // asynchronous projections in a background process\n    .AddAsyncDaemon(DaemonMode.HotCold)\n\n    // I added this to enroll Marten in the Wolverine outbox\n    .IntegrateWithWolverine()\n\n    // I also added this to opt into events being forward to\n    // the Wolverine outbox during SaveChangesAsync()\n    .EventForwardingToWolverine();\n```\n\n----------------------------------------\n\nTITLE: Defining a Fluent Validator and Message Handler in C#\nDESCRIPTION: This snippet illustrates how to define a message (`CreateCustomer`), a corresponding Fluent Validation validator (`CreateCustomerValidator`), and a message handler (`CreateCustomerHandler`). The `CreateCustomerValidator` uses `AbstractValidator<T>` to specify rules for the `CreateCustomer` record's properties. The `CreateCustomerHandler` contains the logic to process the message, which will only be invoked by Wolverine if the message passes validation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/fluent-validation.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic class CreateCustomerValidator : AbstractValidator<CreateCustomer>\n{\n    public CreateCustomerValidator()\n    {\n        RuleFor(x => x.FirstName).NotNull();\n        RuleFor(x => x.LastName).NotNull();\n        RuleFor(x => x.PostalCode).NotNull();\n    }\n}\n\npublic record CreateCustomer\n(\n    string FirstName,\n    string LastName,\n    string PostalCode\n);\n\npublic static class CreateCustomerHandler\n{\n    public static void Handle(CreateCustomer customer)\n    {\n        // do whatever you'd do here, but this won't be called\n        // at all if the Fluent Validation rules fail\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RabbitMQ Topic Bindings in Wolverine (C#)\nDESCRIPTION: This snippet demonstrates how to configure a .NET host with Wolverine, enabling RabbitMQ as the message transport and binding specific topics to named queues. All messages are published to RabbitMQ topics using the specified exchange, and bindings use pattern matching for flexible routing. Dependencies include the Wolverine and RabbitMQ integration, proper RabbitMQ server access, and message contract types such as RoutedMessage. Exchange and binding parameters should match your messaging requirements, and this configuration must run during application startup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/broadcast-to-topic.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ntheSender = Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq(\"host=localhost;port=5672\").AutoProvision();\n        opts.PublishAllMessages().ToRabbitTopics(\"wolverine.topics\", exchange =>\n        {\n            exchange.BindTopic(\"color.green\").ToQueue(\"green\");\n            exchange.BindTopic(\"color.blue\").ToQueue(\"blue\");\n            exchange.BindTopic(\"color.*\").ToQueue(\"all\");\n        });\n\n        opts.PublishMessagesToRabbitMqExchange<RoutedMessage>(\"wolverine.topics\", m => m.TopicName);\n    }).Start();\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten and Wolverine with Durable Local Queue Inbox in C#\nDESCRIPTION: This snippet demonstrates configuring Marten and Wolverine in a .NET WebApplication. It sets up Marten using a connection string from configuration and integrates it with Wolverine, optionally specifying a separate schema for Wolverine tables. It specifically enables the durable inbox feature for the \"important\" local queue, ensuring messages sent to this queue are persisted in the Marten/Postgresql database before processing. Requires Marten, Wolverine, Wolverine.Marten, and Oakton NuGet packages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/inbox.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Host.ApplyOaktonExtensions();\n\nbuilder.Services.AddMarten(opts =>\n    {\n        var connectionString = builder\n            .Configuration\n            .GetConnectionString(\"postgres\");\n\n        opts.Connection(connectionString);\n        opts.DatabaseSchemaName = \"orders\";\n    })\n    // Optionally add Marten/Postgresql integration\n    // with Wolverine's outbox\n    .IntegrateWithWolverine();\n\n// You can also place the Wolverine database objects\n// into a different database schema, in this case\n// named \"wolverine_messages\"\n//.IntegrateWithWolverine(\"wolverine_messages\");\n\nbuilder.Host.UseWolverine(opts =>\n{\n    // I've added persistent inbox\n    // behavior to the \"important\"\n    // local queue\n    opts.LocalQueue(\"important\")\n        .UseDurableInbox();\n});\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies into Handler Constructors - Wolverine (.NET C#)\nDESCRIPTION: This example displays how to use constructor injection in a message handler class, as supported by Wolverine and other .NET frameworks. The 'CreateProjectHandler' takes an 'IProjectRepository' instance via its constructor, allowing handler logic to use repository services. The 'HandleAsync' method processes a 'CreateProject' message and uses the repository to create a new project. Requires 'IProjectRepository', 'CreateProject', and 'Project' to be defined elsewhere.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// Wolverine does constructor injection as you're probably\n// used to with basically every other framework in .NET\npublic class CreateProjectHandler(IProjectRepository Repository)\n{\n    public async Task HandleAsync(CreateProject message)\n    {\n        await Repository.CreateAsync(new Project(message.Name));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Wolverine with ASP.NET Core using Host Builder (C#)\nDESCRIPTION: Demonstrates how to configure and add Wolverine to an ASP.NET Core application using WebApplicationBuilder. This example shows dependency registration, using Wolverine as a mediator for HTTP endpoints, and integration with common API documentation tools like Swashbuckle. Requires NuGet packages for Wolverine, Oakton, Swashbuckle, and relevant application services. Accepts user-defined service and endpoint types, and uses Oakton for command-line processing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/configuration.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing Oakton;\\nusing Quickstart;\\nusing Wolverine;\\n\\nvar builder = WebApplication.CreateBuilder(args);\\n\\n// The almost inevitable inclusion of Swashbuckle:)\\nbuilder.Services.AddEndpointsApiExplorer();\\nbuilder.Services.AddSwaggerGen();\\n\\n// For now, this is enough to integrate Wolverine into\\n// your application, but there'll be *many* more\\n// options later of course :-)\\nbuilder.Host.UseWolverine();\\n\\n// Some in memory services for our application, the\\n// only thing that matters for now is that these are\\n// systems built by the application's IoC container\\nbuilder.Services.AddSingleton<UserRepository>();\\nbuilder.Services.AddSingleton<IssueRepository>();\\n\\nvar app = builder.Build();\\n\\n// An endpoint to create a new issue that delegates to Wolverine as a mediator\\napp.MapPost(\"/issues/create\", (CreateIssue body, IMessageBus bus) => bus.InvokeAsync(body));\\n\\n// An endpoint to assign an issue to an existing user that delegates to Wolverine as a mediator\\napp.MapPost(\"/issues/assign\", (AssignIssue body, IMessageBus bus) => bus.InvokeAsync(body));\\n\\n// Swashbuckle inclusion\\napp.UseSwagger();\\napp.UseSwaggerUI();\\n\\napp.MapGet(\"/\", () => Results.Redirect(\"/swagger\"));\\n\\n// Opt into using Oakton for command line parsing\\n// to unlock built in diagnostics and utility tools within\\n// your Wolverine application\\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Using Method Injection for Wolverine Handler Dependencies (C#)\nDESCRIPTION: Shows a static handler method (`MethodInjectionHandler.Handle`) accepting an `InvoiceCreated` message and an `IDocumentSession` dependency directly as parameters. Wolverine resolves the `IDocumentSession` from the IoC container and injects it when invoking the handler method. This technique allows injecting services, `Envelope`, `IMessageContext`, `CancellationToken`, or the current time directly into the handler method's signature, and is particularly useful with static handlers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\npublic static class MethodInjectionHandler\n{\n    public static Task Handle(InvoiceCreated message, IDocumentSession session)\n    {\n        var invoice = new Invoice { Id = message.InvoiceId };\n        session.Store(invoice);\n\n        return session.SaveChangesAsync();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Error Handling Policy with IHandlerPolicy in Wolverine - C#\nDESCRIPTION: Defines a class-based chain policy for Wolverine by implementing the IHandlerPolicy interface, thereby applying an error handling rule (such as requeueing on SqlException) across all handlers for messages in a specific namespace ('MyApp.Messages'). The Apply method traverses all HandlerChains, filters those with matching MessageType namespaces, and adds retry logic. Requires IHandlerPolicy, HandlerChain, and necessary using directives.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// This error policy will apply to all message types in the namespace\n// 'MyApp.Messages', and add a \"requeue on SqlException\" to all of these\n// message handlers\npublic class ErrorHandlingPolicy : IHandlerPolicy\n{\n    public void Apply(IReadOnlyList<HandlerChain> chains, GenerationRules rules, IServiceContainer container)\n    {\n        var matchingChains = chains\n            .Where(x => x.MessageType.IsInNamespace(\"MyApp.Messages\"));\n\n        foreach (var chain in matchingChains) chain.OnException<SqlException>().Requeue(2);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto-Applied EF Core Transactions in Wolverine (C#)\nDESCRIPTION: Demonstrates setting up Wolverine in a .NET application (`Host.CreateApplicationBuilder`) to automatically apply transactional middleware to any message handler that depends on an EF Core `DbContext`. It uses `AddDbContextWithWolverineIntegration` for optimized registration of `SampleDbContext` with SQL Server, enables EF Core transactions with `UseEntityFrameworkCoreTransactions`, and activates the automatic application policy with `opts.Policies.AutoApplyTransactions()`. This eliminates the need for the `[Transactional]` attribute on handlers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/efcore.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    var connectionString = builder.Configuration.GetConnectionString(\"database\");\n\n    opts.Services.AddDbContextWithWolverineIntegration<SampleDbContext>(x =>\n    {\n        x.UseSqlServer(connectionString);\n    });\n\n    opts.UseEntityFrameworkCoreTransactions();\n\n    // Add the auto transaction middleware attachment policy\n    opts.Policies.AutoApplyTransactions();\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Injecting HTTP Headers into Endpoint Methods using Wolverine Middleware - C#\nDESCRIPTION: Demonstrates several methods in C# leveraging the Wolverine framework to inject HTTP header values into endpoint parameters using the [FromHeader] attribute. Dependencies include the Wolverine.AspNetCore package and proper setup of HTTP endpoints. Parameters are decorated with [FromHeader] to bind values such as strings and integers from headers, with automatic handling of defaults if the header is missing. Inputs are incoming HTTP requests with headers, and outputs are either direct responses or side effects (e.g., Debug logs). This pattern aids testability and method purity, but be aware that missing or malformed headers for non-nullable types may result in default values.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/headers.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// As of Wolverine 2.6, you can utilize header data in middleware\npublic static void Before([FromHeader(Name = \"x-day\")] string? day)\n{\n    Debug.WriteLine($\"Day header is {day}\");\n    Day = day; // This is for testing\n}\n\n[WolverineGet(\"/headers/simple\")]\npublic string Get(\n    // Find the request header with the supplied name and pass\n    // it as the \"name\" parameter to this method at runtime\n    [FromHeader(Name = \"x-wolverine\")]\n    string name)\n{\n    return name;\n}\n\n[WolverineGet(\"/headers/int\")]\npublic string Get(\n    // Find the request header with the supplied name and pass\n    // it as the \"name\" parameter to this method at runtime\n    // If the attribute does not exist, Wolverine will pass\n    // in the default value for the parameter type, in this case\n    // 0\n    [FromHeader(Name = \"x-wolverine\")] int number\n)\n{\n    return (number * 2).ToString();\n}\n\n[WolverineGet(\"/headers/accepts\")]\n// In this case, push the string value for the \"accepts\" header\n// right into the parameter based on the parameter name\npublic string GetETag([FromHeader] string accepts)\n{\n    return accepts;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine with Kafka Transport in C#\nDESCRIPTION: Demonstrates bootstrapping a .NET host with Wolverine configured to use Kafka. It shows how to specify the Kafka broker address, configure underlying Confluent Kafka client options for producers and consumers, define publishing rules (publishing all messages or specific types to topics), configure specific producer settings per topic, set up listeners for Kafka topics with different processing modes (inline, buffered), and automatically provision topics on startup. Dependencies include Wolverine.Core and Wolverine.Kafka.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/kafka.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseKafka(\"localhost:9092\")\n\n            // See https://github.com/confluentinc/confluent-kafka-dotnet for the exact options here\n            .ConfigureClient(client =>\n            {\n                // configure both producers and consumers\n\n            })\n\n            .ConfigureConsumers(consumer =>\n            {\n                // configure only consumers\n            })\n\n            .ConfigureProducers(producer =>\n            {\n                // configure only producers\n            })\n            \n            .ConfigureProducerBuilders(builder =>\n            {\n                // there are some options that are only exposed\n                // on the ProducerBuilder\n            })\n            \n            .ConfigureConsumerBuilders(builder =>\n            {\n                // there are some Kafka client options that\n                // are only exposed from the builder\n            })\n            \n            .ConfigureAdminClientBuilders(builder =>\n            {\n                // configure admin client builders\n            });\n\n        // Just publish all messages to Kafka topics\n        // based on the message type (or message attributes)\n        // This will get fancier in the near future\n        opts.PublishAllMessages().ToKafkaTopics();\n\n        // Or explicitly make subscription rules\n        opts.PublishMessage<ColorMessage>()\n            .ToKafkaTopic(\"colors\")\n            \n            // Override the producer configuration for just this topic\n            .ConfigureProducer(config =>\n            {\n                config.BatchSize = 100;\n                config.EnableGaplessGuarantee = true;\n                config.EnableIdempotence = true;\n            });\n\n        // Listen to topics\n        opts.ListenToKafkaTopic(\"red\")\n            .ProcessInline()\n            \n            // Override the consumer configuration for only this \n            // topic\n            .ConfigureConsumer(config =>\n            {\n                // This will also set the Envelope.GroupId for any\n                // received messages at this topic\n                config.GroupId = \"foo\";\n                \n                // Other configuration\n            });\n\n        opts.ListenToKafkaTopic(\"green\")\n            .BufferedInMemory();\n\n        // This will direct Wolverine to try to ensure that all\n        // referenced Kafka topics exist at application start up\n        // time\n        opts.Services.AddResourceSetupOnStartup();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Method Injection Handler for Message Processing in Wolverine (C#)\nDESCRIPTION: This snippet exemplifies the recommended Wolverine pattern for writing message handlers using static methods with method injection, which receives dependencies as method parameters rather than through object construction. The static HandleAsync method handles Message1 messages and accepts an IService, allowing for cleaner and more performant code with simpler dependency management. No specific DI setup is required for the handler class itself; dependencies are resolved per invocation. The method expects a Message1 input and returns a Task. This approach reduces runtime overhead compared to constructor injection.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/best-practices.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// Wolverine prefers this:\npublic static class Message1Handler\n{\n    public static Task HandleAsync(Message1 message, IService service)\n    {\n        // Do stuff\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Wolverine Message Handler with EF Core DbContext (C#)\nDESCRIPTION: Defines a static Wolverine message handler function `Handle` that processes a `CreateItemCommand`. It injects an `ItemsDbContext` to interact with the database, creates and adds an `Item` entity, and returns an `ItemCreated` event which will be automatically persisted and sent via Wolverine's outbox mechanism when transactional middleware is enabled. The `[Transactional]` attribute explicitly applies the middleware, although it might be automatically applied depending on configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/efcore.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n[Transactional]\npublic static ItemCreated Handle(\n    // This would be the message\n    CreateItemCommand command,\n\n    // Any other arguments are assumed\n    // to be service dependencies\n    ItemsDbContext db)\n{\n    // Create a new Item entity\n    var item = new Item\n    {\n        Name = command.Name\n    };\n\n    // Add the item to the current\n    // DbContext unit of work\n    db.Items.Add(item);\n\n    // This event being returned\n    // by the handler will be automatically sent\n    // out as a \"cascading\" message\n    return new ItemCreated\n    {\n        Id = item.Id\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Aggregate Operations via [Aggregate] Attribute in Wolverine.HTTP - C#\nDESCRIPTION: This code defines a Wolverine HTTP POST endpoint that processes the shipping of an Order aggregate, binding an Order domain object directly via the [Aggregate] attribute from route arguments. The endpoint throws if the order has already shipped, and otherwise emits an OrderShipped event. The [EmptyResponse] attribute signals event publishing instead of returning a response body. Marten's transactional middleware is used automatically, and the aggregate is loaded by matching 'orderId' in the route.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverinePost(\"/orders/{orderId}/ship2\"), EmptyResponse]\n// The OrderShipped return value is treated as an event being posted\n// to a Marten even stream\n// instead of as the HTTP response body because of the presence of\n// the [EmptyResponse] attribute\npublic static OrderShipped Ship(ShipOrder2 command, [Aggregate] Order order)\n{\n    if (order.HasShipped)\n        throw new InvalidOperationException(\"This has already shipped!\");\n\n    return new OrderShipped();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Transport and Persistence in Wolverine (C#)\nDESCRIPTION: Shows how to configure Wolverine using `Host.CreateApplicationBuilder()` to leverage PostgreSQL for both message persistence and as a messaging transport. It uses `opts.UsePostgresqlPersistenceAndTransport()` specifying the connection string and distinct database schema names for envelope storage ('myapp') and transport queues ('queues'). It also demonstrates enabling automatic schema provisioning (`AutoProvision()`), optional purging on startup (`AutoPurgeOnStartup()`), publishing all messages to a specific PostgreSQL queue ('outbound'), and listening to another queue ('inbound') with circuit breaker customization and message batch sizing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/postgresql.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    var connectionString = builder.Configuration.GetConnectionString(\"postgres\");\n    opts.UsePostgresqlPersistenceAndTransport(\n            connectionString, \n            \n            // This argument is the database schema for the envelope storage\n            // If separate logical services are targeting the same physical database,\n            // you should use a separate schema name for each logical application\n            // to make basically *everything* run smoother\n            \"myapp\", \n            \n            // This schema name is for the actual PostgreSQL queue tables. If using\n            // the PostgreSQL transport between two logical applications, make sure\n            // to use the same transportSchema!\n            transportSchema:\"queues\")\n\n        // Tell Wolverine to build out all necessary queue or scheduled message\n        // tables on demand as needed\n        .AutoProvision()\n\n        // Optional that may be helpful in testing, but probably bad\n        // in production!\n        .AutoPurgeOnStartup();\n\n    // Use this extension method to create subscriber rules\n    opts.PublishAllMessages().ToPostgresqlQueue(\"outbound\");\n\n    // Use this to set up queue listeners\n    opts.ListenToPostgresqlQueue(\"inbound\")\n\n        .CircuitBreaker(cb =>\n        {\n            // fine tune the circuit breaker\n            // policies here\n        })\n\n        // Optionally specify how many messages to\n        // fetch into the listener at any one time\n        .MaximumMessagesToReceive(50);\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Enabling System Endpoints for Wolverine GCP Pub/Sub (C#)\nDESCRIPTION: This snippet demonstrates how to enable system endpoints within the Wolverine GCP Pub/Sub configuration using the `EnableSystemEndpoints` method. This is necessary to support request/reply messaging patterns (`IMessageBus.InvokeAsync<T>()`). Enabling this grants Wolverine permission to automatically provision specific response topics and subscriptions (named like `wlvrn.response.[application node id]`) required for this pattern.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/gcp-pubsub/index.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UsePubsub(\"your-project-id\")\n            .EnableSystemEndpoints();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing Mediator Pattern with Wolverine in ASP.Net Core Controller (C#)\nDESCRIPTION: Demonstrates using Wolverine as a mediator within an ASP.Net Core controller by forwarding incoming HTTP POST requests to the Wolverine IMessageBus for asynchronous command processing. Requires Wolverine and ASP.Net Core MVC dependencies. The controller method accepts a Question object and injects IMessageBus via dependency injection to invoke and await an Answer. Input is a Question DTO from the HTTP request, output is an asynchronously returned Answer. Intended for situations where controller logic is offloaded to a mediator framework to reduce controller bloat.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/mediator.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MediatorController : ControllerBase\n{\n    [HttpPost(\"/question\")]\n    public Task<Answer> Get(Question question, [FromServices] IMessageBus bus)\n    {\n        // All the real processing happens in Wolverine\n        return bus.InvokeAsync<Answer>(question);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Conventional Topic/Subscription Routing with Wolverine Azure Service Bus in C#\nDESCRIPTION: This C# snippet illustrates how to configure Wolverine to use conventional routing with Azure Service Bus topics and subscriptions (introduced in Wolverine 1.6.0). It utilizes `UseTopicAndSubscriptionConventionalRouting` to automatically route messages based on type names to corresponding topics and subscriptions. It also includes options for auto-provisioning and purging queues on startup, mentioning the ability to further customize the convention.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/conventional-routing.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nopts.UseAzureServiceBusTesting()\n    .UseTopicAndSubscriptionConventionalRouting(convention =>\n    {\n        // Optionally control every aspect of the convention and\n        // its applicability to types\n        // as well as overriding any listener, sender, topic, or subscription\n        // options\n    })\n\n    .AutoProvision()\n    .AutoPurgeOnStartup();\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Message Type Alias with Attribute in C#\nDESCRIPTION: This snippet shows how to explicitly control the message type alias used by Wolverine. The `PersonBorn` class is decorated with the `[MessageIdentity(\"person-born\")]` attribute, overriding the default behavior and setting the alias to \"person-born\". This is useful for decoupling, readability, or diagnostic purposes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[MessageIdentity(\"person-born\")]\npublic class PersonBorn\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    public int Day { get; set; }\n    public int Month { get; set; }\n    public int Year { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten and Wolverine with RabbitMQ for Durable Messaging in C#\nDESCRIPTION: This snippet sets up a .NET WebApplication integrating Marten for persistence and Wolverine for messaging. It configures a PostgreSQL connection for Marten, enables Wolverine integration, defines retry policies, uses Marten for message storage, configures RabbitMQ for transport with durable inbox/outbox enabled globally, and auto-applies transactions. Requires Marten, Wolverine, Wolverine.Marten, Wolverine.RabbitMQ, and Oakton NuGet packages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/inbox.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Host.ApplyOaktonExtensions();\n\nbuilder.Services.AddMarten(opts =>\n    {\n        opts.Connection(Servers.PostgresConnectionString);\n        opts.DatabaseSchemaName = \"chaos2\";\n    })\n    .IntegrateWithWolverine();\n\nbuilder.Host.UseWolverine(opts =>\n{\n    opts.Policies.OnAnyException().RetryWithCooldown(50.Milliseconds(), 100.Milliseconds(), 250.Milliseconds());\n\n    opts.Services.AddScoped<IMessageRecordRepository, MartenMessageRecordRepository>();\n\n    opts.Policies.DisableConventionalLocalRouting();\n    opts.UseRabbitMq().AutoProvision();\n\n    opts.Policies.UseDurableInboxOnAllListeners();\n    opts.Policies.UseDurableOutboxOnAllSendingEndpoints();\n\n    opts.ListenToRabbitQueue(\"chaos2\");\n    opts.PublishAllMessages().ToRabbitQueue(\"chaos2\");\n\n    opts.Policies.AutoApplyTransactions();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Inter-Application SQL Server Queues in Wolverine (C#)\nDESCRIPTION: Illustrates setting up two separate Wolverine hosts (a sender and a listener) to communicate via SQL Server queues. Both hosts are configured using `UseSqlServerPersistenceAndTransport()`, targeting the same connection string and crucially, specifying the identical `transportSchema` parameter ('transport' in this case) to ensure they can share the same transport infrastructure. The sender publishes messages, and the listener is configured to listen to the target queue. Conventional discovery and routing are disabled for clarity in this example.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sqlserver.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n<!-- snippet: sample_sql_server_as_queue_between_two_apps -->\n<a id='snippet-sample_sql_server_as_queue_between_two_apps'></a>\n```cs\n_sender = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseSqlServerPersistenceAndTransport(\n                Servers.SqlServerConnectionString, \n                \"sender\",\n                \n                // If using Sql Server as a queue between multiple applications,\n                // be sure to use the same transportSchema setting\n                transportSchema:\"transport\")\n            .AutoProvision()\n            .AutoPurgeOnStartup();\n\n        opts.PublishMessage<SqlServerFoo>().ToSqlServerQueue(\"foobar\");\n        opts.PublishMessage<SqlServerBar>().ToSqlServerQueue(\"foobar\");\n        opts.Policies.DisableConventionalLocalRouting();\n        opts.Discovery.DisableConventionalDiscovery();\n\n    }).StartAsync();\n_listener = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseSqlServerPersistenceAndTransport(Servers.SqlServerConnectionString, \n                \"listener\",\n                \n                transportSchema:\"transport\")\n            .AutoProvision()\n            .AutoPurgeOnStartup();\n        opts.PublishMessage<SqlServerBar>().ToSqlServerQueue(\"foobar\");\n        opts.ListenToSqlServerQueue(\"foobar\");\n        opts.Discovery.DisableConventionalDiscovery()\n            .IncludeType<FooBarHandler>();\n    }).StartAsync();\n```\n<sup><a href='https://github.com/JasperFx/wolverine/blob/main/src/Persistence/SqlServerTests/Transport/with_multiple_hosts.cs#L21-L57' title='Snippet source file'>snippet source</a> | <a href='#snippet-sample_sql_server_as_queue_between_two_apps' title='Start of snippet'>anchor</a></sup>\n<!-- endSnippet -->\n```\n\n----------------------------------------\n\nTITLE: Integrating Marten and Wolverine with Durable Messaging in C#\nDESCRIPTION: This C# snippet demonstrates configuring Marten using `AddMarten` with a connection string and integrating it with Wolverine via `IntegrateWithWolverine()`. It then configures Wolverine using `UseWolverine` to apply retry policies, register a custom `MartenMessageRecordRepository`, disable conventional local routing, set up RabbitMQ for durable inbox/outbox messaging, and enable automatic transaction application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/index.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Host.ApplyOaktonExtensions();\n\nbuilder.Services.AddMarten(opts =>\n    {\n        opts.Connection(Servers.PostgresConnectionString);\n        opts.DatabaseSchemaName = \"chaos2\";\n    })\n    .IntegrateWithWolverine();\n\nbuilder.Host.UseWolverine(opts =>\n{\n    opts.Policies.OnAnyException().RetryWithCooldown(50.Milliseconds(), 100.Milliseconds(), 250.Milliseconds());\n\n    opts.Services.AddScoped<IMessageRecordRepository, MartenMessageRecordRepository>();\n\n    opts.Policies.DisableConventionalLocalRouting();\n    opts.UseRabbitMq().AutoProvision();\n\n    opts.Policies.UseDurableInboxOnAllListeners();\n    opts.Policies.UseDurableOutboxOnAllSendingEndpoints();\n\n    opts.ListenToRabbitQueue(\"chaos2\");\n    opts.PublishAllMessages().ToRabbitQueue(\"chaos2\");\n\n    opts.Policies.AutoApplyTransactions();\n});\n```\n\n----------------------------------------\n\nTITLE: Using the [Entity] Attribute for Automatic Loading in C#\nDESCRIPTION: This C# code demonstrates a Wolverine HTTP endpoint method (`Handle`) that also functions as a message handler. It uses the `[Entity]` attribute on the `Todo2 todo` parameter. Wolverine automatically loads the `Todo2` entity from the configured persistence layer (e.g., Marten, EF Core) using the `Id` property from the incoming `RenameTodo` command object. The method then updates the `Name` property of the loaded `todo` entity and returns a `Storage.Update(todo)` action to instruct Wolverine to persist the changes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/persistence.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n// Use \"Id\" as the default member\n[WolverinePost(\"/api/todo/update\")]\npublic static Update<Todo2> Handle(\n    // The first argument is always the incoming message\n    RenameTodo command, \n    \n    // By using this attribute, we're telling Wolverine\n    // to load the Todo entity from the configured\n    // persistence of the app using a member on the\n    // incoming message type\n    [Entity] Todo2 todo)\n{\n    // Do your actual business logic\n    todo.Name = command.Name;\n    \n    // Tell Wolverine that you want this entity\n    // updated in persistence\n    return Storage.Update(todo);\n}\n```\n\n----------------------------------------\n\nTITLE: Returning HTTP Response and Cascading Message via Tuple in Wolverine C#\nDESCRIPTION: This C# example defines a Wolverine HTTP POST endpoint (`/todoitems`) within a static class `TodoCreationEndpoint`. The `Post` method returns a `Tuple<(TodoCreationResponse, TodoCreated)>`. Wolverine interprets the first element, `TodoCreationResponse` (inheriting from `CreationResponse`), as the HTTP response (201 Created with `location` header). The second element, `TodoCreated`, is treated as a cascading message. It uses an injected `IDocumentSession` for persistence.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// Introducing this special type just for the http response\n// gives us back the 201 status code\npublic record TodoCreationResponse(int Id)\n    : CreationResponse(\"/todoitems/\" + Id);\n\n// The \"Endpoint\" suffix is meaningful, but you could use\n// any name if you don't mind adding extra attributes or a marker interface\n// for discovery\npublic static class TodoCreationEndpoint\n{\n    [WolverinePost(\"/todoitems\")]\n    public static (TodoCreationResponse, TodoCreated) Post(CreateTodo command, IDocumentSession session)\n    {\n        var todo = new Todo { Name = command.Name };\n\n        // Just telling Marten that there's a new entity to persist,\n        // but I'm assuming that the transactional middleware in Wolverine is\n        // handling the asynchronous persistence outside of this handler\n        session.Store(todo);\n\n        // By Wolverine.Http conventions, the first \"return value\" is always\n        // assumed to be the Http response, and any subsequent values are\n        // handled independently\n        return (\n            new TodoCreationResponse(todo.Id),\n            new TodoCreated(todo.Id)\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Wolverine Message Handlers as Instance Methods (C#)\nDESCRIPTION: Illustrates creating a handler class (`ExampleHandler`) with instance methods (`Handle`) for different message types (`Message1`, `Message2`). When using instance methods, Wolverine creates a new instance of the handler class for each message being processed, scoping the handler object to that message and disposing it afterward. This allows for state management within the handler instance and facilitates dependency injection via the constructor.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic class ExampleHandler\n{\n    public void Handle(Message1 message)\n    {\n        // Do work synchronously\n    }\n\n    public Task Handle(Message2 message)\n    {\n        // Do work asynchronously\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Account Debit with Transactional Outbox in Wolverine (C#)\nDESCRIPTION: Implements a transactional message handler in C# for debiting an account using Wolverine middleware. The handler processes a DebitAccount command, updates the account balance, stores the updated state via a session, and conditionally queues further messages (e.g., alerts for low balance, overdrawn status) using IMessageContext. All message publishing is coordinated within a single transaction, relying on the outbox pattern to ensure eventual consistency between persistence and messaging. This snippet requires Wolverine, Marten or EF Core for session management, and an active IMessageContext. It receives command and state objects, and emits no direct outputs but triggers asynchronous messages as side effects.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[Transactional]\npublic static async Task Handle(\n    DebitAccount command,\n    Account account,\n    IDocumentSession session,\n    IMessageContext messaging)\n{\n    account.Balance -= command.Amount;\n\n    // This just marks the account as changed, but\n    // doesn't actually commit changes to the database\n    // yet. That actually matters as I hopefully explain\n    session.Store(account);\n\n    // Conditionally trigger other, cascading messages\n    if (account.Balance > 0 && account.Balance < account.MinimumThreshold)\n    {\n        await messaging.SendAsync(new LowBalanceDetected(account.Id));\n    }\n    else if (account.Balance < 0)\n    {\n        await messaging.SendAsync(new AccountOverdrawn(account.Id), new DeliveryOptions{DeliverWithin = 1.Hours()});\n\n        // Give the customer 10 days to deal with the overdrawn account\n        await messaging.ScheduleAsync(new EnforceAccountOverdrawnDeadline(account.Id), 10.Days());\n    }\n\n    // \"messaging\" is a Wolverine IMessageContext or IMessageBus service\n    // Do the deliver within rule on individual messages\n    await messaging.SendAsync(new AccountUpdated(account.Id, account.Balance),\n        new DeliveryOptions { DeliverWithin = 5.Seconds() });\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Storage Actions with Wolverine UnitOfWork in C#\nDESCRIPTION: This C# example demonstrates using `UnitOfWork<T>` as a return type from a message handler (`StoreManyHandler`). This allows returning multiple storage actions (in this case, multiple inserts based on the `Adds` array in the `StoreMany` command). The `UnitOfWork<T>` collects these actions, which Wolverine then processes against the underlying persistence store.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/side-effects.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic record StoreMany(string[] Adds);\n\npublic static class StoreManyHandler\n{\n    public static UnitOfWork<Todo> Handle(StoreMany command)\n    {\n        var uow = new UnitOfWork<Todo>();\n        foreach (var add in command.Adds)\n        {\n            uow.Insert(new Todo { Id = add });\n        }\n\n        return uow;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten Multi-Tenancy and Integrating with Wolverine in C#\nDESCRIPTION: Configures Marten to use a database-per-tenant strategy by registering explicit connection strings for each tenant and specifies a common database schema. The Marten instance is integrated with Wolverine by providing a master database connection string for tenant-neutral operations. Requires dependency injection set up in ASP.NET Core and references to Marten, Wolverine.Marten, and proper PostgreSQL databases. Inputs are tenant names and their corresponding connection strings; outputs are database sessions and correct routing of messages to tenant-specific data stores.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/multi-tenancy.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// Adding Marten for persistence\nbuilder.Services.AddMarten(m =>\n    {\n        // With multi-tenancy through a database per tenant\n        m.MultiTenantedDatabases(tenancy =>\n        {\n            // You would probably be pulling the connection strings out of configuration,\n            // but it's late in the afternoon and I'm being lazy building out this sample!\n            tenancy.AddSingleTenantDatabase(\"Host=localhost;Port=5433;Database=tenant1;Username=postgres;password=postgres\", \"tenant1\");\n            tenancy.AddSingleTenantDatabase(\"Host=localhost;Port=5433;Database=tenant2;Username=postgres;password=postgres\", \"tenant2\");\n            tenancy.AddSingleTenantDatabase(\"Host=localhost;Port=5433;Database=tenant3;Username=postgres;password=postgres\", \"tenant3\");\n        });\n\n        m.DatabaseSchemaName = \"mttodo\";\n    })\n    .IntegrateWithWolverine(x => x.MasterDatabaseConnectionString = connectionString);\n```\n\n----------------------------------------\n\nTITLE: Auto-Purging Azure Service Bus Queues at Startup with Wolverine (C#)\nDESCRIPTION: This example illustrates how to configure Wolverine to automatically purge all Azure Service Bus queues at application startup by chaining the AutoPurgeOnStartup() method. It is useful for development environments to ensure a clean state at every run, and may also be used queue-by-queue. Requires Wolverine and a valid Service Bus connection string. Inputs are startup configuration; output is purged queues upon startup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/object-management.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAzureServiceBus(\"some connection string\")\n            .AutoPurgeOnStartup();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Returning a Tuple to Start a Saga and Cascade a Message in Wolverine (C#)\nDESCRIPTION: This C# code snippet shows a static `Start` method within a Wolverine message handler. It accepts a `StartOrder` message and an `ILogger`. The method returns a tuple containing a new `Order` object (which likely initiates a saga) and an `OrderTimeout` object (treated as a cascading message to be published). This illustrates Wolverine's capability to handle tuple return types, processing each element individually according to its type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/return-values.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// This method would be called when a StartOrder message arrives\n// to start a new Order\npublic static (Order, OrderTimeout) Start(StartOrder order, ILogger<Order> logger)\n{\n    logger.LogInformation(\"Got a new order with id {Id}\", order.OrderId);\n\n    // creating a timeout message for the saga\n    return (new Order{Id = order.OrderId}, new OrderTimeout(order.OrderId));\n}\n```\n\n----------------------------------------\n\nTITLE: Using IDbContextOutbox and Explicit Enrollment for EF Core Outbox in C#\nDESCRIPTION: This snippet illustrates using the non-generic `IDbContextOutbox` service alongside a separately injected `DbContext` in an ASP.NET Core controller. It highlights the mandatory step of explicitly calling `outbox.Enroll(dbContext)` *before* publishing any messages to link the `DbContext`'s transaction with the outbox. It performs similar actions to the generic approach: creating an entity, adding it to the DbContext, publishing a message, and using `SaveChangesAndFlushMessagesAsync` for an atomic commit of database changes and message persistence. Requires `IDbContextOutbox`, `ItemsDbContext`, and related types in the DI container.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/efcore.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\n[HttpPost(\"/items/create3\")]\npublic async Task Post3(\n    [FromBody] CreateItemCommand command,\n    [FromServices] ItemsDbContext dbContext,\n    [FromServices] IDbContextOutbox outbox)\n{\n    // Create a new Item entity\n    var item = new Item\n    {\n        Name = command.Name\n    };\n\n    // Add the item to the current\n    // DbContext unit of work\n    dbContext.Items.Add(item);\n\n    // Gotta attach the DbContext to the outbox\n    // BEFORE sending any messages\n    outbox.Enroll(dbContext);\n\n    // Publish a message to take action on the new item\n    // in a background thread\n    await outbox.PublishAsync(new ItemCreated\n    {\n        Id = item.Id\n    });\n\n    // Commit all changes and flush persisted messages\n    // to the persistent outbox\n    // in the correct order\n    await outbox.SaveChangesAndFlushMessagesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Circuit Breaker for Wolverine RabbitMQ Endpoint in C#\nDESCRIPTION: This C# snippet demonstrates configuring Wolverine's circuit breaker for a RabbitMQ queue listener named 'incoming' within the host setup. It configures various options such as the minimum number of messages before evaluation (`MinimumThreshold`), the pause duration (`PauseTime`), the period for tracking statistics (`TrackingPeriod`), and the failure percentage threshold to trip the circuit (`FailurePercentageThreshold`). Optional exception filtering is shown using `Include` for specific exceptions (NpgsqlException, SocketException) and `Exclude` for others (InvalidOperationException) to control what constitutes a failure.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_12\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Policies.OnException<InvalidOperationException>()\n            .Discard();\n\n        opts.ListenToRabbitQueue(\"incoming\")\n            .CircuitBreaker(cb =>\n            {\n                // Minimum number of messages encountered within the tracking period\n                // before the circuit breaker will be evaluated\n                cb.MinimumThreshold = 10;\n\n                // The time to pause the message processing before trying to restart\n                cb.PauseTime = 1.Minutes();\n\n                // The tracking period for the evaluation. Statistics tracking\n                cb.TrackingPeriod = 5.Minutes();\n\n                // If the failure percentage is higher than this number, trip\n                // the circuit and stop processing\n                cb.FailurePercentageThreshold = 10;\n\n                // Optional allow list\n                cb.Include<NpgsqlException>(e => e.Message.Contains(\"Failure\"));\n                cb.Include<SocketException>();\n\n                // Optional ignore list\n                cb.Exclude<InvalidOperationException>();\n            });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Synchronous HTTP Endpoints with Wolverine in C#\nDESCRIPTION: This code defines a synchronous HTTP POST endpoint in C# using the WolverinePost attribute, handling incoming Question objects and returning calculated ArithmeticResults. It requires the Wolverine framework and expects Question as the request body, computing both the sum and product of two fields. The method is static and demonstrates attribute-based routing for API handlers, with the endpoint accessible via the '/question' path and returning a serialized ArithmeticResults object.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[WolverinePost(\"/question\")]\npublic static ArithmeticResults PostJson(Question question)\n{\n    return new ArithmeticResults\n    {\n        Sum = question.One + question.Two,\n        Product = question.One * question.Two\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Conventional Wolverine Middleware with Stopwatch (C#)\nDESCRIPTION: This C# snippet defines a `StopwatchMiddleware` class demonstrating Wolverine's conventional middleware approach. The `Before` method starts a `Stopwatch` instance stored in a field. The `Finally` method, which Wolverine places in a `finally` block during code generation, stops the stopwatch and logs the execution duration along with message envelope details using `ILogger` and `Envelope` parameters provided by Wolverine.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic class StopwatchMiddleware\n{\n    private readonly Stopwatch _stopwatch = new();\n\n    public void Before()\n    {\n        _stopwatch.Start();\n    }\n\n    public void Finally(ILogger logger, Envelope envelope)\n    {\n        _stopwatch.Stop();\n        logger.LogDebug(\"Envelope {Id} / {MessageType} ran in {Duration} milliseconds\",\n            envelope.Id, envelope.MessageType, _stopwatch.ElapsedMilliseconds);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Durable Messaging Policy Globally in Wolverine (C#)\nDESCRIPTION: Demonstrates how to configure all outgoing subscriber endpoints to use durable message storage globally within a Wolverine application. Utilizing the UseDurableOutboxOnAllSendingEndpoints policy, this snippet ensures all outbound messages benefit from the outbox pattern and transactional safety. This configuration must be placed in the UseWolverine options during host startup. Requires Wolverine and should be included at the application configuration stage to affect all endpoints.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/index.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // This forces every outgoing subscriber to use durable\n        // messaging\n        opts.Policies.UseDurableOutboxOnAllSendingEndpoints();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Returning Conditional IResult from Wolverine HTTP Endpoint in C#\nDESCRIPTION: Demonstrates a Wolverine HTTP endpoint method decorated with `[WolverinePost]`. The method takes a `GoToColor` request object and returns different `IResult` types (specifically `Results.Redirect` or `Results.Content` from `Microsoft.AspNetCore.Http.Results`) based on the value of the `Color` property in the request. This allows for conditional logic to determine the HTTP response.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\n[WolverinePost(\"/choose/color\")]\npublic IResult Redirect(GoToColor request)\n{\n    switch (request.Color)\n    {\n        case \"Red\":\n            return Results.Redirect(\"/red\");\n\n        case \"Green\":\n            return Results.Redirect(\"/green\");\n\n        default:\n            return Results.Content(\"Choose red or green!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Local and External (e.g., RabbitMQ) Routing Conventions in Wolverine (C#)\nDESCRIPTION: This code sets up Wolverine to use both local and RabbitMQ broker routing for the same message types by enabling additive local routing. It configures RabbitMQ using a connection string from configuration and sets UseConventionalRouting and ConventionalLocalRoutingIsAdditive, allowing handlers to run locally and publish externally. Dependencies: Microsoft Extensions Hosting, IWolverineOptions, RabbitMQ (Wolverine integration). Inputs: Host builder and configuration; Output: Routing is additive and applies all relevant conventions. Requires RabbitMQ connection string to be set in configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/subscriptions.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    var rabbitConnectionString = builder\n        .Configuration.GetConnectionString(\"rabbitmq\");\n\n    opts.UseRabbitMq(rabbitConnectionString)\n        .AutoProvision()\n\n        // Using the built in, default Rabbit MQ message routing conventions\n        .UseConventionalRouting();\n    \n    // Allow Wolverine to *also* apply the Rabbit MQ conventional\n    // routing to message types that this system can handle locally\n    opts.Policies.ConventionalLocalRoutingIsAdditive();\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Required Entity Loading in Wolverine.Http Endpoint using C#\nDESCRIPTION: Illustrates using the `[Required]` attribute on an endpoint handler parameter (`Todo? todo`) to enforce its presence. A separate `LoadAsync` method is defined to fetch the `Todo` entity based on the `id` route parameter using Marten's `IDocumentSession`. If `LoadAsync` returns null, Wolverine.Http automatically returns a 404 Not Found response. If the entity exists, the `Put` method is invoked with the non-null `todo`, updates its properties from the `UpdateRequest` body, and returns a `StoreDoc<Todo>` side effect for Marten to persist the changes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npublic record UpdateRequest(string Name, bool IsComplete);\n\npublic static class UpdateEndpoint\n{\n    // Find required Todo entity for the route handler below\n    public static Task<Todo?> LoadAsync(int id, IDocumentSession session)\n        => session.LoadAsync<Todo>(id);\n\n    [WolverinePut(\"/todos/{id:int}\")]\n    public static StoreDoc<Todo> Put(\n        // Route argument\n        int id,\n\n        // The request body\n        UpdateRequest request,\n\n        // Entity loaded by the method above,\n        // but note the [Required] attribute\n        [Required] Todo? todo)\n    {\n        todo.Name = request.Name;\n        todo.IsComplete = request.IsComplete;\n\n        return MartenOps.Store(todo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating Request/Response Invocations with TestMessageContext in C#\nDESCRIPTION: This snippet demonstrates how to use Wolverine's TestMessageContext to set up and test expected responses to InvokeAsync request messages, including scenarios for message type, destination URI, and named endpoints. The code shows using WhenInvokedMessageOf to register expected replies based on message content or route, making it suitable for testing request/reply logic in message-driven applications. The approach supports synthetic invocation and response, facilitating unit testing without real transport dependencies. Required are the relevant request and response types, and reference to the Wolverine testing infrastructure.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nvar spy = new TestMessageContext();\nvar context = (IMessageContext)spy;\n\n// Set up an expected response for a message\nspy.WhenInvokedMessageOf<NumberRequest>()\n    .RespondWith(new NumberResponse(12));\n\n// Used for:\nvar response1 = await context.InvokeAsync<NumberResponse>(new NumberRequest(4, 5));\n\n// Set up an expected response with a matching filter\nspy.WhenInvokedMessageOf<NumberRequest>(x => x.X == 4)\n    .RespondWith(new NumberResponse(12));\n\n// Set up an expected response for a message to an explicit destination Uri\nspy.WhenInvokedMessageOf<NumberRequest>(destination:new Uri(\"rabbitmq://queue/incoming\"))\n    .RespondWith(new NumberResponse(12));\n\n// Used to set up:\nvar response2 = await context.EndpointFor(new Uri(\"rabbitmq://queue/incoming\"))\n    .InvokeAsync<NumberResponse>(new NumberRequest(5, 6));\n\n// Set up an expected response for a message to a named endpoint\nspy.WhenInvokedMessageOf<NumberRequest>(endpointName:\"incoming\")\n    .RespondWith(new NumberResponse(12));\n\n// Used to set up:\nvar response3 = await context.EndpointFor(\"incoming\")\n    .InvokeAsync<NumberResponse>(new NumberRequest(5, 6));\n```\n\n----------------------------------------\n\nTITLE: Configuring Durable Local Queues in Wolverine using C#\nDESCRIPTION: This C# snippet illustrates different ways to configure durability for Wolverine's local queues. It shows how to enable durable storage for all local queues using `opts.Policies.UseDurableLocalQueues()`, for a specific named queue ('important') using `opts.LocalQueue(\"important\").UseDurableInbox()`, or conventionally based on message type namespaces within `opts.Policies.ConfigureConventionalLocalRouting()`. Durable local queues ensure messages published locally are persisted until successfully processed.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/index.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Policies.UseDurableLocalQueues();\n\n        // or\n\n        opts.LocalQueue(\"important\").UseDurableInbox();\n\n        // or conventionally, make the local queues for messages in a certain namespace\n        // be durable\n        opts.Policies.ConfigureConventionalLocalRouting().CustomizeQueues((type, queue) =>\n        {\n            if (type.IsInNamespace(\"MyApp.Commands.Durable\"))\n            {\n                queue.UseDurableInbox();\n            }\n        });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Durable Inbox for Wolverine Endpoints in C#\nDESCRIPTION: This snippet demonstrates how to configure Wolverine's durable inbox feature within the host builder. It shows two approaches: enrolling a specific listening endpoint (`ListenAtPort(5555)`) using `.UseDurableInbox()`, and enrolling all listener endpoints globally using `opts.Policies.UseDurableInboxOnAllListeners()`. This ensures incoming messages are persisted durably before processing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/index.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.ListenAtPort(5555)\n\n            // Make specific endpoints be enrolled\n            // in the durable inbox\n            .UseDurableInbox();\n\n        // Make every single listener endpoint use\n        // durable message storage\n        opts.Policies.UseDurableInboxOnAllListeners();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Creating Orders via ASP.NET Core MVC Controller with Outbox Pattern - C#\nDESCRIPTION: Showcases an ASP.NET Core MVC controller action that handles HTTP POST requests to create orders using Marten and ensures an OrderCreated message is only published if the transaction commits. Relies on ASP.NET Core dependency injection for IDocumentSession and IMartenOutbox. The action receives a CreateOrder DTO and persists a new Order. Message publication is deferred to post-transaction, promoting strong consistency between the database and event bus.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/outbox.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class CreateOrderController : ControllerBase\n{\n    [HttpPost(\"/orders/create2\")]\n    public async Task Create(\n        [FromBody] CreateOrder command,\n        [FromServices] IDocumentSession session,\n        [FromServices] IMartenOutbox outbox)\n    {\n        var order = new Order\n        {\n            Description = command.Description\n        };\n\n        // Register the new document with Marten\n        session.Store(order);\n\n        // Don't worry, this message doesn't go out until\n        // after the Marten transaction succeeds\n        await outbox.PublishAsync(new OrderCreated(order.Id));\n\n        // Commit the Marten transaction\n        await session.SaveChangesAsync();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Fluent Validation Failure Action in C#\nDESCRIPTION: This snippet shows how to customize the behavior when Fluent Validation fails. It defines a custom exception class `MySpecialException` and a generic class `CustomFailureAction<T>` that implements the `Wolverine.FluentValidation.IFailureAction<T>` interface. The `Throw` method in `CustomFailureAction<T>` receives the message and validation failures, and throws the custom exception with a formatted error message.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/fluent-validation.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic class MySpecialException : Exception\n{\n    public MySpecialException(string? message) : base(message)\n    {\n    }\n}\n\npublic class CustomFailureAction<T> : IFailureAction<T>\n{\n    public void Throw(T message, IReadOnlyList<ValidationFailure> failures)\n    {\n        throw new MySpecialException(\"Your message stinks!: \" + failures.Select(x => x.ErrorMessage).Join(\", \"));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Lightweight Saga Storage in Wolverine (C#)\nDESCRIPTION: This C# code snippet shows how to configure Wolverine within a .NET `Host` builder. It manually registers `RedSaga` and `BlueSaga` types using `opts.AddSagaType()`, optionally specifying custom table names ('red', 'blue'). It also configures SQL Server persistence for messages and sagas using `PersistMessagesWithSqlServer` and enables resource setup on startup. This is useful for controlling table names or integrating with database migration tools. Dependencies include `Microsoft.Extensions.Hosting`, `Wolverine`, and specific database persistence extensions.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sagas.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.AddSagaType<RedSaga>(\"red\");\n        opts.AddSagaType(typeof(BlueSaga),\"blue\");\n        \n        \n        opts.PersistMessagesWithSqlServer(Servers.SqlServerConnectionString, \"color_sagas\");\n        opts.Services.AddResourceSetupOnStartup();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Wolverine.HTTP Endpoint for Cancelling Orders with Validation and Side Effects in C#\nDESCRIPTION: Implements order cancellation logic using a dedicated Wolverine.HTTP endpoint class (`CancelOrderEndpoint`). It uses the `[WolverinePost]` attribute to define the route (`/api/orders/cancel/id`) and HTTP method. The `[Entity]` attribute signifies that the `Order` parameter should be loaded by Wolverine, presumably based on an 'id' route parameter. A separate `Validate` method performs business rule checks (e.g., `HasShipped`) and returns `ProblemDetails` for errors or `WolverineContinue.NoProblems` to allow execution to proceed. The `Post` method returns a tuple containing `Delete<Order>` and `OrderCancelled` side effects, which Wolverine executes. The `[EmptyResponse]` attribute suggests a 204 No Content response is returned on success.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class CancelOrderEndpoint\n{\n    // Validation method executed before the handler\n    public static ProblemDetails Validate(Order order)\n    {\n        // Assuming Order has a HasShipped property\n        return order.HasShipped\n            // Return ProblemDetails for a 400 Bad Request if shipped\n            ? new ProblemDetails { Status = 400, Detail = \"Order has already shipped\" } \n            \n            // Indicate validation passed, continue processing\n            : WolverineContinue.NoProblems;\n    }\n\n    // Define HTTP POST endpoint with route and indicate empty success response\n    [WolverinePost(\"/api/orders/cancel/id\"), EmptyResponse] \n    // [Entity] likely directs Wolverine to load the Order based on route parameter 'id'\n    // Returns a tuple of side effects: Delete operation and OrderCancelled event\n    public static (Delete<Order>, OrderCancelled) Post([Entity] Order order) \n    {\n        // Return side effects: delete the loaded order and publish the event\n        return (Storage.Delete(order), new OrderCancelled(order.Id));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Durable Local Queues in Wolverine (C#)\nDESCRIPTION: Illustrates different ways to configure durable local queues in Wolverine during application setup using `UseWolverine`. Options shown include enabling durable local queues globally via policies (`opts.Policies.UseDurableLocalQueues()`), making a specific named local queue durable (`opts.LocalQueue(\"important\").UseDurableInbox()`), or conventionally enabling durability for local queues based on the message type's namespace (`opts.Policies.ConfigureConventionalLocalRouting().CustomizeQueues(...)`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/modular-monolith.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n```cs\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Policies.UseDurableLocalQueues();\n\n        // or\n\n        opts.LocalQueue(\"important\").UseDurableInbox();\n\n        // or conventionally, make the local queues for messages in a certain namespace\n        // be durable\n        opts.Policies.ConfigureConventionalLocalRouting().CustomizeQueues((type, queue) =>\n        {\n            if (type.IsInNamespace(\"MyApp.Commands.Durable\"))\n            {\n                queue.UseDurableInbox();\n            }\n        });\n    }).StartAsync();\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring KeepAfterMessageHandling Duration in Wolverine (C#)\nDESCRIPTION: This C# snippet demonstrates configuring Wolverine's durability settings within the application host setup. It specifically sets the `KeepAfterMessageHandling` property to 10 minutes, overriding the default of 5 minutes. This setting determines how long Wolverine retains records of handled messages in its durable inbox storage to detect and prevent processing of duplicate messages, thus ensuring idempotent delivery.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/idempotency.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // The default is 5 minutes, but if you want to keep\n        // messages around longer (or shorter) in case of duplicates,\n        // this is how you do it\n        opts.Durability.KeepAfterMessageHandling = 10.Minutes();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Handling DebitAccount with Wolverine IMessageContext in C#\nDESCRIPTION: This C# code implements a Wolverine message handler that manages account debits, conditionally emits cascading messages for low balance or overdrawn scenarios, and schedules further actions using IMessageContext. It relies on dependencies including Account, DebitAccount command, IDocumentSession for persistence, and an IMessageContext for asynchronous messaging. Key parameters include the command, account state, session, and messaging context; outputs are sent or scheduled messages based on business logic, with the handler itself being async and transactional. Prerequisites include references to the Wolverine framework and related domain models.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[Transactional]\npublic static async Task Handle(\n    DebitAccount command,\n    Account account,\n    IDocumentSession session,\n    IMessageContext messaging)\n{\n    account.Balance -= command.Amount;\n\n    // This just marks the account as changed, but\n    // doesn't actually commit changes to the database\n    // yet. That actually matters as I hopefully explain\n    session.Store(account);\n\n    // Conditionally trigger other, cascading messages\n    if (account.Balance > 0 && account.Balance < account.MinimumThreshold)\n    {\n        await messaging.SendAsync(new LowBalanceDetected(account.Id));\n    }\n    else if (account.Balance < 0)\n    {\n        await messaging.SendAsync(new AccountOverdrawn(account.Id), new DeliveryOptions{DeliverWithin = 1.Hours()});\n\n        // Give the customer 10 days to deal with the overdrawn account\n        await messaging.ScheduleAsync(new EnforceAccountOverdrawnDeadline(account.Id), 10.Days());\n    }\n\n    // \"messaging\" is a Wolverine IMessageContext or IMessageBus service\n    // Do the deliver within rule on individual messages\n    await messaging.SendAsync(new AccountUpdated(account.Id, account.Balance),\n        new DeliveryOptions { DeliverWithin = 5.Seconds() });\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling Message Publishing with Delays using Wolverine (.NET/C#)\nDESCRIPTION: Demonstrates two approaches to scheduling message delivery with a delay via the IMessageContext interface: ScheduleAsync with a TimeSpan delay and PublishAsync with DeliveryOptions specifying ScheduleDelay. Dependencies: Wolverine, IMessageContext, custom message types (WarnIfIssueIsStale). The method delays execution by three days, using .NET extension methods (3.Days()), and requires awaiting asynchronous calls. Inputs: a message context and a GUID. Outputs: scheduled message delivery; exceptions may arise if message scheduling is unsupported for the endpoint.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task schedule_send(IMessageContext context, Guid issueId)\n{\n    var timeout = new WarnIfIssueIsStale\n    {\n        IssueId = issueId\n    };\n\n    // Process the issue timeout logic 3 days from now\n    await context.ScheduleAsync(timeout, 3.Days());\n\n    // The code above is short hand for this:\n    await context.PublishAsync(timeout, new DeliveryOptions\n    {\n        ScheduleDelay = 3.Days()\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Middleware by Message Type Using Configuration API in Wolverine (C#)\nDESCRIPTION: Depicts how to register middleware globally for message types implementing a specific interface via the UseWolverine options configuration. The sample also demonstrates additional policies like FluentValidation registration and local publish route setup. Requires a configured builder.Host and presumes prior setup of corresponding middleware classes/types.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Host.UseWolverine(opts =>\n{\n    // This middleware should be applied to all handlers where the\n    // command type implements the IAccountCommand interface that is the\n    // \"detected\" message type of the middleware\n    opts.Policies.ForMessagesOfType<IAccountCommand>().AddMiddleware(typeof(AccountLookupMiddleware));\n\n    opts.UseFluentValidation();\n\n    // Explicit routing for the AccountUpdated\n    // message handling. This has precedence over conventional routing\n    opts.PublishMessage<AccountUpdated>()\n        .ToLocalQueue(\"signalr\")\n\n        // Throw the message away if it's not successfully\n        // delivered within 10 seconds\n        .DeliverWithin(10.Seconds())\n\n        // Not durable\n        .BufferedInMemory();\n});\n```\n\n----------------------------------------\n\nTITLE: Returning Conditional Cascading Messages in Wolverine (C#)\nDESCRIPTION: This C# snippet demonstrates a handler `ConditionalResponseHandler` that returns different cascading messages based on the content of the input `DirectionRequest`. By returning `object`, the handler can use conditional logic (like a switch statement) to decide whether to return `GoNorth`, `GoSouth`, or potentially nothing (`null`). This allows for dynamic response types.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic class ConditionalResponseHandler\n{\n    public object Consume(DirectionRequest request)\n    {\n        switch (request.Direction)\n        {\n            case \"North\":\n                return new GoNorth();\n            case \"South\":\n                return new GoSouth();\n        }\n\n        // This does nothing\n        return null;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Static Message Publishing Rules with Wolverine (C#)\nDESCRIPTION: This snippet configures various explicit publishing rules within the UseWolverine options lambda, showing single-type routing, all-messages routing, assembly-based routing, and complex multi-rule scenarios. It demonstrates the fluent API for advanced message selection, including by assembly, type, and namespace. Dependencies: Microsoft Extensions Hosting, Wolverine. Inputs: Host builder setup; Outputs: Routing rules for message types are statically applied prior to Host startup. All configuration must occur before StartAsync, and message type references must be available at compile time.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/subscriptions.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Route a single message type\n        opts.PublishMessage<PingMessage>()\n            .ToServerAndPort(\"server\", 1111);\n\n        // Send every possible message to a TCP listener\n        // on this box at port 2222\n        opts.PublishAllMessages().ToPort(2222);\n\n        // Or use a more fluent interface style\n        opts.Publish().MessagesFromAssembly(typeof(PingMessage).Assembly)\n            .ToPort(3333);\n\n        // Complicated rules, I don't think folks will use this much\n        opts.Publish(rule =>\n        {\n            // Apply as many message matching\n            // rules as you need\n\n            // Specific message types\n            rule.Message<PingMessage>();\n            rule.Message<Message1>();\n\n            // Implementing a specific marker interface or common base class\n            rule.MessagesImplementing<IEventMarker>();\n\n            // All types in a certain assembly\n            rule.MessagesFromAssemblyContaining<PingMessage>();\n\n            // or this\n            rule.MessagesFromAssembly(typeof(PingMessage).Assembly);\n\n            // or by namespace\n            rule.MessagesFromNamespace(\"MyMessageLibrary\");\n            rule.MessagesFromNamespaceContaining<PingMessage>();\n\n            // Express the subscribers\n            rule.ToPort(1111);\n            rule.ToPort(2222);\n        });\n\n        // Or you just send all messages to a certain endpoint\n        opts.PublishAllMessages().ToPort(3333);\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Return Type Record for File Writing (C#)\nDESCRIPTION: This C# snippet defines a public `record` named `WriteFile` with `Path` and `Contents` properties. It includes an asynchronous method `WriteAsync` that uses `File.WriteAllTextAsync` to write the contents to the specified path. This record serves as a custom return value from a Wolverine handler to represent a file writing side effect.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/return-values.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n// This has to be public btw\npublic record WriteFile(string Path, string Contents)\n{\n    public Task WriteAsync()\n    {\n        return File.WriteAllTextAsync(Path, Contents);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Interop-Friendly RabbitMQ Dead Letter Queues in Wolverine (C#)\nDESCRIPTION: This C# code configures Wolverine's RabbitMQ transport for dead letter queueing in an interoperability-friendly mode. By specifying `DeadLetterQueueMode.InteropFriendly` when creating the `DeadLetterQueue` object, Wolverine is instructed not to add the `x-dead-letter-exchange` argument to the queues it declares. This is useful when interacting with other messaging tools (like NServiceBus) or existing RabbitMQ setups where queues might already be declared without this argument. The snippet shows applying this mode globally, conventionally, and for a specific queue.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/deadletterqueues.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Use a different default deal letter queue name\n        opts.UseRabbitMq()\n            .CustomizeDeadLetterQueueing(\n                new DeadLetterQueue(\"error-queue\", DeadLetterQueueMode.InteropFriendly))\n\n            // or conventionally\n            .ConfigureListeners(l =>\n            {\n                l.DeadLetterQueueing(new DeadLetterQueue($\"{l.QueueName}-errors\",\n                    DeadLetterQueueMode.InteropFriendly));\n            });\n\n        // Use a different dead letter queue for this specific queue\n        opts.ListenToRabbitQueue(\"incoming\")\n            .DeadLetterQueueing(new DeadLetterQueue(\"incoming-errors\", DeadLetterQueueMode.InteropFriendly));\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Endpoint-Specific Dead Lettering for Wolverine with GCP Pub/Sub in C#\nDESCRIPTION: This C# snippet demonstrates configuring dead lettering behavior for individual Wolverine endpoints using the GCP Pub/Sub transport. After enabling dead lettering globally, it shows how to disable it for a specific topic (`incoming`) using `DisableDeadLettering()` and how to customize the dead letter topic name ('important_errors') and its configuration (e.g., enabling telemetry) for another topic (`important`) using `ConfigureDeadLettering()`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/gcp-pubsub/deadlettering.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UsePubsub(\"your-project-id\")\n            .EnableDeadLettering();\n\n        // No dead letter queueing\n        opts.ListenToPubsubTopic(\"incoming\")\n            .DisableDeadLettering();\n\n        // Use a different dead letter queue\n        opts.ListenToPubsubTopic(\"important\")\n            .ConfigureDeadLettering(\n                \"important_errors\",\n\n                // Optionally configure how the dead letter itself\n                // is built by Wolverine\n                e => { e.TelemetryEnabled = true; }\n            );\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring SQL Server Persistence and Transport in Wolverine (C#)\nDESCRIPTION: Demonstrates configuring Wolverine to utilize SQL Server for both message persistence and as a messaging transport using `UseSqlServerPersistenceAndTransport()`. The configuration includes setting the connection string, schema name, enabling automatic provisioning of necessary database objects (`AutoProvision`), and optionally purging queues on startup (`AutoPurgeOnStartup`). It also shows how to define publishing rules to a specific SQL Server queue (`ToSqlServerQueue`) and set up a listener for another queue (`ListenToSqlServerQueue`) with circuit breaker customization and message batch sizing. Requires the `WolverineFx.SqlServer` package.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sqlserver.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n<!-- snippet: sample_using_sql_server_transport -->\n<a id='snippet-sample_using_sql_server_transport'></a>\n```cs\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    var connectionString = builder.Configuration.GetConnectionString(\"sqlserver\");\n    opts.UseSqlServerPersistenceAndTransport(connectionString, \"myapp\")\n\n        // Tell Wolverine to build out all necessary queue or scheduled message\n        // tables on demand as needed\n        .AutoProvision()\n\n        // Optional that may be helpful in testing, but probably bad\n        // in production!\n        .AutoPurgeOnStartup();\n\n    // Use this extension method to create subscriber rules\n    opts.PublishAllMessages().ToSqlServerQueue(\"outbound\");\n\n    // Use this to set up queue listeners\n    opts.ListenToSqlServerQueue(\"inbound\")\n        .CircuitBreaker(cb =>\n        {\n            // fine tune the circuit breaker\n            // policies here\n        })\n\n        // Optionally specify how many messages to\n        // fetch into the listener at any one time\n        .MaximumMessagesToReceive(50);\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n<sup><a href='https://github.com/JasperFx/wolverine/blob/main/src/Persistence/SqlServerTests/Transport/DocumentationSamples.cs#L12-L48' title='Snippet source file'>snippet source</a> | <a href='#snippet-sample_using_sql_server_transport' title='Start of snippet'>anchor</a></sup>\n<!-- endSnippet -->\n```\n\n----------------------------------------\n\nTITLE: Disabling All Wolverine Persistence and Transports in C#\nDESCRIPTION: Illustrates how to completely disable both external message transports and message persistence in Wolverine by calling `DisableAllExternalWolverineTransports()` and `DisableAllWolverineMessagePersistence()` extension methods on `IServiceCollection` during host configuration. This is useful for bootstrapping the application for tasks like generating OpenAPI documentation or running specific tests without requiring database or broker connectivity.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await AlbaHost.For<Program>(builder =>\n{\n    builder.ConfigureServices(services =>\n    {\n        // You probably have to do both\n        services.DisableAllExternalWolverineTransports();\n        services.DisableAllWolverineMessagePersistence();\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Customizing Individual Cascading Messages Delivery in Wolverine (C#)\nDESCRIPTION: Illustrates applying delivery customizations directly to individual cascaded messages using extension methods. This handler returns an `IEnumerable<object>`, yielding messages configured with delays (`DelayedFor`), specific schedules (`ScheduledAt`), custom delivery options like headers (`WithDeliveryOptions`), or targeted replies (`Respond.ToSender`). This allows fine-grained control over cascaded message publishing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n// snippet: sample_customized_cascaded_messages\npublic static IEnumerable<object> Consume(Incoming incoming)\n{\n    // Delay the message delivery by 10 minutes\n    yield return new Message1().DelayedFor(10.Minutes());\n\n    // Schedule the message delivery for a certain time\n    yield return new Message2().ScheduledAt(new DateTimeOffset(DateTime.Today.AddDays(2)));\n\n    // Customize the message delivery however you please...\n    yield return new Message3()\n        .WithDeliveryOptions(new DeliveryOptions().WithHeader(\"foo\", \"bar\"));\n\n    // Send back to the original sender\n    yield return Respond.ToSender(new Message4());\n}\n// endSnippet\n```\n\n----------------------------------------\n\nTITLE: Defining GET Endpoint for Single Todo with Marten (C#)\nDESCRIPTION: Defines a static HTTP GET endpoint at `/todoitems/{id}` to retrieve a single `Todo` item by its ID. It uses route parameter binding to get the `id`, injects Marten's `IQuerySession` and a `CancellationToken`, and loads the `Todo` asynchronously. Wolverine automatically handles returning the `Todo` object (200 OK) or a 404 Not Found if the `Todo` is not found, based on the nullable `Task<Todo?>` return type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n// Wolverine can infer the 200/404 status codes for you here\n// so there's no code noise just to satisfy OpenAPI tooling\n[WolverineGet(\"/todoitems/{id}\")]\npublic static Task<Todo?> GetTodo(int id, IQuerySession session, CancellationToken cancellation)\n    => session.LoadAsync<Todo>(id, cancellation);\n```\n\n----------------------------------------\n\nTITLE: Handling Optional Entities with [Entity(Required = false)] in C#\nDESCRIPTION: This C# snippet shows a Wolverine HTTP endpoint/handler method that uses `[Entity(Required = false)]` to load a `Todo2` entity. Because `Required` is set to `false`, Wolverine will not error if the entity corresponding to the ID in the `MaybeCompleteTodo` command is not found. The method checks if `todo` is null; if it is, it returns `Storage.Nothing<Todo2>()`, indicating no persistence action. Otherwise, it marks the found `todo` as complete and returns `Storage.Update(todo)`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/persistence.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n[WolverinePost(\"/api/todo/maybecomplete\")]\npublic static IStorageAction<Todo2> Handle(MaybeCompleteTodo command, [Entity(Required = false)] Todo2? todo)\n{\n    if (todo == null) return Storage.Nothing<Todo2>();\n    todo.IsComplete = true;\n    return Storage.Update(todo);\n}\n```\n\n----------------------------------------\n\nTITLE: Using MessagePack on Selected Endpoints in Wolverine (C#)\nDESCRIPTION: Demonstrates configuring individual endpoints or queues in Wolverine to use MessagePack serialization selectively instead of the global setting. Requires WolverineFx.MessagePack and properly initialized endpoints via the WolverineOptions object. This approach allows fine-grained control over which endpoints use MessagePack serialization.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Use MessagePack on a local queue\n        opts.LocalQueue(\"one\").UseMessagePackSerialization();\n\n        // Use MessagePack on a listening endpoint\n        opts.ListenAtPort(2223).UseMessagePackSerialization();\n\n        // Use MessagePack on one subscriber\n        opts.PublishAllMessages().ToPort(2222).UseMessagePackSerialization();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Invoking Tenant-Specific Commands with Wolverine Message Bus in C#\nDESCRIPTION: Shows two ways to handle delete operations in a multi-tenant system: (1) Explicit tenant invocation using `bus.InvokeForTenantAsync`, and (2) Utilizing automatic multi-tenancy resolution via `IDocumentSession` and Wolverine HTTP policy. Both require Marten and Wolverine integration and assume the existence of a `DeleteTodo` command and a `Todo` document class. Inputs are tenant name, command object, and optionally a message bus; output is the deletion of the specified document for the correct tenant.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/multi-tenancy.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// While this is still valid....\n[WolverineDelete(\"/todoitems/{tenant}/longhand\")]\npublic static async Task Delete(\n    string tenant,\n    DeleteTodo command,\n    IMessageBus bus)\n{\n    // Invoke inline for the specified tenant\n    await bus.InvokeForTenantAsync(tenant, command);\n}\n\n// Wolverine.HTTP 1.7 added multi-tenancy support so\n// this short hand works without the extra jump through\n// \"Wolverine as Mediator\"\n[WolverineDelete(\"/todoitems/{tenant}\")]\npublic static void Delete(\n    DeleteTodo command, IDocumentSession session)\n{\n    // Just mark this document as deleted,\n    // and Wolverine middleware takes care of the rest\n    // including the multi-tenancy detection now\n    session.Delete<Todo>(command.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Processing an Item Ready Command via MVC Controller with Outbox - C#\nDESCRIPTION: This snippet demonstrates an ASP.NET MVC controller method that processes a MarkItemReady command for an order using Marten's event sourcing and Wolverine's outbox message publishing in C#. The method handles session enrollment, concurrency-checked aggregate fetching, event appending, crude validation, conditional outbox publishing, and transactional persistence. Required dependencies are IDocumentSession, IMartenOutbox, and Marten's event store, and the method expects the command, item data, and aggregate to interact with. Outputs are transactional database changes and outbox message dispatch, with limitations tied to outbox enrollment and simple validation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[HttpPost(\"/orders/itemready\")]\npublic async Task Post(\n    [FromBody] MarkItemReady command,\n    [FromServices] IDocumentSession session,\n    [FromServices] IMartenOutbox outbox\n)\n{\n    // This is important!\n    outbox.Enroll(session);\n\n    // Fetch the current value of the Order aggregate\n    var stream = await session\n        .Events\n\n        // We're also opting into Marten optimistic concurrency checks here\n        .FetchForWriting<Order>(command.OrderId, command.Version);\n\n    var order = stream.Aggregate;\n\n    if (order.Items.TryGetValue(command.ItemName, out var item))\n    {\n        item.Ready = true;\n\n        // Mark that the this item is ready\n        stream.AppendOne(new ItemReady(command.ItemName));\n    }\n    else\n    {\n        // Some crude validation\n        throw new InvalidOperationException($\"Item {command.ItemName} does not exist in this order\");\n    }\n\n    // If the order is ready to ship, also emit an OrderReady event\n    if (order.IsReadyToShip())\n    {\n        // Publish a cascading command to do whatever it takes\n        // to actually ship the order\n        // Note that because the context here is enrolled in a Wolverine\n        // outbox, the message is registered, but not \"released\" to\n        // be sent out until SaveChangesAsync() is called down below\n        await outbox.PublishAsync(new ShipOrder(command.OrderId));\n        stream.AppendOne(new OrderReady());\n    }\n\n    // This will also persist and flush out any outgoing messages\n    // registered into the context outbox\n    await session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Batch Message Processing in Wolverine with C#\nDESCRIPTION: Shows how to configure Wolverine to batch Item messages, specifying key batching parameters such as maximum batch size, the execution queue, and batch trigger timing. Uses .NET's generic Host and Wolverine's fluent API to set these options. The 'BatchSize', 'LocalExecutionQueueName', and 'TriggerTime' control the batching behavior; '.Sequential()' further tunes queue processing. Requires Wolverine NuGet package and integration into a .NET host.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/batching.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ntheHost = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.BatchMessagesOf<Item>(batching =>\n        {\n            // Really the maximum batch size\n            batching.BatchSize = 500;\n            \n            // You can alternatively override the local queue\n            // for the batch publishing. \n            batching.LocalExecutionQueueName = \"items\";\n\n            // We can tell Wolverine to wait longer for incoming\n            // messages before kicking out a batch if there\n            // are fewer waiting messages than the maximum\n            // batch size\n            batching.TriggerTime = 1.Seconds();\n            \n        })\n            \n            // The object returned here is the local queue configuration that\n            // will handle the batched messages. This may be useful for fine\n            // tuning the behavior of the batch processing\n            .Sequential();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Wolverine Message Handler Output with Extension Methods in C#\nDESCRIPTION: This C# snippet demonstrates an xUnit (`[Fact]`) test case for the `AccountHandler.Handle` method. It sets up initial data, mocks the `IDocumentSession` dependency using NSubstitute, executes the handler, and then uses Wolverine's testing extension methods (`ShouldHaveMessageOfType`, `ShouldHaveNoMessageOfType`) on the resulting message collection. These assertions verify that the correct types of messages are returned, check specific properties on those messages, inspect delivery options (like `ScheduleDelay`), and ensure that unexpected message types are absent.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic void handle_a_debit_that_makes_the_account_have_a_low_balance()\n{\n    var account = new Account\n    {\n        Balance = 1000,\n        MinimumThreshold = 200,\n        Id = 1111\n    };\n\n    // Let's otherwise ignore this for now, but this is using NSubstitute\n    var session = Substitute.For<IDocumentSession>();\n\n    var message = new DebitAccount(account.Id, 801);\n    var messages = AccountHandler.Handle(message, account, session).ToList();\n\n    // Now, verify that the only the expected messages are published:\n\n    // One message of type AccountUpdated\n    messages\n        .ShouldHaveMessageOfType<AccountUpdated>()\n        .AccountId.ShouldBe(account.Id);\n\n    // You can optionally assert against DeliveryOptions\n    messages\n        .ShouldHaveMessageOfType<LowBalanceDetected>(delivery =>\n        {\n            delivery.ScheduleDelay.Value.ShouldNotBe(TimeSpan.Zero);\n        })\n        .AccountId.ShouldBe(account.Id);\n\n    // Assert that there are no messages of type AccountOverdrawn\n    messages.ShouldHaveNoMessageOfType<AccountOverdrawn>();\n}\n```\n\n----------------------------------------\n\nTITLE: Activating Conventional RabbitMQ Routing with Wolverine in C#\nDESCRIPTION: This snippet demonstrates how to enable conventional RabbitMQ routing in a Wolverine-based .NET application using the HostBuilder. By invoking UseConventionalRouting() on the RabbitMQ configuration, all declared RabbitMQ objects become durable and message routing for handlers and outgoing messages follows Wolverine conventions. Dependencies include the Wolverine and Host libraries. No explicit queue or exchange naming is required; conventions will be used automatically. The host is started asynchronously.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/conventional-routing.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq()\n            // Opt into conventional Rabbit MQ routing\n            .UseConventionalRouting();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Minimal API Endpoints with Optimized Wolverine Integration (C#)\nDESCRIPTION: Shows how to use extension methods from Wolverine.Http to directly map HTTP routes to Wolverine message handlers in an ASP.Net Core Minimal API setup. This approach bypasses some service location overhead by calling optimized MapPostToWolverine, MapPutToWolverine, and MapDeleteToWolverine methods for both command and request/response handlers. Dependencies include ASP.Net Core and Wolverine.Http. Inputs are HTTP messages (HttpMessage1, HttpMessage2, HttpMessage3, CustomRequest), outputs are optional response types (e.g., CustomResponse). Useful for high-performance HTTP endpoint integration with messaging workflows.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/mediator.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Functional equivalent to MapPost(pattern, (command, IMessageBus) => bus.Invoke(command))\napp.MapPostToWolverine<HttpMessage1>(\"/wolverine\");\napp.MapPutToWolverine<HttpMessage2>(\"/wolverine\");\napp.MapDeleteToWolverine<HttpMessage3>(\"/wolverine\");\n\n// Functional equivalent to MapPost(pattern, (command, IMessageBus) => bus.Invoke<IResponse>(command))\napp.MapPostToWolverine<CustomRequest, CustomResponse>(\"/wolverine/request\");\napp.MapDeleteToWolverine<CustomRequest, CustomResponse>(\"/wolverine/request\");\napp.MapPutToWolverine<CustomRequest, CustomResponse>(\"/wolverine/request\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Event Subscriptions and Policies in C#\nDESCRIPTION: This snippet configures Wolverine event publishing rules, sets up message queuing, and defines exception handling policies. The configuration is attached to the Host using UseWolverine(). It subscribes to ChartingFinished event messages, assigns them to a durable local queue, specifies retry logic for concurrency and database exceptions, and enables autotransactions when persistence operations are detected. Inputs include builder.Host and options for event types, error policies, and transaction detection. No outputs, but affects runtime message routing and error handling.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-forwarding.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Host.UseWolverine(opts =>\n{\n    // I'm choosing to process any ChartingFinished event messages\n    // in a separate, local queue with persistent messages for the inbox/outbox\n    opts.PublishMessage<ChartingFinished>()\n        .ToLocalQueue(\"charting\")\n        .UseDurableInbox();\n\n    // If we encounter a concurrency exception, just try it immediately\n    // up to 3 times total\n    opts.Policies.OnException<ConcurrencyException>().RetryTimes(3);\n\n    // It's an imperfect world, and sometimes transient connectivity errors\n    // to the database happen\n    opts.Policies.OnException<NpgsqlException>()\n        .RetryWithCooldown(50.Milliseconds(), 100.Milliseconds(), 250.Milliseconds());\n\n    // Automatic usage of transactional middleware as\n    // Wolverine recognizes that an HTTP endpoint or message handler\n    // persists data\n    opts.Policies.AutoApplyTransactions();\n});\n```\n\n----------------------------------------\n\nTITLE: Example Log Format for Message Execution Start\nDESCRIPTION: Provides an example of the log entry format generated when message execution start logging is enabled. It includes a timestamp, log level, the message type, and the message ID.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n[09:41:00 INF] Starting to process <MessageType> (<MessageId>)\n```\n\n----------------------------------------\n\nTITLE: Implementing ISideEffect for File Writing (C#)\nDESCRIPTION: Demonstrates defining a C# class `WriteFile` that implements the `Wolverine.ISideEffect` marker interface. The `ExecuteAsync` method, which Wolverine invokes, handles the file writing logic, including checking/creating the directory and accepting injected dependencies like `PathSettings`. This approach formally declares the type as a Wolverine side effect.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/side-effects.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n// ISideEffect is a Wolverine marker interface\npublic class WriteFile : ISideEffect\n{\n    public string Path { get; }\n    public string Contents { get; }\n\n    public WriteFile(string path, string contents)\n    {\n        Path = path;\n        Contents = contents;\n    }\n\n    // Wolverine will call this method.\n    public Task ExecuteAsync(PathSettings settings)\n    {\n        if (!Directory.Exists(settings.Directory))\n        {\n            Directory.CreateDirectory(settings.Directory);\n        }\n\n        return File.WriteAllTextAsync(Path, Contents);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Routing Messages to a Specific Wolverine Local Queue in C#\nDESCRIPTION: This snippet shows how to configure Wolverine to publish messages of a specific type (Message2) directly to a named local queue ('important'). This is achieved using 'opts.PublishMessage<Message2>().ToLocalQueue(\"important\")' within the UseWolverine configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Publish Message2 messages to the \"important\"\n        // local queue\n        opts.PublishMessage<Message2>()\n            .ToLocalQueue(\"important\");\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Wolverine with RavenDb Persistence (.NET C#)\nDESCRIPTION: This C# snippet configures a Wolverine-based application to use RavenDb for message persistence. It requires references to RavenDB.DependencyInjection and WolverineFx.RavenDb packages. The example shows configuring the document store, enabling RavenDb-backed persistence, and applying transaction policies in Wolverine. The builder pattern is used for .NET hosting, and configuration details for RavenDb connection should be provided inside the lambda.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/ravendb.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n\n// You'll need a reference to RavenDB.DependencyInjection\n// for this one\nbuilder.Services.AddRavenDbDocStore(raven =>\n{\n    // configure your RavenDb connection here\n});\n\nbuilder.UseWolverine(opts =>\n{\n    // That's it, nothing more to see here\n    opts.UseRavenDbPersistence();\n    \n    // The RavenDb integration supports basic transactional\n    // middleware just fine\n    opts.Policies.AutoApplyTransactions();\n});\n\n// continue with your bootstrapping...\n```\n\n----------------------------------------\n\nTITLE: Configuring Mediator-Only Mode with Wolverine in C#\nDESCRIPTION: This snippet shows how to set up a .NET host with Wolverine configured strictly for mediator usage by disabling background message durability and asynchronous messaging features. The code uses 'Host.CreateDefaultBuilder' and the '.UseWolverine' extension with lambda configuration, setting 'opts.Durability.Mode' to 'DurabilityMode.MediatorOnly'. This requires the Wolverine library and any referenced durability modes, and is intended for .NET applications where only synchronous in-memory message mediation is required, without persistent queues or background workers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/mediator.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Other configuration...\n        \n        // But wait! Optimize Wolverine for usage as *only*\n        // a mediator\n        opts.Durability.Mode = DurabilityMode.MediatorOnly;\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Marking Assembly for Handler Discovery with WolverineModule Attribute in C#\nDESCRIPTION: This snippet shows how to mark an assembly for handler discovery in Wolverine by applying the [WolverineModule] attribute at the assembly level. To use, add the using Wolverine.Attributes; directive and the [assembly: WolverineModule] declaration at the top of the file in any assembly that should be scanned for handlers. This is an alternative to programmatically registering assemblies and requires the 'Wolverine.Attributes' namespace. No runtime inputs or outputs; it affects compile-time assembly scanning in Wolverine.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/discovery.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing Wolverine.Attributes;\n\n[assembly: WolverineModule]\n```\n\n----------------------------------------\n\nTITLE: Registering EF Core Middleware and SQL Server Persistence in Wolverine (C#)\nDESCRIPTION: Demonstrates configuring Wolverine within a .NET host builder (`builder.Host`) to use SQL Server for message persistence (`PersistMessagesWithSqlServer`) and enabling Entity Framework Core for transactional middleware (`UseEntityFrameworkCoreTransactions`). It also enrolls local queues in durable processing (`UseDurableLocalQueues`). Requires `WolverineFx.EntityFrameworkCore` and `Wolverine.SqlServer` NuGet packages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/efcore.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nbuilder.Host.UseWolverine(opts =>\n{\n    // Setting up Sql Server-backed message storage\n    // This requires a reference to Wolverine.SqlServer\n    opts.PersistMessagesWithSqlServer(connectionString, \"wolverine\");\n\n    // Set up Entity Framework Core as the support\n    // for Wolverine's transactional middleware\n    opts.UseEntityFrameworkCoreTransactions();\n\n    // Enrolling all local queues into the\n    // durable inbox/outbox processing\n    opts.Policies.UseDurableLocalQueues();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Exponential Backoff Retries in Wolverine C#\nDESCRIPTION: This snippet shows how to configure Wolverine to retry message handling upon encountering a `SqlException` using an exponential backoff strategy. It specifies a sequence of cooldown periods (50ms, 100ms, 250ms) before subsequent retry attempts. If all retries fail, the message is moved to the dead letter queue.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Retry the message again, but wait for the specified time\n        // The message will be dead lettered if it exhausts the delay\n        // attempts\n        opts\n            .OnException<SqlException>()\n            .RetryWithCooldown(50.Milliseconds(), 100.Milliseconds(), 250.Milliseconds());\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Setting Inline RabbitMQ Endpoints with Wolverine in C#\nDESCRIPTION: This snippet shows how to configure Wolverine to use RabbitMQ endpoints in Inline mode for serverless function scenarios, ensuring messages are immediately sent rather than queued for background processing. It utilizes the UseRabbitMq and PublishAllMessages methods, with the key setting SendInline to disable durability and maximize cold start responsiveness. Dependencies include the Wolverine and RabbitMQ libraries, and key parameters are the Rabbit queue name and SendInline; outputs are immediate message sends suitable for stateless execution, with the constraint that no message persistence or retry capability is provided.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/serverless.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n.UseWolverine(opts =>\n{\n    opts.UseRabbitMq().AutoProvision().AutoPurgeOnStartup();\n    opts\n        .PublishAllMessages()\n        .ToRabbitQueue(queueName)\n\n        // This option is important inside of Serverless functions\n        .SendInline();\n})\n```\n\n----------------------------------------\n\nTITLE: Applying Wolverine Middleware via Policy (C#)\nDESCRIPTION: This C# snippet demonstrates how to register and apply custom middleware (`StopwatchMiddleware`) to Wolverine message handlers during application startup using `Host.CreateDefaultBuilder` and `UseWolverine`. It uses `opts.Policies.AddMiddleware<T>` to add the middleware and includes an optional lambda expression (`chain => ...`) to filter its application, in this case, only applying it to messages within the specified namespace `MyApp.Messages.Important`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Apply our new middleware to message handlers, but optionally\n        // filter it to only messages from a certain namespace\n        opts.Policies\n            .AddMiddleware<StopwatchMiddleware>(chain =>\n                chain.MessageType.IsInNamespace(\"MyApp.Messages.Important\"));\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Mapping HTTP Requests to Publish Wolverine Messages (C#)\nDESCRIPTION: This snippet demonstrates configuring Wolverine to map incoming HTTP requests to message types and publish them. Similar to `SendMessage`, it uses `app.MapWolverineEndpoints` but employs the `opts.PublishMessage<T>()` method. Publishing differs from sending as it only dispatches the message if there are active subscribers for that message type. The endpoint returns a 202 Accepted status code. It also allows for additional configuration like security metadata.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/messaging.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = WebApplication.CreateBuilder();\n\nbuilder.Host.UseWolverine();\n\nvar app = builder.Build();\n\napp.MapWolverineEndpoints(opts =>\n{\n    opts.PublishMessage<CreateOrder>(\"/orders/create\", chain =>\n    {\n        // You can make any necessary metadata configurations exactly\n        // as you would for Minimal API endpoints with this syntax\n        // to fine tune OpenAPI generation or security\n        chain.Metadata.RequireAuthorization();\n    });\n    opts.PublishMessage<ShipOrder>(HttpMethod.Put, \"/orders/ship\");\n});\n\n// and the rest of your application configuration and bootstrapping\n```\n\n----------------------------------------\n\nTITLE: Building a Batch Message Handler for SubTaskCompletedBatch in Wolverine (C#)\nDESCRIPTION: This static C# class provides handler methods for the SubTaskCompletedBatch message type, enabling batch processing via the Wolverine framework. The LoadAsync method fetches a TrackedTask from the ITrackedTaskRepository based on the batch's TaskId, while the Handle method is a stub that executes batch processing logic (currently a no-op). Both methods require the SubTaskCompletedBatch message and may utilize dependency injection for repository access. Handlers like these are mandatory for Wolverine's message processing pipeline when introducing custom batch messages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/batching.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic static class SubTaskCompletedBatchHandler\n{\n    public static Task<TrackedTask> LoadAsync(SubTaskCompletedBatch batch, ITrackedTaskRepository repository)\n    {\n        return repository.LoadAsync(batch.TaskId);\n    }\n\n    public static Task Handle(SubTaskCompletedBatch batch)\n    {\n        // actually do something here....\n\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Dead Letter Queue Expiration in Wolverine (C#)\nDESCRIPTION: Configures Wolverine's durability settings within the application's host builder to automatically expire and purge old messages from the dead letter queue database table. This involves setting `DeadLetterQueueExpirationEnabled` to true and optionally configuring the `DeadLetterQueueExpiration` retention period (default is 10 days).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/dead-letter-storage.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n\n        // This is required\n        opts.Durability.DeadLetterQueueExpirationEnabled = true;\n\n        // Default is 10 days. This is the retention period\n        opts.Durability.DeadLetterQueueExpiration = 3.Days();\n\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Querying a Marten Document via Explicit Session in Wolverine.HTTP - C#\nDESCRIPTION: This C# code demonstrates defining a Wolverine HTTP GET endpoint to resolve an Invoice document by its id from the Marten session. The route argument 'id' is used for lookup, and the endpoint returns HTTP 404 if not found or HTTP 200 with the object. It relies on IQuerySession, proper cancellation handling, and the presence of OpenAPI/Swagger attributes for describing the API response schema.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n{\n    [WolverineGet(\"/invoices/longhand/{id}\")]\n    [ProducesResponseType(404)]\n    [ProducesResponseType(200, Type = typeof(Invoice))]\n    public static async Task<IResult> GetInvoice(\n        Guid id,\n        IQuerySession session,\n        CancellationToken cancellationToken)\n    {\n        var invoice = await session.LoadAsync<Invoice>(id, cancellationToken);\n        if (invoice == null) return Results.NotFound();\n\n        return Results.Ok(invoice);\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Querying a Marten Document with [Document] Attribute in Wolverine.HTTP - C#\nDESCRIPTION: This snippet presents a simplified Wolverine HTTP GET endpoint that automatically binds an Invoice document parameter using the [Document] attribute. It leverages route parameter inference for loading the document by id, removing the need for explicit session-based queries and manual OpenAPI annotations. The endpoint returns the Invoice or HTTP 404 if it is missing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverineGet(\"/invoices/{id}\")]\npublic static Invoice Get([Document] Invoice invoice)\n{\n    return invoice;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Message Timeout Using Wolverine - C#\nDESCRIPTION: This snippet demonstrates how to configure the default message execution timeout for a Wolverine-based .NET application during host bootstrapping. It sets the DefaultExecutionTimeout option to 1 minute using the Minutes() extension method. Required dependencies include Wolverine and support for asynchronous host startup. The expected input is a configuration lambda, and successful configuration will enforce a global timeout for all message processing unless otherwise specified.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/timeout.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts => { opts.DefaultExecutionTimeout = 1.Minutes(); }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Wolverine Endpoint with ProblemDetails Validation (C#)\nDESCRIPTION: Defines a Wolverine HTTP endpoint class `ProblemDetailsUsageEndpoint`. It includes a `Before` middleware method that validates the incoming `NumberMessage`. If the number is greater than 5, it returns a `ProblemDetails` object with status 400. Otherwise, it returns `WolverineContinue.NoProblems` to allow processing to continue to the `Post` handler. Requires Wolverine.Http.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/problemdetails.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic class ProblemDetailsUsageEndpoint\n{\n    public ProblemDetails Before(NumberMessage message)\n    {\n        // If the number is greater than 5, fail with a\n        // validation message\n        if (message.Number > 5)\n            return new ProblemDetails\n            {\n                Detail = \"Number is bigger than 5\",\n                Status = 400\n            };\n\n        // All good, keep on going!\n        return WolverineContinue.NoProblems;\n    }\n\n    [WolverinePost(\"/problems\")]\n    public static string Post(NumberMessage message)\n    {\n        return \"Ok\";\n    }\n}\n\npublic record NumberMessage(int Number);\n```\n\n----------------------------------------\n\nTITLE: Creating a Handler Returning a Custom Side Effect (C#)\nDESCRIPTION: Defines necessary components for a message handling scenario: `PathSettings` for configuration, `RecordText` as the message type, and `RecordTextHandler`. The `Handle` method processes the `RecordText` message and returns a `WriteFile` object (the custom side effect), delegating the actual file writing to Wolverine's side effect mechanism.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/side-effects.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n// An options class\npublic class PathSettings\n{\n    public string Directory { get; set; }\n        = Environment.CurrentDirectory.AppendPath(\"files\");\n}\n\npublic record RecordText(Guid Id, string Text);\n\npublic class RecordTextHandler\n{\n    // Notice that the concrete WriteFile is the return type in the method signature\n    // and not the ISideEffect interface\n    public WriteFile Handle(RecordText command)\n    {\n        return new WriteFile(command.Id + \".txt\", command.Text);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten Identity Map for Aggregate Performance in C#\nDESCRIPTION: Shows how to enable Marten's `UseIdentityMapForAggregates` option within the `AddMarten` configuration when integrating with Wolverine. This setting optimizes the aggregate handler workflow, especially when using `UpdatedAggregate` to return the latest state, by minimizing database round trips through identity mapping. It depends on the Marten library and its Wolverine integration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddMarten(opts =>\n{\n    // Other Marten configuration\n\n    // Use this setting to get the very best performance out\n    // of the UpdatedAggregate workflow and aggregate handler\n    // workflow over all\n    opts.Events.UseIdentityMapForAggregates = true;\n}).IntegrateWithWolverine();\n```\n\n----------------------------------------\n\nTITLE: Setting Wolverine Message Identity to Id and Destination in C#\nDESCRIPTION: This snippet shows how to configure Wolverine's message persistence to identify messages using a combination of their ID and destination endpoint. This is achieved by setting `opts.Durability.MessageIdentity = MessageIdentity.IdAndDestination`. This setting is particularly useful in modular monolith architectures where the same message might be delivered multiple times to the same application but intended for different internal handlers, preventing them from being incorrectly flagged as duplicates.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/index.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.PersistMessagesWithSqlServer(Servers.SqlServerConnectionString, \"receiver2\");\n        \n        // This setting changes the internal message storage identity\n        opts.Durability.MessageIdentity = MessageIdentity.IdAndDestination;\n    })\n    .StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Swashbuckle IOperationFilter for Wolverine Operation IDs - C#\nDESCRIPTION: This snippet defines a custom IOperationFilter implementation for Swashbuckle to adjust the OpenAPI operation ID using information from Wolverine's HttpChain model. It inspects the context's action descriptor, and if it is a WolverineActionDescriptor, sets the OpenAPI operation ID to the appropriate value. Meant for integration into Swashbuckle via AddSwaggerGen in ASP.NET Core projects using Wolverine. Requires Swashbuckle.AspNetCore, proper use of the IOperationFilter interface, and access to Wolverine-internal descriptors.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/metadata.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// This class is NOT distributed in any kind of Nuget today, but feel very free\n// to copy this code into your own as it is at least tested through Wolverine's\n// CI test suite\npublic class WolverineOperationFilter : IOperationFilter // IOperationFilter is from Swashbuckle itself\n{\n    public void Apply(OpenApiOperation operation, OperationFilterContext context)\n    {\n        if (context.ApiDescription.ActionDescriptor is WolverineActionDescriptor action)\n        {\n            operation.OperationId = action.Chain.OperationId;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Wolverine Message Class in C#\nDESCRIPTION: This snippet defines a simple C# class named `PersonBorn` intended to be used as a message within the Wolverine framework. It demonstrates that messages are plain C# objects without requiring specific base classes or interfaces. The class contains properties related to a person's birth details.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PersonBorn\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n\n    // This is obviously a contrived example\n    // so just let this go for now;)\n    public int Day { get; set; }\n    public int Month { get; set; }\n    public int Year { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Endpoint With Inline FluentValidation in Wolverine - C#\nDESCRIPTION: Demonstrates the pattern for defining a record request object and its FluentValidation validator nested class, and exposing a Wolverine HTTP endpoint method. Dependencies: FluentValidation, Wolverine.Http, and an IoC container to register the validator. The sample endpoint takes a CreateCustomer request as input and returns a confirmation string. The validator ensures each field is not null; failures are managed via Wolverine's middleware. This snippet is intended for use in Wolverine HTTP services.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/from-mediatr.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\npublic record CreateCustomer\n(\n    string FirstName,\n    string LastName,\n    string PostalCode\n)\n{\n    public class CreateCustomerValidator : AbstractValidator<CreateCustomer>\n    {\n        public CreateCustomerValidator()\n        {\n            RuleFor(x => x.FirstName).NotNull();\n            RuleFor(x => x.LastName).NotNull();\n            RuleFor(x => x.PostalCode).NotNull();\n        }\n    }\n}\n\npublic static class CreateCustomerEndpoint\n{\n    [WolverinePost(\"/validate/customer\")]\n    public static string Post(CreateCustomer customer)\n    {\n        return \"Got a new customer\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Wolverine with Fluent Validation Middleware in C#\nDESCRIPTION: This snippet demonstrates how to configure Wolverine during application bootstrapping to use the Fluent Validation middleware. It shows two ways: `opts.UseFluentValidation()` enables the middleware and automatically discovers/registers validators from the assembly. Alternatively, `opts.UseFluentValidation(RegistrationBehavior.ExplicitRegistration)` enables the middleware but requires manual registration of validators in the DI container. It also includes registration of a prerequisite service `IDataService`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/fluent-validation.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Apply the validation middleware *and* discover and register\n        // Fluent Validation validators\n        opts.UseFluentValidation();\n\n        // Or if you'd prefer to deal with all the DI registrations yourself\n        opts.UseFluentValidation(RegistrationBehavior.ExplicitRegistration);\n\n        // Just a prerequisite for some of the test validators\n        opts.Services.AddSingleton<IDataService, DataService>();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Wolverine IChainPolicy for WriteFile Return Type (C#)\nDESCRIPTION: This C# snippet shows the implementation of `WriteFilePolicy`, which adheres to Wolverine's `IChainPolicy` interface. The `Apply` method iterates through all handler chains, finds return variables of type `WriteFile`, and uses `UseReturnAction` to configure Wolverine to generate code that calls the `WriteAsync` method on each `WriteFile` instance returned by a handler. This customizes the default behavior for this specific return type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/return-values.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\ninternal class WriteFilePolicy : IChainPolicy\n{\n    // IChain is a Wolverine model to configure the code generation of\n    // a message or HTTP handler and the core model for the application\n    // of middleware\n    public void Apply(IReadOnlyList<IChain> chains, GenerationRules rules, IServiceContainer container)\n    {\n        var method = ReflectionHelper.GetMethod<WriteFile>(x => x.WriteAsync());\n\n        // Check out every message and/or http handler:\n        foreach (var chain in chains)\n        {\n            var writeFiles = chain.ReturnVariablesOfType<WriteFile>();\n            foreach (var writeFile in writeFiles)\n            {\n                // This is telling Wolverine to handle any return value\n                // of WriteFile by calling its WriteAsync() method\n                writeFile.UseReturnAction(_ =>\n                {\n                    // This is important, return a separate MethodCall\n                    // object for each individual WriteFile variable\n                    return new MethodCall(typeof(WriteFile), method!)\n                    {\n                        Target = writeFile\n                    };\n                });\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Message Locally with IMessageBus (C#)\nDESCRIPTION: Shows how to invoke a message for inline processing using IMessageBus's InvokeAsync method in Wolverine. Requires an implementation of IMessageBus and a message type (e.g., Message1) with a corresponding local handler. Illustrates immediate synchronous-like message handling, leveraging error-handling and retry logic attached to handlers. The method returns when the handling completes or an error occurs.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task invoke_locally(IMessageBus bus)\\n{\\n    // Execute the message inline\\n    await bus.InvokeAsync(new Message1());\\n}\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Rabbit MQ Transport via Wolverine in C#\nDESCRIPTION: This snippet demonstrates setting up a .NET Generic Host with the Wolverine framework to handle messaging through Rabbit MQ. It configures separate queues for sending ('pings') and receiving ('pongs'), connects using a named connection, auto-provisions broker resources, and ensures services for continuous message sending and resource setup are registered. Dependencies include the WolverineFX.RabbitMQ NuGet package, the Rabbit MQ .NET Client, and optionally Aspire for connection management. Input parameters include the application's command-line args and optionally a connection string named 'rabbit'. The host is created and Oakton commands are run as part of the bootstrapping process.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nreturn await Host.CreateDefaultBuilder(args)\n    .UseWolverine(opts =>\n    {\n        // Listen for messages coming into the pongs queue\n        opts\n            .ListenToRabbitQueue(\"pongs\");\n\n        // Publish messages to the pings queue\n        opts.PublishMessage<PingMessage>().ToRabbitExchange(\"pings\");\n\n        // Configure Rabbit MQ connection to the connection string\n        // named \"rabbit\" from IConfiguration. This is *a* way to use\n        // Wolverine + Rabbit MQ using Aspire\n        opts.UseRabbitMqUsingNamedConnection(\"rabbit\")\n            // Directs Wolverine to build any declared queues, exchanges, or\n            // bindings with the Rabbit MQ broker as part of bootstrapping time\n            .AutoProvision();\n\n        // Or you can use this functionality to set up *all* known\n        // Wolverine (or Marten) related resources on application startup\n        opts.Services.AddResourceSetupOnStartup();\n\n        // This will send ping messages on a continuous\n        // loop\n        opts.Services.AddHostedService<PingerService>();\n    }).RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Cascading Messages via Tuple Return Values from Wolverine HTTP Endpoint (C#)\nDESCRIPTION: Shows an alternative method for cascading messages from a Wolverine HTTP endpoint by returning them directly as elements in a tuple. The `[WolverinePost]` endpoint method's signature explicitly defines the message types being returned (`(HttpMessage1, HttpMessage2)`). The method returns instances of these messages wrapped in a tuple. Wolverine publishes these messages upon success. The `[EmptyResponse]` attribute ensures a 204 No Content status code is returned.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/messaging.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n// This would have an empty response and a 204 status code\n[EmptyResponse]\n[WolverinePost(\"/spawn2\")]\npublic static (HttpMessage1, HttpMessage2) Post()\n{\n    return new(new HttpMessage1(\"foo\"), new HttpMessage2(\"bar\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Organization Tagging Middleware in Wolverine Message Handlers (.NET)\nDESCRIPTION: This snippet shows how to register and apply the OrganizationTaggingMiddleware to all handlers processing messages that implement the `IOrganizationRelated` interface in a Wolverine-hosted application. It uses the builder's policy configuration to ensure this middleware executes automatically for applicable message types. Assumes that middleware and interface are defined per previous snippets and that the host is set up with Wolverine. There are no explicit inputs or outputs; effect is the automatic tagging of processed messages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Add this middleware to all handlers where the message can be cast to\n        // IOrganizationRelated\n        opts.Policies.ForMessagesOfType<IOrganizationRelated>().AddMiddleware(typeof(OrganizationTaggingMiddleware));\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Pausing Listener on System Unavailability in Wolverine C#\nDESCRIPTION: This code configures Wolverine to handle a `SystemIsCompletelyUnusableException` by first requeuing the failed message for later processing and then pausing the message listener associated with that endpoint for 10 minutes. This prevents further processing attempts when a critical downstream system is known to be unavailable.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // The failing message is requeued for later processing, then\n        // the specific listener is paused for 10 minutes\n        opts.OnException<SystemIsCompletelyUnusableException>()\n            .Requeue().AndPauseProcessing(10.Minutes());\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Appending Multiple Marten Events from Wolverine HTTP Endpoint in C#\nDESCRIPTION: Implements a Wolverine HTTP POST endpoint marked with `[AggregateHandler]` and `[WolverinePost]`. The `Post` method handles a `MarkItemReady` command for a given `Order` aggregate. It conditionally creates an `ItemReady` event and potentially an `OrderReady` event, adding them to an `Events` collection. The endpoint returns a tuple containing an `OrderStatus` object (for the HTTP response) and the `Events` collection (to be appended to the Marten stream).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[AggregateHandler]\n[WolverinePost(\"/orders/itemready\")]\npublic static (OrderStatus, Events) Post(MarkItemReady command, Order order)\n{\n    var events = new Events();\n\n    if (order.Items.TryGetValue(command.ItemName, out var item))\n    {\n        item.Ready = true;\n\n        // Mark that the this item is ready\n        events += new ItemReady(command.ItemName);\n    }\n    else\n    {\n        // Some crude validation\n        throw new InvalidOperationException($\"Item {command.ItemName} does not exist in this order\");\n    }\n\n    // If the order is ready to ship, also emit an OrderReady event\n    if (order.IsReadyToShip())\n    {\n        events += new OrderReady();\n    }\n\n    return (new OrderStatus(order.Id, order.IsReadyToShip()), events);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring System.Text.Json for Wolverine Endpoints (C#)\nDESCRIPTION: This snippet shows how to apply custom System.Text.Json serializer settings in a Minimal API app using the Wolverine extension method ConfigureSystemTextJsonForWolverineOrMinimalApi. Dependencies include ASP.NET Core, Microsoft.Extensions.Options, and Wolverine. It demonstrates configuring JSON options (like WriteIndented), registering necessary services, and mapping Wolverine endpoints. Accepts a configuration delegate to adjust serializer options. The resulting application will use the specified settings for its JSON serialization.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/json.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder();\n\nbuilder.Host.UseWolverine();\n\nbuilder.Services.ConfigureSystemTextJsonForWolverineOrMinimalApi(o =>\n{\n    // Do whatever you want here to customize the JSON\n    // serialization\n    o.SerializerOptions.WriteIndented = true;\n});\n\nvar app = builder.Build();\n\napp.MapWolverineEndpoints();\n\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Declaring the CreateIssue Command Record - C#\nDESCRIPTION: Defines a C# record named 'CreateIssue' carrying data to create a new issue: originator ID, title, and description. This record acts as a command DTO for API endpoints and handler methods. It requires .NET 5 or greater and is used as a structured payload for issue creation, expecting to be mapped from request data.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/getting-started.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic record CreateIssue(Guid OriginatorId, string Title, string Description);\n```\n\n----------------------------------------\n\nTITLE: Customizing Outgoing Message Delivery Options with DeliveryOptions (Wolverine/.NET/C#)\nDESCRIPTION: Illustrates how to publish messages with customized DeliveryOptions, including request for acknowledgment, explicit content type, expiration, scheduling (delay and absolute), and type of expected response. Dependencies: Wolverine, IMessageBus, DeliveryOptions, Message1/Message2 types. The method demonstrates fluent chaining of WithHeader. Inputs: IMessageBus instance. Outputs: scheduled and customized message publishing; side effects depend on endpoint configuration. Requires proper type setup for messages and matching options; some header values are arbitrary.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task SendMessagesWithDeliveryOptions(IMessageBus bus)\n{\n    await bus.PublishAsync(new Message1(), new DeliveryOptions\n        {\n            AckRequested = true,\n            ContentType = \"text/xml\", // you can do this, but I'm not sure why you'd want to override this\n            DeliverBy = DateTimeOffset.Now.AddHours(1), // set a message expiration date\n            DeliverWithin = 1.Hours(), // convenience method to set the deliver-by expiration date\n            ScheduleDelay = 1.Hours(), // Send this in one hour, or...\n            ScheduledTime = DateTimeOffset.Now.AddHours(1),\n            ResponseType = typeof(Message2) // ask the receiver to send this message back to you if it can\n        }\n        // There's a chained fluent interface for adding header values too\n        .WithHeader(\"tenant\", \"one\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Fluent Validation Failure Action in C#\nDESCRIPTION: This snippet demonstrates how to register the custom failure action (`CustomFailureAction<>`) during Wolverine bootstrapping. After enabling Fluent Validation with `opts.UseFluentValidation()`, it overrides the default `IFailureAction<>` service registration in the DI container using `opts.Services.AddSingleton(typeof(IFailureAction<>), typeof(CustomFailureAction<>))`. This ensures that the custom action is used when validation fails. It also includes registration of a prerequisite service `IDataService`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/fluent-validation.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Apply the validation middleware *and* discover and register\n        // Fluent Validation validators\n        opts.UseFluentValidation();\n\n        // Override the service registration for IFailureAction\n        opts.Services.AddSingleton(typeof(IFailureAction<>), typeof(CustomFailureAction<>));\n        \n        // Just a prerequisite for some of the test validators\n        opts.Services.AddSingleton<IDataService, DataService>();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Specifying the Identity Source with [Entity(\"id\")] in C#\nDESCRIPTION: This C# code defines a Wolverine HTTP GET endpoint. It uses the `[Entity(\"id\")]` attribute to explicitly tell Wolverine to load the `Todo2` entity using the value from the route parameter named `id`. This allows overriding the default behavior of looking for members named `Id` or `Todo2Id` on the input object.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/persistence.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// Okay, I still used \"id\", but it *could* be something different here!\n[WolverineGet(\"/api/todo/{id}\")]\npublic static Todo2 Get([Entity(\"id\")] Todo2 todo) => todo;\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Batched Event Subscription with Marten and Wolverine (C#)\nDESCRIPTION: This snippet shows how to define custom event record types and a batched event subscription by extending the BatchSubscription base class for more advanced event processing strategies. It includes utility logic for tracking company activations and removals, and a custom ProcessEventsAsync implementation to aggregate changes and publish a single activation message. This requires references to Wolverine.Marten, Marten event types, and assumes transactional outbox guarantees; inputs are EventRange batches, and outputs are single aggregated messages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/subscriptions.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic record CompanyActivated(string Name);\n\npublic record CompanyDeactivated();\n\npublic record NewCompany(Guid Id, string Name);\n\n// Message type we're going to publish to external\n// systems to keep them up to date on new companies\npublic class CompanyActivations\n{\n    public List<NewCompany> Additions { get; set; } = new();\n    public List<Guid> Removals { get; set; } = new();\n\n    public void Add(Guid companyId, string name)\n    {\n        Removals.Remove(companyId);\n\n        // Fill is an extension method in JasperFx.Core that adds the\n        // record to a list if the value does not already exist\n        Additions.Fill(new NewCompany(companyId, name));\n    }\n\n    public void Remove(Guid companyId)\n    {\n        Removals.Fill(companyId);\n\n        Additions.RemoveAll(x => x.Id == companyId);\n    }\n}\n\npublic class CompanyTransferSubscription : BatchSubscription\n{\n    public CompanyTransferSubscription() : base(\"CompanyTransfer\")\n    {\n        IncludeType<CompanyActivated>();\n        IncludeType<CompanyDeactivated>();\n    }\n\n    public override async Task ProcessEventsAsync(EventRange page, ISubscriptionController controller, IDocumentOperations operations,\n        IMessageBus bus, CancellationToken cancellationToken)\n    {\n        var activations = new CompanyActivations();\n        foreach (var e in page.Events)\n        {\n            switch (e)\n            {\n                // In all cases, I'm assuming that the Marten stream id is the identifier for a customer\n                case IEvent<CompanyActivated> activated:\n                    activations.Add(activated.StreamId, activated.Data.Name);\n                    break;\n                case IEvent<CompanyDeactivated> deactivated:\n                    activations.Remove(deactivated.StreamId);\n                    break;\n            }\n        }\n\n        // At the end of all of this, publish a single message\n        // In case you're wondering, this will opt into Wolverine's\n        // transactional outbox with the same transaction as any changes\n        // made by Marten's IDocumentOperations passed in, including Marten's\n        // own work to track the progression of this subscription\n        await bus.PublishAsync(activations);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Including External Transports in Tracked Sessions - Wolverine - C#\nDESCRIPTION: Illustrates using the TrackActivity fluent API to extend message activity tracking to include work coming and going from external brokers in Wolverine during integration testing. The snippet utilizes methods such as IncludeExternalTransports, Timeout, and WaitForMessageToBeReceivedAt with a specified message type (here OrderPlaced), enabling robust, reliable testing of asynchronous message flows that may interact with components outside the current process. Inputs are an IHost and a PlaceOrder command, with configuration for timeouts and broker message arrival tracking. Outputs include a tracked session covering all locally and externally routed messages relevant to the test scenario.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/modular-monolith.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task run_end_to_end_with_external_transports(IHost host)\n{\n    var placeOrder = new PlaceOrder(\"111\", \"222\", 1000);\n    \n    // This would be the \"act\" part of your arrange/act/assert\n    // test structure\n    var tracked = await host\n        .TrackActivity()\n        \n        // Direct Wolverine to also track activity coming and going from\n        // external brokers\n        .IncludeExternalTransports()\n        \n        // You'll sadly need to do this sometimes\n        .Timeout(30.Seconds())\n        \n        // You *might* have to do this as well to make\n        // your tests more reliable in the face of async messaging\n        .WaitForMessageToBeReceivedAt<OrderPlaced>(host)\n        \n        .InvokeMessageAndWaitAsync(placeOrder);\n    \n    // proceed to test the outcome of handling the original command *and*\n    // any subsequent domain events that are published from the original\n    // command handler\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Topic-Routed Message with Wolverine (C#)\nDESCRIPTION: This snippet shows how to obtain the Wolverine message bus (`IMessageBus`) from a configured host and send a message (`Message1`). Based on the configuration in the previous snippet, Wolverine will automatically route this message to the 'topics-exchange' using a topic name derived from the message type (`Message1`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/topics.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar publisher = host.MessageBus();\nawait publisher.SendAsync(new Message1());\n```\n\n----------------------------------------\n\nTITLE: Applying Message Timeout Attribute to Handler Method - C#\nDESCRIPTION: This snippet shows the use of the [MessageTimeout] attribute to override the default timeout for a specific message handler in a Wolverine application. By decorating the Handle method with [MessageTimeout(1)], the execution timeout is set to 1 minute (or as interpreted by the attribute's value). The method should accept a CancellationToken parameter for proper cancellation support. Dependencies include the Wolverine framework and attribute support.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/timeout.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[MessageTimeout(1)]\npublic async Task Handle(PotentiallySlowMessage message, CancellationToken cancellationToken)\n```\n\n----------------------------------------\n\nTITLE: Handling CancelOrder Command with Marten and MessageBus (Transaction Script) in C#\nDESCRIPTION: Defines the `CancelOrder` command and `OrderCancelled` event records. Implements an asynchronous `CancelOrderHandler` using the transaction script pattern. It injects Marten's `IDocumentSession` to load and potentially delete the `Order` and Wolverine's `IMessageBus` to publish the `OrderCancelled` event upon successful cancellation. Includes checks for non-existent or already shipped orders.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic record CancelOrder(string OrderId);\n\npublic record OrderCancelled(string OrderId);\n\npublic static class CancelOrderHandler\n{\n    public static async Task Handle(\n        CancelOrder command, \n        IDocumentSession session, // Marten's IDocumentSession\n        IMessageBus messageBus, // Wolverine's IMessageBus\n        CancellationToken token)\n    {\n        // Load the order asynchronously using Marten\n        var order = await session.LoadAsync<Order>(command.OrderId, token);\n        \n        // You should probably log something at the least here\n        if (order == null) return; // Order not found\n        \n        // Assuming Order has a HasShipped property\n        if (order.HasShipped) return; // Cannot cancel shipped order\n        \n        // Maybe it's a soft delete here?\n        session.Delete(order); // Delete the order using Marten\n        \n        // Publish a domain event to let other things in the system know to\n        // take actions to stop shipping, inventory, who knows what\n        await messageBus.PublishAsync(new OrderCancelled(command.OrderId));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Marking Message Members for Auditing using Attributes in C#\nDESCRIPTION: Demonstrates how to mark public properties (`Name`) or fields (`AccountId`) on a message type (`AuditedMessage`) as 'audited members' using the `[Audit]` attribute. Audited members are included in logging and telemetry data. The attribute can optionally take a string parameter to specify the name used in logging/telemetry.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic class AuditedMessage\n{\n    [Audit]\n    public string Name { get; set; }\n\n    [Audit(\"AccountIdentifier\")] public int AccountId;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IAccountCommand Interface - C#\nDESCRIPTION: Defines a marker interface for command messages that reference an Account by AccountId, supporting middleware selection. This interface standardizes the presence of an AccountId property for downstream lookup logic. Its presence allows middleware registration to target any commands implementing the interface.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/middleware.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IAccountCommand\n{\n    Guid AccountId { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating New ASP.Net Core Web API Project (Bash)\nDESCRIPTION: Initializes a new ASP.Net Core Web API project using the .NET CLI. This serves as the starting point before adding WolverineFx.HTTP.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet new webapi\n```\n\n----------------------------------------\n\nTITLE: Defining GET Endpoint for Listing Todos with Marten (C#)\nDESCRIPTION: Defines a static HTTP GET endpoint at `/todoitems` to retrieve all `Todo` items. The method uses dependency injection to receive Marten's `IQuerySession` and asynchronously queries the database for all `Todo` documents, returning them as a read-only list. Wolverine automatically serializes the result to JSON.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\n[WolverineGet(\"/todoitems\")]\npublic static Task<IReadOnlyList<Todo>> Get(IQuerySession session)\n    => session.Query<Todo>().ToListAsync();\n```\n\n----------------------------------------\n\nTITLE: Accessing Envelope Metadata in Wolverine Handler (C#)\nDESCRIPTION: This snippet shows how to access Wolverine's Envelope object within a handler method by adding it as a method parameter. The handler for InvoiceCreated receives the Envelope, allowing access to message metadata such as SentAt for calculating message age. No explicit dependencies are required; Envelope is provided by the Wolverine framework at runtime. Input is an InvoiceCreated message, and developers can use Envelope fields for custom logic or telemetry.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic class EnvelopeUsingHandler\n{\n    public void Handle(InvoiceCreated message, Envelope envelope)\n    {\n        var howOldIsThisMessage =\n            DateTimeOffset.Now.Subtract(envelope.SentAt);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Wolverine Aggregate Handler Using IEventStream in C#\nDESCRIPTION: Defines a Wolverine command handler using the `[AggregateHandler]` attribute. It takes the command (`MarkItemReady`) and an `IEventStream<Order>` as arguments. The handler interacts with the stream's aggregate (`Order`), appends events (`ItemReady`, `OrderReady`) directly using `stream.AppendOne()`, and performs validation. No explicit return value is needed as events are appended directly.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n[AggregateHandler]\npublic static void Handle(OrderEventSourcingSample.MarkItemReady command, IEventStream<Order> stream)\n{\n    var order = stream.Aggregate;\n\n    if (order.Items.TryGetValue(command.ItemName, out var item))\n    {\n        // Not doing this in a purist way here, but just\n        // trying to illustrate the Wolverine mechanics\n        item.Ready = true;\n\n        // Mark that the this item is ready\n        stream.AppendOne(new ItemReady(command.ItemName));\n    }\n    else\n    {\n        // Some crude validation\n        throw new InvalidOperationException($\"Item {command.ItemName} does not exist in this order\");\n    }\n\n    // If the order is ready to ship, also emit an OrderReady event\n    if (order.IsReadyToShip())\n    {\n        stream.AppendOne(new OrderReady());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Wolverine Messages with Tenant IDs using DeliveryOptions in C#\nDESCRIPTION: Illustrates how to publish a message to be processed asynchronously while specifying a tenant ID. This is achieved by passing a `DeliveryOptions` object with the `TenantId` property set to the `IMessageBus.PublishAsync` method. The handler processing this message will receive the associated tenant ID ('tenant3'). Requires an `IMessageBus` instance.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/multi-tenancy.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic static async Task publish_by_tenant(IMessageBus bus)\n{\n    await bus.PublishAsync(new CreateTodo(\"Fix that last broken test\"),\n        new DeliveryOptions { TenantId = \"tenant3\" });\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Mapping Wolverine Envelope Storage in EF Core DbContext (C#)\nDESCRIPTION: Illustrates how to manually configure an Entity Framework Core `DbContext` (e.g., `SampleMappedDbContext`) to include the necessary table mappings for Wolverine's durable message persistence (inbox/outbox). This is achieved by calling the `MapWolverineEnvelopeStorage()` extension method on the `ModelBuilder` within the `OnModelCreating` override. This approach is typically used when not utilizing the `AddDbContextWithWolverineIntegration` registration method.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/efcore.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\npublic class SampleMappedDbContext : DbContext\n{\n    public SampleMappedDbContext(DbContextOptions<SampleMappedDbContext> options) : base(options)\n    {\n    }\n\n    public DbSet<Item> Items { get; set; }\n\n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        // This enables your DbContext to map the incoming and\n        // outgoing messages as part of the outbox\n        modelBuilder.MapWolverineEnvelopeStorage();\n\n        // Your normal EF Core mapping\n        modelBuilder.Entity<Item>(map =>\n        {\n            map.ToTable(\"items\");\n            map.HasKey(x => x.Id);\n            map.Property(x => x.Name);\n        });\n    }\n}\n```\n\nLANGUAGE: cs\nCODE:\n```\npublic class SampleMappedDbContext : DbContext\n{\n    public SampleMappedDbContext(DbContextOptions<SampleMappedDbContext> options) : base(options)\n    {\n    }\n\n    public DbSet<Item> Items { get; set; }\n\n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        // This enables your DbContext to map the incoming and\n        // outgoing messages as part of the outbox\n        modelBuilder.MapWolverineEnvelopeStorage();\n\n        // Your normal EF Core mapping\n        modelBuilder.Entity<Item>(map =>\n        {\n            map.ToTable(\"items\");\n            map.HasKey(x => x.Id);\n            map.Property(x => x.Name);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling a Timeout Message in a Wolverine Saga (C#)\nDESCRIPTION: This C# snippet presents a `Handle` method specifically for the `OrderTimeout` message defined earlier. When the scheduled timeout message is delivered, this handler logs the timeout event and calls `MarkCompleted()` to terminate the Saga, effectively enforcing a time limit. It depends on `Microsoft.Extensions.Logging.ILogger` and the Saga's `MarkCompleted()` method.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sagas.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\n// Delete this order if it has not already been deleted to enforce a \"timeout\"\n// condition\npublic void Handle(OrderTimeout timeout, ILogger<Order> logger)\n{\n    logger.LogInformation(\"Applying timeout to order {Id}\", timeout.Id);\n\n    // That's it, we're done. Delete the saga state after the message is done.\n    MarkCompleted();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Expiration Rules for Subscribers with Azure Service Bus - Wolverine C#\nDESCRIPTION: This sample shows how to apply a delivery expiration rule to all messages sent to a specific Azure Service Bus queue using Wolverine's configuration API. The snippet demonstrates pulling a connection string from configuration, setting up Azure Service Bus, and publishing messages of a particular type to a queue with a 5-second expiration and in-memory buffering. Dependencies include Host, UseWolverine, and the relevant Azure Service Bus configuration (connection string and queue name).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/expiration.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\\nbuilder.UseWolverine(opts =>\\n{\\n    // One way or another, you're probably pulling the Azure Service Bus\\n    // connection string out of configuration\\n    var azureServiceBusConnectionString = builder\\n        .Configuration\\n        .GetConnectionString(\"azure-service-bus\");\\n\\n    // Connect to the broker in the simplest possible way\\n    opts.UseAzureServiceBus(azureServiceBusConnectionString).AutoProvision();\\n\\n    // Explicitly configure a delivery expiration of 5 seconds\\n    // for a specific Azure Service Bus queue\\n    opts.PublishMessage<StatusUpdate>().ToAzureServiceBusQueue(\"transient\")\\n\\n        // If the messages are transient, it's likely that they should not be\\n        // durably stored, so make things lighter in your system\\n        .BufferedInMemory()\\n        .DeliverWithin(5.Seconds());\\n});\\n\\nusing var host = builder.Build();\\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Versions of a Message in Wolverine (C#)\nDESCRIPTION: Defines a message handler with static methods for handling both v1 and v2 versions of the PersonBorn message. Requires both types to be defined and demonstrates how multiple handlers can coexist for version compatibility. Inputs are strongly-typed message objects corresponding to each version, and the outputs are side effects from message processing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PersonCreatedHandler\n{\n    public static void Handle(PersonBorn person)\n    {\n        // do something w/ the message\n    }\n\n    public static void Handle(PersonBornV2 person)\n    {\n        // do something w/ the message\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Kafka Metadata in Wolverine Middleware for Instrumentation in C#\nDESCRIPTION: Provides a static middleware class example demonstrating how to access Kafka-specific metadata (TopicName, Offset, GroupId) from the Wolverine Envelope object. This is useful for logging, diagnostics, or custom instrumentation when processing messages received from Kafka topics. Depends on Wolverine.Core and Microsoft.Extensions.Logging.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/kafka.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\npublic static class KafkaInstrumentation\n{\n    // Just showing what data elements are available to use for \n    // extra instrumentation when listening to Kafka topics\n    public static void Before(Envelope envelope, ILogger logger)\n    {\n        logger.LogDebug(\"Received message from Kafka topic {TopicName} with Offset={Offset} and GroupId={GroupId}\", \n            envelope.TopicName, envelope.Offset, envelope.GroupId);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages Using Routing Keys via Exchanges in Wolverine C#\nDESCRIPTION: This snippet shows how to configure Wolverine to publish messages to a RabbitMQ exchange (\"exchange1\"), effectively using routing keys defined by bindings. It demonstrates configuring the RabbitMQ connection, explicitly declaring an exchange (\"exchange1\"), a queue (\"queue1\"), and the binding key (\"key1\") using `DeclareExchange` and `BindQueue`. Crucially, it enables `AutoProvision()`, allowing Wolverine to create these RabbitMQ objects if they don't exist. Messages are then directed to the exchange using `PublishAllMessages().ToRabbitExchange(\"exchange1\")`, relying on the configured bindings for routing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/publishing.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq(rabbit => { rabbit.HostName = \"localhost\"; })\n            // I'm declaring an exchange, a queue, and the binding\n            // key that we're referencing below.\n            // This is NOT MANDATORY, but rather just allows Wolverine to\n            // control the Rabbit MQ object lifecycle\n            .DeclareExchange(\"exchange1\", ex => { ex.BindQueue(\"queue1\", \"key1\"); })\n\n            // This will direct Wolverine to create any missing Rabbit MQ exchanges,\n            // queues, or binding keys declared in the application at application\n            // start up time\n            .AutoProvision();\n\n        opts.PublishAllMessages().ToRabbitExchange(\"exchange1\");\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Adapting Wolverine Handler to Return IResult for Minimal API Responses in C#\nDESCRIPTION: Modifies the `CancelOrderHandler` to return `Microsoft.AspNetCore.Http.IResult`. Instead of returning `void` or `Task`, it now returns specific HTTP status codes and responses like `Results.NotFound()` if the order doesn't exist, `Results.BadRequest()` with a reason if the order has shipped, or `Results.Ok()` upon successful cancellation and event publication. This integrates Wolverine handler logic with standard Minimal API result types for better HTTP client feedback.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class CancelOrderHandler\n{\n    public static async Task<IResult> Handle(\n        CancelOrder command, \n        IDocumentSession session, \n        IMessageBus messageBus,\n        CancellationToken token)\n    {\n        var order = await session.LoadAsync<Order>(command.OrderId, token);\n        \n        // return a 404 if the order doesn't exist\n        if (order == null) return Results.NotFound();\n\n        // return a 400 with a description of why the order could not be cancelled\n        // Assuming Order has a HasShipped property\n        if (order.HasShipped) return Results.BadRequest(\"Order has already been shipped\");\n        \n        // Maybe it's a soft delete here?\n        session.Delete(order);\n        \n        // Publish a domain event to let other things in the system know to\n        // take actions to stop shipping, inventory, who knows what\n        await messageBus.PublishAsync(new OrderCancelled(command.OrderId));\n\n        // Return 200 OK on success\n        return Results.Ok();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating TenantId Instances for Testing in C#\nDESCRIPTION: Shows the simple instantiation of the `TenantId` record for use in unit testing scenarios. This allows developers to create `TenantId` objects with specific tenant values (e.g., 'tenant1') and pass them directly into message handler methods during tests to simulate different tenant contexts.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/multi-tenancy.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar tenantId = new TenantId(\"tenant1\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Message Log Levels in Wolverine C#\nDESCRIPTION: Demonstrates how to override the default logging levels for message execution start/finish (default Debug) and successful message completion (default Information) globally within a Wolverine application using `WolverineOptions`. This snippet sets execution logging to `LogLevel.None` and success logging to `LogLevel.Debug` during application startup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Turn off all logging of the message execution starting and finishing\n        // The default is Debug\n        opts.Policies.MessageExecutionLogLevel(LogLevel.None);\n\n        // Turn down Wolverine's built in logging of all successful\n        // message processing\n        opts.Policies.MessageSuccessLogLevel(LogLevel.Debug);\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Connecting Wolverine to Azure Service Bus with Basic Configuration in C#\nDESCRIPTION: This snippet demonstrates the basic configuration for connecting a Wolverine application to Azure Service Bus. It retrieves the connection string from configuration, uses `opts.UseAzureServiceBus()` to establish the connection, and shows optional configurations like `.AutoProvision()` to create missing queues at runtime and `.AutoPurgeOnStartup()` to clear queues on application start (useful for testing). It also shows how to provide further Azure Service Bus client options, such as setting the retry mode.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/index.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // One way or another, you're probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\");\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString)\n\n        // Let Wolverine try to initialize any missing queues\n        // on the first usage at runtime\n        .AutoProvision()\n\n        // Direct Wolverine to purge all queues on application startup.\n        // This is probably only helpful for testing\n        .AutoPurgeOnStartup();\n\n    // Or if you need some further specification...\n    opts.UseAzureServiceBus(azureServiceBusConnectionString,\n        azure => { azure.RetryOptions.Mode = ServiceBusRetryMode.Exponential; });\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Message Handler - Wolverine (.NET C#)\nDESCRIPTION: This snippet demonstrates a minimal message handler class in C# for use with the Wolverine framework. The 'Handle' method is intended to process incoming 'MyMessage' messages with zero required interfaces or base classes. Dependencies: Requires a definition of 'MyMessage'. The method prints a line to the console on message receipt, but in practice, developers would include application logic within this handler.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyMessageHandler\n{\n    public void Handle(MyMessage message)\n    {\n        Console.WriteLine(\"I got a message!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Handler Policy with Wolverine Host (C#)\nDESCRIPTION: Demonstrates the use of Host.CreateDefaultBuilder and UseWolverine extension to register a custom handler policy (WrapWithSimple) at host startup. This registers the WrapWithSimple policy, causing all handler chains in the application lifecycle to be configured by it. Dependencies are the Microsoft.Extensions.Hosting system and the Wolverine UseWolverine extension. Input is a lambda that modifies Wolverine policies; output is a running application with the middleware policy globally applied.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts => { opts.Policies.Add<WrapWithSimple>(); }).StartAsync();\n\n```\n\n----------------------------------------\n\nTITLE: Testing HTTP Endpoint with JSON Serialization in Wolverine (C#)\nDESCRIPTION: This snippet demonstrates an end-to-end HTTP test using Alba with a Wolverine endpoint that handles JSON serialization for both request and response types. It posts a JSON object, sets the accept header, and validates the deserialized result, requiring dependencies on Alba, Wolverine, and Shouldly. The expected input is a JSON body matching the Question model; output is the ArithmeticResults object with Product and Sum assertions. This snippet requires a properly configured Wolverine HTTP app and appropriate NuGet packages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/json.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic async Task post_json_happy_path()\n{\n    // This test is using Alba to run an end to end HTTP request\n    // and interrogate the results\n    var response = await Scenario(x =>\n    {\n        x.Post.Json(new Question { One = 3, Two = 4 }).ToUrl(\"/question\");\n        x.WithRequestHeader(\"accept\", \"application/json\");\n    });\n\n    var result = await response.ReadAsJsonAsync<ArithmeticResults>();\n\n    result.Product.ShouldBe(12);\n    result.Sum.ShouldBe(7);\n}\n```\n\n----------------------------------------\n\nTITLE: Delegating Minimal API POST Request to Wolverine Command Bus in C#\nDESCRIPTION: This snippet shows an ASP.NET Core Minimal API endpoint that handles POST requests to `/orders/create2`. It receives a `CreateOrder` command object and an `IMessageBus` (Wolverine's command bus) via dependency injection and executes the command using `bus.InvokeAsync()`. This pattern delegates request handling directly to Wolverine's messaging infrastructure, potentially leveraging features like the outbox configured elsewhere. Requires `Wolverine.Runtime` and relevant ASP.NET Core packages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/inbox.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n// Delegate directly to Wolverine commands -- More efficient recipe coming later...\napp.MapPost(\"/orders/create2\", (CreateOrder command, IMessageBus bus)\n    => bus.InvokeAsync(command));\n```\n\n----------------------------------------\n\nTITLE: Defining a Reservation Saga Class using Wolverine (C#)\nDESCRIPTION: This snippet defines a Reservation saga by subclassing Saga in C#. It handles reservation booking and timeout events through dedicated handler methods that log actions and mark the saga as completed, triggering persistence changes. Dependencies include ILogger<Reservation> for logging and types BookReservation and ReservationTimeout for saga messages. Inputs are message objects; outputs are side-effects on the saga state and logs.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/sagas.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Reservation : Saga\n{\n    public string? Id { get; set; }\n\n    // Apply the CompleteReservation to the saga\n    public void Handle(BookReservation book, ILogger<Reservation> logger)\n    {\n        logger.LogInformation(\"Completing Reservation {Id}\", book.Id);\n\n        // That's it, we're done. Delete the saga state after the message is done.\n        MarkCompleted();\n    }\n\n    // Delete this Reservation if it has not already been deleted to enforce a \"timeout\"\n    // condition\n    public void Handle(ReservationTimeout timeout, ILogger<Reservation> logger)\n    {\n        logger.LogInformation(\"Applying timeout to Reservation {Id}\", timeout.Id);\n\n        // That's it, we're done. Delete the saga state after the message is done.\n        MarkCompleted();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Listener Types in Wolverine (C#)\nDESCRIPTION: This C# snippet demonstrates the configuration of different types of Rabbit MQ message listeners (inline, buffered, durable) in a Wolverine application. It sets up Wolverine on the host, registers Rabbit MQ as the transport, and uses PostgreSQL for message persistence. Inline listeners process messages in real time and can be parallelized with 'ListenerCount'. Buffered listeners queue messages in memory for higher throughput, controlled by buffering limits, while durable listeners use a persistent inbox for guaranteed delivery. Required dependencies include Wolverine, a Rabbit MQ broker, and PostgreSQL for persistence. Options for listener count and buffering limits allow fine-tuning of endpoint throughput and durability, and the code must be invoked as part of a .NET host builder pipeline.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/listeners.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // The Rabbit MQ transport supports all three types of listeners\n        opts.UseRabbitMq();\n\n        // The durable mode requires some sort of envelope storage\n        opts.PersistMessagesWithPostgresql(\"some connection string\");\n\n        opts.ListenToRabbitQueue(\"inline\")\n            // Process inline, default is with one listener\n            .ProcessInline()\n\n            // But, you can use multiple, parallel listeners\n            .ListenerCount(5);\n\n        opts.ListenToRabbitQueue(\"buffered\")\n            // Buffer the messages in memory for increased throughput\n            .BufferedInMemory(new BufferingLimits(1000, 500));\n\n        opts.ListenToRabbitQueue(\"durable\")\n            // Opt into durable inbox mechanics\n            .UseDurableInbox(new BufferingLimits(1000, 500));\n\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Initializing a .NET WebAPI Project - Bash\nDESCRIPTION: This snippet initializes a new ASP.NET Core Web API project using the .NET CLI. It does not require any dependencies besides the .NET SDK being installed. Running this command scaffolds a new webapi project in the current directory, setting up basic folders and files needed for development.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/getting-started.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet new webapi\n```\n\n----------------------------------------\n\nTITLE: Setting Tenant IDs for Cascading Messages in Wolverine Handlers (C#)\nDESCRIPTION: Shows how to assign tenant IDs to outgoing messages returned from a Wolverine message handler using helper methods. The `WithTenantId()` extension method provides a concise way to tag messages (`Message1`, `Message2`). Alternatively, the `WithDeliveryOptions()` method allows setting the `TenantId` along with other options like `ScheduleDelay` (`Message3`, `Message4`). This ensures subsequent handlers process these messages under the specified tenant context.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/multi-tenancy.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic static IEnumerable<object> Handle(IncomingMessage message)\n{\n    yield return new Message1().WithTenantId(\"one\");\n    yield return new Message2().WithTenantId(\"one\");\n\n    yield return new Message3().WithDeliveryOptions(new DeliveryOptions\n    {\n        ScheduleDelay = 5.Minutes(),\n        TenantId = \"two\"\n    });\n    \n    // Long hand\n    yield return new Message4().WithDeliveryOptions(new DeliveryOptions\n    {\n        TenantId = \"one\"\n    });\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Message Handler in C#\nDESCRIPTION: Shows a basic message handler implementation in C#. The static `DebitAccountHandler` class contains a `Handle` method that accepts a `DebitAccount` message. This method defines the logic to be executed when a `DebitAccount` message is processed, in this case, printing details to the console. Wolverine automatically discovers such handlers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/basics.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic static class DebitAccountHandler\n{\n    public static void Handle(DebitAccount account)\n    {\n        Console.WriteLine($\"I'm supposed to debit {account.Amount} from account {account.AccountId}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple String Response Endpoint in Wolverine C#\nDESCRIPTION: This C# snippet demonstrates a minimal Wolverine HTTP GET endpoint. The `Get` method within the `HelloEndpoint` class, decorated with `[WolverineGet(\"/\")]`, handles GET requests to the root path. It returns a simple string \"Hello.\", which Wolverine sends as the HTTP response with a `Content-Type` of `text/plain` and a 200 OK status code.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic class HelloEndpoint\n{\n    [WolverineGet(\"/\")]\n    public string Get() => \"Hello.\";\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Wolverine PostgreSQL Dependency using .NET CLI\nDESCRIPTION: This command uses the .NET CLI to add the `WolverineFx.Postgresql` NuGet package dependency to the current .NET project. This package is essential for enabling PostgreSQL-backed message persistence and the PostgreSQL messaging transport within a Wolverine application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/postgresql.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package WolverineFx.Postgresql\n```\n\n----------------------------------------\n\nTITLE: Manually Handling Logic and Outbox in an MVC Controller (C#)\nDESCRIPTION: This C# snippet shows an alternative approach using a traditional ASP.NET Core MVC Controller (`DoItAllMyselfItemController`) where the transaction management, entity persistence, and event publishing are handled explicitly within the controller action, contrasting with the Wolverine mediator pattern. It injects `IDbContextOutbox<ItemsDbContext>`, adds the new `Item` to the context, uses `outbox.SendAsync()` to stage an `ItemCreated` event for publishing, and finally calls `outbox.SaveChangesAndFlushMessagesAsync()` to commit the database changes and publish the message transactionally via Wolverine's outbox.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/mediator.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n// This controller does all the transactional work and business\n// logic all by itself\npublic class DoItAllMyselfItemController : ControllerBase\n{\n    [HttpPost(\"/items/create3\")]\n    public async Task Create(\n        [FromBody] CreateItemCommand command,\n        [FromServices] IDbContextOutbox<ItemsDbContext> outbox)\n    {\n        // Create a new Item entity\n        var item = new Item\n        {\n            Name = command.Name\n        };\n\n        // Add the item to the current\n        // DbContext unit of work\n        outbox.DbContext.Items.Add(item);\n\n        // Publish an event to anyone\n        // who cares that a new Item has\n        // been created\n        var @event = new ItemCreated\n        {\n            Id = item.Id\n        };\n\n        // Because the message context is enlisted in an\n        // \"outbox\" transaction, these outgoing messages are\n        // held until the ongoing transaction completes\n        await outbox.SendAsync(@event);\n\n        // Commit the unit of work. This will persist\n        // both the Item entity we created above, and\n        // also a Wolverine Envelope for the outgoing\n        // ItemCreated message\n        await outbox.SaveChangesAndFlushMessagesAsync();\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Wolverine GET Endpoint with a String Route Parameter in C#\nDESCRIPTION: This snippet demonstrates defining a simple HTTP GET endpoint using the `[WolverineGet]` attribute. The route `/name/{name}` includes a route parameter `{name}`. The method parameter `string name` exactly matches the route parameter name, so Wolverine automatically binds the value from the URL path segment to this parameter at runtime.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/routing.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n[WolverineGet(\"/name/{name}\")]\npublic static string SimpleStringRouteArgument(string name)\n{\n    return $\"Name is {name}\";\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Wolverine Database Schema Changes via CLI using Bash\nDESCRIPTION: Shows the command `dotnet run -- db-apply` used to apply any outstanding database schema changes required by the current Wolverine message persistence configuration. This command ensures the database schema matches the application's requirements without clearing existing data.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- db-apply\n```\n\n----------------------------------------\n\nTITLE: Disabling Native RabbitMQ Dead Letter Queues in Wolverine (C#)\nDESCRIPTION: This C# snippet shows how to disable Wolverine's use of RabbitMQ's native dead letter queue functionality. This is useful if you prefer to rely solely on Wolverine's built-in dead letter storage mechanisms (e.g., database-backed durability). The `DisableDeadLetterQueueing()` method can be called on the RabbitMQ transport options, within `ConfigureListeners` for a conventional approach, or directly on a specific queue listener configuration (`ListenToRabbitQueue`) to disable it for that endpoint only.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/deadletterqueues.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Disable dead letter queueing by default\n        opts.UseRabbitMq()\n            .DisableDeadLetterQueueing()\n\n            // or conventionally\n            .ConfigureListeners(l =>\n            {\n                // Really does the same thing as the first usage\n                l.DisableDeadLetterQueueing();\n            });\n\n        // Disable the dead letter queue for this specific queue\n        opts.ListenToRabbitQueue(\"incoming\").DisableDeadLetterQueueing();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing Sticky Handlers with Attributes in C#\nDESCRIPTION: Demonstrates defining two static C# handler classes, `BlueStickyHandler` and `GreenStickyHandler`, for the `StickyMessage`. Each class uses the `[StickyHandler(\"name\")]` attribute to associate it with a specific logical endpoint ('blue' or 'green'). This ensures Wolverine routes `StickyMessage` instances to separate local queues for independent processing by these handlers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/sticky.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n[StickyHandler(\"blue\")]\npublic static class BlueStickyHandler\n{\n    public static StickyMessageResponse Handle(StickyMessage message, Envelope envelope)\n    {\n        return new StickyMessageResponse(\"blue\", message, envelope.Destination);\n    }\n}\n\n[StickyHandler(\"green\")]\npublic static class GreenStickyHandler\n{\n    public static StickyMessageResponse Handle(StickyMessage message, Envelope envelope)\n    {\n        return new StickyMessageResponse(\"green\", message, envelope.Destination);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Wolverine Handler Discovery Conventions (C#)\nDESCRIPTION: This C# example demonstrates customizing Wolverine's message handler discovery. It disables the default conventions using `DisableConventionalDiscovery()`, then adds custom discovery rules using `CustomizeHandlerDiscovery()` to include types ending in \"Worker\" or \"Listener\", and finally explicitly includes a specific handler type `SimpleHandler` using `IncludeType<SimpleHandler>()`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/discovery.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Discovery\n\n            // Turn off the default handler conventions\n            // altogether\n            .DisableConventionalDiscovery()\n\n            // Include candidate actions by a user supplied\n            // type filter\n            .CustomizeHandlerDiscovery(x =>\n            {\n                x.Includes.WithNameSuffix(\"Worker\");\n                x.Includes.WithNameSuffix(\"Listener\");\n            })\n\n            // Include a specific handler class with a generic argument\n            .IncludeType<SimpleHandler>();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Parameter Handling Strategy in Wolverine C#\nDESCRIPTION: Demonstrates how to register a custom `IParameterStrategy` implementation, such as `NowParameterStrategy`, within the Wolverine configuration. This is done by calling the `AddParameterHandlingStrategy<T>()` extension method on the `WolverineHttpOptions` (`opts`) inside the `MapWolverineEndpoints()` setup block, making the custom strategy available to all defined Wolverine HTTP endpoints.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\n// Customizing parameter handling\nopts.AddParameterHandlingStrategy<NowParameterStrategy>();\n```\n\n----------------------------------------\n\nTITLE: Using MessagePack Serialization Globally in Wolverine (C#)\nDESCRIPTION: Illustrates enabling MessagePack serialization as the default serializer across a Wolverine application using the UseMessagePackSerialization() extension. Requires installing the WolverineFx.MessagePack NuGet package and configuring the host builder to use Wolverine. This setup can improve serialization efficiency over JSON.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Make MessagePack the default serializer throughout this application\n        opts.UseMessagePackSerialization();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining the ValueSource Enum for Entity Loading in C#\nDESCRIPTION: This C# snippet defines the `ValueSource` enum used within the Wolverine framework, specifically with the `[Entity]` attribute's `ValueSource` property. This enum allows developers to specify where Wolverine should look for the identity value when automatically loading an entity: `Anything` (default, looks in route arguments and input members), `InputMember` (only looks in properties/fields of the message or request body), or `RouteValue` (only looks in HTTP route arguments).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/persistence.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\npublic enum ValueSource\n{\n    /// <summary>\n    /// This value can be sourced by any mechanism that matches the name. This is the default.\n    /// </summary>\n    Anything,\n    \n    /// <summary>\n    /// The value should be sourced by a property or field on the message type or HTTP request type\n    /// </summary>\n    InputMember,\n    \n    /// <summary>\n    /// The value should be sourced by a route argument of an HTTP request\n    /// </summary>\n    RouteValue\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Commands Using Aggregate State in Wolverine Compound Handler (C#)\nDESCRIPTION: Shows a Wolverine compound handler structure where a static `Validate` method accesses the current state of the `LetterAggregate` before the main `Handle` method executes. Based on the aggregate's state (e.g., `aggregate.ACount`), it returns `HandlerContinuation.Continue` or `HandlerContinuation.Stop` to control whether the `[AggregateHandler]` method proceeds. This requires Wolverine's compound handler and aggregate handler features, along with the relevant aggregate and command types.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\npublic record RaiseIfValidated(Guid LetterAggregateId);\n\npublic static class RaiseIfValidatedHandler\n{\n    public static HandlerContinuation Validate(LetterAggregate aggregate) =>\n        aggregate.ACount == 0 ? HandlerContinuation.Continue : HandlerContinuation.Stop;\n    \n    [AggregateHandler]\n    public static IEnumerable<object> Handle(RaiseIfValidated command, LetterAggregate aggregate)\n    {\n        yield return new BEvent();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning a Route Name to a Wolverine POST Endpoint in C#\nDESCRIPTION: This snippet illustrates how to assign a specific name to an ASP.NET Core route defined by a Wolverine attribute. By setting the `RouteName` property on the `[WolverinePost]` attribute (or any `[WolverineVerb]` attribute), the underlying route registered with ASP.Net Core will have the specified name ('NamedRoute' in this case). This can be useful for URL generation or identification.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/routing.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n[WolverinePost(\"/named/route\", RouteName = \"NamedRoute\")]\npublic string Post()\n{\n    return \"Hello\";\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Extra Assemblies to Handler Discovery in Wolverine in C#\nDESCRIPTION: This snippet programmatically registers additional assemblies for type discovery in Wolverine by calling opts.Discovery.IncludeAssembly with the relevant assembly reference. This is useful when message handler classes reside outside the main application assembly. It requires Wolverine and is used inside UseWolverine configuration. Key parameter is typeof(MessageFromOtherAssembly).Assembly, which points to the external assembly to include; no direct input/output beyond affecting handler discovery during application startup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/discovery.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Add as many other assemblies as you need\n        opts.Discovery.IncludeAssembly(typeof(MessageFromOtherAssembly).Assembly);\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining a Message Record with C#\nDESCRIPTION: Defines the message contract for an Item to be batched using a C# record type. This snippet creates an immutable data structure used in Wolverine's messaging pipeline. No additional dependencies beyond the standard C# record support are required. The 'Name' property is the core data passed between systems and will be used for batching.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/batching.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic record Item(string Name);\n```\n\n----------------------------------------\n\nTITLE: Configuring RabbitMQ Connection in Wolverine using C#\nDESCRIPTION: Demonstrates three methods for configuring a connection to a RabbitMQ broker within a Wolverine application using the `UseRabbitMq` extension method on `WolverineOptions`. Options include using a connection URI string from configuration, connecting to a default local broker (localhost), or setting connection properties like HostName, VirtualHost, and UserName programmatically. Requires `Wolverine`, `Wolverine.RabbitMQ`, and `Oakton` Nuget packages, and typically relies on configuration settings provided via `builder.Configuration`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/introduction.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing Oakton;\nusing Wolverine;\nusing Wolverine.RabbitMQ;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Host.UseWolverine(opts =>\n{\n    // Using the Rabbit MQ URI specification: https://www.rabbitmq.com/uri-spec.html\n    opts.UseRabbitMq(new Uri(builder.Configuration[\"rabbitmq\"]));\n\n    // Or connect locally as you might for development purposes\n    opts.UseRabbitMq();\n\n    // Or do it more programmatically:\n    opts.UseRabbitMq(rabbit =>\n    {\n        rabbit.HostName = builder.Configuration[\"rabbitmq_host\"];\n        rabbit.VirtualHost = builder.Configuration[\"rabbitmq_virtual_host\"];\n        rabbit.UserName = builder.Configuration[\"rabbitmq_username\"];\n\n        // and you get the point, you get full control over the Rabbit MQ\n        // connection here for the times you need that\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling On-Demand Azure Service Bus Provisioning with Wolverine (C#)\nDESCRIPTION: This code sample configures Wolverine to provision Azure Service Bus queues, topics, and subscriptions dynamically at runtime using the AutoProvision() method. This means required resources are created as they become necessary during execution, providing flexibility for applications with evolving messaging infrastructure. Requires the Wolverine library and a valid Azure Service Bus connection string. The main input is the runtime configuration; outputs are resources built as needed.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/object-management.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAzureServiceBus(\"some connection string\")\n\n            // Wolverine will build missing queues, topics, and subscriptions\n            // as necessary at runtime\n            .AutoProvision();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Disabling Conventional Handler Discovery in Wolverine (C#)\nDESCRIPTION: This snippet demonstrates how to completely turn off Wolverine's automatic discovery of message handlers based on naming conventions. By calling `opts.DisableConventionalDiscovery()` within the `UseWolverine` configuration, type scanning for handlers is prevented, requiring explicit registration or alternative discovery mechanisms.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/discovery.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // No automatic discovery of handlers\n        opts.DisableConventionalDiscovery();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Testing Query String Parameter Binding in Wolverine Endpoints (C#)\nDESCRIPTION: Provides xUnit tests demonstrating how to test Wolverine endpoints that use query string parameters. The tests cover scenarios where a string parameter ('name') is present ('hit') and missing ('miss'), and a scenario involving a decimal parameter ('amount'), validating the endpoint's response body in each case. It uses the `Scenario` helper for setting up HTTP requests and asserting responses.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/querystring.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n```cs\n[Fact]\npublic async Task use_string_querystring_hit()\n{\n    var body = await Scenario(x =>\n    {\n        x.Get.Url(\"/querystring/string?name=Magic\");\n        x.Header(\"content-type\").SingleValueShouldEqual(\"text/plain\");\n    });\n\n    body.ReadAsText().ShouldBe(\"Name is Magic\");\n}\n\n[Fact]\npublic async Task use_string_querystring_miss()\n{\n    var body = await Scenario(x =>\n    {\n        x.Get.Url(\"/querystring/string\");\n        x.Header(\"content-type\").SingleValueShouldEqual(\"text/plain\");\n    });\n\n    body.ReadAsText().ShouldBe(\"Name is missing\");\n}\n\n[Fact]\npublic async Task use_decimal_querystring_hit()\n{\n    var body = await Scenario(x =>\n    {\n        x.WithRequestHeader(\"Accept-Language\", \"fr-FR\");\n        x.Get.Url(\"/querystring/decimal?amount=42.1\");\n        x.Header(\"content-type\").SingleValueShouldEqual(\"text/plain\");\n    });\n\n    body.ReadAsText().ShouldBe(\"Amount is 42.1\");\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Sending Request Requiring Specific Response in Wolverine (C#)\nDESCRIPTION: This C# snippet defines a `Requester` class that utilizes Wolverine's `IMessageContext` to send a `MyMessage`. It specifically requires a response of type `MyResponse` using `DeliveryOptions.RequireResponse<MyResponse>()`. This pattern is used in request/reply scenarios where the sending service expects a specific type of reply from the handling service.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic class Requester\n{\n    private readonly IMessageContext _bus;\n\n    public Requester(IMessageContext bus)\n    {\n        _bus = bus;\n    }\n\n    public ValueTask GatherResponse()\n    {\n        return _bus.SendAsync(new MyMessage(), DeliveryOptions.RequireResponse<MyResponse>());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine to Publish to RabbitMQ Topics Exchange (C#)\nDESCRIPTION: This snippet demonstrates how to configure a Wolverine host application to use RabbitMQ transport and publish messages originating from a specific namespace ('SomeNamespace') to a designated RabbitMQ topic exchange named 'topics-exchange'. It initializes the host, enables RabbitMQ using `UseRabbitMq()`, and sets up a publishing rule with `Publish().ToRabbitTopics()`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/topics.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq();\n\n        opts.Publish(x =>\n        {\n            x.MessagesFromNamespace(\"SomeNamespace\");\n            x.ToRabbitTopics(\"topics-exchange\", ex =>\n            {\n                // optionally configure the exchange\n            });\n        });\n\n        opts.ListenToRabbitQueue(\"\");\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Example Response Body from Querying Dead Letters API (JSON)\nDESCRIPTION: Shows an example JSON response from the `POST /dead-letters/` endpoint. The response includes an array of `Messages` containing detailed information about each dead letter envelope and an optional `NextId` for pagination.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/dead-letter-storage.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Messages\": [\n    {\n      \"Id\": \"4e3d5e88-e01f-4bcb-af25-6e4c14b0a867\",\n      \"ExecutionTime\": \"2024-04-06T12:00:00Z\",\n      \"Body\": {\n        \"OrderId\": 123456,\n        \"OrderStatus\": \"Failed\",\n        \"Reason\": \"Invalid Payment Method\"\n      },\n      \"MessageType\": \"OrderFailedEvent\",\n      \"ReceivedAt\": \"2024-04-06T12:05:00Z\",\n      \"Source\": \"OrderService\",\n      \"ExceptionType\": \"PaymentException\",\n      \"ExceptionMessage\": \"The payment method provided is invalid.\",\n      \"SentAt\": \"2024-04-06T12:00:00Z\",\n      \"Replayable\": true\n    },\n    {\n      \"Id\": \"5f2c3d1e-3f3d-46f9-ba29-dac8e0f9b078\",\n      \"ExecutionTime\": null,\n      \"Body\": {\n        \"CustomerId\": 78910,\n        \"AccountBalance\": -150.75\n      },\n      \"MessageType\": \"AccountOverdrawnEvent\",\n      \"ReceivedAt\": \"2024-04-06T15:20:00Z\",\n      \"Source\": \"AccountService\",\n      \"ExceptionType\": \"OverdrawnException\",\n      \"ExceptionMessage\": \"Account balance cannot be negative.\",\n      \"SentAt\": \"2024-04-06T15:15:00Z\",\n      \"Replayable\": false\n    }\n  ],\n  \"NextId\": \"8a1d77f2-f91b-4edb-8b51-466b5a8a3a6f\"\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom IChainPolicy in Wolverine Application (C#)\nDESCRIPTION: This C# code snippet illustrates how to register the custom `WriteFilePolicy` within a .NET application using Wolverine. It utilizes the `UseWolverine` extension method on `IHostBuilder` and adds the policy instance to the `opts.Policies` collection during application startup configuration. This ensures the custom policy is applied to message handlers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/return-values.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts => { opts.Policies.Add<WriteFilePolicy>(); }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Generated Wolverine HTTP Handler for ProblemDetails (C#)\nDESCRIPTION: Shows the C# code generated by Wolverine for the `ProblemDetailsUsageEndpoint`. This handler demonstrates how Wolverine processes the `ProblemDetails` returned by the `Before` method. If the returned object is not `WolverineContinue.NoProblems`, it writes the `ProblemDetails` to the HTTP response using `Microsoft.AspNetCore.Http.Results.Problem()` and stops further execution. Otherwise, it proceeds to call the main `Post` handler method.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/problemdetails.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n    public class POST_problems : Wolverine.Http.HttpHandler\n    {\n        private readonly Wolverine.Http.WolverineHttpOptions _wolverineHttpOptions;\n\n        public POST_problems(Wolverine.Http.WolverineHttpOptions wolverineHttpOptions) : base(wolverineHttpOptions)\n        {\n            _wolverineHttpOptions = wolverineHttpOptions;\n        }\n\n        public override async System.Threading.Tasks.Task Handle(Microsoft.AspNetCore.Http.HttpContext httpContext)\n        {\n            var problemDetailsUsageEndpoint = new WolverineWebApi.ProblemDetailsUsageEndpoint();\n            var (message, jsonContinue) = await ReadJsonAsync<WolverineWebApi.NumberMessage>(httpContext);\n            if (jsonContinue == Wolverine.HandlerContinuation.Stop) return;\n            \n            var problemDetails = problemDetailsUsageEndpoint.Before(message);\n            if (!(ReferenceEquals(problemDetails, Wolverine.Http.WolverineContinue.NoProblems)))\n            {\n                await Microsoft.AspNetCore.Http.Results.Problem(problemDetails).ExecuteAsync(httpContext).ConfigureAwait(false);\n                return;\n            }\n\n            var result_of_Post = WolverineWebApi.ProblemDetailsUsageEndpoint.Post(message);\n            await WriteString(httpContext, result_of_Post);\n        }\n\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine TCP Listener in .NET Host (C#)\nDESCRIPTION: This C# snippet demonstrates how to configure Wolverine within a .NET application host using `UseWolverine`. It sets up a listener for the lightweight TCP transport on a port retrieved from application configuration via `opts.ListenAtPort(port)`. Additionally, it shows how to conditionally stub all external messaging transports during development using `opts.StubAllExternalTransports()`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/tcp.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic static IHost CreateHostBuilder()\n{\n    var builder = Host.CreateApplicationBuilder();\n    \n    // This adds Wolverine with inline configuration\n    // of WolverineOptions\n    builder.UseWolverine(opts =>\n    {\n        // This is an example usage of the application's\n        // IConfiguration inside of Wolverine bootstrapping\n        var port = builder.Configuration.GetValue<int>(\"ListenerPort\");\n        opts.ListenAtPort(port);\n\n        // If we're running in development mode and you don't\n        // want to worry about having all the external messaging\n        // dependencies up and running, stub them out\n        if (builder.Environment.IsDevelopment())\n        {\n            // This will \"stub\" out all configured external endpoints\n            opts.StubAllExternalTransports();\n        }\n    });\n\n    return builder.Build();\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Oakton for Command Line Support in a Wolverine .NET Application (C#)\nDESCRIPTION: This C# snippet demonstrates the setup of a minimal ASP.NET Core application incorporating Wolverine for message handling and Oakton for command-line capabilities. It configures necessary services like repositories, integrates Wolverine using `builder.Host.UseWolverine()`, defines API endpoints that delegate to Wolverine's `IMessageBus`, and uses `app.RunOaktonCommands(args)` to enable command-line tools. Dependencies include ASP.NET Core, Wolverine, Oakton, and Swashbuckle for API documentation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/command-line.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing Oakton;\nusing Quickstart;\nusing Wolverine;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// The almost inevitable inclusion of Swashbuckle:)\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// For now, this is enough to integrate Wolverine into\n// your application, but there'll be *many* more\n// options later of course :-)\nbuilder.Host.UseWolverine();\n\n// Some in memory services for our application, the\n// only thing that matters for now is that these are\n// systems built by the application's IoC container\nbuilder.Services.AddSingleton<UserRepository>();\nbuilder.Services.AddSingleton<IssueRepository>();\n\nvar app = builder.Build();\n\n// An endpoint to create a new issue that delegates to Wolverine as a mediator\napp.MapPost(\"/issues/create\", (CreateIssue body, IMessageBus bus) => bus.InvokeAsync(body));\n\n// An endpoint to assign an issue to an existing user that delegates to Wolverine as a mediator\napp.MapPost(\"/issues/assign\", (AssignIssue body, IMessageBus bus) => bus.InvokeAsync(body));\n\n// Swashbuckle inclusion\napp.UseSwagger();\napp.UseSwaggerUI();\n\napp.MapGet(\"/\", () => Results.Redirect(\"/swagger\"));\n\n// Opt into using Oakton for command line parsing\n// to unlock built in diagnostics and utility tools within\n// your Wolverine application\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Applying Expiration Attribute Per Message Type - Wolverine C#\nDESCRIPTION: This snippet illustrates the use of the DeliverWithinAttribute on a message type to set a global expiration for all instances of that message. Applying [DeliverWithin(5)] ensures that Wolverine will treat these messages as transient and discard them if not handled within five seconds. Dependencies include the Wolverine.Attributes namespace and any middleware or infrastructure that respects the attribute, and the attribute's constructor argument sets the expiry time in seconds.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/expiration.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// The attribute directs Wolverine to send this message with\\n// a \"deliver within 5 seconds, or discard\" directive\\n[DeliverWithin(5)]\\npublic record AccountUpdated(Guid AccountId, decimal Balance);\n```\n\n----------------------------------------\n\nTITLE: Creating a Multi-Tenant Todo Item with Wolverine HTTP - C#\nDESCRIPTION: This snippet implements a create endpoint for a multi-tenant todo resource, using the [WolverinePost] attribute and including a tenant id parameter. A new Todo is instantiated and persisted, with the resulting entity id included in both the TodoCreated event and the resource URI. This pattern leverages IDocumentSession for persistence and demonstrates Wolverine.HTTP 1.7's capabilities for associating commands with tenants. Inputs: tenant id, CreateTodo command, and session; output: a CreationResponse containing the event and resource location.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverinePost(\"/todoitems/{tenant}\")]\npublic static CreationResponse<TodoCreated> Create(\n    // Only need this to express the location of the newly created\n    // Todo object\n    string tenant,\n    CreateTodo command,\n    IDocumentSession session)\n{\n    var todo = new Todo { Name = command.Name };\n\n    // Marten itself sets the Todo.Id identity\n    // in this call\n    session.Store(todo);\n\n    // New syntax in Wolverine.HTTP 1.7\n    // Helps Wolverine\n    return CreationResponse.For(new TodoCreated(todo.Id), $\"/todoitems/{tenant}/{todo.Id}\");\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic MQTT Transport in Wolverine (C#)\nDESCRIPTION: Demonstrates the basic setup for using MQTT in Wolverine. It involves calling `UseMqtt()` within `UseWolverine` to configure the connection to the MQTT broker (server specified in configuration), setting options like maximum pending messages, listening to a specific topic (`app/incoming`) with a default message type (`Message1`) and Quality of Service (QoS), and configuring a rule to publish all messages to a designated topic (`app/outgoing`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n\nbuilder.UseWolverine(opts =>\n{\n    // Connect to the MQTT broker\n    opts.UseMqtt(mqtt =>\n    {\n        var mqttServer = builder.Configuration[\"mqtt_server\"];\n\n        mqtt\n            .WithMaxPendingMessages(3)\n            .WithClientOptions(client => { client.WithTcpServer(mqttServer); });\n    });\n\n    // Listen to an MQTT topic, and this could also be a wildcard\n    // pattern\n    opts.ListenToMqttTopic(\"app/incoming\")\n        // In the case of receiving JSON data, but\n        // not identifying metadata, tell Wolverine\n        // to assume the incoming message is this type\n        .DefaultIncomingMessage<Message1>()\n\n        // The default is AtLeastOnce\n        .QualityOfService(MqttQualityOfServiceLevel.AtMostOnce);\n\n    // Publish messages to an outbound topic\n    opts.PublishAllMessages()\n        .ToMqttTopic(\"app/outgoing\");\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Running the Wolverine Describe Command via Oakton (Bash)\nDESCRIPTION: This Bash command runs the .NET application, invoking the Wolverine `describe` command through Oakton. This command analyzes the application's configuration and outputs detailed reports about Wolverine options, listeners, message routing, sending endpoints, error handling, and potentially HTTP endpoints. Requires the .NET SDK and the compiled application with Wolverine and Oakton integrated.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/command-line.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- describe\n```\n\n----------------------------------------\n\nTITLE: Configuring Explicit Azure Service Bus Listener with Wolverine (C#)\nDESCRIPTION: This snippet demonstrates how to explicitly configure a Wolverine application to listen to a specific Azure Service Bus queue in C#. It retrieves the connection string from configuration, sets batching and buffering options for the listener, applies a circuit breaker, and initializes the application host. Key parameters include the connection string key ('azure-service-bus'), the queue name ('incoming'), and batch settings via 'MaximumMessagesToReceive' and 'MaximumWaitTime'. Requires access to Azure Service Bus and relevant NuGet packages for Wolverine. This setup enforces batch processing due to Azure Service Bus constraints.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/listening.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // One way or another, you're probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\");\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString).AutoProvision();\n\n    opts.ListenToAzureServiceBusQueue(\"incoming\")\n\n        // Customize how many messages to retrieve at one time\n        .MaximumMessagesToReceive(100)\n\n        // Customize how long the listener will wait for more messages before\n        // processing a batch\n        .MaximumWaitTime(3.Seconds())\n\n        // Add a circuit breaker for systematic failures\n        .CircuitBreaker()\n\n        // And all the normal Wolverine options you'd expect\n        .BufferedInMemory();\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Error Handling Policies Using WolverineOptions.Handlers - C#\nDESCRIPTION: Illustrates setting global exception handling rules on all message handlers using WolverineOptions.Handlers' Policies property. The configuration applies ScheduleRetry and MoveToErrorQueue behaviors for specific exception types such as TimeoutException, SecurityException, and SocketException, with optional message-based filters for granular policy control. Requires Host and UseWolverine setup, and the use of extension methods like 5.Seconds() for retry intervals.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Policies.OnException<TimeoutException>().ScheduleRetry(5.Seconds());\n        opts.Policies.OnException<SecurityException>().MoveToErrorQueue();\n\n        // You can also apply an additional filter on the\n        // exception type for finer grained policies\n        opts.Policies\n            .OnException<SocketException>(ex => ex.Message.Contains(\"not responding\"))\n            .ScheduleRetry(5.Seconds());\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Basic Wolverine Tracked Session Invocation in C#\nDESCRIPTION: Demonstrates the fundamental use of `InvokeMessageAndWaitAsync` to start a tracked session in a Wolverine integration test. It shows how to create an `IHost`, invoke a `DebitAccount` message, wait for all related processing (including potentially cascaded local messages) to complete, and then assert on messages sent during the session using the returned `TrackedSession` object.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\npublic async Task using_tracked_sessions()\n{\n    // The point here is just that you somehow have\n    // an IHost for your application\n    using var host = await Host.CreateDefaultBuilder()\n        .UseWolverine().StartAsync();\n\n    var debitAccount = new DebitAccount(111, 300);\n    var session = await host.InvokeMessageAndWaitAsync(debitAccount);\n\n    var overdrawn = session.Sent.SingleMessage<AccountOverdrawn>();\n    overdrawn.AccountId.ShouldBe(debitAccount.AccountId);\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Methods and Classes in Wolverine Handler Discovery (C#)\nDESCRIPTION: This snippet illustrates how to use the `[WolverineIgnore]` attribute in C# to prevent Wolverine from discovering specific methods or entire classes as message handlers. Applying the attribute to a method (like `NetflixHandler.Handles(MovieAdded added)`) ignores only that method, while applying it to a class (like `BlockbusterHandler`) ignores all methods within that class, even if they match naming conventions.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/discovery.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic class NetflixHandler : IMovieSink\n{\n    public void Listen(MovieAdded added)\n    {\n    }\n\n    public void Handles(IMovieEvent @event)\n    {\n    }\n\n    public void Handles(MovieEvent @event)\n    {\n    }\n\n    public void Consume(MovieAdded added)\n    {\n    }\n\n    // Only this method will be ignored as\n    // a handler method\n    [WolverineIgnore]\n    public void Handles(MovieAdded added)\n    {\n    }\n\n    public void Handle(MovieAdded message, IMessageContext context)\n    {\n    }\n\n    public static Task Handle(MovieRemoved removed)\n    {\n        return Task.CompletedTask;\n    }\n}\n\n// All methods on this class will be ignored\n// as handler methods even though the class\n// name matches the discovery naming conventions\n[WolverineIgnore]\npublic class BlockbusterHandler\n{\n    public void Handle(MovieAdded added)\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Middleware Globally via a Custom Handler Policy (C#)\nDESCRIPTION: Implements WrapWithSimple, an IHandlerPolicy that loops through all discovered handler chains and injects SimpleWrapper middleware. Intended for global middleware concerns such as logging, error handling, or telemetry in a Wolverine application. Requires SimpleWrapper middleware, the IHandlerPolicy contract, and is configured during the host's policy setup phase. Inputs are all registered HandlerChains and outputs are updated chains with additional middleware injected.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\npublic class WrapWithSimple : IHandlerPolicy\n{\n    public void Apply(IReadOnlyList<HandlerChain> chains, GenerationRules rules, IServiceContainer container)\n    {\n        foreach (var chain in chains) chain.Middleware.Add(new SimpleWrapper());\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Wolverine GCP Pub/Sub Connection (C#)\nDESCRIPTION: This snippet demonstrates the basic configuration required to connect a Wolverine application to GCP Pub/Sub. It uses the `UsePubsub` extension method, providing the GCP project ID. Optional methods `AutoProvision` and `AutoPurgeOnStartup` are shown to automatically create necessary topics/subscriptions and purge them on startup, respectively. This setup assumes running on Google Cloud or using Application Default Credentials (ADC).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/gcp-pubsub/index.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UsePubsub(\"your-project-id\")\n\n            // Let Wolverine create missing topics and subscriptions as necessary\n            .AutoProvision()\n\n            // Optionally purge all subscriptions on application startup.\n            // Warning though, this is potentially slow\n            .AutoPurgeOnStartup();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Composing Pre-Validation and Message Handling with HandlerContinuation in Wolverine (.NET C#)\nDESCRIPTION: Demonstrates a compound handler approach in Wolverine for .NET, where preliminary validation or data loading occurs before the primary business logic handler using HandlerContinuation. Dependencies include Wolverine, IDocumentSession, domain models (Order, Customer), and HandlerContinuation types. LoadAsync is an async step for retrieving entities and controlling flow; returning Stop halts further processing, while Continue passes retrieved data to the handler. Handle represents the main command handler yielding business events. Inputs are command objects and retrieved aggregates, outputs are resultant events or halt in processing. This keeps happy-path logic clean and testable; method names are convention-based but can be customized.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/railway-programming.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class ShipOrderHandler\n{\n    // This would be called first\n    public static async Task<(HandlerContinuation, Order?, Customer?)> LoadAsync(ShipOrder command, IDocumentSession session)\n    {\n        var order = await session.LoadAsync<Order>(command.OrderId);\n        if (order == null)\n        {\n            return (HandlerContinuation.Stop, null, null);\n        }\n\n        var customer = await session.LoadAsync<Customer>(command.CustomerId);\n\n        return (HandlerContinuation.Continue, order, customer);\n    }\n\n    // The main method becomes the \"happy path\", which also helps simplify it\n    public static IEnumerable<object> Handle(ShipOrder command, Order order, Customer customer)\n    {\n        // use the command data, plus the related Order & Customer data to\n        // \"decide\" what action to take next\n\n        yield return new MailOvernight(order.Id);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Marten Operations from Handler (C#)\nDESCRIPTION: Shows a Wolverine message handler returning multiple `IMartenOp` side effects by yielding them in an `IEnumerable<IMartenOp>`. The handler processes an `AppendManyNamedDocuments` command, iterating through names and yielding a `MartenOps.Store` operation for each new `NamedDocument`. Wolverine automatically executes all yielded `IMartenOp` side effects within the same transaction.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/operations.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// Just keep in mind that this \"example\" was rigged up for test coverage\npublic static IEnumerable<IMartenOp> Handle(AppendManyNamedDocuments command)\n{\n    var number = 1;\n    foreach (var name in command.Names)\n    {\n        yield return MartenOps.Store(new NamedDocument{Id = name, Number = number++});\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Error Handling with Attributes in Wolverine - C#\nDESCRIPTION: This snippet demonstrates assigning error handling strategies to a specific Wolverine message handler by decorating the handler method with attributes such as ScheduleRetry, RetryNow, RequeueOn, MoveToErrorQueueOn, and MaximumAttempts. These attributes define how exceptions like IOException, SqlException, InvalidOperationException, and DivideByZeroException are processed, including retry schedules and error queue behaviors. Requires the exception attribute classes, and the message handler is written for InvoiceCreated messages, enforcing a cap on processing attempts.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AttributeUsingHandler\n{\n    [ScheduleRetry(typeof(IOException), 5)]\n    [RetryNow(typeof(SqlException), 50, 100, 250)]\n    [RequeueOn(typeof(InvalidOperationException))]\n    [MoveToErrorQueueOn(typeof(DivideByZeroException))]\n    [MaximumAttempts(2)]\n    public void Handle(InvoiceCreated created)\n    {\n        // handle the invoice created message\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling OpenTelemetry Tracing with Wolverine in C#\nDESCRIPTION: This snippet configures OpenTelemetry tracing sources in a .NET application's service collection to instrument Wolverine and related system events. It requires the OpenTelemetry.Extensions.Hosting and OpenTelemetry.Exporter.Jaeger (or another exporter) NuGet packages. The builder registers OpenTelemetry for the application, labels the telemetry by service name, adds exporters, instrumentations, and importantly attaches Wolverine as a custom source for emitting activities. The configuration must occur during service wiring. Input: IServiceCollection instance. Output: Tracing data published to exporter endpoints (e.g., Jaeger).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n// builder.Services is an IServiceCollection object\\nbuilder.Services.AddOpenTelemetryTracing(x =>\\n{\\n    x.SetResourceBuilder(ResourceBuilder\\n            .CreateDefault()\\n            .AddService(\\\"OtelWebApi\\\")) // <-- sets service name\\n        .AddJaegerExporter()\\n        .AddAspNetCoreInstrumentation()\\n\\n        // This is absolutely necessary to collect the Wolverine\\n        // open telemetry tracing information in your application\\n        .AddSource(\\\"Wolverine\\\");\\n});\n```\n\n----------------------------------------\n\nTITLE: Using OutgoingMessages Collection for Cascading in Wolverine (C#)\nDESCRIPTION: Demonstrates returning an `OutgoingMessages` object from a handler to manage multiple cascaded messages. This approach allows using collection initializers and provides helper methods like `RespondToSender`, `Delay`, and `Schedule` to customize how and when specific messages within the collection are sent. It can improve clarity when handlers have complex output requirements.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// snippet: sample_using_OutgoingMessage\npublic static OutgoingMessages Handle(Incoming incoming)\n{\n    // You can use collection initializers for OutgoingMessages in C#\n    // as a shorthand.\n    var messages = new OutgoingMessages\n    {\n        new Message1(),\n        new Message2(),\n        new Message3(),\n    };\n\n    // Send a specific message back to the original sender\n    // of the incoming message\n    messages.RespondToSender(new Message4());\n\n    // Send a message with a 5 minute delay\n    messages.Delay(new Message5(), 5.Minutes());\n\n    // Schedule a message to be sent at a specific time\n    messages.Schedule(new Message5(), new DateTimeOffset(2023, 4, 5, 0, 0, 0, 0.Minutes()));\n\n    return messages;\n}\n// endSnippet\n```\n\n----------------------------------------\n\nTITLE: Directly Creating Wolverine Storage Actions in C#\nDESCRIPTION: This C# snippet shows an alternative way to create a storage side effect. Instead of using the static factory `Wolverine.Persistence.Storage`, it directly instantiates the `Insert<T>` class (where `T` is the entity type, like `Item`) to represent an insertion operation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/side-effects.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nreturn new Insert<Item>(new Item{});\n```\n\n----------------------------------------\n\nTITLE: Handling Message and Returning Direct Response in Wolverine (C#)\nDESCRIPTION: This C# snippet shows a simple Wolverine message handler class `CascadingHandler`. The `Consume` method takes `MyMessage` as input and directly returns an instance of `MyResponse`. In a request/reply scenario where the sender requested `MyResponse`, Wolverine automatically sends this returned object back to the original sender.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic class CascadingHandler\n{\n    public MyResponse Consume(MyMessage message)\n    {\n        return new MyResponse();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine for RabbitMQ Auto-Provisioning in C#\nDESCRIPTION: Shows how to configure a .NET host using Wolverine to interact with RabbitMQ. It uses `UseRabbitMq` to specify the connection, declares an exchange (\"exchange1\") and binds a queue (\"queue1\") to it with a routing key (\"key1\") using `DeclareExchange`. It enables `AutoProvision()` to automatically create these RabbitMQ objects if they don't exist at startup and configures all messages to be published to \"exchange1\".\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/object-management.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq(rabbit => { rabbit.HostName = \"localhost\"; })\n            // I'm declaring an exchange, a queue, and the binding\n            // key that we're referencing below.\n            // This is NOT MANDATORY, but rather just allows Wolverine to\n            // control the Rabbit MQ object lifecycle\n            .DeclareExchange(\"exchange1\", ex => { ex.BindQueue(\"queue1\", \"key1\"); })\n\n            // This will direct Wolverine to create any missing Rabbit MQ exchanges,\n            // queues, or binding keys declared in the application at application\n            // start up time\n            .AutoProvision();\n\n        opts.PublishAllMessages().ToRabbitExchange(\"exchange1\");\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Discovering Wolverine Message Types via Attribute in C#\nDESCRIPTION: This snippet shows an alternative method for Wolverine message type discovery using the `[WolverineMessage]` attribute. Applying this attribute to the `CloseIssue` record marks it as a message type for Wolverine's diagnostic discovery process, similar to using marker interfaces.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverineMessage]\npublic record CloseIssue(Guid Id);\n```\n\n----------------------------------------\n\nTITLE: Using Optional IResult for Validation in Wolverine Endpoints (C#)\nDESCRIPTION: Illustrates a compound endpoint `ValidatedCompoundEndpoint2` where a `Validate` method returns an optional `IResult` (`NotFound?`). If the loaded `User` is null, it returns `Results.NotFound<User>(user)`, stopping execution. If the user exists, it returns `null`, which Wolverine interprets as a signal to continue processing to the `Handle` method. This pattern allows conditional logic and influences OpenAPI metadata.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\npublic class ValidatedCompoundEndpoint2\n{\n    public static User? Load(BlockUser2 cmd)\n    {\n        return cmd.UserId.IsNotEmpty() ? new User(cmd.UserId) : null;\n    }\n\n    // This method would be called, and if the NotFound value is\n    // not null, will stop the rest of the processing\n    // Likewise, Wolverine will use the NotFound type to add\n    // OpenAPI metadata\n    public static NotFound? Validate(User? user)\n    {\n        if (user == null)\n            return (NotFound?)Results.NotFound<User>(user);\n\n        return null;\n    }\n\n    [WolverineDelete(\"/optional/result\")]\n    public static  string Handle(BlockUser2 cmd, User user)\n    {\n        return \"Ok - user blocked\";\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Topics and Subscriptions with Wolverine.AzureServiceBus in C#\nDESCRIPTION: This snippet demonstrates how to register endpoints for publishing to Azure Service Bus topics and listening to subscriptions within a .NET application using the Wolverine framework. It showcases auto-provisioning of topics and subscriptions, as well as optional custom configuration for these entities at startup. Key parameters include connection string, topic and subscription names, and topic/subscription configuration parameters such as MaxSizeInMegabytes and DefaultMessageTimeToLive. Dependencies include Wolverine, Wolverine.AzureServiceBus, and Host from .NET. The expected input is configuration values, and the output is a running host that sends and receives messages via Service Bus.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/topics.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAzureServiceBus(\"some connection string\")\n\n            // If this is part of your configuration, Wolverine will try to create\n            // any missing topics or subscriptions in the configuration at application\n            // start up time\n            .AutoProvision();\n\n        // Publish to a topic\n        opts.PublishMessage<Message1>().ToAzureServiceBusTopic(\"topic1\")\n\n            // Option to configure how the topic would be configured if\n            // built by Wolverine\n            .ConfigureTopic(topic =>\n            {\n                topic.MaxSizeInMegabytes = 100;\n            });\n\n        opts.ListenToAzureServiceBusSubscription(\"subscription1\", subscription =>\n            {\n                // Optionally alter how the subscription is created or configured in Azure Service Bus\n                subscription.DefaultMessageTimeToLive = 5.Minutes();\n            })\n            .FromTopic(\"topic1\", topic =>\n            {\n                // Optionally alter how the topic is created in Azure Service Bus\n                topic.DefaultMessageTimeToLive = 5.Minutes();\n            });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Listener-Only Rabbit MQ Connection in Wolverine C#\nDESCRIPTION: This snippet configures the Wolverine framework within a .NET Generic Host to use a Rabbit MQ transport in listener-only mode. The connection uses a URI for broker access and disables the sender connection to conserve resources when only incoming messages are processed. The 'incoming2' queue is fine-tuned with options like automatic purging on startup and message TTL. Required dependencies include WolverineFX.RabbitMQ and access to a Rabbit MQ broker via URI. The StartAsync method begins message processing upon host startup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/index.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // *A* way to configure Rabbit MQ using their Uri schema\n        // documented here: https://www.rabbitmq.com/uri-spec.html\n        opts.UseRabbitMq(new Uri(\"amqp://localhost\"))\n\n            // Turn on listener connection only in case if you only need to listen for messages\n            // The sender connection won't be activated in this case\n            .UseListenerConnectionOnly();\n\n        // Set up a listener for a queue, but also\n        // fine-tune the queue characteristics if Wolverine\n        // will be governing the queue setup\n        opts.ListenToRabbitQueue(\"incoming2\", q =>\n        {\n            q.PurgeOnStartup = true;\n            q.TimeToLive(5.Minutes());\n        });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Handling Messages with a Specific Marten Store in Wolverine (C#)\nDESCRIPTION: Demonstrates the use of the [MartenStore(typeof(IPlayerStore))] attribute to tag a Wolverine message handler so that it uses a session from the IPlayerStore interface rather than the default store. The handler static class returns a Marten side effect for storing a Player object, showing how ancillary stores are referenced in dependency-injected handlers. Requires Wolverine, Marten, explicit store configuration, and proper type definitions for PlayerMessage and Player.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/ancillary-stores.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// This will use a Marten session from the\n// IPlayerStore rather than the main IDocumentStore\n[MartenStore(typeof(IPlayerStore))]\npublic static class PlayerMessageHandler\n{\n    // Using a Marten side effect just like normal\n    public static IMartenOp Handle(PlayerMessage message)\n    {\n        return MartenOps.Store(new Player{Id = message.Id});\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Cascading Messages via IEnumerable in Wolverine (C#)\nDESCRIPTION: This C# snippet shows a `MultipleResponseHandler` that returns multiple cascading messages from a single handler method. By returning `IEnumerable<object>` (using `yield return`), Wolverine treats each yielded object as a separate cascading message. This example yields a `GoNorth` message for immediate processing and a `GoWest` message scheduled for one hour later using Wolverine's extension methods.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npublic class MultipleResponseHandler\n{\n    public IEnumerable<object> Consume(MyMessage message)\n    {\n        // Go North now\n        yield return new GoNorth();\n\n        // Go West in an hour\n        yield return new GoWest().DelayedFor(1.Hours());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Newtonsoft.Json Serialization in Wolverine (C#)\nDESCRIPTION: Configures the Wolverine host to use Newtonsoft.Json with custom settings, such as allowing non-public default constructors. Prerequisites include referencing Wolverine, Newtonsoft.Json, and a properly configured HostBuilder. The 'UseNewtonsoftForSerialization' lambda provides an entry point for manipulating JsonSerializerSettings before serialization is used.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseNewtonsoftForSerialization(settings =>\n        {\n            settings.ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor;\n        });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Disabling Wolverine Transports in Integration Tests using Alba & WebApplicationFactory - C#\nDESCRIPTION: Illustrates disabling all Wolverine external transports in a real-world integration test using the Alba testing framework and WebApplicationFactory. The sample demonstrates how to override services (services.DisableAllExternalWolverineTransports()) while bootstrapping a production application host to run entirely in-memory for testing purposes. Prerequisites: Alba, Wolverine, testable ASP.NET Core applications, and WebApplicationFactory. Input: test context; Output: in-memory IHost suitable for testing message handlers without any real transport endpoints enabled.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\n// This is using Alba to bootstrap a Wolverine application\\n// for integration tests, but it's using WebApplicationFactory\\n// to do the actual bootstrapping\\nawait using var host = await AlbaHost.For<Program>(x =>\\n{\\n    // I'm overriding\\n    x.ConfigureServices(services => services.DisableAllExternalWolverineTransports());\\n});\n```\n\n----------------------------------------\n\nTITLE: Transactional Handler Using IAsyncDocumentSession Dependency (C#)\nDESCRIPTION: This C# handler demonstrates an alternative to explicit [Transactional] attributes. If a message handler (or HTTP endpoint) has an IAsyncDocumentSession parameter, Wolverine's transactional middleware is automatically applied (assuming the 'AutoApplyTransactions' policy is enabled). The example stores a new 'FakeDoc' document using RavenDb's async session.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/ravendb.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic class AlternativeCreateDocCommandHandler\n{\n    // Auto transactions would kick in just because of the dependency\n    // on IAsyncDocumentSession\n    public async Task Handle(CreateDocCommand message, IAsyncDocumentSession session)\n    {\n        await session.StoreAsync(new FakeDoc { Id = message.Id });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages to a RabbitMQ Exchange using Wolverine in C#\nDESCRIPTION: This C# code configures Wolverine within a .NET Host to publish messages to a RabbitMQ exchange. It first sets up the connection using `UseRabbitMq()` and then directs all messages to \"exchange1\" using `PublishAllMessages().ToRabbitExchange(\"exchange1\")`. Additionally, it demonstrates how to fine-tune exchange properties (like setting `ExchangeType` to `Direct` instead of the default `Fanout`) and declare bindings programmatically (binding \"queue1\" to \"exchange2\" with a specific key) when publishing to another exchange \"exchange2\".\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/publishing.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Connect to an unsecured, local Rabbit MQ broker\n        // at port 5672\n        opts.UseRabbitMq();\n\n        opts.PublishAllMessages().ToRabbitExchange(\"exchange1\");\n\n        // fine-tune the exchange characteristics if Wolverine\n        // will be governing the queue setup\n        opts.PublishAllMessages().ToRabbitExchange(\"exchange2\", e =>\n        {\n            // Default is Fanout, so overriding that here\n            e.ExchangeType = ExchangeType.Direct;\n\n            // If you want, you can also create binding here too\n            e.BindQueue(\"queue1\", \"exchange2ToQueue1\");\n        });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining a Versioned Message Type with MessageIdentity in Wolverine (C#)\nDESCRIPTION: Shows how to define a versioned message class (PersonBornV2) with a MessageIdentity attribute indicating its name and version. The class structure must match the expected properties for use by serializers or handlers and acts as the 'current' version in message forwarding. Assumes the existence of the MessageIdentity attribute and corresponding message handling infrastructure.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n[MessageIdentity(\"person-born\", Version = 2)]\npublic class PersonBornV2\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    public DateTime Birthday { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Responding Directly to Sender in Wolverine Handler (C#)\nDESCRIPTION: This C# snippet demonstrates how a message handler can send a response message directly back to the original sender of the incoming message. The `Handle` method processes a `PingMessage` and constructs a `PongMessage`. It then uses `Respond.ToSender(pong)` as the return value, instructing Wolverine to route the `PongMessage` specifically to the service that sent the initial `PingMessage`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\npublic object Handle(PingMessage message)\n{\n    var pong = new PongMessage { Id = message.Id };\n\n    // This will send the pong message back\n    // to the original sender of the PingMessage\n    return Respond.ToSender(pong);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Parameter Strategy for Current Time in Wolverine C#\nDESCRIPTION: Provides a concrete implementation of `IParameterStrategy` called `NowParameterStrategy`. This strategy checks if an endpoint method parameter is named \"now\" and has the type `DateTimeOffset`. If both conditions are met, it configures Wolverine's code generation to supply `DateTimeOffset.UtcNow` for that parameter, effectively injecting the current system time. Requires `Wolverine.Http.CodeGen`, `Lamar`, and `System.Reflection` namespaces.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npublic class NowParameterStrategy : IParameterStrategy\n{\n    public bool TryMatch(HttpChain chain, IServiceContainer container, ParameterInfo parameter, out Variable? variable)\n    {\n        if (parameter.Name == \"now\" && parameter.ParameterType == typeof(DateTimeOffset))\n        {\n            // This is tying into Wolverine's code generation model\n            variable = new Variable(typeof(DateTimeOffset),\n                $\"{typeof(DateTimeOffset).FullNameInCode()}.{nameof(DateTimeOffset.UtcNow)}\");\n            return true;\n        }\n\n        variable = default;\n        return false;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine HTTP with Fluent Validation Middleware in C#\nDESCRIPTION: This C# snippet demonstrates how to configure Wolverine HTTP endpoints within an ASP.NET Core application. It shows the usage of `MapWolverineEndpoints` to apply configurations, including adding custom metadata and enabling the Fluent Validation middleware using `opts.UseFluentValidationProblemDetailMiddleware()`. This middleware automatically validates request types based on registered Fluent Validation validators.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/fluentvalidation.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\napp.MapWolverineEndpoints(opts =>\n{\n    // This is strictly to test the endpoint policy\n\n    opts.ConfigureEndpoints(httpChain =>\n    {\n        // The HttpChain model is a configuration time\n        // model of how the HTTP endpoint handles requests\n\n        // This adds metadata for OpenAPI\n        httpChain.WithMetadata(new CustomMetadata());\n    });\n\n    // more configuration for HTTP...\n\n    // Opting into the Fluent Validation middleware from\n    // Wolverine.Http.FluentValidation\n    opts.UseFluentValidationProblemDetailMiddleware();\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Messages to Specific MQTT Topics with IMessageBus (C#)\nDESCRIPTION: Illustrates how to explicitly publish a specific message object (`paymentMade`) to a named MQTT topic (`region/europe/incoming`) at runtime using the `BroadcastToTopicAsync` method available on the `IMessageBus` interface. This requires the MQTT transport to be enabled in the application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic static async Task broadcast(IMessageBus bus)\n{\n    var paymentMade = new PaymentMade(200, \"EUR\");\n    await bus.BroadcastToTopicAsync(\"region/europe/incoming\", paymentMade);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding WolverineFx.Http.Marten package via dotnet CLI - Bash\nDESCRIPTION: This snippet shows the shell command to add the WolverineFx.Http.Marten NuGet package required for Marten integration in Wolverine.HTTP projects. Execute this in your .NET project directory. The dependency is necessary before using any Marten-enhanced HTTP endpoint features.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package WolverineFx.Http.Marten\n```\n\n----------------------------------------\n\nTITLE: Example Output of Oakton Help Command (Bash)\nDESCRIPTION: This snippet shows the typical console output when running the `dotnet run -- help` command on a Wolverine application integrated with Oakton. It lists the available commands, including standard Oakton commands (`run`, `help`) and Wolverine-specific diagnostic and management commands (`describe`, `storage`, `resources`, `codegen`). No execution dependencies, represents command output.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/command-line.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nThe available commands are:\n                                                                                                    \n  Alias       Description                                                                           \n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n  check-env   Execute all environment checks against the application                                \n  codegen     Utilities for working with JasperFx.CodeGeneration and JasperFx.RuntimeCompiler       \n  describe    Writes out a description of your running application to either the console or a file  \n  help        List all the available commands                                                       \n  resources   Check, setup, or teardown stateful resources of this system                           \n  run         Start and run this .Net application                                                   \n  storage     Administer the Wolverine message storage                                                       \n                                                                                                    \n\nUse dotnet run -- ? [command name] or dotnet run -- help [command name] to see usage help about a specific command\n\n```\n\n----------------------------------------\n\nTITLE: Adding OpenAPI Metadata with ASP.NET Core Attributes and Wolverine WebApi - C#\nDESCRIPTION: This snippet demonstrates the use of ASP.Net Core and Wolverine attributes to decorate an HTTP endpoint method, thereby adding OpenAPI metadata. It utilizes standard attributes like [Tags] and [ProducesResponseType], in combination with a Wolverine route attribute, to declaratively define API groupings and response codes. The method is intended for registering a sign-up endpoint and expects a request body of type SignUpRequest, returning a 204 No Content result. Requires ASP.Net Core, Wolverine.WebApi and proper attribute referenced types.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/metadata.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SignupEndpoint\n{\n    // The first couple attributes are ASP.Net Core\n    // attributes that add OpenAPI metadata to this endpoint\n    [Tags(\"Users\")]\n    [ProducesResponseType(204)]\n    [WolverinePost(\"/users/sign-up\")]\n    public static IResult SignUp(SignUpRequest request)\n    {\n        return Results.NoContent();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Message Publishing to GCP Pub/Sub Topics with Wolverine - C#\nDESCRIPTION: This snippet demonstrates how to configure a Wolverine application in C# to publish specific message types to designated Google Cloud Pub/Sub topics using the ToPubsubTopic() extension method. It sets up two message types, assigns each to a different Pub/Sub topic, and shows how to specify message retention settings for an individual topic. Dependencies include the Wolverine framework, Google.Cloud.PubSub.V1, and the Google.Protobuf.WellKnownTypes.Duration type. Input includes message type classes and project/topic names; outputs are outbound messages routed to configured Pub/Sub topics. Retention options and Pub/Sub credentials must be set appropriately.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/gcp-pubsub/publishing.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UsePubsub(\"your-project-id\");\n\n        opts\n            .PublishMessage<Message1>()\n            .ToPubsubTopic(\"outbound1\");\n\n        opts\n            .PublishMessage<Message2>()\n            .ToPubsubTopic(\"outbound2\")\n            .ConfigurePubsubTopic(options =>\n            {\n                options.MessageRetentionDuration =\n                    Duration.FromTimeSpan(TimeSpan.FromMinutes(10));\n            });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing VSA AddToCart with Wolverine HTTP Endpoint in C#\nDESCRIPTION: Illustrates a lower-ceremony Vertical Slice Architecture approach using Wolverine.HTTP for an 'Add to Cart' feature. It defines a static endpoint class `AddToCartRequestEndpoint` with a `Post` method decorated with `[WolverinePost]` to handle HTTP POST requests. The method directly takes the `AddToCartRequest`, uses Wolverine's `[Entity]` attribute for automatic `Cart` entity loading, performs the add operation, and returns a Wolverine `Storage` command (`Update` or `Nothing`) to manage persistence, eliminating the need for separate MediatR handlers or controllers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/from-mediatr.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class AddToCartRequestEndpoint\n{\n    // Remember, we can do validation in middleware, or\n    // even do a custom Validate() : ProblemDetails method\n    // to act as a filter so the main method is the happy path\n    \n    [WolverinePost(\"/api/cart/add\")]\n    public static Update<Cart> Post(\n        AddToCartRequest request, \n        \n        // See \n        [Entity] Cart cart)\n    {\n        return cart.TryAddRequest(request) ? Storage.Update(cart) : Storage.Nothing(cart);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Registering Middleware by Command Message Type in Wolverine - C#\nDESCRIPTION: Configures Wolverine to apply the AccountLookupMiddleware to all message handlers processing commands implementing IAccountCommand. Demonstrates how to register middleware, add FluentValidation, configure explicit routing for AccountUpdated messages, and set delivery/queue options. Assumes builder and Wolverine options are available; intended for registration at application startup. Uses Marten and Wolverine APIs.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/middleware.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Host.UseWolverine(opts =>\n{\n    // This middleware should be applied to all handlers where the\n    // command type implements the IAccountCommand interface that is the\n    // \"detected\" message type of the middleware\n    opts.Policies.ForMessagesOfType<IAccountCommand>().AddMiddleware(typeof(AccountLookupMiddleware));\n\n    opts.UseFluentValidation();\n\n    // Explicit routing for the AccountUpdated\n    // message handling. This has precedence over conventional routing\n    opts.PublishMessage<AccountUpdated>()\n        .ToLocalQueue(\"signalr\")\n\n        // Throw the message away if it's not successfully\n        // delivered within 10 seconds\n        .DeliverWithin(10.Seconds())\n\n        // Not durable\n        .BufferedInMemory();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten Event Publishing to Wolverine Subscribers in C#\nDESCRIPTION: This snippet demonstrates configuring a .NET host to integrate Marten and Wolverine for event publishing using the PublishEventsToWolverine API. It sets up Marten's async daemon in HotCold mode, specifies database connection via dependency injection, and shows how to publish all or filtered event streams to Wolverine subscribers by event type. Dependencies include .NET Host, Wolverine, Marten, and a configured Npgsql data source. Parameters include relay filters that allow for event stream type and subscription position control. The code outputs an active host instance with event publishing enabled and may be constrained by the need for the async daemon to be running.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/subscriptions.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Services\n            .AddMarten()\n\n            // Just pulling the connection information from\n            // the IoC container at runtime.\n            .UseNpgsqlDataSource()\n\n            // You don't absolutely have to have the Wolverine\n            // integration active here for subscriptions, but it's\n            // more than likely that you will want this anyway\n            .IntegrateWithWolverine()\n\n            // The Marten async daemon most be active\n            .AddAsyncDaemon(DaemonMode.HotCold)\n\n            // This would attempt to publish every non-archived event\n            // from Marten to Wolverine subscribers\n            .PublishEventsToWolverine(\"Everything\")\n\n            // You wouldn't do this *and* the above option, but just to show\n            // the filtering\n            .PublishEventsToWolverine(\"Orders\", relay =>\n            {\n                // Filtering\n                relay.FilterIncomingEventsOnStreamType(typeof(Order));\n\n                // Optionally, tell Marten to only subscribe to new\n                // events whenever this subscription is first activated\n                relay.Options.SubscribeFromPresent();\n            });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Stopwatch Middleware Frame in JasperFx.CodeGeneration (C#)\nDESCRIPTION: Defines a custom SyncFrame called StopwatchFrame that injects timing logic into a Wolverine or JasperFx chain via code generation. It starts and stops a Stopwatch instance around the handler execution, logging duration using ILogger. Requires JasperFx.CodeGeneration, a logger dependency injected at runtime, and access to IChain and supporting variable resolution. Inputs are the chain and code generation context, and outputs generated code that wraps the handler. The frame exposes the stopwatch variable for use by other code, with the constraint that it must be added to a chain for activation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\npublic class StopwatchFrame : SyncFrame\n{\n    private readonly IChain _chain;\n    private readonly Variable _stopwatch;\n    private Variable _logger;\n\n    public StopwatchFrame(IChain chain)\n    {\n        _chain = chain;\n\n        // This frame creates a Stopwatch, so we\n        // expose that fact to the rest of the generated method\n        // just in case someone else wants that\n        _stopwatch = new Variable(typeof(Stopwatch), \"stopwatch\", this);\n    }\n\n    public override void GenerateCode(GeneratedMethod method, ISourceWriter writer)\n    {\n        writer.Write($\"var stopwatch = new {typeof(Stopwatch).FullNameInCode()}();\");\n        writer.Write(\"stopwatch.Start();\");\n\n        writer.Write(\"BLOCK:try\");\n        Next?.GenerateCode(method, writer);\n        writer.FinishBlock();\n\n        // Write a finally block where you record the stopwatch\n        writer.Write(\"BLOCK:finally\");\n\n        writer.Write(\"stopwatch.Stop();\");\n        writer.Write(\n            $\"{_logger.Usage}.Log(Microsoft.Extensions.Logging.LogLevel.Information, \\\"{_chain.Description} ran in \\\" + {_stopwatch.Usage}.{nameof(Stopwatch.ElapsedMilliseconds)});)\");\n\n        writer.FinishBlock();\n    }\n\n    public override IEnumerable<Variable> FindVariables(IMethodVariables chain)\n    {\n        // This in effect turns into \\\"I need ILogger<message type> injected into the\n        // compiled class\\\"\n        _logger = chain.FindVariable(typeof(ILogger));\n        yield return _logger;\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Disabling All Wolverine Transports via IServiceCollection - C#\nDESCRIPTION: Shows an alternative approach to disabling Wolverine external transports by directly modifying IServiceCollection using the 'DisableAllExternalWolverineTransports' extension. This method ensures all Wolverine transports and message broker connections are stubbed for fully local operation. It integrates into the startup chain using 'ConfigureServices' and does not require environment checks, making it suitable for test projects or any code wanting to forcibly avoid external message interactions. Requires Wolverine and .NET Generic Host libraries. Input: standard service collection; Output: a completely stubbed-in-memory Wolverine host.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\\n    .UseWolverine(opts =>\\n    {\\n        // do whatever you need to configure Wolverine\\n    })\\n\\n    // Override the Wolverine configuration to disable all\\n    // external transports, broker connectivity, and incoming/outgoing\\n    // messages to run completely locally\\n    .ConfigureServices(services => services.DisableAllExternalWolverineTransports())\\n\\n    .StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing Organization Tagging Middleware for Message Metrics in Wolverine .NET\nDESCRIPTION: This snippet provides a C# implementation for tagging metrics with an organization code based on a marker interface (`IOrganizationRelated`). It defines the interface and static middleware that inspects messages to add the 'org.code' tag using `Envelope.SetMetricsTag`. Requires implementing this interface on relevant messages and integrating the middleware into Wolverine policies. Inputs are any message implementing `IOrganizationRelated` and its context envelope; output is a message with an associated metrics tag for organization correlation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n// Common interface on message types within our system\npublic interface IOrganizationRelated\n{\n    string OrganizationCode { get; }\n}\n\n// Middleware just to add a metrics tag for the organization code\npublic static class OrganizationTaggingMiddleware\n{\n    public static void Before(IOrganizationRelated command, Envelope envelope)\n    {\n        envelope.SetMetricsTag(\"org.code\", command.OrganizationCode);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Updated Marten Aggregate from Wolverine HTTP Endpoint in C#\nDESCRIPTION: Defines a Wolverine HTTP POST endpoint using `[AggregateHandler]` and `[WolverinePost]`. The `ConfirmDifferent` method processes a `ConfirmOrder` command for an `Order`. It returns a tuple containing `UpdatedAggregate` and an `Events` collection with `OrderConfirmed`. The `UpdatedAggregate` marker signals Wolverine to fetch the latest projected state of the `Order` aggregate after applying the event and return it as the HTTP response body.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n[AggregateHandler]\n[WolverinePost(\"/orders/{id}/confirm2\")]\n// The updated version of the Order aggregate will be returned as the response body\n// from requesting this endpoint at runtime\npublic static (UpdatedAggregate, Events) ConfirmDifferent(ConfirmOrder command, Order order)\n{\n    return (\n        new UpdatedAggregate(),\n        [new OrderConfirmed()]\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting IMessageBus into Wolverine Handlers via Constructor in C#\nDESCRIPTION: Shows an alternative method for providing an `IMessageBus` instance to a message handler class using constructor injection. While method injection is generally preferred, this pattern is acceptable for those accustomed to traditional .NET dependency injection practices.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/best-practices.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyMessageHandler\n{\n    private readonly IMessageBus _messageBus;\n\n    public MyMessageHandler(IMessageBus messageBus)\n    {\n        _messageBus = messageBus;\n    }\n    \n    public async Task HandleAsync(MyMessage message)\n    {\n         // handle the message..;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling and Responding to PingMessage with Dependency Injection (C#)\nDESCRIPTION: This example demonstrates a static handler for PingMessage that utilizes dependency injection to access IMessageContext. The handler logs the received ping using AnsiConsole and creates a PongMessage as a reply, leveraging context.RespondToSenderAsync to return the result. All dependencies (IMessageContext, PingMessage) are injected at runtime. Expected input is a PingMessage; output is a PongMessage returned to the original sender. Comments explain how method injection and headers are used for routing responses.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic static class PingHandler\n{\n    // Simple message handler for the PingMessage message type\n    public static ValueTask Handle(\n        // The first argument is assumed to be the message type\n        PingMessage message,\n\n        // Wolverine supports method injection similar to ASP.Net Core MVC\n        // In this case though, IMessageContext is scoped to the message\n        // being handled\n        IMessageContext context)\n    {\n        AnsiConsole.MarkupLine($\"[blue]Got ping #{message.Number}[/]\");\n\n        var response = new PongMessage\n        {\n            Number = message.Number\n        };\n\n        // This usage will send the response message\n        // back to the original sender. Wolverine uses message\n        // headers to embed the reply address for exactly\n        // this use case\n        return context.RespondToSenderAsync(response);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Sender-Only Rabbit MQ Connection in Wolverine C#\nDESCRIPTION: This code sample shows how to configure Wolverine's Rabbit MQ transport in sender-only mode using a .NET Host. It establishes a sender connection to the broker via URI while disabling the listener to conserve Rabbit MQ connections where only message sending (no receiving) is needed. The configuration for the 'incoming2' queue is included for completeness, although the sender-only setup means the listener connection is not activated. The system requires the WolverineFX.RabbitMQ library and network access to the Rabbit MQ broker.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/index.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // *A* way to configure Rabbit MQ using their Uri schema\n        // documented here: https://www.rabbitmq.com/uri-spec.html\n        opts.UseRabbitMq(new Uri(\"amqp://localhost\"))\n\n            // Turn on sender connection only in case if you only need to send messages\n            // The listener connection won't be created in this case\n            .UseSenderConnectionOnly();\n\n        // Set up a listener for a queue, but also\n        // fine-tune the queue characteristics if Wolverine\n        // will be governing the queue setup\n        opts.ListenToRabbitQueue(\"incoming2\", q =>\n        {\n            q.PurgeOnStartup = true;\n            q.TimeToLive(5.Minutes());\n        });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining ITenantDetection Interface for Custom Strategies - C#\nDESCRIPTION: This snippet provides the definition of the ITenantDetection interface, which allows for custom strategies to detect the tenant id from an HttpContext. Implementers must provide the DetectTenant method returning a ValueTask<string?>. This interface is essential when the default detection mechanisms are insufficient. Dependencies include ASP.NET Core's HttpContext type and support for async ValueTask results.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>\n/// Used to create new strategies to detect the tenant id from an HttpContext\n/// for the current request\n/// </summary>\npublic interface ITenantDetection\n{\n    /// <summary>\n    /// This method can return the actual tenant id or null to represent \"not found\"\n    /// </summary>\n    /// <param name=\"context\"></param>\n    /// <returns></returns>\n    public ValueTask<string?> DetectTenant(HttpContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Disabling Wolverine External Transports - C#\nDESCRIPTION: Demonstrates how to conditionally disable all Wolverine external transports within a .NET host setup based on the application environment. This approach uses a runtime check for the environment ('Development' in this example), and if matched, it calls 'StubAllExternalTransports' to ensure Wolverine does not listen to or interact with outside message brokers or transports. Prerequisites include the Wolverine library, .NET hosting APIs, and knowledge of application environment management. Inputs: application environment; Output: an IHost with Wolverine transports disabled if the condition is met. Useful for automated or local development/testing scenarios where external dependencies are undesirable.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\\nbuilder.UseWolverine(opts =>\\n{\\n    // Other configuration...\\n\\n    // IF the environment is \\\"Testing\\\", turn off all external transports\\n    if (builder.Environment.IsDevelopment())\\n    {\\n        opts.StubAllExternalTransports();\\n    }\\n});\\n\\nusing var host = builder.Build();\\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Setting Up Buffered In-Memory Endpoints in Wolverine with Azure Service Bus (C#)\nDESCRIPTION: This snippet sets up a buffered in-memory endpoint for receiving messages from an Azure Service Bus queue in Wolverine, showcasing how to override buffering limits for back pressure control. The required dependencies are the Wolverine framework, Azure Service Bus configuration, and a 'BufferingLimits' object specifying the local buffer capacity. Inputs are the queue name ('incoming') and custom buffering thresholds, and the output is an endpoint that queues messages locally before delivery to handlers, potentially increasing throughput but risking loss on shutdown.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/runtime.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// I overrode the buffering limits just to show\\n// that they exist for \"back pressure\"\\nopts.ListenToAzureServiceBusQueue(\"incoming\")\\n    .BufferedInMemory(new BufferingLimits(1000, 200));\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Transactional Outbox and Durable Local Queues in C#\nDESCRIPTION: This snippet shows how to configure Wolverine within a .NET application's host builder. It enables the automatic application of transactional boundaries to handlers and configures the use of durable local queues for message persistence, ensuring messages are not lost during processing failures.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Host.UseWolverine(opts =>\n{\n    // Other Wolverine configuration...\n    \n    opts.Policies.AutoApplyTransactions();\n    opts.Policies.UseDurableLocalQueues();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Fluent Validation Middleware for Wolverine HTTP (C#)\nDESCRIPTION: Shows a static method `ExecuteOne` within the `FluentValidationHttpExecutor` class. This method asynchronously validates a message of type `T` using an `IValidator<T>`. If validation errors occur, it creates a `ProblemDetails` result using `IProblemDetailSource<T>` and returns `Results.Problem(details)` (an `IResult`) to stop processing. Otherwise, it returns `WolverineContinue.Result()` to proceed.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n[MethodImpl(MethodImplOptions.AggressiveInlining)]\npublic static async Task<IResult> ExecuteOne<T>(IValidator<T> validator, IProblemDetailSource<T> source, T message)\n{\n    // First, validate the incoming request of type T\n    var result = await validator.ValidateAsync(message);\n\n    // If there are any errors, create a ProblemDetails result and return\n    // that to write out the validation errors and otherwise stop processing\n    if (result.Errors.Any())\n    {\n        var details = source.Create(message, result.Errors);\n        return Results.Problem(details);\n    }\n\n    // Everything is good, full steam ahead!\n    return WolverineContinue.Result();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Tenant-Aware Wolverine HTTP Endpoint (C#)\nDESCRIPTION: This C# snippet defines an HTTP GET endpoint using Wolverine. The `[WolverineGet(\"/todoitems/{tenant}\")]` attribute maps the endpoint to a URL containing a tenant identifier as a route argument. The handler method takes the `tenant` string and an `IQuerySession` (provided by Marten via Wolverine's integration) as parameters to query `Todo` items specific to the current tenant's database.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n// The \"tenant\" route argument would be the route\n[WolverineGet(\"/todoitems/{tenant}\")]\npublic static Task<IReadOnlyList<Todo>> Get(string tenant, IQuerySession session)\n{\n    return session.Query<Todo>().ToListAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing a Message using IMessageContext in Wolverine C#\nDESCRIPTION: This C# method shows how to publish a message using Wolverine's `IMessageContext`. It creates an `InvoiceCreated` event and publishes it using `bus.PublishAsync(@event)`. Unlike `SendAsync`, the `PublishAsync` method will only send the message if there are known subscribers for the `InvoiceCreated` type. If no subscribers are found, the message is silently ignored, and no exception is thrown. This relies on dependency injection for the `IMessageContext`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\npublic ValueTask PublishMessage(IMessageContext bus)\n{\n    // In this case, we're sending an \"InvoiceCreated\"\n    // message\n    var @event = new InvoiceCreated\n    {\n        Time = DateTimeOffset.Now,\n        Purchaser = \"Guy Fieri\",\n        Amount = 112.34,\n        Item = \"Cookbook\"\n    };\n\n    return bus.PublishAsync(@event);\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Request/Response Message Handling with Response Type (C#)\nDESCRIPTION: Illustrates the use of IMessageBus.InvokeAsync<T> to synchronously request a result from a message handler in Wolverine, where T is the expected response type. Requires an IMessageBus instance and defined Numbers/Results message contracts. Inputs include a message (Numbers), and the output is a Results object populated by the handler. Demonstrates how request/reply is handled using asynchronous code.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task invoke_math_operations(IMessageBus bus)\\n{\\n    var results = await bus.InvokeAsync<Results>(new Numbers(3, 4));\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SQL Server Persistence with EF Core Middleware in Wolverine (C#)\nDESCRIPTION: Configures Wolverine within a .NET HostBuilder to use SQL Server for message persistence via `PersistMessagesWithSqlServer()`, specifying the connection string and schema name. It also integrates Entity Framework Core for transactional middleware using `UseEntityFrameworkCoreTransactions()` and enables durable processing for all local queues with `UseDurableLocalQueues()`. Requires the `WolverineFx.SqlServer` package.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sqlserver.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n<!-- snippet: sample_registering_efcore_middleware -->\n<a id='snippet-sample_registering_efcore_middleware'></a>\n```cs\nbuilder.Host.UseWolverine(opts =>\n{\n    // Setting up Sql Server-backed message storage\n    // This requires a reference to Wolverine.SqlServer\n    opts.PersistMessagesWithSqlServer(connectionString, \"wolverine\");\n\n    // Set up Entity Framework Core as the support\n    // for Wolverine's transactional middleware\n    opts.UseEntityFrameworkCoreTransactions();\n\n    // Enrolling all local queues into the\n    // durable inbox/outbox processing\n    opts.Policies.UseDurableLocalQueues();\n});\n```\n<sup><a href='https://github.com/JasperFx/wolverine/blob/main/src/Samples/EFCoreSample/ItemService/Program.cs#L36-L53' title='Snippet source file'>snippet source</a> | <a href='#snippet-sample_registering_efcore_middleware' title='Start of snippet'>anchor</a></sup>\n<!-- endSnippet -->\n```\n\n----------------------------------------\n\nTITLE: Disabling Remote Invocation in Wolverine C#\nDESCRIPTION: This snippet demonstrates how to configure Wolverine within a .NET Host application to disable remote message invocation. By setting `opts.EnableRemoteInvocation = false` inside the `UseWolverine` configuration lambda, any attempt to use `IMessageBus.InvokeAsync()` or `IMessageBus.InvokeAsync<T>()` for a remote operation will result in an `InvalidOperationException` instead of attempting the remote call. This requires the `Microsoft.Extensions.Hosting` and `Wolverine` NuGet packages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // This will disallow Wolverine from making remote calls\n        // through IMessageBus.InvokeAsync() or InvokeAsync<T>()\n        // Instead, Wolverine will throw an InvalidOperationException\n        opts.EnableRemoteInvocation = false;\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Applying HTTP Policy Explicitly in Wolverine.Http using C#\nDESCRIPTION: Demonstrates how to explicitly register an `IHttpPolicy` implementation (like `RequestIdPolicy`) with Wolverine's HTTP endpoint configuration. Within the `MapWolverineEndpoints` configuration action, `opts.AddPolicy<RequestIdPolicy>()` is called to ensure the policy is applied during endpoint discovery and generation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n// app is a WebApplication\napp.MapWolverineEndpoints(opts =>\n{\n    // add the policy to Wolverine HTTP endpoints\n    opts.AddPolicy<RequestIdPolicy>();\n});\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Tenant Detection Strategy in Wolverine - C#\nDESCRIPTION: This snippet demonstrates how to register a custom ITenantDetection strategy with Wolverine endpoints. You can either inject an instance directly with opts.TenantId.DetectWith or register a type for the IoC container to resolve by opts.TenantId.DetectWith<T>(). No explicit registration is required if dependencies are resolvable by the IoC container, which in Wolverine is Lamar. Inputs are endpoint options; the effect is to configure tenant detection globally for the application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\napp.MapWolverineEndpoints(opts =>\n{\n    // If your strategy does not need any IoC service\n    // dependencies, just add it directly\n    opts.TenantId.DetectWith(new MyCustomTenantDetection());\n\n    // In this case, your detection type will be built by\n    // the underlying IoC container for your application\n    // No other registration is necessary here for the strategy\n    // itself\n    opts.TenantId.DetectWith<MyCustomTenantDetection>();\n});\n```\n\n----------------------------------------\n\nTITLE: Moving Messages to Error Queue on TimeoutException in Wolverine C#\nDESCRIPTION: This snippet demonstrates configuring Wolverine to immediately move a message to the designated error queue when a `TimeoutException` occurs during message handling. This bypasses any potential retry logic for this specific exception type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Don't retry, immediately send to the error queue\n        opts.OnException<TimeoutException>().MoveToErrorQueue();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining and Using IHttpAware Interface for Custom Resource Creation Responses - Wolverine - C#\nDESCRIPTION: This snippet implements a custom CreationResponse record implementing the IHttpAware interface in C#. It demonstrates how to automatically assign the correct HTTP status (201) and set the Location header for resource creation endpoints within Wolverine, replacing the generic 200 status. Dependencies include Wolverine, ASP.NET Core, and proper reference to IHttpAware, with key parameters being the target URL. The snippet defines static and explicit interface methods to apply both runtime and OpenAPI metadata for endpoints returning this response type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/metadata.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>\\n/// Base class for resource types that denote some kind of resource being created\\n/// in the system. Wolverine specific, and more efficient, version of Created<T> from ASP.Net Core\\n/// </summary>\\npublic record CreationResponse([StringSyntax(\"Route\")]string Url) : IHttpAware\\n{\\n    public static void PopulateMetadata(MethodInfo method, EndpointBuilder builder)\\n    {\\n        builder.RemoveStatusCodeResponse(200);\\n\\n        var create = new MethodCall(method.DeclaringType!, method).Creates.FirstOrDefault()?.VariableType;\\n        var metadata = new WolverineProducesResponseTypeMetadata { Type = create, StatusCode = 201 };\\n        builder.Metadata.Add(metadata);\\n    }\\n\\n    void IHttpAware.Apply(HttpContext context)\\n    {\\n        context.Response.Headers.Location = Url;\\n        context.Response.StatusCode = 201;\\n    }\\n\\n    public static CreationResponse<T> For<T>(T value, string url) => new CreationResponse<T>(url, value);\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Wolverine GET Endpoint with an Integer Route Parameter in C#\nDESCRIPTION: This example shows another HTTP GET endpoint defined with `[WolverineGet]`. The route `/age/{age}` uses an integer route parameter `{age}`. The method parameter `int age` matches the route parameter name, and Wolverine handles the necessary parsing and binding of the URL segment value to the integer parameter. If parsing fails (e.g., non-numeric input), Wolverine returns a 404 status code.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/routing.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n[WolverineGet(\"/age/{age}\")]\npublic static string IntRouteArgument(int age)\n{\n    return $\"Age is {age}\";\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Latest Aggregate State in Wolverine Message Handler using [ReadAggregate] (C#)\nDESCRIPTION: Demonstrates using the `[ReadAggregate]` attribute in a Wolverine message handler to inject the latest projected state of a Marten aggregate (`LetterAggregate`) for informational purposes. Wolverine identifies the aggregate based on the `FindAggregate` command's ID property and uses Marten's `FetchLatest` API to load it. This avoids the full aggregate handler workflow when only read access is needed. If the aggregate doesn't exist, a 404 is typically returned in HTTP scenarios.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_12\n\nLANGUAGE: cs\nCODE:\n```\npublic record FindAggregate(Guid Id);\n\npublic static class FindLettersHandler\n{\n    // This is admittedly just some weak sauce testing support code\n    public static LetterAggregateEnvelope Handle(\n        FindAggregate command, \n        [ReadAggregate] LetterAggregate aggregate)\n    \n        => new LetterAggregateEnvelope(aggregate);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Conjoined-Tenancy Document and Handler with Marten and Wolverine in C#\nDESCRIPTION: Implements a document type that participates in 'conjoined' multi-tenancy by implementing Marten's `ITenanted` interface and providing both an Id and TenantId. Defines a create command and a handler that performs an insert using Marten operations but without directly handling tenant logic in the handler. Requires Marten and Wolverine dependencies, and that tenancy is configured in Marten. Inputs are document IDs and locations; outputs are new documents persisted under the correct tenant.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/multi-tenancy.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n// Implementing Marten's ITenanted interface\n// also makes Marten treat this document type as\n// having \"conjoined\" multi-tenancy\npublic class TenantedDocument : ITenanted\n{\n    public Guid Id { get; init; }\n\n    public string TenantId { get; set; }\n    public string Location { get; set; }\n}\n\n// A command to create a new document that's multi-tenanted\npublic record CreateTenantDocument(Guid Id, string Location);\n\n// A message handler to create a new document. Notice there's\n// absolutely NO code related to a tenant id, but yet it's\n// fully respecting multi-tenancy here in a second\npublic static class CreateTenantDocumentHandler\n{\n    public static IMartenOp Handle(CreateTenantDocument command)\n    {\n        return MartenOps.Insert(new TenantedDocument{Id = command.Id, Location = command.Location});\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Wolverine HTTP Endpoints for File Uploads in C#\nDESCRIPTION: This C# snippet defines a class `FileUploadEndpoint` with two static methods acting as Wolverine HTTP POST endpoints. The first method, `Upload(IFormFile file)`, handles a single file upload at `/upload/file`. The second method, `Upload(IFormFileCollection files)`, handles multiple file uploads at `/upload/files`. These methods leverage ASP.NET Core's `IFormFile` and `IFormFileCollection` interfaces, which are automatically populated by the framework when files are included in the request.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/files.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic class FileUploadEndpoint\n{\n    // If you have exactly one file upload, take\n    // in IFormFile\n    [WolverinePost(\"/upload/file\")]\n    public static Task Upload(IFormFile file)\n    {\n        // access the file data\n        return Task.CompletedTask;\n    }\n\n    // If you have multiple files at one time,\n    // use IFormCollection\n    [WolverinePost(\"/upload/files\")]\n    public static Task Upload(IFormFileCollection files)\n    {\n        // access files\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Discarding Invalid Messages in Wolverine C#\nDESCRIPTION: This code configures Wolverine to discard messages that cause a specific exception (`InvalidMessageYouWillNeverBeAbleToProcessException`). This is useful for messages that are known to be invalid and cannot be processed, preventing them from clogging retry or error queues.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Bad message, get this thing out of here!\n        opts.OnException<InvalidMessageYouWillNeverBeAbleToProcessException>()\n            .Discard();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Request ID Middleware in C#\nDESCRIPTION: Defines a static class `RequestIdMiddleware` with an `Apply` method. This middleware extracts a correlation ID from the `X-Correlation-ID` request header and applies it to the Wolverine `IMessageContext` if present. It depends on `HttpContext` and `IMessageContext` and is intended to propagate tracing information across requests and subsequent messages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic static class RequestIdMiddleware\n{\n    public const string CorrelationIdHeaderKey = \"X-Correlation-ID\";\n\n    // Remember that most Wolverine middleware can be done with \"just\" a method\n    public static void Apply(HttpContext httpContext, IMessageContext messaging)\n    {\n        if (httpContext.Request.Headers.TryGetValue(CorrelationIdHeaderKey, out var correlationId))\n        {\n            messaging.CorrelationId = correlationId.First();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Wolverine Message Handler with Cascading Messages in C#\nDESCRIPTION: This C# snippet defines a static `Handle` method within an `AccountHandler` class, decorated with `[Transactional]`. It processes a `DebitAccount` command, updates an `Account`'s balance using an `IDocumentSession`, and conditionally yields various cascading messages (`LowBalanceDetected`, `AccountOverdrawn`, `EnforceAccountOverdrawnDeadline`, `AccountUpdated`) based on the account's state after the debit. It demonstrates returning multiple potential outgoing messages from a single handler.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n[Transactional]\npublic static IEnumerable<object> Handle(\n    DebitAccount command,\n    Account account,\n    IDocumentSession session)\n{\n    account.Balance -= command.Amount;\n\n    // This just marks the account as changed, but\n    // doesn't actually commit changes to the database\n    // yet. That actually matters as I hopefully explain\n    session.Store(account);\n\n    // Conditionally trigger other, cascading messages\n    if (account.Balance > 0 && account.Balance < account.MinimumThreshold)\n    {\n        yield return new LowBalanceDetected(account.Id)\n            .WithDeliveryOptions(new DeliveryOptions { ScheduleDelay = 1.Hours() });\n    }\n    else if (account.Balance < 0)\n    {\n        yield return new AccountOverdrawn(account.Id);\n\n        // Give the customer 10 days to deal with the overdrawn account\n        yield return new EnforceAccountOverdrawnDeadline(account.Id);\n    }\n\n    yield return new AccountUpdated(account.Id, account.Balance);\n}\n```\n\n----------------------------------------\n\nTITLE: Responding to Messages with IMessageContext in Wolverine Handler (C#)\nDESCRIPTION: This snippet defines a handler that logs incoming Ping messages and sends responses to the original sender using the IMessageContext service. Dependencies include Microsoft.Extensions.Logging for logging and Wolverine's IMessageContext for response capabilities. The Ping argument represents the incoming message, and Pong is returned as a response using context.RespondToSenderAsync. This pattern is central for implementing request-response and local command dispatch in Wolverine handlers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nusing Messages;\nusing Microsoft.Extensions.Logging;\nusing Wolverine;\n\nnamespace Ponger;\n\npublic class PingHandler\n{\n    public ValueTask Handle(Ping ping, ILogger<PingHandler> logger, IMessageContext context)\n    {\n        logger.LogInformation(\"Got Ping #{Number}\", ping.Number);\n        return context.RespondToSenderAsync(new Pong { Number = ping.Number });\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic Transaction Middleware with Marten in C#\nDESCRIPTION: This snippet demonstrates how to configure a Wolverine application within a .NET Host to automatically apply transactional middleware for handlers interacting with Marten. It involves adding Marten services, integrating with Wolverine using `IntegrateWithWolverine()`, and opting into automatic transactions via `opts.Policies.AutoApplyTransactions()`. This setup ensures handlers depending on `IDocumentSession` are wrapped in a transaction.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/transactional-middleware.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Services.AddMarten(\"some connection string\")\n            .IntegrateWithWolverine();\n\n        // Opt into using \"auto\" transaction middleware\n        opts.Policies.AutoApplyTransactions();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Publishing a Message to a Specific RabbitMQ Topic via Wolverine (C#)\nDESCRIPTION: This code shows how to publish a message to a specified RabbitMQ topic using Wolverine's IMessageBus abstraction in C#. It first retrieves the message bus from the configured service provider and then broadcasts a new message to the 'color.purple' topic. This pattern requires Wolverine, a configured RabbitMQ sending endpoint, and an appropriate message type (e.g., Message1). The asynchronous API can be awaited, and the topic name determines routing within RabbitMQ.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/broadcast-to-topic.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar publisher = theSender.Services\n    .GetRequiredService<IMessageBus>();\n\nawait publisher.BroadcastToTopicAsync(\"color.purple\", new Message1());\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvar publisher = theSender.Services\n    .GetRequiredService<IMessageBus>();\n\nawait publisher.BroadcastToTopicAsync(\"color.purple\", new Message1());\n```\n\n----------------------------------------\n\nTITLE: Implementing an Asynchronous Wolverine Extension (IAsyncWolverineExtension) in C#\nDESCRIPTION: Demonstrates the `SampleAsyncExtension` class implementing `IAsyncWolverineExtension`. This interface allows asynchronous operations within the `Configure` method, shown here checking a feature flag using `IFeatureManager` before applying configuration changes to `WolverineOptions`. Requires Wolverine 2.3+.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic class SampleAsyncExtension : IAsyncWolverineExtension\n{\n    private readonly IFeatureManager _features;\n\n    public SampleAsyncExtension(IFeatureManager features)\n    {\n        _features = features;\n    }\n\n    public async ValueTask Configure(WolverineOptions options)\n    {\n        if (await _features.IsEnabledAsync(\"Module1\"))\n        {\n            // Make any kind of Wolverine configuration\n            options\n                .PublishMessage<Module1Message>()\n                .ToLocalQueue(\"module1-high-priority\")\n                .Sequential();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages to Derived MQTT Topics in Wolverine (C#)\nDESCRIPTION: Configures Wolverine to publish all messages to MQTT topics where the topic name is automatically derived from the message type name or a `[Topic]` attribute on the message class. It uses `UseMqtt()` to connect to the broker and `PublishAllMessages().ToMqttTopics()` to enable this routing behavior, optionally setting a default QoS level.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n\nbuilder.UseWolverine(opts =>\n{\n    // Connect to the MQTT broker\n    opts.UseMqtt(mqtt =>\n    {\n        var mqttServer = builder.Configuration[\"mqtt_server\"];\n\n        mqtt\n            .WithMaxPendingMessages(3)\n            .WithClientOptions(client => { client.WithTcpServer(mqttServer); });\n    });\n\n    // Publish messages to MQTT topics based on\n    // the message type\n    opts.PublishAllMessages()\n        .ToMqttTopics()\n        .QualityOfService(MqttQualityOfServiceLevel.AtMostOnce);\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Exposing Wolverine Handler Returning IResult via Minimal API in C#\nDESCRIPTION: Shows the updated Minimal API endpoint mapping for the `CancelOrderHandler` that now returns `IResult`. The call to `IMessageBus.InvokeAsync` specifies `IResult` as the expected return type (<IResult>), allowing the Minimal API framework to correctly process and send the HTTP response generated by the handler.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// Assuming 'app' is an IEndpointRouteBuilder instance\napp.MapPost(\"/api/orders/cancel\", (CancelOrder command, IMessageBus bus, CancellationToken token) => bus.InvokeAsync<IResult>(command, token));\n```\n\n----------------------------------------\n\nTITLE: Defining a Saga Entity with String Identity for RavenDb (C#)\nDESCRIPTION: This C# class demonstrates a Saga entity compatible with Wolverine's RavenDb saga persistence. The class must inherit from 'Saga' and use a public string property ('Id') as its unique identity. This is required due to RavenDb's string-based identity scheme; other types are not supported. The class is a template, and further handler or state logic should be added as needed.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/ravendb.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic class Order : Saga\n{\n    // Just use this for the identity\n    // of RavenDb backed sagas\n    public string Id { get; set; }\n    \n    // Handle and Start methods...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Subscription Filters with Wolverine.AzureServiceBus in C#\nDESCRIPTION: This snippet illustrates configuring a custom SQL filter when Wolverine provisions Azure Service Bus subscriptions in a .NET setup. The filter ensures that only messages not matching the condition (user.ignore != 'true') are delivered to the subscription. Required dependencies include Wolverine framework, Azure.Messaging.ServiceBus, and related packages. Key parameters are the subscription name and a rule/filter expression; output is a filtered subscription endpoint. The filter uses a SqlRuleFilter compatible with Azure Service Bus, and the default filter is '1=1' if not specified.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/topics.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nopts.ListenToAzureServiceBusSubscription(\n        \"subscription1\",\n        configureSubscriptionRule: rule =>\n        {\n            rule.Filter = new SqlRuleFilter(\"NOT EXISTS(user.ignore) OR user.ignore NOT LIKE 'true'\");\n        })\n    .FromTopic(\"topic1\");\n```\n\n----------------------------------------\n\nTITLE: Opting into System.Text.Json Serialization in Wolverine (C#)\nDESCRIPTION: Demonstrates how to configure Wolverine to use System.Text.Json for serialization with custom defaults by adjusting the JsonSerializerOptions object. Requires a reference to System.Text.Json and the 'opts' parameter as a WolverineOptions instance. Customize unknown type handling via the provided options for improved performance with caution regarding compatibility.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nopts.UseSystemTextJsonForSerialization(stj =>\n{\n    stj.UnknownTypeHandling = JsonUnknownTypeHandling.JsonNode;\n});\n```\n\n----------------------------------------\n\nTITLE: Registering Audited Members Programmatically in Wolverine C#\nDESCRIPTION: Illustrates how to programmatically specify audited members for messages implementing a specific interface (`IAccountMessage`) using `WolverineOptions`. The `opts.Policies.ForMessagesOfType<T>().Audit()` method allows selecting members (like `AccountId`) via a lambda expression.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\n// opts is WolverineOptions inside of a UseWolverine() call\nopts.Policies.ForMessagesOfType<IAccountMessage>().Audit(x => x.AccountId);\n```\n\n----------------------------------------\n\nTITLE: Defining a Wolverine HTTP POST Endpoint with Marten Persistence in C#\nDESCRIPTION: This snippet defines a static class representing a Wolverine HTTP endpoint. The `[WolverinePost]` attribute maps the `Post` method to the specified route `/api/orders/place`. The method takes a `PlaceOrder` command object (presumably deserialized from the request body) and an `IDocumentSession` (injected by Wolverine, integrated with Marten) to store a new `Order` entity.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class PlaceOrderEndpoint\n{\n    [WolverinePost(\"/api/orders/place\")]\n    public static void Post(\n        PlaceOrder command, \n        IDocumentSession session)\n    {\n        var order = new Order\n        {\n            Id = command.OrderId, \n            CustomerId = command.CustomerId, \n            Amount = command.Amount\n        };\n        \n        session.Store(order);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the IMessageBatcher Batching Interface in Wolverine (C#)\nDESCRIPTION: This snippet shows the IMessageBatcher interface, which abstracts the batching strategy for Wolverine. Implementers provide a Group method for grouping Envelope instances and specify the batch message type. Dependencies include knowledge of the Envelope class and batching concepts; this interface is required for building custom grouping logic. The interface supports creating complex grouping scenarios by allowing developers to batch based on any arbitrary logic or key.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/batching.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\n/// Plugin strategy for creating custom grouping of messages\n/// </summary>\npublic interface IMessageBatcher\n{\n    /// <summary>\n    /// Main method that batches items\n    /// </summary>\n    /// <param name=\"envelopes\"></param>\n    /// <returns></returns>\n    IEnumerable<Envelope> Group(IReadOnlyList<Envelope> envelopes);\n    \n    /// <summary>\n    /// The actual message type being built that is assumed to contain\n    /// all the batched items\n    /// </summary>\n    Type BatchMessageType { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages to Named Wolverine TCP Endpoints (C#)\nDESCRIPTION: This C# code illustrates how to configure Wolverine to publish messages to named TCP endpoints. It uses `opts.PublishAllMessages().ToPort(5555).Named(\"One\")` to define named endpoints. The example then retrieves the `IMessageBus` service and demonstrates sending messages to a specific named endpoint using `bus.EndpointFor(\"One\").SendAsync()` and `bus.EndpointFor(\"One\").InvokeAsync()` for different interaction patterns like fire-and-forget, remote invocation, and request/reply.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/tcp.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.PublishAllMessages().ToPort(5555)\n            .Named(\"One\");\n\n        opts.PublishAllMessages().ToPort(5555)\n            .Named(\"Two\");\n    }).StartAsync();\n\nvar bus = host.Services\n    .GetRequiredService<IMessageBus>();\n\n// Explicitly send a message to a named endpoint\nawait bus.EndpointFor(\"One\").SendAsync(new SomeMessage());\n\n// Or invoke remotely\nawait bus.EndpointFor(\"One\").InvokeAsync(new SomeMessage());\n\n// Or request/reply\nvar answer = bus.EndpointFor(\"One\")\n    .InvokeAsync<Answer>(new Question());\n```\n\n----------------------------------------\n\nTITLE: Configuring PostgreSQL Message Persistence in Wolverine (C#)\nDESCRIPTION: Demonstrates configuring Wolverine within an ASP.NET Core application to use PostgreSQL for transactional message persistence. It retrieves the database connection string from configuration, calls `opts.PersistMessagesWithPostgresql(connectionString)` to enable PostgreSQL storage, and optionally uses `UseResourceSetupOnStartup()` to manage schema creation/clearing on application start. Requires the `WolverineFx.Postgresql` package.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/postgresql.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\nvar connectionString = builder.Configuration.GetConnectionString(\"postgres\");\n\nbuilder.Host.UseWolverine(opts =>\n{\n    // Setting up Postgresql-backed message storage\n    // This requires a reference to Wolverine.Postgresql\n    opts.PersistMessagesWithPostgresql(connectionString);\n\n    // Other Wolverine configuration\n});\n\n// This is rebuilding the persistent storage database schema on startup\n// and also clearing any persisted envelope state\nbuilder.Host.UseResourceSetupOnStartup();\n\nvar app = builder.Build();\n\n// Other ASP.Net Core configuration...\n\n// Using Oakton opens up command line utilities for managing\n// the message storage\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Routing Cascading Messages to Specific Endpoints in Wolverine (C#)\nDESCRIPTION: Shows how to send cascading messages to specific, named endpoints or URI destinations instead of relying on default routing rules. The handler returns an `IEnumerable<object>`, yielding messages (`GoNorth`, `GoWest`) modified with `ToEndpoint()` or `ToDestination()` extension methods to specify their target queues.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n// snippet: sample_ManuallyRoutedResponseHandler\npublic class ManuallyRoutedResponseHandler\n{\n    public IEnumerable<object> Consume(MyMessage message)\n    {\n        // Go North now at the \"important\" queue\n        yield return new GoNorth().ToEndpoint(\"important\");\n\n        // Go West in a lower priority queue\n        yield return new GoWest().ToDestination(new Uri(\"rabbitmq://queue/low\"));\n    }\n}\n// endSnippet\n```\n\n----------------------------------------\n\nTITLE: Customizing Conventional RabbitMQ Routing with Wolverine in C#\nDESCRIPTION: This snippet shows advanced customization of the RabbitMQ routing behavior using Wolverine's UseConventionalRouting method. It demonstrates customizing outgoing exchange and incoming queue naming conventions, conditionally configuring listeners (setting durability, listener counts, or message TTLs), and modifying exchange type for outgoing messages. The example uses lambda expressions to alter conventions and conditional logic based on message type. Dependencies include Wolverine, HostBuilder, and knowledge of message type hierarchies. This configuration targets scenarios where application-specific requirements deviate from Wolverine's built-in conventions.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/conventional-routing.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq()\n            // Opt into conventional Rabbit MQ routing\n            .UseConventionalRouting(x =>\n            {\n                // Customize the naming convention for the outgoing exchanges\n                x.ExchangeNameForSending(type => type.Name + \"Exchange\");\n\n                // Customize the naming convention for incoming queues\n                x.QueueNameForListener(type => type.FullName.Replace('.', '-'));\n\n                // Or maybe you want to conditionally configure listening endpoints\n                x.ConfigureListeners((listener, context) =>\n                    {\n                        if (context.MessageType.IsInNamespace(\"MyApp.Messages.Important\"))\n                        {\n                            listener.UseDurableInbox().ListenerCount(5);\n                        }\n                        else\n                        {\n                            // If not important, let's make the queue be\n                            // volatile and purge older messages automatically\n                            listener.TimeToLive(2.Minutes());\n                        }\n                    })\n                    // Or maybe you want to conditionally configure the outgoing exchange\n                    .ConfigureSending((ex, _) => { ex.ExchangeType(ExchangeType.Direct); });\n            });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Exposing Wolverine Handler via Minimal API Endpoint Delegation in C#\nDESCRIPTION: Demonstrates mapping an HTTP POST request (`/api/orders/cancel`) to a Wolverine message handler using ASP.NET Core Minimal APIs. It takes the `CancelOrder` command from the request body and uses `IMessageBus.InvokeAsync` to trigger the corresponding Wolverine handler (like the `CancelOrderHandler` defined previously).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// Assuming 'app' is an IEndpointRouteBuilder instance (e.g., WebApplication)\n// Assuming 'CancelOrder' can be bound from the request body\napp.MapPost(\"/api/orders/cancel\", (CancelOrder command, IMessageBus bus, CancellationToken token) => bus.InvokeAsync(command, token));\n```\n\n----------------------------------------\n\nTITLE: Configuring Explicit Azure Service Bus Publishing with Wolverine in C#\nDESCRIPTION: This snippet demonstrates how to explicitly configure a Wolverine application to publish messages to a specific Azure Service Bus queue. It sets up the connection string (typically from configuration), initializes the integration with Azure Service Bus, and specifies messaging options such as in-memory buffering for outgoing messages. Prerequisites include the Wolverine and Azure Service Bus .NET packages, a valid connection string, and suitable permissions for provisioning queues. Key parameters are the connection string and the name of the target queue. The outcome is the ability to publish messages from Wolverine to a specific Azure Service Bus queue with custom buffering behavior.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/publishing.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // One way or another, you're probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\");\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString).AutoProvision();\n\n    // Explicitly configure sending messages to a specific queue\n    opts.PublishAllMessages().ToAzureServiceBusQueue(\"outgoing\")\n\n        // All the normal Wolverine options you'd expect\n        .BufferedInMemory();\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Wolverine Message Handlers as Static Methods (C#)\nDESCRIPTION: Demonstrates defining message handlers as static methods within a static or non-static class (`ExampleHandler`). This approach avoids the overhead of creating and garbage collecting handler instances for each message, potentially offering a minor performance improvement. Dependencies for static handlers must be provided via method injection.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic static class ExampleHandler\n{\n    public static void Handle(Message1 message)\n    {\n        // Do work synchronously\n    }\n\n    public static Task Handle(Message2 message)\n    {\n        // Do work asynchronously\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Logging and Tracing with WolverineLogging Attribute in C#\nDESCRIPTION: Illustrates using the `[WolverineLogging]` attribute on a handler method (`Handle(QuietMessage message)`) to control Open Telemetry tracing and logging levels for a specific message type (`QuietMessage`). This example disables telemetry, sets the success log level to None, and the execution log level to Trace for this handler.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\npublic class QuietMessage;\n\npublic class QuietMessageHandler\n{\n    [WolverineLogging(\n        telemetryEnabled:false,\n        successLogLevel: LogLevel.None,\n        executionLogLevel:LogLevel.Trace)]\n    public void Handle(QuietMessage message)\n    {\n        Console.WriteLine(\"Hush!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Asynchronous HTTP Endpoints with Wolverine in C#\nDESCRIPTION: This code demonstrates creating an asynchronous HTTP POST endpoint using C# and Wolverine, marked with the WolverinePost attribute. The method receives a Question object, calculates the sum and product, and returns an ArithmeticResults object wrapped in a Task. The endpoint is accessible at '/question2'. The handler is static and asynchronous, suitable for use-cases where asynchronous workflows or I/O operations are integrated.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[WolverinePost(\"/question2\")]\npublic static Task<ArithmeticResults> PostJsonAsync(Question question)\n{\n    var results = new ArithmeticResults\n    {\n        Sum = question.One + question.Two,\n        Product = question.One * question.Two\n    };\n\n    return Task.FromResult(results);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Cascading Message Handler in Wolverine (C#)\nDESCRIPTION: Illustrates the core concept of cascading messages in Wolverine. The `Consume` method processes `MyMessage` and simply returns a `MyResponse` object. Wolverine automatically detects this return value and sends it as a message, eliminating the need for `IMessageContext` and promoting purer function handlers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n// snippet: sample_CascadingHandler\npublic class CascadingHandler\n{\n    public MyResponse Consume(MyMessage message)\n    {\n        return new MyResponse();\n    }\n}\n// endSnippet\n```\n\n----------------------------------------\n\nTITLE: Binding Complex Object from Query String using [FromQuery] in Wolverine (C#)\nDESCRIPTION: Demonstrates using the `[FromQuery]` attribute in a Wolverine GET endpoint (`/api/orders/query`) to bind multiple query string parameters to the properties of a complex object (`OrderQuery`). The `OrderQuery` class defines optional query parameters like `PageSize`, `PageNumber`, and `HasShipped` with default values. The endpoint method uses these bound values to query orders from a Marten `IQuerySession` and returns a paged list. An alternative record definition (`OrderQueryAlternative`) is also shown. This requires Wolverine 3.12+.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/querystring.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n```cs\n// If you want every value to be optional, use public, settable\n// properties and a no-arg public constructor\npublic class OrderQuery\n{\n    public int PageSize { get; set; } = 10;\n    public int PageNumber { get; set; } = 1;\n    public bool? HasShipped { get; set; }\n}\n\n// Or -- and I'm not sure how useful this really is, use a record:\npublic record OrderQueryAlternative(int PageSize, int PageNumber, bool HasShipped);\n\npublic static class QueryOrdersEndpoint\n{\n    [WolverineGet(\"/api/orders/query\")]\n    public static Task<IPagedList<Order>> Query(\n        // This will be bound from query string values in the HTTP request\n        [FromQuery] OrderQuery query, \n        IQuerySession session,\n        CancellationToken token)\n    {\n        IQueryable<Order> queryable = session.Query<Order>()\n            // Just to make the paging deterministic\n            .OrderBy(x => x.Id);\n\n        if (query.HasShipped.HasValue)\n        {\n            queryable = query.HasShipped.Value \n                ? queryable.Where(x => x.Shipped.HasValue) \n                : queryable.Where(x => !x.Shipped.HasValue);\n        }\n\n        // Marten specific Linq helper\n        return queryable.ToPagedListAsync(query.PageNumber, query.PageSize, token);\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring RabbitMQ in Wolverine Extension - C#\nDESCRIPTION: This snippet shows how to create a custom Wolverine extension module (MyModuleExtension) to declaratively set up RabbitMQ exchanges and queues using the fluent ConfigureRabbitMq API. The extension must implement IWolverineExtension and define the Configure method, which receives WolverineOptions for customization. Required dependencies include the Wolverine framework, RabbitMQ integration, and any referenced types (e.g., IWolverineExtension, WolverineOptions). The method demonstrates how to declare an exchange and a queue named 'my-module' and 'my-queue' respectively. The input is the configuration context, and the expected effect is the addition of custom RabbitMQ infrastructure during app startup. Limitations: assumes RabbitMQ and relevant libraries are installed and correctly referenced.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/object-management.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyModuleExtension : IWolverineExtension\n{\n    public void Configure(WolverineOptions options)\n    {\n        options.ConfigureRabbitMq()\n            // Make any Rabbit Mq configuration or declare\n            // additional Rabbit Mq options through the normal\n            // syntax\n            .DeclareExchange(\"my-module\")\n            .DeclareQueue(\"my-queue\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Middleware Conditionally via Predicate in Wolverine.Http using C#\nDESCRIPTION: Shows a simpler way to apply middleware conditionally using `opts.AddMiddleware(Type, Func<HttpChain, bool>)`. This example applies `MyAuthenticationMiddleware` only to HTTP endpoints (`HttpChain`) where any of the associated handler method calls involve a handler type located within the specified \"MyApp.Authenticated\" namespace. This allows for fine-grained middleware application without needing a full `IHttpPolicy` implementation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\napp.MapWolverineEndpoints(opts =>\n{\n    // Fake policy to add authentication middleware to any endpoint classes under\n    // an application namespace\n    opts.AddMiddleware(typeof(MyAuthenticationMiddleware),\n        c => c.HandlerCalls().Any(x => x.HandlerType.IsInNamespace(\"MyApp.Authenticated\")));\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring a Maybe-Tenanted Wolverine HTTP Endpoint - C#\nDESCRIPTION: This snippet illustrates how to mark an endpoint as optionally tenanted by using the [MaybeTenanted] attribute. The method receives an IMessageBus instance and returns the detected tenant id or 'none' if absent. This allows clients to omit tenant id while still participating in tenant detection infrastructure. Dependencies include the MaybeTenanted attribute and IMessageBus. Input is the bus instance; output is a string representing the tenant id or a default.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// Mark this endpoint as \"maybe\" having a tenant id\n[WolverineGet(\"/maybe\"), MaybeTenanted]\npublic static string MaybeTenanted(IMessageBus bus)\n{\n    return bus.TenantId ?? \"none\";\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Batched Message Handler in Wolverine with C#\nDESCRIPTION: Defines a static handler class for batching Item messages in Wolverine, processing arrays of Item objects. This handler implements the convention Wolverine expects: handling Item[] as input for batch mode. The static method 'Handle' takes the array and processes it as a unit; the logic inside is customizable according to business requirements. Ensure this handler is discoverable by Wolverine and matches the batch configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/batching.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class ItemHandler\n{\n    public static void Handle(Item[] items)\n    {\n        // Handle this just like a normal message handler,\n        // just that the message type is Item[]\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Wolverine Extension in C#\nDESCRIPTION: Demonstrates a concrete implementation of `IWolverineExtension` named `SampleExtension`. The `Configure` method adds a transient service `IFoo` and configures Newtonsoft.Json serialization settings within the `WolverineOptions`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic class SampleExtension : IWolverineExtension\n{\n    public void Configure(WolverineOptions options)\n    {\n        // Add service registrations\n        options.Services.AddTransient<IFoo, Foo>();\n\n        // Alter settings within the application\n        options\n            .UseNewtonsoftForSerialization(settings => settings.TypeNameHandling = TypeNameHandling.None);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Wolverine Environment Checks via Command Line using Bash\nDESCRIPTION: This Bash command utilizes Oakton's environment check facility to verify the application's ability to connect to external infrastructure like databases and message brokers, as well as internal configuration validity. Running `dotnet run -- check-env` executes these checks and reports success or failure, aiding in diagnosing configuration or connectivity problems. It can also be used during startup to halt execution on failure.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/diagnostics.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- check-env\n```\n\n----------------------------------------\n\nTITLE: Enabling Wolverine Resource Setup on Startup in C#\nDESCRIPTION: Demonstrates how to ensure Wolverine builds any missing database schema objects for message persistence upon application startup using the `UseResourceSetupOnStartup()` extension method on the host builder. This is an alternative to the default automatic build behavior.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n// This is rebuilding the persistent storage database schema on startup\nbuilder.Host.UseResourceSetupOnStartup();\n```\n\n----------------------------------------\n\nTITLE: Disabling System Queue Creation in Azure Service Bus for Wolverine in C#\nDESCRIPTION: This snippet demonstrates how to prevent Wolverine from attempting to create temporary system queues in Azure Service Bus, which is useful if the application lacks the necessary permissions. The `.SystemQueuesAreEnabled(false)` method is called during the Azure Service Bus configuration within `UseWolverine`. The example also includes setting up a listener and publisher for a specific application queue.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/index.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAzureServiceBusTesting()\n            .AutoProvision().AutoPurgeOnStartup()\n            .SystemQueuesAreEnabled(false);\n\n        opts.ListenToAzureServiceBusQueue(\"send_and_receive\");\n\n        opts.PublishAllMessages().ToAzureServiceBusQueue(\"send_and_receive\");\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing RequireAuthorizeOnAll for Wolverine HTTP Options (C#)\nDESCRIPTION: This C# code snippet shows the implementation of the `RequireAuthorizeOnAll` method within the `WolverineHttpOptions` class. It iterates through all configured Wolverine endpoints and applies the standard ASP.NET Core `RequireAuthorization()` policy to each one.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/security.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n/// Equivalent of calling RequireAuthorization() on all wolverine endpoints\n/// </summary>\npublic void RequireAuthorizeOnAll()\n{\n    ConfigureEndpoints(e => e.RequireAuthorization());\n}\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping a Wolverine Application with Marten Saga Persistence in C#\nDESCRIPTION: This C# code demonstrates how to configure a .NET Web Application to use Wolverine with Marten for saga persistence. It uses `WebApplication.CreateBuilder` to set up the application, adds Marten persistence via `AddMarten` and configures its connection string and schema. Crucially, it integrates Marten with Wolverine for saga persistence using `.IntegrateWithWolverine()`. Wolverine itself is added and configured with default settings using `UseWolverine()`. Minimal API endpoints (`/start`, `/complete`, `/all`) are defined to interact with the saga using `IMessageBus` and query saga state using Marten's `IQuerySession`. Oakton extensions and Swagger are also configured for diagnostics and API exploration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sagas.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing Marten;\nusing Oakton;\nusing Oakton.Resources;\nusing OrderSagaSample;\nusing Wolverine;\nusing Wolverine.Marten;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Not 100% necessary, but enables some extra command line diagnostics\nbuilder.Host.ApplyOaktonExtensions();\n\n// Adding Marten\nbuilder.Services.AddMarten(opts =>\n    {\n        var connectionString = builder.Configuration.GetConnectionString(\"Marten\");\n        opts.Connection(connectionString);\n        opts.DatabaseSchemaName = \"orders\";\n    })\n\n    // Adding the Wolverine integration for Marten.\n    .IntegrateWithWolverine();\n\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// Do all necessary database setup on startup\nbuilder.Services.AddResourceSetupOnStartup();\n\n// The defaults are good enough here\nbuilder.Host.UseWolverine();\n\nvar app = builder.Build();\n\n// Just delegating to Wolverine's local command bus for all\napp.MapPost(\"/start\", (StartOrder start, IMessageBus bus) => bus.InvokeAsync(start));\napp.MapPost(\"/complete\", (CompleteOrder start, IMessageBus bus) => bus.InvokeAsync(start));\napp.MapGet(\"/all\", (IQuerySession session) => session.Query<Order>().ToListAsync());\napp.MapGet(\"/\", (HttpResponse response) =>\n{\n    response.Headers.Add(\"Location\", \"/swagger\");\n    response.StatusCode = 301;\n}).ExcludeFromDescription();\n\napp.UseSwagger();\napp.UseSwaggerUI();\n\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Swagger Operation Filter using Swashbuckle in ASP.NET Core - C#\nDESCRIPTION: This code shows how to register a custom operation filter, such as the previously shown WolverineOperationFilter, with the Swashbuckle Swagger generator during ASP.NET Core startup. It configures the service collection's SwaggerGen options so that the custom filter is invoked during OpenAPI generation. Must be called during application initialization (e.g., Program.Main) prior to Swagger document generation. Assumes availability of builder.Services in the configuration context.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/metadata.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddSwaggerGen(x =>\n{\n    x.OperationFilter<WolverineOperationFilter>();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Intrinsic Serialization with Wolverine ISerializable Interface - C#\nDESCRIPTION: This snippet demonstrates a C# message class, SerializedMessage, implementing the Wolverine ISerializable interface to embed its own serialization and deserialization logic. The Write method serializes the Name property to a byte array using Encoding.Default, while the static Read method reconstructs a SerializedMessage object from a byte array. Requires C# 11+ for static interface methods. This approach eliminates the need for external serializers, allowing Wolverine to detect and utilize intrinsic serialization automatically. Inputs are the Name property or byte arrays; output is a byte array or a deserialized object. This method is specialized for internal performance optimizations and may not be compatible with all serialization scenarios, especially where encoding must be controlled or cross-platform compatibility is critical.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SerializedMessage : ISerializable\n{\n    public string Name { get; set; } = \"Bob Schneider\";\n\n    public byte[] Write()\n    {\n        return Encoding.Default.GetBytes(Name);\n    }\n\n    // You'll need at least C# 11 for static methods\n    // on interfaces!\n    public static object Read(byte[] bytes)\n    {\n        var name = Encoding.Default.GetString(bytes);\n        return new SerializedMessage { Name = name };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Marten Operation Side Effect Interface in C#\nDESCRIPTION: Defines the `IMartenOp` interface, which extends `ISideEffect`. Implementations of this interface encapsulate operations to be executed against a Marten `IDocumentSession` as part of Wolverine's handler execution flow. This promotes separating database actions from core handler logic.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/operations.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n/// Interface for any kind of Marten related side effect\n/// </summary>\npublic interface IMartenOp : ISideEffect\n{\n    void Execute(IDocumentSession session);\n}\n```\n\n----------------------------------------\n\nTITLE: Clearing Wolverine Persisted Message Data via CLI using Bash\nDESCRIPTION: Shows the command `dotnet run -- storage clear` used to delete all persisted message data from the configured Wolverine message store. This is useful for resetting state in development or testing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- storage clear\n```\n\n----------------------------------------\n\nTITLE: Customizing Handler Logging via Configure Method in C#\nDESCRIPTION: Shows how to customize logging levels for a specific message type (`SpecialMessage`) by implementing a static `Configure(HandlerChain chain)` method within the handler class (`CustomizedHandler`). This method allows modification of the handler chain, including setting `SuccessLogLevel` and `ProcessingLogLevel` to `LogLevel.None` specifically for this message type, while still allowing error logging.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic class CustomizedHandler\n{\n    public void Handle(SpecialMessage message)\n    {\n        // actually handle the SpecialMessage\n    }\n\n    public static void Configure(HandlerChain chain)\n    {\n        chain.Middleware.Add(new CustomFrame());\n\n        // Turning off all execution tracking logging\n        // from Wolverine for just this message type\n        // Error logging will still be enabled on failures\n        chain.SuccessLogLevel = LogLevel.None;\n        chain.ProcessingLogLevel = LogLevel.None;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Incorrect IMessageBus Resolution in Service Registration in C#\nDESCRIPTION: Highlights an anti-pattern that must be avoided: manually resolving `IMessageBus` from the service provider within a service registration lambda (`AddScoped`, `AddTransient`, etc.). This results in obtaining an `IMessageBus` instance disconnected from the current Wolverine `MessageContext`, leading to incorrect behavior and loss of tracking.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/best-practices.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddScoped<IService>(s => {\n    var bus = s.GetRequiredService<IMessageBus>();\n    return new Service { TenantId = bus.TenantId };\n});\n```\n\n----------------------------------------\n\nTITLE: Conceptual Structure of Applied Wolverine Middleware (C#)\nDESCRIPTION: This C# snippet conceptually illustrates how Wolverine integrates conventional middleware methods into the generated handler pipeline. It shows the `Before()` method being called first, followed by a `try` block containing the actual handler logic and the `After()` method (if present). Finally, the `Finally()` method is called within a `finally` block, ensuring its execution regardless of success or failure within the `try` block.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nmiddleware.Before();\ntry\n{\n    // call the actual handler methods\n    middleware.After();\n}\nfinally\n{\n    middleware.Finally();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten Event Handler Integration in Wolverine (C#)\nDESCRIPTION: This snippet demonstrates configuring a .NET generic host with Marten and Wolverine to process events using message handlers in strict order. It sets up Marten projections, error handling strategies, and a filtered event subscription starting from a specific time. Dependencies include Marten and Wolverine libraries as well as a PostgreSQL connection, and the configuration is done via UseWolverine/UseNpgsqlDataSource APIs. Inputs are service configuration options, and the output is a running host; primary limitation is that Marten's async daemon must be active to process events.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/subscriptions.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Services\n            .AddMarten(o =>\n            {\n                // This is the default setting, but just showing\n                // you that Wolverine subscriptions will be able\n                // to skip over messages that fail without\n                // shutting down the subscription\n                o.Projections.Errors.SkipApplyErrors = true;\n            })\n\n            // Just pulling the connection information from\n            // the IoC container at runtime.\n            .UseNpgsqlDataSource()\n\n            // You don't absolutely have to have the Wolverine\n            // integration active here for subscriptions, but it's\n            // more than likely that you will want this anyway\n            .IntegrateWithWolverine()\n\n            // The Marten async daemon most be active\n            .AddAsyncDaemon(DaemonMode.HotCold)\n\n            // Notice the allow list filtering of event types and the possibility of overriding\n            // the starting point for this subscription at runtime\n            .ProcessEventsWithWolverineHandlersInStrictOrder(\"Orders\", o =>\n            {\n                // It's more important to create an allow list of event types that can be processed\n                o.IncludeType<OrderCreated>();\n\n                // Optionally mark the subscription as only starting from events from a certain time\n                o.Options.SubscribeFromTime(new DateTimeOffset(new DateTime(2023, 12, 1)));\n            });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Default Message Timeout via TimeoutMessage Base Class (Wolverine/.NET/C#)\nDESCRIPTION: Shows how to define a message type that is always scheduled for delayed delivery by inheriting from the TimeoutMessage base type and specifying a delay. Dependencies: Wolverine's TimeoutMessage, custom record types, extension methods for TimeSpan creation (1.Minutes()). Instantiating this record ensures it’s scheduled after one minute by default. Inputs: a string Id; Outputs: a scheduled message object configured for delayed delivery. Limitations: applicable where scheduled retry or timeouts are required.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n// This message will always be scheduled to be delivered after\n// a one minute delay\npublic record OrderTimeout(string Id) : TimeoutMessage(1.Minutes());\n```\n\n----------------------------------------\n\nTITLE: Returning Events and Outgoing Messages from Wolverine Aggregate Handler in C#\nDESCRIPTION: Presents an asynchronous Wolverine aggregate handler (`[AggregateHandler]`) demonstrating method injection (`ISomeService`). It processes a `MarkItemReady` command against an `Order` aggregate. Instead of directly appending to a stream, it returns a tuple containing `Wolverine.Marten.Events` and `Wolverine.Messaging.Runtime.OutgoingMessages` to capture events to be appended and new messages (`ShipOrder`) to be published, respectively.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\n[AggregateHandler]\npublic static async Task<(Events, OutgoingMessages)> HandleAsync(MarkItemReady command, Order order, ISomeService service)\n{\n    // All contrived, let's say we need to call some\n    // kind of service to get data so this handler has to be\n    // async\n    var data = await service.FindDataAsync();\n\n    var messages = new OutgoingMessages();\n    var events = new Events();\n\n    if (order.Items.TryGetValue(command.ItemName, out var item))\n    {\n        // Not doing this in a purist way here, but just\n        // trying to illustrate the Wolverine mechanics\n        item.Ready = true;\n\n        // Mark that the this item is ready\n        events += new ItemReady(command.ItemName);\n    }\n    else\n    {\n        // Some crude validation\n        throw new InvalidOperationException($\"Item {command.ItemName} does not exist in this order\");\n    }\n\n    // If the order is ready to ship, also emit an OrderReady event\n    if (order.IsReadyToShip())\n    {\n        events += new OrderReady();\n        messages.Add(new ShipOrder(order.Id));\n    }\n\n    // This results in both new events being captured\n    // and potentially the ShipOrder message going out\n    return (events, messages);\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Simple String Query Parameter in Wolverine (C#)\nDESCRIPTION: Defines a Wolverine HTTP GET endpoint at '/querystring/string'. The method argument 'name' is automatically bound from the query string parameter with the same name. If the 'name' query string parameter is missing or empty, the method receives a default value (empty string for 'string') and returns a specific message; otherwise, it returns a formatted string including the provided name. This illustrates Wolverine's default behavior for binding simple types from the query string when the parameter name doesn't match a route argument.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/querystring.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n```cs\n[WolverineGet(\"/querystring/string\")]\npublic static string UsingQueryString(string name) // name is from the query string\n{\n    return name.IsEmpty() ? \"Name is missing\" : $\"Name is {name}\";\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding OpenAPI OperationId in Wolverine Endpoint Attribute - C#\nDESCRIPTION: This example demonstrates how to override the default OpenAPI operationId for a HTTP endpoint in Wolverine via the route attribute. By specifying OperationId in the WolverineGet attribute, developers can ensure Swashbuckle assigns a custom operation ID for the endpoint, independently of class or method name. Endpoint returns a string in response to GET requests. Relies on the existence of the WolverineGet attribute with an OperationId property.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/metadata.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// Override the operation id within the generated OpenAPI\n// metadata\n[WolverineGet(\"/fake/hello/async\", OperationId = \"OverriddenId\")]\npublic Task<string> SayHelloAsync()\n{\n    return Task.FromResult(\"Hello\");\n}\n```\n\n----------------------------------------\n\nTITLE: Posting Aggregate Events with Route-Inferred Identity via [Aggregate] Attribute in Wolverine.HTTP - C#\nDESCRIPTION: This snippet demonstrates a Wolverine HTTP POST endpoint that publishes an OrderShipped event for a given Order aggregate. With only the aggregate bound by [Aggregate] from route parameters, it eliminates the need for a command body. The [EmptyResponse] attribute means the response is empty and the event is published to the Marten event stream, with HTTP 404 returned if the aggregate does not exist. This illustrates a streamlined HTTP-centric aggregate command pattern.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverinePost(\"/orders/{orderId}/ship3\"), EmptyResponse]\n// The OrderShipped return value is treated as an event being posted\n// to a Marten even stream\n// instead of as the HTTP response body because of the presence of\n// the [EmptyResponse] attribute\npublic static OrderShipped Ship3([Aggregate] Order order)\n{\n    return new OrderShipped();\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom UserDefinedContinuation Policy for Exception Handling in Wolverine - C#\nDESCRIPTION: Shows how to register a custom continuation class (e.g., ShippingOrderFailurePolicy) as an additional error action for a given exception type (ShippingFailedException) in the fluent policy setup. After discarding the failed message, the policy uses the And<T>() method to add the user-defined policy. Used in conjunction with a handler host setup for Wolverine. Requires receiver port configuration, service naming, and custom error continuation types.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\ntheReceiver = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.ListenAtPort(receiverPort);\n        opts.ServiceName = \"Receiver\";\n\n        opts.Policies.OnException<ShippingFailedException>()\n            .Discard().And<ShippingOrderFailurePolicy>();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Invoking Wolverine Handler and Retrieving Updated Aggregate via IMessageBus in C#\nDESCRIPTION: Illustrates invoking a command handler asynchronously using Wolverine's `IMessageBus`. The `InvokeAsync<Order>(command)` method sends the `MarkItemReady` command and awaits the updated `Order` aggregate state, which is returned because the corresponding handler uses the `UpdatedAggregate` response type. Depends on `IMessageBus`, the command, the aggregate type, and a handler configured to return `UpdatedAggregate`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\npublic static Task<Order> update_and_get_latest(IMessageBus bus, MarkItemReady command)\n{\n    // This will return the updated version of the Order\n    // aggregate that incorporates whatever events were appended\n    // in the course of processing the command\n    return bus.InvokeAsync<Order>(command);\n}\n```\n\n----------------------------------------\n\nTITLE: Rebuilding Wolverine Storage Schema via CLI using Bash\nDESCRIPTION: Demonstrates the command `dotnet run -- storage rebuild` which rebuilds the database schema objects for Wolverine message persistence. Note that this command will also clear out any existing persisted message data, making it suitable for development or testing environments.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- storage rebuild\n```\n\n----------------------------------------\n\nTITLE: Utilizing Optional IResult with OpenAPI Metadata in Compound Endpoints - Wolverine - C#\nDESCRIPTION: This snippet shows how to utilize compound handler middleware in Wolverine that leverages nullable returns and the IEndpointMetadataProvider interface for detailed OpenAPI documentation. It includes a static endpoint class with methods for loading, validating, and handling user block commands. The Validate method returns an ASP.NET Core NotFound result wrapped in an optional, automatically affecting endpoint metadata. Appropriate for advanced Wolverine/ASP.NET Core projects, it requires Results API, WolverineDelete attribute, and relies on correct middleware processing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/metadata.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ValidatedCompoundEndpoint2\\n{\\n    public static User? Load(BlockUser2 cmd)\\n    {\\n        return cmd.UserId.IsNotEmpty() ? new User(cmd.UserId) : null;\\n    }\\n\\n    // This method would be called, and if the NotFound value is\\n    // not null, will stop the rest of the processing\\n    // Likewise, Wolverine will use the NotFound type to add\\n    // OpenAPI metadata\\n    public static NotFound? Validate(User? user)\\n    {\\n        if (user == null)\\n            return (NotFound?)Results.NotFound<User>(user);\\n\\n        return null;\\n    }\\n\\n    [WolverineDelete(\"/optional/result\")]\\n    public static  string Handle(BlockUser2 cmd, User user)\\n    {\\n        return \"Ok - user blocked\";\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Conventional Local Queue Routing in Wolverine C#\nDESCRIPTION: This snippet shows how to customize Wolverine's conventional local message routing during startup. It configures the policy to name local queues based on the message type's namespace (`Named(type => type.Namespace)`) and optionally customizes queue properties, such as making them process messages sequentially (`CustomizeQueues((type, listener) => { listener.Sequential(); })`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Out of the box, this uses a separate local queue\n        // for each message based on the message type name\n        opts.Policies.ConfigureConventionalLocalRouting()\n\n            // Or you can customize the usage of queues\n            // per message type\n            .Named(type => type.Namespace)\n\n            // Optionally configure the local queues\n            .CustomizeQueues((type, listener) => { listener.Sequential(); });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Testing Event Forwarding and Outbox Synchronization with Marten and Wolverine in C#\nDESCRIPTION: This test method, execution_of_forwarded_events_can_be_awaited_from_tests, constructs a host with Marten and Wolverine, configures event forwarding transformations, appends events to an aggregate, and verifies that the resulting event stream contains both the original and a subsequent event. The snippet demonstrates how to wire up service configuration for forwarding (including event transformation) and assert stream contents. Inputs include a test-specific aggregateId and event data; outputs are checks on the resulting event count and types. Intended for automated integration tests to confirm reliable event delivery.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-forwarding.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic async Task execution_of_forwarded_events_can_be_awaited_from_tests()\n{\n    var host = await Host.CreateDefaultBuilder()\n        .UseWolverine()\n        .ConfigureServices(services =>\n        {\n            services.AddMarten(Servers.PostgresConnectionString)\n                .IntegrateWithWolverine().EventForwardingToWolverine(opts =>\n                {\n                    opts.SubscribeToEvent<SecondEvent>().TransformedTo(e =>\n                        new SecondMessage(e.StreamId, e.Sequence));\n                });\n        }).StartAsync();\n\n    var aggregateId = Guid.NewGuid();\n    await host.SaveInMartenAndWaitForOutgoingMessagesAsync(session =>\n    {\n        session.Events.Append(aggregateId, new SecondEvent());\n    }, 100_000);\n\n    using var store = host.Services.GetRequiredService<IDocumentStore>();\n    await using var session = store.LightweightSession();\n    var events = await session.Events.FetchStreamAsync(aggregateId);\n    events.Count.ShouldBe(2);\n    events[0].Data.ShouldBeOfType<SecondEvent>();\n    events[1].Data.ShouldBeOfType<FourthEvent>();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a HandlerChain via Convention-Based Static Method (C#)\nDESCRIPTION: Defines a CustomizedHandler class with a static Configure(HandlerChain chain) method that modifies the handler's middleware and logging settings. When Wolverine detects this static Configure method, it automatically calls it for chain customization – here adding a CustomFrame middleware and altering log levels for success and processing events. Requires implementation of CustomFrame, LogLevel, and compatibility with Wolverine’s convention-based configuration system. Inputs are the HandlerChain during bootstrapping, and outputs a modified chain with customized execution and logging.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic class CustomizedHandler\n{\n    public void Handle(SpecialMessage message)\n    {\n        // actually handle the SpecialMessage\n    }\n\n    public static void Configure(HandlerChain chain)\n    {\n        chain.Middleware.Add(new CustomFrame());\n\n        // Turning off all execution tracking logging\n        // from Wolverine for just this message type\n        // Error logging will still be enabled on failures\n        chain.SuccessLogLevel = LogLevel.None;\n        chain.ProcessingLogLevel = LogLevel.None;\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Replacing ServiceProvider with Lamar using HostApplicationBuilder (C#)\nDESCRIPTION: Illustrates how to integrate Lamar as the DI container with HostApplicationBuilder, configuring the service container factory. This example uses the ServiceRegistry and LamarServiceProviderFactory types for advanced container setup. Intended for scenarios where HostApplicationBuilder is used and finer control over container configuration is needed. Requires Lamar NuGet package.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/configuration.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\\n\\n// Little ugly, and Lamar *should* have a helper for this...\\nbuilder.ConfigureContainer<ServiceRegistry>(new LamarServiceProviderFactory());\n```\n\n----------------------------------------\n\nTITLE: Defining a UserDefinedContinuation for Custom Error Actions in Wolverine - C#\nDESCRIPTION: Implements a reusable continuation by subclassing UserDefinedContinuation, enabling custom error handling logic to run when processing fails. On execution, the policy examines if the failed envelope's message is a ShipOrder and sends a ShippingFailed message in response. Intended for registration as a secondary action in error policies, this approach encapsulates error response logic for reuse. Requires IWolverineRuntime, IEnvelopeLifecycle, and message contract types.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ShippingOrderFailurePolicy : UserDefinedContinuation\n{\n    public ShippingOrderFailurePolicy() : base(\n        $\"Send a {nameof(ShippingFailed)} back to the sender on shipping order failures\")\n    {\n    }\n\n    public override async ValueTask ExecuteAsync(IEnvelopeLifecycle lifecycle, IWolverineRuntime runtime,\n        DateTimeOffset now, Activity activity)\n    {\n        if (lifecycle.Envelope?.Message is ShipOrder cmd)\n        {\n            await lifecycle\n                .RespondToSenderAsync(new ShippingFailed(cmd.OrderId));\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending a Message to a Specific Tenant in Wolverine (.NET, C#)\nDESCRIPTION: This snippet shows how to publish a message explicitly to a given tenant using Wolverine's messaging interface in a .NET application. The Send API includes DeliveryOptions where a TenantId can be specified, directing the message to the Azure Service Bus namespace or connection associated with that tenant. Requires prior transport configuration for multi-tenancy and access to an IMessageBus instance.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/multi-tenancy.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task send_message_to_specific_tenant(IMessageBus bus)\n{\n    // Send a message tagged to a specific tenant id\n    await bus.PublishAsync(new Message1(), new DeliveryOptions { TenantId = \"two\" });\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Marten and Wolverine with Durable Local Queue in C#\nDESCRIPTION: This C# snippet shows how to configure Marten by retrieving the connection string from application configuration (`builder.Configuration.GetConnectionString(\"postgres\")`) and integrating it with Wolverine's outbox using `IntegrateWithWolverine()`. Wolverine is then configured via `UseWolverine` to enable a durable inbox specifically for the local queue named \"important\". A commented-out option shows how to potentially place Wolverine's database objects into a separate schema.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/index.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Host.ApplyOaktonExtensions();\n\nbuilder.Services.AddMarten(opts =>\n    {\n        var connectionString = builder\n            .Configuration\n            .GetConnectionString(\"postgres\");\n\n        opts.Connection(connectionString);\n        opts.DatabaseSchemaName = \"orders\";\n    })\n    // Optionally add Marten/Postgresql integration\n    // with Wolverine's outbox\n    .IntegrateWithWolverine();\n\n// You can also place the Wolverine database objects\n// into a different database schema, in this case\n// named \"wolverine_messages\"\n//.IntegrateWithWolverine(\"wolverine_messages\");\n\nbuilder.Host.UseWolverine(opts =>\n{\n    // I've added persistent inbox\n    // behavior to the \"important\"\n    // local queue\n    opts.LocalQueue(\"important\")\n        .UseDurableInbox();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a File Writing Side Effect Record (C#)\nDESCRIPTION: Shows how to define a C# record `WriteFile` to encapsulate the data needed for writing a file (path, contents). It includes a `WriteAsync` method that performs the actual file writing using `File.WriteAllTextAsync`. This pattern allows Wolverine handlers to return this record, separating the decision to write from the action itself, relying on convention for execution.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/side-effects.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// This has to be public btw\npublic record WriteFile(string Path, string Contents)\n{\n    public Task WriteAsync()\n    {\n        return File.WriteAllTextAsync(Path, Contents);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MQTT Topic Names using [Topic] Attribute (C#)\nDESCRIPTION: Shows how to explicitly define the MQTT topic name for specific message types (`TopicMessage1`, `FirstMessage`) using the `[Topic(\"topic name\")]` attribute directly on the class definition. This specified topic name will be used when publishing messages of this type, particularly when using the `.ToMqttTopics()` publishing rule.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n[Topic(\"one\")]\npublic class TopicMessage1;\n```\n\nLANGUAGE: cs\nCODE:\n```\n[Topic(\"color.blue\")]\npublic class FirstMessage\n{\n    public Guid Id { get; set; } = Guid.NewGuid();\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Resource Setup on Startup with Wolverine and Marten in C#\nDESCRIPTION: Ensures all database-backed resources (like message storage tables) are set up in all tenant databases when the application starts. This method is invoked via dependency injection and applies to all registered databases. Requires Wolverine and Marten setup as shown previously. Parameterless method; affects application startup by pre-creating resources.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/multi-tenancy.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nbuilder.Services.AddResourceSetupOnStartup();\n```\n\n----------------------------------------\n\nTITLE: Configuring Durable Local Queues in Wolverine C#\nDESCRIPTION: This snippet illustrates how to configure local queues for durability in Wolverine. It shows making the default local queue durable using 'opts.DefaultLocalQueue.UseDurableInbox()' and configuring a specific named queue ('important') for durability using 'opts.LocalQueue(\"important\").UseDurableInbox()'. Durable queues persist messages until successful processing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Make the default local queue durable\n        opts.DefaultLocalQueue.UseDurableInbox();\n\n        // Or do just this by name\n        opts.LocalQueue(\"important\")\n            .UseDurableInbox();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Transactional Handler With Explicit [Transactional] Attribute (C#)\nDESCRIPTION: This C# handler shows explicit transactional processing using the [Transactional] attribute in Wolverine. The method handles a 'CreateDocCommand', using an injected IAsyncDocumentSession to interact with RavenDb. Upon receiving a command, it asynchronously stores a new 'FakeDoc' document, leveraging Wolverine's RavenDb-backed transaction management.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/ravendb.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\npublic class CreateDocCommandHandler\n{\n    [Transactional]\n    public async Task Handle(CreateDocCommand message, IAsyncDocumentSession session)\n    {\n        await session.StoreAsync(new FakeDoc { Id = message.Id });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Endpoints with Lambda-Based Policies (C#)\nDESCRIPTION: This snippet demonstrates configuring Wolverine HTTP endpoints using a lambda passed to MapWolverineEndpoints, enabling custom modifications at configuration time. The lambda adds OpenAPI metadata to HttpChain objects via WithMetadata and enables additional middleware such as Fluent Validation. Prerequisites include an ASP.NET Core application with Wolverine and possibly the Fluent Validation extension. No explicit inputs and outputs beyond mutation of endpoint configuration; usable for adding or customizing endpoint middleware and metadata.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/policies.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\napp.MapWolverineEndpoints(opts =>\\n{\\n    // This is strictly to test the endpoint policy\\n\\n    opts.ConfigureEndpoints(httpChain =>\\n    {\\n        // The HttpChain model is a configuration time\\n        // model of how the HTTP endpoint handles requests\\n\\n        // This adds metadata for OpenAPI\\n        httpChain.WithMetadata(new CustomMetadata());\\n    });\\n\\n    // more configuration for HTTP...\\n\\n    // Opting into the Fluent Validation middleware from\\n    // Wolverine.Http.FluentValidation\\n    opts.UseFluentValidationProblemDetailMiddleware();\n```\n\n----------------------------------------\n\nTITLE: Refactoring PlaceOrder Handler as Pure Function with Wolverine Side Effects in C#\nDESCRIPTION: Refactors the `PlaceOrderHandler` into a pure function that receives the `PlaceOrder` command and returns a Wolverine `Insert<Order>` side effect. This decouples the handler logic from direct persistence dependencies (like `IDocumentSession`), making it easier to unit test. The actual database insertion is handled by Wolverine middleware based on the returned side effect.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class PlaceOrderHandler\n{\n    // Pure function style using Wolverine side effects\n    public static Insert<Order> Handle(PlaceOrder command)\n    {\n        var order = new Order\n        {\n            Id = command.OrderId, \n            CustomerId = command.CustomerId, \n            Amount = command.Amount\n        };\n\n        // Return a side effect instruction to insert the order\n        return Storage.Insert(order);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Parameter Handling Strategy Interface in Wolverine C#\nDESCRIPTION: Shows the definition of the `IParameterStrategy` interface from `Wolverine.Http`. Implementing this interface allows developers to introduce custom logic for how Wolverine binds parameters in HTTP endpoint methods. The `TryMatch` method determines if the strategy applies to a given parameter and provides the necessary code generation `Variable` if it matches.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n/// Apply custom handling to a Wolverine.Http endpoint/chain based on a parameter within the\n/// implementing Wolverine http endpoint method\n/// </summary>\n/// <param name=\"variable\">The Variable referring to the input of this parameter</param>\npublic interface IParameterStrategy\n{\n    bool TryMatch(HttpChain chain, IServiceContainer container, ParameterInfo parameter, out Variable? variable);\n}\n```\n\n----------------------------------------\n\nTITLE: Modeling an Event-Sourced Order Aggregate with Marten - C#\nDESCRIPTION: This snippet models the order aggregate and associated item entity for an event-sourced domain following Marten conventions in C#. The Order class implements methods for applying events to update its state, supports versioning for event streams, and exposes logic to check readiness for shipping. Dependencies include Marten for event stream management and LINQ for collection queries. Key fields include Id, Version, Items, and Shipped, and methods leverage event application patterns for rebuilding aggregate state from events.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Item\n{\n    public string Name { get; set; }\n    public bool Ready { get; set; }\n}\n\npublic class Order\n{\n    public Order(OrderCreated created)\n    {\n        foreach (var item in created.Items) Items[item.Name] = item;\n    }\n\n    // This would be the stream id\n    public Guid Id { get; set; }\n\n    // This is important, by Marten convention this would\n    // be the\n    public int Version { get; set; }\n\n    public DateTimeOffset? Shipped { get; private set; }\n\n    public Dictionary<string, Item> Items { get; set; } = new();\n\n    // These methods are used by Marten to update the aggregate\n    // from the raw events\n    public void Apply(IEvent<OrderShipped> shipped)\n    {\n        Shipped = shipped.Timestamp;\n    }\n\n    public void Apply(ItemReady ready)\n    {\n        Items[ready.Name].Ready = true;\n    }\n\n    public bool IsReadyToShip()\n    {\n        return Shipped == null && Items.Values.All(x => x.Ready);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Kafka Messages with Partition Key using Wolverine in C#\nDESCRIPTION: Illustrates how to publish a message to Kafka using Wolverine's IMessageBus, specifying a partition key via DeliveryOptions. This ensures that messages with the same partition key are sent to the same Kafka partition, which is crucial for ordering guarantees within a partition. Depends on Wolverine.Core.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/kafka.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic static ValueTask publish_by_partition_key(IMessageBus bus)\n{\n    return bus.PublishAsync(new Message1(), new DeliveryOptions { PartitionKey = \"one\" });\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced Wolverine Tracked Session Configuration in C#\nDESCRIPTION: Illustrates advanced configuration options for Wolverine tracked sessions using the `TrackActivity()` fluent interface. It shows how to customize the session timeout, include messages sent via external transports, track activity across multiple `IHost` instances, suppress automatic assertions on exceptions, and wait for specific messages to be received by another host before completing the session.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npublic async Task using_tracked_sessions_advanced(IHost otherWolverineSystem)\n{\n    // The point here is just that you somehow have\n    // an IHost for your application\n    using var host = await Host.CreateDefaultBuilder()\n        .UseWolverine().StartAsync();\n\n    var debitAccount = new DebitAccount(111, 300);\n    var session = await host\n\n        // Start defining a tracked session\n        .TrackActivity()\n\n        // Override the timeout period for longer tests\n        .Timeout(1.Minutes())\n\n        // Be careful with this one! This makes Wolverine wait on some indication\n        // that messages sent externally are completed\n        .IncludeExternalTransports()\n\n        // Make the tracked session span across an IHost for another process\n        // May not be super useful to the average user, but it's been crucial\n        // to test Wolverine itself\n        .AlsoTrack(otherWolverineSystem)\n\n        // This is actually helpful if you are testing for error handling\n        // functionality in your system\n        .DoNotAssertOnExceptionsDetected()\n\n        // Again, this is testing against processes, with another IHost\n        .WaitForMessageToBeReceivedAt<LowBalanceDetected>(otherWolverineSystem)\n\n        // There are many other options as well\n        .InvokeMessageAndWaitAsync(debitAccount);\n\n    var overdrawn = session.Sent.SingleMessage<AccountOverdrawn>();\n    overdrawn.AccountId.ShouldBe(debitAccount.AccountId);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Todo Data Model (C#)\nDESCRIPTION: Defines a Plain Old C# Object (POCO) class named `Todo`. This class represents the data structure for a todo item with properties for `Id`, `Name`, and `IsComplete`. It serves as the data model for persistence and API responses in the subsequent examples.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic class Todo\n{\n    public int Id { get; set; }\n    public string? Name { get; set; }\n    public bool IsComplete { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Wolverine with RavenDb and Transactional Policies (Alternative, C#)\nDESCRIPTION: This alternative .NET C# snippet shows bootstrapping Wolverine to use RavenDb persistence with automatic application of transaction policies. By calling 'UseRavenDbPersistence' and 'AutoApplyTransactions', all handlers using IAsyncDocumentSession will have transactional middleware applied. Requires WolverineFx.RavenDb and appropriate configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/ravendb.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n        builder.UseWolverine(opts =>\n        {\n            // That's it, nothing more to see here\n            opts.UseRavenDbPersistence();\n            \n            // The RavenDb integration supports basic transactional\n            // middleware just fine\n            opts.Policies.AutoApplyTransactions();\n        });\n```\n\n----------------------------------------\n\nTITLE: Overriding Conventional RabbitMQ Exchange Routing Conventions in Wolverine C#\nDESCRIPTION: This snippet illustrates advanced override of the default exchange and queue routing conventions in Wolverine's RabbitMQ integration. It features separate sender and receiver hosts, each configured to append '_custom' to exchange names. For specific message types (e.g., HeadersMessage), the snippet sets the exchange type to 'Headers', and for receivers, demonstrates custom queue binding with additional binding arguments (such as tenant-id). This requires familiarity with RabbitMQ exchange types, message type detection, and WolverineHost configuration. Target use-case: multi-tenant or header-based routing scenarios.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/conventional-routing.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar sender = WolverineHost.For(opts =>\n{\n    opts.UseRabbitMq()\n        .UseConventionalRouting(conventions =>\n        {\n            conventions.ExchangeNameForSending(type => type.Name + \"_custom\");\n            conventions.ConfigureSending((x, c) =>\n            {\n                // Route messages via headers exchange whilst taking advantage of conventional naming\n                if (c.MessageType == typeof(HeadersMessage))\n                {\n                    x.ExchangeType(ExchangeType.Headers);\n                }\n            });\n        });\n});\n\nvar receiver = WolverineHost.For(opts =>\n{\n    opts.UseRabbitMq()\n        .UseConventionalRouting(conventions =>\n        {\n            conventions.ExchangeNameForSending(type => type.Name + \"_custom\");\n            conventions.ConfigureListeners((x, c) =>\n            {\n                if (c.MessageType == typeof(HeadersMessage))\n                {\n                    // Bind our queue based on the headers tenant-id\n                    x.BindToExchange<HeadersMessage>(ExchangeType.Headers,\n                        arguments: new Dictionary<string, object>()\n                        {\n                            { \"tenant-id\", \"tenant-id\" }\n                        });\n                }\n            });\n        });\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an Extension Method to Register Transport Disabling Extension in C#\nDESCRIPTION: Defines the `DisableAllExternalWolverineTransports` extension method for `IServiceCollection`. This method registers the `DisableExternalTransports` extension as a singleton `IWolverineExtension` in the IoC container.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic static IServiceCollection DisableAllExternalWolverineTransports(this IServiceCollection services)\n{\n    services.AddSingleton<IWolverineExtension, DisableExternalTransports>();\n    return services;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Inserting Entities with Wolverine Storage Actions in C#\nDESCRIPTION: This C# snippet demonstrates a message handler `CreateItemHandler` that returns an `IStorageAction<Item>`. Based on a profanity check using `IProfanityDetector`, it either returns `Storage.Insert` to indicate a new `Item` should be persisted or `Storage.Nothing<Item>` to signify no action should be taken. This keeps the handler's logic pure and delegates the actual persistence to Wolverine's infrastructure.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/side-effects.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\npublic record CreateItem(Guid Id, string Name);\n\npublic static class CreateItemHandler\n{\n    // It's always a struggle coming up with sample use cases\n    public static IStorageAction<Item> Handle(\n        CreateItem command, \n        IProfanityDetector detector)\n    {\n        // First see if the name is valid\n        if (detector.HasProfanity(command.Name))\n        {\n            // and if not, do nothing\n            return Storage.Nothing<Item>();\n        }\n\n        return Storage.Insert(new Item\n        {\n            Id = command.Id, \n            Name = command.Name\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Handler Match using Wolverine in C#\nDESCRIPTION: This snippet demonstrates how to use the DescribeHandlerMatch diagnostic function from WolverineOptions to obtain a detailed report explaining why a given type (e.g., MyMissingMessageHandler) is or is not being discovered as a message handler by Wolverine. It requires a .NET application with Wolverine set up, using Host.CreateDefaultBuilder and UseWolverine for configuration. The Console.WriteLine statement outputs the discovery results; expected output is a string explanation printed to the console. The snippet is useful for troubleshooting handler resolution issues in .NET applications using Wolverine.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/discovery.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Surely plenty of other configuration for Wolverine...\n\n        // This *temporary* line of code will write out a full report about why or\n        // why not Wolverine is finding this handler and its candidate handler messages\n        Console.WriteLine(opts.DescribeHandlerMatch(typeof(MyMissingMessageHandler)));\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Message Records in Wolverine (C#)\nDESCRIPTION: This snippet defines two message record types—'DebitAccount' as a command and 'AccountOverdrawn' as an event—using C# record structs for immutability and value semantics, key for messaging patterns in Wolverine. There are no dependencies other than being part of a Wolverine-based messaging solution. 'DebitAccount' takes an account ID and an amount to debit, and 'AccountOverdrawn' signals an overdraft event for an account; both serve as strongly-typed contracts for message handling.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/runtime.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// A \"command\" message\\npublic record DebitAccount(long AccountId, decimal Amount);\\n\\n// An \"event\" message\\npublic record AccountOverdrawn(long AccountId);\n```\n\n----------------------------------------\n\nTITLE: Conceptual Stopwatch Timing Logic in C#\nDESCRIPTION: This C# snippet illustrates the basic conceptual code structure for timing an operation (like an HTTP request or message handling) using `System.Diagnostics.Stopwatch`. It shows starting a stopwatch before the operation, executing the operation within a try block, and stopping the stopwatch and logging the duration within a finally block to ensure timing is captured even if errors occur.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar stopwatch = new Stopwatch();\nstopwatch.Start();\ntry\n{\n    // execute the HTTP request\n    // or message\n}\nfinally\n{\n    stopwatch.Stop();\n    logger.LogInformation(\"Ran something in \" + stopwatch.ElapsedMilliseconds);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Commands with RavenOps Side Effects (C#)\nDESCRIPTION: This C# record and static handler use the Wolverine 'RavenOps' side-effect model. The handler receives a 'RecordTeam' command and returns an IRavenDbOp operation to store a new 'Team' document. Side effects are processed by Wolverine's pipeline, allowing for concise, composable RavenDb operations without direct session access. 'RavenOps' must be present and configured.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/ravendb.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic record RecordTeam(string Team, int Year);\n\npublic static class RecordTeamHandler\n{\n    public static IRavenDbOp Handle(RecordTeam command)\n    {\n        return RavenOps.Store(new Team { Id = command.Team, YearFounded = command.Year });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Various Valid Handler Methods - Wolverine (.NET C#)\nDESCRIPTION: This comprehensive snippet shows multiple valid configurations for message handler methods in Wolverine. Experimental features include method naming conventions (Handle, Consume), synchronous and asynchronous forms, use of injected services as parameters (e.g., IDocumentSession, IEmailService), methods cascading single or multiple messages, and use of both value and regular tasks. At the class level, the [WolverineHandler] attribute is used. Requires definitions for Message1, Message2, Message3, IDocumentSession, IEmailService. Outputs and inputs vary by method signature; handlers can return tasks, value tasks, messages, or void.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n[WolverineHandler]\npublic class ValidMessageHandlers\n{\n    // There's only one argument, so we'll assume that\n    // argument is the message\n    public void Handle(Message1 something)\n    {\n    }\n\n    // The parameter named \"message\" is assumed to be the message type\n    public Task ConsumeAsync(Message1 message, IDocumentSession session)\n    {\n        return session.SaveChangesAsync();\n    }\n\n    // In this usage, we're \"cascading\" a new message of type\n    // Message2\n    public Task<Message2> HandleAsync(Message1 message, IDocumentSession session)\n    {\n        return Task.FromResult(new Message2());\n    }\n\n    // In this usage we're \"cascading\" 0 to many additional\n    // messages from the return value\n    public IEnumerable<object> Handle(Message3 message)\n    {\n        yield return new Message1();\n        yield return new Message2();\n    }\n\n    // It's perfectly valid to have multiple handler methods\n    // for a given message type. Each will be called in sequence\n    // they were discovered\n    public void Consume(Message1 input, IEmailService emails)\n    {\n    }\n\n    // You can inject additional services directly into the handler\n    // method\n    public ValueTask ConsumeAsync(Message3 weirdName, IEmailService service)\n    {\n        return ValueTask.CompletedTask;\n    }\n\n    public interface IEvent\n    {\n        string CustomerId { get; }\n        Guid Id { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure Service Bus Endpoints with Sessions in Wolverine (C#)\nDESCRIPTION: This snippet configures a .NET host to listen to and publish on Azure Service Bus queues and topics requiring session identifiers, using the Wolverine framework. It utilizes various options such as auto provisioning, session enforcement, sequential message processing, and special topic handling. Dependencies include .NET, the Wolverine framework, and relevant Azure Service Bus libraries. Parameters such as queue/topic names and session counts are highlighted; output is a running host ready to handle bus messages according to these rules.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/session-identifiers.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n_host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAzureServiceBusTesting()\n            .AutoProvision().AutoPurgeOnStartup();\n\n        opts.ListenToAzureServiceBusQueue(\"send_and_receive\");\n        opts.PublishMessage<AsbMessage1>().ToAzureServiceBusQueue(\"send_and_receive\");\n\n        opts.ListenToAzureServiceBusQueue(\"fifo1\")\n\n            // Require session identifiers with this queue\n            .RequireSessions()\n\n            // This controls the Wolverine handling to force it to process\n            // messages sequentially\n            .Sequential();\n\n        opts.PublishMessage<AsbMessage2>()\n            .ToAzureServiceBusQueue(\"fifo1\");\n\n        opts.PublishMessage<AsbMessage3>().ToAzureServiceBusTopic(\"asb3\");\n        opts.ListenToAzureServiceBusSubscription(\"asb3\")\n            .FromTopic(\"asb3\")\n\n            // Require sessions on this subscription\n            .RequireSessions(1)\n\n            .ProcessInline();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Previewing Message Routing Programmatically in Wolverine (C#)\nDESCRIPTION: This snippet shows how to access and display Wolverine message routes for a specific message type using IWolverineRuntime obtained from the application's IHost. Dependencies include IWolverineRuntime, and the code optionally checks for a ToString override available in newer Wolverine versions. Inputs are an IHost with Wolverine configured; output is a log of route details for diagnostic purposes. Requires proper type references, e.g., MyMessage, and relevant using statements for debugging and LINQ methods.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/subscriptions.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void PreviewRouting(IHost host)\n{\n    // In test projects, you would probably have access to the IHost for \n    // the running application\n\n    // First, get access to the Wolverine runtime for the application\n    // It's registered by Wolverine as a singleton in your IoC container\n    var runtime = host.Services.GetRequiredService<IWolverineRuntime>();\n    \n    var router = runtime.RoutingFor(typeof(MyMessage));\n    \n    // If using Wolverine 3.6 or later when we added more\n    // ToString() behavior for exactly this reason\n    foreach (var messageRoute in router.Routes)\n    {\n        Debug.WriteLine(messageRoute);\n    }\n    \n    // Otherwise, you might have to do this to \"see\" where\n    // the routing is going\n    foreach (var route in router.Routes.OfType<MessageRoute>())\n    {\n        Debug.WriteLine(route.Sender.Destination);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Programmatically Managing Wolverine Message Storage in C#\nDESCRIPTION: Provides examples of managing the Wolverine message store programmatically using an `IHost` instance. It covers applying database changes (`SetupResources`), tearing down storage (`TeardownResources`), clearing storage and broker messages (`ResetResourceState`), rebuilding the schema (`store.Admin.RebuildAsync`), and clearing persisted messages (`store.Admin.ClearAllAsync`). This is particularly useful for automated testing setup and teardown.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n// IHost would be your application in a testing harness\npublic static async Task testing_setup_or_teardown(IHost host)\n{\n    // Programmatically apply any outstanding message store\n    // database changes\n    await host.SetupResources();\n\n    // Teardown the database message storage\n    await host.TeardownResources();\n\n    // Clear out any database message storage\n    // also tries to clear out any messages held\n    // by message brokers connected to your Wolverine app\n    await host.ResetResourceState();\n\n    var store = host.Services.GetRequiredService<IMessageStore>();\n\n    // Rebuild the database schema objects\n    // and delete existing message data\n    // This is good for testing\n    await store.Admin.RebuildAsync();\n\n    // Remove all persisted messages\n    await store.Admin.ClearAllAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Marten Order Aggregate and Events in C#\nDESCRIPTION: Shows the C# record and class definitions for an `Order` aggregate designed for Marten event sourcing. Includes various event types (`OrderCreated`, `ItemReady`, `OrderShipped`), command types (`ShipOrder`), and the `Order` aggregate class itself with state properties and `Apply` methods for event handling. This structure models an order workflow.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// OrderId refers to the identity of the Order aggregate\npublic record MarkItemReady(Guid OrderId, string ItemName, int Version);\n\npublic record OrderShipped;\npublic record OrderCreated(Item[] Items);\npublic record OrderReady;\npublic record OrderConfirmed;\npublic interface IShipOrder\n{\n    Guid OrderId { init; }\n}\npublic record ShipOrder(Guid OrderId) : IShipOrder;\npublic record ShipOrder2(string Description);\npublic record ItemReady(string Name);\n\npublic class Item\n{\n    public string Name { get; set; }\n    public bool Ready { get; set; }\n}\n\npublic class Order\n{\n    // For JSON serialization\n    public Order(){}\n    \n    public Order(OrderCreated created)\n    {\n        foreach (var item in created.Items) Items[item.Name] = item;\n    }\n\n    // This would be the stream id\n    public Guid Id { get; set; }\n\n    // This is important, by Marten convention this would\n    // be the\n    public int Version { get; set; }\n\n    public DateTimeOffset? Shipped { get; private set; }\n\n    public Dictionary<string, Item> Items { get; set; } = new();\n    public bool HasShipped { get; set; }\n\n    // These methods are used by Marten to update the aggregate\n    // from the raw events\n    public void Apply(IEvent<OrderShipped> shipped)\n    {\n        Shipped = shipped.Timestamp;\n    }\n\n    public void Apply(ItemReady ready)\n    {\n        Items[ready.Name].Ready = true;\n    }\n\n    public void Apply(OrderConfirmed confirmed)\n    {\n        IsConfirmed = true;\n    }\n\n    public bool IsConfirmed { get; set; }\n\n    public bool IsReadyToShip()\n    {\n        return Shipped == null && Items.Values.All(x => x.Ready);\n    }\n\n    public bool IsShipped() => Shipped.HasValue;\n}\n```\n\n----------------------------------------\n\nTITLE: Previewing Generated Source Code with Oakton (Bash CLI)\nDESCRIPTION: This Bash CLI snippet calls the JasperFx.CodeGeneration.Commands feature, installed as part of Wolverine, to preview the generated source code for all message handlers and HTTP endpoints. It requires the Oakton command line integration and must be executed from the application's root directory. Output is printed code for inspection; there are no parameters other than the command, but the application must be buildable and Oakton must be referenced.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/codegen.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- codegen preview\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom SubTaskCompletedBatcher in Wolverine (C#)\nDESCRIPTION: This C# class realizes the IMessageBatcher interface to group SubTaskCompleted events by TaskId into SubTaskCompletedBatch messages. The Group method groups envelopes based on TaskId, aggregates SubTaskIds, and yields new Envelope instances with batch messages and source envelopes for transactional tracking. Dependencies include the definition of Envelope, SubTaskCompleted, and SubTaskCompletedBatch, as well as LINQ for grouping and selection. This implementation is essential for enabling custom batching logic based on business requirements.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/batching.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class SubTaskCompletedBatcher : IMessageBatcher\n{\n    public IEnumerable<Envelope> Group(IReadOnlyList<Envelope> envelopes)\n    {\n        var groups = envelopes\n            // You can trust that the message will be a non-null SubTaskCompleted here\n            .GroupBy(x => x.Message!.As<SubTaskCompleted>().TaskId)\n            .ToArray();\n        \n        foreach (var group in groups)\n        {\n            var subTaskIdList = group\n                .Select(x => x.Message)\n                .OfType<SubTaskCompleted>()\n                .Select(x => x.SubTaskId)\n                .ToArray();\n            \n            var message = new SubTaskCompletedBatch(group.Key,\n                subTaskIdList);\n\n            // It's important here to pass along the group of envelopes that make up \n            // this batched message for Wolverine's transactional inbox/outbox\n            // tracking\n            yield return new Envelope(message, group);\n        }\n    }\n\n    public Type BatchMessageType => typeof(SubTaskCompletedBatch);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Wolverine Endpoints by URI in C#\nDESCRIPTION: This snippet shows how to access and interact with a specific Wolverine endpoint using its URI. It demonstrates invoking a message handler on an endpoint identified by a RabbitMQ queue URI (`rabbitmq://queue/rabbit-one`) using the `InvokeAsync` method on the endpoint object obtained via `bus.EndpointFor(Uri)`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/endpoint-operations.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n// Or access operations on a specific endpoint using a Uri\nawait bus.EndpointFor(new Uri(\"rabbitmq://queue/rabbit-one\"))\n    .InvokeAsync(new SomeMessage());\n```\n\n----------------------------------------\n\nTITLE: Cascading Messages via OutgoingMessages from Wolverine HTTP Endpoint (C#)\nDESCRIPTION: Illustrates how to return multiple messages to be published from a Wolverine HTTP endpoint using the `OutgoingMessages` collection. The endpoint method, decorated with `[WolverinePost]`, returns a tuple containing the primary response (`string`) and an `OutgoingMessages` object populated with various message instances. Wolverine automatically publishes these messages upon successful execution of the endpoint. This endpoint returns a string response body ('got it') and a 200 OK status code.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/messaging.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// This would have a string response and a 200 status code\n[WolverinePost(\"/spawn\")]\npublic static (string, OutgoingMessages) Post(SpawnInput input)\n{\n    var messages = new OutgoingMessages\n    {\n        new HttpMessage1(input.Name),\n        new HttpMessage2(input.Name),\n        new HttpMessage3(input.Name),\n        new HttpMessage4(input.Name)\n    };\n\n    return (\"got it\", messages);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Periodic Ping Publisher Worker in C#\nDESCRIPTION: Defines a BackgroundService named Worker that publishes a new Ping message every second via the IMessageBus. The service logs each outgoing message and increments the pingNumber on each iteration, leveraging dependency injection for logging and message bus access. Designed to support graceful shutdown via the provided CancellationToken, this snippet requires the Messages library and Wolverine to be referenced. The main inputs are logger and bus via constructor injection; there are no specific outputs except console logs and published messages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/ping-pong.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nusing Messages;\nusing Wolverine;\n\nnamespace Pinger;\n\npublic class Worker : BackgroundService\n{\n    private readonly ILogger<Worker> _logger;\n    private readonly IMessageBus _bus;\n\n    public Worker(ILogger<Worker> logger, IMessageBus bus)\n    {\n        _logger = logger;\n        _bus = bus;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        var pingNumber = 1;\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            await Task.Delay(1000, stoppingToken);\n            _logger.LogInformation(\"Sending Ping #{Number}\", pingNumber);\n            await _bus.PublishAsync(new Ping { Number = pingNumber });\n            pingNumber++;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RavenOps Utility Methods for Side Effects (C#)\nDESCRIPTION: This static C# class offers convenience methods for creating side-effect operations compatible with Wolverine's RavenDb integration. Methods include 'Store' for adding documents, 'DeleteDocument' for deleting by object reference, and 'DeleteById' for deleting documents by string ID. Each returns an IRavenDbOp, which is processed by Wolverine's side-effect pipeline. This class must be accessible to handlers wishing to produce storage actions without direct session usage.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/ravendb.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n/// Side effect helper class for Wolverine's integration with RavenDb\n/// </summary>\npublic static class RavenOps\n{\n    /// <summary>\n    /// Store a new RavenDb document\n    /// </summary>\n    /// <param name=\"document\"></param>\n    /// <typeparam name=\"T\"></typeparam>\n    /// <returns></returns>\n    public static IRavenDbOp Store<T>(T document) => new StoreDoc<T>(document);\n\n    /// <summary>\n    /// Delete this document in RavenDb\n    /// </summary>\n    /// <param name=\"document\"></param>\n    /// <returns></returns>\n    public static IRavenDbOp DeleteDocument(object document) => new DeleteByDoc(document);\n\n    /// <summary>\n    /// Delete a RavenDb document by its id\n    /// </summary>\n    /// <param name=\"id\"></param>\n    /// <returns></returns>\n    public static IRavenDbOp DeleteById(string id) => new DeleteById(id);\n}\n```\n\n----------------------------------------\n\nTITLE: Routing Message Type to Local Queue via Attribute in C#\nDESCRIPTION: This snippet illustrates how to route all messages of a specific type (`ImportanceMessage`) to a designated local queue ('important') using the `[LocalQueue]` attribute directly on the message class definition. This provides a declarative way to configure local routing for a message type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n[LocalQueue(\"important\")]\npublic class ImportanceMessage;\n```\n\n----------------------------------------\n\nTITLE: Configuring Route-Based Tenant ID Detection in Wolverine HTTP (C#)\nDESCRIPTION: This C# code configures Wolverine HTTP endpoints, specifically setting up tenant ID detection based on a route argument named 'tenant'. It also uses `AssertExists()` to ensure that a tenant ID is successfully detected for the request; otherwise, it returns a 400 Bad Request response with ProblemDetails. This is suitable for scenarios where the tenant is part of the URL path.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// Let's add in Wolverine HTTP endpoints to the routing tree\napp.MapWolverineEndpoints(opts =>\n{\n    // Letting Wolverine HTTP automatically detect the tenant id!\n    opts.TenantId.IsRouteArgumentNamed(\"tenant\");\n\n    // Assert that the tenant id was successfully detected,\n    // or pull the rip cord on the request and return a\n    // 400 w/ ProblemDetails\n    opts.TenantId.AssertExists();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Tenant ID Detection Strategies in Wolverine HTTP (C#)\nDESCRIPTION: This C# snippet demonstrates configuring various tenant ID detection strategies within an ASP.NET Core application using Wolverine.HTTP. It shows how to set up detection based on request headers, claims, query strings, route arguments, subdomains, and a default fallback, configured within the `MapWolverineEndpoints` options. The strategies are evaluated in order, with the first successful detection taking precedence.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = WebApplication.CreateBuilder();\n\nvar connectionString = builder.Configuration.GetConnectionString(\"postgres\");\n\nbuilder.Services\n    .AddMarten(connectionString)\n    .IntegrateWithWolverine();\n\nbuilder.Host.UseWolverine(opts =>\n{\n    opts.Policies.AutoApplyTransactions();\n});\n\nvar app = builder.Build();\n\n// Configure the WolverineHttpOptions\napp.MapWolverineEndpoints(opts =>\n{\n    // The tenancy detection is fall through, so the first strategy\n    // that finds anything wins!\n\n    // Use the value of a named request header\n    opts.TenantId.IsRequestHeaderValue(\"tenant\");\n\n    // Detect the tenant id from an expected claim in the\n    // current request's ClaimsPrincipal\n    opts.TenantId.IsClaimTypeNamed(\"tenant\");\n\n    // Use a query string value for the key 'tenant'\n    opts.TenantId.IsQueryStringValue(\"tenant\");\n\n    // Use a named route argument for the tenant id\n    opts.TenantId.IsRouteArgumentNamed(\"tenant\");\n\n    // Use the *first* sub domain name of the request Url\n    // Note that this is very naive\n    opts.TenantId.IsSubDomainName();\n    \n    // If the tenant id cannot be detected otherwise, fallback\n    // to a designated tenant id\n    opts.TenantId.DefaultIs(\"default_tenant\");\n\n});\n\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Defining a Message Type for Sticky Handling in C#\nDESCRIPTION: Defines a simple C# class `StickyMessage` which serves as the message type used in subsequent examples demonstrating Wolverine's sticky handler functionality. This class itself has no properties or methods and acts purely as a marker type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/sticky.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic class StickyMessage;\n\n```\n\n----------------------------------------\n\nTITLE: Sending Outgoing Messages from Before Middleware in Wolverine (C#)\nDESCRIPTION: Shows how middleware methods can emit outgoing messages using IMessageBus in Wolverine. If a business rule (here, a property check) fails, the handler publishes a notification and returns HandlerContinuation.Stop to abort further message processing. Requires IMessageBus as a dependency and may return either Stop or Continue depending on validation logic.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class MaybeBadThingHandler\n{\n    public static async Task<HandlerContinuation> ValidateAsync(MaybeBadThing thing, IMessageBus bus)\n    {\n        if (thing.Number > 10)\n        {\n            await bus.PublishAsync(new RejectYourThing(thing.Number));\n            return HandlerContinuation.Stop;\n        }\n\n        return HandlerContinuation.Continue;\n    }\n\n    public static void Handle(MaybeBadThing message)\n    {\n        Debug.WriteLine(\"Got \" + message);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Account Lookup Middleware in Wolverine - C#\nDESCRIPTION: Implements an asynchronous middleware method matching Wolverine's conventions, pre-loading an Account for any IAccountCommand and deciding whether to continue handler execution. Utilizes IDocumentSession for database access and ILogger for logging. If no Account is found, logs the situation, responds with InvalidAccount, and stops processing; otherwise, passes along the Account. Adheres to parameter and return conventions for BeforeAsync middleware in Wolverine; relies on HandlerContinuation and OutgoingMessages from Wolverine.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/middleware.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// This is *a* way to build middleware in Wolverine by basically just\n// writing functions/methods. There's a naming convention that\n// looks for Before/BeforeAsync or After/AfterAsync\npublic static class AccountLookupMiddleware\n{\n    // The message *has* to be first in the parameter list\n    // Before or BeforeAsync tells Wolverine this method should be called before the actual action\n    public static async Task<(HandlerContinuation, Account?, OutgoingMessages)> LoadAsync(\n        IAccountCommand command,\n        ILogger logger,\n\n        // This app is using Marten for persistence\n        IDocumentSession session,\n\n        CancellationToken cancellation)\n    {\n        var messages = new OutgoingMessages();\n        var account = await session.LoadAsync<Account>(command.AccountId, cancellation);\n        if (account == null)\n        {\n            logger.LogInformation(\"Unable to find an account for {AccountId}, aborting the requested operation\", command.AccountId);\n\n            messages.RespondToSender(new InvalidAccount(command.AccountId));\n            return (HandlerContinuation.Stop, null, messages);\n        }\n\n        // messages would be empty here\n        return (HandlerContinuation.Continue, account, messages);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Tenant Id Existence in Wolverine Endpoints - C#\nDESCRIPTION: This snippet demonstrates how to configure Wolverine HTTP endpoints to require the presence of a tenant id for every request by calling opts.TenantId.AssertExists(). If the tenant id is missing or null, the request responds with a 400 status code using the ProblemDetails format. This is typically used during API setup and requires that app.MapWolverineEndpoints is available in your startup configuration. Inputs include endpoint options; there are no outputs except side effects on endpoint validation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\napp.MapWolverineEndpoints(opts =>\n{\n    // Configure your tenant id detection...\n\n    // Require tenant id some how, some way...\n    opts.TenantId.AssertExists();\n});\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Wolverine with Ancillary Marten Stores in C#\nDESCRIPTION: Configures host startup by registering the main Marten store and multiple ancillary stores using AddMartenStore along with explicit schema and multi-tenancy configurations. Integrates each store with Wolverine using IntegrateWithWolverine(), sets up event subscriptions and publishing, adjusts durability mode, and ensures resource initialization at startup. The sample expects pre-defined connection strings and dependencies: Marten, Wolverine, and Microsoft.Extensions.Hosting.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/ancillary-stores.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\ntheHost = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Services.AddMarten(Servers.PostgresConnectionString).IntegrateWithWolverine();\n\n        opts.Policies.AutoApplyTransactions();\n        opts.Durability.Mode = DurabilityMode.Solo;\n\n        opts.Services.AddMartenStore<IPlayerStore>(m =>\n        {\n            m.Connection(Servers.PostgresConnectionString);\n            m.DatabaseSchemaName = \"players\";\n        })\n            .IntegrateWithWolverine()\n            \n            // Add a subscription\n            .SubscribeToEvents(new ColorsSubscription())\n            \n            // Forward events to wolverine handlers\n            .PublishEventsToWolverine(\"PlayerEvents\", x =>\n            {\n                x.PublishEvent<ColorsUpdated>();\n            });\n        \n        // Look at that, it even works with Marten multi-tenancy through separate databases!\n        opts.Services.AddMartenStore<IThingStore>(m =>\n        {\n            m.MultiTenantedDatabases(tenancy =>\n            {\n                tenancy.AddSingleTenantDatabase(tenant1ConnectionString, \"tenant1\");\n                tenancy.AddSingleTenantDatabase(tenant2ConnectionString, \"tenant2\");\n                tenancy.AddSingleTenantDatabase(tenant3ConnectionString, \"tenant3\");\n            });\n            m.DatabaseSchemaName = \"things\";\n        }).IntegrateWithWolverine(masterDatabaseConnectionString:Servers.PostgresConnectionString);\n\n        opts.Services.AddResourceSetupOnStartup();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining a Versioned Wolverine Message in C#\nDESCRIPTION: This snippet defines `PersonBornV2`, a new version of the `PersonBorn` message. The `[MessageIdentity(\"person-born\", Version = 2)]` attribute specifies both the message alias (\"person-born\") and explicitly sets its version to 2. This allows Wolverine to handle different versions of the same conceptual message, potentially with different structures.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n[MessageIdentity(\"person-born\", Version = 2)]\npublic class PersonBornV2\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    public DateTime Birthday { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping HTTP Requests to Send Wolverine Messages (C#)\nDESCRIPTION: This snippet shows how to configure Wolverine during application startup to directly map incoming HTTP requests to specific message types and send them using Wolverine's message bus. It uses `app.MapWolverineEndpoints` and the `opts.SendMessage<T>()` method to define routes (`/orders/create`, `/orders/ship`) and corresponding message types (`CreateOrder`, `ShipOrder`). This automatically handles deserialization and sending, returning a 202 Accepted status code. Optional configuration, like adding authorization metadata, can be chained.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/messaging.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = WebApplication.CreateBuilder();\n\nbuilder.Host.UseWolverine();\n\nvar app = builder.Build();\n\napp.MapWolverineEndpoints(opts =>\n{\n    opts.SendMessage<CreateOrder>(\"/orders/create\", chain =>\n    {\n        // You can make any necessary metadata configurations exactly\n        // as you would for Minimal API endpoints with this syntax\n        // to fine tune OpenAPI generation or security\n        chain.Metadata.RequireAuthorization();\n    });\n    opts.SendMessage<ShipOrder>(HttpMethod.Put, \"/orders/ship\");\n});\n\n// and the rest of your application configuration and bootstrapping\n```\n\n----------------------------------------\n\nTITLE: Configuring Metrics Export and Tracing with Honeycomb and Wolverine in .NET\nDESCRIPTION: This C# snippet demonstrates configuring a HostBuilder to use Wolverine's metrics and OpenTelemetry integration. It shows how to customize logging behavior, add tags for specific message interfaces, and export metrics and traces to Honeycomb. Prerequisites include a .NET application, Wolverine, OpenTelemetry extensions, and Honeycomb configuration. Inputs include configuration context and a Honeycomb options provider; the resulting host supports metrics and distributed tracing instrumentation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar host = Host.CreateDefaultBuilder(args)\n    .UseWolverine((context, opts) =>\n    {\n        opts.ServiceName = \"Metrics\";\n \n        // Open Telemetry *should* cover this anyway, but\n        // if you want Wolverine to log a message for *beginning*\n        // to execute a message, try this\n        opts.Policies.LogMessageStarting(LogLevel.Debug);\n         \n        // For both Open Telemetry span tracing and the \"log message starting...\"\n        // option above, add the AccountId as a tag for any command that implements\n        // the IAccountCommand interface\n        opts.Policies.ForMessagesOfType<IAccountCommand>().Audit(x => x.AccountId);\n         \n        // Setting up metrics and Open Telemetry activity tracing\n        // to Honeycomb\n        var honeycombOptions = context.Configuration.GetHoneycombOptions();\n        honeycombOptions.MetricsDataset = \"Wolverine:Metrics\";\n         \n        opts.Services.AddOpenTelemetry()\n            // enable metrics\n            .WithMetrics(x =>\n            {\n                // Export metrics to Honeycomb\n                x.AddHoneycomb(honeycombOptions);\n            })\n             \n            // enable Otel span tracing\n            .WithTracing(x =>\n            {\n                x.AddHoneycomb(honeycombOptions);\n                x.AddSource(\"Wolverine\");\n            });\n \n    })\n    .UseResourceSetupOnStartup()\n    .Build();\n \nawait host.RunAsync();\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Headless Service with Wolverine and OpenTelemetry (C#)\nDESCRIPTION: Configures a console-style (headless) .NET application using HostBuilder with Wolverine, RabbitMQ messaging, service discovery, and OpenTelemetry tracing. Shows explicit transport configuration, message handler registration, automatic provisioning, and diagnostics integration using Oakton. Required dependencies include Wolverine, RabbitMQ client libraries, OpenTelemetry, and Oakton. Accepts handler and messaging constants as parameters; outputs a started application pipeline.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/configuration.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nreturn await Host.CreateDefaultBuilder(args)\\n    .UseWolverine(opts =>\\n    {\\n        opts.ServiceName = \"Subscriber1\";\\n\\n        opts.Discovery.DisableConventionalDiscovery().IncludeType<Subscriber1Handlers>();\\n\\n        opts.ListenAtPort(MessagingConstants.Subscriber1Port);\\n\\n        opts.UseRabbitMq().AutoProvision();\\n\\n        opts.ListenToRabbitQueue(MessagingConstants.Subscriber1Queue);\\n\\n        // Publish to the other subscriber\\n        opts.PublishMessage<RabbitMessage2>().ToRabbitQueue(MessagingConstants.Subscriber2Queue);\\n\\n        // Add Open Telemetry tracing\\n        opts.Services.AddOpenTelemetryTracing(builder =>\\n        {\\n            builder\\n                .SetResourceBuilder(ResourceBuilder\\n                    .CreateDefault()\\n                    .AddService(\"Subscriber1\"))\\n                .AddJaegerExporter()\\n\\n                // Add Wolverine as a source\\n                .AddSource(\"Wolverine\");\\n        });\\n    })\\n\\n    // Executing with Oakton as the command line parser to unlock\\n    // quite a few utilities and diagnostics in our Wolverine application\\n    .RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom HTTP Policy with WolverineHttpOptions (C#)\nDESCRIPTION: This extension method allows the application of Fluent Validation middleware to all Wolverine HTTP endpoints that have a matching Fluent Validation validator for their request type. The method 'UseFluentValidationProblemDetailMiddleware' extends the WolverineHttpOptions type, adding the HttpChainFluentValidationPolicy via the AddPolicy method. Prerequisites include references to the Fluent Validation library and the HttpChainFluentValidationPolicy class. The input is the options object; no return value is expected.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/policies.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\\n///     Apply Fluent Validation middleware to all Wolverine HTTP endpoints with a known Fluent Validation\\n///     validator for the request type\\n/// </summary>\\n/// <param name=\\\"httpOptions\\\"></param>\\npublic static void UseFluentValidationProblemDetailMiddleware(this WolverineHttpOptions httpOptions)\\n{\\n    httpOptions.AddPolicy<HttpChainFluentValidationPolicy>();\\n}\n```\n\n----------------------------------------\n\nTITLE: Posting an Approved Marten Document with Custom Route Parameter using [Document] Attribute - C#\nDESCRIPTION: This C# code example shows a Wolverine HTTP POST endpoint that approves (updates) an Invoice document. The [Document(\"number\")] attribute binds the Invoice parameter to the 'number' route argument. The endpoint modifies the document and returns a Marten operation for storage. This approach decouples the code from route parameter names and relies on MartenOps.Store for handling persistence.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverinePost(\"/invoices/{number}/approve\")]\npublic static IMartenOp Approve([Document(\"number\")] Invoice invoice)\n{\n    invoice.Approved = true;\n    return MartenOps.Store(invoice);\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Middleware Explicitly via Attribute on Handler in Wolverine (C#)\nDESCRIPTION: Demonstrates associating a middleware with a specific handler method using the [Middleware] attribute. Enables developers to target individual methods (or whole classes) for middleware execution, which can be used to add cross-cutting concerns like timing or logging. The snippet shows a handler for PotentiallySlowMessage decorated with StopwatchMiddleware; dependencies must include the named middleware type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class SomeHandler\n{\n    [Middleware(typeof(StopwatchMiddleware))]\n    public static void Handle(PotentiallySlowMessage message)\n    {\n        // do something expensive with the message\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Tenant Id and Correlation Id Configuration for Marten Sessions in ASP.NET Core (C#)\nDESCRIPTION: This snippet extends the previous configuration by adding a callback to further customize the Marten session after tenant id resolution. Besides resolving the tenant id from the query string or falling back to the default, it attaches the current request's TraceIdentifier as the session's CorrelationId. This is useful for advanced tracing or auditing scenarios where session operations should be correlated to the original HTTP request. Dependencies include WolverineFx.Http.Marten and Marten session objects, and inputs include the current HTTP context and the Marten session.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddMartenTenancyDetection(tenantId =>\n{\n    tenantId.IsQueryStringValue(\"tenant\");\n    tenantId.DefaultIs(\"default-tenant\");\n}, (c, session) =>\n{\n    session.CorrelationId = c.TraceIdentifier;\n});\n```\n\n----------------------------------------\n\nTITLE: Reading Latest Marten Aggregate in Wolverine HTTP Endpoint using C#\nDESCRIPTION: Shows a Wolverine HTTP GET endpoint defined with `[WolverineGet]`. The `GetLatest` method takes a `Guid id` route parameter and an `Order` parameter decorated with `[ReadAggregate]`. Wolverine uses this attribute to automatically load the latest state of the `Order` aggregate corresponding to the provided `id` from Marten using `FetchLatest` and inject it into the method. The method then returns the loaded aggregate. If the aggregate doesn't exist, a 404 response is returned.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverineGet(\"/orders/latest/{id}\")]\npublic static Order GetLatest(Guid id, [ReadAggregate] Order order) => order;\n```\n\n----------------------------------------\n\nTITLE: Defining Valid Message Handlers using Wolverine in C#\nDESCRIPTION: This example demonstrates various valid method signatures for message handlers in Wolverine, showing usage of the [WolverineHandler] attribute and acceptable method and parameter patterns. It shows how to handle messages using synchronous, asynchronous, and cascading message return types, as well as injection of additional services into handler methods. Dependencies include the Wolverine framework and (optionally) IDocumentSession and IEmailService interfaces. Input messages (e.g., Message1, Message3) are passed as method parameters; outputs may include void, tasks, or enumerables for cascading messages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/discovery.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverineHandler]\npublic class ValidMessageHandlers\n{\n    // There's only one argument, so we'll assume that\n    // argument is the message\n    public void Handle(Message1 something)\n    {\n    }\n\n    // The parameter named \"message\" is assumed to be the message type\n    public Task ConsumeAsync(Message1 message, IDocumentSession session)\n    {\n        return session.SaveChangesAsync();\n    }\n\n    // In this usage, we're \"cascading\" a new message of type\n    // Message2\n    public Task<Message2> HandleAsync(Message1 message, IDocumentSession session)\n    {\n        return Task.FromResult(new Message2());\n    }\n\n    // In this usage we're \"cascading\" 0 to many additional\n    // messages from the return value\n    public IEnumerable<object> Handle(Message3 message)\n    {\n        yield return new Message1();\n        yield return new Message2();\n    }\n\n    // It's perfectly valid to have multiple handler methods\n    // for a given message type. Each will be called in sequence\n    // they were discovered\n    public void Consume(Message1 input, IEmailService emails)\n    {\n    }\n\n    // You can inject additional services directly into the handler\n    // method\n    public ValueTask ConsumeAsync(Message3 weirdName, IEmailService service)\n    {\n        return ValueTask.CompletedTask;\n    }\n\n    public interface IEvent\n    {\n        string CustomerId { get; }\n        Guid Id { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing SQS Dead Letter Queue Behavior per Queue in Wolverine (C#)\nDESCRIPTION: This C# snippet demonstrates configuring dead letter queue (DLQ) behavior for individual SQS queues within a Wolverine application. It shows how to completely disable the DLQ for the \"incoming\" queue using `DisableDeadLetterQueueing()` and how to specify a custom DLQ named \"important_errors\" for the \"important\" queue using `ConfigureDeadLetterQueue()`. The example also illustrates optional configuration of the custom DLQ itself, setting its `MaxNumberOfMessages`. This configuration is done within the `UseWolverine` setup when building the application host. Dependencies include Wolverine, Wolverine.AmazonSqs, and Microsoft.Extensions.Hosting.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/deadletterqueues.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAmazonSqsTransport();\n\n        // No dead letter queueing\n        opts.ListenToSqsQueue(\"incoming\")\n            .DisableDeadLetterQueueing();\n\n        // Use a different dead letter queue\n        opts.ListenToSqsQueue(\"important\")\n            .ConfigureDeadLetterQueue(\"important_errors\", q =>\n            {\n                // optionally configure how the dead letter queue itself\n                // is built by Wolverine\n                q.MaxNumberOfMessages = 1000;\n            });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Creating CreditAccount Command Record - C#\nDESCRIPTION: Defines an immutable command message for crediting an account, implementing IAccountCommand. Takes AccountId and Amount as parameters. This enables the command to be recognized by the account lookup middleware. It is used to trigger account credit operations in the system.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/middleware.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic record CreditAccount(Guid AccountId, decimal Amount) : IAccountCommand;\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Batched Subscription with Marten and Wolverine (C#)\nDESCRIPTION: This code demonstrates registering a custom batched subscription (CompanyTransferSubscription) within a .NET host using Marten and Wolverine for event handling. It showcases RabbitMQ integration for message publishing, Marten data source configuration, async daemon setup, and subscription registration. Dependencies are Marten, Wolverine, and RabbitMQ; key inputs are the service configuration and the custom subscription, and the output is an initialized host ready for event-driven processing. The subscription depends on prior definition of CompanyTransferSubscription.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/subscriptions.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq();\n\n        // There needs to be *some* kind of subscriber for CompanyActivations\n        // for this to work at all\n        opts.PublishMessage<CompanyActivations>()\n            .ToRabbitExchange(\"activations\");\n\n        opts.Services\n            .AddMarten()\n\n            // Just pulling the connection information from\n            // the IoC container at runtime.\n            .UseNpgsqlDataSource()\n\n            .IntegrateWithWolverine()\n\n            // The Marten async daemon most be active\n            .AddAsyncDaemon(DaemonMode.HotCold)\n\n            // Register the new subscription\n            .SubscribeToEvents(new CompanyTransferSubscription());\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Resource Writer Policy with WolverineHttpOptions (C#)\nDESCRIPTION: This snippet shows how to register a custom implementation of IResourceWriterPolicy using the AddResourceWriterPolicy method on Wolverine endpoint configuration options. The method accepts a type parameter specifying the custom policy. Input is the options object; as output, the configured policy will take precedence over built-in policies for handling endpoint result types. Requires the custom policy type and an application integrating Wolverine.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/policies.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nopts.AddResourceWriterPolicy<CustomResourceWriterPolicy>();\n```\n\n----------------------------------------\n\nTITLE: Handling Order Creation with Transactional Outbox in Marten and Wolverine - C#\nDESCRIPTION: Demonstrates an explicit, asynchronous handler method that processes a CreateOrder command by storing a new Order entity in Marten and registering an OrderCreated message for deferred sending via Wolverine's outbox. Requires the Marten and Wolverine packages, and expects CreateOrder, Order, and OrderCreated types plus dependency injection for IDocumentSession and IMartenOutbox. Parameters include the incoming command, the database session, the outbox context, and a cancellation token. The method writes data and ensures that outbound messaging occurs only after the underlying transaction succeeds, reducing the risk of inconsistencies between the data and messaging subsystems.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/outbox.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task Handle(\n    CreateOrder command,\n    IDocumentSession session,\n    IMartenOutbox outbox,\n    CancellationToken cancellation)\n{\n    var order = new Order\n    {\n        Description = command.Description\n    };\n\n    // Register the new document with Marten\n    session.Store(order);\n\n    // Hold on though, this message isn't actually sent\n    // until the Marten session is committed\n    await outbox.SendAsync(new OrderCreated(order.Id));\n\n    // This makes the database commits, *then* flushed the\n    // previously registered messages to Wolverine's sending\n    // agents\n    await session.SaveChangesAsync(cancellation);\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling Cascaded Messages in Handlers with Delays and DeliveryOptions (Wolverine/.NET/C#)\nDESCRIPTION: Describes how to use cascading message returns from handler methods with customized scheduling using the DelayedFor and ScheduledAt extensions, along with custom DeliveryOptions for outgoing messages. Dependencies: Wolverine, handler conventions, helper extension methods. The method yields multiple messages with varied delivery timing and options. Inputs: an Incoming message; Outputs: multiple outgoing messages to the bus with customized scheduling. Assumes Message1–4 types and custom delivery configuration support.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic static IEnumerable<object> Consume(Incoming incoming)\n{\n    // Delay the message delivery by 10 minutes\n    yield return new Message1().DelayedFor(10.Minutes());\n\n    // Schedule the message delivery for a certain time\n    yield return new Message2().ScheduledAt(new DateTimeOffset(DateTime.Today.AddDays(2)));\n\n    // Customize the message delivery however you please...\n    yield return new Message3()\n        .WithDeliveryOptions(new DeliveryOptions().WithHeader(\"foo\", \"bar\"));\n\n    // Send back to the original sender\n    yield return Respond.ToSender(new Message4());\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure Service Bus for Wolverine Control Queues (C#)\nDESCRIPTION: This C# snippet configures Wolverine to use Azure Service Bus for system control queues. It retrieves the connection string from configuration, connects to the broker, provisions queues, and enables Wolverine's runtime control queues. This setup is necessary because RavenDb integration does not natively support control queues. Requires the 'Wolverine.AzureServiceBus' transport and corresponding NuGet packages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/ravendb.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // One way or another, you're probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\")!;\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString)\n        .AutoProvision()\n        \n        // This enables Wolverine to use temporary Azure Service Bus\n        // queues created at runtime for communication between\n        // Wolverine nodes\n        .EnableWolverineControlQueues();\n\n});\n```\n\n----------------------------------------\n\nTITLE: Querying a Marten Document with Soft Delete Handling using [Document] Attribute in Wolverine.HTTP - C#\nDESCRIPTION: This snippet illustrates a Wolverine HTTP GET endpoint that loads an Invoice document, treating soft-deleted entities as null. The [Document(Required = true, MaybeSoftDeleted = false)] attribute ensures that the endpoint will return HTTP 404 for both missing or soft-deleted documents. This is useful when endpoints must not operate on soft-deleted resources and want strict existence checks.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverineGet(\"/invoices/soft-delete/{id}\")]\npublic static Invoice GetSoftDeleted([Document(Required = true, MaybeSoftDeleted = false)] Invoice invoice)\n{\n    return invoice;\n}\n```\n\n----------------------------------------\n\nTITLE: Returning OutgoingMessages from Middleware Methods in Wolverine (C#)\nDESCRIPTION: Illustrates the use of tuple return values from middleware methods to simultaneously communicate a HandlerContinuation and schedule outgoing messages. If the validation criterion is not met, a rejection message is dispatched and the processing is stopped; otherwise, processing continues without outgoing messages. Useful for batch or conditional messaging scenarios within handlers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class MaybeBadThing2Handler\n{\n    public static (HandlerContinuation, OutgoingMessages) ValidateAsync(MaybeBadThing2 thing, IMessageBus bus)\n    {\n        if (thing.Number > 10)\n        {\n            return (HandlerContinuation.Stop, [new RejectYourThing(thing.Number)]);\n        }\n\n        return (HandlerContinuation.Continue, []);\n    }\n\n    public static void Handle(MaybeBadThing2 message)\n    {\n        Debug.WriteLine(\"Got \" + message);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Wolverine Message Type Discovery Logic in C#\nDESCRIPTION: This snippet illustrates how to extend Wolverine's message type discovery mechanism with custom criteria. It uses the `CustomizeHandlerDiscovery` extension method on `WolverineOptions` to configure the discovery process to include any types that implement a custom marker interface, `IDiagnosticsMessageHandler`, in addition to the default discovery rules.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nopts.Discovery.CustomizeHandlerDiscovery(types => types.Includes.Implements<IDiagnosticsMessageHandler>());\n```\n\n----------------------------------------\n\nTITLE: Sending a Message using IMessageContext in Wolverine C#\nDESCRIPTION: This C# method demonstrates how to send a message using Wolverine's `IMessageContext`. It creates an instance of `InvoiceCreated` and sends it using `bus.SendAsync(@event)`. The `SendAsync` method requires that Wolverine has a configured subscriber or routing rule for the `InvoiceCreated` message type; otherwise, it will throw an exception. This relies on dependency injection to provide the `IMessageContext` instance.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic ValueTask SendMessage(IMessageContext bus)\n{\n    // In this case, we're sending an \"InvoiceCreated\"\n    // message\n    var @event = new InvoiceCreated\n    {\n        Time = DateTimeOffset.Now,\n        Purchaser = \"Guy Fieri\",\n        Amount = 112.34,\n        Item = \"Cookbook\"\n    };\n\n    return bus.SendAsync(@event);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Marten Compiled Query for Invoices in C#\nDESCRIPTION: Defines a C# class `ApprovedInvoicedCompiledQuery` that implements Marten's `ICompiledListQuery<Invoice>`. The `QueryIs()` method provides the LINQ expression (`q => q.Where(x => x.Approved)`) that defines the query logic to fetch approved invoices. This compiled query can be efficiently executed by Marten.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ApprovedInvoicedCompiledQuery : ICompiledListQuery<Invoice>\n{\n    public Expression<Func<IMartenQueryable<Invoice>, IEnumerable<Invoice>>> QueryIs()\n    {\n        return q => q.Where(x => x.Approved);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Ordering on a Rabbit MQ Listener with Wolverine (C#)\nDESCRIPTION: This C# snippet shows how to enable strict global ordering for an endpoint in Wolverine using the 'ListenWithStrictOrdering' option. It configures Rabbit MQ and Wolverine's control queues, sets up persistent messaging using PostgreSQL, and configures a Rabbit MQ listener for a given queue ('ordered') with strict, single-threaded message sequencing across the application. Dependencies include Wolverine, Rabbit MQ, PostgreSQL, and the necessary Wolverine extension methods. This setup ensures messages are processed one at a time and only on a single running node, eliminating concurrency at the endpoint level.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/listeners.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder().UseWolverine(opts =>\n{\n    opts.UseRabbitMq().EnableWolverineControlQueues();\n    opts.PersistMessagesWithPostgresql(Servers.PostgresConnectionString, \"listeners\");\n\n    opts.ListenToRabbitQueue(\"ordered\")\n\n        // This option is available on all types of Wolverine\n        // endpoints that can be configured to be a listener\n        .ListenWithStrictOrdering();\n}).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Envelope Mapper for GCP Pub/Sub Endpoints in Wolverine (.NET/C#)\nDESCRIPTION: Shows how to register and apply a custom IPubsubEnvelopeMapper implementation (CustomPubsubMapper) for both listeners and senders in a Wolverine application using the configuration API. Dependencies include the Host class and the UseWolverine extension from the Wolverine framework, along with access to your GCP project ID. Key parameters involve configuring Pub/Sub endpoints for interoperability. Takes no message input directly, but affects how Wolverine serializes and deserializes messages once running. Requires .NET async/await context. The configuration must be in startup code before host is started.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/gcp-pubsub/interoperability.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UsePubsub(\"your-project-id\")\n            .UseConventionalRouting()\n            .ConfigureListeners(l => l.InteropWith(e => new CustomPubsubMapper(e)))\n            .ConfigureSenders(s => s.InteropWith(e => new CustomPubsubMapper(e)));\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Exporting Wolverine Database Schema SQL via CLI using Bash\nDESCRIPTION: Demonstrates the command `dotnet run -- db-dump export.sql` used to export the SQL Data Definition Language (DDL) script required to create the necessary database objects for Wolverine's message persistence into a specified file (e.g., `export.sql`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- db-dump export.sql\n```\n\n----------------------------------------\n\nTITLE: Configuring Buffered SQL Server Queue Listener in Wolverine (C#)\nDESCRIPTION: Configures a specific SQL Server queue listener (`ListenToSqlServerQueue`) to use buffered in-memory processing via the `BufferedInMemory()` extension method. This mode bypasses the transactional inbox/outbox for potentially higher performance but offers lower durability guarantees, as messages held in memory might be lost during unexpected shutdowns.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sqlserver.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n<!-- snippet: sample_setting_sql_server_queue_to_buffered -->\n<a id='snippet-sample_setting_sql_server_queue_to_buffered'></a>\n```cs\nopts.ListenToSqlServerQueue(\"sender\").BufferedInMemory();\n```\n<sup><a href='https://github.com/JasperFx/wolverine/blob/main/src/Persistence/SqlServerTests/Transport/compliance_tests.cs#L67-L71' title='Snippet source file'>snippet source</a> | <a href='#snippet-sample_setting_sql_server_queue_to_buffered' title='Start of snippet'>anchor</a></sup>\n<!-- endSnippet -->\n```\n\n----------------------------------------\n\nTITLE: Verifying Default Message Type Alias in Wolverine using C#\nDESCRIPTION: This xUnit test demonstrates that Wolverine, by default, identifies a message type using its full .NET type name. It creates a Wolverine `Envelope` containing a `PersonBorn` message and asserts, using Shouldly library, that the `MessageType` property of the envelope matches the `FullName` of the `PersonBorn` type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic void message_alias_is_fullname_by_default()\n{\n    new Envelope(new PersonBorn())\n        .MessageType.ShouldBe(typeof(PersonBorn).FullName);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the IAgent Interface for Background Processes in C#\nDESCRIPTION: This snippet presents the `IAgent` interface definition in Wolverine. It models a long-running background process within a distributed Wolverine application cluster. Implementations of this interface must inherit from `IHostedService`, provide a unique `Uri` for identification, and report their current `Status` (Started, Stopped, Paused) via the `AgentStatus` enum.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/runtime.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n///     Models a constantly running background process within a Wolverine\n///     node cluster\n/// </summary>\npublic interface IAgent : IHostedService\n{\n    /// <summary>\n    ///     Unique identification for this agent within the Wolverine system\n    /// </summary>\n    Uri Uri { get; }\n    \n    AgentStatus Status { get; }\n}\n\npublic enum AgentStatus\n{\n    Started,\n    Stopped,\n    Paused\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a C# Record for Message/Request Data\nDESCRIPTION: This snippet defines a simple C# record named `RenameTodo`. This record is intended to be used as a message type in a Wolverine message handler or as the request body model for a Wolverine HTTP endpoint. It contains properties for the `Id` of the Todo item to rename and the new `Name`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/persistence.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic record RenameTodo(string Id, string Name);\n```\n\n----------------------------------------\n\nTITLE: Configuring a Named Listener Endpoint in Wolverine (C#)\nDESCRIPTION: Illustrates how to configure a Wolverine host application to explicitly name a listening endpoint. This C# snippet uses the `UseWolverine` extension method and the `ListenAtPort` fluent API, followed by `Named(\"blue\")`, to create a TCP listener on port 4000 specifically named 'blue'. This named endpoint can then be targeted by sticky handlers using the `[StickyHandler(\"blue\")]` attribute.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/sticky.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // I'm explicitly configuring an incoming TCP\n        // endpoint named \"blue\"\n        opts.ListenAtPort(4000).Named(\"blue\");\n    }).StartAsync();\n\n```\n\n----------------------------------------\n\nTITLE: Applying Wolverine Extensions During Host Setup in C#\nDESCRIPTION: Illustrates how to register `IWolverineExtension` implementations with the application host. It shows using `opts.Include<SampleExtension>()` for simple extensions and `opts.Services.AddWolverineExtension<ConfigurationUsingExtension>()` for extensions requiring dependency injection, both within `UseWolverine` and directly on `IServiceCollection`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Including a single extension\n        opts.Include<SampleExtension>();\n\n        // Or add a Wolverine extension that needs\n        // to use IoC services\n        opts.Services.AddWolverineExtension<ConfigurationUsingExtension>();\n\n    })\n\n    .ConfigureServices(services =>\n    {\n        // This is the same logical usage, just showing that it\n        // can be done directly against IServiceCollection\n        services.AddWolverineExtension<ConfigurationUsingExtension>();\n    })\n\n    .StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Verifying Explicit Message Type Alias in Wolverine using C#\nDESCRIPTION: This xUnit test verifies that applying the `[MessageIdentity]` attribute correctly sets the message type alias. It creates an `Envelope` with the attributed `PersonBorn` message and asserts, using Shouldly, that the `MessageType` property matches the explicitly defined alias \"person-born\".\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic void message_alias_is_fullname_by_default()\n{\n    new Envelope(new PersonBorn())\n        .MessageType.ShouldBe(\"person-born\");\n}\n```\n\n----------------------------------------\n\nTITLE: Registering an Asynchronous Wolverine Extension (IAsyncWolverineExtension) in C#\nDESCRIPTION: Illustrates how to register an asynchronous extension (`SampleAsyncExtension`) during host setup. It uses the `AddAsyncWolverineExtension<T>()` extension method on `IServiceCollection` (accessed via `opts.Services`) within the `UseWolverine` configuration block. Dependencies like `IFeatureManager` are also registered.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Services.AddFeatureManagement();\n        opts.Services.AddSingleton(featureManager);\n\n        // Adding the async extension to the underlying IoC container\n        opts.Services.AddAsyncWolverineExtension<SampleAsyncExtension>();\n\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Sending a Message to a Specific RabbitMQ Topic (C#)\nDESCRIPTION: This snippet demonstrates how to explicitly send a message to a specific topic or topic pattern within a pre-configured RabbitMQ topic exchange using Wolverine. It uses the `BroadcastToTopicAsync()` method on the `IMessageBus`, providing the topic pattern ('color.*') and the message instance. This requires a topic exchange endpoint to be declared in the configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/topics.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nawait publisher.BroadcastToTopicAsync(\"color.*\", new Message1());\n```\n\n----------------------------------------\n\nTITLE: Tagging Tenant Id on Outgoing Messages Using IMessageBus in Wolverine .NET\nDESCRIPTION: This C# snippet illustrates how to assign a tenant ID to all outgoing messages published via an `IMessageBus` instance by setting the `TenantId` property before publishing. This ensures that all metrics and tracked operations are correlated with the correct tenancy context. It expects an initialized IMessageBus object and the identifier strings as parameters; it publishes a new message with tenant tagging for downstream metrics and trace correlation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task publish_operation(IMessageBus bus, string tenantId, string name)\n{\n    // All outgoing messages or executed messages from this\n    // IMessageBus object will be tagged with the tenant id\n    bus.TenantId = tenantId;\n    await bus.PublishAsync(new SomeMessage(name));\n}\n```\n\n----------------------------------------\n\nTITLE: Using Marten Store Operation in HTTP Endpoint (C#)\nDESCRIPTION: Demonstrates a Wolverine HTTP endpoint (`[WolverinePost]`) that modifies an `Invoice` document (retrieved via `[Document]`) and returns a Marten side effect. The `MartenOps.Store(invoice)` call creates an `IMartenOp` instance that instructs Wolverine to persist the updated `invoice` object using the active Marten session when the handler completes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/operations.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n[WolverinePost(\"/invoices/{invoiceId}/pay\")]\npublic static IMartenOp Pay([Document] Invoice invoice)\n{\n    invoice.Paid = true;\n    return MartenOps.Store(invoice);\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Stopping Message Handling with Middleware in Wolverine (C#)\nDESCRIPTION: Demonstrates a middleware class with a BeforeAsync method that attempts to load an Account entity based on the incoming message's AccountId. Utilizes Marten for persistence and decides whether to halt processing by returning a tuple containing HandlerContinuation. Requires dependencies such as IDocumentSession for persistence and ILogger for logging. Returns a tuple with continuation, loaded account, and outgoing messages, enabling the handler to receive both the entity and the continuation decision.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// This is *a* way to build middleware in Wolverine by basically just\n// writing functions/methods. There's a naming convention that\n// looks for Before/BeforeAsync or After/AfterAsync\npublic static class AccountLookupMiddleware\n{\n    // The message *has* to be first in the parameter list\n    // Before or BeforeAsync tells Wolverine this method should be called before the actual action\n    public static async Task<(HandlerContinuation, Account?, OutgoingMessages)> LoadAsync(\n        IAccountCommand command,\n        ILogger logger,\n\n        // This app is using Marten for persistence\n        IDocumentSession session,\n\n        CancellationToken cancellation)\n    {\n        var messages = new OutgoingMessages();\n        var account = await session.LoadAsync<Account>(command.AccountId, cancellation);\n        if (account == null)\n        {\n            logger.LogInformation(\"Unable to find an account for {AccountId}, aborting the requested operation\", command.AccountId);\n\n            messages.RespondToSender(new InvalidAccount(command.AccountId));\n            return (HandlerContinuation.Stop, null, messages);\n        }\n\n        // messages would be empty here\n        return (HandlerContinuation.Continue, account, messages);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the IWolverineExtension Interface in C#\nDESCRIPTION: Shows the definition of the `IWolverineExtension` interface, which provides a `Configure` method for applying custom configurations to `WolverineOptions`. This interface allows for modular configuration of Wolverine applications.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n///     Use to create loadable extensions to Wolverine applications\n/// </summary>\npublic interface IWolverineExtension\n{\n    /// <summary>\n    ///     Make any alterations to the WolverineOptions for the application\n    /// </summary>\n    /// <param name=\"options\"></param>\n    void Configure(WolverineOptions options);\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Wolverine HTTP Handler with Tenant ID Detection (C#)\nDESCRIPTION: This C# code shows the runtime-generated handler class created by Wolverine for a multi-tenant HTTP endpoint. It demonstrates the internal steps: dependency injection of necessary services (Wolverine options, runtime, Marten session factory), tenant ID detection based on the configured route argument ('tenant'), setting the tenant ID on the `MessageContext`, creating a tenant-specific Marten `IQuerySession`, executing the original endpoint logic (`TodoEndpoints.Get`), and handling the response.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic class GET_todoitems_tenant : Wolverine.Http.HttpHandler\n{\n    private readonly Wolverine.Http.WolverineHttpOptions _wolverineHttpOptions;\n    private readonly Wolverine.Runtime.IWolverineRuntime _wolverineRuntime;\n    private readonly Wolverine.Marten.Publishing.OutboxedSessionFactory _outboxedSessionFactory;\n\n    public GET_todoitems_tenant(Wolverine.Http.WolverineHttpOptions wolverineHttpOptions, Wolverine.Runtime.IWolverineRuntime wolverineRuntime, Wolverine.Marten.Publishing.OutboxedSessionFactory outboxedSessionFactory) : base(wolverineHttpOptions)\n    {\n        _wolverineHttpOptions = wolverineHttpOptions;\n        _wolverineRuntime = wolverineRuntime;\n        _outboxedSessionFactory = outboxedSessionFactory;\n    }\n\n\n\n    public override async System.Threading.Tasks.Task Handle(Microsoft.AspNetCore.Http.HttpContext httpContext)\n    {\n        var messageContext = new Wolverine.Runtime.MessageContext(_wolverineRuntime);\n\n        // Tenant Id detection\n        // 1. Tenant Id is route argument named 'tenant'\n        var tenantId = await TryDetectTenantId(httpContext);\n        messageContext.TenantId = tenantId;\n        if (string.IsNullOrEmpty(tenantId))\n        {\n            await WriteTenantIdNotFound(httpContext);\n            return;\n        }\n\n        // Building the Marten session using the detected tenant id\n        await using var querySession = _outboxedSessionFactory.QuerySession(messageContext, tenantId);\n        var tenant = (string)httpContext.GetRouteValue(\"tenant\");\n        \n        // The actual HTTP request handler execution\n        var todoIReadOnlyList_response = await MultiTenantedTodoWebService.TodoEndpoints.Get(tenant, querySession).ConfigureAwait(false);\n\n        // Writing the response body to JSON because this was the first 'return variable' in the method signature\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages via IMessageBus in Wolverine HTTP Endpoint (C#)\nDESCRIPTION: This snippet demonstrates injecting `IMessageBus` into a Wolverine HTTP endpoint method defined with `[WolverinePost]`. It then uses `bus.PublishAsync()` to asynchronously publish two different message types (`HttpMessage1`, `HttpMessage2`). This approach requires manual handling of outbox mechanics if needed, unlike Wolverine message handlers. The endpoint returns an empty response with a 204 status code.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/messaging.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// This would have an empty response and a 204 status code\n[WolverinePost(\"/spawn3\")]\npublic static async ValueTask SendViaMessageBus(IMessageBus bus)\n{\n    await bus.PublishAsync(new HttpMessage1(\"foo\"));\n    await bus.PublishAsync(new HttpMessage2(\"bar\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Message Handler Class in Wolverine (C#)\nDESCRIPTION: This snippet provides a sample static handler class that processes 'DebitAccount' messages via a static Handle method, following Wolverine's convention for message handling. The handler receives a 'DebitAccount' message and writes the debit operation details to the console for demonstration, requiring no dependencies beyond .NET's standard library and the message type definition. Input is a 'DebitAccount' instance; the output is a console log, useful for illustrating how message handlers are registered and invoked in Wolverine.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/runtime.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class DebitAccountHandler\\n{\\n    public static void Handle(DebitAccount account)\\n    {\\n        Console.WriteLine($\"I'm supposed to debit {account.Amount} from account {account.AccountId}\");\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Example Log Format with Audited Members\nDESCRIPTION: Provides an example log entry format when message execution start logging is enabled and audited members (like `AccountId`) are configured. The audited members and their values are appended to the standard log message using structural logging.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n[09:41:00 INFO] Starting to process IAccountMessage (\"018761ad-8ed2-4bc9-bde5-c3cbb643f9f3\") with AccountId: \"c446fa0b-7496-42a5-b6c8-dd53c65c96c8\"\n```\n\n----------------------------------------\n\nTITLE: Sending and Receiving Raw JSON via Kafka with Wolverine in C#\nDESCRIPTION: Shows how to configure separate Wolverine hosts for sending and receiving raw JSON messages over Kafka, facilitating interoperability with non-Wolverine systems. The receiver uses `ReceiveRawJson<T>()` on the listener configuration to specify the expected message type for deserialization. The sender uses `PublishRawJson()` on the publishing rule to send the message as plain JSON without Wolverine metadata, optionally configuring JsonSerializerOptions. Dependencies include Wolverine.Core, Wolverine.Kafka, and System.Text.Json.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/kafka.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n_receiver = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseKafka(\"localhost:9092\").AutoProvision();\n        opts.ListenToKafkaTopic(\"json\")\n            \n            // You do have to tell Wolverine what the message type\n            // is that you'll receive here so that it can deserialize the \n            // incoming data\n            .ReceiveRawJson<ColorMessage>();\n\n        opts.Services.AddResourceSetupOnStartup();\n    }).StartAsync();\n\n_sender = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseKafka(\"localhost:9092\").AutoProvision();\n        opts.Policies.DisableConventionalLocalRouting();\n\n        opts.Services.AddResourceSetupOnStartup();\n\n        opts.PublishAllMessages().ToKafkaTopic(\"json\")\n            \n            // Just publish the outgoing information as pure JSON\n            // and no other Wolverine metadata\n            .PublishRawJson(new JsonSerializerOptions());\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure Service Bus Queue Parameters with Wolverine (C#)\nDESCRIPTION: This snippet shows advanced configuration of Azure Service Bus queues using Wolverine options. It demonstrates reading the Service Bus connection string from configuration, setting up provisioning with AutoProvision(), and customizing queue behavior (e.g., AutoDeleteOnIdle, MaxDeliveryCount, LockDuration) through ConfigureQueue. Also shown is customizing message batch sizes when publishing. Dependencies are Wolverine, .NET configuration, and valid Azure Service Bus access. Inputs include specific queue and listener names and configuration delegates; outputs are queues and subscriptions with tailored parameters for reliability and performance.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/object-management.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // One way or another, you're probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\");\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString).AutoProvision()\n\n        // Alter how a queue should be provisioned by Wolverine\n        .ConfigureQueue(\"outgoing\", options => { options.AutoDeleteOnIdle = 5.Minutes(); });\n\n    // Or do the same thing when creating a listener\n    opts.ListenToAzureServiceBusQueue(\"incoming\")\n        .ConfigureQueue(options => { options.MaxDeliveryCount = 5; });\n\n    // Or as part of a subscription\n    opts.PublishAllMessages()\n        .ToAzureServiceBusQueue(\"outgoing\")\n        .ConfigureQueue(options => { options.LockDuration = 3.Seconds(); })\n\n        // You may need to change the maximum number of messages\n        // in message batches depending on the size of your messages\n        // if you hit maximum data constraints\n        .MessageBatchSize(50);\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining the TenantId Record for Wolverine Multi-Tenancy in C#\nDESCRIPTION: Presents the `TenantId` record definition, a strongly-typed identifier used within Wolverine for multi-tenancy. It encapsulates the tenant ID string (`Value`) and provides a constant for the default tenant (`DefaultTenantId`). An `IsEmpty()` method checks if the tenant ID is null, empty, or the default. This record can be injected into message handlers or HTTP endpoints.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/multi-tenancy.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n/// Strong typed identifier for the tenant id within a Wolverine message handler\n/// or HTTP endpoint that is using multi-tenancy\n/// </summary>\n/// <param name=\"Value\">The active tenant id. Note that this can be null</param>\npublic record TenantId(string Value)\n{\n    public const string DefaultTenantId = \"*DEFAULT*\";\n\n    /// <summary>\n    /// Is there a non-default tenant id?\n    /// </summary>\n    /// <returns></returns>\n    public bool IsEmpty() => Value.IsEmpty() || Value == DefaultTenantId;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Global Dead Lettering for Wolverine with GCP Pub/Sub in C#\nDESCRIPTION: This snippet shows how to configure a .NET Host to use Wolverine with GCP Pub/Sub and enable Wolverine's dead lettering feature globally for all endpoints. It utilizes the `UseWolverine` and `UsePubsub` extension methods and demonstrates optional configuration for the dead letter topic and subscription properties, such as message retention duration, within the `EnableDeadLettering` method.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/gcp-pubsub/deadlettering.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UsePubsub(\"your-project-id\")\n\n            // Enable dead lettering for all Wolverine endpoints\n            .EnableDeadLettering(\n                // Optionally configure how the GCP Pub/Sub dead letter itself\n                // is created by Wolverine\n                options =>\n                {\n                    options.Topic.MessageRetentionDuration =\n                        Duration.FromTimeSpan(TimeSpan.FromDays(14));\n\n                    options.Subscription.MessageRetentionDuration =\n                        Duration.FromTimeSpan(TimeSpan.FromDays(14));\n                }\n            );\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining the IAgentFamily Interface for Agent Management in C#\nDESCRIPTION: This snippet shows the `IAgentFamily` interface definition in Wolverine. Implementations of this interface are responsible for managing a related group ('family') of stateful background agents within a Wolverine cluster. Key responsibilities include defining the URI scheme for the family, discovering all possible agent URIs, building specific agent instances, reporting which agents are supported by the current node, and evaluating agent assignments across the cluster nodes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/runtime.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n///     Pluggable model for managing the assignment and execution of stateful, \"sticky\"\n///     background agents on the various nodes of a running Wolverine cluster\n/// </summary>\npublic interface IAgentFamily\n{\n    /// <summary>\n    ///     Uri scheme for this family of agents\n    /// </summary>\n    string Scheme { get; }\n\n    /// <summary>\n    ///     List of all the possible agents by their identity for this family of agents\n    /// </summary>\n    /// <returns></returns>\n    ValueTask<IReadOnlyList<Uri>> AllKnownAgentsAsync();\n\n    /// <summary>\n    ///     Create or resolve the agent for this family\n    /// </summary>\n    /// <param name=\"uri\"></param>\n    /// <param name=\"wolverineRuntime\"></param>\n    /// <returns></returns>\n    ValueTask<IAgent> BuildAgentAsync(Uri uri, IWolverineRuntime wolverineRuntime);\n\n    /// <summary>\n    ///     All supported agent uris by this node instance\n    /// </summary>\n    /// <returns></returns>\n    ValueTask<IReadOnlyList<Uri>> SupportedAgentsAsync();\n\n    /// <summary>\n    ///     Assign agents to the currently running nodes when new nodes are detected or existing\n    ///     nodes are deactivated\n    /// </summary>\n    /// <param name=\"assignments\"></param>\n    /// <returns></returns>\n    ValueTask EvaluateAssignmentsAsync(AssignmentGrid assignments);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Newtonsoft.Json for Wolverine HTTP Serialization (C#)\nDESCRIPTION: This snippet demonstrates opting into Newtonsoft.Json for HTTP endpoint serialization in a Wolverine app. It configures service dependencies, sets up Marten persistence with Wolverine integration, and customizes the TypeNameHandling option with a delegate. The app registers endpoints with MapWolverineEndpoints and configures JSON serialization only for Wolverine HTTP routes. Dependencies include Alba, Marten, Microsoft.Extensions.DependencyInjection, and both Newtonsoft.Json and Wolverine libraries. This approach limits Newtonsoft JSON usage to Wolverine endpoints, not affecting the rest of the app.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/json.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder([]);\nbuilder.Services.AddScoped<IUserService, UserService>();\n\nbuilder.Services.AddMarten(Servers.PostgresConnectionString)\n    .IntegrateWithWolverine();\n\nbuilder.Host.UseWolverine(opts =>\n{\n    opts.Discovery.IncludeAssembly(GetType().Assembly);\n});\n\nbuilder.Services.AddWolverineHttp();\n\nawait using var host = await AlbaHost.For(builder, app =>\n{\n    app.MapWolverineEndpoints(opts =>\n    {\n        // Opt into using Newtonsoft.Json for JSON serialization just with Wolverine.HTTP routes\n        // Configuring the JSON serialization is optional\n        opts.UseNewtonsoftJsonForSerialization(settings => settings.TypeNameHandling = TypeNameHandling.All);\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting to Amazon SQS Using Default AWS Credentials in Wolverine (C#)\nDESCRIPTION: This snippet demonstrates how to bootstrap a .NET host with Wolverine, configuring it to use the Amazon SQS transport via default AWS credentials (stored in the shared credentials file). It leverages fluent configuration options to auto-provision and, optionally, purge Amazon SQS queues on startup. Dependencies required are the WolverineFx.AmazonSqs package and valid AWS credentials present on the server. Inputs include configuration directives within the UseWolverine lambda, and the output is a running host configured for SQS messaging. Use caution with queue purging as it can slow down startup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/index.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // This does depend on the server having an AWS credentials file\n        // See https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html for more information\n        opts.UseAmazonSqsTransport()\n\n            // Let Wolverine create missing queues as necessary\n            .AutoProvision()\n\n            // Optionally purge all queues on application startup.\n            // Warning though, this is potentially slow\n            .AutoPurgeOnStartup();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Invoking Wolverine Handler and Returning Response in Minimal API (C#)\nDESCRIPTION: This C# snippet defines an ASP.NET Core Minimal API endpoint that invokes a Wolverine handler and returns the handler's result as the HTTP response body. It maps a POST request to `/items/create2`. It uses the generic overload `bus.InvokeAsync<ItemCreated>(cmd)`, specifying that it expects the handler for `CreateItemCommand` to return an `ItemCreated` object. This returned object is then automatically serialized (likely as JSON) and sent back in the HTTP response.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/mediator.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\napp.MapPost(\"/items/create2\", (CreateItemCommand cmd, IMessageBus bus) => bus.InvokeAsync<ItemCreated>(cmd));\n\n```\n\n----------------------------------------\n\nTITLE: Installing Wolverine Fluent Validation Package via .NET CLI\nDESCRIPTION: This command installs the `WolverineFx.Http.FluentValidation` NuGet package into the current .NET project. This package provides the necessary middleware for integrating Fluent Validation with Wolverine HTTP endpoints.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/fluentvalidation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package WolverineFx.Http.FluentValidation\n```\n\n----------------------------------------\n\nTITLE: Configuring Serverless Mode with Wolverine in C#\nDESCRIPTION: This snippet demonstrates how to configure Wolverine for serverless environments by disabling the transactional inbox/outbox durability features. It integrates Marten with Wolverine and optimizes for serverless by setting DurabilityMode.Serverless, which removes background processes unsuitable for short-lived serverless execution. Required dependencies include Wolverine, Marten, and EF Core; the key parameter is opts.Durability.Mode, and correct setup minimizes startup latency. The expected output is a tuned host for serverless workloads, but this configuration is not appropriate for long-running message durability scenarios.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/serverless.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Services.AddMarten(\"some connection string\")\n\n            // This adds quite a bit of middleware for\n            // Marten\n            .IntegrateWithWolverine();\n\n        // You want this maybe!\n        opts.Policies.AutoApplyTransactions();\n\n        // But wait! Optimize Wolverine for usage within Serverless\n        // and turn off the heavy duty, background processes\n        // for the transactional inbox/outbox\n        opts.Durability.Mode = DurabilityMode.Serverless;\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine-Managed Marten Subscription Distribution in C#\nDESCRIPTION: This C# code snippet demonstrates configuring Marten persistence within a .NET application's service registration using `AddMarten`. It sets up a PostgreSQL connection, defines a database schema, and registers several asynchronous projections (`TripProjection`, `DayProjection`, `DistanceProjection`). Crucially, it calls `IntegrateWithWolverine` and sets the `UseWolverineManagedEventSubscriptionDistribution` property to `true`, enabling Wolverine to distribute the execution of these asynchronous projections and any event subscriptions evenly across a running application cluster. This replaces Marten's native hot/cold distribution and requires Wolverine's durability mode to be `Balanced` and relies on its control queue mechanism for inter-node communication.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/distribution.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nopts.Services.AddMarten(m =>\n    {\n        m.DisableNpgsqlLogging = true;\n        m.Connection(Servers.PostgresConnectionString);\n        m.DatabaseSchemaName = \"csp\";\n\n        m.Projections.Add<TripProjection>(ProjectionLifecycle.Async);\n        m.Projections.Add<DayProjection>(ProjectionLifecycle.Async);\n        m.Projections.Add<DistanceProjection>(ProjectionLifecycle.Async);\n    })\n    .IntegrateWithWolverine(m =>\n    {\n        // This makes Wolverine distribute the registered projections\n        // and event subscriptions evenly across a running application\n        // cluster\n        m.UseWolverineManagedEventSubscriptionDistribution = true;\n    });\n```\n\n----------------------------------------\n\nTITLE: Defining the IResourceWriterPolicy Interface in Wolverine (C#)\nDESCRIPTION: This snippet defines the IResourceWriterPolicy interface, used to apply custom handling to the primary result (resource) of an HTTP endpoint in Wolverine. The TryApply method determines whether a given HttpChain is handled by this policy, and if so, no subsequent policies are evaluated. Prerequisites include the definition of HttpChain. The input is a single HttpChain, and the method returns a boolean indicating applicability. Only one resource writer policy applies per endpoint.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/policies.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\\n///    Use to apply custom handling to the primary result of an HTTP endpoint handler\\n/// </summary>\\npublic interface IResourceWriterPolicy\\n{\\n    /// <summary>\\n    ///  Called during bootstrapping to see whether this policy can handle the chain. If yes no further policies are tried.\\n    /// </summary>\\n    /// <param name=\\\"chain\\\"> The chain to test against</param>\\n    /// <returns>True if it applies to the chain, false otherwise</returns>\\n    bool TryApply(HttpChain chain);\\n}\n```\n\n----------------------------------------\n\nTITLE: Binding RabbitMQ Topics and Patterns to Queues in Wolverine (C#)\nDESCRIPTION: This snippet shows how to configure Wolverine to bind specific topic names (e.g., 'color.green') and topic patterns (e.g., 'color.*') from a RabbitMQ topic exchange ('wolverine.topics') to specific queues ('green', 'blue', 'all'). It uses `UseRabbitMq().AutoProvision()`, defines the exchange with `PublishAllMessages().ToRabbitTopics()`, and configures bindings using `exchange.BindTopic().ToQueue()`. It also shows a rule for publishing specific message types based on a property (`RoutedMessage`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/topics.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\ntheSender = Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq(\"host=localhost;port=5672\").AutoProvision();\n        opts.PublishAllMessages().ToRabbitTopics(\"wolverine.topics\", exchange =>\n        {\n            exchange.BindTopic(\"color.green\").ToQueue(\"green\");\n            exchange.BindTopic(\"color.blue\").ToQueue(\"blue\");\n            exchange.BindTopic(\"color.*\").ToQueue(\"all\");\n        });\n\n        opts.PublishMessagesToRabbitMqExchange<RoutedMessage>(\"wolverine.topics\", m => m.TopicName);\n    }).Start();\n```\n\n----------------------------------------\n\nTITLE: Invoking a Wolverine Handler from a Minimal API Endpoint (C#)\nDESCRIPTION: This C# snippet demonstrates how to define an ASP.NET Core Minimal API endpoint that uses Wolverine as a mediator. It maps a POST request to `/items/create`. The endpoint handler receives a `CreateItemCommand` from the request body and an injected `IMessageBus` service. It then calls `bus.InvokeAsync(cmd)` to asynchronously find and execute the appropriate Wolverine handler for the `CreateItemCommand`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/mediator.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\napp.MapPost(\"/items/create\", (CreateItemCommand cmd, IMessageBus bus) => bus.InvokeAsync(cmd));\n\n```\n\n----------------------------------------\n\nTITLE: Multi-Tenant Deletion Endpoint with Wolverine as Mediator - C#\nDESCRIPTION: This composite snippet presents both a longhand and shorthand way to implement deletion for a multi-tenanted todo resource in Wolverine HTTP. The longhand version explicitly passes a tenant id to bus.InvokeForTenantAsync; the shorthand version uses only the command and session, leveraging Wolverine's 1.7+ middleware to detect and manage the tenant context automatically. Required dependencies include IMessageBus, IDocumentSession, and command objects. Inputs are the tenant id, command, and context; outputs are either completion of the bus invocation or entity deletion.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n// While this is still valid....\n[WolverineDelete(\"/todoitems/{tenant}/longhand\")]\npublic static async Task Delete(\n    string tenant,\n    DeleteTodo command,\n    IMessageBus bus)\n{\n    // Invoke inline for the specified tenant\n    await bus.InvokeForTenantAsync(tenant, command);\n}\n\n// Wolverine.HTTP 1.7 added multi-tenancy support so\n// this short hand works without the extra jump through\n// \"Wolverine as Mediator\"\n[WolverineDelete(\"/todoitems/{tenant}\")]\npublic static void Delete(\n    DeleteTodo command, IDocumentSession session)\n{\n    // Just mark this document as deleted,\n    // and Wolverine middleware takes care of the rest\n    // including the multi-tenancy detection now\n    session.Delete<Todo>(command.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FluentValidation PipelineBehavior with MediatR - C#\nDESCRIPTION: Implements a generic MediatR IPipelineBehavior for applying all registered FluentValidation validators to requests before passing them to the next handler. Requires MediatR, FluentValidation, and registration of validator implementations in the IoC container. Accepts a generic TRequest and TResponse, throws a ValidationException if validation fails, and otherwise calls the next handler in the pipeline. All failures from validators are collected and aggregated. Intended for use in MediatR-based .NET applications as a cross-cutting validation behavior.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/from-mediatr.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n    public class ValidationBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse> where TRequest : IRequest<TResponse>\n    {\n        private readonly IEnumerable<IValidator<TRequest>> _validators;\n        public ValidationBehaviour(IEnumerable<IValidator<TRequest>> validators)\n        {\n            _validators = validators;\n        }\n        public async Task<TResponse> Handle(TRequest request, CancellationToken cancellationToken, RequestHandlerDelegate<TResponse> next)\n        {\n            if (_validators.Any())\n            {\n                var context = new ValidationContext<TRequest>(request);\n                var validationResults = await Task.WhenAll(_validators.Select(v => v.ValidateAsync(context, cancellationToken)));\n                var failures = validationResults.SelectMany(r => r.Errors).Where(f => f != null).ToList();\n                if (failures.Count != 0)\n                    throw new ValidationException(failures);\n            }\n            return await next();\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Durable Azure Service Bus Endpoints in C#\nDESCRIPTION: This snippet demonstrates how to configure Wolverine application options (`opts`) to listen to an Azure Service Bus queue ('incoming') using a durable inbox with specified buffering limits (1000 capacity, 200 threshold for back pressure). It also configures all published messages to be sent to another Azure Service Bus queue ('outgoing') using a durable outbox, ensuring message persistence until successful delivery acknowledgment.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/runtime.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n// I overrode the buffering limits just to show\n// that they exist for \"back pressure\"\nopts.ListenToAzureServiceBusQueue(\"incoming\")\n    .UseDurableInbox(new BufferingLimits(1000, 200));\n\nopts.PublishAllMessages().ToAzureServiceBusQueue(\"outgoing\")\n    .UseDurableOutbox();\n```\n\n----------------------------------------\n\nTITLE: Using Constructor Injection for Wolverine Handler Dependencies (C#)\nDESCRIPTION: Provides an example of an instance message handler (`ServiceUsingHandler`) that receives a dependency (`IDocumentSession`) through constructor injection. This dependency is resolved from the application's IoC container (like Lamar) when Wolverine creates the handler instance to process an `InvoiceCreated` message. The injected service is then utilized within the `Handle` method to perform actions like storing data.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic class ServiceUsingHandler\n{\n    private readonly IDocumentSession _session;\n\n    public ServiceUsingHandler(IDocumentSession session)\n    {\n        _session = session;\n    }\n\n    public Task Handle(InvoiceCreated created)\n    {\n        var invoice = new Invoice { Id = created.InvoiceId };\n        _session.Store(invoice);\n\n        return _session.SaveChangesAsync();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling the CreateIssue Command via Handler Class - C#\nDESCRIPTION: Implements the CreateIssueHandler class, which handles CreateIssue commands by storing the new issue in the repository and returning an IssueCreated event. Requires IssueRepository as a constructor dependency. The Handle method constructs an Issue object from the CreateIssue command's properties, persists it, and generates a cascading message for further processing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/getting-started.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nnamespace Quickstart;\n\npublic class CreateIssueHandler\n{\n    private readonly IssueRepository _repository;\n\n    public CreateIssueHandler(IssueRepository repository)\n    {\n        _repository = repository;\n    }\n\n    // The IssueCreated event message being returned will be\n    // published as a new \"cascaded\" message by Wolverine after\n    // the original message and any related middleware has\n    // succeeded\n    public IssueCreated Handle(CreateIssue command)\n    {\n        var issue = new Issue\n        {\n            Title = command.Title,\n            Description = command.Description,\n            IsOpen = true,\n            Opened = DateTimeOffset.Now,\n            OriginatorId = command.OriginatorId\n        };\n\n        _repository.Store(issue);\n\n        return new IssueCreated(issue.Id);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Message Expiration Per Message When Sending - Wolverine C#\nDESCRIPTION: This snippet demonstrates how to send messages in Wolverine with explicit expiration settings by specifying either a relative TimeSpan (using DeliverWithin) or an absolute deadline (DeliverBy) via the DeliveryOptions class. Dependencies include an IMessageBus instance for sending and types such as StatusUpdate and DeliveryOptions. Key parameters include DeliverWithin for relative expiry and DeliverBy for absolute deadlines; both determine when unsent or unprocessed messages should be discarded.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/expiration.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task message_expiration(IMessageBus bus)\\n{\\n    // Disregard the message if it isn't sent and/or processed within 3 seconds from now\\n    await bus.SendAsync(new StatusUpdate(\"Okay\"), new DeliveryOptions { DeliverWithin = 3.Seconds() });\\n\\n    // Disregard the message if it isn't sent and/or processed by 3 PM today\\n    // but watch all the potentially harmful time zone issues in your real code that I'm ignoring here!\\n    await bus.SendAsync(new StatusUpdate(\"Okay\"), new DeliveryOptions { DeliverBy = DateTime.Today.AddHours(15) });\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine to Listen for Raw JSON on MQTT Topic (C#)\nDESCRIPTION: This C# snippet configures a Wolverine application host to connect to an MQTT broker and listen on a specific topic ('app/payments/made'). It assumes incoming messages on this topic are raw JSON and specifies that they should be deserialized as the 'PaymentMade' type, enabling integration with systems that don't send Wolverine metadata.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // Connect to the MQTT broker\n    opts.UseMqtt(mqtt =>\n    {\n        var mqttServer = builder.Configuration[\"mqtt_server\"];\n\n        mqtt\n            .WithMaxPendingMessages(3)\n            .WithClientOptions(client => { client.WithTcpServer(mqttServer); });\n    });\n\n    // Listen to an MQTT topic, and this could also be a wildcard\n    // pattern\n    opts.ListenToMqttTopic(\"app/payments/made\")\n        // In the case of receiving JSON data, but\n        // not identifying metadata, tell Wolverine\n        // to assume the incoming message is this type\n        .DefaultIncomingMessage<PaymentMade>();\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Command and Event Messages in C#\nDESCRIPTION: Demonstrates defining simple messages in Wolverine using C# records. `DebitAccount` is presented as a 'command' message, intended to trigger an action, while `AccountOverdrawn` serves as an 'event' message, notifying about something that happened. Wolverine itself doesn't enforce strict handling differences based on these roles.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/basics.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// A \"command\" message\npublic record DebitAccount(long AccountId, decimal Amount);\n\n// An \"event\" message\npublic record AccountOverdrawn(long AccountId);\n```\n\n----------------------------------------\n\nTITLE: Applying Durable Outbox Policy to All Sending Endpoints in C#\nDESCRIPTION: This snippet shows how to use Wolverine policies to apply the durable outbox mechanism universally to all configured sending endpoints within the application options (`opts`). This simplifies configuration by ensuring all outgoing messages benefit from durable storage guarantees without needing individual endpoint configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/runtime.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nopts.Policies.UseDurableOutboxOnAllSendingEndpoints();\n```\n\n----------------------------------------\n\nTITLE: Sending Messages with Session (GroupId) in Azure Service Bus via Wolverine (C#)\nDESCRIPTION: This snippet demonstrates how to send messages to an Azure Service Bus queue or topic using Wolverine, explicitly specifying a session identifier via the GroupId property in the DeliveryOptions. The code requires a configured IMessageBus and relies on types such as AsbMessage3 and DeliveryOptions, available within the Wolverine ecosystem. Each send operation targets a specific session (GroupId = \"2\"), enabling FIFO order for all messages in that session.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/session-identifiers.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// bus is an IMessageBus\nawait bus.SendAsync(new AsbMessage3(\"Red\"), new DeliveryOptions { GroupId = \"2\" });\nawait bus.SendAsync(new AsbMessage3(\"Green\"), new DeliveryOptions { GroupId = \"2\" });\nawait bus.SendAsync(new AsbMessage3(\"Refactor\"), new DeliveryOptions { GroupId = \"2\" });\n```\n\n----------------------------------------\n\nTITLE: Awaiting Outgoing Event Messages in Marten and Wolverine Tests in C#\nDESCRIPTION: This extension method, SaveInMartenAndWaitForOutgoingMessagesAsync, enables test code to execute a document session action, persist changes, and wait for any outgoing Wolverine messages generated as part of event forwarding. It requires a registered OutboxedSessionFactory and relies on IHost's ExecuteAndWaitAsync for synchronization. Key parameters are the document session action and a timeout (default 5000ms). Inputs include an IHost and an action modifying an IDocumentSession; output is a tracked session. Designed for test scenarios that need deterministic completion of outbox dispatch.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-forwarding.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static Task<ITrackedSession> SaveInMartenAndWaitForOutgoingMessagesAsync(this IHost host, Action<IDocumentSession> action, int timeoutInMilliseconds = 5000)\n{\n    var factory = host.Services.GetRequiredService<OutboxedSessionFactory>();\n\n    return host.ExecuteAndWaitAsync(async context =>\n    {\n        var session = factory.OpenSession(context);\n        action(session);\n        await session.SaveChangesAsync();\n\n        // Shouldn't be necessary, but real life says do it anyway\n        await context.As<MessageContext>().FlushOutgoingMessagesAsync();\n    }, timeoutInMilliseconds);\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling OpenTelemetry Tracing Per Endpoint in Wolverine (C#)\nDESCRIPTION: This snippet demonstrates disabling OpenTelemetry tracing on a specific Wolverine endpoint by configuring the endpoint's TelemetryEnabled flag to false. The code creates and starts a Host with Wolverine integrated, publishing all messages to a designated port and explicitly turning off telemetry for actions processed by this endpoint. Dependencies include Wolverine and Microsoft.Extensions.Hosting. Inputs: host builder configuration and endpoint options. Output: Messages sent or received via this endpoint do not emit OpenTelemetry traces.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\\n    .UseWolverine(opts =>\\n    {\\n        opts\\n            .PublishAllMessages()\\n            .ToPort(2222)\\n\\n            // Disable Open Telemetry data collection on\\n            // all messages sent, received, or executed\\n            // from this endpoint\\n            .TelemetryEnabled(false);\\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Declaring the AssignIssue Command Record - C#\nDESCRIPTION: Defines a C# record 'AssignIssue' with properties for issue and assignee GUIDs. It serves as a command message or DTO for API endpoints and Wolverine handlers. The record is typically used to update issue assignments through the service's command bus, mapping inputs directly from HTTP payloads.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/getting-started.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic record AssignIssue(Guid IssueId, Guid AssigneeId);\n```\n\n----------------------------------------\n\nTITLE: Using MemoryPack Serialization Globally in Wolverine (C#)\nDESCRIPTION: Shows how to configure Wolverine to use the high-performance MemoryPack serializer application-wide by invoking UseMemoryPackSerialization() during host configuration. Requires the WolverineFx.MemoryPack NuGet package. This boosts performance for serialization at the cost of MemoryPack's specific constraints (e.g., needing attributes for types).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Make MemoryPack the default serializer throughout this application\n        opts.UseMemoryPackSerialization();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Asserting Existence of Pre-Built Types at Startup in Wolverine (.NET, C#)\nDESCRIPTION: This example shows enforcing a fail-fast check for expected pre-generated types in a production environment. By setting 'TypeLoadMode' to 'Static' and calling 'opts.Services.AssertAllExpectedPreBuiltTypesExistOnStartUp()', the application verifies all handler adaptors are compiled in-assembly. This is suitable for production, helps catch deployment errors early, and requires pre-built source code in the correct assembly. Limitations include potentially masking issues if not kept in sync with handler signatures.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/codegen.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n    {\n        if (builder.Environment.IsProduction())\n        {\n            opts.CodeGeneration.TypeLoadMode = TypeLoadMode.Static;\n\n            // You probably only ever want to do this in Production\n            opts.Services.AssertAllExpectedPreBuiltTypesExistOnStartUp();\n        }\n    });\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Scheduling Local Message Execution with Wolverine in C#\nDESCRIPTION: This snippet shows how to schedule a message (`ValidateInvoiceIsNotLate`) for execution at a future time within the local application process using `IMessageContext.ScheduleAsync()`. It demonstrates scheduling based on a relative time delay (30 days from now) and scheduling for a specific future timestamp. Note that durable scheduling requires enabling Wolverine's message persistence.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic async Task ScheduleLocally(IMessageContext bus, Guid invoiceId)\n{\n    var message = new ValidateInvoiceIsNotLate\n    {\n        InvoiceId = invoiceId\n    };\n\n    // Schedule the message to be processed in a certain amount\n    // of time\n    await bus.ScheduleAsync(message, 30.Days());\n\n    // Schedule the message to be processed at a certain time\n    await bus.ScheduleAsync(message, DateTimeOffset.Now.AddDays(30));\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Rabbit MQ Control Queues for Inter-Node Communication in Wolverine C#\nDESCRIPTION: This example enables Rabbit MQ for Wolverine system control queues across a cluster of nodes in a .NET application. By calling .EnableWolverineControlQueues(), Wolverine uses non-durable Rabbit MQ queues for inter-node coordination instead of polling via the database. The transport is configured with a URI. The dependency is the WolverineFX.RabbitMQ library and a suitable Rabbit MQ broker. No additional parameters are needed, other than URI for broker configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/index.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // *A* way to configure Rabbit MQ using their Uri schema\n        // documented here: https://www.rabbitmq.com/uri-spec.html\n        opts.UseRabbitMq(new Uri(\"amqp://localhost\"))\n\n            // Use Rabbit MQ for inter-node communication\n            .EnableWolverineControlQueues();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Listening to MQTT Topic Filters in Wolverine (C#)\nDESCRIPTION: Demonstrates configuring a Wolverine host to listen for messages matching an MQTT topic filter (`incoming/#`) using `ListenToMqttTopic()`. This allows the endpoint to receive any message published to topics starting with 'incoming/' according to MQTT wildcard rules. The example uses `UseMqttWithLocalBroker` for setting up the connection, likely in a test environment.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n_receiver = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseMqttWithLocalBroker(port);\n        opts.ListenToMqttTopic(\"incoming/#\").RetainMessages();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining a MediatR Request Handler in C#\nDESCRIPTION: This C# snippet demonstrates a standard MediatR handler implementation. It defines a `Ping` request message implementing `IRequest<Pong>` and a corresponding `PingHandler` class implementing `IRequestHandler<Ping, Pong>`. The handler utilizes constructor injection to receive dependencies (like `TextWriter`) and processes the request within the asynchronous `Handle` method, returning a `Pong` response. This exemplifies MediatR's reliance on specific framework interfaces.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/from-mediatr.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\npublic class Ping : IRequest<Pong>\n{\n    public string Message { get; set; }\n}\n\npublic class PingHandler : IRequestHandler<Ping, Pong> \n{\n    private readonly TextWriter _writer;\n\n    public PingHandler(TextWriter writer)\n    {\n        _writer = writer;\n    }\n\n    public async Task<Pong> Handle(Ping request, CancellationToken cancellationToken)\n    {\n        await _writer.WriteLineAsync($\"--- Handled Ping: {request.Message}\");\n        return new Pong { Message = request.Message + \" Pong\" };\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Wolverine Kafka Integration via .NET CLI\nDESCRIPTION: This command uses the .NET CLI to add the Wolverine.Kafka NuGet package to the current project. This package provides the necessary components to use Kafka as a messaging transport within Wolverine, utilizing the Confluent.Kafka client library internally.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/kafka.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add WolverineFx.Kafka\n```\n\n----------------------------------------\n\nTITLE: Defining a Wolverine Message Handler using Conventions in C#\nDESCRIPTION: This C# snippet illustrates the Wolverine approach to message handling, contrasting with MediatR. It uses simple record types (`Ping`, `Pong`) for messages without requiring framework interfaces. The handler is defined as a static `Handle` method within a static class, showcasing Wolverine's support for static handlers and method injection (`TextWriter` passed as an argument). Wolverine discovers handlers by convention, supports synchronous methods where appropriate, and promotes a lower-ceremony coding style.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/from-mediatr.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\n// No marker interface necessary, and records work well for this kind of little data structure\npublic record Ping(string Message);\npublic record Pong(string Message);\n\n// It is legal to implement more than message handler in the same class\npublic static class PingHandler\n{\n    public static Pong Handle(Ping command, TextWriter writer)\n    {\n        _writer.WriteLine($\"--- Handled Ping: {request.Message}\");\n        return new Pong(command.Message);\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Marker Interface for Convention-Based Auditing in C#\nDESCRIPTION: Shows the definition of a marker interface (`IAccountMessage`) with a common property (`AccountId`) and a message record (`DebitAccount`) implementing it. This pattern allows configuring audited members by convention for all types implementing the interface.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n// Marker interface\npublic interface IAccountMessage\n{\n    public int AccountId { get; }\n}\n\n// A possible command that uses our marker interface above\npublic record DebitAccount(int AccountId, decimal Amount) : IAccountMessage;\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom IMessageBatcher in Wolverine Configuration (C#)\nDESCRIPTION: This C# snippet demonstrates how to register the custom SubTaskCompletedBatcher with Wolverine during application startup using the Host builder. The opts.BatchMessagesOf<SubTaskCompleted> hook configures Wolverine to batch incoming SubTaskCompleted messages using the provided batcher implementation. Dependencies include the SubTaskCompleted message type and SubTaskCompletedBatcher class. This registration step is essential for Wolverine to recognize and utilize the custom batching strategy for the corresponding message type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/batching.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.BatchMessagesOf<SubTaskCompleted>(x =>\n        {\n            // We just have to let Wolverine know about our custom\n            // message batcher\n            x.Batcher = new SubTaskCompletedBatcher();\n        });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Installing Lamar via CLI (bash)\nDESCRIPTION: A simple bash command showing how to add the Lamar.Microsoft.DependencyInjection NuGet package to a .NET project. This prepares a project to use Lamar as the dependency injection container. Requires dotnet CLI and an initialized .NET project. Outputs package installation status.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/configuration.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package Lamar.Microsoft.DependencyInjection\n```\n\n----------------------------------------\n\nTITLE: Configuring a Buffered PostgreSQL Queue Listener in Wolverine (C#)\nDESCRIPTION: This snippet shows how to configure a Wolverine listener for a specific PostgreSQL queue named 'sender' to operate in buffered mode. By calling `.BufferedInMemory()` on the listener configuration, messages are processed without involving the transactional inbox/outbox, potentially increasing performance but sacrificing guaranteed delivery if the application terminates unexpectedly.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/postgresql.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nopts.ListenToPostgresqlQueue(\"sender\").BufferedInMemory();\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Solo Durability Mode in C#\nDESCRIPTION: This C# code snippet shows how to configure Wolverine within a .NET Host application builder. It integrates Marten persistence, optionally applies transactions automatically, and critically, sets the `DurabilityMode` to `Solo` specifically for development environments. This mode optimizes Wolverine for single-node execution, improving startup speed and recovery of persisted messages after ungraceful shutdowns common during debugging.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/leadership-and-troubleshooting.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n\nbuilder.UseWolverine(opts =>\n{\n    opts.Services.AddMarten(\"some connection string\")\n\n        // This adds quite a bit of middleware for\n        // Marten\n        .IntegrateWithWolverine();\n\n    // You want this maybe!\n    opts.Policies.AutoApplyTransactions();\n\n    if (builder.Environment.IsDevelopment())\n    {\n        // But wait! Optimize Wolverine for usage as\n        // if there would never be more than one node running\n        opts.Durability.Mode = DurabilityMode.Solo;\n    }\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing a Wolverine Extension with Dependency Injection (IConfiguration) in C#\nDESCRIPTION: Shows the `ConfigurationUsingExtension` class implementing `IWolverineExtension`. It utilizes constructor injection to receive an `IConfiguration` instance from the DI container, which can then be used within the `Configure` method to apply configuration settings to `WolverineOptions`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic class ConfigurationUsingExtension : IWolverineExtension\n{\n    private readonly IConfiguration _configuration;\n\n    // Use constructor injection from your DI container at runtime\n    public ConfigurationUsingExtension(IConfiguration configuration)\n    {\n        _configuration = configuration;\n    }\n\n    public void Configure(WolverineOptions options)\n    {\n        // Configure the wolverine application using\n        // the information from IConfiguration\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting TenantId into Wolverine Message Handlers in C#\nDESCRIPTION: Demonstrates how to inject the `TenantId` record directly into a Wolverine message handler method (`Handle`) as a parameter. Wolverine automatically resolves and provides the `TenantId` associated with the current message, allowing easy access to the tenant ID (`tenantId.Value`) without needing to inject the full `IMessageContext` or `Envelope`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/multi-tenancy.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\npublic static class SomeCommandHandler\n{\n    // Wolverine is keying off the type, the parameter name\n    // doesn't really matter\n    public static void Handle(SomeCommand command, TenantId tenantId)\n    {\n        Debug.WriteLine($\"I got a command {command} for tenant {tenantId.Value}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Supported Route Parameter Types in WolverineFx.Http (C#)\nDESCRIPTION: This C# snippet reveals a static dictionary named `TypeOutputs` within the `Wolverine.Http` library. This dictionary maps various primitive .NET types (like bool, int, double, Guid, DateTime, etc.) to their string representations, effectively listing the data types currently supported by Wolverine for automatic binding as route parameters.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/routing.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic static readonly Dictionary<Type, string> TypeOutputs = new()\n{\n    { typeof(bool), \"bool\" },\n    { typeof(byte), \"byte\" },\n    { typeof(sbyte), \"sbyte\" },\n    { typeof(char), \"char\" },\n    { typeof(decimal), \"decimal\" },\n    { typeof(float), \"float\" },\n    { typeof(short), \"short\" },\n    { typeof(int), \"int\" },\n    { typeof(double), \"double\" },\n    { typeof(long), \"long\" },\n    { typeof(ushort), \"ushort\" },\n    { typeof(uint), \"uint\" },\n    { typeof(ulong), \"ulong\" },\n    { typeof(Guid), typeof(Guid).FullName! },\n    { typeof(DateTime), typeof(DateTime).FullName! },\n    { typeof(DateTimeOffset), typeof(DateTimeOffset).FullName! },\n    { typeof(DateOnly), typeof(DateOnly).FullName! }\n};\n```\n\n----------------------------------------\n\nTITLE: Starting a Wolverine Saga and Scheduling a Timeout in C#\nDESCRIPTION: This C# code demonstrates a static `Start` method, a convention used by Wolverine to initiate a new Saga instance when a `StartOrder` message is received. The method creates a new `Order` saga state and an `OrderTimeout` message. By returning both as a tuple, Wolverine persists the new saga state and schedules the `OrderTimeout` message. It utilizes `Microsoft.Extensions.Logging.ILogger` for logging.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sagas.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\n// This method would be called when a StartOrder message arrives\n// to start a new Order\npublic static (Order, OrderTimeout) Start(StartOrder order, ILogger<Order> logger)\n{\n    logger.LogInformation(\"Got a new order with id {Id}\", order.OrderId);\n\n    // creating a timeout message for the saga\n    return (new Order{Id = order.OrderId}, new OrderTimeout(order.OrderId));\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Asynchronous Wolverine Extensions before HTTP Mapping in C#\nDESCRIPTION: Demonstrates how to explicitly call `ApplyAsyncWolverineExtensions()` on the application's service provider after building the `WebApplication` but before calling `MapWolverineEndpoints()`. This ensures that asynchronous Wolverine extensions are correctly applied to the Wolverine.HTTP configuration, resolving a potential timing issue. Requires the `WebApplication` instance (`app`) to be built.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\nvar app = builder.Build();\n\n// In order for async Wolverine extensions to apply to Wolverine.HTTP configuration,\n// you will need to explicitly call this *before* MapWolverineEndpoints()\nawait app.Services.ApplyAsyncWolverineExtensions();\n```\n\n----------------------------------------\n\nTITLE: Defining an Order Saga with State and Handlers in C#\nDESCRIPTION: This C# code defines a stateful saga named `Order` that inherits from `Wolverine.Saga`. It includes message record types (`StartOrder`, `CompleteOrder`, `OrderTimeout`) and handler methods (`Start`, `Handle`) to manage the lifecycle of an order. The static `Start` method initiates the saga state, assigns an ID, and returns the initial state along with a scheduled `OrderTimeout` message. Instance `Handle` methods process `CompleteOrder` and `OrderTimeout` messages, marking the saga as completed using `MarkCompleted()`, which signals Wolverine to delete the saga state. The `OrderTimeout` message utilizes the `TimeoutMessage` base class for easy scheduling.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sagas.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic record StartOrder(string OrderId);\n\npublic record CompleteOrder(string Id);\n\n// This message will always be scheduled to be delivered after\n// a one minute delay\npublic record OrderTimeout(string Id) : TimeoutMessage(1.Minutes());\n\npublic class Order : Saga\n{\n    public string? Id { get; set; }\n\n    // This method would be called when a StartOrder message arrives\n    // to start a new Order\n    public static (Order, OrderTimeout) Start(StartOrder order, ILogger<Order> logger)\n    {\n        logger.LogInformation(\"Got a new order with id {Id}\", order.OrderId);\n\n        // creating a timeout message for the saga\n        return (new Order{Id = order.OrderId}, new OrderTimeout(order.OrderId));\n    }\n\n    // Apply the CompleteOrder to the saga\n    public void Handle(CompleteOrder complete, ILogger<Order> logger)\n    {\n        logger.LogInformation(\"Completing order {Id}\", complete.Id);\n\n        // That's it, we're done. Delete the saga state after the message is done.\n        MarkCompleted();\n    }\n\n    // Delete this order if it has not already been deleted to enforce a \"timeout\"\n    // condition\n    public void Handle(OrderTimeout timeout, ILogger<Order> logger)\n    {\n        logger.LogInformation(\"Applying timeout to order {Id}\", timeout.Id);\n\n        // That's it, we're done. Delete the saga state after the message is done.\n        MarkCompleted();\n    }\n\n    public static void NotFound(CompleteOrder complete, ILogger<Order> logger)\n    {\n        logger.LogInformation(\"Tried to complete order {Id}, but it cannot be found\", complete.Id);\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Replaying Dead Letter Messages via Wolverine CLI\nDESCRIPTION: Executes the Wolverine application with the `storage replay` command to trigger the reprocessing of all messages currently marked as replayable in the dead letter queue storage. This is a command-line alternative for initiating replay.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/dead-letter-storage.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- storage replay\n```\n\n----------------------------------------\n\nTITLE: Constructor Injection Handler for Message Processing in Wolverine (C#)\nDESCRIPTION: This alternative snippet demonstrates a traditional approach to dependency injection for message handlers, using constructor injection to populate a private service field. The Message1Handler class receives an IService1 instance via its constructor and uses it within its HandleAsync method. This approach increases boilerplate and runtime overhead due to service instantiation with each handler instance. Prerequisites are appropriate DI container configuration to resolve IService1. The method input is a Message1 message, and it returns a Task. While supported by Wolverine, this pattern is less favored versus method injection.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/best-practices.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// This certainly works with Wolverine, but it's more code and more\n// runtime overhead\npublic class Message1Handler\n{\n    private readonly IService1 _service1;\n    \n    public Message1Handler(IService1 service1)\n    {\n        _service1 = service1;\n    }\n    \n    public Task HandleAsync(Message1 message)\n    {\n        // Do stuff\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling Cascading Message Responses in Wolverine (C#)\nDESCRIPTION: This C# snippet illustrates how to schedule cascading messages using the `Envelope` class in Wolverine. The `ScheduledResponseHandler` contains two `Consume` methods: one schedules `GoWest` with a relative delay using `ScheduleDelayed`, and the other schedules `GoEast` at a specific time using `ScheduleAt`. Returning an `Envelope` wrapping the message allows specifying delivery options like scheduling.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\npublic class ScheduledResponseHandler\n{\n    public Envelope Consume(DirectionRequest request)\n    {\n        return new Envelope(new GoWest()).ScheduleDelayed(TimeSpan.FromMinutes(5));\n    }\n\n    public Envelope Consume(MyMessage message)\n    {\n        // Process GoEast at 8 PM local time\n        return new Envelope(new GoEast()).ScheduleAt(DateTime.Today.AddHours(20));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Code Generation TypeLoadMode in Wolverine (.NET, C#)\nDESCRIPTION: This C# code snippet configures a HostBuilder to initialize a Wolverine application instance with explicit code generation loading strategy using the 'TypeLoadMode' property. The configuration sets the mode to either 'Dynamic', 'Static', or 'Auto', which impacts whether code is compiled on demand, pre-built, or a hybrid approach. Key prerequisites include referencing the Wolverine library and ensuring the relevant generated code is available if using 'Static' or 'Auto' modes. This influences startup performance and behavior during development versus production environments.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/codegen.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // The default behavior. Dynamically generate the\n        // types on the first usage\n        opts.CodeGeneration.TypeLoadMode = TypeLoadMode.Dynamic;\n\n        // Never generate types at runtime, but instead try to locate\n        // the generated types from the main application assembly\n        opts.CodeGeneration.TypeLoadMode = TypeLoadMode.Static;\n\n        // Hybrid approach that first tries to locate the types\n        // from the application assembly, but falls back to\n        // generating the code and dynamic type. Also writes the\n        // generated source code file to disk\n        opts.CodeGeneration.TypeLoadMode = TypeLoadMode.Auto;\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Adding Wolverine HTTP Package via .NET CLI\nDESCRIPTION: Installs the `WolverineFx.Http` NuGet package using the .NET command-line interface. This package is required to integrate the Dead Letters REST API into a Wolverine application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/dead-letter-storage.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package WolverineFx.Http\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Policy for Marten Transactions in C#\nDESCRIPTION: This code defines a custom Wolverine handler policy named `CommandsAreTransactional` that implements `IHandlerPolicy`. The policy applies the Marten transaction middleware (`CreateDocumentSessionFrame`) to any message handler whose message type name ends with \"Command\". This allows for conditional application of transactional behavior based on naming conventions or other criteria.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/transactional-middleware.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\npublic class CommandsAreTransactional : IHandlerPolicy\n{\n    public void Apply(IReadOnlyList<HandlerChain> chains, GenerationRules rules, IServiceContainer container)\n    {\n        // Important! Create a brand new TransactionalFrame\n        // for each chain\n        chains\n            .Where(chain => chain.MessageType.Name.EndsWith(\"Command\"))\n            .Each(chain => chain.Middleware.Add(new CreateDocumentSessionFrame(chain)));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Message Execution Start Logging in Wolverine C#\nDESCRIPTION: Shows how to configure Wolverine to automatically log a message when the execution of any message handler begins. This is done using `opts.Policies.LogMessageStarting()` within the `UseWolverine` configuration, setting the desired log level (e.g., `LogLevel.Information`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Opt into having Wolverine add a log message at the beginning\n        // of the message execution\n        opts.Policies.LogMessageStarting(LogLevel.Information);\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Validating HTTP Endpoint Input and Flow Control Using ProblemDetails in Wolverine (.NET C#)\nDESCRIPTION: Shows an HTTP endpoint using Wolverine's validation mechanism via a Validate method that returns a ProblemDetails or a continue marker. Dependencies include ASP.NET Core (ProblemDetails), Wolverine decorators (WolverinePost, EmptyResponse), and custom domain types. Validate inspects an Incident and either stops processing (returning ProblemDetails with a 400 response) or proceeds if validation passes. The main Post method handles categorical updates for an Incident; attribute usage maps command and aggregated input. The command and Incident are required inputs; output is an event/confirmation or HTTP error response. This pattern streamlines endpoint logic and surfaces validation scenarios for easy testing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/railway-programming.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic record CategoriseIncident(\n    IncidentCategory Category,\n    Guid CategorisedBy,\n    int Version\n);\n\npublic static class CategoriseIncidentEndpoint\n{\n    // This is Wolverine's form of \"Railway Programming\"\n    // Wolverine will execute this before the main endpoint,\n    // and stop all processing if the ProblemDetails is *not*\n    // \"NoProblems\"\n    public static ProblemDetails Validate(Incident incident)\n    {\n        return incident.Status == IncidentStatus.Closed \n            ? new ProblemDetails { Detail = \"Incident is already closed\" } \n            \n            // All good, keep going!\n            : WolverineContinue.NoProblems;\n    }\n    \n    // This tells Wolverine that the first \"return value\" is NOT the response\n    // body\n    [EmptyResponse]\n    [WolverinePost(\"/api/incidents/{incidentId:guid}/category\")]\n    public static IncidentCategorised Post(\n        // the actual command\n        CategoriseIncident command, \n        \n        // Wolverine is generating code to look up the Incident aggregate\n        // data for the event stream with this id\n        [Aggregate(\"incidentId\")] Incident incident)\n    {\n        // This is a simple case where we're just appending a single event to\n        // the stream.\n        return new IncidentCategorised(incident.Id, command.Category, command.CategorisedBy);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Wolverine HTTP Handler With Integrated Validation Flow - C#\nDESCRIPTION: Displays the generated code for a Wolverine HTTP handler that includes deserialization, FluentValidation execution, and conditional response based on validation. It requires registration of FluentValidation validators, WolverineHttpOptions, and FluentValidationProblemDetailSource in the IoC container. The handler reads and validates the request, executes the endpoint logic if validation passes, and writes the result to the HTTP response. This approach achieves efficiency by skipping unnecessary middleware wrappers for endpoints without validators.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/from-mediatr.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n    public class POST_validate_customer : Wolverine.Http.HttpHandler\n    {\n        private readonly Wolverine.Http.WolverineHttpOptions _wolverineHttpOptions;\n        private readonly Wolverine.Http.FluentValidation.IProblemDetailSource<WolverineWebApi.Validation.CreateCustomer> _problemDetailSource;\n        private readonly FluentValidation.IValidator<WolverineWebApi.Validation.CreateCustomer> _validator;\n\n        public POST_validate_customer(Wolverine.Http.WolverineHttpOptions wolverineHttpOptions, Wolverine.Http.FluentValidation.IProblemDetailSource<WolverineWebApi.Validation.CreateCustomer> problemDetailSource, FluentValidation.IValidator<WolverineWebApi.Validation.CreateCustomer> validator) : base(wolverineHttpOptions)\n        {\n            _wolverineHttpOptions = wolverineHttpOptions;\n            _problemDetailSource = problemDetailSource;\n            _validator = validator;\n        }\n\n\n\n        public override async System.Threading.Tasks.Task Handle(Microsoft.AspNetCore.Http.HttpContext httpContext)\n        {\n            // Reading the request body via JSON deserialization\n            var (customer, jsonContinue) = await ReadJsonAsync<WolverineWebApi.Validation.CreateCustomer>(httpContext);\n            if (jsonContinue == Wolverine.HandlerContinuation.Stop) return;\n            \n            // Execute FluentValidation validators\n            var result1 = await Wolverine.Http.FluentValidation.Internals.FluentValidationHttpExecutor.ExecuteOne<WolverineWebApi.Validation.CreateCustomer>(_validator, _problemDetailSource, customer).ConfigureAwait(false);\n\n            // Evaluate whether or not the execution should be stopped based on the IResult value\n            if (result1 != null && !(result1 is Wolverine.Http.WolverineContinue))\n            {\n                await result1.ExecuteAsync(httpContext).ConfigureAwait(false);\n                return;\n            }\n\n\n            \n            // The actual HTTP request handler execution\n            var result_of_Post = WolverineWebApi.Validation.ValidatedEndpoint.Post(customer);\n\n            await WriteString(httpContext, result_of_Post);\n        }\n\n    }\n```\n\n----------------------------------------\n\nTITLE: Forcing Response Publication with AlwaysPublishResponse in C# Message Handler\nDESCRIPTION: This example defines a C# class that handles a CreateItemCommand using Wolverine's message handling conventions. It uses the [AlwaysPublishResponse] attribute to ensure that any return value from the handler—both ItemCreated and SecondItemCreated events—are always published as messages, regardless of how the handler is invoked. The snippet depends on Wolverine's messaging abstractions, Marten's IDocumentSession, and relevant message types (ItemCreated, SecondItemCreated). The main parameters are the command and a document session, with the return value being a tuple of event objects. This approach is used for advanced message bus scenarios where explicit event publication is required.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/migration.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class CreateItemCommandHandler\n{\n    // Using this attribute will force Wolverine to also publish the ItemCreated event even if\n    // this is called by IMessageBus.InvokeAsync<ItemCreated>()\n    [AlwaysPublishResponse]\n    public async Task<(ItemCreated, SecondItemCreated)> Handle(CreateItemCommand command, IDocumentSession session)\n    {\n        var item = new Item\n        {\n            Id = Guid.NewGuid(),\n            Name = command.Name\n        };\n\n        session.Store(item);\n\n        return (new ItemCreated(item.Id, item.Name), new SecondItemCreated(item.Id, item.Name));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Available Commands with Oakton (Bash)\nDESCRIPTION: This Bash command executes the .NET application configured with Oakton, passing the `help` argument. It leverages Oakton's command-line parsing to display a list of available commands registered within the application, including built-in Oakton and Wolverine commands. Requires the .NET SDK and the compiled application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/command-line.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- help\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Pure Function PlaceOrder Handler with xUnit.Net in C#\nDESCRIPTION: Provides an xUnit unit test (`[Fact]`) for the pure function version of `PlaceOrderHandler`. It creates a `PlaceOrder` command, calls the `Handle` method, and asserts that the `Entity` property of the returned `Insert<Order>` side effect contains the correct data, demonstrating testability without mocking infrastructure dependencies like database sessions.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n    [Fact] // Using xUnit.Net\n    public void handling_place_order_creates_new_order()\n    {\n        // Look Ma, no mocks anywhere in sight!\n        var command = new PlaceOrder(\"111\", \"222\", 100.23M);\n        \n        // Execute the pure function handler\n        var action = PlaceOrderHandler.Handle(command);\n        \n        // Assert on the properties of the returned side effect's entity\n        action.Entity.Id.ShouldBe(command.OrderId); // Using Shouldly assertions\n        action.Entity.CustomerId.ShouldBe(command.CustomerId);\n        action.Entity.Amount.ShouldBe(command.Amount);\n    }\n```\n\n----------------------------------------\n\nTITLE: Applying Conventional Azure Service Bus Subscriber Configuration with Wolverine in C#\nDESCRIPTION: This snippet shows how to use Wolverine's fluent configuration API to apply default settings to all Azure Service Bus subscribers in a .NET Core application. It retrieves the service bus connection string from configuration, sets up Wolverine to connect and auto-provision the broker, and adds a durable outbox to all sender endpoints for reliable message delivery. Dependencies include the Wolverine and Azure Service Bus libraries and a properly configured connection string. Key options such as UseDurableOutbox can be globally applied but overridden for specific endpoints. This setup is ideal for scenarios involving many queues with common subscription requirements.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/publishing.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // One way or another, you're probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\");\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString).AutoProvision()\n        // Apply default configuration to all Azure Service Bus subscribers\n        // This can be overridden explicitly by any configuration for specific\n        // sending/subscribing endpoints\n        .ConfigureSenders(sender => sender.UseDurableOutbox());\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Testing End-to-End Batch Message Processing with Wolverine in C#\nDESCRIPTION: Presents a full integration test to ensure that multiple Item messages published are batched and processed as an Item[] array by Wolverine. Utilizes xUnit for the test method and Wolverine's test helpers to publish, track, and assert batch delivery. Dependencies include xUnit and the Wolverine test framework; published messages are verified to arrive as a single batch. This verifies both correct batching and item delivery, ensuring test driven confidence.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/batching.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[Fact]\npublic async Task send_end_to_end_with_batch()\n{\n    // Items to publish\n    var item1 = new Item(\"one\");\n    var item2 = new Item(\"two\");\n    var item3 = new Item(\"three\");\n    var item4 = new Item(\"four\");\n\n    Func<IMessageContext, Task> publish = async c =>\n    {\n        // I'm publishing the 4 items in sequence\n        await c.PublishAsync(item1);\n        await c.PublishAsync(item2);\n        await c.PublishAsync(item3);\n        await c.PublishAsync(item4);\n    };\n\n    // This is the \"act\" part of the test\n    var session = await theHost.TrackActivity()\n        \n        // Wolverine testing helper to \"wait\" until\n        // the tracking receives a message of Item[]\n        .WaitForMessageToBeReceivedAt<Item[]>(theHost)\n        .ExecuteAndWaitAsync(publish);\n\n    // The four Item messages should be processed as a single \n    // batch message\n    var items = session.Executed.SingleMessage<Item[]>();\n\n    items.Length.ShouldBe(4);\n    items.ShouldContain(item1);\n    items.ShouldContain(item2);\n    items.ShouldContain(item3);\n    items.ShouldContain(item4);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optimized Static Stopwatch Middleware in C#\nDESCRIPTION: This C# snippet shows an alternative, potentially micro-optimized implementation of the stopwatch middleware using a static class (`StopwatchMiddleware2`). The static `Before` method creates, starts, and returns a `Stopwatch` instance. This instance is then passed by Wolverine as an argument into the static `Finally` method, which stops the watch and logs the duration. `MethodImplOptions.AggressiveInlining` is used as a hint to the JIT compiler for potential performance gains, reducing method call overhead.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\npublic static class StopwatchMiddleware2\n{\n    // The Stopwatch being returned from this method will\n    // be passed back into the later method\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static Stopwatch Before()\n    {\n        var stopwatch = new Stopwatch();\n        stopwatch.Start();\n\n        return stopwatch;\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void Finally(Stopwatch stopwatch, ILogger logger, Envelope envelope)\n    {\n        stopwatch.Stop();\n        logger.LogDebug(\"Envelope {Id} / {MessageType} ran in {Duration} milliseconds\",\n            envelope.Id, envelope.MessageType, stopwatch.ElapsedMilliseconds);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Default RabbitMQ Dead Letter Queue Names in Wolverine (C#)\nDESCRIPTION: This C# snippet demonstrates configuring Wolverine to use custom names for RabbitMQ dead letter queues. It shows setting a different default DLQ name ('error-queue') for all listeners using `CustomizeDeadLetterQueueing`, defining a naming convention based on the listener queue name using `ConfigureListeners`, and specifying a unique DLQ ('incoming-errors') for a specific queue ('incoming') using `DeadLetterQueueing` on the listener definition. This requires the Wolverine.RabbitMQ transport.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/deadletterqueues.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Use a different default deal letter queue name\n        opts.UseRabbitMq()\n            .CustomizeDeadLetterQueueing(new DeadLetterQueue(\"error-queue\"))\n\n            // or conventionally\n            .ConfigureListeners(l => { l.DeadLetterQueueing(new DeadLetterQueue($\"{l.QueueName}-errors\")); });\n\n        // Use a different dead letter queue for this specific queue\n        opts.ListenToRabbitQueue(\"incoming\")\n            .DeadLetterQueueing(new DeadLetterQueue(\"incoming-errors\"));\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Enqueueing Message to Specific Wolverine Local Queue in C#\nDESCRIPTION: This snippet demonstrates how to explicitly send a message object (`InvoiceCreated`) to a specific named local worker queue ('highpriority') using the `EndpointFor().SendAsync()` method on an `IMessageContext` instance. This bypasses default routing rules and targets the specified queue directly.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic ValueTask EnqueueToQueue(IMessageContext bus)\n{\n    var @event = new InvoiceCreated\n    {\n        Time = DateTimeOffset.Now,\n        Purchaser = \"Guy Fieri\",\n        Amount = 112.34,\n        Item = \"Cookbook\"\n    };\n\n    // Put this message in a local worker\n    // queue named 'highpriority'\n    return bus.EndpointFor(\"highpriority\").SendAsync(@event);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Interfaces for Ancillary Marten Stores in C#\nDESCRIPTION: Defines two interfaces, IPlayerStore and IThingStore, both extending IDocumentStore for use as separate Marten document stores. These interfaces serve as explicit markers to distinguish between different logical data stores within dependency injection. There are no external dependencies beyond Marten's contract, and typical usage involves registration and injection for modular store configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/ancillary-stores.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IPlayerStore : IDocumentStore;\npublic interface IThingStore : IDocumentStore;\n```\n\n----------------------------------------\n\nTITLE: Listing Available Wolverine/Oakton CLI Commands using Bash\nDESCRIPTION: Displays the help output generated by running `dotnet run -- help` in a Wolverine application using Oakton. It lists various commands for environment checks, code generation, database management (`db-apply`, `db-assert`, `db-dump`, `db-patch`), application description, resource management (`resources`), running the application, and managing storage (`storage`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nThe available commands are:\n\n  Alias       Description\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n  check-env   Execute all environment checks against the application\n  codegen     Utilities for working with JasperFx.CodeGeneration and JasperFx.RuntimeCompiler\n  db-apply    Applies all outstanding changes to the database(s) based on the current configuration\n  db-assert   Assert that the existing database(s) matches the current configuration\n  db-dump     Dumps the entire DDL for the configured Marten database\n  db-patch    Evaluates the current configuration against the database and writes a patch and drop file if there are\n              any differences\n  describe    Writes out a description of your running application to either the console or a file\n  help        List all the available commands\n  resources   Check, setup, or teardown stateful resources of this system\n  run         Start and run this .Net application\n  storage     Administer the envelope storage\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Transactional Policy in C#\nDESCRIPTION: This snippet shows how to register the custom `CommandsAreTransactional` policy (defined elsewhere) within the Wolverine application configuration. By calling `opts.Policies.Add<CommandsAreTransactional>()` during host setup, the policy will be applied to handler chains, automatically adding Marten transactional middleware to handlers processing messages ending in \"Command\".\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/transactional-middleware.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // And actually use the policy\n        opts.Policies.Add<CommandsAreTransactional>();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Solo Mode in Program.cs (C#)\nDESCRIPTION: This snippet demonstrates how to configure Wolverine to run in \"Solo\" mode directly within the application's startup configuration (`Program.cs`). It uses the `UseWolverine` extension method and conditionally sets the `Durability.Mode` to `DurabilityMode.Solo` based on the environment (e.g., Development) to bypass leadership election and speed up cold starts. Marten integration and automatic transaction application are also shown as typical configurations.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_12\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n\nbuilder.UseWolverine(opts =>\n{\n    opts.Services.AddMarten(\"some connection string\")\n\n        // This adds quite a bit of middleware for\n        // Marten\n        .IntegrateWithWolverine();\n\n    // You want this maybe!\n    opts.Policies.AutoApplyTransactions();\n\n    if (builder.Environment.IsDevelopment())\n    {\n        // But wait! Optimize Wolverine for usage as\n        // if there would never be more than one node running\n        opts.Durability.Mode = DurabilityMode.Solo;\n    }\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Adding Wolverine HTTP Services in C#\nDESCRIPTION: This code snippet shows the required registration of Wolverine HTTP services in an ASP.NET Core application's startup process using the AddWolverineHttp() method. It starts with standard .NET Core WebApplication builder creation and ensures that Wolverine's HTTP endpoints and required services are included in the DI container. Dependencies include ASP.NET Core, Wolverine.Http, and correct integration with the .NET ServiceProvider. Leaving out this registration will cause a startup assertion error from Wolverine. The main input is the IServiceCollection, and the expected result is a fully registered HTTP infrastructure for Wolverine.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/migration.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\n\n// Necessary services for Wolverine HTTP\n// And don't worry, if you forget this, Wolverine\n// will assert this is missing on startup:(\nbuilder.Services.AddWolverineHttp();\n```\n\n----------------------------------------\n\nTITLE: Starting a Wolverine Saga via an HTTP POST Endpoint (C#)\nDESCRIPTION: This snippet demonstrates how to initiate a new Reservation saga from an HTTP POST endpoint by returning a tuple containing a response object, the saga entity, and a timeout message. The method uses the WolverinePost attribute for route binding, and Wolverine interprets the tuple to trigger persistence, handle the saga, and send cascading messages. Required dependencies are the StartReservation input type and related Reservation entities; outputs include HTTP responses and Wolverine saga persistence.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/sagas.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverinePost(\"/reservation\")]\npublic static (\n    // The first return value would be written out as the HTTP response body\n    ReservationBooked,\n\n    // Because this subclasses from Saga, Wolverine will persist this entity\n    // with saga persistence\n    Reservation,\n\n    // Other return values that trigger no special handling will be treated\n    // as cascading messages\n    ReservationTimeout) Post(StartReservation start)\n{\n    return (new ReservationBooked(start.ReservationId, DateTimeOffset.UtcNow), new Reservation { Id = start.ReservationId }, new ReservationTimeout(start.ReservationId));\n}\n```\n\n----------------------------------------\n\nTITLE: Attaching Stopwatch Middleware via a Custom ModifyChainAttribute (C#)\nDESCRIPTION: Implements StopwatchAttribute, a custom attribute deriving from ModifyChainAttribute to inject StopwatchFrame into a Wolverine IChain as middleware. This lets developers decorate handlers or endpoints with the [Stopwatch] attribute to add timing logging for specific methods or classes. Dependencies include the custom StopwatchFrame, Wolverine’s attribute system, and chain-building infrastructure. Takes the target chain and adds the custom middleware in place; intended for granular, attribute-level control over middleware application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\npublic class StopwatchAttribute : ModifyChainAttribute\n{\n    public override void Modify(IChain chain, GenerationRules rules, IServiceContainer container)\n    {\n        chain.Middleware.Add(new StopwatchFrame(chain));\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing HttpContext Trace Identifier in Wolverine Endpoint C#\nDESCRIPTION: Illustrates how a Wolverine HTTP endpoint method, marked with `[WolverineGet]`, can automatically receive the `HttpContext.TraceIdentifier` by simply declaring a string parameter named `traceIdentifier`. Wolverine's parameter binding injects the value from the current request's `HttpContext`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n[WolverineGet(\"/http/identifier\")]\npublic string UseTraceIdentifier(string traceIdentifier)\n{\n    return traceIdentifier;\n}\n```\n\n----------------------------------------\n\nTITLE: Cascading Message Topic Routing in Wolverine Handlers (C#)\nDESCRIPTION: This handler class illustrates returning a message destined for a dynamic topic based on tenant context using Wolverine. When consuming a message, a new GoNorth message is yielded, directed to a calculated topic constructed from the current tenant ID. This pattern enables pure-function handlers that leverage message cascading; dependencies are Wolverine, message contracts, and runtime envelope context. Inputs include the input message and envelope; outputs are cascaded messages sent to dynamically determined topics. The handler must be registered for message dispatch, and topics must conform to RabbitMQ's bindings.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/broadcast-to-topic.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ManuallyRoutedTopicResponseHandler\n{\n    public IEnumerable<object> Consume(MyMessage message, Envelope envelope)\n    {\n        // Go North now at the \"direction\" queue\n        yield return new GoNorth().ToTopic($\"direction/{envelope.TenantId}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using IDbContextOutbox<T> for EF Core Outbox in C#\nDESCRIPTION: This snippet shows how to use the generic `IDbContextOutbox<T>` service injected into an ASP.NET Core controller action to integrate EF Core persistence with Wolverine's transactional outbox. It demonstrates creating an entity, adding it to the `DbContext` accessed via the outbox service, publishing a message, and committing both the database changes and the message persistence atomically using `SaveChangesAndFlushMessagesAsync`. Requires `IDbContextOutbox<ItemsDbContext>` and related types (like `ItemsDbContext`, `CreateItemCommand`, `Item`, `ItemCreated`) to be registered in the dependency injection container.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/efcore.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\n[HttpPost(\"/items/create2\")]\npublic async Task Post(\n    [FromBody] CreateItemCommand command,\n    [FromServices] IDbContextOutbox<ItemsDbContext> outbox)\n{\n    // Create a new Item entity\n    var item = new Item\n    {\n        Name = command.Name\n    };\n\n    // Add the item to the current\n    // DbContext unit of work\n    outbox.DbContext.Items.Add(item);\n\n    // Publish a message to take action on the new item\n    // in a background thread\n    await outbox.PublishAsync(new ItemCreated\n    {\n        Id = item.Id\n    });\n\n    // Commit all changes and flush persisted messages\n    // to the persistent outbox\n    // in the correct order\n    await outbox.SaveChangesAndFlushMessagesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Amazon SQS Transport with Custom AWS URL in Wolverine (C#)\nDESCRIPTION: This snippet shows how to configure the Amazon SQS transport in Wolverine using custom configuration values such as ServiceURL, which can point to a given SQS endpoint. The example demonstrates setting SQS-specific settings via the UseAmazonSqsTransport delegate and reads parameters from builder.Configuration. It maintains the ability to auto-provision and purge SQS queues. Dependencies include WolverineFx.AmazonSqs and any configuration sources for AWS parameters. The host is started after building with the given configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/index.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    var config = builder.Configuration;\n\n    opts.UseAmazonSqsTransport(sqsConfig =>\n        {\n            sqsConfig.ServiceURL = config[\"AwsUrl\"];\n            // And any other elements of the SQS AmazonSQSConfig\n            // that you may need to configure\n        })\n\n        // Let Wolverine create missing queues as necessary\n        .AutoProvision()\n\n        // Optionally purge all queues on application startup.\n        // Warning though, this is potentially slow\n        .AutoPurgeOnStartup();\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Wolverine OpenTelemetry Span and Activity Constants (C#)\nDESCRIPTION: This snippet defines constants in C# for span names, activity event names, and tag names that Wolverine emits for distributed tracing via OpenTelemetry. These fields are typically placed in a static class and are referenced when emitting activities to annotate telemetry concerning message handling, listener states, retries, and correlation. No runtime dependencies are required, but consumers should reference these values when integrating with OpenTelemetry-compatible monitoring solutions. Inputs: N/A. Outputs: String constants used in tracing instrumentation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\\n/// ActivityEvent marking when an incoming envelope is discarded\\n/// </summary>\\npublic const string EnvelopeDiscarded = \\\"wolverine.envelope.discarded\\\";\\n\\n/// <summary>\\n/// ActivityEvent marking when an incoming envelope is being moved to the error queue\\n/// </summary>\\npublic const string MovedToErrorQueue = \\\"wolverine.error.queued\\\";\\n\\n/// <summary>\\n/// ActivityEvent marking when an incoming envelope does not have a known message\\n/// handler and is being shunted to registered \\\"NoHandler\\\" actions\\n/// </summary>\\npublic const string NoHandler = \\\"wolverine.no.handler\\\";\\n\\n/// <summary>\\n/// ActivityEvent marking when a message failure is configured to pause the message listener\\n/// where the message was handled. This is tied to error handling policies\\n/// </summary>\\npublic const string PausedListener = \\\"wolverine.paused.listener\\\";\\n\\n/// <summary>\\n/// Span that is emitted when a listener circuit breaker determines that there are too many\\n/// failures and listening should be paused\\n/// </summary>\\npublic const string CircuitBreakerTripped = \\\"wolverine.circuit.breaker.triggered\\\";\\n\\n/// <summary>\\n/// Span emitted when a listening agent is started or restarted\\n/// </summary>\\npublic const string StartingListener = \\\"wolverine.starting.listener\\\";\\n\\n/// <summary>\\n/// Span emitted when a listening agent is stopping\\n/// </summary>\\npublic const string StoppingListener = \\\"wolverine.stopping.listener\\\";\\n\\n/// <summary>\\n/// Span emitted when a listening agent is being paused\\n/// </summary>\\npublic const string PausingListener = \\\"wolverine.pausing.listener\\\";\\n\\n/// <summary>\\n/// ActivityEvent marking that an incoming envelope is being requeued after a message\\n/// processing failure\\n/// </summary>\\npublic const string EnvelopeRequeued = \\\"wolverine.envelope.requeued\\\";\\n\\n/// <summary>\\n/// ActivityEvent marking that an incoming envelope is being retried after a message\\n/// processing failure\\n/// </summary>\\npublic const string EnvelopeRetry = \\\"wolverine.envelope.retried\\\";\\n\\n/// <summary>\\n/// ActivityEvent marking than an incoming envelope has been rescheduled for later\\n/// execution after a failure\\n/// </summary>\\npublic const string ScheduledRetry = \\\"wolverine.envelope.rescheduled\\\";\\n\\n/// <summary>\\n/// Tag name trying to explain why a sender or listener was stopped or paused\\n/// </summary>\\npublic const string StopReason = \\\"wolverine.stop.reason\\\";\\n\\n/// <summary>\\n/// The Wolverine Uri that identifies what sending or listening endpoint the activity\\n/// refers to\\n/// </summary>\\npublic const string EndpointAddress = \\\"wolverine.endpoint.address\\\";\\n\\n/// <summary>\\n/// A stop reason when back pressure policies call for a pause in processing in a single endpoint\\n/// </summary>\\npublic const string TooBusy = \\\"TooBusy\\\";\\n\\n/// <summary>\\n/// A span emitted when a sending agent for a specific endpoint is paused\\n/// </summary>\\npublic const string SendingPaused = \\\"wolverine.sending.pausing\\\";\\n\\n/// <summary>\\n/// A span emitted when a sending agent is resuming after having been paused\\n/// </summary>\\npublic const string SendingResumed = \\\"wolverine.sending.resumed\\\";\\n\\n/// <summary>\\n/// A stop reason when sending agents are paused after too many sender failures\\n/// </summary>\\npublic const string TooManySenderFailures = \\\"TooManySenderFailures\\\";\n```\n\n----------------------------------------\n\nTITLE: Alternate Ping Handler for RabbitMQ Sample with Wolverine in C#\nDESCRIPTION: Shows another form of a PingHandler intended for a RabbitMQ-based setup, demonstrating static handler usage and method injection of IMessageContext. The handler prints to the console using AnsiConsole and constructs a PongMessage response, using Wolverine's built-in reply address for sending back the response. This code is illustrative for users migrating between transport technologies or adopting different method-injection patterns. Requires AnsiConsole, PingMessage, PongMessage classes, and IMessageContext. The handler expects PingMessage objects and returns PongMessage responses.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/ping-pong.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic static class PingHandler\n{\n    // Simple message handler for the PingMessage message type\n    public static ValueTask Handle(\n        // The first argument is assumed to be the message type\n        PingMessage message,\n\n        // Wolverine supports method injection similar to ASP.Net Core MVC\n        // In this case though, IMessageContext is scoped to the message\n        // being handled\n        IMessageContext context)\n    {\n        AnsiConsole.MarkupLine($\"[blue]Got ping #{message.Number}[/]\");\n\n        var response = new PongMessage\n        {\n            Number = message.Number\n        };\n\n        // This usage will send the response message\n        // back to the original sender. Wolverine uses message\n        // headers to embed the reply address for exactly\n        // this use case\n        return context.RespondToSenderAsync(response);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic Wolverine Storage Migration in C#\nDESCRIPTION: Demonstrates disabling the automatic database migration for Wolverine's message storage by setting `AutoBuildMessageStorageOnStartup` to `false` within the `UseWolverine` configuration lambda. This prevents Wolverine from altering the database schema upon startup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Disable automatic database migrations for message\n        // storage\n        opts.AutoBuildMessageStorageOnStartup = false;\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Cascading Outgoing Messages with GroupId in Wolverine Message Handlers (C#)\nDESCRIPTION: This C# snippet illustrates a message handler yielding multiple outgoing messages, each assigned to a specific session (group) via the GroupId or delivery options. It showcases both the concise and explicit styles for assigning GroupId, and demonstrates scheduling a message for delayed delivery in the same session. Dependencies include the definitions for Message1, Message2, Message3, Message4, and DeliveryOptions, as well as extension methods like WithGroupId and ScheduleToGroup. The input is an IncomingMessage, and the output is a set of messages routed to the 'one' session/group.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/session-identifiers.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static IEnumerable<object> Handle(IncomingMessage message)\n{\n    yield return new Message1().WithGroupId(\"one\");\n    yield return new Message2().WithGroupId(\"one\");\n\n    yield return new Message3().ScheduleToGroup(\"one\", 5.Minutes());\n\n    // Long hand\n    yield return new Message4().WithDeliveryOptions(new DeliveryOptions\n    {\n        GroupId = \"one\"\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Conventional Queue Routing with Wolverine Azure Service Bus in C#\nDESCRIPTION: This C# snippet demonstrates how to configure Wolverine to use conventional routing with Azure Service Bus queues. It retrieves the connection string, connects to Azure Service Bus, enables auto-provisioning, and sets up conventional routing. It also shows how to optionally override default queue naming for senders and listeners and how to fine-tune discovered listeners and sending endpoints based on message type or runtime context.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/conventional-routing.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // One way or another, you're probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\");\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString).AutoProvision()\n        .UseConventionalRouting(convention =>\n        {\n            // Optionally override the default queue naming scheme\n            convention.QueueNameForSender(t => t.Namespace)\n\n                // Optionally override the default queue naming scheme\n                .QueueNameForListener(t => t.Namespace)\n\n                // Fine tune the conventionally discovered listeners\n                .ConfigureListeners((listener, builder) =>\n                {\n                    var messageType = builder.MessageType;\n                    var runtime = builder.Runtime; // Access to basically everything\n\n                    // customize the new queue\n                    listener.CircuitBreaker(queue => { });\n\n                    // other options...\n                })\n\n                // Fine tune the conventionally discovered sending endpoints\n                .ConfigureSending((subscriber, builder) =>\n                {\n                    // Similarly, use the message type and/or wolverine runtime\n                    // to customize the message sending\n                });\n        });\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Conventional Pub/Sub Routing in Wolverine (C#)\nDESCRIPTION: This C# snippet demonstrates how to configure Wolverine within a .NET Host to use GCP Pub/Sub with conventional routing. It initializes Wolverine with `UseWolverine`, specifies the GCP Project ID via `UsePubsub`, and enables conventional routing using `UseConventionalRouting`. The example further shows optional customizations like overriding default topic and queue naming conventions based on message type namespace, and fine-tuning listener and sender endpoint configurations using delegates that provide access to builder and runtime context.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/gcp-pubsub/conventional-routing.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UsePubsub(\"your-project-id\")\n            .UseConventionalRouting(convention =>\n            {\n                // Optionally override the default queue naming scheme\n                convention.TopicNameForSender(t => t.Namespace)\n\n                    // Optionally override the default queue naming scheme\n                    .QueueNameForListener(t => t.Namespace)\n\n                    // Fine tune the conventionally discovered listeners\n                    .ConfigureListeners((listener, builder) =>\n                    {\n                        var messageType = builder.MessageType;\n                        var runtime = builder.Runtime; // Access to basically everything\n\n                        // customize the new queue\n                        listener.CircuitBreaker(queue => { });\n\n                        // other options...\n                    })\n\n                    // Fine tune the conventionally discovered sending endpoints\n                    .ConfigureSending((subscriber, builder) =>\n                    {\n                        // Similarly, use the message type and/or wolverine runtime\n                        // to customize the message sending\n                    });\n            });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Forwarding Legacy Messages with IForwardsTo in Wolverine (C#)\nDESCRIPTION: Implements the IForwardsTo<T> interface to forward legacy PersonBorn messages to the new PersonBornV2 message type. The Transform() method converts v1 properties into the v2 format, facilitating seamless message upgrades. Requires both PersonBorn and PersonBornV2 classes; the primary input is a v1 message and the primary output is a v2 message.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\npublic class PersonBorn : IForwardsTo<PersonBornV2>\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    public int Day { get; set; }\n    public int Month { get; set; }\n    public int Year { get; set; }\n\n    public PersonBornV2 Transform()\n    {\n        return new PersonBornV2\n        {\n            FirstName = FirstName,\n            LastName = LastName,\n            Birthday = new DateTime(Year, Month, Day)\n        };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Modular Monolith Message Handling with Wolverine in C#\nDESCRIPTION: This code snippet illustrates how to configure Wolverine in a .NET application to support modular monolith patterns with Marten as the persistence layer. The code sets Wolverine's MultipleHandlerBehavior to Separated so that each handler for a message type is executed independently, and adjusts MessageIdentity to include both id and destination to handle message fan-out scenarios. It also integrates PostgreSQL-backed transactional inbox/outbox functionality and applies transactional middleware policies automatically. Required dependencies include the Marten and Wolverine libraries, and it expects proper database connection configuration. Inputs include service and message configurations; outputs are modular message processing with independent transactions and message deduplication tuned for multi-handler uniqueness.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/modular-monolith.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n\n// It's not important that it's Marten here, just that if you have\n// *any* message persistence configured for the transactional inbox/outbox\n// support, it's impacted by the MessageIdentity setting\nbuilder.Services.AddMarten(opts =>\n    {\n        var connectionString = builder.Configuration.GetConnectionString(\"marten\");\n        opts.Connection(connectionString);\n    })\n    \n    // This line of code is adding a PostgreSQL backed transactional inbox/outbox \n    // integration using the same database as what Marten is using\n    .IntegrateWithWolverine();\n\nbuilder.UseWolverine(opts =>\n{\n    // Tell Wolverine that when you have more than one handler for the same\n    // message type, they should be executed separately and automatically\n    // \"stuck\" to separate local queues\n    opts.MultipleHandlerBehavior = MultipleHandlerBehavior.Separated;\n\n    // *If* you may be using external message brokers in such a way that they\n    // are \"fanning out\" a single message sent from an upstream system into\n    // multiple listeners within the same Wolverine process, you'll want to make\n    // this setting to tell Wolverine to treat that as completely different messages\n    // instead of failing by idempotency checks\n    opts.Durability.MessageIdentity = MessageIdentity.IdAndDestination;\n    \n    // Not 100% necessary for \"modular monoliths\", but this makes the Wolverine durable\n    // inbox/outbox feature a lot easier to use and DRYs up your message handlers\n    opts.Policies.AutoApplyTransactions();\n});\n```\n\n----------------------------------------\n\nTITLE: Replacing ServiceProvider with Lamar using IHostBuilder (C#)\nDESCRIPTION: Shows how to switch from the built-in .NET ServiceProvider to Lamar for dependency injection using IHostBuilder. Demonstrates the use of UseLamar extension to configure the host for Lamar container integration. Requires the Lamar.Microsoft.DependencyInjection NuGet package and is suitable for migration scenarios or troubleshooting integration issues. Accepts a host builder instance.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/configuration.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// With IHostBuilder\\nvar builder = Host.CreateDefaultBuilder();\\nbuilder.UseLamar();\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom RabbitMQ Routing Key Convention in C#\nDESCRIPTION: This C# class, `RouteKeyConvention`, implements `IMessageRoutingConvention` to establish a custom routing rule for RabbitMQ. It routes messages based on their full type name (converted to lowercase) as the routing key to a specified exchange. The `DiscoverSenders` method retrieves the RabbitMQ transport, finds or creates the necessary exchange and routing key within Wolverine's configuration model, and yields the corresponding endpoint.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/subscriptions.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic class RouteKeyConvention : IMessageRoutingConvention\n{\n    private readonly string _exchangeName;\n\n    public RouteKeyConvention(string exchangeName)\n    {\n        _exchangeName = exchangeName;\n    }\n\n    public void DiscoverListeners(IWolverineRuntime runtime, IReadOnlyList<Type> handledMessageTypes)\n    {\n        // Not worrying about this at all for this case\n    }\n\n    public IEnumerable<Endpoint> DiscoverSenders(Type messageType, IWolverineRuntime runtime)\n    {\n        var routingKey = messageType.FullNameInCode().ToLowerInvariant();\n        var rabbitTransport = runtime.Options.Transports.GetOrCreate<RabbitMqTransport>();\n\n        // Find or create the named Rabbit MQ exchange in Wolverine's model\n        var exchange = rabbitTransport.Exchanges[_exchangeName];\n        \n        // Find or create the named routing key / binding key\n        // in Wolverine's model\n        var routing = exchange.Routings[routingKey];\n\n        // Tell Wolverine you want the message type routed to this\n        // endpoint\n        yield return routing;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Inline Error Handling Action Sending Responses in Wolverine - C#\nDESCRIPTION: Demonstrates adding a custom inline asynchronous action to an error handling policy for a specific exception (ShippingFailedException), using the fluent API. On error, the handler discards the failed message and then executes a lambda to send a ShippingFailed message back to the sender via context.RespondToSenderAsync. This inline action is useful for returning feedback on failures. Requires Wolverine hosting setup, message types ShipOrder and ShippingFailed, and asynchronous context support.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\ntheReceiver = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.ListenAtPort(receiverPort);\n        opts.ServiceName = \"Receiver\";\n\n        opts.Policies.OnException<ShippingFailedException>()\n            .Discard().And(async (_, context, _) =>\n            {\n                if (context.Envelope?.Message is ShipOrder cmd)\n                {\n                    await context.RespondToSenderAsync(new ShippingFailed(cmd.OrderId));\n                }\n            });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Wolverine Message Event Types Enum Definition in C#\nDESCRIPTION: Defines the `MessageEventType` enum in Wolverine. This enum lists the various types of events that can occur during message processing and are captured within a `TrackedSession`, such as `Received`, `Sent`, `ExecutionStarted`, `ExecutionFinished`, `MessageSucceeded`, `MessageFailed`, etc. These values correspond to collections available on the `TrackedSession` object for assertion purposes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\npublic enum MessageEventType\n{\n    Received,\n    Sent,\n    ExecutionStarted,\n    ExecutionFinished,\n    MessageSucceeded,\n    MessageFailed,\n    NoHandlers,\n    NoRoutes,\n    MovedToErrorQueue,\n    Requeued\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message Expiry Property in Wolverine Envelope - C#\nDESCRIPTION: This snippet defines the DeliverBy property within Wolverine's Envelope class, used to specify a deadline after which a message should be discarded if not successfully delivered or processed. It ensures that the provided DateTimeOffset is stored in UTC to avoid potential time zone ambiguities. The property is nullable and can be set directly or left unset to allow indefinite delivery attempts.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/expiration.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\\n///     Instruct Wolverine to throw away this message if it is not successfully sent and processed\\n///     by the time specified\\n/// </summary>\\npublic DateTimeOffset? DeliverBy\\n{\\n    get => _deliverBy;\\n    set => _deliverBy = value?.ToUniversalTime();\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Wolverine HTTP PUT Endpoint in C#\nDESCRIPTION: This C# snippet shows a static class `UpdateTodoEndpoint` implementing a Wolverine HTTP endpoint for updating `Todo` items. It includes a `LoadAsync` method using Wolverine's handler filters concept to retrieve a `Todo` entity by ID before the main handler executes, returning `Results.NotFound()` if it doesn't exist. The `Put` method, marked with `[WolverinePut(\"/todoitems\")]`, handles the update logic, receiving the `UpdateTodo` command, the pre-loaded `Todo` entity (via `LoadAsync`), and an `IDocumentSession` (likely from Marten) to persist changes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npublic static class UpdateTodoEndpoint\n{\n    public static async Task<(Todo? todo, IResult result)> LoadAsync(UpdateTodo command, IDocumentSession session)\n    {\n        var todo = await session.LoadAsync<Todo>(command.Id);\n        return todo != null\n            ? (todo, new WolverineContinue())\n            : (todo, Results.NotFound());\n    }\n\n    [WolverinePut(\"/todoitems\")]\n    public static void Put(UpdateTodo command, Todo todo, IDocumentSession session)\n    {\n        todo.Name = todo.Name; // Note: Likely intended to use command properties\n        todo.IsComplete = todo.IsComplete; // Note: Likely intended to use command properties\n        session.Store(todo);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Sticky Handlers via Fluent Interface in Wolverine (C#)\nDESCRIPTION: Shows how to configure Wolverine endpoints and assign specific sticky handlers using the fluent interface in C#. The example sets up two TCP listeners (ports 400 and 5000) and uses the `AddStickyHandler(typeof(HandlerType))` method to associate `GreenStickyHandler` exclusively with the port 400 endpoint and `BlueStickyHandler` with the port 5000 endpoint. This approach ties handler execution directly to the receiving endpoint.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/sticky.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.ListenAtPort(400)\n            // This handler type should be executed at this listening\n            // endpoint, but other handlers for the same message type\n            // should not\n            .AddStickyHandler(typeof(GreenStickyHandler));\n        \n        opts.ListenAtPort(5000)\n            // Likewise, the same StickyMessage received at this\n            // endpoint should be handled by BlueStickHandler\n            .AddStickyHandler(typeof(BlueStickyHandler));\n\n    }).StartAsync();\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Argument-Based Tenant Detection - C#\nDESCRIPTION: This snippet shows an internal class ArgumentDetection that implements both ITenantDetection and ISynchronousTenantDetection, supporting both asynchronous and synchronous detection of tenant ids via route parameters. The constructor accepts the argument name to be extracted from HttpContext.Request.RouteValues. The ToString method provides a summary for diagnostics. Requires access to HttpContext and knowledge of route data. Input is the HttpContext; output is a nullable tenant id string.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\ninternal class ArgumentDetection : ITenantDetection, ISynchronousTenantDetection\n{\n    private readonly string _argumentName;\n\n    public ArgumentDetection(string argumentName)\n    {\n        _argumentName = argumentName;\n    }\n    \n    \n\n    public ValueTask<string?> DetectTenant(HttpContext httpContext) \n        => new(DetectTenantSynchronously(httpContext));\n\n    public override string ToString()\n    {\n        return $\"Tenant Id is route argument named '{_argumentName}'\";\n    }\n\n    public string? DetectTenantSynchronously(HttpContext context)\n    {\n        return context.Request.RouteValues.TryGetValue(_argumentName, out var value)\n            ? value?.ToString()\n            : null;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding RavenDb Persistence Dependency via dotnet CLI (bash)\nDESCRIPTION: This bash command adds the 'WolverineFx.RavenDb' NuGet package to a .NET project. It is a prerequisite for enabling RavenDb as the message and saga persistence store in Wolverine. The command should be run in the root directory of your target project.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/ravendb.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package WolverineFx.RavenDb\n```\n\n----------------------------------------\n\nTITLE: Defining Basic GET Endpoint with WolverineFx.HTTP (C#)\nDESCRIPTION: Defines a simple HTTP GET endpoint using WolverineFx.HTTP. The `HelloEndpoint` class contains a `Get` method decorated with the `[WolverineGet(\"/\")]` attribute, mapping it to the root path (`/`). The method returns a simple string \"Hello.\", which Wolverine automatically writes to the HTTP response body.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\npublic class HelloEndpoint\n{\n    [WolverineGet(\"/\")]\n    public string Get() => \"Hello.\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Scheduled Retries with Azure Service Bus in Wolverine (C#)\nDESCRIPTION: This C# example shows how to set up scheduled retries using Wolverine with Azure Service Bus by defining an exception handling policy in the application's host configuration. Dependencies include Microsoft.Extensions.Hosting, WolverineFx, and a configured Azure Service Bus endpoint. The code uses a fluent API to customize retry behavior: immediate retry on first failure, queue re-enqueue on second, scheduled retry after a specified TimeSpan (here, 15.Seconds()) on third, and moving to the error queue afterwards. It demonstrates integrating scheduled delivery into error-handling for robust and recoverable messaging patterns.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/scheduled.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Policies.OnException<TimeoutException>()\n            // Just retry the message again on the\n            // first failure\n            .RetryOnce()\n\n            // On the 2nd failure, put the message back into the\n            // incoming queue to be retried later\n            .Then.Requeue()\n\n            // On the 3rd failure, retry the message again after a configurable\n            // cool-off period. This schedules the message\n            .Then.ScheduleRetry(15.Seconds())\n\n            // On the next failure, move the message to the dead letter queue\n            .Then.MoveToErrorQueue();\n\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Batch and Item Messages in Wolverine (C#)\nDESCRIPTION: This snippet defines two message types using C# records: 'SubTaskCompleted' for individual events, and 'SubTaskCompletedBatch' for batched processing grouped by TaskId. There are no external dependencies beyond the C# language itself. These strongly-typed messages serve as the basis for custom batching and handler logic, with 'TaskId' used as the logical grouping key and 'SubTaskIdList' representing the aggregated payload.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/batching.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n// Messages at the granular level that might be streaming in\n// very quickly\npublic record SubTaskCompleted(string TaskId, string SubTaskId);\n\n// A custom message type for processing a batch of sub task\n// completed messages. Note that it's batched by the TaskId\npublic record SubTaskCompletedBatch(string TaskId, string[] SubTaskIdList);\n```\n\n----------------------------------------\n\nTITLE: Enforcing Authorization on All Wolverine HTTP Endpoints (C#)\nDESCRIPTION: This C# snippet demonstrates how to configure Wolverine within an ASP.NET Core application to require authorization for all HTTP endpoints by default. It uses the `MapWolverineEndpoints` extension method and an options lambda to call `RequireAuthorizeOnAll()`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/security.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\napp.MapWolverineEndpoints(opts =>\n{\n    opts.RequireAuthorizeOnAll();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine to Receive Raw JSON from SQS in C#\nDESCRIPTION: This snippet demonstrates how to configure a Wolverine application to listen to an AWS SQS queue named 'incoming' and process messages as raw JSON. It specifies that only messages of type 'Message1' are expected on this queue and optionally customizes the System.Text.Json serialization settings, such as setting the property naming policy to camelCase. This is useful when integrating with systems that send plain JSON payloads without Wolverine-specific metadata.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/interoperability.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAmazonSqsTransport();\n\n        opts.ListenToSqsQueue(\"incoming\").ReceiveRawJsonMessage(\n            // Specify the single message type for this queue\n            typeof(Message1),\n\n            // Optionally customize System.Text.Json configuration\n            o => { o.PropertyNamingPolicy = JsonNamingPolicy.CamelCase; });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages Directly to a RabbitMQ Queue using Wolverine in C#\nDESCRIPTION: This snippet demonstrates configuring Wolverine within a .NET Host to publish all messages directly to a specific RabbitMQ queue named \"outgoing\". It initializes the host, configures Wolverine to use RabbitMQ, and specifies the target queue using `PublishAllMessages().ToRabbitQueue(\"outgoing\")`. It also shows an example of fine-tuning queue properties like `IsExclusive` for another queue \"special\" if Wolverine manages its creation. This setup uses a durable outbox for reliability.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/publishing.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Connect to an unsecured, local Rabbit MQ broker\n        // at port 5672\n        opts.UseRabbitMq();\n\n        opts.PublishAllMessages().ToRabbitQueue(\"outgoing\")\n            .UseDurableOutbox();\n\n        // fine-tune the queue characteristics if Wolverine\n        // will be governing the queue setup\n        opts.PublishAllMessages().ToRabbitQueue(\"special\", queue => { queue.IsExclusive = true; });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Handling Ping Messages and Responding in Ponger with Wolverine in C#\nDESCRIPTION: Implements a message handler for the Ponger application, which receives Ping messages, logs receipt, and responds to the sender with a Pong message containing the same Number. The handler uses method injection to access the logger and Wolverine's IMessageContext for responding to the original sender. Dependencies include the Messages library, logging, and Wolverine. Expects incoming Ping messages and outputs corresponding Pong responses and log statements.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/ping-pong.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nusing Messages;\nusing Microsoft.Extensions.Logging;\nusing Wolverine;\n\nnamespace Ponger;\n\npublic class PingHandler\n{\n    public ValueTask Handle(Ping ping, ILogger<PingHandler> logger, IMessageContext context)\n    {\n        logger.LogInformation(\"Got Ping #{Number}\", ping.Number);\n        return context.RespondToSenderAsync(new Pong { Number = ping.Number });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Tenant RabbitMQ Transports with Wolverine in C#\nDESCRIPTION: This snippet demonstrates the setup and configuration of multi-tenancy support in Wolverine for RabbitMQ transports within a .NET application. It includes defining tenant identification behavior, registering multiple tenants either on the same broker via virtual hosts or on different brokers, and configuring per-tenant and global queue listeners as well as message publishing. Dependencies include the Host, Configuration, and Wolverine integration packages. Key parameters involve connection strings, tenant names/IDs, and queue names, and the expected result is a Wolverine application able to route and listen to messages across separate tenants with customizable fallback and error strategies.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/multi-tenancy.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n\nbuilder.UseWolverine(opts =>\n{\n    // At this point, you still have to have a *default* broker connection to be used for \n    // messaging. \n    opts.UseRabbitMq(new Uri(builder.Configuration.GetConnectionString(\"main\")))\n        \n        // This will be respected across *all* the tenant specific\n        // virtual hosts and separate broker connections\n        .AutoProvision()\n\n        // This is the default, if there is no tenant id on an outgoing message,\n        // use the default broker\n        .TenantIdBehavior(TenantedIdBehavior.FallbackToDefault)\n\n        // Or tell Wolverine instead to just quietly ignore messages sent\n        // to unrecognized tenant ids\n        .TenantIdBehavior(TenantedIdBehavior.IgnoreUnknownTenants)\n\n        // Or be draconian and make Wolverine assert and throw an exception\n        // if an outgoing message does not have a tenant id\n        .TenantIdBehavior(TenantedIdBehavior.TenantIdRequired)\n\n        // Add specific tenants for separate virtual host names\n        // on the same broker as the default connection\n        .AddTenant(\"one\", \"vh1\")\n        .AddTenant(\"two\", \"vh2\")\n        .AddTenant(\"three\", \"vh3\")\n\n        // Or, you can add a broker connection to something completel\n        // different for a tenant\n        .AddTenant(\"four\", new Uri(builder.Configuration.GetConnectionString(\"rabbit_four\")));\n\n    // This Wolverine application would be listening to a queue\n    // named \"incoming\" on all virtual hosts and/or tenant specific message\n    // brokers\n    opts.ListenToRabbitQueue(\"incoming\");\n\n    opts.ListenToRabbitQueue(\"incoming_global\")\n        \n        // This opts this queue out from being per-tenant, such that\n        // there will only be the single \"incoming_global\" queue for the default\n        // broker connection\n        .GlobalListener();\n\n    // More on this in the docs....\n    opts.PublishMessage<Message1>()\n        .ToRabbitQueue(\"outgoing\").GlobalSender();\n});\n```\n\n----------------------------------------\n\nTITLE: Default Newtonsoft.Json Serializer Settings in Wolverine (C#)\nDESCRIPTION: Shows the default JsonSerializerSettings used by Wolverine when Newtonsoft.Json is enabled for serialization. The settings object specifies automatic type name handling and object reference preservation. Requires the Newtonsoft.Json NuGet package and is typically used internally when configuring the serializer.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nreturn new JsonSerializerSettings\n{\n    TypeNameHandling = TypeNameHandling.Auto,\n    PreserveReferencesHandling = PreserveReferencesHandling.Objects\n};\n```\n\n----------------------------------------\n\nTITLE: Applying a Custom SQS Envelope Mapper in Wolverine Configuration (C#)\nDESCRIPTION: This snippet demonstrates how to apply a custom `ISqsEnvelopeMapper` implementation (`CustomSqsMapper`) to Wolverine's AWS SQS transport configuration. It uses the `ConfigureListeners` and `ConfigureSenders` methods along with `InteropWith()` to specify the custom mapper for both incoming and outgoing SQS messages. This enables advanced interoperability scenarios where default message mapping is insufficient.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/interoperability.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAmazonSqsTransport()\n            .UseConventionalRouting()\n            .ConfigureListeners(l => l.InteropWith(new CustomSqsMapper()))\n            .ConfigureSenders(s => s.InteropWith(new CustomSqsMapper()));\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Timeout Message in Wolverine Sagas (C#)\nDESCRIPTION: This C# snippet defines a record `OrderTimeout` that inherits from Wolverine's `TimeoutMessage`. It specifies a fixed delay (1 minute in this case) for the message delivery. This pattern simplifies scheduling timeout messages within Sagas. The record takes an `Id` parameter, likely the Saga identifier. It depends on `Wolverine.TimeoutMessage` and `System.TimeSpan` (implicitly via `.Minutes()`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sagas.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n// This message will always be scheduled to be delivered after\n// a one minute delay\npublic record OrderTimeout(string Id) : TimeoutMessage(1.Minutes());\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom MQTT Envelope Mapper in Wolverine (C#)\nDESCRIPTION: This C# snippet defines a custom class 'MyMqttEnvelopeMapper' that implements Wolverine's 'IMqttEnvelopeMapper' interface. This mapper provides custom logic to map between Wolverine's internal 'Envelope' structure and MQTT's 'MqttApplicationMessage' for both outgoing and incoming messages. It demonstrates setting mandatory fields like payload and message type, and optional ones like content type and delivery constraints.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_9\n\nLANGUAGE: cs\nCODE:\n```\npublic class MyMqttEnvelopeMapper : IMqttEnvelopeMapper\n{\n    public void MapEnvelopeToOutgoing(Envelope envelope, MqttApplicationMessage outgoing)\n    {\n        // This is the only absolutely mandatory item\n        outgoing.PayloadSegment = envelope.Data;\n\n        // Maybe enrich this more?\n        outgoing.ContentType = envelope.ContentType;\n    }\n\n    public void MapIncomingToEnvelope(Envelope envelope, MqttApplicationMessage incoming)\n    {\n        // These are the absolute minimums necessary for Wolverine to function\n        envelope.MessageType = typeof(PaymentMade).ToMessageTypeName();\n        envelope.Data = incoming.PayloadSegment.Array;\n\n        // Optional items\n        envelope.DeliverWithin = 5.Seconds(); // throw away the message if it\n        // is not successfully processed\n        // within 5 seconds\n    }\n\n    public IEnumerable<string> AllHeaders()\n    {\n        yield break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Messages to Named Endpoints in Wolverine (C#)\nDESCRIPTION: This snippet demonstrates how to configure multiple named TCP endpoints in Wolverine and then send messages to a specific endpoint by its name ('One') using the IMessageBus. It shows sending a message fire-and-forget style with SendAsync, invoking a remote handler with InvokeAsync, and performing a request/reply pattern with InvokeAsync<T>.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/endpoint-operations.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.PublishAllMessages().ToPort(5555)\n            .Named(\"One\");\n\n        opts.PublishAllMessages().ToPort(5555)\n            .Named(\"Two\");\n    }).StartAsync();\n\nvar bus = host.Services\n    .GetRequiredService<IMessageBus>();\n\n// Explicitly send a message to a named endpoint\nawait bus.EndpointFor(\"One\").SendAsync(new SomeMessage());\n\n// Or invoke remotely\nawait bus.EndpointFor(\"One\").InvokeAsync(new SomeMessage());\n\n// Or request/reply\nvar answer = bus.EndpointFor(\"One\")\n    .InvokeAsync<Answer>(new Question());\n```\n\n----------------------------------------\n\nTITLE: Installing Wolverine Pulsar Transport using .NET CLI\nDESCRIPTION: Shows the .NET CLI command to add the `WolverineFx.Pulsar` NuGet package to a project. This package provides the necessary integration for using Apache Pulsar as a message transport with the Wolverine framework.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/pulsar.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add WolverineFx.Pulsar\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine with EF Core and SQL Server in Minimal API (C#)\nDESCRIPTION: This C# snippet shows how to configure Wolverine within an ASP.NET Core Minimal API application's `Program.cs`. It sets up Wolverine to use SQL Server for message persistence via a connection string and enables EF Core transactional middleware using `UseEntityFrameworkCoreTransactions()`. It also registers an EF Core `DbContext` (`ItemsDbContext`) with a Singleton lifetime for its options, which is important for Wolverine's optimization, and adds a hosted service (`DatabaseSchemaCreator`) likely for ensuring the database schema exists.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/mediator.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\n// Using Weasel to make sure the items table exists\nbuilder.Services.AddHostedService<DatabaseSchemaCreator>();\n\nvar connectionString = builder.Configuration.GetConnectionString(\"SqlServer\");\n\nbuilder.Host.UseWolverine(opts =>\n{\n    opts.PersistMessagesWithSqlServer(connectionString);\n\n    // If you're also using EF Core, you may want this as well\n    opts.UseEntityFrameworkCoreTransactions();\n});\n\n// Register the EF Core DbContext\nbuilder.Services.AddDbContext<ItemsDbContext>(\n    x => x.UseSqlServer(connectionString),\n\n    // This is weirdly important! Using Singleton scoping\n    // of the options allows Wolverine to significantly\n    // optimize the runtime pipeline of the handlers that\n    // use this DbContext type\n    optionsLifetime: ServiceLifetime.Singleton);\n\n```\n\n----------------------------------------\n\nTITLE: Disabling Rabbit MQ System Request/Reply Queues in Wolverine C#\nDESCRIPTION: This snippet demonstrates how to disable Wolverine's automatic creation of system reply queues in Rabbit MQ, which is useful when broker permissions are insufficient. The .DisableSystemRequestReplyQueueDeclaration() option prevents issues during deployment or local testing in restricted environments, but also disables request/reply support through Rabbit MQ in Wolverine. The configuration uses a URI schema, and sets queue options for 'incoming2'. Requires WolverineFX.RabbitMQ and a Rabbit MQ broker accessible via URI.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/index.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // *A* way to configure Rabbit MQ using their Uri schema\n        // documented here: https://www.rabbitmq.com/uri-spec.html\n        opts.UseRabbitMq(new Uri(\"amqp://localhost\"))\n\n            // Stop Wolverine from trying to create a reply queue\n            // for this node if your process does not have permission to\n            // do so against your Rabbit MQ broker\n            .DisableSystemRequestReplyQueueDeclaration();\n\n        // Set up a listener for a queue, but also\n        // fine-tune the queue characteristics if Wolverine\n        // will be governing the queue setup\n        opts.ListenToRabbitQueue(\"incoming2\", q =>\n        {\n            q.PurgeOnStartup = true;\n            q.TimeToLive(5.Minutes());\n        });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages to MQTT Using Custom Topic Rules (C#)\nDESCRIPTION: Configures Wolverine to publish messages implementing a specific interface (`ITenantMessage`) to MQTT topics derived dynamically using a user-provided lambda function. The function (`m => $\"{m.GetType().Name.ToLower()}/{m.TenantId}\"`) determines the topic name based on the message type name and its `TenantId`. The example also shows configuring QoS and buffering for these messages using `.QualityOfService()` and `.BufferedInMemory()`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n\nbuilder.UseWolverine(opts =>\n{\n    // Connect to the MQTT broker\n    opts.UseMqtt(mqtt =>\n    {\n        var mqttServer = builder.Configuration[\"mqtt_server\"];\n\n        mqtt\n            .WithMaxPendingMessages(3)\n            .WithClientOptions(client => { client.WithTcpServer(mqttServer); });\n    });\n\n    // Publish any message that implements ITenantMessage to\n    // MQTT with a topic derived from the message\n    opts.PublishMessagesToMqttTopic<ITenantMessage>(m => $\"{m.GetType().Name.ToLower()}/{m.TenantId}\")\n\n        // Specify or configure sending through Wolverine for all\n        // MQTT topic broadcasting\n        .QualityOfService(MqttQualityOfServiceLevel.ExactlyOnce)\n        .BufferedInMemory();\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenAPI Metadata Programmatically with HttpChain Model - C#\nDESCRIPTION: This sample shows how to customize or override OpenAPI endpoint metadata programmatically using the HttpChain model in Wolverine. The example adds a new response type (202 Accepted) and removes a default status code (200) post-metadata application for an HTTP chain. Useful for endpoints that simply forward requests or require advanced customization. Dependencies include Wolverine's HttpChain model, and the sample assumes it runs as part of endpoint configuration initialization.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/metadata.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void Configure(HttpChain chain)\n{\n    // This sample is from Wolverine itself on endpoints where all you do is forward\n    // a request directly to a Wolverine messaging endpoint for later processing\n    chain.Metadata.Add(builder =>\n    {\n        // Adding metadata\n        builder.Metadata.Add(new WolverineProducesResponseTypeMetadata { StatusCode = 202, Type = null });\n    });\n    // This is run after all other metadata has been applied, even after the wolverine built-in metadata\n    // So use this if you want to change or remove some metadata\n    chain.Metadata.Finally(builder =>\n    {\n        builder.RemoveStatusCodeResponse(200);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamically Managing RabbitMQ Objects at Runtime with Wolverine in C#\nDESCRIPTION: Shows how to interact with the RabbitMQ topology at runtime using Wolverine. It retrieves the `IWolverineRuntime` service and uses the `ModifyRabbitMqObjects` extension method to dynamically declare queues, exchanges, and bindings. It also demonstrates how to unbind a queue from an exchange using `UnBindRabbitMqQueue`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/object-management.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n// _host is an IHost\nvar runtime = _host.Services.GetRequiredService<IWolverineRuntime>();\n\n// Declare new Exchanges, Queues, and Bindings at runtime\nruntime.ModifyRabbitMqObjects(o =>\n{\n    var queue = o.DeclareQueue(queueName);\n    var exchange = o.DeclareExchange(exchangeName);\n    queue.BindExchange(exchange.ExchangeName, bindingKey);\n});\n\n// Unbind a queue from an exchange\nruntime.UnBindRabbitMqQueue(queueName, exchangeName, bindingKey);\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Wolverine with RabbitMQ, Marten, and Oakton in C#\nDESCRIPTION: Demonstrates a complete setup for a .NET Web Application integrating Wolverine with RabbitMQ for messaging and Marten for PostgreSQL persistence. It configures publishing to a RabbitMQ exchange with a durable outbox, listening to a queue with a durable inbox, sets up the RabbitMQ connection, integrates Marten with Wolverine's outbox/inbox storage, and uses `AddResourceSetupOnStartup()` from Oakton extensions to auto-provision RabbitMQ objects and PostgreSQL schema elements on startup. It also includes a hosted service (`Worker`) for message generation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/object-management.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Host.ApplyOaktonExtensions();\n\nbuilder.Host.UseWolverine(opts =>\n{\n    // I'm setting this up to publish to the same process\n    // just to see things work\n    opts.PublishAllMessages()\n        .ToRabbitExchange(\"issue_events\", exchange => exchange.BindQueue(\"issue_events\"))\n        .UseDurableOutbox();\n\n    opts.ListenToRabbitQueue(\"issue_events\").UseDurableInbox();\n\n    opts.UseRabbitMq(factory =>\n    {\n        // Just connecting with defaults, but showing\n        // how you *could* customize the connection to Rabbit MQ\n        factory.HostName = \"localhost\";\n        factory.Port = 5672;\n    });\n});\n\n// This is actually important, this directs\n// the app to build out all declared Postgresql and\n// Rabbit MQ objects on start up if they do not already\n// exist\nbuilder.Services.AddResourceSetupOnStartup();\n\n// Just pumping out a bunch of messages so we can see\n// statistics\nbuilder.Services.AddHostedService<Worker>();\n\nbuilder.Services.AddMarten(opts =>\n{\n    // I think you would most likely pull the connection string from\n    // configuration like this:\n    // var martenConnectionString = builder.Configuration.GetConnectionString(\"marten\");\n    // opts.Connection(martenConnectionString);\n\n    opts.Connection(Servers.PostgresConnectionString);\n    opts.DatabaseSchemaName = \"issues\";\n\n    // Just letting Marten know there's a document type\n    // so we can see the tables and functions created on startup\n    opts.RegisterDocumentType<Issue>();\n\n    // I'm putting the inbox/outbox tables into a separate \"issue_service\" schema\n}).IntegrateWithWolverine(x => x.MessageStorageSchemaName = \"issue_service\");\n\nvar app = builder.Build();\n\napp.MapGet(\"/\", () => \"Hello World!\");\n\n// Actually important to return the exit code here!\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Disabling Wolverine Conventional Assembly Discovery in C#\nDESCRIPTION: Shows how to disable Wolverine's default assembly scanning mechanism for discovering extensions by calling `opts.DisableConventionalDiscovery()` within the `UseWolverine` configuration lambda and optionally passing `ExtensionDiscovery.ManualOnly`. This can prevent memory issues in specific environments (like Docker root directories) or improve startup time, but requires extensions to be registered manually if needed. This configuration is applied during host setup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Microsoft.Extensions.Hosting.Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.DisableConventionalDiscovery();\n    }, ExtensionDiscovery.ManualOnly)\n    \n    .StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Conventional Routing via Azure Service Bus in Wolverine (C#)\nDESCRIPTION: Demonstrates configuring Wolverine to use Azure Service Bus for message transport with conventional routing, suitable for communication via an external broker. It explicitly disables conventional local routing (`opts.Policies.DisableConventionalLocalRouting()`) to force messages through ASB. It then connects to Azure Service Bus using a connection string (retrieved from configuration) and enables automatic queue/topic provisioning and conventional routing rules (`opts.UseAzureServiceBus(...).AutoProvision().UseConventionalRouting()`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/modular-monolith.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n```cs\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // Turn *off* the conventional local routing so that\n    // the messages that this application handles still go\n    // through the external Azure Service Bus broker\n    opts.Policies.DisableConventionalLocalRouting();\n    \n    // One way or another, you're probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\");\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString).AutoProvision()\n        .UseConventionalRouting();\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Policy for Request ID Middleware in C#\nDESCRIPTION: Implements the `IHttpPolicy` interface to selectively apply the `RequestIdMiddleware`. The `Apply` method iterates through all discovered HTTP chains (`HttpChain`), checks if their service dependencies include `IMessageContext` or `IMessageBus`, and if so, inserts a `MethodCall` targeting `RequestIdMiddleware.Apply` at the beginning of the chain's middleware pipeline. This ensures the request ID logic runs only for relevant endpoints.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\ninternal class RequestIdPolicy : IHttpPolicy\n{\n    public void Apply(IReadOnlyList<HttpChain> chains, GenerationRules rules, IServiceContainer container)\n    {\n        foreach (var chain in chains)\n        {\n            var serviceDependencies = chain.ServiceDependencies(container, Type.EmptyTypes).ToArray();\n            if (serviceDependencies.Contains(typeof(IMessageContext)) ||\n                serviceDependencies.Contains(typeof(IMessageBus)))\n            {\n                chain.Middleware.Insert(0, new MethodCall(typeof(RequestIdMiddleware), nameof(RequestIdMiddleware.Apply)));\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking a Message Handler Locally with IMessageBus in C#\nDESCRIPTION: Illustrates how to trigger the execution of a message handler within the same process using Wolverine's `IMessageBus` interface. The `InvokeAsync` method is called with a new `DebitAccount` message instance, causing Wolverine to find and execute the corresponding handler (`DebitAccountHandler.Handle` in this context). This demonstrates Wolverine's capability as a local mediator or in-process command bus. Requires an injected `IMessageBus` instance.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/basics.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic async Task invoke_debit_account(IMessageBus bus)\n{\n    // Debit $250 from the account #2222\n    await bus.InvokeAsync(new DebitAccount(2222, 250));\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ASP.NET Core with Wolverine and Oakton Integration in C#\nDESCRIPTION: This C# snippet demonstrates the basic configuration of an ASP.NET Core application using Wolverine for messaging and Oakton for command-line parsing. It sets up dependency injection, registers Wolverine (`UseWolverine`), defines simple API endpoints that use `IMessageBus`, includes Swashbuckle for API documentation, and crucially, integrates Oakton (`app.RunOaktonCommands`) to enable command-line diagnostics and utilities for the Wolverine application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/diagnostics.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing Oakton;\nusing Quickstart;\nusing Wolverine;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// The almost inevitable inclusion of Swashbuckle:)\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// For now, this is enough to integrate Wolverine into\n// your application, but there'll be *many* more\n// options later of course :-)\nbuilder.Host.UseWolverine();\n\n// Some in memory services for our application, the\n// only thing that matters for now is that these are\n// systems built by the application's IoC container\nbuilder.Services.AddSingleton<UserRepository>();\nbuilder.Services.AddSingleton<IssueRepository>();\n\nvar app = builder.Build();\n\n// An endpoint to create a new issue that delegates to Wolverine as a mediator\napp.MapPost(\"/issues/create\", (CreateIssue body, IMessageBus bus) => bus.InvokeAsync(body));\n\n// An endpoint to assign an issue to an existing user that delegates to Wolverine as a mediator\napp.MapPost(\"/issues/assign\", (AssignIssue body, IMessageBus bus) => bus.InvokeAsync(body));\n\n// Swashbuckle inclusion\napp.UseSwagger();\napp.UseSwaggerUI();\n\napp.MapGet(\"/\", () => Results.Redirect(\"/swagger\"));\n\n// Opt into using Oakton for command line parsing\n// to unlock built in diagnostics and utility tools within\n// your Wolverine application\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Configuring a Specific Durable Messaging Endpoint in Wolverine (C#)\nDESCRIPTION: Shows how to configure a single outgoing subscriber endpoint to use durable message storage in a Wolverine application. Using the Host builder, this snippet applies the 'UseDurableOutbox' option to ensure that messages sent to port 5555 are persisted using the outbox pattern. Requires the Wolverine library, and must be run in a .NET host context. No extra input is required; the setting applies to all messages published on this specific endpoint.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/index.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.PublishAllMessages().ToPort(5555)\n\n            // This option makes just this one outgoing subscriber use\n            // durable message storage\n            .UseDurableOutbox();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Using Marten StartStream Operation in HTTP Endpoint (C#)\nDESCRIPTION: Illustrates a Wolverine HTTP endpoint (`[WolverinePost]`) creating a new Marten event stream. It takes a `CreateTodoListRequest`, generates an ID and a `TodoListCreated` event, then returns a tuple containing a response object and an `IStartStream` side effect generated by `MartenOps.StartStream<TodoList>(listId, result)`. This side effect instructs Wolverine to initiate a new event stream for the `TodoList` aggregate with the created event.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/operations.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic static class TodoListEndpoint\n{\n    [WolverinePost(\"/api/todo-lists\")]\n    public static (TodoCreationResponse, IStartStream) CreateTodoList(\n        CreateTodoListRequest request\n    )\n    {\n        var listId = CombGuidIdGeneration.NewGuid();\n        var result = new TodoListCreated(listId, request.Title);\n        var startStream = MartenOps.StartStream<TodoList>(listId, result);\n\n        return (new TodoCreationResponse(listId), startStream);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine to Publish Raw JSON to SQS in C#\nDESCRIPTION: This snippet shows how to configure Wolverine to publish all messages to an AWS SQS queue named 'outgoing' as raw JSON. It specifies that only messages of type 'Message1' will be published to this queue in this manner and allows for optional customization of System.Text.Json serialization settings, like using camelCase for property names. This approach is suitable for sending messages to external systems that expect plain JSON.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/interoperability.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAmazonSqsTransport();\n\n        opts.PublishAllMessages().ToSqsQueue(\"outgoing\").SendRawJsonMessage(\n            // Specify the single message type for this queue\n            typeof(Message1),\n\n            // Optionally customize System.Text.Json configuration\n            o => { o.PropertyNamingPolicy = JsonNamingPolicy.CamelCase; });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Starting a Saga with Scheduled Timeout Message Handling (Wolverine/.NET/C#)\nDESCRIPTION: Demonstrates a handler that starts a new saga (Order) and returns a timeout message for automatic scheduling using the OrderTimeout type. Dependencies: Wolverine, saga conventions, ILogger, Order and StartOrder types. The method logs new order receipt, creates an Order entity, and returns it along with the scheduled timeout message. Inputs: StartOrder command, logger; Outputs: tuple containing Order and related timeout message. Requires logger injection and message types defined elsewhere.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\n// This method would be called when a StartOrder message arrives\n// to start a new Order\npublic static (Order, OrderTimeout) Start(StartOrder order, ILogger<Order> logger)\n{\n    logger.LogInformation(\"Got a new order with id {Id}\", order.OrderId);\n\n    // creating a timeout message for the saga\n    return (new Order{Id = order.OrderId}, new OrderTimeout(order.OrderId));\n}\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping Wolverine and Marten for Conjoined Multi-Tenancy in C#\nDESCRIPTION: Demonstrates application host setup using `UseWolverine` and adding Marten persistence for a single-conjoined database, enabling lightweight sessions and automated transaction policies. Requires that a valid PostgreSQL connection string is supplied and Marten/Wolverine services are available. No direct input parameters beyond connection string; outputs a configured, running host ready for multi-tenant operations.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/multi-tenancy.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n_host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.Services.AddMarten(Servers.PostgresConnectionString)\n            .IntegrateWithWolverine()\n            .UseLightweightSessions();\n\n        opts.Policies.AutoApplyTransactions();\n\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Overriding ProblemDetails Status Code in OpenAPI Metadata (C#)\nDESCRIPTION: Demonstrates how to use the `ProducesResponseType` attribute in C# to override the default 400 status code associated with `ProblemDetails` in OpenAPI documentation. In this example, the status code for `ProblemDetails` responses is set to 418 (I'm a teapot).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/problemdetails.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n    // Use 418 as the status code instead\n    [ProducesResponseType(typeof(ProblemDetails), 418)]\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Overdrawn Account Handler with TestMessageContext in C#\nDESCRIPTION: This code defines an xUnit asynchronous test fixture for verifying the behavior of a message handler in an overdrawn account scenario using Wolverine's TestMessageContext. Dependencies include Account domain objects, TestMessageContext for capturing outgoing messages, and NSubstitute for providing a stub IDocumentSession. The fixture executes DebitAccountHandler.Handle, then asserts the resulting account balance and checks that appropriate messages (AccountOverdrawn, EnforceAccountOverdrawnDeadline) are sent or scheduled with correct timing. Input is simulated via domain commands; output is validated via assertions on TestMessageContext's state. Requires xUnit and Wolverine test extensions.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\npublic class when_the_account_is_overdrawn : IAsyncLifetime\n{\n    private readonly Account theAccount = new Account\n    {\n        Balance = 1000,\n        MinimumThreshold = 100,\n        Id = Guid.NewGuid()\n    };\n\n    private readonly TestMessageContext theContext = new TestMessageContext();\n\n    // I happen to like NSubstitute for mocking or dynamic stubs\n    private readonly IDocumentSession theDocumentSession = Substitute.For<IDocumentSession>();\n\n    public async Task InitializeAsync()\n    {\n        var command = new DebitAccount(theAccount.Id, 1200);\n        await DebitAccountHandler.Handle(command, theAccount, theDocumentSession, theContext);\n    }\n\n    [Fact]\n    public void the_account_balance_should_be_negative()\n    {\n        theAccount.Balance.ShouldBe(-200);\n    }\n\n    [Fact]\n    public void raises_an_account_overdrawn_message()\n    {\n        // ShouldHaveMessageOfType() is an extension method in\n        // Wolverine itself to facilitate unit testing assertions like this\n        theContext.Sent.ShouldHaveMessageOfType<AccountOverdrawn>()\n            .AccountId.ShouldBe(theAccount.Id);\n    }\n\n    [Fact]\n    public void raises_an_overdrawn_deadline_message_in_10_days()\n    {\n        theContext.ScheduledMessages()\n            // Find the wrapping envelope for this message type,\n            // then we can chain assertions against the wrapping Envelope\n            .ShouldHaveEnvelopeForMessageType<EnforceAccountOverdrawnDeadline>()\n            .ScheduleDelay.ShouldBe(10.Days());\n    }\n\n    public Task DisposeAsync()\n    {\n        return Task.CompletedTask;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling an Event Message in Wolverine (C#)\nDESCRIPTION: Shows a simple static Wolverine message handler class for the `OrderPlaced` event. The `Handle` method receives the `OrderPlaced` message (published potentially by another handler) and performs an action, in this case, writing the OrderId to the debug output.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/modular-monolith.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\npublic static class OrderPlacedHandler\n{\n    public static void Handle(OrderPlaced @event) \n        => Debug.WriteLine(\"got a new order \" + @event.OrderId);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Asserting Wolverine Application Configuration Validity Programmatically in C#\nDESCRIPTION: This C# snippet shows a function that utilizes the `AssertWolverineConfigurationIsValid()` extension method on an `IHost` instance. This method performs a comprehensive check of the Wolverine configuration, including attempting to generate and compile handler code and leveraging the underlying IoC container's (Lamar) diagnostics. It's primarily intended for use in testing scenarios to ensure the application's messaging and dependency injection setup is valid.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/diagnostics.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\npublic static void assert_configuration_is_valid(IHost host)\n{\n    host.AssertWolverineConfigurationIsValid();\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to LocalStack SQS via Wolverine (C#)\nDESCRIPTION: This snippet demonstrates how to configure Wolverine to use a locally running Amazon SQS compatible service, such as LocalStack, for development purposes. By calling UseAmazonSqsTransportLocally() within the configuration lambda, it automatically points the transport at the LocalStack endpoint. This setup enables testing SQS integration without live AWS services. Required dependencies include WolverineFx.AmazonSqs and a running instance of LocalStack. The output is a started host instance configured to use LocalStack for SQS.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/index.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Connect to an SQS broker running locally\n        // through LocalStack\n        opts.UseAmazonSqsTransportLocally();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Example Request Body for Querying Dead Letters API (JSON)\nDESCRIPTION: Provides an example JSON request body for the `POST /dead-letters/` endpoint. It demonstrates filtering dead letters based on criteria like the number of records (`Limit`), `MessageType`, and `ExceptionType`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/dead-letter-storage.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Limit\": 50,\n  \"MessageType\": \"OrderPlacedEvent\",\n  \"ExceptionType\": \"InvalidOrderException\"\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Pong Messages in Pinger with Wolverine in C#\nDESCRIPTION: Provides a message handler class for Pong messages in the Pinger application, processing inbound Pong messages by logging their Number property. The handler method takes a Pong message and an ILogger via dependency injection, ensuring integration with the messaging pipeline. Dependencies include the Messages library and a logging framework. The handler expects a Pong object as input and produces log entries as output.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/ping-pong.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nusing Messages;\n\nnamespace Pinger;\n\npublic class PongHandler\n{\n    public void Handle(Pong pong, ILogger<PongHandler> logger)\n    {\n        logger.LogInformation(\"Received Pong #{Number}\", pong.Number);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Directly Starting a Saga with Empty HTTP Response via Wolverine (C#)\nDESCRIPTION: This snippet illustrates how to start a new Reservation saga through an HTTP POST method by returning a single Reservation object and marking the endpoint with [EmptyResponse]. This instructs Wolverine to disregard the return as a response body and instead process it as a persistent saga entity. The endpoint depends on StartReservation as input, requires the EmptyResponse directive for intended behavior, and outputs a new saga; the method will not invoke static Start() if present.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/sagas.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverinePost(\"/reservation2\")]\n\n// This directs Wolverine to disregard the Reservation return value\n// as the response body, and allow Wolverine to use the Reservation\n// return as a new saga\n[EmptyResponse]\npublic static Reservation Post2(StartReservation start)\n{\n    return new Reservation { Id = start.ReservationId };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Explicit Local Queue Routing in Wolverine C#\nDESCRIPTION: This snippet demonstrates how to configure explicit message routing rules during application startup using the `UseWolverine` extension method. It specifically routes messages of type `Message2` to the local queue named 'important' using the fluent API (`PublishMessage<T>().ToLocalQueue()`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Publish Message2 messages to the \"important\"\n        // local queue\n        opts.PublishMessage<Message2>()\n            .ToLocalQueue(\"important\");\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Setting Up All Wolverine Resources via CLI using Bash\nDESCRIPTION: Shows the command `dotnet run -- resources setup` which attempts to create or update all configured Wolverine resources. This includes database objects for message persistence as well as transport objects like RabbitMQ queues or Azure Service Bus entities if configured.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- resources setup\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine FluentValidation Middleware in Application Bootstrap - C#\nDESCRIPTION: Shows how to integrate the FluentValidation middleware for HTTP endpoints in a Wolverine application. This snippet demonstrates bootstrapping: the opts.UseFluentValidationProblemDetailMiddleware() call opts in to request body validation and standardized error responses per the ProblemDetails spec. Intended for use in the application's startup configuration where endpoints are mapped via MapWolverineEndpoints. Requires Wolverine.Http.FluentValidation package.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/from-mediatr.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\napp.MapWolverineEndpoints(opts =>\n{\n    // more configuration for HTTP...\n\n    // Opting into the Fluent Validation middleware from\n    // Wolverine.Http.FluentValidation\n    opts.UseFluentValidationProblemDetailMiddleware();\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing ServiceProvider with Lamar in ASP.NET Core (C#)\nDESCRIPTION: Demonstrates replacing the default ServiceProvider with Lamar in an ASP.NET Core application using WebApplicationBuilder. Illustrates setting up Lamar with the host builder for web applications. Ensures that Lamar is used for all service registrations and resolutions in the web host. Requires Lamar NuGet package and a standard ASP.NET Core setup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/configuration.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = WebApplication.CreateBuilder(args);\\nbuilder.Host.UseLamar();\n```\n\n----------------------------------------\n\nTITLE: Disabling Conventional Local Queue Routing in Wolverine C#\nDESCRIPTION: This snippet demonstrates how to disable the default conventional routing of messages to local queues within Wolverine's configuration. By calling `opts.Policies.DisableConventionalLocalRouting()`, messages without explicit routing rules will not automatically be sent to a local queue named after their type, allowing other routing conventions (e.g., to external transports) to take precedence.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic static async Task disable_queue_routing()\n{\n    using var host = await Host.CreateDefaultBuilder()\n        .UseWolverine(opts =>\n        {\n            // This will disable the conventional local queue\n            // routing that would take precedence over other conventional\n            // routing\n            opts.Policies.DisableConventionalLocalRouting();\n\n            // Other routing conventions. Rabbit MQ? SQS?\n        }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Using TCP as Control Endpoint for Wolverine (C#)\nDESCRIPTION: This C# configuration enables Wolverine to use a local TCP port for control queues during development. 'UseTcpForControlEndpoint' automatically selects an unused port for runtime node communication. This alternative is useful when Azure Service Bus or other brokers are unavailable.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/ravendb.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nWolverineOptions.UseTcpForControlEndpoint();\n```\n\n----------------------------------------\n\nTITLE: Writing Generated Source Code Ahead of Time (Bash CLI)\nDESCRIPTION: This Bash command invokes pre-compilation of handler adaptor source code via the Oakton-powered 'codegen write' command. Designed for use during development or build pipelines, it generates and writes the source code files for all handlers into '/Internal/Generated/WolverineHandlers' in the project structure. This process is essential before using Static or Auto modes and requires Oakton integration. Inputs are the project context; output is written .cs files ready for deployment or auditing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/codegen.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- codegen write\n```\n\n----------------------------------------\n\nTITLE: Using ProblemDetails Middleware with Marten Aggregates (C#)\nDESCRIPTION: Shows a static `Before` middleware method used with a Marten aggregate handler in Wolverine. The method accepts the command (`IShipOrder`) and the loaded Marten aggregate (`Order`). It performs validation based on the aggregate's state (checking if the order is already shipped) and returns `ProblemDetails` with a specific status code (428 Precondition Required) if validation fails, or `WolverineContinue.NoProblems` otherwise. Requires Wolverine.Http and Wolverine.Marten.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/problemdetails.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n[AggregateHandler]\npublic static ProblemDetails Before(IShipOrder command, Order order)\n{\n    if (order.IsShipped())\n    {\n        return new ProblemDetails\n        {\n            Detail = \"Order already shipped\",\n            Status = 428\n        };\n    }\n    return WolverineContinue.NoProblems;\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Custom MQTT Envelope Mapper in Wolverine Configuration (C#)\nDESCRIPTION: This C# snippet shows how to configure a Wolverine application to use a custom 'IMqttEnvelopeMapper' implementation ('MyMqttEnvelopeMapper') for MQTT interoperability. It sets up the MQTT connection, configures Wolverine to publish all messages to MQTT topics, and explicitly applies the custom mapper using 'UseInterop' for handling message transformations.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n\nbuilder.UseWolverine(opts =>\n{\n    // Connect to the MQTT broker\n    opts.UseMqtt(mqtt =>\n    {\n        var mqttServer = builder.Configuration[\"mqtt_server\"];\n\n        mqtt\n            .WithMaxPendingMessages(3)\n            .WithClientOptions(client => { client.WithTcpServer(mqttServer); });\n    });\n\n    // Publish messages to MQTT topics based on\n    // the message type\n    opts.PublishAllMessages()\n        .ToMqttTopics()\n\n        // Tell Wolverine to map envelopes to MQTT messages\n        // with our custom strategy\n        .UseInterop(new MyMqttEnvelopeMapper())\n        .QualityOfService(MqttQualityOfServiceLevel.AtMostOnce);\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Selectively Auto-Purging Specific RabbitMQ Queues with Wolverine in C#\nDESCRIPTION: Illustrates how to configure Wolverine to purge only specific RabbitMQ queues at application startup. It declares two queues, \"queue1\" (which won't be purged by default) and \"queue2\", explicitly setting `PurgeOnStartup = true` for \"queue2\" within the `DeclareQueue` configuration lambda.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/object-management.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq()\n            .DeclareQueue(\"queue1\")\n            .DeclareQueue(\"queue2\", q => q.PurgeOnStartup = true);\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Tenant Id Detection in ASP.NET Core with WolverineFx.Http.Marten (C#)\nDESCRIPTION: This snippet demonstrates how to configure Marten to detect tenant ids from HTTP requests using the AddMartenTenancyDetection extension method in an ASP.NET Core application. The configuration registers a tenant id resolver that extracts the tenant id from a query string parameter named \"tenant\", and specifies a default tenant value of \"default-tenant\" if the parameter is missing. Requires the WolverineFx.Http.Marten NuGet package and is intended for apps where Wolverine is not otherwise in use. Inputs include the HTTP query string, and outputs are multi-tenant-aware Marten sessions. Assumes the presence of a standard dependency injection setup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddMartenTenancyDetection(tenantId =>\n{\n    tenantId.IsQueryStringValue(\"tenant\");\n    tenantId.DefaultIs(\"default-tenant\");\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine to Listen to GCP Pub/Sub Topics in C#\nDESCRIPTION: This snippet demonstrates setting up a .NET application's host to use Wolverine for listening to multiple GCP Pub/Sub topics. It configures two topic listeners (\\\"incoming1\\\" and \\\"incoming2\\\"), sets parallel listener count, and customizes Pub/Sub subscription settings including dead letter and retry policies. Dependencies include the Host and Wolverine libraries, along with correct Pub/Sub access and configuration. Inputs are applied via method calls (such as project ID, topic names, and policies), and the output is an asynchronously running host listening to specified topics.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/gcp-pubsub/listening.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UsePubsub(\"your-project-id\");\n\n        opts.ListenToPubsubTopic(\"incoming1\");\n\n        opts.ListenToPubsubTopic(\"incoming2\")\n\n            // You can optimize the throughput by running multiple listeners\n            // in parallel\n            .ListenerCount(5)\n            .ConfigurePubsubSubscription(options =>\n            {\n                // Optionally configure the subscription itself\n                options.DeadLetterPolicy = new DeadLetterPolicy\n                {\n                    DeadLetterTopic = \"errors\",\n                    MaxDeliveryAttempts = 5\n                };\n                options.AckDeadlineSeconds = 60;\n                options.RetryPolicy = new RetryPolicy\n                {\n                    MinimumBackoff = Duration.FromTimeSpan(TimeSpan.FromSeconds(1)),\n                    MaximumBackoff = Duration.FromTimeSpan(TimeSpan.FromSeconds(10))\n                };\n            });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring RabbitMQ Quorum Queues or Streams with Wolverine in C#\nDESCRIPTION: Illustrates configuring Wolverine to use RabbitMQ Quorum Queues or Streams. It shows declaring a specific queue as a stream using `QueueType = QueueType.stream`, setting a global policy to use quorum queues by default with `UseQuorumQueues()` (or streams with `UseStreamsAsQueues()`), and overriding the policy for a specific listener queue using `.QueueType(QueueType.quorum)`. Note that internal Wolverine queues remain classic, and streams cannot be purged.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/object-management.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    opts\n        .UseRabbitMq(builder.Configuration.GetConnectionString(\"rabbit\"))\n        \n        // You can configure the queue type for declaration with this\n        // usage as well\n        .DeclareQueue(\"stream\", q => q.QueueType = QueueType.stream)\n\n        // Use quorum queues by default as a policy\n        .UseQuorumQueues()\n\n        // Or instead use streams\n        .UseStreamsAsQueues();\n\n    opts.ListenToRabbitQueue(\"quorum1\")\n        // Override the queue type in declarations for a\n        // single queue, and the explicit configuration will win\n        // out over any policy or convention\n        .QueueType(QueueType.quorum);\n    \n    \n});\n```\n\n----------------------------------------\n\nTITLE: Transforming and Publishing Integration Events with Wolverine Handlers in C#\nDESCRIPTION: This snippet demonstrates how to define custom record types and a static handler class in C# for transforming internal event representations before publishing as integration events via Wolverine. It utilizes Marten's IEvent<T> wrapper and loads related data (such as Customer) within handlers for enrichment. Dependencies include Marten abstractions, a Customer domain model, and a formally declared event type. Inputs are OrderCreated events and query sessions; outputs are enriched OrderCreatedIntegrationEvent instances. This pattern is useful for decoupling internal event structures from external integrations and enforces handler statelessness and composability.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/subscriptions.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic record OrderCreated(string OrderNumber, Guid CustomerId);\n\n// I wouldn't use this kind of suffix in real life, but it helps\n// document *what* this is for the sample in the docs:)\npublic record OrderCreatedIntegrationEvent(string OrderNumber, string CustomerName, DateTimeOffset Timestamp);\n\n// We're going to use the Marten IEvent metadata and some other Marten reference\n// data to transform the internal OrderCreated event\n// to an OrderCreatedIntegrationEvent that will be more appropriate for publishing to\n// external systems\npublic static class InternalOrderCreatedHandler\n{\n    public static Task<Customer?> LoadAsync(IEvent<OrderCreated> e, IQuerySession session,\n        CancellationToken cancellationToken)\n        => session.LoadAsync<Customer>(e.Data.CustomerId, cancellationToken);\n\n    public static OrderCreatedIntegrationEvent Handle(IEvent<OrderCreated> e, Customer customer)\n    {\n        return new OrderCreatedIntegrationEvent(e.Data.OrderNumber, customer.Name, e.Timestamp);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Interface for Tenant-Based Topic Routing (C#)\nDESCRIPTION: This snippet defines a simple C# interface `ITenantMessage` with a single property `TenantId`. Message types implementing this interface can provide a tenant identifier, which can then be used in Wolverine configuration to determine the RabbitMQ topic for routing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/topics.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic interface ITenantMessage\n{\n    string TenantId { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Marten Persistence with Wolverine in C#\nDESCRIPTION: This code demonstrates how to configure Marten persistence within a .NET application's service collection and integrate it with Wolverine. Calling `.IntegrateWithWolverine()` adds Marten integration and enables features like PostgreSQL-backed message persistence for Wolverine's transactional outbox.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nbuilder.Services.AddMarten(opts =>\n{\n    // Marten configuration...\n})\n    // This adds Marten integration \n    // and PostgreSQL backed message persistence\n    // to Wolverine in this application\n    .IntegrateWithWolverine();\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Services for Wolverine Sample\nDESCRIPTION: This shell command uses Docker Compose to start the required background services (PostgreSQL and PgAdmin4) defined in the `docker-compose.yml` file in detached mode (`-d`). This is a prerequisite for running the application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/CommandBus/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Returning Empty HTTP Response with Cascading Message using [EmptyResponse] in Wolverine C#\nDESCRIPTION: This C# snippet defines a Wolverine HTTP POST endpoint (`/orders/ship`) using `[WolverinePost(\"/orders/ship\"), EmptyResponse]`. The `[EmptyResponse]` attribute ensures an empty HTTP response body (204 No Content), while the method's return value (`OrderShipped`) is processed by Wolverine's return value rules (e.g., published as a message or event) instead of being serialized as the response. `[AggregateHandler]` suggests event sourcing integration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n[AggregateHandler]\n[WolverinePost(\"/orders/ship\"), EmptyResponse]\n// The OrderShipped return value is treated as an event being posted\n// to a Marten even stream\n// instead of as the HTTP response body because of the presence of\n// the [EmptyResponse] attribute\npublic static OrderShipped Ship(ShipOrder command, Order order)\n{\n    return new OrderShipped();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RabbitMQ Queue Listeners in Wolverine (C#)\nDESCRIPTION: This C# snippet demonstrates configuring a Wolverine host to listen to RabbitMQ queues. It initializes the host, configures Wolverine to use RabbitMQ via a connection URI, and sets up listeners for two queues ('incoming1' and 'incoming2'). For 'incoming1', it specifies performance tuning options like `PreFetchCount`, `ListenerCount`, circuit breaker settings (`PauseTime`, `FailurePercentageThreshold`), and enables `UseDurableInbox`. For 'incoming2', it configures queue properties like `PurgeOnStartup` and `TimeToLive` assuming Wolverine manages the queue setup. Dependencies include Wolverine, Wolverine.RabbitMQ, and Microsoft.Extensions.Hosting.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/listening.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // *A* way to configure Rabbit MQ using their Uri schema\n        // documented here: https://www.rabbitmq.com/uri-spec.html\n        opts.UseRabbitMq(new Uri(\"amqp://localhost\"));\n\n        // Set up a listener for a queue\n        opts.ListenToRabbitQueue(\"incoming1\")\n            .PreFetchCount(100)\n            .ListenerCount(5) // use 5 parallel listeners\n            .CircuitBreaker(cb =>\n            {\n                cb.PauseTime = 1.Minutes();\n                // 10% failures will cause the listener to pause\n                cb.FailurePercentageThreshold = 10;\n            })\n            .UseDurableInbox();\n\n        // Set up a listener for a queue, but also\n        // fine-tune the queue characteristics if Wolverine\n        // will be governing the queue setup\n        opts.ListenToRabbitQueue(\"incoming2\", q =>\n        {\n            q.PurgeOnStartup = true;\n            q.TimeToLive(5.Minutes());\n        });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Solo Mode for Integration Tests (C#)\nDESCRIPTION: This snippet shows how to configure Wolverine to run in \"Solo\" mode specifically for integration testing environments, often bootstrapped using tools like `WebHostFactory` or Alba (as shown). It utilizes the `RunWolverineInSoloMode()` extension method on the `IServiceCollection` within the test host configuration to override the application's default Wolverine settings. Additionally, it demonstrates disabling all external Wolverine transports using `DisableAllExternalWolverineTransports()` for more isolated testing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/testing.md#_snippet_13\n\nLANGUAGE: cs\nCODE:\n```\n// This is bootstrapping the actual application using\n// its implied Program.Main() set up\n// For non-Alba users, this is using IWebHostBuilder \nHost = await AlbaHost.For<Program>(x =>\n{\n    x.ConfigureServices(services =>\n    {\n        // Override the Wolverine configuration in the application\n        // to run the application in \"solo\" mode for faster\n        // testing cold starts\n        services.RunWolverineInSoloMode();\n\n        // And just for completion, disable all Wolverine external \n        // messaging transports\n        services.DisableAllExternalWolverineTransports();\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine SQS Listener with Queue Attributes and Parallelization in C#\nDESCRIPTION: This C# code snippet demonstrates configuring a Wolverine host to listen to an SQS queue named 'incoming'. It utilizes the Amazon SQS transport, enables auto-provisioning and optional purging of queues. Specific SQS queue attributes like 'DelaySeconds' (set to 5 seconds) and 'MessageRetentionPeriod' (set to 4 days) are configured. The listener count is increased to 5 for parallel processing to improve throughput. Requires the Wolverine.AmazonSqs NuGet package and a configured AWS environment.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/listening.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAmazonSqsTransport()\n\n            // Let Wolverine create missing queues as necessary\n            .AutoProvision()\n\n            // Optionally purge all queues on application startup.\n            // Warning though, this is potentially slow\n            .AutoPurgeOnStartup();\n\n        opts.ListenToSqsQueue(\"incoming\", queue =>\n            {\n                queue.Configuration.Attributes[QueueAttributeName.DelaySeconds]\n                    = \"5\";\n\n                queue.Configuration.Attributes[QueueAttributeName.MessageRetentionPeriod]\n                    = 4.Days().TotalSeconds.ToString();\n            })\n            // You can optimize the throughput by running multiple listeners\n            // in parallel\n            .ListenerCount(5);\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Example Request Body for Replaying Dead Letters API (JSON)\nDESCRIPTION: Illustrates an example JSON request body for the `POST /dead-letters/replay` endpoint. It contains an array of `Ids` specifying which dead letter messages should be marked as replayable for reprocessing.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/dead-letter-storage.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Ids\": [\"d3b07384-d113-4ec8-98c4-b3bf34e2c572\", \"d3b07384-d113-4ec8-98c4-b3bf34e2c573\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Marten Compiled Query from Wolverine HTTP Endpoint in C#\nDESCRIPTION: Defines a Wolverine HTTP GET endpoint using `[WolverineGet]` that returns an instance of `ApprovedInvoicedCompiledQuery`. When the Marten compiled query policy is enabled, Wolverine executes this query and streams the results directly as the JSON response, bypassing intermediate deserialization.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n[WolverineGet(\"/invoices/approved\")]\npublic static ApprovedInvoicedCompiledQuery GetApproved()\n{\n    return new ApprovedInvoicedCompiledQuery();\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Local Queues via Options in C#\nDESCRIPTION: This snippet demonstrates configuring Wolverine local queues during host setup using UseWolverine. It shows how to set durability (UseDurableInbox) and sequential processing (Sequential) for queues identified by message type (Message1) or name ('one', 'two'). It also illustrates setting maximum parallelism (MaximumParallelMessages) and applying default policies (AllLocalQueues) to all local queues, noting that specific configurations take precedence.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Explicit configuration for the local queue\n        // by the message type it handles:\n        opts.LocalQueueFor<Message1>()\n            .UseDurableInbox()\n            .Sequential();\n\n        // Explicit configuration by queue name\n        opts.LocalQueue(\"one\")\n            .Sequential();\n\n        opts.LocalQueue(\"two\")\n            .MaximumParallelMessages(10)\n            .UseDurableInbox();\n\n        // Apply configuration options to all local queues,\n        // but explicit changes to specific local queues take precedence\n        opts.Policies.AllLocalQueues(x => x.UseDurableInbox());\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Appending Single Marten Event from Wolverine HTTP Endpoint in C#\nDESCRIPTION: Defines a Wolverine HTTP POST endpoint using `[WolverinePost]` and `[AggregateHandler]` attributes. The `Ship` method takes a `ShipOrder` command and an `Order` aggregate. It returns an `OrderShipped` event. The `[EmptyResponse]` attribute ensures this event is appended to the Marten event stream for the corresponding `Order` aggregate instead of being sent as the HTTP response body.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[AggregateHandler]\n[WolverinePost(\"/orders/ship\"), EmptyResponse]\n// The OrderShipped return value is treated as an event being posted\n// to a Marten even stream\n// instead of as the HTTP response body because of the presence of\n// the [EmptyResponse] attribute\npublic static OrderShipped Ship(ShipOrder command, Order order)\n{\n    return new OrderShipped();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom RabbitMQ Topic Routing Rules in Wolverine (C#)\nDESCRIPTION: This snippet demonstrates configuring a Wolverine publishing rule to dynamically determine the RabbitMQ topic based on message properties. It targets messages implementing `ITenantMessage` and publishes them to the 'tenant.messages' exchange. The topic name is generated using a lambda expression that combines the message type name and the `TenantId` (e.g., 'messagetypename/tenantid'). The `.BufferedInMemory()` method is chained to specify sending configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/topics.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    opts.UseRabbitMq();\n\n    // Publish any message that implements ITenantMessage to\n    // a Rabbit MQ \"Topic\" exchange named \"tenant.messages\"\n    opts.PublishMessagesToRabbitMqExchange<ITenantMessage>(\"tenant.messages\",\n            m => $\"{m.GetType().Name.ToLower()}/{m.TenantId}\")\n\n        // Specify or configure sending through Wolverine for all\n        // messages through this Exchange\n        .BufferedInMemory();\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Returning Multiple Cascading Messages via Tuples in Wolverine (C#)\nDESCRIPTION: This C# snippet presents an alternative way to return multiple cascading messages using C# tuples. The `TupleResponseHandler`'s `Consume` method returns a `(GoNorth, GoWest)` tuple. Wolverine interprets each item in the returned tuple as a distinct cascading message. This approach enhances code readability compared to returning `IEnumerable<object>` by making the cascaded types explicit in the method signature.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\npublic class TupleResponseHandler\n{\n    // Both GoNorth and GoWest will be interpreted as\n    // cascading messages\n    public (GoNorth, GoWest) Consume(MyMessage message)\n    {\n        return (new GoNorth(), new GoWest());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing Wolverine Handler Discovery Rules (C#)\nDESCRIPTION: This C# code shows how to replace Wolverine's default handler discovery mechanism with custom rules. It first disables the built-in conventional discovery using `opts.DisableConventionalDiscovery()` and then adds a custom rule using `opts.Discovery.CustomizeHandlerDiscovery()`, specifying that types with the suffix \"Listener\" should be included as handlers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/discovery.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Turn off Wolverine's built in handler discovery\n        opts.DisableConventionalDiscovery();\n        \n        // And replace the scanning with your own special discovery:\n        opts.Discovery.CustomizeHandlerDiscovery(q =>\n        {\n            q.Includes.WithNameSuffix(\"Listener\");\n        });\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Clearing Retained MQTT Messages in Wolverine Handlers (C#)\nDESCRIPTION: This C# snippet demonstrates two Wolverine message handlers that return cascading messages to clear retained messages from MQTT topics. The first handler returns 'AckMqttTopic()' to clear the topic from which the 'ZeroMessage' was received. The second handler returns 'ClearMqttTopic(\"red\")' to clear a specifically named topic (\"red\") when handling a 'TriggerZero' message.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\npublic static AckMqttTopic Handle(ZeroMessage message)\n{\n    // \"Zero out\" the topic that the original message was received from\n    return new AckMqttTopic();\n}\n\npublic static ClearMqttTopic Handle(TriggerZero message)\n{\n    // \"Zero out\" the designated topic\n    return new ClearMqttTopic(\"red\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Command Record for Order Item Readiness - C#\nDESCRIPTION: This short snippet defines a command record in C# for marking an order item as ready, encapsulating the order ID, item name, and version for concurrency checks in Marten. It is constructed to support optimistic concurrency on the aggregate and is intended for use as a message in CQRS workflows, with no specific dependencies beyond typical C# and Marten integration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// OrderId refers to the identity of the Order aggregate\npublic record MarkItemReady(Guid OrderId, string ItemName, int Version);\n```\n\n----------------------------------------\n\nTITLE: Handling Account Existence in Wolverine Message Handler - C#\nDESCRIPTION: Shows the original repetitive pattern in handlers where the account is loaded from persistence using Marten, non-existence is logged, and handling aborts. Requires an instance of IDocumentSession for database access, and ILogger for logging. Accepts a DebitAccount command and expects an Account object to be loaded; if not found, logs and returns early. This synchronous pattern is a candidate for refactoring via middleware.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/middleware.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task Handle(DebitAccount command, IDocumentSession session, ILogger logger)\n{\n    // Try to find a matching account for the incoming command\n    var account = await session.LoadAsync<Account>(command.AccountId);\n    if (account == null)\n    {\n        logger.LogInformation(\"Referenced account {AccountId} does not exist\", command.AccountId);\n        return;\n    }\n\n    // do the real processing\n}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Specifying Aggregate Identity using [Identity] Attribute in C#\nDESCRIPTION: Demonstrates how to explicitly designate the property representing the aggregate identity in a command class using Marten's `[Identity]` attribute. This overrides the default naming convention, allowing properties like `Id` to be used for the `Order` aggregate identity.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic class MarkItemReady\n{\n    // This attribute tells Wolverine that this property will refer to the\n    // Order aggregate\n    [Identity] public Guid Id { get; init; }\n\n    public string ItemName { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Wolverine.Http Handler Code for Required Input in C#\nDESCRIPTION: Shows the C# code generated by Wolverine.Http for the PUT endpoint `/todos/{id}` that uses the `[Required]` attribute. The generated `Handle` method demonstrates parsing the route parameter `id`, deserializing the request body, calling the custom `LoadAsync` method, checking if the returned `todo` is null, and returning a 404 status code if it is. Only if `todo` is not null does it proceed to call the original `UpdateEndpoint.Put` method and handle Marten side effects (`StoreDoc`) and session persistence.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n    public class PUT_todos_id : Wolverine.Http.HttpHandler\n    {\n        private readonly Wolverine.Http.WolverineHttpOptions _wolverineHttpOptions;\n        private readonly Marten.ISessionFactory _sessionFactory;\n\n        public PUT_todos_id(Wolverine.Http.WolverineHttpOptions wolverineHttpOptions, Marten.ISessionFactory sessionFactory) : base(wolverineHttpOptions)\n        {\n            _wolverineHttpOptions = wolverineHttpOptions;\n            _sessionFactory = sessionFactory;\n        }\n\n\n\n        public override async System.Threading.Tasks.Task Handle(Microsoft.AspNetCore.Http.HttpContext httpContext)\n        {\n            await using var documentSession = _sessionFactory.OpenSession();\n            if (!int.TryParse((string)httpContext.GetRouteValue(\"id\"), out var id))\n            {\n                httpContext.Response.StatusCode = 404;\n                return;\n            }\n\n\n            var (request, jsonContinue) = await ReadJsonAsync<WolverineWebApi.Samples.UpdateRequest>(httpContext);\n            if (jsonContinue == Wolverine.HandlerContinuation.Stop) return;\n            var todo = await WolverineWebApi.Samples.UpdateEndpoint.LoadAsync(id, documentSession).ConfigureAwait(false);\n            // 404 if this required object is null\n            if (todo == null)\n            {\n                httpContext.Response.StatusCode = 404;\n                return;\n            }\n\n            var storeDoc = WolverineWebApi.Samples.UpdateEndpoint.Put(id, request, todo);\n            \n            // Placed by Wolverine's ISideEffect policy\n            storeDoc.Execute(documentSession);\n\n            \n            // Commit any outstanding Marten changes\n            await documentSession.SaveChangesAsync(httpContext.RequestAborted).ConfigureAwait(false);\n\n            // Wolverine automatically sets the status code to 204 for empty responses\n            httpContext.Response.StatusCode = 204;\n        }\n\n    }\n```\n\n----------------------------------------\n\nTITLE: Generated Wolverine Handler Code for [FromQuery] Binding (C#)\nDESCRIPTION: Shows the C# code automatically generated by Wolverine for the `QueryOrdersEndpoint.Query` method which uses `[FromQuery]` binding. This handler class (`GET_api_orders_query`) demonstrates how Wolverine implements the binding: it instantiates the `OrderQuery` object and then attempts to parse corresponding values from `httpContext.Request.Query` (e.g., 'PageSize', 'PageNumber', 'HasShipped') and assigns them to the object's properties before invoking the original user method. This code is internal and illustrates the underlying mechanism.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/querystring.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\n// <auto-generated/>\n#pragma warning disable\nusing Microsoft.AspNetCore.Routing;\nusing System;\nusing System.Linq;\nusing Wolverine.Http;\nusing Wolverine.Marten.Publishing;\nusing Wolverine.Runtime;\n\nnamespace Internal.Generated.WolverineHandlers\n{\n    // START: GET_api_orders_query\n    public class GET_api_orders_query : Wolverine.Http.HttpHandler\n    {\n        private readonly Wolverine.Http.WolverineHttpOptions _wolverineHttpOptions;\n        private readonly Wolverine.Runtime.IWolverineRuntime _wolverineRuntime;\n        private readonly Wolverine.Marten.Publishing.OutboxedSessionFactory _outboxedSessionFactory;\n\n        public GET_api_orders_query(Wolverine.Http.WolverineHttpOptions wolverineHttpOptions, Wolverine.Runtime.IWolverineRuntime wolverineRuntime, Wolverine.Marten.Publishing.OutboxedSessionFactory outboxedSessionFactory) : base(wolverineHttpOptions)\n        {\n            _wolverineHttpOptions = wolverineHttpOptions;\n            _wolverineRuntime = wolverineRuntime;\n            _outboxedSessionFactory = outboxedSessionFactory;\n        }\n\n\n\n        public override async System.Threading.Tasks.Task Handle(Microsoft.AspNetCore.Http.HttpContext httpContext)\n        {\n            var messageContext = new Wolverine.Runtime.MessageContext(_wolverineRuntime);\n            // Building the Marten session\n            await using var querySession = _outboxedSessionFactory.QuerySession(messageContext);\n            // Binding QueryString values to the argument marked with [FromQuery]\n            var orderQuery = new WolverineWebApi.Marten.OrderQuery();\n            if (int.TryParse(httpContext.Request.Query[\"PageSize\"], System.Globalization.CultureInfo.InvariantCulture, out var PageSize)) orderQuery.PageSize = PageSize;\n            if (int.TryParse(httpContext.Request.Query[\"PageNumber\"], System.Globalization.CultureInfo.InvariantCulture, out var PageNumber)) orderQuery.PageNumber = PageNumber;\n            if (bool.TryParse(httpContext.Request.Query[\"HasShipped\"], out var HasShipped)) orderQuery.HasShipped = HasShipped;\n            \n            // The actual HTTP request handler execution\n            var pagedList_response = await WolverineWebApi.Marten.QueryOrdersEndpoint.Query(orderQuery, querySession, httpContext.RequestAborted).ConfigureAwait(false);\n\n            // Writing the response body to JSON because this was the first 'return variable' in the method signature\n            await WriteJsonAsync(httpContext, pagedList_response);\n        }\n\n    }\n\n    // END: GET_api_orders_query\n    \n    \n}\n\n```\n```\n\n----------------------------------------\n\nTITLE: Wolverine Generated Code for Side Effect Execution (C#)\nDESCRIPTION: Illustrates the runtime code generated by Wolverine for the `RecordTextHandler`. This code shows how Wolverine instantiates the handler, calls its `Handle` method to get the side effect object (`outgoing1`), and then invokes the side effect's execution method (`ExecuteAsync`) with necessary dependencies like `PathSettings`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/side-effects.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n    public class RecordTextHandler597515455 : Wolverine.Runtime.Handlers.MessageHandler\n    {\n        public override System.Threading.Tasks.Task HandleAsync(Wolverine.Runtime.MessageContext context, System.Threading.CancellationToken cancellation)\n        {\n            var recordTextHandler = new CoreTests.Acceptance.RecordTextHandler();\n            var recordText = (CoreTests.Acceptance.RecordText)context.Envelope.Message;\n            var pathSettings = new CoreTests.Acceptance.PathSettings();\n            var outgoing1 = recordTextHandler.Handle(recordText);\n            \n            // Placed by Wolverine's ISideEffect policy\n            return outgoing1.ExecuteAsync(pathSettings);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Exponential Backoff with Attributes in Wolverine C#\nDESCRIPTION: This snippet demonstrates configuring exponential backoff retry logic directly on a message class using the `RetryNow` attribute in Wolverine. When a `SqlException` occurs while handling `MessageWithBackoff`, it will be retried with delays of 50ms, 100ms, and 250ms respectively.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n[RetryNow(typeof(SqlException), 50, 100, 250)]\npublic class MessageWithBackoff\n{\n    // whatever members\n}\n```\n\n----------------------------------------\n\nTITLE: Determining Aggregate Identity by Convention in Wolverine Command (C#)\nDESCRIPTION: Illustrates the conventional way Wolverine identifies the aggregate identity within a command type (using C# records). The `OrderId` property in the `MarkItemReady` record is assumed to correspond to the `Order` aggregate identity because it follows the `<AggregateTypeName>Id` naming pattern.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-sourcing.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\n// OrderId refers to the identity of the Order aggregate\npublic record MarkItemReady(Guid OrderId, string ItemName, int Version);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Wolverine Policies for Multi-Tenancy (C#)\nDESCRIPTION: This C# snippet configures basic Wolverine policies within an ASP.NET Core host. It uses `UseWolverine` to apply middleware policies, specifically enabling automatic transaction management (`AutoApplyTransactions`) and durable local queues (`UseDurableLocalQueues`) for background tasks, which are relevant in a multi-tenant setup using Marten.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n// Wolverine usage is required for WolverineFx.Http\nbuilder.Host.UseWolverine(opts =>\n{\n    // This middleware will apply to the HTTP\n    // endpoints as well\n    opts.Policies.AutoApplyTransactions();\n\n    // Setting up the outbox on all locally handled\n    // background tasks\n    opts.Policies.UseDurableLocalQueues();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing IConfigureLocalQueue on a Handler in C#\nDESCRIPTION: This code demonstrates how to implement the IConfigureLocalQueue interface on a message handler class (MultipleMessage1Handler). The static 'Configure' method is implemented to modify the LocalQueueConfiguration, in this case, making the queue execute handlers sequentially.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\npublic class MultipleMessage1Handler : IConfigureLocalQueue\n{\n    public static void Handle(MultipleMessage message)\n    {\n        \n    }\n\n    // This method is configuring the local queue that executes this\n    // handler to be strictly ordered\n    public static void Configure(LocalQueueConfiguration configuration)\n    {\n        configuration.Sequential();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Endpoint Using a Custom Middleware Attribute (C#)\nDESCRIPTION: Defines a class ClockedEndpoint with a get_clocked method decorated with [Stopwatch], showing how to use the custom StopwatchAttribute from a previous snippet. When Wolverine processes this class, it applies the StopwatchFrame middleware for logging execution time only to the targeted method. Inputs are HTTP GET requests to this endpoint, and output is a string response with added timing logic via middleware. Relies on previous implementations of StopwatchAttribute and Wolverine’s handler discovery.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ClockedEndpoint\n{\n    [Stopwatch]\n    public string get_clocked()\n    {\n        return \"how fast\";\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Assembly Scanning in C#\nDESCRIPTION: This C# code snippet demonstrates how to configure Wolverine during application startup using the `UseWolverine` extension method on `IHostBuilder`. It shows how to extend Wolverine's discovery mechanism to include specific assemblies for finding message handlers or HTTP endpoints by using `opts.Discovery.IncludeAssembly()`, passing a loaded `Assembly` object.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // This gives you the option to programmatically\n        // add other assemblies to the discovery of HTTP endpoints\n        // or message handlers\n        var assembly = Assembly.Load(\"my other assembly name that holds HTTP endpoints or handlers\");\n        opts.Discovery.IncludeAssembly(assembly);\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Starting PostgreSQL Database with Docker Compose using Bash\nDESCRIPTION: This Bash command uses Docker Compose to start the services defined in the `docker-compose.yml` file (typically including a PostgreSQL database) in detached mode (`-d`). This is a prerequisite step for running the MultiTenantedTodoWebService project when using the provided Docker setup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/MultiTenantedTodoService/MultiTenantedTodoService/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Implementing a Shorthand Transactional Handler with Marten in C#\nDESCRIPTION: This code shows a simplified message handler method that uses the `[Transactional]` attribute to leverage Wolverine's Marten transactional middleware. The handler takes a command message and an `IDocumentSession`, stores a new `Order` document using `session.Store()`, and returns an `OrderCreated` event as a cascading message. The middleware automatically handles transaction creation, `SaveChangesAsync()` calls, and outbox integration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/transactional-middleware.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n// Note that we're able to avoid doing any kind of asynchronous\n// code in this handler\n[Transactional]\npublic static OrderCreated Handle(CreateOrder command, IDocumentSession session)\n{\n    var order = new Order\n    {\n        Description = command.Description\n    };\n\n    // Register the new document with Marten\n    session.Store(order);\n\n    // Utilizing Wolverine's \"cascading messages\" functionality\n    // to have this message sent through Wolverine\n    return new OrderCreated(order.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Batched Subscription with IoC Services Using Marten and Wolverine (C#)\nDESCRIPTION: This snippet illustrates how to register a batched event subscription class that uses constructor injection by leveraging SubscribeToEventsWithServices<T>() in a custom Marten and Wolverine setup. It includes RabbitMQ for message distribution, Marten async daemon configuration, and specifies the service lifetime for the injected subscription. Required dependencies include Marten, Wolverine, RabbitMQ, and correctly configured IoC services. Inputs are service registrations and the subscription type; output is a .NET host capable of resolving services for subscriptions.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/subscriptions.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq();\n\n        // There needs to be *some* kind of subscriber for CompanyActivations\n        // for this to work at all\n        opts.PublishMessage<CompanyActivations>()\n            .ToRabbitExchange(\"activations\");\n\n        opts.Services\n            .AddMarten()\n\n            // Just pulling the connection information from\n            // the IoC container at runtime.\n            .UseNpgsqlDataSource()\n\n            .IntegrateWithWolverine()\n\n            // The Marten async daemon most be active\n            .AddAsyncDaemon(DaemonMode.HotCold)\n\n            // Register the new subscription\n            // With this alternative you can inject services into your subscription's constructor\n            // function\n            .SubscribeToEventsWithServices<CompanyTransferSubscription>(ServiceLifetime.Scoped);\n\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Marking a Wolverine Saga as Complete in C#\nDESCRIPTION: This C# code snippet shows a `Handle` method for a `CompleteOrder` message within a Wolverine Saga. Upon receiving the message, it logs the completion and calls `MarkCompleted()`. This signals to Wolverine that the saga's lifecycle is finished and its state can be deleted after the message processing concludes. It depends on `Microsoft.Extensions.Logging.ILogger` and the `MarkCompleted()` method provided by the Wolverine Saga base functionality.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sagas.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// Apply the CompleteOrder to the saga\npublic void Handle(CompleteOrder complete, ILogger<Order> logger)\n{\n    logger.LogInformation(\"Completing order {Id}\", complete.Id);\n\n    // That's it, we're done. Delete the saga state after the message is done.\n    MarkCompleted();\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Wolverine to GCP Pub/Sub Emulator (C#)\nDESCRIPTION: This code shows how to configure Wolverine to connect to a GCP Pub/Sub emulator running locally for development purposes. After calling `UsePubsub` with the project ID, the `UseEmulatorDetection` method is chained. This method attempts to detect and use the emulator, defaulting to `EmulatorDetection.EmulatorOrProduction`. This allows testing Pub/Sub integration without connecting to the actual GCP service.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/gcp-pubsub/index.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UsePubsub(\"your-project-id\")\n\n            // Tries to use GCP Pub/Sub emulator, as it defaults\n            // to EmulatorDetection.EmulatorOrProduction. But you can\n            // supply your own, like EmulatorDetection.EmulatorOnly\n            .UseEmulatorDetection();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Implementing Compound Handlers in Wolverine (C#)\nDESCRIPTION: This snippet illustrates the use of Wolverine's compound handler to separate data loading from business logic when processing a ShipOrder command. The static class defines a LoadAsync method for retrieving both Order and Customer entities before passing them to a synchronous Handle method that determines the next action. Dependencies include an IDocumentSession for data access and custom exceptions (e.g., MissingOrderException). The input is a ShipOrder command; outputs are the loaded entities and any yield-returned actions, such as MailOvernight. The code is organized for clarity, testability, and follows Wolverine's handler conventions.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic static class ShipOrderHandler\n{\n    // This would be called first\n    public static async Task<(Order, Customer)> LoadAsync(ShipOrder command, IDocumentSession session)\n    {\n        var order = await session.LoadAsync<Order>(command.OrderId);\n        if (order == null)\n        {\n            throw new MissingOrderException(command.OrderId);\n        }\n\n        var customer = await session.LoadAsync<Customer>(command.CustomerId);\n\n        return (order, customer);\n    }\n\n    // By making this method completely synchronous and having it just receive the\n    // data it needs to make determinations of what to do next, Wolverine makes this\n    // business logic easy to unit test\n    public static IEnumerable<object> Handle(ShipOrder command, Order order, Customer customer)\n    {\n        // use the command data, plus the related Order & Customer data to\n        // \"decide\" what action to take next\n\n        yield return new MailOvernight(order.Id);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Tenant Azure Service Bus Transport in Wolverine (.NET, C#)\nDESCRIPTION: This snippet configures Wolverine to support multi-tenant messaging using Azure Service Bus in a .NET application. It demonstrates adding tenants by namespace or connection string, setting tenant ID behaviors for messages, and establishing both tenant-specific and global queue/topic listeners. Dependencies include the Wolverine library and Azure Service Bus; required configuration entries are per-tenant connection strings or namespaces. Key parameters include tenant IDs, message types, queue/topic names, and the desired global or tenant-specific scope.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/multi-tenancy.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\n\nbuilder.UseWolverine(opts =>\n{\n    // One way or another, you\\'re probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\");\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString)\n\n        // This is the default, if there is no tenant id on an outgoing message,\n        // use the default broker\n        .TenantIdBehavior(TenantedIdBehavior.FallbackToDefault)\n\n        // Or tell Wolverine instead to just quietly ignore messages sent\n        // to unrecognized tenant ids\n        .TenantIdBehavior(TenantedIdBehavior.IgnoreUnknownTenants)\n\n        // Or be draconian and make Wolverine assert and throw an exception\n        // if an outgoing message does not have a tenant id\n        .TenantIdBehavior(TenantedIdBehavior.TenantIdRequired)\n\n        // Add new tenants by registering the tenant id and a separate fully qualified namespace\n        // to a different Azure Service Bus connection\n        .AddTenantByNamespace(\"one\", builder.Configuration.GetValue<string>(\"asb_ns_one\"))\n        .AddTenantByNamespace(\"two\", builder.Configuration.GetValue<string>(\"asb_ns_two\"))\n        .AddTenantByNamespace(\"three\", builder.Configuration.GetValue<string>(\"asb_ns_three\"))\n\n        // OR, instead, add tenants by registering the tenant id and a separate connection string\n        // to a different Azure Service Bus connection\n        .AddTenantByConnectionString(\"four\", builder.Configuration.GetConnectionString(\"asb_four\"))\n        .AddTenantByConnectionString(\"five\", builder.Configuration.GetConnectionString(\"asb_five\"))\n        .AddTenantByConnectionString(\"six\", builder.Configuration.GetConnectionString(\"asb_six\"));\n    \n    // This Wolverine application would be listening to a queue\n    // named \"incoming\" on all Azure Service Bus connections, including the default\n    opts.ListenToAzureServiceBusQueue(\"incoming\");\n\n    // This Wolverine application would listen to a single queue\n    // at the default connection regardless of tenant\n    opts.ListenToAzureServiceBusQueue(\"incoming_global\")\n        .GlobalListener();\n    \n    // Likewise, you can override the queue, subscription, and topic behavior\n    // to be \"global\" for all tenants with this syntax:\n    opts.PublishMessage<Message1>()\n        .ToAzureServiceBusQueue(\"message1\")\n        .GlobalSender();\n\n    opts.PublishMessage<Message2>()\n        .ToAzureServiceBusTopic(\"message2\")\n        .GlobalSender();\n});\n```\n\n----------------------------------------\n\nTITLE: Class Diagram of IMessageBus and IMessageContext Relationships (Mermaid)\nDESCRIPTION: Visualizes the relationship between the IMessageBus and IMessageContext abstractions in Wolverine using a Mermaid class diagram. IMessageContext is shown as related to IMessageBus and to an Envelope representing the current message. This diagram provides conceptual guidance for developers architecting message-based systems in Wolverine.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_0\n\nLANGUAGE: Mermaid\nCODE:\n```\nclassDiagram\\n    \\n\\nclass IMessageBus\\nclass IMessageContext\\n\\nIMessageContext ..> IMessageBus\\nIMessageContext --> Envelope : Current Message\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Chain Error Handling via Static 'Configure' Method in Wolverine - C#\nDESCRIPTION: Shows how to use a static Configure method in a handler class to set up per-message-type error handling logic using the fluent API. Within this static method, custom policies (e.g., requeueing messages on IOException for a set number of attempts) are registered against a HandlerChain argument, enforcing handler-specific exception flows. Supports fine-grained error handling for both InvoiceCreated and InvoiceApproved message types. Requires Wolverine's handler and error policy types.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/error-handling.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyErrorCausingHandler\n{\n    // This method signature is meaningful\n    public static void Configure(HandlerChain chain)\n    {\n        // Requeue on IOException for a maximum\n        // of 3 attempts\n        chain.OnException<IOException>()\n            .Requeue();\n    }\n\n    public void Handle(InvoiceCreated created)\n    {\n        // handle the invoice created message\n    }\n\n    public void Handle(InvoiceApproved approved)\n    {\n        // handle the invoice approved message\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Routing Convention with Wolverine in C#\nDESCRIPTION: This C# snippet demonstrates how to register a custom `IMessageRoutingConvention` implementation, `RouteKeyConvention`, within a Wolverine application. It uses `Host.CreateApplicationBuilder` for setup, configures RabbitMQ transport via `UseRabbitMq`, retrieves configuration values (connection string, exchange name), and then adds the custom convention using `opts.RouteWith()` within the `UseWolverine` configuration block.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/subscriptions.md#_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nvar rabbitConnectionString = builder\n    .Configuration\n    .GetConnectionString(\"rabbitmq\");\n\nbuilder.UseWolverine(opts =>\n{\n    opts.UseRabbitMq(rabbitConnectionString)\n        .AutoProvision();\n\n    var exchangeName = builder\n        .Configuration\n        .GetValue<string>(\"exchange-name\");\n\n    opts.RouteWith(new RouteKeyConvention(exchangeName));\n});\n\n// actually start the app...\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Authentication Middleware in Wolverine (C#)\nDESCRIPTION: Defines a C# middleware class `FakeAuthenticationMiddleware` with a `Before` method. This method inspects an `IAmAuthenticated` message and returns `WolverineContinue.Result()` to allow processing or `Results.Unauthorized()` (an `IResult`) to stop processing and return a 401 status code, demonstrating conditional execution in Wolverine HTTP middleware.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic class FakeAuthenticationMiddleware\n{\n    public static IResult Before(IAmAuthenticated message)\n    {\n        return message.Authenticated\n            // This tells Wolverine to just keep going\n            ? WolverineContinue.Result()\n\n            // If the IResult is not WolverineContinue, Wolverine\n            // will execute the IResult and stop processing otherwise\n            : Results.Unauthorized();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ISideEffect for Custom File Writing Side Effect (C#)\nDESCRIPTION: This C# code defines a `WriteFile` class implementing the `ISideEffect` marker interface from Wolverine. It takes a path and contents in its constructor. Wolverine automatically calls the `ExecuteAsync` method (which accepts `PathSettings` injected by Wolverine) to perform the side effect, in this case, creating the directory if needed and writing the file asynchronously using `File.WriteAllTextAsync`. This approach leverages Wolverine's standard side effect mechanism.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/return-values.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n// ISideEffect is a Wolverine marker interface\npublic class WriteFile : ISideEffect\n{\n    public string Path { get; }\n    public string Contents { get; }\n\n    public WriteFile(string path, string contents)\n    {\n        Path = path;\n        Contents = contents;\n    }\n\n    // Wolverine will call this method.\n    public Task ExecuteAsync(PathSettings settings)\n    {\n        if (!Directory.Exists(settings.Directory))\n        {\n            Directory.CreateDirectory(settings.Directory);\n        }\n\n        return File.WriteAllTextAsync(Path, Contents);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling the IssueCreated Event with Static Handler - C#\nDESCRIPTION: Defines a static IssueCreatedHandler with an async Handle method that sends an email when an IssueCreated event is published. The handler retrieves the relevant issue from IssueRepository, asynchronously constructs an email, and sends it using SmtpClient. The code illustrates static handler usage, method injection, and cascading message support in Wolverine. Dependencies: IssueRepository; expects IssueCreated event and uses MailMessage/SmtpClient (from System.Net.Mail).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/getting-started.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class IssueCreatedHandler\n{\n    public static async Task Handle(IssueCreated created, IssueRepository repository)\n    {\n        var issue = repository.Get(created.Id);\n        var message = await BuildEmailMessage(issue);\n        using var client = new SmtpClient();\n        client.Send(message);\n    }\n\n    // This is a little helper method I made public\n    // Wolverine will not expose this as a message handler\n    internal static Task<MailMessage> BuildEmailMessage(Issue issue)\n    {\n        // Build up a templated email message, with\n        // some sort of async method to look up additional\n        // data just so we can show off an async\n        // Wolverine Handler\n        return Task.FromResult(new MailMessage());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Handling PlaceOrder Command with Marten (Transaction Script) in C#\nDESCRIPTION: Defines the `PlaceOrder` command record, the `Order` entity, and an optional FluentValidation `Validator`. Implements a `PlaceOrderHandler` using a transaction script pattern, injecting Marten's `IDocumentSession` to store the new `Order`. It assumes Wolverine's transactional middleware handles `SaveChangesAsync` and Fluent Validation middleware executes the validation, hence these operations are not explicitly called within the handler.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/vertical-slice-architecture.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic record PlaceOrder(string OrderId, string CustomerId, decimal Amount);\n\npublic class Order\n{\n    public string Id { get; set; }\n    public string CustomerId { get; set; }\n    public decimal Amount { get; set; }\n\n    // Using FluentValidation library\n    public class Validator : AbstractValidator<PlaceOrder>\n    {\n        public Validator()\n        {\n            RuleFor(x => x.OrderId).ShouldNotBeNull();\n            RuleFor(x => x.CustomerId).ShouldNotBeNull();\n            RuleFor(x => x.Amount).ShouldNotBeNull();\n        }\n    }\n}\n\npublic static class PlaceOrderHandler\n{\n    // Transaction Script style\n    // I'm assuming the usage of transactional middleware\n    // to actually call IDocumentSession.SaveChangesAsync()\n    public static void Handle(\n        PlaceOrder command, \n        IDocumentSession session) // Marten's IDocumentSession\n    {\n        var order = new Order\n        {\n            Id = command.OrderId, \n            CustomerId = command.CustomerId, \n            Amount = command.Amount\n        };\n        \n        // Store the new Order document using Marten\n        session.Store(order);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping the Ponger Application with Wolverine in C#\nDESCRIPTION: Configures the Ponger service using .NET Generic Host and Wolverine, designating port 5581 for TCP message listening. This short bootstrap code is set up as an entry point for the Ponger process. Required dependencies are Microsoft.Extensions.Hosting, Oakton, Wolverine, and TCP transport. The code expects command-line arguments, initializes listening for incoming network messages, and starts the process lifecycle.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/ping-pong.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nusing Microsoft.Extensions.Hosting;\nusing Oakton;\nusing Wolverine;\nusing Wolverine.Transports.Tcp;\n\nreturn await Host.CreateDefaultBuilder(args)\n    .UseWolverine(opts =>\n    {\n        // Using Wolverine's built in TCP transport\n        opts.ListenAtPort(5581);\n    })\n    .RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Overriding Application Assembly Lookup in Wolverine (.NET, C#)\nDESCRIPTION: This configuration snippet demonstrates overriding the default application assembly Wolverine uses to discover pre-generated handler types by explicitly specifying 'opts.ApplicationAssembly'. This can resolve issues when project structure confuses assembly resolution, especially in advanced or modular setups. Dependencies include a .NET environment with Wolverine and an accessible Program-type assembly. Inputs involve the application assembly; output is correct handler code registration. Should typically not be required unless facing type discovery issues.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/codegen.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing var host = Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Override the application assembly to help\n        // Wolverine find its handlers\n        // Should not be necessary in most cases\n        opts.ApplicationAssembly = typeof(Program).Assembly;\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Appending Events from Message Handlers in Marten with Wolverine in C#\nDESCRIPTION: This handler method, HandleAsync, listens for SecondMessage events, appends a FourthEvent to the session's event stream for the associated aggregate, and commits with SaveChangesAsync. The method requires IDocumentSession injected into the handler and is intended for use as part of a message handling pipeline. Inputs are the message and a session; output is an asynchronous task representing the completion of event persistence. Used in scenarios where forwarding/transformation of events triggers new event emissions.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/event-forwarding.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic static Task HandleAsync(SecondMessage message, IDocumentSession session)\n{\n    session.Events.Append(message.AggregateId, new FourthEvent());\n    return session.SaveChangesAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom SQS Envelope Mapper in C#\nDESCRIPTION: This snippet defines a custom class `CustomSqsMapper` that implements the `ISqsEnvelopeMapper` interface. This allows for fine-grained control over how Wolverine message envelopes are mapped to and from SQS message bodies and attributes. The `BuildMessageBody` method extracts the serialized message data, `ToAttributes` maps Wolverine envelope headers (like TenantId) to SQS message attributes, and `ReadEnvelopeData` reconstructs the Wolverine envelope from the SQS message body and attributes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/interoperability.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic class CustomSqsMapper : ISqsEnvelopeMapper\n{\n    public string BuildMessageBody(Envelope envelope)\n    {\n        // Serialized data from the Wolverine message\n        return Encoding.Default.GetString(envelope.Data);\n    }\n\n    // Specify header values for the SQS message from the Wolverine envelope\n    public IEnumerable<KeyValuePair<string, MessageAttributeValue>> ToAttributes(Envelope envelope)\n    {\n        if (envelope.TenantId.IsNotEmpty())\n        {\n            yield return new KeyValuePair<string, MessageAttributeValue>(\"tenant-id\",\n                new MessageAttributeValue { StringValue = envelope.TenantId });\n        }\n    }\n\n    public void ReadEnvelopeData(Envelope envelope, string messageBody,\n        IDictionary<string, MessageAttributeValue> attributes)\n    {\n        envelope.Data = Encoding.Default.GetBytes(messageBody);\n\n        if (attributes.TryGetValue(\"tenant-id\", out var att))\n        {\n            envelope.TenantId = att.StringValue;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Pulsar Broker via Batch Script with Docker - Batch\nDESCRIPTION: This batch command is intended for Windows environments to start a local Pulsar broker instance for test purposes. It requires Docker to be installed and involves executing the 'build' script with the 'pulsar' parameter, which will initialize the Pulsar broker locally. Ensure 'build' is available in the project directory and Docker is running prior to execution.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Transports/Pulsar/Wolverine.Pulsar.Tests/README.md#_snippet_0\n\nLANGUAGE: batch\nCODE:\n```\nbuild pulsar\n```\n\n----------------------------------------\n\nTITLE: Publishing a Message Using IMessageBus - Wolverine (.NET C#)\nDESCRIPTION: This code snippet illustrates publishing a 'MyMessage' command asynchronously using the 'IMessageBus' interface in Wolverine. Dependencies: Requires an 'IMessageBus' implementation and a valid 'MyMessage' type. The function accepts an 'IMessageBus' object, publishes a new instance of 'MyMessage', and awaits completion. Input is the message bus instance; output is a completed task when the message has been dispatched.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static async Task publish_command(IMessageBus bus)\n{\n    await bus.PublishAsync(new MyMessage());\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Transactional Wolverine Message Handler with EF Core (C#)\nDESCRIPTION: This C# snippet defines a Wolverine message handler class `ItemHandler`. The static `Handle` method processes a `CreateItemCommand` message. It uses an injected `ItemsDbContext` (from EF Core) to create and add a new `Item` entity. The `[Transactional]` attribute applies Wolverine's EF Core transactional middleware, ensuring the database operation and message handling occur within a single transaction. The method returns an `ItemCreated` event object, which Wolverine will automatically publish as a cascading message upon successful completion of the handler and transaction.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/mediator.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic class ItemHandler\n{\n    // This attribute applies Wolverine's EF Core transactional\n    // middleware\n    [Transactional]\n    public static ItemCreated Handle(\n        // This would be the message\n        CreateItemCommand command,\n\n        // Any other arguments are assumed\n        // to be service dependencies\n        ItemsDbContext db)\n    {\n        // Create a new Item entity\n        var item = new Item\n        {\n            Name = command.Name\n        };\n\n        // Add the item to the current\n        // DbContext unit of work\n        db.Items.Add(item);\n\n        // This event being returned\n        // by the handler will be automatically sent\n        // out as a \"cascading\" message\n        return new ItemCreated\n        {\n            Id = item.Id\n        };\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing VSA AddToCart with MediatR and ASP.NET Core Controller in C#\nDESCRIPTION: Demonstrates the MediatR pattern for handling an 'Add to Cart' operation within a Vertical Slice Architecture. It includes the request message (`AddToCartRequest`), the handler (`AddToCartHandler`) implementing `IRequestHandler` which contains the core logic using `ICartService`, and an ASP.NET Core `CartController` that receives the request via HTTP POST and dispatches it through the `IMediator` service. This pattern separates concerns but often involves distinct request, handler, and controller classes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/from-mediatr.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic class AddToCartRequest : IRequest<Result>\n{\n    public int ProductId { get; set; }\n    public int Quantity { get; set; }\n}\n\npublic class AddToCartHandler : IRequestHandler<AddToCartRequest, Result>\n{\n    private readonly ICartService _cartService;\n\n    public AddToCartHandler(ICartService cartService)\n    {\n        _cartService = cartService;\n    }\n\n    public async Task<Result> Handle(AddToCartRequest request, CancellationToken cancellationToken)\n    {\n        // Logic to add the product to the cart using the cart service\n        bool addToCartResult = await _cartService.AddToCart(request.ProductId, request.Quantity);\n\n        bool isAddToCartSuccessful = addToCartResult; // Check if adding the product to the cart was successful.\n        return Result.SuccessIf(isAddToCartSuccessful, \"Failed to add the product to the cart.\"); // Return failure if adding to cart fails.\n    }\n    \npublic class CartController : ControllerBase\n{\n    private readonly IMediator _mediator;\n\n    public CartController(IMediator mediator)\n    {\n        _mediator = mediator;\n    }\n\n    [HttpPost]\n    public async Task<IActionResult> AddToCart([FromBody] AddToCartRequest request)\n    {\n        var result = await _mediator.Send(request);\n\n        if (result.IsSuccess)\n        {\n            return Ok(\"Product added to the cart successfully.\");\n        }\n        else\n        {\n            return BadRequest(result.ErrorMessage);\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling a Command and Cascading an Event in Wolverine (C#)\nDESCRIPTION: Demonstrates a Wolverine message handler function for a `PlaceOrder` command. Upon successful processing (details omitted), it returns a new `OrderPlaced` event object. Wolverine automatically interprets this return value as a message to be published (\"cascaded\") to any subscribers for the `OrderPlaced` type.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/modular-monolith.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\npublic static OrderPlaced Handle(PlaceOrder command)\n{\n    // actually do stuff to place a new order...\n    \n    // Returning this from the method will \"cascade\" this\n    // object as a message. Essentially just publishing\n    // this as a message to any active subscribers in the\n    // Wolverine system\n    return new OrderPlaced(command.OrderId);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Scheduling Message Delivery with Azure Service Bus in Wolverine (C#)\nDESCRIPTION: This C# snippet demonstrates how to schedule message delivery for a specific delay or a future timestamp using WolverineFx's integration with Azure Service Bus. Dependencies include a properly configured IMessageContext and message type (e.g., ValidateInvoiceIsNotLate). Key parameters are the message instance and either a TimeSpan (e.g., 30.Days()) or a DateTimeOffset (e.g., DateTimeOffset.Now.AddDays(30)) to specify schedule timing. The method is asynchronous and returns a Task, with no result other than the message being scheduled. The feature is available natively in Wolverine 1.6.0 and beyond, with no explicit setup required.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/scheduled.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic async Task SendScheduledMessage(IMessageContext bus, Guid invoiceId)\n{\n    var message = new ValidateInvoiceIsNotLate\n    {\n        InvoiceId = invoiceId\n    };\n\n    // Schedule the message to be processed in a certain amount\n    // of time\n    await bus.ScheduleAsync(message, 30.Days());\n\n    // Schedule the message to be processed at a certain time\n    await bus.ScheduleAsync(message, DateTimeOffset.Now.AddDays(30));\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Documentation Website Locally using Bash\nDESCRIPTION: This command executes the 'docs' script defined in the `package.json` file using npm. This script typically starts the Vitepress development server, allowing users to view the documentation website locally.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run docs\n```\n\n----------------------------------------\n\nTITLE: Configuring Application Launch Profile for Production - JSON\nDESCRIPTION: This JSON snippet provides a sample 'launchSettings.json' configuration to set the DOTNET_ENVIRONMENT environment variable to 'Production' for the OrderSagaSample project. This adjustment affects Wolverine's behavior—specifically, it disables system database table migration and assumes artifact code is pre-compiled. Requires .NET SDK-compatible tools and should be placed under /Properties/launchSettings.json. Key parameters include 'profiles' for project-specific launch control, and 'environmentVariables' for adjusting runtime environments. Inputs are project launch settings, and outputs are modified ASP.NET application startup behaviors.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/OptimizedArtifactWorkflowSample/README.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"profiles\": {\n    \"OrderSagaSample\": {\n      \"commandName\": \"Project\",\n      \"dotnetRunMessages\": true,\n      \"environmentVariables\": {\n        \"DOTNET_ENVIRONMENT\": \"Production\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Wolverine Endpoint with ProblemDetails Behavior (C#)\nDESCRIPTION: Provides xUnit tests using Alba for the `ProblemDetailsUsageEndpoint`. The first test, `continue_happy_path`, verifies the successful scenario where validation passes. The second test, `stop_with_problems_if_middleware_trips_off`, validates the failure scenario where the `Before` middleware returns `ProblemDetails`, asserting that the status code is 400 and the content type is `application/problem+json`. Requires xUnit and Alba.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/problemdetails.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task continue_happy_path()\n{\n    // Should be good\n    await Scenario(x =>\n    {\n        x.Post.Json(new NumberMessage(3)).ToUrl(\"/problems\");\n    });\n}\n\n[Fact]\npublic async Task stop_with_problems_if_middleware_trips_off()\n{\n    // This is the \"sad path\" that should spawn a ProblemDetails\n    // object\n    var result = await Scenario(x =>\n    {\n        x.Post.Json(new NumberMessage(10)).ToUrl(\"/problems\");\n        x.StatusCodeShouldBe(400);\n        x.ContentTypeShouldBe(\"application/problem+json\");\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Timing Middleware in Wolverine HTTP (C#)\nDESCRIPTION: Defines a `StopwatchMiddleware` class for Wolverine HTTP endpoints. It uses a `Stopwatch` instance, starting it in the `Before` method (executed before the endpoint handler) and stopping it in the `Finally` method (executed after the handler, regardless of success or failure). The `Finally` method logs the request path and duration using injected `ILogger` and `HttpContext`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\npublic class StopwatchMiddleware\n{\n    private readonly Stopwatch _stopwatch = new();\n\n    public void Before()\n    {\n        _stopwatch.Start();\n    }\n\n    public void Finally(ILogger logger, HttpContext context)\n    {\n        _stopwatch.Stop();\n        logger.LogDebug(\"Request for route {Route} ran in {Duration} milliseconds\",\n            context.Request.Path, _stopwatch.ElapsedMilliseconds);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Alternative Transactional Handler with Explicit Message Sending in C#\nDESCRIPTION: This snippet presents an alternative transactional message handler using the `[Transactional]` attribute. It explicitly injects `IMessageBus` to send the resulting `OrderCreated` message with specific `DeliveryOptions`. While still benefiting from the middleware's transaction management (`session.Store` is included in the transaction), this approach allows for finer control over how the outgoing message is dispatched.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/transactional-middleware.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n[Transactional]\npublic static ValueTask Handle(\n    CreateOrder command,\n    IDocumentSession session,\n    IMessageBus bus)\n{\n    var order = new Order\n    {\n        Description = command.Description\n    };\n\n    // Register the new document with Marten\n    session.Store(order);\n\n    // Utilizing Wolverine's \"cascading messages\" functionality\n    // to have this message sent through Wolverine\n    return bus.SendAsync(\n        new OrderCreated(order.Id),\n        new DeliveryOptions { DeliverWithin = 5.Minutes() });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Optimized Artifact Workflow with Wolverine in C#\nDESCRIPTION: This C# snippet demonstrates initializing a .NET Generic Host using Wolverine and applying an environment-aware optimization for the artifact workflow. The code uses the Host.CreateDefaultBuilder() to set up the host, then uses the UseWolverine() extension method to configure the Wolverine options. The key method, opts.OptimizeArtifactWorkflow(), sets artifact generation to 'Auto' mode in 'Development' environments—enabling code regeneration and updates—and 'Static' mode elsewhere for faster cold starts. Dependencies include JasperFx.Wolverine and Microsoft.Extensions.Hosting packages. Inputs are .NET environment variables; output is a configured and running IHost. Limitations: Assumes proper NuGet dependencies and typical environment variable setup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/codegen.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Use \"Auto\" type load mode at development time, but\n        // \"Static\" any other time\n        opts.OptimizeArtifactWorkflow();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining a Tenant Message Interface for MQTT Routing (C#)\nDESCRIPTION: Defines a simple C# interface `ITenantMessage` with a single string property `TenantId`. This interface acts as a marker and contract for message types that should be routed based on tenant information when using custom MQTT topic publishing rules.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic interface ITenantMessage\n{\n    string TenantId { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Build Script for Test Samples on Windows - Bash\nDESCRIPTION: This command is intended for Windows systems and runs the 'build' script with 'test-samples' as an argument to prepare the environment and execute tests for the BankingService project. Requires a compatible build environment set up on Windows. This facilitates a cross-platform workflow for setting up and running tests.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/TestHarness/BankingService/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbuild test-samples\n\n```\n\n----------------------------------------\n\nTITLE: Auto-Purging All RabbitMQ Queues with Wolverine in C#\nDESCRIPTION: Demonstrates configuring Wolverine to purge all managed RabbitMQ queues upon application startup. This is achieved by calling the `AutoPurgeOnStartup()` extension method after `UseRabbitMq()`. This is useful in development or scenarios where ensuring a clean slate at startup is necessary.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/object-management.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseRabbitMq()\n            .AutoPurgeOnStartup();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Compose for Wolverine.Http Testing - Bash\nDESCRIPTION: This snippet starts the required Docker Compose environment for running integration tests against the Wolverine.Http endpoint using Alba. It assumes Docker and docker-compose are installed, and that the compose file is located at the project root. Running the command will start containers in detached mode necessary for the tests.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/TestHarness/BankingService/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n\n```\n\n----------------------------------------\n\nTITLE: Updating Documentation Code Snippets using Bash\nDESCRIPTION: This command executes the 'mdsnippets' script defined in the `package.json` file using npm. This script likely runs the MarkdownSnippets tool to update the code samples embedded within the project's Markdown documentation files.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run mdsnippets\n```\n\n----------------------------------------\n\nTITLE: Configuring Pulsar Connection and Endpoints in Wolverine (C#)\nDESCRIPTION: Demonstrates configuring Wolverine within a .NET Host application builder to use Apache Pulsar. It shows setting the Pulsar service URL, configuring a message publisher for `Message1` to a specific topic, and setting up a listener for another topic with subscription details like name and type. It also illustrates applying standard Wolverine endpoint options like `SendInline()` and `Sequential()`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/pulsar.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    opts.UsePulsar(c =>\n    {\n        var pulsarUri = builder.Configuration.GetValue<Uri>(\"pulsar\");\n        c.ServiceUrl(pulsarUri);\n        \n        // Any other configuration you want to apply to your\n        // Pulsar client\n    });\n\n    // Publish messages to a particular Pulsar topic\n    opts.PublishMessage<Message1>()\n        .ToPulsarTopic(\"persistent://public/default/one\")\n        \n        // And all the normal Wolverine options...\n        .SendInline();\n\n    // Listen for incoming messages from a Pulsar topic\n    opts.ListenToPulsarTopic(\"persistent://public/default/two\")\n        .SubscriptionName(\"two\")\n        .SubscriptionType(SubscriptionType.Exclusive)\n        \n        // And all the normal Wolverine options...\n        .Sequential();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Marten Multi-Tenancy with Wolverine Integration (C#)\nDESCRIPTION: This C# code configures Marten for multi-tenancy using a separate database per tenant within an ASP.NET Core application. It uses `AddMarten` and `MultiTenantedDatabases` to define tenant-specific connection strings. The `.IntegrateWithWolverine()` method links Marten's multi-tenancy with Wolverine, specifying the master database connection string.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n// Adding Marten for persistence\nbuilder.Services.AddMarten(m =>\n    {\n        // With multi-tenancy through a database per tenant\n        m.MultiTenantedDatabases(tenancy =>\n        {\n            // You would probably be pulling the connection strings out of configuration,\n            // but it's late in the afternoon and I'm being lazy building out this sample!\n            tenancy.AddSingleTenantDatabase(\"Host=localhost;Port=5433;Database=tenant1;Username=postgres;password=postgres\", \"tenant1\");\n            tenancy.AddSingleTenantDatabase(\"Host=localhost;Port=5433;Database=tenant2;Username=postgres;password=postgres\", \"tenant2\");\n            tenancy.AddSingleTenantDatabase(\"Host=localhost;Port=5433;Database=tenant3;Username=postgres;password=postgres\", \"tenant3\");\n        });\n\n        m.DatabaseSchemaName = \"mttodo\";\n    })\n    .IntegrateWithWolverine(x => x.MasterDatabaseConnectionString = connectionString);\n```\n\n----------------------------------------\n\nTITLE: CreditAccount Handler Expecting Injected Account - C#\nDESCRIPTION: Demonstrates a message handler for CreditAccount that relies on middleware to inject the Account instance, avoiding manual lookups. This handler increases the account balance and stores the updated state, using Marten's IDocumentSession for persistence. Assumes Account instance is valid and provided by preceding middleware, simplifying testing and handler implementation. Requires session for database update.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/middleware.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class CreditAccountHandler\n{\n    public static void Handle(\n        CreditAccount command,\n\n        // Wouldn't it be nice to just have Wolverine \"push\"\n        // the right account into this method?\n        Account account,\n\n        // Using Marten for persistence here\n        IDocumentSession session)\n    {\n        account.Balance += command.Amount;\n\n        // Just mark this account as needing to be updated\n        // in the database\n        session.Store(account);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Conventional Amazon SQS Routing with Wolverine (C#)\nDESCRIPTION: This snippet shows how to initialize a .NET host using Wolverine, configure the Amazon SQS transport, and apply conventional routing so that outgoing messages not handled locally or subscribed elsewhere are routed to SQS queues named after their message type. Requires the Wolverine and AWS SDK dependencies. The key parameters are the options for the SQS transport and routing behavior, and the output is a running host instance with automatic conventional message routing to SQS. This pattern assumes proper AWS credentials and permissions are configured.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/conventional-routing.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAmazonSqsTransport()\n            .UseConventionalRouting();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Sending Messages via IMessageContext in Wolverine (C#)\nDESCRIPTION: This code demonstrates publishing a PingMessage using the IMessageContext interface with an asynchronous call to SendAsync. Dependency: IMessageContext is assumed to be supplied by Wolverine's dependency injection. Input: An instance of IMessageContext; Output: The PingMessage is sent according to configured routing. A key requirement is that routing for PingMessage must be configured or handled conventionally; SendAsync returns a Task for async handling.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/subscriptions.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SendingExample\n{\n    public async Task SendPingsAndPongs(IMessageContext bus)\n    {\n        // Publish a message\n        await bus.SendAsync(new PingMessage());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Oakton Command Line Parsing in C#\nDESCRIPTION: Shows how to enable Oakton command-line parsing in a .NET application, typically at the end of the `Program.cs` file, by calling `app.RunOaktonCommands(args)`. This integration provides access to various management commands for Wolverine and other configured resources via the command line.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// Opt into using Oakton for command parsing\nawait app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Illustrating Wolverine Storage Action Workflow with Mermaid\nDESCRIPTION: This Mermaid sequence diagram illustrates the runtime flow when a Wolverine message handler returns a storage action side effect. It shows the handler returning the action, which Wolverine then relays to the appropriate persistence mechanism (e.g., `EfCoreStorageActionApplier` for Entity Framework Core), ultimately leading to the changes being saved via `SaveChangesAsync()` on the `DbContext`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/side-effects.md#_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n   note right of MessageHandler: MessageHandler is generated by Wolverine\n   MessageHandler->>CreateItemHandler:Handle()\n   CreateItemHandler-->>MessageHandler: storage action side effect\n   note left of EfCoreStorageActionApplier: This is Wolverine relaying the side effect to the DbContext\n   MessageHandler->>EfCoreStorageActionApplier:Apply(ItemDbContext, storage action side effect)\n   MessageHandler->>ItemDbContext:SaveChangesAsync()\n```\n\n----------------------------------------\n\nTITLE: Adding WolverineFx.SqlServer NuGet Package (Bash)\nDESCRIPTION: Demonstrates the command to add the necessary `WolverineFx.SqlServer` NuGet package dependency to a .NET project using the dotnet CLI. This package enables SQL Server integration for persistence and transport within Wolverine applications.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sqlserver.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n```bash\ndotnet add package WolverineFx.SqlServer\n```\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting Wolverine Handler Discovery Programmatically in C#\nDESCRIPTION: This C# snippet demonstrates how to use the `DescribeHandlerMatch` method within Wolverine's configuration (`UseWolverine`) to obtain a diagnostic report for a specific potential handler type (`MyMissingMessageHandler`). This is useful during development to understand why Wolverine might not be discovering or applying conventions to a particular handler class and its methods as expected. The output explains the matching process and potential issues.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/diagnostics.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Surely plenty of other configuration for Wolverine...\n\n        // This *temporary* line of code will write out a full report about why or\n        // why not Wolverine is finding this handler and its candidate handler messages\n        Console.WriteLine(opts.DescribeHandlerMatch(typeof(MyMissingMessageHandler)));\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Using ProblemDetails Validation in Wolverine Message Handlers (C#)\nDESCRIPTION: Illustrates how to use `ProblemDetails` for validation within Wolverine message handlers (available since Wolverine 3.0). A static `Validate` method performs the validation logic for `NumberMessage`, returning `ProblemDetails` on failure or `WolverineContinue.NoProblems` on success. The `Handle` method acts as the message handler and is also decorated with `[WolverinePost]` to serve as an HTTP endpoint, reusing the validation logic. Requires Wolverine.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/problemdetails.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\npublic static ProblemDetails Validate(NumberMessage message)\n{\n    if (message.Number > 5)\n    {\n        return new ProblemDetails\n        {\n            Detail = \"Number is bigger than 5\",\n            Status = 400\n        };\n    }\n    \n    // All good, keep on going!\n    return WolverineContinue.NoProblems;\n}\n\n// Look at this! You can use this as an HTTP endpoint too!\n[WolverinePost(\"/problems2\")]\npublic static void Handle(NumberMessage message)\n{\n    Debug.WriteLine(\"Handled \" + message);\n    Handled = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing WolverineFx.HTTP Endpoint with Alba (C#)\nDESCRIPTION: Demonstrates an integration test for the 'Hello, World' endpoint using the Alba testing framework. The test sends a GET request to the root URL (\"/\") and asserts that the response content type is \"text/plain\" and the response body is \"Hello.\". Requires an `IAlbaHost` instance (`_host`) configured for the application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\n[Fact]\npublic async Task hello_world()\n{\n    var result = await _host.Scenario(x =>\n    {\n        x.Get.Url(\"/\");\n        x.Header(\"content-type\").SingleValueShouldEqual(\"text/plain\");\n    });\n\n    result.ReadAsText().ShouldBe(\"Hello.\");\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Conventional Listener Configuration for Azure Service Bus with Wolverine (C#)\nDESCRIPTION: This code example shows how to apply conventional configuration across all Azure Service Bus listeners in a Wolverine-enabled .NET application. It programmatically retrieves the connection string and uses 'ConfigureListeners' to set a default durable inbox with custom buffering limits for all listeners. Specific endpoint settings can override these defaults. Main dependencies include Wolverine, a valid Azure Service Bus namespace, and a proper app configuration containing the connection string. This approach is useful when managing multiple queues efficiently.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/listening.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // One way or another, you're probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\");\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString).AutoProvision()\n        // Apply default configuration to all Azure Service Bus listeners\n        // This can be overridden explicitly by any configuration for specific\n        // listening endpoints\n        .ConfigureListeners(listener => { listener.UseDurableInbox(new BufferingLimits(500, 100)); });\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Registering Wolverine.Http Services in .NET Application Startup\nDESCRIPTION: Registers necessary Wolverine.Http services with the .NET dependency injection container (`IServiceCollection`). This extension method call is required during application bootstrapping (e.g., in `Program.cs`) when using Wolverine.Http version 3.0 or later to enable its web service features. Failure to include this registration will result in a runtime exception upon application startup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/index.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nIServiceCollection.AddWolverineHttp()\n```\n\n----------------------------------------\n\nTITLE: Writing Wolverine Generated Code to Disk via Command Line using Bash\nDESCRIPTION: This Bash command leverages Oakton to instruct Wolverine to generate and write the source code for its message handlers and potentially HTTP endpoints to the filesystem. Executing `dotnet run -- codegen write` saves the generated C# files, typically within an `Internal/Generated/WolverineHandlers` folder, allowing developers to inspect the runtime code, middleware application, and conventions.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/diagnostics.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- codegen write\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Envelope Mapper for GCP Pub/Sub in Wolverine (.NET/C#)\nDESCRIPTION: Defines a CustomPubsubMapper class by extending EnvelopeMapper and implementing IPubsubEnvelopeMapper to control how incoming and outgoing messages are mapped between Wolverine envelopes and GCP Pub/Sub messages. Dependencies include PubsubEndpoint for context, and requires definitions for types such as ReceivedMessage, PubsubMessage, Message1, PubsubEnvelope, and OutgoingMessageBatch. Key parameters involve handling acknowledgement IDs, message type discovery, binary data transfer, and attribute (header) synchronization. Inputs are Pub/Sub message types and envelope structures; output ensures message mapping works for both sending and receiving. Type safety and header mapping are crucial; users must ensure correct type handling and mapping logic.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/gcp-pubsub/interoperability.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class CustomPubsubMapper : EnvelopeMapper<ReceivedMessage, PubsubMessage>, IPubsubEnvelopeMapper\n{\n    public CustomPubsubMapper(PubsubEndpoint endpoint) : base(endpoint)\n    {\n    }\n\n    public void MapIncomingToEnvelope(PubsubEnvelope envelope, ReceivedMessage incoming)\n    {\n        envelope.AckId = incoming.AckId;\n\n        // You will have to help Wolverine out by either telling Wolverine\n        // what the message type is, or by reading the actual message object,\n        // or by telling Wolverine separately what the default message type\n        // is for a listening endpoint\n        envelope.MessageType = typeof(Message1).ToMessageTypeName();\n    }\n\n    public void MapOutgoingToMessage(OutgoingMessageBatch outgoing, PubsubMessage message)\n    {\n        message.Data = ByteString.CopyFrom(outgoing.Data);\n    }\n\n    protected override void writeOutgoingHeader(PubsubMessage outgoing, string key, string value)\n    {\n        outgoing.Attributes[key] = value;\n    }\n\n    protected override void writeIncomingHeaders(ReceivedMessage incoming, Envelope envelope)\n    {\n        if (incoming.Message.Attributes is null)\n        {\n            return;\n        }\n\n        foreach (var pair in incoming.Message.Attributes) envelope.Headers[pair.Key] = pair.Value;\n    }\n\n    protected override bool tryReadIncomingHeader(ReceivedMessage incoming, string key, out string? value)\n    {\n        if (incoming.Message.Attributes.TryGetValue(key, out var header))\n        {\n            value = header;\n\n            return true;\n        }\n\n        value = null;\n\n        return false;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Continuing HTTP Handler Pipeline Using IResult and Entity Presence in Wolverine (.NET C#)\nDESCRIPTION: Illustrates the use of an HTTP handler precondition in Wolverine with ASP.NET Core, leveraging IResult for flow control. Dependencies include ASP.NET Core's IResult, Results, Wolverine's route/HTTP attributes, and possible entity binding via custom [Entity] attributes. The Before method checks for the presence of a Todo2 entity: if present, WolverineContinue.Result() continues processing; otherwise, Results.Empty halts execution. The Handle method marks that continuation logic has been executed. Inputs are command objects and hydrated entity instances, outputs are side effects or early HTTP responses. This allows precise request gating based on preconditions with minimal code.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/railway-programming.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class ExamineFirstHandler\n{\n    public static bool DidContinue { get; set; }\n    \n    public static IResult Before([Entity] Todo2 todo)\n    {\n        return todo != null ? WolverineContinue.Result() : Results.Empty;\n    }\n\n    [WolverinePost(\"/api/todo/examinefirst\")]\n    public static void Handle(ExamineFirst command) => DidContinue = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Primary and Named Secondary RabbitMQ Brokers in Wolverine (C#)\nDESCRIPTION: This C# code snippet configures a Wolverine application within a .NET Host. It sets up a default RabbitMQ broker using `UseRabbitMq` and adds a secondary, named broker (\"external\") using `AddNamedRabbitMqBroker`. It demonstrates configuring listeners and various publishing strategies (to exchanges, queues, specific routing keys, and topics) for both the default and the named secondary broker, retrieving connection strings from application configuration. Requires Wolverine, Wolverine.RabbitMQ, Microsoft.Extensions.Hosting, and Microsoft.Extensions.Configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/multiple-brokers.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // Connect to the \"main\" Rabbit MQ broker for this application\n    opts.UseRabbitMq(builder.Configuration.GetConnectionString(\"internal-rabbit-mq\"));\n\n    // Listen for incoming messages on the main broker at the queue named \"incoming\"\n    opts.ListenToRabbitQueue(\"incoming\");\n\n    // Let's say there's one Rabbit MQ broker for internal communications\n    // and a second one for external communications\n    var external = new BrokerName(\"external\");\n\n    // BUT! Let's also use a second broker\n    opts.AddNamedRabbitMqBroker(external, factory =>\n    {\n        factory.Uri = new Uri(builder.Configuration.GetConnectionString(\"external-rabbit-mq\"));\n    });\n\n    // Listen to a queue on the named, secondary broker\n    opts.ListenToRabbitQueueOnNamedBroker(external, \"incoming\");\n    \n    // Other options for publishing messages to the named broker\n    opts.PublishAllMessages().ToRabbitExchangeOnNamedBroker(external, \"exchange1\");\n\n    opts.PublishAllMessages().ToRabbitQueueOnNamedBroker(external, \"outgoing\");\n\n    opts.PublishAllMessages().ToRabbitRoutingKeyOnNamedBroker(external, \"exchange1\", \"key2\");\n\n    opts.PublishAllMessages().ToRabbitTopicsOnNamedBroker(external, \"topics\");\n});\n```\n\n----------------------------------------\n\nTITLE: Running the .NET Wolverine Sample Application\nDESCRIPTION: This shell command uses the .NET CLI to build and run the sample application project located in the current directory. It assumes the necessary .NET SDK is installed and the project dependencies (like Wolverine and Marten) are correctly configured.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/CommandBus/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run\n```\n\n----------------------------------------\n\nTITLE: Enabling Marten Compiled Query Policy in Wolverine HTTP C#\nDESCRIPTION: Demonstrates how to configure Wolverine HTTP options within the application setup (likely `Program.cs`). The `opts.UseMartenCompiledQueryResultPolicy()` extension method registers a policy that enables Wolverine to handle Marten compiled query results efficiently, streaming them directly to the client.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/marten.md#_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nopts.UseMartenCompiledQueryResultPolicy();\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Azure Service Bus Mapper in C#\nDESCRIPTION: Defines a custom class `CustomAzureServiceBusMapper` that implements the `IAzureServiceBusEnvelopeMapper` interface. This mapper customizes how Wolverine `Envelope` objects are mapped to outgoing Azure Service Bus `ServiceBusMessage` objects and how incoming `ServiceBusReceivedMessage` objects are mapped back to Wolverine `Envelope` objects, facilitating interoperability with non-Wolverine systems. It maps the body data and `DeliverWithin` property for outgoing messages and extracts the body for incoming messages, requiring manual specification of the `MessageType` for incoming envelopes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/interoperability.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic class CustomAzureServiceBusMapper : IAzureServiceBusEnvelopeMapper\n{\n    public void MapEnvelopeToOutgoing(Envelope envelope, ServiceBusMessage outgoing)\n    {\n        outgoing.Body = new BinaryData(envelope.Data);\n        if (envelope.DeliverWithin != null)\n        {\n            outgoing.TimeToLive = envelope.DeliverWithin.Value;\n        }\n    }\n\n    public void MapIncomingToEnvelope(Envelope envelope, ServiceBusReceivedMessage incoming)\n    {\n        envelope.Data = incoming.Body.ToArray();\n\n        // You will have to help Wolverine out by either telling Wolverine\n        // what the message type is, or by reading the actual message object,\n        // or by telling Wolverine separately what the default message type\n        // is for a listening endpoint\n        envelope.MessageType = typeof(Message1).ToMessageTypeName();\n    }\n\n    public IEnumerable<string> AllHeaders()\n    {\n        yield break;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Dead Letter REST API Endpoints in ASP.NET Core (C#)\nDESCRIPTION: Registers the Wolverine Dead Letters REST API endpoints within an ASP.NET Core application using the `MapDeadLettersEndpoints()` extension method on the `WebApplication` instance. This enables HTTP-based management of dead letters and allows further configuration like authorization.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/dead-letter-storage.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\napp.MapDeadLettersEndpoints()\n\n    // It's a Minimal API endpoint group,\n    // so you can add whatever authorization\n    // or OpenAPI metadata configuration you need\n    // for just these endpoints\n    //.RequireAuthorization(\"Admin\")\n\n    ;\n```\n\n----------------------------------------\n\nTITLE: Defining Static Wolverine TCP Publishing Rules (C#)\nDESCRIPTION: This C# snippet showcases various methods for defining static publishing rules in Wolverine for the TCP transport. It demonstrates routing specific message types (`opts.PublishMessage<PingMessage>().ToServerAndPort()`), all messages (`opts.PublishAllMessages().ToPort()`), messages from specific assemblies (`opts.Publish().MessagesFromAssembly().ToPort()`), and using complex, criteria-based rules involving message types, interfaces, assemblies, and namespaces to target specific TCP ports (`opts.Publish(rule => ...)`).\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/tcp.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Route a single message type\n        opts.PublishMessage<PingMessage>()\n            .ToServerAndPort(\"server\", 1111);\n\n        // Send every possible message to a TCP listener\n        // on this box at port 2222\n        opts.PublishAllMessages().ToPort(2222);\n\n        // Or use a more fluent interface style\n        opts.Publish().MessagesFromAssembly(typeof(PingMessage).Assembly)\n            .ToPort(3333);\n\n        // Complicated rules, I don't think folks will use this much\n        opts.Publish(rule =>\n        {\n            // Apply as many message matching\n            // rules as you need\n\n            // Specific message types\n            rule.Message<PingMessage>();\n            rule.Message<Message1>();\n\n            // Implementing a specific marker interface or common base class\n            rule.MessagesImplementing<IEventMarker>();\n\n            // All types in a certain assembly\n            rule.MessagesFromAssemblyContaining<PingMessage>();\n\n            // or this\n            rule.MessagesFromAssembly(typeof(PingMessage).Assembly);\n\n            // or by namespace\n            rule.MessagesFromNamespace(\"MyMessageLibrary\");\n            rule.MessagesFromNamespaceContaining<PingMessage>();\n\n            // Express the subscribers\n            rule.ToPort(1111);\n            rule.ToPort(2222);\n        });\n\n        // Or you just send all messages to a certain endpoint\n        opts.PublishAllMessages().ToPort(3333);\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining the IMessageRoute Interface for Wolverine Routing in C#\nDESCRIPTION: This C# interface, `IMessageRoute`, defines the contract for routing a single outgoing message to a specific subscriber. It encapsulates rules for destination, delivery options, and potentially dynamic topic determination. The `CreateForSending` method is responsible for generating the `Envelope` object required for dispatching the message.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/subscriptions.md#_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n/// Contains all the rules for where and how an outgoing message\n/// should be sent to a single subscriber\n/// </summary>\npublic interface IMessageRoute\n{\n    Envelope CreateForSending(object message, DeliveryOptions? options, ISendingAgent localDurableQueue,\n        WolverineRuntime runtime, string? topicName);\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling Message Publishing at Absolute Time using Wolverine (.NET/C#)\nDESCRIPTION: Illustrates how to schedule a message for delivery at a specific date and time using ScheduleAsync and DateTime on IMessageContext. Dependencies: Wolverine, IMessageContext, custom message types (WarnIfIssueIsStale). Inputs: a message context and a GUID. Outputs: message is scheduled for execution at 5PM the next day, and Wolverine will internally convert to UTC for consistency. Useful where precise timed delivery is required; the snippet assumes access to extension methods like AddDays and AddHours.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic async Task schedule_send_at_5_tomorrow_afternoon(IMessageContext context, Guid issueId)\n{\n    var timeout = new WarnIfIssueIsStale\n    {\n        IssueId = issueId\n    };\n\n    var time = DateTime.Today.AddDays(1).AddHours(17);\n\n    // Process the issue timeout at 5PM tomorrow\n    // Do note that Wolverine quietly converts this\n    // to universal time in storage\n    await context.ScheduleAsync(timeout, time);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Envelope Mapper for Azure Service Bus Endpoints in C#\nDESCRIPTION: Demonstrates how to configure Wolverine within a .NET Host to use a custom `IAzureServiceBusEnvelopeMapper` implementation (`CustomAzureServiceBusMapper`). It applies the custom mapper to both listeners and senders configured for Azure Service Bus using the `ConfigureListeners` and `ConfigureSenders` methods along with the `InteropWith()` extension method. This is necessary when needing customized message mapping for interoperability scenarios.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/interoperability.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAzureServiceBus(\"some connection string\")\n            .UseConventionalRouting()\n\n            .ConfigureListeners(l => l.InteropWith(new CustomAzureServiceBusMapper()))\n\n            .ConfigureSenders(s => s.InteropWith(new CustomAzureServiceBusMapper()));\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom IHttpPolicy Interface in Wolverine (C#)\nDESCRIPTION: This snippet defines the IHttpPolicy interface, enabling users to apply custom conventions or policies to HTTP endpoint handlers within Wolverine. It requires implementation of the Apply method, which receives collections of HttpChain, GenerationRules, and IServiceContainer, enabling full access to all chains and configuration rules at application's bootstrap time. Inputs include chains to modify, the rules used for handler generation, and the application IoC container. Outputs are side effects on endpoint configuration; there are no explicit return values. The interface must be implemented and registered for it to take effect.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/policies.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n/// <summary>\\n///     Use to apply your own conventions or policies to HTTP endpoint handlers\\n/// </summary>\\npublic interface IHttpPolicy\\n{\\n    /// <summary>\\n    ///     Called during bootstrapping to alter how the message handlers are configured\\n    /// </summary>\\n    /// <param name=\\\"chains\\\"></param>\\n    /// <param name=\\\"rules\\\"></param>\\n    /// <param name=\\\"container\\\">The application's underlying IoC Container</param>\\n    void Apply(IReadOnlyList<HttpChain> chains, GenerationRules rules, IServiceContainer container);\\n}\n```\n\n----------------------------------------\n\nTITLE: Running End-to-End Integration Tests with Tracked Sessions - Wolverine - C#\nDESCRIPTION: Demonstrates how to use Wolverine's InvokeMessageAndWaitAsync method to reliably execute and test both a command and any subsequently published domain events in integration tests. This snippet presumes a configured IHost instance, along with the PlaceOrder and OrderPlaced message types. Inputs include an IHost and a PlaceOrder command, while the output is a tracked session enabling you to assert the effects of all message handling completed by the system. There are no explicit dependencies outside of Wolverine and the project-defined message types.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/modular-monolith.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// Personally, I prefer to reuse the IHost between tests and\n// do something to clear off any dirty state, but other folks\n// will spin up an IHost per test to maybe get better test parallelization\npublic static async Task run_end_to_end(IHost host)\n{\n    var placeOrder = new PlaceOrder(\"111\", \"222\", 1000);\n    \n    // This would be the \"act\" part of your arrange/act/assert\n    // test structure\n    var tracked = await host.InvokeMessageAndWaitAsync(placeOrder);\n    \n    // proceed to test the outcome of handling the original command *and*\n    // any subsequent domain events that are published from the original\n    // command handler\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Program.cs for Minimal Web API with Wolverine - C#\nDESCRIPTION: This Program.cs file configures a minimal ASP.NET Core Web API, integrates Wolverine as a mediator, adds Swashbuckle for API docs, and registers singleton repositories. It maps two POST endpoints that delegate commands to Wolverine for processing, and configures Oakton for command line diagnostics. Requires .NET 6+, Wolverine, Oakton, and Swashbuckle packages; endpoints accept command objects and return async operation results.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/getting-started.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nusing Oakton;\nusing Quickstart;\nusing Wolverine;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// The almost inevitable inclusion of Swashbuckle:)\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\n// For now, this is enough to integrate Wolverine into\n// your application, but there'll be *many* more\n// options later of course :-)\nbuilder.Host.UseWolverine();\n\n// Some in memory services for our application, the\n// only thing that matters for now is that these are\n// systems built by the application's IoC container\nbuilder.Services.AddSingleton<UserRepository>();\nbuilder.Services.AddSingleton<IssueRepository>();\n\nvar app = builder.Build();\n\n// An endpoint to create a new issue that delegates to Wolverine as a mediator\napp.MapPost(\"/issues/create\", (CreateIssue body, IMessageBus bus) => bus.InvokeAsync(body));\n\n// An endpoint to assign an issue to an existing user that delegates to Wolverine as a mediator\napp.MapPost(\"/issues/assign\", (AssignIssue body, IMessageBus bus) => bus.InvokeAsync(body));\n\n// Swashbuckle inclusion\napp.UseSwagger();\napp.UseSwaggerUI();\n\napp.MapGet(\"/\", () => Results.Redirect(\"/swagger\"));\n\n// Opt into using Oakton for command line parsing\n// to unlock built in diagnostics and utility tools within\n// your Wolverine application\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Sending a Tenant-Scoped Message via IMessageBus in Wolverine (C#)\nDESCRIPTION: This code sample illustrates how to asynchronously publish a message tagged to a specific tenant using Wolverine's IMessageBus in a .NET application. It leverages the DeliveryOptions object to assign the tenant ID, ensuring the message is routed to the correct tenant-specific RabbitMQ connection. Dependencies include an implementation of IMessageBus and proper multi-tenancy configuration as previously shown; parameters are the message to be published and the desired tenant ID. The output is an asynchronous task representing completion of message dispatch; messages without a valid tenant ID will follow fallback, ignore, or error handling as configured.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/multi-tenancy.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic static async Task send_message_to_specific_tenant(IMessageBus bus)\n{\n    // Send a message tagged to a specific tenant id\n    await bus.PublishAsync(new Message1(), new DeliveryOptions { TenantId = \"two\" });\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Wolverine Control Queues with Azure Service Bus in C#\nDESCRIPTION: This snippet shows how to configure Wolverine to utilize Azure Service Bus for its internal control queues. By calling `.EnableWolverineControlQueues()` after `opts.UseAzureServiceBus()`, Wolverine will use temporary Azure Service Bus queues for node communication, leader election, and background worker distribution. This is more efficient than the default database control queues and necessary for message stores like RavenDB that lack built-in control queue mechanisms.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/index.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    // One way or another, you're probably pulling the Azure Service Bus\n    // connection string out of configuration\n    var azureServiceBusConnectionString = builder\n        .Configuration\n        .GetConnectionString(\"azure-service-bus\")!;\n\n    // Connect to the broker in the simplest possible way\n    opts.UseAzureServiceBus(azureServiceBusConnectionString)\n        .AutoProvision()\n        \n        // This enables Wolverine to use temporary Azure Service Bus\n        // queues created at runtime for communication between\n        // Wolverine nodes\n        .EnableWolverineControlQueues();\n\n});\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping ASP.Net Core with WolverineFx.HTTP and Marten (C#)\nDESCRIPTION: Demonstrates the `Program.cs` setup for an ASP.Net Core application integrating WolverineFx.HTTP, Marten persistence, and Oakton command execution. It configures Marten, integrates it with Wolverine, enables Wolverine with transactional and durable queue policies, adds Swagger/OpenAPI support, registers Wolverine HTTP services, and maps Wolverine endpoints in the request pipeline. Dependencies include Marten, Oakton, Wolverine, Wolverine.Http, and Wolverine.Marten.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nusing Marten;\nusing Oakton;\nusing Oakton.Resources;\nusing Wolverine;\nusing Wolverine.Http;\nusing Wolverine.Marten;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Adding Marten for persistence\nbuilder.Services.AddMarten(opts =>\n    {\n        opts.Connection(builder.Configuration.GetConnectionString(\"Marten\"));\n        opts.DatabaseSchemaName = \"todo\";\n    })\n    .IntegrateWithWolverine();\n\nbuilder.Services.AddResourceSetupOnStartup();\n\n// Wolverine usage is required for WolverineFx.Http\nbuilder.Host.UseWolverine(opts =>\n{\n    // This middleware will apply to the HTTP\n    // endpoints as well\n    opts.Policies.AutoApplyTransactions();\n\n    // Setting up the outbox on all locally handled\n    // background tasks\n    opts.Policies.UseDurableLocalQueues();\n});\n\n// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nbuilder.Services.AddWolverineHttp();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\n// Let's add in Wolverine HTTP endpoints to the routing tree\napp.MapWolverineEndpoints();\n\nreturn await app.RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Installing Wolverine MQTT NuGet Package (Bash)\nDESCRIPTION: Shows the command to add the necessary `WolverineFx.Mqtt` NuGet package to a .NET project using the dotnet CLI. This package enables MQTT transport capabilities within Wolverine and uses the MQTTnet library internally.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/mqtt.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add WolverineFx.Mqtt\n```\n\n----------------------------------------\n\nTITLE: Describing Wolverine Application Configuration via Command Line using Bash\nDESCRIPTION: This Bash command utilizes the Oakton integration within a .NET project to generate a detailed textual report about the Wolverine application. Running `dotnet run -- describe` will output information about discovered message handlers, messaging endpoints, configured middleware, and error handling rules, aiding in understanding the application's setup. Requires the project to be configured with Oakton as shown in the `Program.cs` example.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/diagnostics.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- describe\n```\n\n----------------------------------------\n\nTITLE: Disabling All Native SQS Dead Letter Queues in Wolverine (C#)\nDESCRIPTION: This C# code snippet illustrates how to globally disable Wolverine's use of native Amazon SQS dead letter queues (DLQs). By calling `DisableAllNativeDeadLetterQueues()` within the `UseWolverine` configuration block after setting up the SQS transport (using `UseAmazonSqsTransportLocally()` in this example), the application is instructed not to create or use SQS DLQs. Instead, Wolverine will rely on its configured persistent envelope storage for handling dead-lettered messages. This approach requires Wolverine, Wolverine.AmazonSqs, and Microsoft.Extensions.Hosting.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/deadletterqueues.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAmazonSqsTransportLocally()\n            // Disable all native SQS dead letter queueing\n            .DisableAllNativeDeadLetterQueues()\n            .AutoProvision();\n\n        opts.ListenToSqsQueue(\"incoming\");\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Configuring Parallelization and Execution for Wolverine Local Queues in C#\nDESCRIPTION: This code example demonstrates configuring parallelism and execution properties for Wolverine local queues. It shows how to enforce sequential processing ('Sequential()'), set the maximum number of parallel message handlers ('MaximumParallelMessages(5)'), and directly configure TPL Dataflow ActionBlock options like 'MaxDegreeOfParallelism' and 'BoundedCapacity' using 'ConfigureExecution()'. It also reiterates making a queue durable ('UseDurableInbox()').\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Force a local queue to be\n        // strictly first in, first out\n        // with no more than a single\n        // thread handling messages enqueued\n        // here\n\n        // Use this option if message ordering is\n        // important\n        opts.LocalQueue(\"one\")\n            .Sequential();\n\n        // Specify the maximum number of parallel threads\n        opts.LocalQueue(\"two\")\n            .MaximumParallelMessages(5);\n\n        // Or just edit the ActionBlock options directly\n        opts.LocalQueue(\"three\")\n            .ConfigureExecution(options =>\n            {\n                options.MaxDegreeOfParallelism = 5;\n                options.BoundedCapacity = 1000;\n            });\n\n        // And finally, this enrolls a queue into the persistent inbox\n        // so that messages can happily be retained and processed\n        // after the service is restarted\n        opts.LocalQueue(\"four\").UseDurableInbox();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Integrating Marten with Wolverine in C#\nDESCRIPTION: This snippet demonstrates the updated syntax for integrating the Marten document database with Wolverine using the IServiceCollection extension methods in C#. It showcases configuring Marten with connection and logging options, then registering integration-specific schema settings for message and transport storage through a nested lambda. Prerequisites include references to Marten and Wolverine packages. The main parameters are Marten options, PostgreSQL connection string, logging toggle, and schema names. This configuration is typically used in ASP.NET Core startup classes or service bootstrapping routines.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/migration.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nservices.AddMarten(opts =>\n    {\n        opts.Connection(Servers.PostgresConnectionString);\n        opts.DisableNpgsqlLogging = true;\n    })\n    .IntegrateWithWolverine(w =>\n    {\n        w.MessageStorageSchemaName = \"public\";\n        w.TransportSchemaName = \"public\";\n    })\n    .ApplyAllDatabaseChangesOnStartup();\n```\n\n----------------------------------------\n\nTITLE: Adding Wolverine Package to Project - Bash\nDESCRIPTION: This code adds the WolverineFx NuGet package to the project using the .NET CLI. The command requires an existing .NET project in the current directory. It makes Wolverine features available, enabling the use of command and event handling within the service.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/getting-started.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package WolverineFx\n```\n\n----------------------------------------\n\nTITLE: Testing Specific Queue Handlers with ExecuteAndWaitAsync - Wolverine - C#\nDESCRIPTION: Shows how to use the ExecuteAndWaitAsync API to target and test a specific handler by sending an event message directly to a named local queue, allowing for precise invocation and coordinated completion checks. The code assumes previously configured endpoint routing and OrderPlaced message type. The input is an IHost instance, while the output is the awaited completion of the targeted handler. Caveat: While functional, the surrounding comments suggest this API may receive future syntactic improvements for ergonomics.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/modular-monolith.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task test_specific_handler(IHost host)\n{\n    // We're not thrilled with this usage and it's possible there's\n    // syntactic sugar additions to the API soon\n    await host.ExecuteAndWaitAsync(\n        c => c.EndpointFor(\"local queue name\").SendAsync(new OrderPlaced(\"111\")).AsTask());\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling External Wolverine Transports in Integration Tests (Alba/C#)\nDESCRIPTION: Shows an integration test setup using Alba and `WebApplicationFactory`. It configures the test host services to disable all external Wolverine transports by calling the `DisableAllExternalWolverineTransports()` extension method, useful for isolating tests.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// This is using Alba to bootstrap a Wolverine application\n// for integration tests, but it's using WebApplicationFactory\n// to do the actual bootstrapping\nawait using var host = await AlbaHost.For<Program>(x =>\n{\n    // I'm overriding\n    x.ConfigureServices(services => services.DisableAllExternalWolverineTransports());\n});\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping the Pinger Application with Wolverine in C#\nDESCRIPTION: Initializes the Pinger service using a .NET Generic Host, configuring Wolverine for messaging via TCP. The snippet listens for incoming messages on port 5580, sets up publishing of Ping messages to port 5581, and registers a Worker as a hosted service. Required dependencies include the Messages assembly, Oakton, Wolverine, and TCP transport. The program expects command-line arguments, configures the message routes, and starts the application lifecycle using RunOaktonCommands.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/ping-pong.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nusing Messages;\nusing Oakton;\nusing Pinger;\nusing Wolverine;\nusing Wolverine.Transports.Tcp;\n\nreturn await Host.CreateDefaultBuilder(args)\n    .UseWolverine(opts =>\n    {\n        // Using Wolverine's built in TCP transport\n\n        // listen to incoming messages at port 5580\n        opts.ListenAtPort(5580);\n\n        // route all Ping messages to port 5581\n        opts.PublishMessage<Ping>().ToPort(5581);\n\n        // Registering the hosted service here, but could do\n        // that with a separate call to IHostBuilder.ConfigureServices()\n        opts.Services.AddHostedService<Worker>();\n    })\n    .RunOaktonCommands(args);\n```\n\n----------------------------------------\n\nTITLE: Installing Node.js Dependencies for Documentation using Bash\nDESCRIPTION: This command uses the Node Package Manager (npm) to install the dependencies listed in the `package.json` file, typically located in the `/docs` folder. These dependencies are required to build and run the documentation website locally.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Executing Build Script for Test Samples on Unix - Bash\nDESCRIPTION: This script runs the build.sh file with the 'test-samples' argument to set up and execute test samples for the BankingService project on Unix-like systems. Requires appropriate permissions to execute the script, and assumes the script is available in the current directory. The script likely handles compilation and test execution processes.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/TestHarness/BankingService/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh test-samples\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Inline Endpoint Processing in Wolverine with Azure Service Bus (C#)\nDESCRIPTION: This example configures a Wolverine application to process messages from an Azure Service Bus queue using the 'Inline' mode, where external messages are handled immediately before being acknowledged. It assumes a context containing the 'opts' configuration variable, and dependencies include the Azure Service Bus transport and the Wolverine framework. The key input is a queue name and auto-delete option, while the output is a Wolverine endpoint configured for inline message processing, with limitations based on the transport's support for inline endpoints.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/runtime.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// Configuring a Wolverine application to listen to\\n// an Azure Service Bus queue with the \"Inline\" mode\\nopts.ListenToAzureServiceBusQueue(queueName, q => q.Options.AutoDeleteOnIdle = 5.Minutes()).ProcessInline();\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Outbox and Transactional Middleware for Tenancy in C#\nDESCRIPTION: Sets up Wolverine on the .NET Host builder to auto-apply transaction boundaries and use durable local queues for message handling, ensuring outbox functionality is active for each tenant environment. Depends on `UseWolverine` orchestration, proper policy configuration, and prior Marten setup. No direct input parameters in this config snippet, but must run during startup before processing messages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/multi-tenancy.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// Wolverine usage is required for WolverineFx.Http\nbuilder.Host.UseWolverine(opts =>\n{\n    // This middleware will apply to the HTTP\n    // endpoints as well\n    opts.Policies.AutoApplyTransactions();\n\n    // Setting up the outbox on all locally handled\n    // background tasks\n    opts.Policies.UseDurableLocalQueues();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine SQS Publishing Rules in C#\nDESCRIPTION: This C# snippet demonstrates configuring Wolverine within a .NET Host to publish messages to specific Amazon SQS queues. It initializes Wolverine with SQS transport enabled (`UseAmazonSqsTransport`), then sets up publishing rules for `Message1` and `Message2`. For `Message1`, it targets the 'outbound1' queue and increases parallelism for higher throughput, potentially sacrificing strict ordering. For `Message2`, it targets 'outbound2' and configures a specific maximum message size attribute during queue creation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/publishing.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n```cs\nvar host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAmazonSqsTransport();\n\n        opts.PublishMessage<Message1>()\n            .ToSqsQueue(\"outbound1\")\n\n            // Increase the outgoing message throughput, but at the cost\n            // of strict ordering\n            .MessageBatchMaxDegreeOfParallelism(Environment.ProcessorCount);\n\n        opts.PublishMessage<Message2>()\n            .ToSqsQueue(\"outbound2\").ConfigureQueueCreation(request =>\n            {\n                request.Attributes[QueueAttributeName.MaximumMessageSize] = \"1024\";\n            });\n    }).StartAsync();\n```\n```\n\n----------------------------------------\n\nTITLE: Using Custom Parameter Strategy in Wolverine HTTP Endpoint C#\nDESCRIPTION: Shows a Wolverine HTTP GET endpoint (`[WolverineGet(\"/now\")]`) that takes advantage of the custom `NowParameterStrategy` registered previously. By declaring a parameter `DateTimeOffset now`, the custom strategy automatically injects the current UTC time (`DateTimeOffset.UtcNow`) into the method when the endpoint is called.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_11\n\nLANGUAGE: cs\nCODE:\n```\n[WolverineGet(\"/now\")]\npublic static string GetNow(DateTimeOffset now) // using the custom parameter strategy for \"now\"\n{\n    return now.ToString();\n}\n```\n\n----------------------------------------\n\nTITLE: Using MemoryPack on Selected Endpoints in Wolverine (C#)\nDESCRIPTION: Shows how to apply MemoryPack serialization to specific Wolverine endpoints (queues, ports, subscribers), granting endpoint-level customization over the serialization protocol. Requires the WolverineFx.MemoryPack package and correct configuration of each needed endpoint in WolverineOptions.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Use MemoryPack on a local queue\n        opts.LocalQueue(\"one\").UseMemoryPackSerialization();\n\n        // Use MemoryPack on a listening endpoint\n        opts.ListenAtPort(2223).UseMemoryPackSerialization();\n\n        // Use MemoryPack on one subscriber\n        opts.PublishAllMessages().ToPort(2222).UseMemoryPackSerialization();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Running Docker Compose for Wolverine Environment Setup (Bash)\nDESCRIPTION: This Bash snippet starts the necessary Docker Compose services in detached mode, creating the required infrastructure (such as a SQL Server database) for the Wolverine/EF Core sample project. It assumes Docker and Docker Compose are installed and that a valid compose file exists at the root of the solution. Running this command will pull required images, create containers, and start them in the background. No parameters are required. The expected result is all specified infrastructure services ready for use by the main application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/InMemoryMediator/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n\n```\n\n----------------------------------------\n\nTITLE: Configuring External Database Table Message Polling in Wolverine with C#\nDESCRIPTION: This C# snippet configures a Wolverine application to poll an external database table for incoming messages using the .NET Host builder and Wolverine integration. It demonstrates how to set up the connection with either PostgreSQL or SQL Server using connection strings, and specifies the external table, schema, and message metadata columns to monitor. The options include customizing the primary key, JSON data column, message type resolution logic, diagnostic timestamping, polling intervals, batch sizes, table migration controls, advisory locking, and default message type binding. Expected input includes properly structured database tables, and the output is a Wolverine endpoint ready to ingest and process messages from the external source reliably. The example assumes Wolverine and related dependencies (e.g., Marten for Postgres or configuration libraries) are available, and constraints include standard limitations on polling intervals and batch sizes as set in configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/external-tables.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    opts.UsePostgresqlPersistenceAndTransport(builder.Configuration.GetConnectionString(\"postgres\"));\n\n    // Or\n    // opts.UseSqlServerPersistenceAndTransport(builder.Configuration.GetConnectionString(\"sqlserver\"));\n    \n    // Or\n    // opts.Services\n    //     .AddMarten(builder.Configuration.GetConnectionString(\"postgres\"))\n    //     .IntegrateWithWolverine();\n    \n    // Directing Wolverine to \"listen\" for messages in an externally controlled table\n    // You have to explicitly tell Wolverine about the schema name and table name\n    opts.ListenForMessagesFromExternalDatabaseTable(\"exports\", \"messaging\", table =>\n        {\n            // The primary key column for this table, default is \"id\"\n            table.IdColumnName = \"id\";\n\n            // What column has the actual JSON data? Default is \"json\"\n            table.JsonBodyColumnName = \"body\";\n\n            // Optionally tell Wolverine that the message type name is this\n            // column. \n            table.MessageTypeColumnName = \"message_type\";\n\n            // Add a column for the current time when a message was inserted\n            // Strictly for diagnostics\n            table.TimestampColumnName = \"added\";\n\n            // How often should Wolverine poll this table? Default is 10 seconds\n            table.PollingInterval = 1.Seconds();\n\n            // Maximum number of messages that each node should try to pull in at \n            // any one time. Default is 100\n            table.MessageBatchSize = 50;\n\n            // Is Wolverine allowed to try to apply automatic database migrations for this\n            // table at startup time? Default is true.\n            // Also overridden by WolverineOptions.AutoBuildMessageStorageOnStartup\n            table.AllowWolverineControl = true;\n\n            // Wolverine uses a database advisory lock so that only one node at a time\n            // can ever be polling for messages at any one time. Default is 12000\n            // It might release contention to vary the advisory lock if you have multiple\n            // incoming tables or applications targeting the same database\n            table.AdvisoryLock = 12001;\n            \n            // Tell Wolverine what the default message type is coming from this\n            // table to aid in deserialization\n            table.MessageType = typeof(ExternalMessage);\n            \n            \n        })\n        \n        // Just showing that you have all the normal options for configuring and\n        // fine tuning the behavior of a message listening endpoint here\n        .Sequential();\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up Azure Service Bus Resources at Startup with Wolverine (C#)\nDESCRIPTION: This snippet demonstrates how to configure Wolverine to automatically create all necessary Azure Service Bus queues, topics, and subscriptions at application startup. It leverages the AddResourceSetupOnStartup() method to ensure missing resources are provisioned before the application runs. Dependencies include the Wolverine library, a valid Azure Service Bus connection string, and .NET hosting infrastructure. Inputs are configuration options; outputs are provisioned Azure Service Bus resources for the app.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/azureservicebus/object-management.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        opts.UseAzureServiceBus(\"some connection string\");\n\n        // Make sure that all known resources like\n        // the Azure Service Bus queues, topics, and subscriptions\n        // configured for this application exist at application start up\n        opts.Services.AddResourceSetupOnStartup();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Previewing Wolverine Message Routing Programmatically in C#\nDESCRIPTION: This C# snippet demonstrates using the `PreviewSubscriptions` method on the `IMessageBus` interface to determine where Wolverine would route a given message instance (e.g., `new BlueMessage()`) without actually sending it. It returns a collection of outgoing `Envelope` objects, whose `Destination` property indicates the target endpoint URI (like a queue, topic, or exchange). This is helpful for debugging routing rules and subscriptions at runtime.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/diagnostics.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\npublic static void using_preview_subscriptions(IMessageBus bus)\n{\n    // Preview where Wolverine is wanting to send a message\n    var outgoing = bus.PreviewSubscriptions(new BlueMessage());\n    foreach (var envelope in outgoing)\n    {\n        // The URI value here will identify the endpoint where the message is\n        // going to be sent (Rabbit MQ exchange, Azure Service Bus topic, Kafka topic, local queue, etc.)\n        Debug.WriteLine(envelope.Destination);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized EF Core DbContext Registration with Wolverine Integration (C#)\nDESCRIPTION: Shows how to register an Entity Framework Core `DbContext` (e.g., `ItemsDbContext`) using the `AddDbContextWithWolverineIntegration` extension method within the service collection (`builder.Services`). This method provides Wolverine-specific optimizations, potentially improves performance by setting options lifetime to Singleton, automatically includes mappings for Wolverine's persisted messages using the specified schema ('wolverine' in this case), and enables transactional middleware support.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/efcore.md#_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// If you're okay with this, this will register the DbContext as normally,\n// but make some Wolverine specific optimizations at the same time\nbuilder.Services.AddDbContextWithWolverineIntegration<ItemsDbContext>(\n    x => x.UseSqlServer(connectionString), \"wolverine\");\n```\n\n----------------------------------------\n\nTITLE: Scoped Service Registration with Lambda in .NET DI (C#)\nDESCRIPTION: This snippet demonstrates the registration of an IDatabase service as a scoped dependency within the .NET ServiceCollection using a lambda factory. It retrieves configuration from the service provider, accesses the connection string named 'foo', and instantiates a Database object. Dependencies include Microsoft.Extensions.DependencyInjection and a pre-configured IConfiguration in the DI container. The primary input is the ServiceCollection 'services', and the output is the registration of an IDatabase for runtime resolution. Using this pattern may incur runtime overhead and is discouraged in Wolverine context.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/best-practices.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddScoped<IDatabase>(s => {\n    var c = s.GetRequiredService<IConfiguration>();\n    return new Database(c.GetConnectionString(\"foo\");\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Separate Behavior for Multiple Handlers in Wolverine (C#)\nDESCRIPTION: Shows how to set the `MultipleHandlerBehavior` option to `Separated` during Wolverine host configuration using `UseWolverine`. This ensures that each handler implementation for a given message type is treated as a distinct, independent handler with its own subscription, rather than being combined into a single logical handler. This is particularly useful in Modular Monolith or Event Driven Architectures.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/index.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Right here, tell Wolverine to make every handler \"sticky\"\n        opts.MultipleHandlerBehavior = MultipleHandlerBehavior.Separated;\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Always Publishing Handler Response with Attribute (C#)\nDESCRIPTION: Demonstrates the use of the [AlwaysPublishResponse] attribute to change handler behavior in Wolverine so that handler return values are always published as messages, even when invoked with InvokeAsync<T>. Dependencies include a handler that returns a tuple (ItemCreated, SecondItemCreated), and the [AlwaysPublishResponse] attribute. This feature is useful for scenarios requiring event distribution or integration with external processes triggered by command results.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/message-bus.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class CreateItemCommandHandler\\n{\\n    // Using this attribute will force Wolverine to also publish the ItemCreated event even if\\n    // this is called by IMessageBus.InvokeAsync<ItemCreated>()\\n    [AlwaysPublishResponse]\\n    public async Task<(ItemCreated, SecondItemCreated)> Handle(CreateItemCommand command, IDocumentSession session)\\n    {\\n        var item = new Item\\n        {\\n            Id = Guid.NewGuid(),\\n            Name = command.Name\\n        };\\n\\n        session.Store(item);\\n\\n        return (new ItemCreated(item.Id, item.Name), new SecondItemCreated(item.Id, item.Name));\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Wolverine HTTP Middleware by Message Type (C#)\nDESCRIPTION: Demonstrates how to register HTTP middleware, like `FakeAuthenticationMiddleware` and `CanShipOrderMiddleWare`, in Wolverine using the `AddMiddlewareByMessageType` extension method on the Wolverine options (`opts`). This approach applies the specified middleware to handlers processing messages of corresponding types.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/middleware.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nopts.AddMiddlewareByMessageType(typeof(FakeAuthenticationMiddleware));\nopts.AddMiddlewareByMessageType(typeof(CanShipOrderMiddleWare));\n```\n\n----------------------------------------\n\nTITLE: Defining Ping and Pong Messages in C#\nDESCRIPTION: Defines the message contract classes, Ping and Pong, which are used by both sender and receiver services. These plain C# classes encapsulate a single integer property named Number, representing the sequence or identifier for each message. No external dependencies are required, but both classes must be shared and referenced by any process intending to send or receive these messages.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/tutorials/ping-pong.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class Ping\n{\n    public int Number { get; set; }\n}\n\npublic class Pong\n{\n    public int Number { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Homepage Content (YAML Frontmatter)\nDESCRIPTION: This YAML block defines the metadata and content structure for the Wolverine project's homepage. It sets the layout to 'home', disables the sidebar, defines the page title and template, configures the hero section with text, tagline, image, and a 'Get Started' button, lists key features with titles and details, and sets the footer text.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nlayout: home\nsidebar: false\n\ntitle: Wolverine\ntitleTemplate: Robust Event Driven Architectures with Simpler Code\n\nhero:\n  name: Wolverine\n  text: Build Robust Event Driven Architectures with Simpler Code\n  tagline: The messaging and web development framework that gets out of your way\n  image:\n    src: /logo.png\n    alt: Wolverine Logo image\n  actions:\n    - theme: brand\n      text: Get Started\n      link: /tutorials/getting-started\n\nfeatures:\n- title: 💪 Write Less Code\n  details: A unique approach to writing server side code that delivers fast performance & provides an effective middleware strategy whilst keeping out of the way of your application code\n- title: ⚡️ Messaging\n  details: Everything you need for a robust messaging solution between services including support for many popular transports, message failure policies, and persistent inbox/outbox messaging\n- title: 📚 Asynchronous Processing\n  details: Use Wolverine as an in memory command bus to easily leverage asynchronous and parallel processing within a single or multiple processes\n\nfooter: MIT Licensed | Copyright © Jeremy D. Miller and contributors.\n---\n```\n\n----------------------------------------\n\nTITLE: Discovering Wolverine Message Types via Marker Interfaces in C#\nDESCRIPTION: This snippet demonstrates using marker interfaces (`IMessage`, `ICommand`, `IEvent`) from the `Wolverine` namespace to help Wolverine discover message types for diagnostic purposes (e.g., routing reports). C# record types `CreateIssue`, `DeleteIssue`, and `IssueCreated` implement these interfaces to signify their role.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messages.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic record CreateIssue(string Name) : IMessage;\n\npublic record DeleteIssue(Guid Id) : ICommand;\n\npublic record IssueCreated(Guid Id, string Name) : IEvent;\n```\n\n----------------------------------------\n\nTITLE: Preventing Request Body Deserialization with [NotBody] in Wolverine C#\nDESCRIPTION: This C# snippet shows a Wolverine HTTP POST endpoint (`/notbody`). It uses the `[NotBody]` attribute on the `Recorder recorder` parameter to explicitly instruct Wolverine to resolve `recorder` as an IoC service instead of attempting to deserialize the HTTP request body into it, overriding the default behavior for complex types. The method returns a simple string response.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/endpoints.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n[WolverinePost(\"/notbody\")]\n// The Recorder parameter will be sourced as an IoC service\n// instead of being treated as the HTTP request body\npublic string PostNotBody([NotBody] Recorder recorder)\n{\n    recorder.Actions.Add(\"Called AttributesEndpoints.Post()\");\n    return \"all good\";\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Sagas with NotFound Method in C#\nDESCRIPTION: This C# snippet shows a static `NotFound` method within a Saga class (implicitly `OrderSaga`). It's invoked by Wolverine when a message (`CompleteOrder`) arrives for a saga instance that cannot be found. It logs an informational message using the injected `ILogger`. Dependencies include `Microsoft.Extensions.Logging.ILogger`. The method takes the incoming message (`CompleteOrder`) and optionally other services like the logger.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/sagas.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\npublic static void NotFound(CompleteOrder complete, ILogger<Order> logger)\n{\n    logger.LogInformation(\"Tried to complete order {Id}, but it cannot be found\", complete.Id);\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding RabbitMQ Topic Names with [Topic] Attribute (C#)\nDESCRIPTION: These snippets illustrate how to explicitly define the RabbitMQ topic name for a message type by decorating the class definition with the `[Topic(\"topic-name\")]` attribute. This overrides Wolverine's default topic name derivation (which is usually the message type's alias or full name). Examples show simple names and hierarchical names.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/rabbitmq/topics.md#_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n[Topic(\"one\")]\npublic class TopicMessage1;\n```\n\nLANGUAGE: cs\nCODE:\n```\n[Topic(\"color.blue\")]\npublic class FirstMessage\n{\n    public Guid Id { get; set; } = Guid.NewGuid();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Not-Tenanted Wolverine HTTP Endpoint - C#\nDESCRIPTION: This snippet shows how to exempt a specific endpoint from tenant detection and enforcement by applying the [NotTenanted] attribute. The endpoint method returns a static response and does not participate in multi-tenancy checks. Dependencies include the WolverineGet route attribute and the NotTenanted marker. This is useful for endpoints valid for all or no tenants; no tenant id is expected or validated.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/multi-tenancy.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// Mark this endpoint as not using any kind of multi-tenancy\n[WolverineGet(\"/nottenanted\"), NotTenanted]\npublic static string NoTenantNoProblem()\n{\n    return \"hey\";\n}\n```\n\n----------------------------------------\n\nTITLE: Releasing Wolverine Node Ownership Locks via CLI using Bash\nDESCRIPTION: Explains the command `dotnet run -- storage release` used to release the ownership locks held by persisted nodes on incoming or outgoing messages. This can be useful in recovery scenarios where a node has crashed, although Wolverine typically handles this automatically. Use with caution in production if nodes are currently running.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/managing.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- storage release\n```\n\n----------------------------------------\n\nTITLE: Sending Messages Manually with IMessageContext in Wolverine (C#)\nDESCRIPTION: Demonstrates the traditional approach to sending a subsequent message within a Wolverine handler. This handler injects `IMessageContext` via its constructor and uses the `SendAsync` method to explicitly dispatch a `MyResponse` message after processing `MyMessage`. This pattern requires a dependency on `IMessageContext`.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/cascading.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// snippet: sample_NoCascadingHandler\npublic class NoCascadingHandler\n{\n    private readonly IMessageContext _bus;\n\n    public NoCascadingHandler(IMessageContext bus)\n    {\n        _bus = bus;\n    }\n\n    public void Consume(MyMessage message)\n    {\n        // do whatever work you need to for MyMessage,\n        // then send out a new MyResponse\n        _bus.SendAsync(new MyResponse());\n    }\n}\n// endSnippet\n```\n\n----------------------------------------\n\nTITLE: Disabling Conventional Local Queue Routing in Wolverine (C#)\nDESCRIPTION: This asynchronous snippet demonstrates how to disable the default local queue routing policy in Wolverine by invoking DisableConventionalLocalRouting within UseWolverine. This ensures all messages, regardless of local handlers, use external brokers if defined. Dependencies: Host builder, Wolverine. Inputs: Host builder config; Output: Routing policies set prior to starting the host. All routing convention adjustments must occur during application startup.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/subscriptions.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async Task disable_queue_routing()\n{\n    using var host = await Host.CreateDefaultBuilder()\n        .UseWolverine(opts =>\n        {\n            // This will disable the conventional local queue\n            // routing that would take precedence over other conventional\n            // routing\n            opts.Policies.DisableConventionalLocalRouting();\n\n            // Other routing conventions. Rabbit MQ? SQS?\n        }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Starting PostgreSQL with Docker Compose - Bash\nDESCRIPTION: Starts a PostgreSQL database instance required for Marten persistence using Docker Compose, ensuring that the backing store needed for the application is available. Must be run from the root directory of the Wolverine code repository. No arguments are required, and it assumes a Docker and Docker Compose setup with a valid configuration.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/OrderSagaSample/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Defining IConfigureLocalQueue Interface in C#\nDESCRIPTION: This snippet shows the definition of the IConfigureLocalQueue interface in Wolverine. This interface uses a static abstract method 'Configure' which allows message handler types to specify configuration for the local queue they are associated with, particularly useful for 'sticky' handlers.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/local.md#_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n/// Helps mark a handler to configure the local queue that its messages\n/// would be routed to. It's probably only useful to use this with \"sticky\" handlers\n/// that run on an isolated local queue\n/// </summary>\npublic interface IConfigureLocalQueue\n{\n    static abstract void Configure(LocalQueueConfiguration configuration);\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Wolverine Messages Inline for Specific Tenants in C#\nDESCRIPTION: Demonstrates how to execute a Wolverine message immediately for a specific tenant using the `IMessageBus.InvokeForTenantAsync` method. This example shows both a standard inline invocation and an invocation expecting a response (`TodoCreated`) for different tenant IDs ('tenant1', 'tenant2'). Requires an `IMessageBus` instance.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/multi-tenancy.md#_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\npublic static async Task invoking_by_tenant(IMessageBus bus)\n{\n    // Invoke inline\n    await bus.InvokeForTenantAsync(\"tenant1\", new CreateTodo(\"Release Wolverine 1.0\"));\n\n    // Invoke with an expected result (request/response)\n    var created =\n        await bus.InvokeForTenantAsync<TodoCreated>(\"tenant2\", new CreateTodo(\"Update the Documentation\"));\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Explicit AWS Credentials for Amazon SQS in Wolverine (C#)\nDESCRIPTION: This snippet configures Wolverine to connect to Amazon SQS by explicitly providing AWS access and secret keys through the .Credentials() method. It also demonstrates SQS-specific configuration via ServiceURL and preserves options for queue auto-provisioning and purging. This is useful when programmatic credential management is required, avoiding reliance on shared AWS credentials files. Required dependencies include WolverineFx.AmazonSqs and AWS SDK types such as BasicAWSCredentials. Inputs include AWS keys from configuration, and the output is a running host with explicit SQS credentials.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/transports/sqs/index.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar builder = Host.CreateApplicationBuilder();\nbuilder.UseWolverine(opts =>\n{\n    var config = builder.Configuration;\n\n    opts.UseAmazonSqsTransport(sqsConfig =>\n        {\n            sqsConfig.ServiceURL = config[\"AwsUrl\"];\n            // And any other elements of the SQS AmazonSQSConfig\n            // that you may need to configure\n        })\n\n        // And you can also add explicit AWS credentials\n        .Credentials(new BasicAWSCredentials(config[\"AwsAccessKey\"], config[\"AwsSecretKey\"]))\n\n        // Let Wolverine create missing queues as necessary\n        .AutoProvision()\n\n        // Optionally purge all queues on application startup.\n        // Warning though, this is potentially slow\n        .AutoPurgeOnStartup();\n});\n\nusing var host = builder.Build();\nawait host.StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Testing Multi-Tenant Document Persistence and Retrieval with Wolverine and Marten in C#\nDESCRIPTION: Defines a test method using xUnit that exercises inserting and retrieving documents in a conjoined tenancy Marten setup using tenant-specific lightweight sessions. Shows how to invoke actions for specific tenants and validate that each tenant sees its own document state. Requires xUnit, Marten, and a configured host with tenant-aware document store. Inputs are tenant IDs and initial data; outputs are assertions verifying correct per-tenant document storage and retrieval.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/marten/multi-tenancy.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n[Fact]\npublic async Task execute_with_tenancy()\n{\n    var id = Guid.NewGuid();\n\n    await _host.ExecuteAndWaitAsync(c =>\n        c.InvokeForTenantAsync(\"one\", new CreateTenantDocument(id, \"Andor\")));\n\n    await _host.ExecuteAndWaitAsync(c =>\n        c.InvokeForTenantAsync(\"two\", new CreateTenantDocument(id, \"Tear\")));\n\n    await _host.ExecuteAndWaitAsync(c =>\n        c.InvokeForTenantAsync(\"three\", new CreateTenantDocument(id, \"Illian\")));\n\n    var store = _host.Services.GetRequiredService<IDocumentStore>();\n\n    // Check the first tenant\n    using (var session = store.LightweightSession(\"one\"))\n    {\n        var document = await session.LoadAsync<TenantedDocument>(id);\n        document.Location.ShouldBe(\"Andor\");\n    }\n\n    // Check the second tenant\n    using (var session = store.LightweightSession(\"two\"))\n    {\n        var document = await session.LoadAsync<TenantedDocument>(id);\n        document.Location.ShouldBe(\"Tear\");\n    }\n\n    // Check the third tenant\n    using (var session = store.LightweightSession(\"three\"))\n    {\n        var document = await session.LoadAsync<TenantedDocument>(id);\n        document.Location.ShouldBe(\"Illian\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Automatically Loading a Wolverine Extension using [WolverineModule] in C#\nDESCRIPTION: Illustrates using the `[WolverineModule<T>]` assembly attribute to automatically register an `IWolverineExtension` implementation (e.g., `Module1Extension`) when the containing assembly is referenced by the application. This simplifies extension loading by convention but is noted as potentially being removed in Wolverine 3.0. The attribute is applied at the assembly level.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_10\n\nLANGUAGE: cs\nCODE:\n```\n[assembly: WolverineModule<Module1Extension>]\n```\n\n----------------------------------------\n\nTITLE: Configuring Wolverine Durability Metrics Polling in C#\nDESCRIPTION: This C# snippet demonstrates configuring Wolverine's durability metric settings within a .NET Host application. It explicitly enables the durability metrics (which is the default) using `DurabilityMetricsEnabled` and modifies the polling frequency for these metrics using `UpdateMetricsPeriod`. These metrics track counts of persisted inbox, outbox, and scheduled messages. Adjusting the period can balance monitoring granularity with database query load.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/leadership-and-troubleshooting.md#_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nusing var host = await Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // This does assume that you have *some* kind of message\n        // persistence set up\n        \n        // This is enabled by default, but just showing that\n        // you *could* disable it\n        opts.Durability.DurabilityMetricsEnabled = true;\n\n        // The default is 5 seconds, but maybe you want it slower\n        // because this does have to do a non-trivial query\n        opts.Durability.UpdateMetricsPeriod = 10.Seconds();\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Defining the IMessageRoutingConvention Interface for Custom Wolverine Routing in C#\nDESCRIPTION: This C# interface, `IMessageRoutingConvention`, provides a plugin point for implementing custom, conventional message routing logic within Wolverine. The `DiscoverListeners` method allows defining listening endpoints based on application message handlers, while `DiscoverSenders` enables the creation of outgoing subscriptions for specific message types based on convention.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/messaging/subscriptions.md#_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\n/// <summary>\n///     Plugin for doing any kind of conventional message routing\n/// </summary>\npublic interface IMessageRoutingConvention\n{\n    /// <summary>\n    /// Use this to define listening endpoints based on the known message handlers for the application\n    /// </summary>\n    /// <param name=\"runtime\"></param>\n    /// <param name=\"handledMessageTypes\"></param>\n    void DiscoverListeners(IWolverineRuntime runtime, IReadOnlyList<Type> handledMessageTypes);\n    \n    /// <summary>\n    /// Create outgoing subscriptions for the application for the given message type\n    /// </summary>\n    /// <param name=\"messageType\"></param>\n    /// <param name=\"runtime\"></param>\n    /// <returns></returns>\n    IEnumerable<Endpoint> DiscoverSenders(Type messageType, IWolverineRuntime runtime);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Extension to Disable External Transports in C#\nDESCRIPTION: Provides the implementation of the `DisableExternalTransports` class, which implements `IWolverineExtension`. Its `Configure` method sets the `ExternalTransportsAreStubbed` property on `WolverineOptions` to `true`, effectively disabling external transport communication.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/extensions.md#_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\ninternal class DisableExternalTransports : IWolverineExtension\n{\n    public void Configure(WolverineOptions options)\n    {\n        options.ExternalTransportsAreStubbed = true;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Previewing Wolverine Generated Code in Terminal via Command Line using Bash\nDESCRIPTION: This Bash command uses Oakton to display Wolverine's generated source code directly in the terminal console without writing files to disk. Running `dotnet run -- codegen preview` provides a quick way to view the code Wolverine generates for message handlers and endpoints, useful for debugging middleware or convention application.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/diagnostics.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -- codegen preview\n```\n\n----------------------------------------\n\nTITLE: Overriding Application Assembly in Wolverine (.NET) in C#\nDESCRIPTION: This code demonstrates explicitly setting the ApplicationAssembly property on WolverineOptions to specify which assembly Wolverine should scan for handler types. It is used in scenarios (such as custom testing setups) where the default assembly inference might not locate all needed handlers. Requires .NET and the Wolverine library. The snippet shows Host.CreateDefaultBuilder and UseWolverine, explicitly setting opts.ApplicationAssembly to typeof(Program).Assembly before starting the host; no inputs or outputs are expected from this configuration step.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/discovery.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing var host = Host.CreateDefaultBuilder()\n    .UseWolverine(opts =>\n    {\n        // Override the application assembly to help\n        // Wolverine find its handlers\n        // Should not be necessary in most cases\n        opts.ApplicationAssembly = typeof(Program).Assembly;\n    }).StartAsync();\n```\n\n----------------------------------------\n\nTITLE: Handler Chain Configuration Method Signature in C#\nDESCRIPTION: Specifies the required signature for a static method within a message handler type that Wolverine will invoke to apply message type-specific configuration overrides to the handler chain.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/logging.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void Configure(HandlerChain chain)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Handler Policy Interface for Middleware Application (C#)\nDESCRIPTION: Declares the IHandlerPolicy interface for defining custom global or selective middleware in Wolverine message handlers. Implementers provide an Apply method that manipulates handler chains during application bootstrapping, receiving a list of HandlerChains, code generation rules, and the service container. Expected dependencies are Wolverine's policy interfaces and chain infrastructure. Inputs are the set of all message handler chains, and implementers alter middleware or configuration for each as required.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/handlers/middleware.md#_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>\n///     Use to apply your own conventions or policies to message handlers\n/// </summary>\npublic interface IHandlerPolicy : IWolverinePolicy\n{\n    /// <summary>\n    ///     Called during bootstrapping to alter how the message handlers are configured\n    /// </summary>\n    /// <param name=\"chains\"></param>\n    /// <param name=\"rules\"></param>\n    /// <param name=\"container\">The application's underlying IoC Container</param>\n    void Apply(IReadOnlyList<HandlerChain> chains, GenerationRules rules, IServiceContainer container);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Services for Integration Tests using Bash\nDESCRIPTION: This command uses Docker Compose to start the necessary background services defined in the project's `docker-compose.yml` file. These services are required for running the integration tests. The `-d` flag runs the containers in detached mode.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Defining Incident Management API Endpoints (Commented Out) using ASP.NET Core Minimal APIs and Marten in C#\nDESCRIPTION: This commented-out C# code defines several ASP.NET Core Minimal API endpoints for managing incidents. It includes endpoints for prioritizing, assigning agents, recording customer/agent responses, resolving, acknowledging, closing, and querying incidents. The endpoints utilize Marten's `IDocumentSession` for command operations (updates with optimistic concurrency via ETags using `FromIfMatchHeader` and `GetAndUpdate`) and `IQuerySession` for querying incident details, history, and summaries. Dependencies include ASP.NET Core Minimal APIs, Marten (`IDocumentSession`, `IQuerySession`), and likely custom request/command/event types (e.g., `PrioritiseIncidentRequest`, `AssignAgentToIncident`, `IncidentDetails`, `IncidentHistory`). The `Handle` method likely encapsulates the logic for applying commands/events to the `Incident` aggregate state.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/IncidentService/IncidentService/todo.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n//\n// agentIncidents.MapPost(\"{incidentId:guid}/priority\",\n//     (\n//             IDocumentSession documentSession,\n//             Guid incidentId,\n//             Guid agentId,\n//             [FromIfMatchHeader] string eTag,\n//             PrioritiseIncidentRequest body,\n//             CancellationToken ct\n//         ) =>\n//         documentSession.GetAndUpdate<Incident>(incidentId, ToExpectedVersion(eTag),\n//             state => Handle(state, new PrioritiseIncident(incidentId, body.Priority, agentId, Now)), ct)\n// );\n//\n// agentIncidents.MapPost(\"{incidentId:guid}/assign\",\n//     (\n//             IDocumentSession documentSession,\n//             Guid incidentId,\n//             Guid agentId,\n//             [FromIfMatchHeader] string eTag,\n//             CancellationToken ct\n//         ) =>\n//         documentSession.GetAndUpdate<Incident>(incidentId, ToExpectedVersion(eTag),\n//             state => Handle(state, new AssignAgentToIncident(incidentId, agentId, Now)), ct)\n// );\n//\n// customersIncidents.MapPost(\"{incidentId:guid}/responses/\",\n//     (\n//             IDocumentSession documentSession,\n//             Guid incidentId,\n//             Guid customerId,\n//             [FromIfMatchHeader] string eTag,\n//             RecordCustomerResponseToIncidentRequest body,\n//             CancellationToken ct\n//         ) =>\n//         documentSession.GetAndUpdate<Incident>(incidentId, ToExpectedVersion(eTag),\n//             state => Handle(state,\n//                 new RecordCustomerResponseToIncident(incidentId,\n//                     new IncidentResponse.FromCustomer(customerId, body.Content), Now)), ct)\n// );\n//\n// agentIncidents.MapPost(\"{incidentId:guid}/responses/\",\n//     (\n//         IDocumentSession documentSession,\n//         [FromIfMatchHeader] string eTag,\n//         Guid incidentId,\n//         Guid agentId,\n//         RecordAgentResponseToIncidentRequest body,\n//         CancellationToken ct\n//     ) =>\n//     {\n//         var (content, visibleToCustomer) = body;\n//\n//         return documentSession.GetAndUpdate<Incident>(incidentId, ToExpectedVersion(eTag),\n//             state => Handle(state,\n//                 new RecordAgentResponseToIncident(incidentId,\n//                     new IncidentResponse.FromAgent(agentId, content, visibleToCustomer), Now)), ct);\n//     }\n// );\n//\n// agentIncidents.MapPost(\"{incidentId:guid}/resolve\",\n//     (\n//             IDocumentSession documentSession,\n//             Guid incidentId,\n//             Guid agentId,\n//             [FromIfMatchHeader] string eTag,\n//             ResolveIncidentRequest body,\n//             CancellationToken ct\n//         ) =>\n//         documentSession.GetAndUpdate<Incident>(incidentId, ToExpectedVersion(eTag),\n//             state => Handle(state, new ResolveIncident(incidentId, body.Resolution, agentId, Now)), ct)\n// );\n//\n// customersIncidents.MapPost(\"{incidentId:guid}/acknowledge\",\n//     (\n//             IDocumentSession documentSession,\n//             Guid incidentId,\n//             Guid customerId,\n//             [FromIfMatchHeader] string eTag,\n//             CancellationToken ct\n//         ) =>\n//         documentSession.GetAndUpdate<Incident>(incidentId, ToExpectedVersion(eTag),\n//             state => Handle(state, new AcknowledgeResolution(incidentId, customerId, Now)), ct)\n// );\n//\n// agentIncidents.MapPost(\"{incidentId:guid}/close\",\n//     async (\n//         IDocumentSession documentSession,\n//         Guid incidentId,\n//         Guid agentId,\n//         [FromIfMatchHeader] string eTag,\n//         CancellationToken ct) =>\n//     {\n//         await documentSession.GetAndUpdate<Incident>(incidentId, ToExpectedVersion(eTag),\n//             state => Handle(state, new CloseIncident(incidentId, agentId, Now)), ct);\n//\n//         return Ok();\n//     }\n// );\n//\n// customersIncidents.MapGet(\"\",\n//     (IQuerySession querySession, Guid customerId, [FromQuery] int? pageNumber, [FromQuery] int? pageSize,\n//             CancellationToken ct) =>\n//         querySession.Query<IncidentShortInfo>().Where(i => i.CustomerId == customerId)\n//             .ToPagedListAsync(pageNumber ?? 1, pageSize ?? 10, ct)\n// );\n//\n// incidents.MapGet(\"{incidentId:guid}\",\n//     (HttpContext context, IQuerySession querySession, Guid incidentId) =>\n//         querySession.Json.WriteById<IncidentDetails>(incidentId, context)\n// );\n//\n// incidents.MapGet(\"{incidentId:guid}/history\",\n//     (HttpContext context, IQuerySession querySession, Guid incidentId) =>\n//         querySession.Query<IncidentHistory>().Where(i => i.IncidentId == incidentId).WriteArray(context)\n// );\n//\n// customersIncidents.MapGet(\"incidents-summary\",\n//     (HttpContext context, IQuerySession querySession, Guid customerId) =>\n//         querySession.Json.WriteById<CustomerIncidentsSummary>(customerId, context)\n// );\n```\n\n----------------------------------------\n\nTITLE: Starting Pulsar Broker via Shell Script with Docker - Bash\nDESCRIPTION: This shell command is intended for OSX or Linux environments, launching a local Pulsar broker for testing through Docker. Execution of './build.sh pulsar' assumes the 'build.sh' script exists and is executable in the project root. Docker must be installed and actively running as a prerequisite.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Transports/Pulsar/Wolverine.Pulsar.Tests/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh pulsar\n```\n\n----------------------------------------\n\nTITLE: Running the .NET Application with .NET CLI in Shell\nDESCRIPTION: This shell command builds and runs the .NET project located in the current directory (expected to be the 'AppWithMiddleware' example). It launches the sample application, allowing observation of Wolverine's middleware features interacting with the PostgreSQL database set up previously. Requires the .NET SDK to be installed.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/Middleware/AppWithMiddleware/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run\n```\n\n----------------------------------------\n\nTITLE: Running Docker Compose to Initialize PostgreSQL - Bash\nDESCRIPTION: This Bash snippet starts Docker containers defined in the Docker compose file at the solution root with detached mode enabled. It is required to have Docker and Docker Compose installed and available on the command line. This command will bring up any database and supporting services specified in the compose file, typically including PostgreSQL for the Wolverine sample project. Outputs include running Docker containers and ready-to-use database services. Ensure ports and service dependencies are met for successful operation.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/OptimizedArtifactWorkflowSample/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Compose Services (Bash)\nDESCRIPTION: This bash command starts the Docker Compose services defined in the `docker-compose.yml` file located at the root of the Wolverine solution. The `-d` flag runs the containers in detached mode, meaning they run in the background. This is typically used to initialize the required database (SQL Server) for the ItemService project.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/EFCoreSample/ItemService/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n```bash\ndocker compose up -d\n```\n```\n\n----------------------------------------\n\nTITLE: Manually Replaying Dead Letter Messages via SQL Update\nDESCRIPTION: Updates the `wolverine_dead_letters` table to mark messages that failed with a specific exception type as replayable. This allows the Wolverine durability agent to pick them up for reprocessing. This requires direct database access.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/dead-letter-storage.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nupdate wolverine_dead_letters set replayable = true where exception_type = 'InvalidAccountException';\n```\n\n----------------------------------------\n\nTITLE: Example Request Body for Deleting Dead Letters API (JSON)\nDESCRIPTION: Illustrates an example JSON request body for the `DELETE /dead-letters/` endpoint. It contains an array of `Ids` specifying which dead letter messages should be permanently removed from the system.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/durability/dead-letter-storage.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Ids\": [\"d3b07384-d113-4ec8-98c4-b3bf34e2c574\", \"d3b07384-d113-4ec8-98c4-b3bf34e2c575\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Required Services with Docker Compose (Bash)\nDESCRIPTION: This Bash command uses Docker Compose to build, (re)create, start, and attach to containers for services defined in a `docker-compose.yml` file, running them in the background (`-d` flag). It's used here to initialize the necessary infrastructure, typically a PostgreSQL database, for the TodoWebService project as an alternative to using a custom connection string. Requires Docker and Docker Compose installed and a `docker-compose.yml` file at the solution root.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/TodoWebService/TodoWebService/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Starting PostgreSQL with Docker Compose in Shell\nDESCRIPTION: This shell command uses Docker Compose to start the services defined in the project's docker-compose.yml file (expected to be PostgreSQL and PgAdmin4 based on context) in detached mode (-d). This step sets up the required database infrastructure for the application. Requires Docker and Docker Compose to be installed.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/Middleware/AppWithMiddleware/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Running Docker Compose for Database Setup - Bash\nDESCRIPTION: This snippet provides the command to launch the Docker Compose configuration in detached mode, setting up the necessary PostgreSQL database instance required by the sample project. Running this command ensures that the database backend is active and accessible to the ASP.NET Core application on startup. It requires Docker and Docker Compose installed on the system, and connectivity to the appropriate network interface.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/WebApiWithMarten/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Running the .NET Web API Application - .NET CLI\nDESCRIPTION: Builds and launches the sample Web API using the .NET CLI command. Assumes the user is in the directory containing the project source and that .NET SDK is installed. No additional parameters or configuration are required beyond the dependencies specified in the project.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/src/Samples/OrderSagaSample/README.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\ndotnet run\n```\n\n----------------------------------------\n\nTITLE: Adding WolverineFx.HTTP Package Dependency (Bash)\nDESCRIPTION: Adds the `WolverineFx.HTTP` NuGet package dependency to the current .NET project using the .NET CLI. This package provides the necessary components for building HTTP endpoints with Wolverine.\nSOURCE: https://github.com/jasperfx/wolverine/blob/main/docs/guide/http/integration.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndotnet add package WolverineFx.HTTP\n```"
  }
]