[
  {
    "owner": "chevrotain",
    "repo": "chevrotain",
    "content": "TITLE: Using Gates with Look Ahead for Conditional Parsing in Chevrotain (JavaScript)\nDESCRIPTION: This snippet demonstrates the use of the Gate property combined with the LA (Look Ahead) method in Chevrotain to decide whether an optional rule should be parsed. It defines a 'FromClause' rule where the presence of an alias identifier after the 'From' keyword depends on whether the second lookahead token is not an UnsignedInteger. This conditional approach is used to disambiguate tokens that may serve as identifiers or keywords depending on context.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/gates.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// SELECT LIMIT.ID FROM USER_LIMIT LIMIT\n// SELECT ID, NAME FROM USER_LIMIT LIMIT 1\n$.RULE(\"FromClause\", () => {\n  $.CONSUME(From);\n  $.CONSUME(Identifier);\n\n  $.OPTION({\n    GATE: () => $.LA(2).tokenType !== UnsignedInteger,\n    DEF: () => $.CONSUME1(Identifier, { LABEL: \"alias\" }),\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Gates in Chevrotain Parsing DSL in JavaScript\nDESCRIPTION: This snippet shows how to use the Gate property in an OR alternative to conditionally allow or disallow parsing a specific rule based on a parameter (isConst). It uses a parameterized rule 'Value' where the 'Variable' alternative is only taken if isConst is falsey, thereby preventing code duplication while supporting multiple variants of a parsing rule. The snippet relies on the Chevrotain DSL methods $.RULE, $.OR, $.SUBRULE, and $.CONSUME.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/gates.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// isConst is a parameter passed from another rule.\n$.RULE(\"Value\", (isConst) => {\n  $.OR([\n    // the Variable alternative is only possible when \"isConst\" is Falsey\n    { GATE: () => !isConst, ALT: () => $.SUBRULE($.Variable) },\n    { ALT: () => $.CONSUME(IntValue) },\n    { ALT: () => $.CONSUME(FloatValue) },\n    { ALT: () => $.CONSUME(StringValue) },\n  ]);\n});\n```\n\n----------------------------------------\n\nTITLE: Using the Chevrotain Parser Instance in JavaScript\nDESCRIPTION: Demonstrates how to use the created `SelectParser`. It involves instantiating the parser once, tokenizing the input string using a lexer (`SelectLexer.tokenize`), assigning the resulting tokens to the parser's `input` property (which resets parser state), invoking the desired starting rule (`parser.selectStatement()`), and checking the `parser.errors` array for any parsing issues.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step2_parsing.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// ONLY ONCE\nconst parser = new SelectParser();\n\nfunction parseInput(text) {\n  const lexingResult = SelectLexer.tokenize(text);\n  // \"input\" is a setter which will reset the parser's state.\n  parser.input = lexingResult.tokens;\n  parser.selectStatement();\n\n  if (parser.errors.length > 0) {\n    throw new Error(\"sad sad panda, Parsing errors detected\");\n  }\n}\n\nconst inputText = \"SELECT column1 FROM table2\";\nparseInput(inputText);\n```\n\n----------------------------------------\n\nTITLE: Creating Chevrotain CST Visitor Classes in JavaScript\nDESCRIPTION: This code shows how to create custom CST Visitor classes by subclassing the base visitor constructors from a Chevrotain parser instance. The example creates both a base visitor and a visitor with default traversal methods. Dependencies include a configured SelectParser instance; visitor classes should call validateVisitor to ensure all visit methods are declared. Expected use is subclassing to implement per-rule semantics for parse trees.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step3a_adding_actions_visitor.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// BaseVisitor constructors are accessed via a parser instance.\nconst parserInstance = new SelectParser();\n\nconst BaseSQLVisitor = parserInstance.getBaseCstVisitorConstructor();\n\n// This BaseVisitor include default visit methods that simply traverse the CST.\nconst BaseSQLVisitorWithDefaults =\n  parserInstance.getBaseCstVisitorConstructorWithDefaults();\n\nclass myCustomVisitor extends BaseSQLVisitor {\n  constructor() {\n    super();\n    // The \"validateVisitor\" method is a helper utility which performs static analysis\n    // to detect missing or redundant visitor methods\n    this.validateVisitor();\n  }\n\n  /* Visit methods go here */\n}\n\nclass myCustomVisitorWithDefaults extends BaseSQLVisitorWithDefaults {\n  constructor() {\n    super();\n    this.validateVisitor();\n  }\n\n  /* Visit methods go here */\n}\n\nconst myVisitorInstance = new myCustomVisitor();\nconst myVisitorInstanceWithDefaults = new myCustomVisitorWithDefaults();\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Parameterized Rules in Chevrotain (JavaScript)\nDESCRIPTION: Demonstrates defining a Chevrotain rule (`Value`) that accepts a parameter (`isConst`) and calling it from another rule (`ArgumentInConst`) using `$.SUBRULE` with the `ARGS` property. The `Value` rule uses the passed parameter within a `GATE` condition to conditionally enable a parsing alternative (`$.Variable`). This pattern allows for creating flexible and reusable grammar rules.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/parameterized_rules.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"ArgumentInConst\", () => {\n  $.CONSUME(Name);\n  $.CONSUME(Colon);\n  // passing the argument using the \"ARGS\" property\n  $.SUBRULE($.Value, { ARGS: [true] });\n});\n\n// isConst is a parameter passed from another rule.\n$.RULE(\"Value\", (isConst) => {\n  $.OR([\n    // the Variable alternative is only possible when \"isConst\" is Falsey\n    { GATE: () => !isConst, ALT: () => $.SUBRULE($.Variable) },\n    { ALT: () => $.CONSUME(IntValue) },\n    { ALT: () => $.CONSUME(FloatValue) },\n    { ALT: () => $.CONSUME(StringValue) },\n  ]);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Chevrotain Token Categories and Members\nDESCRIPTION: This snippet demonstrates how to define a Token Category (`KeywordOrIdentifier`) using `Lexer.NA` and how to assign other token types (`Identifier`, `Class`) to this category using the `categories` property during token definition. It also shows the use of `longer_alt`.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/token_categories.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// \"KeywordOrIdentifier\" is our Token category used to match any keyword or Identifier\nconst KeywordOrIdentifier = createToken({\n  name: \"AnyWord\",\n  pattern: Lexer.NA,\n});\n\n// General Identifier\nexport const Identifier = createToken({\n  name: \"Identifier\",\n  pattern: /[a-zA-Z]\\w*/,\n  categories: [KeywordOrIdentifier],\n});\n\n// a Keyword\nexport const Class = createToken({\n  name: \"Class\",\n  pattern: /Class/,\n  longer_alt: Identifier,\n  categories: [KeywordOrIdentifier],\n});\n```\n\n----------------------------------------\n\nTITLE: Skipping Whitespace Tokens in Chevrotain Lexer\nDESCRIPTION: Illustrates how to define a token for whitespace characters and instruct the Chevrotain lexer to ignore it during tokenization. This is achieved by assigning the token to the special `chevrotain.Lexer.SKIPPED` group via the `group` property in the `createToken` options.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step1_lexing.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst WhiteSpace = createToken({\n  name: \"WhiteSpace\",\n  pattern: /\\s+/,\n  group: chevrotain.Lexer.SKIPPED,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Context-Aware Integer Token Matcher in Chevrotain - JavaScript\nDESCRIPTION: Shows how to access the lexing context (matchedTokens and groups) within a custom matcher function to control when tokens are matched. The function matchInteger examines the most recently matched token and disallows integer matching if the previous token was an identifier. Requires Chevrotain's tokenMatcher utility, the Identifier token, and appropriate matcher arguments. Input includes the matched token stream for advanced, context-sensitive lexing.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/custom_token_patterns.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { tokenMatcher } from \"chevrotain\";\n\nfunction matchInteger(text, offset, matchedTokens, groups) {\n  let lastMatchedToken = _.last(matchedTokens);\n\n  // An Integer may not follow an Identifier\n  if (tokenMatcher(lastMatchedToken, Identifier)) {\n    // No match, must return null to conform with the RegExp.prototype.exec signature\n    return null;\n  }\n  // rest of the code from the example above...\n}\n```\n\n----------------------------------------\n\nTITLE: Repetition Re-Sync Recovery Example in Chevrotain - JavaScript\nDESCRIPTION: Illustrates handling of invalid tokens during repeated structures parsing, where the parser skips invalid tokens until it finds either the start of the next iteration or the expected token after the repetition. The JavaScript example shows JSON input with an unexpected number token inside an object repetition. The parser discards tokens between a missing comma and re-syncs the repetition to continue parsing subsequent valid keys. Demonstrates how this recovery can sacrifice some input but preserve continuation.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step4_fault_tolerance.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n{\n  \"key1\" : 1,\n  \"key2\" : 2 666 // '666' should not appear here!\n  \"key3  : 3,\n  \"key4  : 4\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing CstParser for CST Creation - TypeScript\nDESCRIPTION: This snippet demonstrates how to enable automatic CST creation by extending the CstParser class in Chevrotain.  The constructor is called with an empty array representing tokens. This separates semantic actions from grammar implementation. Note the nodeLocationTracking option should be provided in the config to enable accurate position tracking.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { CstParser } from \"chevrotain\";\n\nclass SelectParser extends CstParser {\n  constructor() {\n    super([]);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Single Token Insertion Fault Tolerance in Chevrotain - JavaScript\nDESCRIPTION: Demonstrates how Chevrotain automatically inserts a missing expected token (colon) into the token stream when an expected token Y is missing but a valid next token X is found. The example uses JavaScript to show both valid JSON input and invalid input missing the colon. Key idea is automatic insertion to allow parsing to continue without failure. No external dependencies are required other than Chevrotain itself. Inputs are JSON strings with and without colons; output is successful parse with the missing token implicitly inserted.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step4_fault_tolerance.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// GOOD\n{ \"key\" : 666 }\n\n// BAD, missing colon\n{ \"key\"   666 }\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Error Message for CONSUME Failure - Chevrotain DSL - JavaScript\nDESCRIPTION: This snippet demonstrates how to use the ERR_MSG property directly on a Chevrotain parsing DSL method, specifically CONSUME, to provide a custom error string if the expected token is not found at that position. This allows for very specific and user-friendly error messages tied to particular grammar points.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/custom_errors.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"myStatement\", () => {\n  // ...\n  $.CONSUME(SemiColon, {\n    ERR_MSG: \"expecting semiColon at end of myStatement\"\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Building an AST Node for SELECT Statement using Chevrotain in JavaScript\nDESCRIPTION: Demonstrates the `selectStatement` rule using embedded actions to construct an AST node. It calls `selectClause`, `fromClause`, and optionally `whereClause` using `SUBRULE`, collecting their results. Finally, it returns a JavaScript object representing the SELECT statement AST node, including its type and constituent clauses.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step3b_adding_actions_embedded.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"selectStatement\", () => {\n  let select, from, where;\n\n  select = $.SUBRULE($.selectClause);\n  from = $.SUBRULE($.fromClause);\n  $.OPTION(() => {\n    where = $.SUBRULE($.whereClause);\n  });\n\n  return {\n    type: \"SELECT_STMT\",\n    selectClause: select,\n    fromClause: from,\n    // may be undefined if the OPTION was not entered.\n    whereClause: where,\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Creating an AST by manually walking a CST in JavaScript\nDESCRIPTION: This snippet demonstrates a manual recursive approach to traverse a CST and build a simplified AST for SQL select statements. It highlights handling different node types with switch cases, extracting relevant parts, and raising errors for unexpected nodes. Dependencies include the CST structure produced by a parser.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Tree Walker\nexport function toAst(cst) {\n  const children = cst.children;\n  switch (cst.name) {\n    case \"selectStatement\": {\n      let columnsListCst = children.columnsList[0];\n      let fromClauseCst = children.fromClause[0];\n\n      let columnsListAst = toAst(columnsListCst);\n      let fromClauseAst = toAst(fromClauseCst);\n\n      return {\n        type: \"SelectStatementAst\",\n        columns: columnsListAst,\n        from: fromClauseAst,\n      };\n    }\n    case \"columnsList\": {\n      let columnName = children.identifier[0].image;\n      /*...*/\n    }\n    case \"fromClause\": {\n      /*...*/\n    }\n    default: {\n      throw new Error(\n        `CST case handler not implemented for CST node <${cst.name}>`,\n      );\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Alternatives with Subrules - JavaScript\nDESCRIPTION: This example shows how to handle alternatives within a grammar rule using subrules for better organization and maintainability. This avoids checking token existence in the CST output, allowing for cleaner logic and easier extensibility. Each alternative is wrapped in its own non-terminal sub-rule.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n$.RULE(\"statements\", () => {\n  $.OR([\n    { ALT: () => $.SUBRULE($.letStatement) },\n    { ALT: () => $.SUBRULE($.selectStatement) },\n  ]);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Chevrotain Token with start_chars_hint\nDESCRIPTION: This snippet illustrates how to resolve the  \"Failed parsing < /.../ > Using the regexp-to-ast library\" warning by providing the `start_chars_hint` property.  This is needed because the Chevrotain Lexer performs optimizations that depend on identifying the first possible characters of each token.  This allows the optimization to be used when the regexp-to-ast library has issues.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst Integer = createToken({\n  name: \"Integer\",\n  // lets assume that this pattern caused an error in regexp-to-ast\n  pattern: /[1-9]\\d*/,\n  // by explicitly providing the first possible characters of this pattern\n  // the analysis by the regexp-to-ast library will be skipped\n  // and the optimization can be enabled.\n  start_chars_hint: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n});\n```\n\n----------------------------------------\n\nTITLE: Understanding Chevrotain's Lookahead Mechanism for OR (JavaScript)\nDESCRIPTION: Illustrates the `OR` construct used for alternation in grammar rules. It explains that during the `performSelfAnalysis` phase, Chevrotain records the grammar structure. This allows the parser at runtime to dynamically create and cache lookahead functions to determine which alternative path (`ALT`) to take based on the next token(s), using the `atomicExpression` rule example.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step2_parsing.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n$.OR([\n  {\n    ALT: () => {\n      $.CONSUME(Integer);\n    },\n  },\n  {\n    ALT: () => {\n      $.CONSUME(Identifier);\n    },\n  },\n]);\n```\n\n----------------------------------------\n\nTITLE: Caching Chevrotain Alternatives Array Using JavaScript Pattern\nDESCRIPTION: Presents a JavaScript pattern using the `||` operator to cache the array of alternatives within a Chevrotain parsing rule (`$.c1`). This ensures the array is created only once per parser instance, significantly reducing overhead for large arrays and frequent rule calls.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/performance.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"value\", function () {\n  // c1 is used as a cache, the short circuit \"||\" will ensure only a single initialization\n  $.OR(\n    $.c1 ||\n      ($.c1 = [\n        { ALT: () => $.CONSUME(StringLiteral) },\n        { ALT: () => $.CONSUME(NumberLiteral) },\n        { ALT: () => $.SUBRULE($.object) },\n        { ALT: () => $.SUBRULE($.array) },\n        { ALT: () => $.CONSUME(True) },\n        { ALT: () => $.CONSUME(False) },\n        { ALT: () => $.CONSUME(Null) },\n      ]),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Illustrating Error Scenario and Content Assist Position (JavaScript)\nDESCRIPTION: This JavaScript example depicts several statements, some containing deliberate syntax errors, and demonstrates a scenario where content assist is requested immediately following an incomplete expression. The snippet's purpose is to show why sending only the immediate vicinity of the in-progress edit (as opposed to the entire script) to computeContentAssist results in more accurate suggestions, especially when errors are present earlier in the file. No external dependencies are required; the code is used for conceptual illustration of incremental parsing and its effects on content assist and fault tolerance.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/syntactic_content_assist.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nlet three = // syntax error, missing expression\nlet five = 5\nlet six = 1 + // <-- content assist requested after the '+'\nreturn Math.max(five, six)\n```\n\n----------------------------------------\n\nTITLE: Conditionally Skipping Validations and Tracing (JavaScript)\nDESCRIPTION: This snippet demonstrates conditionally enabling/disabling validations and tracing based on an environment variable. It uses the `skipValidations` and `traceInitPerf` configurations based on the `process.env[\"IN_MY_PACKAGE_LOCAL_TESTING\"]` environment variable. This offers control over validations and tracing, which is useful for local testing or specific scenarios.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/initialization_performance.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nclass MoreRealisticSkippedValidationsParser extends CstParser {\n  constructor() {\n    super([], {\n      // only run the validations when a certain env variable is set.\n      skipValidations: process.env[\"IN_MY_PACKAGE_LOCAL_TESTING\"] !== true,\n      // Always Trace init logs when in local testing to hopefully spot regressions.\n      traceInitPerf: process.env[\"IN_MY_PACKAGE_LOCAL_TESTING\"] === true,\n    });\n\n    this.performSelfAnalysis();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Terminal Consumption and CST Output - JavaScript\nDESCRIPTION: This example illustrates how non-terminals (rules) are consumed using `$.SUBRULE` and how they are represented in the CST output.  The 'qualifiedName' rule invokes the 'singleIdent' rule.  The resulting CST structure shows nested CstNode objects.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n$.RULE(\"qualifiedName\", () => {\n  $.SUBRULE($.singleIdent);\n});\n\n$.RULE(\"singleIdent\", () => {\n  $.CONSUME(Identifier);\n});\n\ninput = \"foo\";\n\noutput = {\n  name: \"qualifiedName\",\n  children: {\n    singleIdent: [\n      {\n        name: \"singleIdent\",\n        children: {\n          Identifier: [\"foo\"],\n        },\n      },\n    ],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Chevrotain Lexer Optimization Check in JavaScript\nDESCRIPTION: Shows how to instantiate a Chevrotain Lexer with the `ensureOptimizations` flag set to `true`. This configuration forces the lexer to verify that its character code optimizations can be applied to all token types, throwing an error if not and printing details to the console.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/performance.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Lexer } from \"chevrotain\";\nconst myLexer = new Lexer(\n  [\n    /* tokens */\n  ],\n  { ensureOptimizations: true },\n);\n```\n\n----------------------------------------\n\nTITLE: Utilizing Chevrotain ACTION DSL for Safe Side Effects in JavaScript\nDESCRIPTION: This snippet demonstrates the use of the Chevrotain ACTION DSL method to encapsulate semantic actions that modify global state outside the parser instance. By wrapping code in $.ACTION, side effects are restricted from executing during the parser's recording phase, which prevents premature or unwanted state changes. Dependencies include the Chevrotain parser API and correct definition of $.RULE and $.CONSUME with relevant token types. The code expects a global 'counter' variable and will increment it only during productive parsing, producing clean state transitions. Inputs are tokens processed by the parser, outputs are updated state and consumed tokens. Care should be taken to avoid reliance on global state across multiple parser instances.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/internals.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n$.RULE(\"myRule\", () => {\n  $.ACTION(() => {\n    // This code will no longer execute during the recording phase.\n    counter++;\n  });\n  $.CONSUME(MyToken);\n});\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Grammar for Re-Sync Recovery Examples - ANTLR\nDESCRIPTION: Defines an example JSON-like grammar snippet in ANTLR format used to illustrate re-sync recovery strategies in Chevrotain. This grammar specifies 'object', 'objectItem', and 'value' rules capturing object structures with key-value pairs and nested values. Required for context to understand re-sync behaviors on repeated tokens and token skipping. This snippet represents the minimal grammar to which parser error recovery heuristics apply.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step4_fault_tolerance.md#_snippet_2\n\nLANGUAGE: ANTLR\nCODE:\n```\nobject\n   : \"{\" objectItem (comma objectItem)* \"}\"\n\nobjectItem\n   : stringLiteral \":\" value\n\nvalue\n   : object | stringLiteral | number | ...\n```\n\n----------------------------------------\n\nTITLE: Resolving Common Prefix by Extracting Common Elements in ANTLR\nDESCRIPTION: Demonstrates refactoring a grammar to extract common prefixes using optional elements, creating a more efficient pattern.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\nmyRule:\n  \"A\" \"B\" (\"C\")?\n```\n\n----------------------------------------\n\nTITLE: Using CST Visitor to Produce AST in Chevrotain (JavaScript)\nDESCRIPTION: This snippet demonstrates usage of the parser and SQLToAstVisitor for transforming an input SQL query string into an AST using Chevrotain. It shows instantiating the parser (with CST output enabled) and visitor, lexing, parsing, error checking, and visiting the CST. Dependencies: SelectParser and selectLexer instances configured for the SQL grammar and visitor methods defined as in prior snippets. Input is a SQL query string; output is an AST object. Throws an error if parsing fails.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step3a_adding_actions_visitor.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// A new parser instance with CST output enabled.\nconst parserInstance = new SelectParser([], { outputCst: true });\n// Our visitor has no state, so a single instance is sufficient.\nconst toAstVisitorInstance = new SQLToAstVisitor();\n\nfunction toAst(inputText) {\n  // Lex\n  const lexResult = selectLexer.tokenize(inputText);\n  parserInstance.input = lexResult.tokens;\n\n  // Automatic CST created when parsing\n  const cst = parserInstance.selectStatement();\n  if (parserInstance.errors.length > 0) {\n    throw Error(\n      \"Sad sad panda, parsing errors detected!\\n\" +\n        parserInstance.errors[0].message,\n    );\n  }\n\n  // Visit\n  const ast = toAstVisitorInstance.visit(cst);\n  return ast;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Chevrotain Token with unicode and start_chars_hint\nDESCRIPTION: This snippet explains how to resolve the \"The regexp unicode flag is not currently supported by the regexp-to-ast library\" warning, by providing `start_chars_hint`. It demonstrates using the unicode flag and the surrogate pairs representation of characters.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// 'ðŸ’©' character\ncreateToken({\n  name: \"PileOfPoo\",\n  // \\u{xxxxx} 32bit unicode escape can only be used with the /u flag enabled.\n  pattern: /\\u{1F4A9}/u,\n  // The 'ðŸ’©' character is represented by surrogate pairs: '\\uD83D\\uDCA9'\n  // the start_chars_hint should only be provided the first of the pair.\n  start_chars_hint: [55357],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Chevrotain Token with alternative complement pattern\nDESCRIPTION: This example demonstrates how to redefine a pattern without using a complement set to avoid the optimization issue, as an alternative to the `start_chars_hint` approach. This example shows the XMLText token and provides a more optimized pattern.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst XMLText = createToken({\n  name: \"XMLText\",\n  // Equivalent to: /[^<&]+/ but a-lot less clear :(\n  // Note that:\n  //   - \"\\u0026\" === \"&\"\n  //   - \"\\u003C\" === \"<\"\n  pattern: /[\\u0000-\\u0025\\u0027-\\u003B\\u003D-\\uFFFF]+/,\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling CstNode Location Tracking - TypeScript\nDESCRIPTION: This snippet demonstrates how to enable CstNode location tracking by setting the `nodeLocationTracking` option in the CstParser constructor.  The available values are 'full' or 'onlyOffset'. Enabling this feature adds location information to the nodes, allowing for enhanced analysis.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { CstParser } from \"chevrotain\";\n\nclass SelectParser extends CstParser {\n  constructor() {\n    super([], {\n      nodeLocationTracking: \"full\",\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Input Reduction for Content Assist (JavaScript)\nDESCRIPTION: This illustrative JavaScript code shows a use-case scenario within a large source file, highlighting how content assist is requested inside a single function rather than the entire file. The example demonstrates that only the relevant function text should be sent to the computeContentAssist method, with the startRule parameter set accordingly (e.g., 'functionDeclaration'), thus optimizing parsing performance. No dependencies beyond Chevrotain itself are needed; the snippet serves to stress the advantage of incremental parsing and input minimization for editor features.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/syntactic_content_assist.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// line 1\n// .\n// .\n// .\n// line 600\nfunction foo() {\n  // content assist requested somewhere in this function\n}\n// line 610\n// .\n// .\n// .\n// line 1000\n```\n\n----------------------------------------\n\nTITLE: Defining Keyword and Identifier Token Types in Chevrotain (JavaScript)\nDESCRIPTION: This snippet illustrates how to define two tokens, a keyword ('for') and an identifier (alphabetic string), using Chevrotain's createToken function in JavaScript. The Identifier token uses a regular expression that matches any alphabetic sequence, potentially overlapping with reserved keywords. Dependencies include Chevrotain and proper import or instantiation of createToken. Inputs are the token definitions; outputs are token objects for the lexer configuration. Conflicts may arise if keyword-like strings are also valid identifiers.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst ForKeyword = createToken({\n  name: \"ForKeyword\",\n  pattern: /for/,\n});\n\nconst Identifier = createToken({\n  name: \"Identifier\",\n  pattern: /[a-zA-z]+/,\n});\n```\n\n----------------------------------------\n\nTITLE: Optional Productions and CST Output - JavaScript\nDESCRIPTION: This demonstrates how optional productions using `$.OPTION` affect the CST output. The 'Equals' and 'Integer' tokens are only present in the CST if they are encountered in the input. The first input doesn't include those tokens so they are not present. The second input does include the tokens so they are present in the output.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n$.RULE(\"variableStatement\", () => {\n  $.CONSUME(Var);\n  $.CONSUME(Identifier);\n  $.OPTION(() => {\n    $.CONSUME(Equals);\n    $.CONSUME(Integer);\n  });\n});\n\ninput1 = \"var x\";\n\noutput1 = {\n  name: \"variableStatement\",\n  children: {\n    Var: [\"var\"],\n    Identifier: [\"x\"],\n    // no \"Equals\" or \"Integer\" keys\n  },\n};\n\ninput2 = \"var x = 5\";\n\noutput2 = {\n  name: \"variableStatement\",\n  children: {\n    Var: [\"var\"],\n    Identifier: [\"x\"],\n    Equals: [\"=\"],\n    Integer: [\"5\"],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Grammar Rule with Alternation in Chevrotain - JavaScript\nDESCRIPTION: Defines a parser rule named \"value\" using Chevrotain's RULE DSL. It illustrates the use of the OR method to handle multiple alternatives, each consuming a different token or invoking another subrule. This snippet demonstrates the need for Chevrotain to \"understand\" grammar structure by knowing all alternatives beforehand. The OR method looks ahead to select the correct alternative during parsing. No dependencies beyond Chevrotainâ€™s parser DSL methods are required.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/internals.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"value\", () => {\n  // The choice of which alternative to pick\n  // is done by the \"OR\" (alternation) method, by **looking ahead** in the token vector.\n  // But making this choice requires **knowing** in advance the full structure of the grammar.\n  $.OR([\n    { ALT: () => $.CONSUME(StringLiteral) },\n    { ALT: () => $.CONSUME(NumberLiteral) },\n    { ALT: () => $.SUBRULE($.object) },\n    { ALT: () => $.SUBRULE($.array) },\n    { ALT: () => $.CONSUME(True) },\n    { ALT: () => $.CONSUME(False) },\n    { ALT: () => $.CONSUME(Null) },\n  ]);\n});\n```\n\n----------------------------------------\n\nTITLE: Default Pattern for Chevrotain Alternatives Array in JavaScript\nDESCRIPTION: Illustrates the default way of defining alternatives within a Chevrotain parsing rule using `$.OR`. This approach creates a new array of alternatives on *every* invocation of the rule, which can incur performance overhead for frequently called rules with many alternatives.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/performance.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"value\", () => {\n  $.OR([\n    // an array with seven alternatives\n    { ALT: () => $.CONSUME(StringLiteral) },\n    { ALT: () => $.CONSUME(NumberLiteral) },\n    { ALT: () => $.SUBRULE($.object) },\n    { ALT: () => $.SUBRULE($.array) },\n    { ALT: () => $.CONSUME(True) },\n    { ALT: () => $.CONSUME(False) },\n    { ALT: () => $.CONSUME(Null) },\n  ]);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Chevrotain Token with string literal\nDESCRIPTION: This snippet presents another solution for the \"The regexp unicode flag is not currently supported by the regexp-to-ast library\" warning, by defining the token pattern as a string literal instead of a regular expression.  String literals are optimized trivially.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\ncreateToken({\n  name: \"LCurley\",\n  // note that the pattern is a string literal, not a regExp literal.\n  pattern: \"{\",\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Grammar Rule Without Embedded Actions in Chevrotain CST Parser - JavaScript\nDESCRIPTION: Example showing a CstParser rule without embedded semantic actions to demonstrate fewer issues during the recording phase. The rule performs simple consumption of tokens and subrule invocation, facilitating safer parsing by separating grammar parsing from semantic handling, which is recommended to reduce embedded action side effects. This pattern avoids runtime exceptions during grammar recording since no code depends on actual token values at this stage.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/internals.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nclass JsonParser extends CstParser {\n  constructor() {\n    /* ... */\n    // This Grammar rule has no custom user semantic actions\n    // So it would not throw an unexpected exception during the recording phase...\n    $.RULE(\"objectItem\", () => {\n      $.CONSUME(StringLiteral);\n      $.CONSUME(Colon);\n      $.SUBRULE($.value);\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Chevrotain Token with line_breaks false\nDESCRIPTION: This snippet demonstrates explicitly setting `line_breaks` to `false` when defining a token. This helps the lexer to correctly compute line and column information.  It is crucial to specify `line_breaks` when using a custom pattern.  This addresses the \"Unable to identify line terminator usage in pattern\" warning.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst MyToken = createToken({\n  name: \"MyToken\",\n  pattern: /abc/,\n  line_breaks: false,\n});\nconst MultiLineStringLiteral = createToken({\n  name: \"MultiLineStringLiteral\",\n  pattern: /`[^`]*`/,\n  line_breaks: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Unsafe Semantic Checks on DSL Method Returns During Recording Phase - JavaScript\nDESCRIPTION: Shows an example of unsafe embedded semantic actions that perform runtime checks on the values returned from DSL methods like CONSUME. During the recording phase, CONSUME returns dummy tokens with placeholder images, which can cause logic errors such as parsing NaN and subsequently throwing exceptions. This snippet highlights the necessity to avoid executing code relying on actual token values during grammar recording to prevent failures. Usage of EmbeddedActionsParser with CONSUME and embedded semantic checks is demonstrated.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/internals.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nclass ErrorSemanticChecks extends EmbeddedActionsParser {\n  constructor() {\n    /* ... */\n    $.RULE(\"semanticCheckRule\", () => {\n      // During the recording phase `CONSUME` will return a \"dummy\" IToken value.\n      const myNumTok = $.CONSUME(NumberTok);\n      // The \"dummy\" IToken `image` is not a number so this will evaluate to NaN.\n      const numValue = parseInt(myNumTok.image);\n\n      // Our embedded semantic check will **always** throw during the recording phase because\n      // the \"mocked\" IToken returned by `CONSUME` would never be a valid integer.\n      if (isNaN(numValue)) {\n        throw Error(\"Unexpected Number Value!\");\n      }\n\n      return numValue;\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Chevrotain Lexer with positionTracking\nDESCRIPTION: This snippet demonstrates how to initialize a Chevrotain Lexer with the `positionTracking` configuration option set to \"onlyOffset\".  This disables line and column tracking.  This is one way to resolve the \"No LINE_BREAKS Found\" warning.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst myTokens = [IntegerLiteral, StringLiteral, WhiteSpace /*, ... */];\nconst myLexer = new chevrotain.Lexer([myTokens], {\n  positionTracking: \"onlyOffset\",\n});\n```\n\n----------------------------------------\n\nTITLE: Fault Tolerance with CST Output - JavaScript\nDESCRIPTION: This example demonstrates how error recovery works with CST output. Even with a parse error, a partially formed CST node is created and marked with the `recoveredNode` property. This partial CST allows for further analysis and potential error correction.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\n$.RULE(\"SelectClause\", () => {\n  $.CONSUME(Select);\n  $.CONSUME2(Identifer);\n  $.CONSUME(From);\n  $.CONSUME3(Identifer);\n  $.CONSUME(Where);\n  $.SUBRULE($.expression);\n});\n\n// mismatch token due to typo at \"wherrrre\", parsing halts and re-syncs to upper rule so\n// the suffix \"wherrrre age > 25\" is not parsed.\ninput = \"select age from persons wherrrre age > 25\";\n\noutput = {\n  name: \"SelectClause\",\n  children: {\n    Select: [\"select\"],\n    Identifier: [\"age, persons\"],\n    From: [\"from\"],\n    // No \"Where\" key d,ue to the parse error\n    // No \"expression\" key due to the parse error\n  },\n  // This marks a recovered node.\n  recoveredNode: true,\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Chevrotain Token with custom patterns\nDESCRIPTION: This example shows how to use a custom token pattern (using `exec` method) and how to correctly specify the `line_breaks` option. It's a solution for the warning \"A Custom Token Pattern should specify the <line_breaks> option\".  If not provided the `line_breaks` defaults to true when using custom patterns.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst MyCustomToken = createToken({\n  name: \"MyCustomToken\",\n  pattern: { exec: matchFunction },\n  line_breaks: false,\n});\nconst MyCustomMultiLineToken = createToken({\n  name: \"MyCustomMultiLineToken\",\n  pattern: { exec: matchFunction2 },\n  line_breaks: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Safe Usage of Embedded Semantic Actions in Chevrotain Parser - JavaScript\nDESCRIPTION: Provides a safe example of embedded semantic actions inside a Chevrotain parser using EmbeddedActionsParser. The snippet demonstrates how the CONSUME and SUBRULE methods reliably return token objects (matching the IToken interface) even during grammar recording phase, preventing runtime errors. It constructs an AST node for a key-value pair by consuming tokens and extracting string literal values, emphasizing safe extraction (e.g., substring operations) on token images while avoiding side effects during recording.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/internals.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nclass SafeEmbeddedActionsExample extends EmbeddedActionsParser {\n  constructor() {\n    /* ... */\n    $.RULE(\"objectItem\", () => {\n      // Usage of the Parsing DSL methods is always safe, otherwise the whole concept of \"grammar recording\" would not work...\n      const keyTok = $.CONSUME(StringLiteral);\n      $.CONSUME(Colon);\n      const valAst = $.SUBRULE($.value);\n\n      // strip away the quotes from the string literal\n      // Note that even during the \"recording phase\" the CONSUME method will return an object that matches the IToken interface\n      // to reduce potential runtime errors, so this is safe.\n      const keyName = keyTok.image.substring(1, keyTok.image.length - 1);\n\n      // Assembling this JS object literal won't cause any issues because\n      // we are not actually doing anything with the returned values.\n      // Only assigning them to properties in a new object (which is always safe)\n      return {\n        type: \"keyValuePair\",\n        key: keyName,\n        value: valAst,\n      };\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Chevrotain Parser Reset for Instance State Management in JavaScript\nDESCRIPTION: This snippet defines a custom parser class inheriting from Chevrotain's CstParser, adding an instance variable and overriding the reset method to ensure parser state is properly re-initialized for each new input. By placing side effects such as state increments inside the grammar rule and implementing a tailored reset, the parser maintains deterministic behavior and avoids state pollution between parsing sessions. Dependencies include Chevrotain's CstParser base class and correct setup of parsing rules. The parser's instanceCounter is incremented within the rule and reset on every call to reset(). Inputs involve new parser invocations; outputs are reflected in the instanceCounter variable. This design is best for instance-specific state and should not be confused with global side effects.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/internals.md#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass FixedSideEffectsParser extends CstParser {\n  constructor() {\n    //\n    this.instanceCounter = 0;\n    /* ... */\n    $.RULE(\"myRule\", () => {\n      // The counter will be incremented during the recording phase.\n      this.instanceCounter++;\n      $.CONSUME(MyToken);\n    });\n  }\n\n  reset() {\n    this.instanceCounter = 0;\n    super.reset();\n  }\n}\n\nconst parser = new FixedSideEffectsParser();\nconsole.log(parser.instanceCounter); // -> 0\n```\n\n----------------------------------------\n\nTITLE: Simple Rule and CST Output - JavaScript\nDESCRIPTION: This example shows a simple rule definition using `$.RULE` and the corresponding CST output. The rule is 'qualifiedName', and the output shows a CST node with that name and an empty children object as no tokens are consumed.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n$.RULE(\"qualifiedName\", () => {});\n\ninput = \"\";\n\noutput = {\n  name: \"qualifiedName\",\n  children: {},\n};\n```\n\n----------------------------------------\n\nTITLE: Using a default CSTVisitor in Chevrotain for partial CST processing in JavaScript\nDESCRIPTION: This snippet demonstrates how to extend the default base CSTVisitorWithDefaults to implement only specific visit methods, such as extracting column names from a fromClause. Unlike custom visitors, it does not support returning values from visit methods, as the default implementation only traverses the CST.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\n// The base Visitor Class can be accessed via a Parser **instance**.\nconst BaseCstVisitorWithDefaults = myParserInstance.getBaseCstVisitorConstructorWithDefaults();\n\nclass SqlColumnNamesVisitor extends BaseCstVisitorWithDefaults {\n  constructor() {\n    super();\n    this.result = [];\n    this.validateVisitor();\n  }\n\n  fromClause(ctx) {\n    // collect only the names of the columns\n    this.result.push(ctx.Identifier[0].image);\n  }\n\n  // All other visit methods will be \"filled\" automatically with the default implementation.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the SELECT Clause Rule with Chevrotain Embedded Actions in JavaScript\nDESCRIPTION: Illustrates the implementation of the `selectClause` rule using embedded actions. It consumes the `Select` keyword and then uses `AT_LEAST_ONE_SEP` to parse comma-separated identifiers. Inside the loop, `CONSUME(Identifier)` returns the token, and its `image` property (the actual text) is pushed into the `columns` array. The rule returns an object representing the SELECT clause AST node.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step3b_adding_actions_embedded.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"selectClause\", () => {\n  let columns = [];\n\n  $.CONSUME(Select);\n  $.AT_LEAST_ONE_SEP({\n    SEP: Comma,\n    DEF: () => {\n      // accessing a token's original text via the `image` property\n      columns.push($.CONSUME(Identifier).image);\n    },\n  });\n\n  return {\n    type: \"SELECT_CLAUSE\",\n    columns: columns,\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Example SQL Select Statements\nDESCRIPTION: Illustrates the simple SQL SELECT syntax that the Chevrotain lexer tutorial aims to parse. These examples show basic SELECT statements with columns, tables, and optional WHERE clauses.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step1_lexing.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nSELECT column1 FROM table2\nSELECT name, age FROM persons WHERE age > 100\n...\n```\n\n----------------------------------------\n\nTITLE: Tokenizing Input Demonstrating Identifier Split After Lexer Reordering (JavaScript)\nDESCRIPTION: This snippet shows the consequences of listing the keyword token first: tokenizing an input like 'forward' splits it into a ForKeyword and an Identifier. It demonstrates how Chevrotain processes the input and displays the resulting token images. Chevrotain and the token definitions from earlier are required dependencies. Input: string to tokenize; output: array of token objects indicating split matches.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst myLexer = new chevrotain.Lexer([ForKeyword, Identifier]);\n\n// [\n//    {image:\"for\"}\n//    {image:\"ward\"}\n// ]\nconst tokensResult = myLexer.tokenize(\"forward\");\n```\n\n----------------------------------------\n\nTITLE: Debugging Chevrotain Parser Rules in JavaScript\nDESCRIPTION: Explains how to debug Chevrotain parsers by adding standard JavaScript `debugger` statements directly within the grammar rule implementations. Since the rules are executable JavaScript code, standard debugging tools can be used without needing code generation steps.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step2_parsing.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// selectClause\n//   : \"SELECT\" IDENTIFIER (\",\" IDENTIFIER)*;\n$.RULE(\"selectClause\", () => {\n  $.CONSUME(Select);\n  // Can be debugged directly! no code generation.\n  debugger;\n  $.AT_LEAST_ONE_SEP({\n    SEP: Comma,\n    DEF: () => {\n      $.CONSUME(Identifier);\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Ignoring All Ambiguities in an Alternation in JavaScript\nDESCRIPTION: Demonstrates how to explicitly ignore all ambiguities in an alternation using the IGNORE_AMBIGUITIES property on the OR method.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n$.OR({\n  IGNORE_AMBIGUITIES: true,\n  DEF: [\n    { ALT: () => $.SUBRULE($.myRule) },\n    { ALT: () => $.SUBRULE($.myOtherRule) },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Example of Lasting Side Effects During Grammar Recording Phase - JavaScript\nDESCRIPTION: Illustrates a common problem when side effects are performed inside parser rules during the grammar recording phase. Specifically, the example increments an external counter each time a rule is recorded, which leads to unintended lasting side effects affecting parser logic and state outside the intended parsing runtime. This highlights Assumption 2 that grammar recording should avoid lasting side effects to maintain correct parsing behavior.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/internals.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nlet ruleCounter = 0;\nclass SideEffectsParser extends CstParser {\n  constructor() {\n    /* ... */\n    $.RULE(\"myRule\", () => {\n      // The counter will be incremented during the recording phase.\n      counter++;\n      $.CONSUME(MyToken);\n    });\n  }\n}\n\nconst parser = new SideEffectsParser();\n// We expected this to be `0`...\nconsole.log(counter); // -> 1\n```\n\n----------------------------------------\n\nTITLE: Deprecating Token Type Class Syntax in Favor of createToken API (JavaScript)\nDESCRIPTION: Illustrates the discontinuation of using ES6 classes for defining TokenTypes in Chevrotain starting version 2.0.0. It recommends using the createToken factory function to define tokens with name and pattern properties instead. This update aligns with the library's internal expectations and improves token interoperability and consistency.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/BREAKING_CHANGES.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n// No longer officially supported\nclass Identifier {\n  static pattern = /[a-zA-Z_]\\w+/;\n}\n\n// Use the createToken API instead\nconst Identifier = createToken({\n  name: \"Identifier\",\n  pattern: /[a-zA-Z_]\\w+/, \n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Repetition and Alternation in Chevrotain Rules (JavaScript)\nDESCRIPTION: Demonstrates implementing grammar rules with repetition and alternation using Chevrotain's parsing DSL. The `selectClause` rule uses `AT_LEAST_ONE_SEP` to handle one or more `Identifier` tokens separated by `Comma` tokens, following a `Select` token. The `atomicExpression` rule uses `OR` to define an alternation, accepting either an `Integer` or an `Identifier` token.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step2_parsing.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"selectClause\", () => {\n  $.CONSUME(Select);\n  $.AT_LEAST_ONE_SEP({\n    SEP: Comma,\n    DEF: () => {\n      $.CONSUME(Identifier);\n    },\n  });\n});\n\n// atomicExpression\n//    : INTEGER | IDENTIFIER\n$.RULE(\"atomicExpression\", () => {\n  $.OR([\n    { ALT: () => $.CONSUME(Integer) },\n    { ALT: () => $.CONSUME(Identifier) },\n  ]);\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Chevrotain via npm in Shell\nDESCRIPTION: This snippet demonstrates how to install the Chevrotain library using npm, the default package manager for Node.js. Prerequisites include having Node.js and npm installed in the environment. The command adds Chevrotain as a dependency in the current project, updating the package.json file accordingly.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/chevrotain/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install chevrotain\n```\n\n----------------------------------------\n\nTITLE: Ambiguous Alternatives Requiring Large Lookahead in ANTLR\nDESCRIPTION: Example of a grammar requiring five tokens of lookahead to disambiguate between alternatives, which exceeds the default maxLookahead value.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\nfiveTokensLookahead:\n  \"A\" \"B\" \"C\" \"D\" \"1\" |\n  \"A\" \"B\" \"C\" \"D\" \"2\"\n```\n\n----------------------------------------\n\nTITLE: Installing Chevrotain via Yarn in Shell\nDESCRIPTION: This snippet shows how to install Chevrotain using yarn, an alternative JavaScript package manager. Yarn must be installed prior to running this command. Executing this command adds Chevrotain to the project's dependencies and updates the yarn.lock file.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/chevrotain/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn add chevrotain\n```\n\n----------------------------------------\n\nTITLE: Enabling Initialization Performance Tracing in Lexer (JavaScript)\nDESCRIPTION: This snippet shows how to enable initialization performance tracing in a Chevrotain lexer.  It utilizes the `traceInitPerf` configuration option.  Setting this option to true enables printing tracing info to the console. This provides insights into the lexer's initialization process.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/initialization_performance.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Will print tracing info to the console.\nnew Lexer([], {\n  // Note `traceInitPerf` may also accept numerical values\n  traceInitPerf: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Refactoring Parser Construction and Input Handling in Chevrotain (JavaScript)\nDESCRIPTION: Demonstrates the migration from the old parser constructor that accepted a token vector as an input argument to the new approach where the parser's 'input' setter is used to assign the token vector after construction. This requires modifying parser subclasses to accept only configuration objects in their constructors and setting token inputs via the 'input' property. The snippet shows example class definitions and instance creations for both the old and new APIs, facilitating compatibility with Chevrotain 4.0.0+.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/BREAKING_CHANGES.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Old API\nclass MyOldParser extends Parser {\n  constructor(input, config) {\n    super(input, allTokens, config);\n  }\n}\n\nconst oldInstance = new MyOldParser(\n  [\n    /* token vector */\n  ],\n  {},\n);\n\n// New API\nclass MyNewParser extends Parser {\n  constructor(config) {\n    super(allTokens, config);\n  }\n}\n\nconst newInstance = new MyNewParser({});\nnewInstance.input = [\n  /* token vector */\n];\n```\n\n----------------------------------------\n\nTITLE: General Re-Sync Recovery Example with Nested Objects and Syntax Error - JavaScript\nDESCRIPTION: Demonstrates a nested JSON example where an invalid token (extra colon) causes a parsing error unrecoverable by single token insertion or deletion. The parser performs general re-sync recovery by skipping tokens until reaching a token suitable for resuming parsing (closest objectItem comma delimiter). The example shows stack-based recovery behavior with token skipping, partial CST node generation, and continuation of successful parsing of subsequent properties. Used to explain generalized error recovery beyond simple insertion or deletion.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step4_fault_tolerance.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n{\n\t\"firstName\": \"John\",\n\t\"someData\":\n\t   { \"bad\" :: \"part\" }, // <-- too many colons in the nested object\n\t\"isAlive\": true,\n\t\"age\": 25\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing the Global maxLookahead Value (JavaScript)\nDESCRIPTION: This snippet demonstrates setting the `maxLookahead` configuration option to reduce the initialization time of a Chevrotain parser. The `maxLookahead` value impacts pre-computation and caching lookahead functions. Lowering this value can improve initialization performance, but it affects the grammar's lookahead capabilities.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/initialization_performance.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nclass LowLookaheadParser extends CstParser {\n  constructor() {\n    super([], {\n      // By default this value is 3\n      maxLookahead: 2,\n    });\n\n    this.performSelfAnalysis();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: RULE_NO_RESYNC Removal (javascript)\nDESCRIPTION: This snippet illustrates the removal of the RULE_NO_RESYNC DSL method.  All usages of RULE_NO_RESYNC must be replaced with an equivalent RULE call using the IRuleConfig resyncEnabled property. This change promotes a more consistent API and allows for better configuration of resynchronization behavior. The code shows the transition from the old deprecated method to the new configuration-based approach.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/CHANGELOG.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// old deprecated form\nthis.RULE_NO_RESYNC(\"createStmt\", function () {\n  /* ... */\n});\n\n// new form\nthis.RULE(\n  \"createStmt\",\n  function () {\n    /* ... */\n  },\n  { resyncEnabled: false },\n);\n```\n\n----------------------------------------\n\nTITLE: Illustrating Single Token Deletion Fault Tolerance in Chevrotain - JavaScript\nDESCRIPTION: Shows how Chevrotain recovers from a redundant token error by deleting an unexpected token X when the expected token Y appears immediately after it. The code example uses JavaScript JSON input showing a valid JSON object and one containing an extra redundant closing curly bracket. Dependencies include Chevrotain parser configured for this grammar. Inputs are JSON strings with and without the redundant token; output is parsed stream where the redundant token is effectively skipped.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step4_fault_tolerance.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n// GOOD\n{ \"key\" : 666}\n\n// BAD, redundant \"}\"\n{ \"key\" }: 666}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Error Message Provider in Chevrotain 7.0.0+\nDESCRIPTION: Example of implementing the IParserErrorMessageProvider interface, showing how to create custom error messages while deferring to default behavior when needed.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/BREAKING_CHANGES.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  defaultParserErrorProvider,\n  IParserErrorMessageProvider,\n  IToken,\n  TokenType,\n} from \"chevrotain\";\n\nclass myCustomErrorMsgProvider implements IParserErrorMessageProvider {\n  buildNoViableAltMessage(options: {\n    expectedPathsPerAlt: TokenType[][][];\n    actual: IToken[];\n    previous: IToken;\n    customUserDescription: string;\n    ruleName: string;\n  }): string {\n    // Custom user error message builder\n    return \"sad sad panda:\" + options.actual[0].image;\n  }\n\n  buildEarlyExitMessage(options: {\n    expectedIterationPaths: TokenType[][];\n    actual: IToken[];\n    previous: IToken;\n    customUserDescription: string;\n    ruleName: string;\n  }): string {\n    // invoking the default error message string builder.\n    return defaultParserErrorProvider.buildEarlyExitMessage(options);\n  }\n\n  // Implementation of other properties from `IParserErrorMessageProvider`\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding maxLookahead for individual DSL (JavaScript)\nDESCRIPTION: This snippet shows how to override the global `maxLookahead` setting for specific DSL methods, enhancing the lookahead capabilities for specific parts of the grammar. It shows using the `MAX_LOOKAHEAD` property to set the lookahead for the `OR` operator.  This allows for selective adjustments to lookahead requirements.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/initialization_performance.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nclass LowLookaheadParser extends CstParser {\n  constructor() {\n    super([], {\n      // Globally **only one** token lookahead.\n      maxLookahead: 1,\n    });\n\n    $.RULE(\"value\", () => {\n      $.OR({\n        // We need **two** tokens lookahead to distinguish between these two alternatives\n        MAX_LOOKAHEAD: 2,\n        DEF: [\n          {\n            ALT: () => {\n              $.CONSUME(A);\n              $.CONSUME(B);\n            },\n          },\n          {\n            ALT: () => {\n              $.CONSUME(A);\n              $.CONSUME(C);\n            },\n          },\n        ],\n      });\n    });\n\n    this.performSelfAnalysis();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating the Chevrotain Lexer\nDESCRIPTION: Demonstrates creating a Chevrotain Lexer instance by passing an ordered array of all previously defined token types to the `Lexer` constructor. The order of tokens in the array is crucial as it determines matching priority; the first pattern to match is chosen. Whitespace is often placed first for performance, and keywords must precede identifiers if `longer_alt` is not used.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step1_lexing.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// note we are placing WhiteSpace first as it is very common thus it will speed up the lexer.\nlet allTokens = [\n  WhiteSpace,\n  // \"keywords\" appear before the Identifier\n  Select,\n  From,\n  Where,\n  Comma,\n  // The Identifier must appear after the keywords because all keywords are valid identifiers.\n  Identifier,\n  Integer,\n  GreaterThan,\n  LessThan,\n];\nlet SelectLexer = new Lexer(allTokens);\n```\n\n----------------------------------------\n\nTITLE: Tokenizing Input with the Chevrotain Lexer\nDESCRIPTION: Shows the final step of using the created `SelectLexer` instance. The `tokenize` method is called with the input string (`inputText`), returning a `lexingResult` object. This object contains the array of recognized tokens (`tokens`) and an array of any errors encountered during lexing (`errors`).\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step1_lexing.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nlet inputText = \"SELECT column1 FROM table2\";\nlet lexingResult = SelectLexer.tokenize(inputText);\n```\n\n----------------------------------------\n\nTITLE: Implementing selectClause Visitor Method in JavaScript\nDESCRIPTION: This snippet implements a visitor method for the 'selectClause' grammar rule in a Chevrotain CST Visitor subclass. The method takes a 'ctx' argument containing rule children, extracts column identifiers, and outputs a structured AST node. The visitor must inherit from the base SQL visitor class and should call validateVisitor in the constructor. Output is an object describing the SELECT_CLAUSE and its columns.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step3a_adding_actions_visitor.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass SQLToAstVisitor extends BaseSQLVisitor {\n  constructor() {\n    super();\n    this.validateVisitor();\n  }\n\n  // The Ctx argument is the current CSTNode's children.\n  selectClause(ctx) {\n    // Each Terminal or Non-Terminal in a grammar rule are collected into\n    // an array with the same name(key) in the ctx object.\n    let columns = ctx.Identifier.map((identToken) => identToken.image);\n\n    return {\n      type: \"SELECT_CLAUSE\",\n      columns: columns,\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Grammar with Infinite Lookahead Requirements in ANTLR\nDESCRIPTION: Demonstrates a grammar pattern that would require an infinite lookahead to disambiguate between alternatives.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_5\n\nLANGUAGE: antlr\nCODE:\n```\ninfiniteTokensLookahead:\n  (\"A\")* \"1\"  |\n  (\"A\")* \"2\"\n```\n\n----------------------------------------\n\nTITLE: Inserting Debugger Statements in Chevrotain Rules - JavaScript\nDESCRIPTION: Demonstrates how to place standard JavaScript `debugger` statements within Chevrotain parser rule definitions (using `$.RULE`, `$.CONSUME`, `$.SUBRULE`). This technique allows you to pause execution at specific points during parsing flow when a debugger is attached, enabling inspection of the parser's state using standard debugging tools.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/easy_debugging.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"statement\", () => {\n  debugger;\n  $.RULE(\"objectItem\", () => {\n    $.CONSUME(StringLiteral)\n    debugger;\n    $.CONSUME(Colon);\n    $.SUBRULE($.value);\n  });\n\n```\n\n----------------------------------------\n\nTITLE: Custom Token Pattern with Payload for String Literals in Chevrotain - JavaScript\nDESCRIPTION: Defines a matcher for string literals that both uses a RegExp with the sticky flag and attaches additional extracted data as a payload to the match result. The matcher caches the RegExp for performance and computes a payload by removing surrounding quotes before storing it on the result object. The token is created via createToken with explicit line_breaks specified. When lexing, matched tokens will include a payload property. Inputs are quoted string literals, outputs are tokens with extracted payload values.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/custom_token_patterns.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n// We define the regExp only **once** (outside) to avoid performance issues.\nconst stringLiteralPattern =\n  /\"(?:[^\\\\\"]|\\\\(?:[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/y;\nfunction matchStringLiteral(text, startOffset) {\n  // using 'y' sticky flag (Note it is not supported on IE11...)\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky\n  stringLiteralPattern.lastIndex = startOffset;\n\n  // Note that just because we are using a custom token pattern\n  // Does not mean we cannot implement it using JavaScript Regular Expressions...\n  const execResult = stringLiteralPattern.exec(text);\n  if (execResult !== null) {\n    const fullMatch = execResult[0];\n    // compute the payload\n    const matchWithOutQuotes = fullMatch.substr(1, fullMatch.length - 2);\n    // attach the payload\n    execResult.payload = matchWithOutQuotes;\n  }\n\n  return execResult;\n}\n\nconst StringLiteral = createToken({\n  name: \"StringLiteral\",\n  pattern: matchStringLiteral,\n  // custom patterns should explicitly specify the line_breaks option.\n  line_breaks: false,\n});\n\n// When we lex a StringLiteral text a \"payload\" property will now exist on the resulting token object.\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Grammar Rule using Chevrotain DSL (JavaScript)\nDESCRIPTION: Shows how to translate the `selectStatement` grammar rule into Chevrotain's JavaScript DSL using `RULE`, `SUBRULE`, and `OPTION`. It demonstrates mapping non-terminals (like `selectClause` and `fromClause`) to `SUBRULE` and optional parts (`?` indicating `whereClause` is optional) to `OPTION` within the parser's context (`this` or `$`).\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step2_parsing.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// selectStatement\n//    : selectClause fromClause (whereClause)?;\n\nconst $ = this;\n$.RULE(\"selectStatement\", () => {\n  $.SUBRULE($.selectClause);\n  $.SUBRULE($.fromClause);\n  $.OPTION(() => {\n    $.SUBRULE($.whereClause);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Using chevrotain's CSTVisitor class to traverse CST in JavaScript\nDESCRIPTION: This example shows how to extend Chevrotain's generated BaseCstVisitor class to create a safer and less error-prone CST traversal. It includes implementing specific visitor methods for selectStatement, columnsList, and fromClause, utilizing this.visit to recurse. The constructor validates visitor correctness.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n// The base Visitor Class can be accessed via a Parser **instance**.\nconst BaseCstVisitor = myParserInstance.getBaseCstVisitorConstructor();\n\nclass SqlToAstVisitor extends BaseCstVisitor {\n  constructor() {\n    super();\n    // This helper will detect any missing or redundant methods on this visitor\n    this.validateVisitor();\n  }\n\n  selectStatement(ctx) {\n    // ctx.columnsList is an array, while this.visit accepts a CSTNode\n    // but if an array is passed to this.visit it will act as though the first element of the array has been passed.\n    // this means \"this.visit(ctx.columnsList)\" is equivalent to \"this.visit(ctx.columnsList[0])\"\n    let columnsListAst = this.visit(ctx.columnsList);\n    let fromClauseAst = this.visit(ctx.fromClause);\n\n    return {\n      type: \"SelectStatementAst\",\n      columns: columnsListAst,\n      from: fromClauseAst,\n    };\n  }\n\n  columnsList(ctx) {\n    let columnName = ctx.identifier[0].image;\n    /*...*/\n  }\n\n  // Optional \"IN\" argument\n  fromClause(ctx, inArg) {\n    /*...*/\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Terminal Consumption and CST Output - JavaScript\nDESCRIPTION: This snippet demonstrates how terminals are consumed using `$.CONSUME` and how they appear in the CST output. The 'qualifiedName' rule consumes 'Identifier' and 'Dot' tokens, which are then represented in the 'children' object of the CST node.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n$.RULE(\"qualifiedName\", () => {\n  $.CONSUME(Identifier);\n  $.CONSUME(Dot);\n  $.CONSUME2(Identifier);\n});\n\ninput = \"foo.bar\";\n\noutput = {\n  name: \"qualifiedName\",\n  children: {\n    Dot: [\".\"],\n    Identifier: [\"foo\", \"bar\"],\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Structuring a Chevrotain Parser Class in JavaScript\nDESCRIPTION: Defines the basic structure of a Chevrotain parser class (`SelectParser`) extending `CstParser`. It includes importing necessary components, passing the list of all expected tokens (`allTokens`) to the `super` constructor to define the parser's vocabulary, implementing a grammar rule (`selectStatement`) within the constructor, and crucially calling `performSelfAnalysis` at the end of the constructor to process the grammar.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step2_parsing.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { CstParser } from \"chevrotain\";\n\nconst allTokens = [\n  WhiteSpace,\n  Select,\n  From,\n  Where,\n  Comma,\n  Identifier,\n  Integer,\n  GreaterThan,\n  LessThan,\n];\n\nclass SelectParser extends CstParser {\n  constructor() {\n    super(allTokens);\n\n    const $ = this;\n\n    $.RULE(\"selectStatement\", () => {\n      $.SUBRULE($.selectClause);\n      $.SUBRULE($.fromClause);\n      $.OPTION(() => {\n        $.SUBRULE($.whereClause);\n      });\n    });\n\n    this.performSelfAnalysis();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: CstNode Type Definition - TypeScript\nDESCRIPTION: These TypeScript type definitions define the structure of a CST node. CstElement can be either a token or another CstNode.  CstChildrenDictionary defines a dictionary with the node's children. CstNode represents a node with a name, children, and an optional flag for recovery in case of error\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type CstElement = IToken | CstNode\nexport type CstChildrenDictionary = { [elementName:string]:CstElement[] }\n\nexport interface CstNode {\n    readonly name:string\n\n    readonly children:CstChildrenDictionary\n\n    readonly recoveredNode?:boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Integer Token with Custom Pattern Function in Chevrotain - JavaScript\nDESCRIPTION: Implements a custom matcher function matchInteger to recognize sequences of digits starting at a specific offset in the input text, conforming to Chevrotain's ICustomPattern interface. The example demonstrates attaching the matcher to a token definition via createToken, optionally optimizing using the start_chars_hint property. The custom pattern behaves like a regular expression with a sticky flag and must return null for no match or a result array for matches. Used for tokens not easily captured with RegExp.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/custom_token_patterns.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction matchInteger(text, startOffset) {\n  let endOffset = startOffset;\n  let charCode = text.charCodeAt(endOffset);\n  // 0-9 digits\n  while (charCode >= 48 && charCode <= 57) {\n    endOffset++;\n    charCode = text.charCodeAt(endOffset);\n  }\n\n  // No match, must return null to conform with the RegExp.prototype.exec signature\n  if (endOffset === startOffset) {\n    return null;\n  } else {\n    let matchedString = text.substring(startOffset, endOffset);\n    // according to the RegExp.prototype.exec API the first item in the returned array must be the whole matched string.\n    return [matchedString];\n  }\n}\n\ncreateToken({\n  name: \"IntegerToken\",\n  pattern: { exec: matchInteger },\n\n  // Optional property that will enable optimizations in the lexer\n  // See: https://chevrotain.io/documentation/11_0_3/interfaces/ITokenConfig.html#start_chars_hint\n  start_chars_hint: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Identifier and Integer Tokens in Chevrotain\nDESCRIPTION: Shows how to define tokens for more complex patterns like variable identifiers and integer literals using appropriate regular expressions within the `chevrotain.createToken` function. Identifiers match sequences starting with a letter followed by word characters, and Integers match zero or sequences starting with a non-zero digit followed by digits.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step1_lexing.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst Identifier = createToken({ name: \"Identifier\", pattern: /[a-zA-Z]\\w*/ });\n\nconst Integer = createToken({ name: \"Integer\", pattern: /0|[1-9]\\d*/ });\n```\n\n----------------------------------------\n\nTITLE: Initializing Chevrotain Parser with Embedded Actions in JavaScript\nDESCRIPTION: Shows how to enable embedded actions by extending the `EmbeddedActionsParser` class instead of `CstParser`. The constructor calls the superclass constructor, passing the token vocabulary, which is standard practice for Chevrotain parsers.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step3b_adding_actions_embedded.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst { EmbeddedActionsParser } = require(\"chevrotain\");\n\nclass SelectParserEmbedded extends EmbeddedActionsParser {\n  constructor() {\n    super(tokenVocabulary);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reusing Chevrotain Parser Instance in JavaScript\nDESCRIPTION: Demonstrates the recommended pattern for using a Chevrotain parser by creating a single instance and reusing it for multiple inputs. This avoids the cost of repeated initialization and allows JavaScript engine optimizations. The parser's state is reset by assigning a new input array.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/performance.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// reuse the same parser instance.\nconst parser = new JsonParser([]);\n\nmodule.exports = function (text) {\n  const lexResult = JsonLexer.tokenize(text);\n\n  // setting a new input will RESET the parser instance's state.\n  parser.input = lexResult.tokens;\n\n  const value = parser.json();\n\n  return {\n    value: value,\n    lexErrors: lexResult.errors,\n    parseErrors: parser.errors,\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Complete Token Definitions for SQL Select Lexer\nDESCRIPTION: Provides the full set of token definitions required for the simple SQL SELECT language lexer using `chevrotain.createToken`. It includes keywords (SELECT, FROM, WHERE), punctuation (Comma), literals (Identifier, Integer), operators (GreaterThan, LessThan), and skipped whitespace. It demonstrates the use of `longer_alt: Identifier` on keywords to resolve ambiguity, ensuring keywords are matched preferentially over identifiers when a string could be either.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step1_lexing.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst Identifier = createToken({ name: \"Identifier\", pattern: /[a-zA-Z]\\w*/ });\n// We specify the \"longer_alt\" property to resolve keywords vs identifiers ambiguity.\n// See: https://github.com/chevrotain/chevrotain/blob/master/examples/lexer/keywords_vs_identifiers/keywords_vs_identifiers.js\nconst Select = createToken({\n  name: \"Select\",\n  pattern: /SELECT/,\n  longer_alt: Identifier,\n});\nconst From = createToken({\n  name: \"From\",\n  pattern: /FROM/,\n  longer_alt: Identifier,\n});\nconst Where = createToken({\n  name: \"Where\",\n  pattern: /WHERE/,\n  longer_alt: Identifier,\n});\n\nconst Comma = createToken({ name: \"Comma\", pattern: /,/ });\n\nconst Integer = createToken({ name: \"Integer\", pattern: /0|[1-9]\\d*/ });\n\nconst GreaterThan = createToken({ name: \"GreaterThan\", pattern: />/ });\n\nconst LessThan = createToken({ name: \"LessThan\", pattern: /</ });\n\nconst WhiteSpace = createToken({\n  name: \"WhiteSpace\",\n  pattern: /\\s+/,\n  group: chevrotain.Lexer.SKIPPED,\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring Integer Token with RegExp Pattern in Chevrotain - JavaScript\nDESCRIPTION: Defines an IntegerToken token for Chevrotain's lexer using a JavaScript regular expression that matches one or more digits. Relies on the standard createToken and a RegExp pattern argument. Requires Chevrotain's lexer utilities and is suitable for simple numeric tokens. Input is any text for tokenization, output is matched integer tokens.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/custom_token_patterns.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst IntegerToken = createToken({ name: \"IntegerToken\", pattern: /\\d+/ });\n```\n\n----------------------------------------\n\nTITLE: Correct Caching of Alternatives by Returning Value in Chevrotain\nDESCRIPTION: Shows the **correct** way to cache alternatives even when needing to capture results. The `ALT` function returns the value, and the result is assigned outside the cached array definition, avoiding the closure issue and allowing the array to be effectively cached and reused.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/performance.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// GOOD\n$.RULE(\"value\", function () {\n  let result;\n  // no closure for the result variable, we use the returned value of the OR instead.\n  result = $.OR(\n    $.c1 ||\n      ($.c1 = [\n        {\n          ALT: () => {\n            return $.CONSUME(StringLiteral);\n          },\n        },\n      ]),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring Integer Token Using Concise Custom Pattern Syntax in Chevrotain - JavaScript\nDESCRIPTION: Demonstrates a shorthand method for supplying a custom matcher function to Chevrotain's createToken, by passing the function as the pattern. This is identical in behavior to the longer form but requires less boilerplate. Needs the matcher function (e.g., matchInteger) and Chevrotain's token creation API.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/custom_token_patterns.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n// pattern is passed the matcher function directly.\ncreateToken({ name: \"IntegerToken\", pattern: matchInteger });\n```\n\n----------------------------------------\n\nTITLE: Incorrect Caching of Alternatives with Closure Variable in Chevrotain\nDESCRIPTION: Illustrates an **incorrect** attempt to cache alternatives when a closure variable (`result`) is accessed within the `ALT` function. Caching fails because a new function closure referencing `result` is needed on each rule invocation, preventing effective reuse of the cached array.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/performance.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// BAD\n$.RULE(\"value\", function () {\n  let result;\n  // We reference the \"result\" variable via a closure.\n  // So a new function is needed each time this grammar rule is invoked.\n  $.OR(\n    $.c1 ||\n      ($.c1 = [\n        {\n          ALT: () => {\n            result = $.CONSUME(StringLiteral);\n          },\n        },\n      ]),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Redundant Parsing Rule Example in Chevrotain\nDESCRIPTION: Provides an example of a parsing rule (`myRedundantRule`) that is considered redundant for performance purposes. It only consumes a single terminal (`StringLiteral`). Defining such rules adds unnecessary overhead compared to inlining the `$.CONSUME` call directly where needed.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/performance.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nthis.myRedundantRule = this.RULE(\"myRedundantRule\", function () {\n  $.CONSUME(StringLiteral);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing selectStatement Visitor Method in JavaScript\nDESCRIPTION: This snippet defines the 'selectStatement' visitor method, which aggregates results of sub-visits for selectClause, fromClause, and optionally whereClause. Dependencies are a CST node structure and other visitor methods for the constituent clauses. The method constructs and returns an AST object for the SELECT_STMT node, mapping child CSTs to semantic components. Optional clauses are handled by Chevrotain's visit mechanics.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step3a_adding_actions_visitor.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass SQLToAstVisitor extends BaseSQLVisitor {\n  constructor() {\n    super();\n    this.validateVisitor();\n  }\n\n  // The Ctx argument is the current CSTNode's children.\n  selectClause(ctx) {\n    /* as above... */\n  }\n\n  selectStatement(ctx) {\n    // \"this.visit\" can be used to visit none-terminals and will invoke the correct visit method for the CstNode passed.\n    let select = this.visit(ctx.selectClause);\n\n    //  \"this.visit\" can work on either a CstNode or an Array of CstNodes.\n    //  If an array is passed (ctx.fromClause is an array) it is equivalent\n    //  to passing the first element of that array\n    let from = this.visit(ctx.fromClause);\n\n    // \"whereClause\" is optional, \"this.visit\" will ignore empty arrays (optional)\n    let where = this.visit(ctx.whereClause);\n\n    return {\n      type: \"SELECT_STMT\",\n      selectClause: select,\n      fromClause: from,\n      whereClause: where,\n    };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable RegExp Patterns with xRegExp in Chevrotain\nDESCRIPTION: This snippet demonstrates how to use the xRegExp library to create reusable pattern fragments in a Chevrotain lexer. It defines helper functions to create and use named pattern fragments, then applies them to create token definitions for integer and floating-point values with complex patterns.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/regexp.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"statement\", () => {\n  const fragments = {};\n\n  // A utility to create re-usable fragments using xRegExp\n  function FRAGMENT(name, def) {\n    fragments[name] = XRegExp.build(def, fragments);\n  }\n\n  // a utility to create a pattern using previously defined fragments\n  function MAKE_PATTERN(def, flags) {\n    return XRegExp.build(def, fragments, flags);\n  }\n\n  // define fragments\n  FRAGMENT(\"IntegerPart\", \"-?(0|[1-9][0-9]*)\");\n  FRAGMENT(\"FractionalPart\", \"\\\\.\\\\d+\");\n  FRAGMENT(\"ExponentPart\", \"[eE][+-]?[0-9]+\");\n\n  const IntValue = createToken({\n    name: \"IntValue\",\n    // Simple use case, not really needed in this case except for avoiding duplication.\n    pattern: MAKE_PATTERN(\"{{IntegerPart}}\"),\n  });\n\n  const FloatValue = createToken({\n    name: \"FloatValue\",\n    pattern: MAKE_PATTERN(\n      // This regExp would be very hard to read without \"named fragments\"\n      \"{{IntegerPart}}{{FractionalPart}}({{ExponentPart}})?|{{IntegerPart}}{{ExponentPart}}\",\n    ),\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Safe Embedded Semantic Actions Using ACTION Wrapper in Chevrotain - JavaScript\nDESCRIPTION: Demonstrates the recommended pattern for avoiding runtime errors during grammar recording by wrapping semantic actions that could throw exceptions inside the ACTION DSL method. Code within ACTION is not executed during the recording phase, preventing errors caused by dummy values returned by CONSUME or SUBRULE. The snippet shows how property access on subrule results and runtime semantic checks can be safely deferred. Highlights the limitation that ACTION wrappers must not include DSL method calls, preserving grammar recording functionality.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/internals.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nclass SolvedEmbeddedActions1 extends EmbeddedActionsParser {\n  constructor() {\n    /* ... */\n    $.RULE(\"topRule\", () => {\n      // During the recording phase `SUBRULE` will return a \"dummy\" value\n      // Which would not match the structure `otherRule` normally returns.\n      const otherRuleVal = $.SUBRULE($.otherRule);\n\n      return $.ACTION(() => {\n        // Code inside `ACTION` will not be executed during the grammar recording phase.\n        // Therefore an error will **not** be thrown...\n        otherRuleVal.foo.bar;\n      });\n    });\n\n    $.RULE(\"otherRule\", () => {\n      const myTok = $.CONSUME(MyTok);\n\n      return {\n        foo: {\n          bar: myTok.image,\n        },\n      };\n    });\n  }\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nclass SolvedSemanticChecks extends EmbeddedActionsParser {\n  constructor() {\n    /* ... */\n    $.RULE(\"semanticCheckRule\", () => {\n      // During the recording phase `CONSUME` will return a \"dummy\" IToken value.\n      const myNumTok = $.CONSUME(NumberTok);\n      // The \"dummy\" IToken `image` is not a number so this will evaluate to NaN.\n      const numValue = parseInt(myNumTok.image);\n\n      $.ACTION(() => {\n        // Code inside `ACTION` will not be executed during the grammar recording phase.\n        // Therefore an error will **not** be thrown...\n        if (isNaN(numValue)) {\n          throw Error(\"Unexpected Number Value!\");\n        }\n      });\n\n      return numValue;\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Namespace Flattening Changes in Chevrotain API Usage (JavaScript)\nDESCRIPTION: Exemplifies how the Chevrotain library flattened its nested 'gast' and 'exceptions' namespaces into its root API starting from version 2.0.0. Usage previously requiring access through nested namespaces now invokes classes and exceptions directly from the root export, simplifying imports and reducing verbosity.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/BREAKING_CHANGES.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Old API - using nested namespace.\nchevrotain.gast.Alternation;\n\n// New API - No nested namespaces.\nchevrotain.Alternation;\n```\n\n----------------------------------------\n\nTITLE: Unsafe Embedded Semantic Actions Assuming SUBRULE Return Structure - JavaScript\nDESCRIPTION: Demonstrates a common error pattern where an embedded semantic action assumes the structure of the value returned by a SUBRULE call. During Chevrotain's recording phase, SUBRULE returns dummy placeholder values, not the expected AST structures, leading to runtime errors like \"undefined is not an object\" when trying to access properties. This snippet highlights the risk of premature property access on subrule results without guarding against recording phase behavior. Requires EmbeddedActionsParser context and usage of CONSUME and SUBRULE methods.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/internals.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nclass ErrorEmbeddedActions1 extends EmbeddedActionsParser {\n  constructor() {\n    /* ... */\n    $.RULE(\"topRule\", () => {\n      // During the recording phase `SUBRULE` will return a \"dummy\" value\n      // Which would not match the structure `otherRule` normally returns.\n      const otherRuleVal = $.SUBRULE($.otherRule);\n\n      // Will cause \"undefined is not an object\" runtime error\n      // because during the recording phase `SUBRULE` will not returned the expected value.\n      return otherRuleVal.foo.bar;\n    });\n\n    $.RULE(\"otherRule\", () => {\n      const myTok = $.CONSUME(MyTok);\n\n      return {\n        foo: {\n          bar: myTok.image,\n        },\n      };\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Skipped Whitespace Token in Chevrotain (JavaScript)\nDESCRIPTION: This snippet shows how to create a token definition for whitespace that should be ignored during lexing by assigning its group to Lexer.SKIPPED. It leverages Chevrotain's createToken and Lexer modules, making the whitespace token invisible in the token vector generated by the lexer.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/token_skipping.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { createToken, Lexer } from \"chevrotain\";\nconst WhiteSpace = createToken({\n  name: \"WhiteSpace\",\n  pattern: /\\s+/,\n  group: Lexer.SKIPPED,\n});\n```\n\n----------------------------------------\n\nTITLE: Skipping Validations During Parser Initialization (JavaScript)\nDESCRIPTION: This snippet demonstrates how to disable Chevrotain's validation during parser initialization using the `skipValidations` option. Disabling validations, a development time tool, can significantly reduce initialization time. The snippet shows setting `skipValidations` to `true`. This option is useful when the parser and lexer are known to be valid.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/initialization_performance.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nclass NaiveSkippedValidationsParser extends CstParser {\n  constructor() {\n    super([], {\n      // This could reduce 30-50% of the initialization time\n      skipValidations: true,\n    });\n\n    this.performSelfAnalysis();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Token Matcher Function in JavaScript for Chevrotain\nDESCRIPTION: This snippet defines a custom JavaScript function `matchInteger` that mimics the behavior of `RegExp.prototype.exec` to identify sequences of digits within a text starting from a given offset. It returns an array containing the matched string or null if no match is found. This function is then used as the `pattern` property when creating a Chevrotain token named `IntegerToken` via the `createToken` factory.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/custom_token_patterns.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// our custom matcher\nfunction matchInteger(text, startOffset) {\n  let endOffset = startOffset;\n  let charCode = text.charCodeAt(endOffset);\n  // 0-9 digits\n  while (charCode >= 48 && charCode <= 57) {\n    endOffset++;\n    charCode = text.charCodeAt(endOffset);\n  }\n\n  // No match, must return null to conform with the RegExp.prototype.exec signature\n  if (endOffset === startOffset) {\n    return null;\n  } else {\n    let matchedString = text.substring(startOffset, endOffset);\n    // according to the RegExp.prototype.exec API the first item in the returned array must be the whole matched string.\n    return [matchedString];\n  }\n}\n\nconst IntegerToken = createToken({\n  name: \"IntegerToken\",\n  pattern: matchInteger,\n});\n```\n\n----------------------------------------\n\nTITLE: Skipping Validations During Lexer Initialization (JavaScript)\nDESCRIPTION: This snippet illustrates skipping validations during Lexer initialization using the `skipValidations` config property. Similar to the Parser, this option when set to `true` disables validations during the initialization of the Lexer and can improve initialization time.  This is suitable when the Lexer is known to be valid.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/initialization_performance.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nnew Lexer([], {\n  skipValidations: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Full SQLToAstVisitor Class for Chevrotain in JavaScript\nDESCRIPTION: This snippet provides the complete implementation of the SQLToAstVisitor class, extending the base Chevrotain visitor to handle all relevant SQL grammar rules. It defines visit methods for selectStatement, selectClause, fromClause, whereClause, expression, atomicExpression, and relationalOperator. Each method transforms CST nodes into AST representations, processing identifiers, operators, and literals appropriately. Class dependencies include a properly configured Chevrotain parser and validated grammar; input is the CST, outputs are structured AST nodes and literals.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step3a_adding_actions_visitor.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass SQLToAstVisitor extends BaseSQLVisitor {\n  constructor() {\n    super();\n    this.validateVisitor();\n  }\n\n  selectStatement(ctx) {\n    /* as above... */\n  }\n\n  selectClause(ctx) {\n    /* as above... */\n  }\n\n  fromClause(ctx) {\n    const tableName = ctx.Identifier[0].image;\n\n    return {\n      type: \"FROM_CLAUSE\",\n      table: tableName,\n    };\n  }\n\n  whereClause(ctx) {\n    const condition = this.visit(ctx.expression);\n\n    return {\n      type: \"WHERE_CLAUSE\",\n      condition: condition,\n    };\n  }\n\n  expression(ctx) {\n    // Note the usage of the \"rhs\" and \"lhs\" labels defined in step 2 in the expression rule.\n    const lhs = this.visit(ctx.lhs[0]);\n    const operator = this.visit(ctx.relationalOperator);\n    const rhs = this.visit(ctx.rhs[0]);\n\n    return {\n      type: \"EXPRESSION\",\n      lhs: lhs,\n      operator: operator,\n      rhs: rhs,\n    };\n  }\n\n  // these two visitor methods will return a string.\n  atomicExpression(ctx) {\n    if (ctx.Integer) {\n      return ctx.Integer[0].image;\n    } else {\n      return ctx.Identifier[0].image;\n    }\n  }\n\n  relationalOperator(ctx) {\n    if (ctx.GreaterThan) {\n      return ctx.GreaterThan[0].image;\n    } else {\n      return ctx.LessThan[0].image;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Safe Existence Checks on CST Node Children in Chevrotain Visitors (JavaScript)\nDESCRIPTION: Demonstrates recommended practice for checking the existence of terminal nodes within a CST visitor method following Chevrotain 3.0.0 changes. Since unmatched tokens no longer produce empty arrays but rather undefined properties, visitor code must first check for the property's existence before accessing array elements to avoid runtime errors. The snippet contrasts unsafe direct index access with the safe guarded approach, ensuring robustness in CST traversal.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/BREAKING_CHANGES.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass MyVisitor extends SomeBaseVisitor {\n  atomicExpression(ctx) {\n    // BAD - will fail due to \"TypeError: Cannot read property '0' of undefined\"\n    if (ctx.Integer[0]) {\n      return ctx.Integer[0].image;\n    }\n\n    // GOOD - safe check\n    if (ctx.Integer) {\n      // if a property exists it's value is guaranteed to have at least one element.\n      return ctx.Identifier[0].image;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Initialization Performance Tracing in Parser (JavaScript)\nDESCRIPTION: This snippet demonstrates how to enable performance tracing during the initialization of a Chevrotain parser. It uses the `traceInitPerf` configuration option set to `true`. The output is tracing information printed to the console. This is useful to diagnose parser initialization performance.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/initialization_performance.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nclass InitTracingParser extends CstParser {\n  constructor() {\n    super([], {\n      // Note `traceInitPerf` may also accept numerical values\n      traceInitPerf: true,\n    });\n\n    this.performSelfAnalysis();\n  }\n}\n\nnew InitTracingParser(); // Will print tracing info to the console.\n```\n\n----------------------------------------\n\nTITLE: Parsing Input to Generate CST with Chevrotain in JavaScript\nDESCRIPTION: This snippet demonstrates how to parse a text input using Chevrotain's SelectLexer and SelectParser to automatically generate a CST (Concrete Syntax Tree). Dependencies include SelectLexer, SelectParser, and Chevrotain's CstParser extension. The function accepts a SQL string and produces a CST via the selectStatement parser rule. Output is the parsed CST structure, suitable for further semantic analysis.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step3a_adding_actions_visitor.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction parseInput(text) {\n  const lexingResult = SelectLexer.tokenize(text);\n  const parser = new SelectParser(lexingResult.tokens);\n\n  // CST automatically created.\n  const cstOutput = parser.selectStatement();\n}\n```\n\n----------------------------------------\n\nTITLE: Parser Configuration Update (javascript)\nDESCRIPTION: This snippet shows the changes to the Parser constructor. The third optional parameter has been replaced with a configuration object of type IParserConfig. Additionally, error recovery is now disabled by default and must be explicitly enabled via the recoveryEnabled flag in the IParserConfig object.  This provides more control over parser behavior and avoids unintended error recovery.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/CHANGELOG.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// old deprecated form\nfunction JsonParser(input) {\n  // The third argument was used to enable/disable error recovery\n  // and was **true** by default.\n  Parser.call(this, input, true);\n}\n\n// new form\nfunction JsonParser(input) {\n  // invoke super constructor\n  Parser.call(this, input, allTokens, {\n    // by default the error recovery flag is **false**\n    // use recoveryEnabled flag in the IParserConfig object to enable enable it.\n    recoveryEnabled: true,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: RULE Method Update (Typescript)\nDESCRIPTION: This snippet demonstrates the change in the RULE method's signature.  The old deprecated form used separate parameters for the implementation and recovery value function, while the new form uses a configuration object of type IRuleConfig. This change requires refactoring existing RULE invocations with more than two arguments. The code illustrates the transition from the old to the new method signature.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/CHANGELOG.md#_snippet_0\n\nLANGUAGE: Typescript\nCODE:\n```\n// old deprecated form\nthis.RULE(\"createStmt\", function(){ /* ... */}, function(){ return 666 })\n\n// new form\nthis.RULE(\"createStmt\", function(){ /* ... */}, {recoveryValueFunc: function(){ return 666 }})\n```\n\n----------------------------------------\n\nTITLE: Refactoring Grammar with Infinite Lookahead in ANTLR\nDESCRIPTION: Shows how to refactor a grammar with infinite lookahead requirements to one that only needs one token of lookahead.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_6\n\nLANGUAGE: antlr\nCODE:\n```\noneTokenLookahead:\n  (\"A\")*\n  (\n    \"1\" |\n    \"2\"\n  )\n```\n\n----------------------------------------\n\nTITLE: Infinite Loop Example with Early Return in JavaScript\nDESCRIPTION: Demonstrates a problematic pattern causing an infinite loop error where a MANY repetition contains an early return preventing token consumption.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n$.MANY(() => {\n  return;\n  // unreachable code\n  $.CONSUME(Plus);\n});\n```\n\n----------------------------------------\n\nTITLE: Refactoring Grammar to Reduce Lookahead in ANTLR\nDESCRIPTION: Shows how to refactor a grammar requiring large lookahead into one that only needs one token of lookahead by extracting common prefixes.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_4\n\nLANGUAGE: antlr\nCODE:\n```\noneTokenLookahead:\n  \"A\" \"B\" \"C\" \"D\"\n  (\n    \"1\" |\n    \"2\"\n  )\n```\n\n----------------------------------------\n\nTITLE: Handling Repetitions Without Return Values in Embedded Actions Mode (JavaScript)\nDESCRIPTION: Shows how repetition constructs like MANY and AT_LEAST_ONE no longer return arrays of results in embedded actions mode from Chevrotain 4.0.0 onwards. Instead, iteration results should be manually collected by pushing returns of subrules into an externally declared array. This example contrasts the previous implicit collection style with the explicit collection required after the update, helping migrate legacy parsers that relied on returned iteration arrays.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/BREAKING_CHANGES.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Before 4.0.0\nconst stmts = $.MANY(() => {\n  return $.SUBRULE(Statement);\n});\n\n// After 4.0.0\nconst stmts = [];\n$.MANY(() => {\n  stmts.push($.SUBRULE(Statement));\n});\n```\n\n----------------------------------------\n\nTITLE: Ignoring Ambiguities for a Specific Alternative in JavaScript\nDESCRIPTION: Shows how to ignore ambiguities for a specific alternative in an alternation by setting IGNORE_AMBIGUITIES on that alternative only.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n$.OR([\n  { ALT: () => $.SUBRULE($.myRule), IGNORE_AMBIGUITIES: true },\n  { ALT: () => $.SUBRULE($.myOtherRule) },\n]);\n```\n\n----------------------------------------\n\nTITLE: Incorrect Use of JavaScript Flow Control in Chevrotain Grammar\nDESCRIPTION: Shows incorrect usage of JavaScript conditions inside Chevrotain grammar which can lead to infinite loops if no tokens are consumed.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n$.MANY(() => {\n  // Never wrap Chevrotain grammar in JavaScript control flow constructs.\n  if (condition) {\n    $.CONSUME(Plus);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Correct Implementation of Conditional Grammar with Chevrotain Constructs\nDESCRIPTION: Shows the correct way to implement conditional grammar paths using Chevrotain's OPTION construct instead of JavaScript control flow.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n$.MANY(() => {\n  $.OPTION(() => {\n    $.CONSUME(Plus);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Concrete Syntax Tree (CST) Output for Embedded Actions in Chevrotain Parser (JavaScript)\nDESCRIPTION: Illustrates how to explicitly disable automatic CST construction, which is enabled by default starting from Chevrotain 4.0.0, when using parsers with embedded actions. The example shows a parser subclass constructor that calls the superclass constructor with a configuration object containing 'outputCst: false' to turn off CST generation. This is necessary because embedded actions are incompatible with default CST output in the latest API version.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/BREAKING_CHANGES.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nclass MyNewParser extends Parser {\n  constructor() {\n    // we have to explicitly disable the CST building for embedded actions to work.\n    super(allTokens, { outputCst: false });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Common Prefix by Reordering Alternatives in ANTLR\nDESCRIPTION: Shows how to fix a common prefix ambiguity by reordering alternatives so that longer patterns appear before shorter ones.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\nmyRule:\n  \"A\" \"B\" \"C\" |\n  \"A\" \"B\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Calculation Logic with Chevrotain Embedded Actions in JavaScript\nDESCRIPTION: A simple example demonstrating how embedded actions work. The `topRule` uses `SUBRULE` to call `decimalRule` and `IntegerRule`, accumulating their numeric results. The `decimalRule` and `IntegerRule` use `CONSUME` to get the token and return its parsed numeric value (`parseFloat` or `parseInt` on the token's `image`).\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step3b_adding_actions_embedded.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"topRule\", () => {\n  let result = 0;\n\n  $.MANY(() => {\n    $.OR([\n      {\n        ALT: () => {\n          result += $.SUBRULE($.decimalRule);\n        },\n      },\n      {\n        ALT: () => {\n          result += $.SUBRULE($.IntegerRule);\n        },\n      },\n    ]);\n  });\n\n  return result;\n});\n\n$.RULE(\"decimalRule\", () => {\n  const decimalToken = $.CONSUME(Decimal);\n  return parseFloat(decimalToken.image);\n});\n\n$.RULE(\"IntegerRule\", () => {\n  const intToken = $.CONSUME(Integer);\n  return parseInt(intToken.image);\n});\n```\n\n----------------------------------------\n\nTITLE: Common Prefix Ambiguity Example in ANTLR Notation\nDESCRIPTION: Demonstrates a grammar with a common prefix ambiguity where the first alternative is a prefix of the second, causing incorrect matching for certain inputs.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_grammar_errors.md#_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nmyRule:\n  \"A\" \"B\" |\n  \"A\" \"B\" \"C\"\n```\n\n----------------------------------------\n\nTITLE: Customizing Line Terminators in Chevrotain Lexer Configuration (JavaScript)\nDESCRIPTION: This snippet shows how to configure a Chevrotain Lexer to recognize '\\n' as the sole line terminator using both lineTerminatorsPattern and lineTerminatorCharacters options. This is useful for grammars with custom line termination rules. Dependencies: Chevrotain and an array of token types. Inputs are the options for terminators; output is a customized Lexer instance. Limitation: both pattern and character codes must be maintained in sync.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nconst myLexer = new chevrotain.Lexer([], {\n  // For our lexer only \"\\n\" is a counted as a line terminator\n  lineTerminatorsPattern: /\\n/,\n  // Duplicate information, \"\\n\".charCodeAt(0) === 10\n  lineTerminatorCharacters: [10],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Chevrotain Lexer with Keyword First to Fix Matching Order (JavaScript)\nDESCRIPTION: This snippet demonstrates resolving token matching conflicts by listing the specific keyword (ForKeyword) before the more general Identifier token in the lexer definition. This makes keyword matching effective, but causes new issues with identifier splitting. Requires Chevrotain and previously defined tokens. Inputs are the reordered token type array; output is a Lexer instance with improved keyword matching.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst myLexer = new chevrotain.Lexer([ForKeyword, Identifier]);\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Token Pattern with start_chars_hint in Chevrotain (JavaScript)\nDESCRIPTION: This snippet demonstrates using a custom exec function for a token pattern in Chevrotain and supplying 'start_chars_hint' for performance optimization. The IntegerToken defines a custom pattern for numeric strings and hints the range of starting characters. Dependencies: Chevrotain and implementation of createToken; custom logic within exec should parse the text to recognize integers. Inputs: custom token definition; outputs: a token type usable within a lexer instance.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nconst IntegerToken = createToken({\n  name: \"IntegerToken\",\n  pattern: {\n    exec: (text, offset) => {\n      /* ... */\n    },\n  },\n  start_chars_hint: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n});\n```\n\n----------------------------------------\n\nTITLE: TypeScript signatures for CST nodes generated by Chevrotain\nDESCRIPTION: This snippet shows how to generate explicit TypeScript interface definitions for CSTNodes based on grammar rules using generateCstDts. The interfaces include properties for rule name and children, enhancing type safety and tooling support when working with CSTs in TypeScript.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ArrayCstNode extends CstNode {\n  name: \"array\";\n  children: ArrayCstChildren;\n}\n\nexport type ArrayCstChildren = {\n  LSquare: IToken[];\n  value?: ValueCstNode[];\n  Comma?: IToken[];\n  RSquare: IToken[];\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Backtracking in Chevrotain JavaScript Parser\nDESCRIPTION: A JavaScript example using Chevrotain's BACKTRACK method to resolve grammar ambiguity. The code demonstrates how to fully try out alternatives in order by using Gates, effectively implementing a depth-first search approach instead of limited token lookahead.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/backtracking.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"statement\", () => {\n  $.OR([\n    {\n      GATE: $.BACKTRACK($.longRule1),\n      ALT: () => $.SUBRULE($.longRule1),\n    },\n    {\n      GATE: $.BACKTRACK($.longRule2),\n      ALT: () => $.SUBRULE($.longRule2),\n    },\n  ]);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Chevrotain Token with start_chars_hint for complement sets\nDESCRIPTION: This code shows how to address the \"Complement Sets cannot be automatically optimized\" warning by providing `start_chars_hint`. It shows the logic to compute the `start_chars_hint` values. This example uses XMLText as an example pattern.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst hints = [];\nfor (let i = 0; i <= 65535; i++) {\n  // 38 is '<' and 60 is '&'\n  if (i !== 38 || i !== 60) {\n    hints.push(i);\n  }\n}\n\nconst XMLText = createToken({\n  name: \"XMLText\",\n  pattern: /[^<&]+/,\n  start_chars_hint: hints,\n});\n```\n\n----------------------------------------\n\nTITLE: LL(K) Grammar Example\nDESCRIPTION: This grammar demonstrates a valid LL(K) grammar that Chevrotain can parse. It has a fixed lookahead of three tokens to decide between the alternatives.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/llk.md#_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nstatement:\n   A B C |\n   A B D |\n   A B E\n```\n\n----------------------------------------\n\nTITLE: Creating a Parser with Increased Lookahead in Chevrotain 7.0.0+\nDESCRIPTION: Example showing how to configure a parser with increased maxLookahead value to maintain pre-7.0.0 behavior where the default maxLookahead was reduced from 4 to 3.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/changes/BREAKING_CHANGES.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nclass MoreLookaheadParser extends CstParser {\n  constructor() {\n    super([], {\n      maxLookahead: 4,\n    });\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar with Ambiguity Example\nDESCRIPTION: An example of an ambiguous grammar that is not LL(K) because both alternatives in 'statement' have a potentially infinitely long common prefix. This grammar cannot be parsed with traditional fixed lookahead.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/backtracking.md#_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nstatement:\n   longRule1 |\n   longRule2 |\n\nlongRule1:\n   A+ B\n\nlongRule2:\n   A+ C\n```\n\n----------------------------------------\n\nTITLE: Creating a Chevrotain Lexer with Token Order Causing Unmatchable Keyword (JavaScript)\nDESCRIPTION: This snippet shows how to instantiate a lexer with Identifier and ForKeyword tokens, where the Identifier precedes the keyword. This causes the 'for' string to always match the Identifier, not ForKeyword, triggering a \"Token <ForKeyword> can never be matched...\" error. Chevrotain and the above-mentioned tokens are required dependencies. Inputs are an array of token types; output is a Lexer instance with problematic ordering.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst myLexer = new chevrotain.Lexer([Identifier, ForKeyword]);\n```\n\n----------------------------------------\n\nTITLE: Implementing longer_alt for keyword vs identifier disambiguation in JavaScript\nDESCRIPTION: This example demonstrates how to use the longer_alt property to disambiguate between keywords and identifiers in Chevrotain. The ClassKeyword token specifies Identifier as its longer alternative, ensuring 'class' is recognized as a keyword rather than an identifier when encountered.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/token_alternative_matches.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createToken } from \"chevrotain\";\n\nconst Identifier = createToken({\n  name: \"Identifier\",\n  pattern: /[a-zA-Z][\\w+]/,\n});\n\nconst ClassKeyword = createToken({\n  name: \"ClassKeyword\",\n  pattern: /class/,\n  longer_alt: Identifier,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Chevrotain Lexer for Offset-Only Position Tracking\nDESCRIPTION: This JavaScript snippet demonstrates how to initialize a Chevrotain Lexer with the `positionTracking` configuration set to `'onlyOffset'`. This optimizes the lexer to only track the start and end offsets of tokens, ignoring line and column information. Requires the `chevrotain` library and an array of token definitions (`allTokens`).\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/position_tracking.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Lexer } from \"chevrotain\";\nconst allTokens = [];\n// createTokens...\nconst myLexer = new Lexer(allTokens, { positionTracking: \"onlyOffset\" });\n```\n\n----------------------------------------\n\nTITLE: Defining Chevrotain Tokens with line_breaks\nDESCRIPTION: This code shows how to define Tokens in Chevrotain and how to explicitly set the `line_breaks` flag. This is another way to resolve the \"No LINE_BREAKS Found\" warning, by informing the lexer about line terminators within the tokens. The `lineTerminatorsPattern` lexer configuration controls the definition of line terminators.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst createToken = chevrotain.createToken;\n\nconst Whitespace = createToken({\n  name: \"Whitespace\",\n  pattern: /\\s+/,\n  // This is normally computed automatically...\n  line_breaks: true,\n});\n\nconst myTokens = [IntegerLiteral, StringLiteral, WhiteSpace /*, ... */];\n\nconst myLexer = new chevrotain.Lexer([myTokens]);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Complete Chevrotain Parser Class (JavaScript)\nDESCRIPTION: Presents the full implementation of the `SelectParser` class, defining all necessary grammar rules (`selectStatement`, `selectClause`, `fromClause`, `whereClause`, `expression`, `atomicExpression`, `relationalOperator`) using Chevrotain's DSL. It shows the use of labels (`LABEL: \"lhs\"`, `LABEL: \"rhs\"`) for easier access in CST visitors and numbered DSL methods (`SUBRULE2`) to distinguish between multiple calls to the same method with the same non-terminal within a single rule.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step2_parsing.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { CstParser } from \"chevrotain\";\nconst allTokens = [\n  WhiteSpace,\n  Select,\n  From,\n  Where,\n  Comma,\n  Identifier,\n  Integer,\n  GreaterThan,\n  LessThan,\n];\n\nclass SelectParser extends CstParser {\n  constructor() {\n    super(allTokens);\n\n    const $ = this;\n\n    $.RULE(\"selectStatement\", () => {\n      $.SUBRULE($.selectClause);\n      $.SUBRULE($.fromClause);\n      $.OPTION(() => {\n        $.SUBRULE($.whereClause);\n      });\n    });\n\n    $.RULE(\"selectClause\", () => {\n      $.CONSUME(Select);\n      $.AT_LEAST_ONE_SEP({\n        SEP: Comma,\n        DEF: () => {\n          $.CONSUME(Identifier);\n        },\n      });\n    });\n\n    $.RULE(\"fromClause\", () => {\n      $.CONSUME(From);\n      $.CONSUME(Identifier);\n    });\n\n    $.RULE(\"whereClause\", () => {\n      $.CONSUME(Where);\n      $.SUBRULE($.expression);\n    });\n\n    // The \"rhs\" and \"lhs\" (Right/Left Hand Side) labels will provide easy\n    // to use names during CST Visitor (step 3a).\n    $.RULE(\"expression\", () => {\n      $.SUBRULE($.atomicExpression, { LABEL: \"lhs\" });\n      $.SUBRULE($.relationalOperator);\n      $.SUBRULE2($.atomicExpression, { LABEL: \"rhs\" }); // note the '2' suffix to distinguish\n      // from the 'SUBRULE(atomicExpression)'\n      // 2 lines above.\n    });\n\n    $.RULE(\"atomicExpression\", () => {\n      $.OR([\n        { ALT: () => $.CONSUME(Integer) },\n        { ALT: () => $.CONSUME(Identifier) },\n      ]);\n    });\n\n    $.RULE(\"relationalOperator\", () => {\n      $.OR([\n        { ALT: () => $.CONSUME(GreaterThan) },\n        { ALT: () => $.CONSUME(LessThan) },\n      ]);\n    });\n\n    this.performSelfAnalysis();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Chevrotain Token with invalid anchors\nDESCRIPTION: This code sample shows an example of how to resolve an error related to using start/end of input anchors ('$' and '^') in a Chevrotain Lexer token pattern. Chevrotain lexers do not support the usage of anchors.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/resolving_lexer_errors.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst createToken = chevrotain.createToken;\n\n// Using createToken API\nconst Whitespace = createToken({\n  name: \"Integer\",\n  // invalid pattern using both anchors\n  pattern: /^\\d+$/,\n});\n\n// will throw an error\nnew chevrotain.Lexer([semVer]);\n```\n\n----------------------------------------\n\nTITLE: Defining the Target Language Grammar using ANTLR Notation\nDESCRIPTION: Describes the grammar for a simple SQL Select statement using ANTLR-like syntax. It defines rules like `selectStatement`, `selectClause`, `fromClause`, `whereClause`, `expression`, `atomicExpression`, and `relationalOperator` to structure the expected input.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step2_parsing.md#_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nselectStatement\n   : selectClause fromClause (whereClause)?\n\nselectClause\n   : \"SELECT\" Identifier (\",\" Identifier)*\n\nfromClause\n   : \"FROM\" Identifier\n\nwhereClause\n   : \"WHERE\" expression\n\nexpression\n   : atomicExpression relationalOperator atomicExpression\n\natomicExpression\n   : Integer | Identifier\n\nrelationalOperator\n   : \">\" | \"<\"\n```\n\n----------------------------------------\n\nTITLE: Performance considerations of CST creation in Chevrotain\nDESCRIPTION: This section discusses benchmark findings indicating CST building can use 35%-90% of the runtime compared to pure grammar parsing. Despite this, Chevrotain's performance remains high, and the benefits of modular, maintainable CST management generally justify the cost unless in performance-critical, niche scenarios.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/guide/concrete_syntax_tree.md#_snippet_13\n\n\n\n----------------------------------------\n\nTITLE: Grouping Token Types in Chevrotain (JavaScript)\nDESCRIPTION: This code snippet demonstrates how to group a token type in Chevrotain using the `group` property in the token configuration. In this example, the 'Comment' token type is grouped under the 'comments' group. The `createToken` function is used to define the token.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/token_grouping.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst Comment = createToken({\n  name: \"Comment\",\n  pattern: /\\/\\/.+/, // Matches comments starting with '//'\n  group: \"comments\",\n});\n```\n\n----------------------------------------\n\nTITLE: Defining DSL Rule Suffixes in Chevrotain Parser - JavaScript\nDESCRIPTION: This JavaScript snippet shows how to define DSL grammar rules in a Chevrotain parser by applying unique numerical suffixes (e.g., OPTION1, OPTION2) and method variants (CONSUME, CONSUME2) to support unambiguous parsing. To use this code, you must have Chevrotain installed and have defined token constructors such as MyToken and MyOtherToken. The RULE method declares a grammar rule, while OPTION and OPTION1/2 enable optional elements and allow Chevrotain to distinguish between different parsing branches, especially when the same token type is consumed more than once within a rule. Expected input is a stream of tokens matching the grammar; outputs are parsed parse trees or error information. The main constraint is that suffixes must be handled carefully to avoid ambiguity in the Chevrotain parser's runtime tracking.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/FAQ.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nthis.RULE(\"someRule\", () => {\n  $.OPTION(() => {\n    $.CONSUME(MyToken);\n  });\n\n  $.OPTION1(() => {\n    // A different suffix is not needed because the argument is different!\n    $.CONSUME(MyOtherToken);\n  });\n\n  // OPTION has no \"named\" argument so a different suffix is **always** needed\n  // within the same top level rule.\n  $.OPTION2(() => {\n    $.CONSUME2(MyToken);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Consuming Chevrotain Token Category in Parser Rule\nDESCRIPTION: This snippet illustrates how to use the previously defined Token Category (`KeywordOrIdentifier`) within a Chevrotain parser rule (`SomeRule`). Using `$.CONSUME(KeywordOrIdentifier)` allows the parser to accept any token that has been assigned to this category.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/token_categories.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n$.RULE(\"SomeRule\", () => {\n  // This would match either an Identifier or a keyword thus allowing for\n  // \"None Reserved keywords\"\n  $.CONSUME(KeywordOrIdentifier);\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Keyword Token (FROM) using Chevrotain\nDESCRIPTION: Demonstrates the basic definition of a keyword token ('FROM') using the `chevrotain.createToken` API. It requires providing a unique `name` for the token and a regular expression `pattern` to match the keyword in the input text.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step1_lexing.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst createToken = chevrotain.createToken;\n// using createToken API\nconst From = createToken({ name: \"From\", pattern: /FROM/ });\n```\n\n----------------------------------------\n\nTITLE: Installing Chevrotain Library (Shell)\nDESCRIPTION: Demonstrates how to install the Chevrotain parsing library using either yarn or npm package managers. It requires Node.js and a package manager (yarn or npm) to be installed. The command adds the library as a project dependency.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/tutorial/step0_introduction.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add chevrotain\n# OR\nnpm install chevrotain\n```\n\n----------------------------------------\n\nTITLE: Invalid LL(K) Grammar Example\nDESCRIPTION: This grammar demonstrates an invalid LL(K) grammar that Chevrotain cannot parse. Due to the A+ in the longRule, the lookahead required to disambiguate the statement alternatives is unbounded, leading to a parser initialization error.\nSOURCE: https://github.com/chevrotain/chevrotain/blob/master/packages/website/docs/features/llk.md#_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\nstatement:\n   longRule B  |\n   longRule C  |\n   longRule D\n\nlongRule:\n   A+\n```"
  }
]