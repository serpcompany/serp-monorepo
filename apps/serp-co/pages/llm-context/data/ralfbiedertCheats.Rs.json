[
  {
    "owner": "ralfbiedert",
    "repo": "cheats.rs",
    "content": "TITLE: Creating and Accessing Rust Data Structures and Composite Types - Rust\nDESCRIPTION: Describes syntax and usage for constructing and accessing Rust structs, enums, tuples, arrays, slices, and ranges. It includes creating struct instances with explicit fields or field shorthand, tuple structs and unit structs, enum variants with different variant types, tuple expressions, single element tuples, array expressions of fixed or dynamic length, slicing via range syntax, and field access for named and numbered fields. Dependencies include Rust’s ownership model and traits for indexing. Inputs are field values or expressions, outputs are initialized structured data values. Limitations highlight that slices' length is unspecified and that unsized types cannot reside on stack.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nS { x: y }\nS { x }\nS { ..s }\nS { 0: x }\nS(x)\nS\nE::C { x: y }\n()\n(x)\n(x,)\n(S,)\n[S]\n[S; n]\n[x; n]\n[x, y]\nx[0]\nx[..]\na..b\n..b\n..=b\na..=b\na..\n.. \ns.x\ns.0\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Command\nDESCRIPTION: This command builds and runs the project if it produces a binary (e.g., main.rs).\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_146\n\nLANGUAGE: Shell\nCODE:\n```\ncargo <span class=\"cargo-prefix\">r</span>un\n```\n\n----------------------------------------\n\nTITLE: Looping and Control Flow in Rust - Rust\nDESCRIPTION: Demonstrates different looping constructs (`while`, infinite `loop`, and `for` over iterators) and control flow statements including labeled loops, `break`, `continue`, `if` conditional branches, and `return`. Shows how to handle error propagation using the question mark operator (`?`), and asynchronous flow control using `await`. Includes details on expression values from loops, label usage for nested loop control, and difference in return behavior in closures and async blocks.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_37\n\nLANGUAGE: Rust\nCODE:\n```\nwhile x {}\nloop {}\nfor x in collection {}\nif x {} else {}\n'label: {}\n'label: loop {}\nbreak\nbreak 'label x\nbreak 'label\nbreak x\ncontinue\ncontinue 'label\nx?\nx.await\nreturn x\n```\n\n----------------------------------------\n\nTITLE: Closure API Table\nDESCRIPTION: This table illustrates the implications of using `FnOnce`, `FnMut`, and `Fn` traits for closure arguments, showing which kinds of closures each signature can accept.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_201\n\n\n\n----------------------------------------\n\nTITLE: Cargo Test Command\nDESCRIPTION: Executes unit and integration tests defined in the project. Requires a tests directory.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_144\n\nLANGUAGE: Shell\nCODE:\n```\ncargo <span class=\"cargo-prefix\">t</span>est\n```\n\n----------------------------------------\n\nTITLE: Integration Testing - Rust\nDESCRIPTION: Shows how to write an integration test in a separate `tests/` directory.  Demonstrates how to access public items of the crate under test. Requires the crate to be available as a dependency.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_134\n\nLANGUAGE: Rust\nCODE:\n```\n// tests/sample.rs (sample integration test)\n\n#[test]\nfn my_sample() {\n    assert_eq!(my_crate::f(), 123); // Integration tests (and benchmarks) 'depend' to the crate like\n}                                   // a 3rd party would. Hence, they only see public items.\n```\n\n----------------------------------------\n\nTITLE: Using Expressions and Control Flow in Rust - Rust\nDESCRIPTION: Demonstrates idiomatic Rust expressions and control flow constructs to assign values concisely and define functions. Shows how Rust emphasizes expressions returning values, including conditional expressions and loops with breaks used as values.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_188\n\nLANGUAGE: Rust\nCODE:\n```\ny = if x { a } else { b };\ny = loop { break 5 };\nfn f() -> u32 { 0 }\n```\n\n----------------------------------------\n\nTITLE: Printing 'Hello, world!' in Rust\nDESCRIPTION: Defines the standard entry point (`main` function) for a Rust executable and uses the `println!` macro to output the string 'Hello, world!' to the console. This requires a Rust compiler and demonstrates basic console output.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Lifetime Scope and Duration in Rust\nDESCRIPTION: This section discusses the concept of 'lifetime' in Rust, illustrating how variables and references have specific durations of validity within code. It clarifies that lifetime parameters dictate the accessibility of data at different code locations, not the actual existence of the data itself. The content is supported by annotated code examples showing memory regions and scope annotations.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_56\n\n\n\n----------------------------------------\n\nTITLE: Enabling Automatic Trait Implementation via #[derive] Attribute in Rust\nDESCRIPTION: The #[derive(Trait)] attribute lets the Rust compiler automatically provide default implementations for common traits like Debug, Clone, Eq, and others on structs or enums. Input: a type to annotate. Output: trait methods synthesized by the compiler. Typically no extra dependencies but some traits may require standard library support or derive macros from external crates.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_163\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug, Clone, PartialEq)]\nstruct Data { ... }\n```\n\n----------------------------------------\n\nTITLE: Using Trait Parameters and Associated Types in Rust\nDESCRIPTION: Describes traits with generic parameters and associated output types, demonstrating how traits can function like multivariate type relations. The examples include the 'From<I>' trait with input parameter 'I' and 'Deref' trait with associated output type 'O'. Shows how traits define input-output relations, requiring uniqueness. Also explains complex traits with multiple input and output parameters. Dependencies include the trait definitions and type implementations. Inputs are type parameters, outputs are associated types. This pattern enables flexible and powerful abstractions in Rust.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_170\n\nLANGUAGE: Rust\nCODE:\n```\nimpl From<u8> for u16 {}\nimpl From<u16> for u32 {}\nimpl Deref for Port { type O = u8; }\nimpl Deref for String { type O = str; }\n```\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Complex<I1, I2> {\n    type O1;\n    type O2;\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Documentation Command\nDESCRIPTION: Generates local documentation for the project, excluding dependencies, and opens it in a web browser. Requires `rustdoc`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_145\n\nLANGUAGE: Shell\nCODE:\n```\ncargo <span class=\"cargo-prefix\">d</span>oc --no-deps --open\n```\n\n----------------------------------------\n\nTITLE: Reading an Entire File into a String in Rust\nDESCRIPTION: Reads the entire contents of the file specified by `path` into a single `String` using `std::fs::read_to_string`. Returns a `Result` containing the string or an I/O error.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_106\n\nLANGUAGE: Rust\nCODE:\n```\nread_to_string(path)?\n```\n\n----------------------------------------\n\nTITLE: Creating a New File in Rust\nDESCRIPTION: Creates a new file at the specified `PATH` using `std::fs::File::create`. If the file already exists, its contents are truncated. Returns a `Result` containing the `File` handle or an I/O error.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_104\n\nLANGUAGE: Rust\nCODE:\n```\nFile::create(PATH)?\n```\n\n----------------------------------------\n\nTITLE: Defining Functions and Methods in Rust\nDESCRIPTION: Examples of function and method definitions in Rust, including functions that return values and methods that operate on a type via 'self' parameter.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nfn f() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn f() -> S {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nfn f(&self) {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nstruct S(T);\n```\n\n----------------------------------------\n\nTITLE: Lifetimes in Rust Functions Example\nDESCRIPTION: This example demonstrates how lifetimes are used in Rust functions to ensure that references passed as arguments remain valid for the duration of the function call. It involves defining a function with lifetime annotations and passing references to variables as arguments.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_61\n\nLANGUAGE: rust\nCODE:\n```\nfn f(x: &S, y:&S) -> &u8 { … }\n\nlet b = S(1);\nlet c = S(2);\n\nlet r = f(&b, &c);\n```\n\n----------------------------------------\n\nTITLE: Splitting Strings by Pattern in Rust\nDESCRIPTION: Splits a string `s` into an iterator of subslices based on a given pattern. The pattern can be a `&str`, a `char`, or a closure (like `char::is_numeric`) that matches characters.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_100\n\nLANGUAGE: Rust\nCODE:\n```\ns.split(pattern)\n```\n\nLANGUAGE: Rust\nCODE:\n```\ns.split(\"abc\")\n```\n\nLANGUAGE: Rust\nCODE:\n```\ns.split('/')\n```\n\nLANGUAGE: Rust\nCODE:\n```\ns.split(char::is_numeric)\n```\n\n----------------------------------------\n\nTITLE: Error and Absence Handling with the `?` Operator - Rust\nDESCRIPTION: Shows idiomatic use of Rust's `?` operator for propagating errors or handling absent values in functions returning `Result` or `Option`. This approach simplifies error handling without verbose match statements.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_190\n\nLANGUAGE: Rust\nCODE:\n```\ny = try_something()?;\nget_option()?.run()?\n```\n\n----------------------------------------\n\nTITLE: Creating/Opening a File with Specific Options in Rust\nDESCRIPTION: Uses `std::fs::OpenOptions` to create or open a file at `PATH` with specific flags: `create(true)` allows creation if it doesn't exist, `write(true)` enables writing, and `truncate(true)` clears the file if it exists upon opening. Returns a `Result`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_105\n\nLANGUAGE: Rust\nCODE:\n```\nOpenOptions::new().create(true).write(true).truncate(true).open(PATH)?\n```\n\n----------------------------------------\n\nTITLE: Explaining Lifetime Annotations in Rust: r: &'c S\nDESCRIPTION: This code explains the semantics of Rust's lifetime annotation `'c` in the context of a reference `r: &'c S`. It describes how the lifetime parameter links the lifetime of the reference to the data it points to, ensuring data validity for the duration `'c`. The example clarifies Rust's borrow checking rules and lifetime scope constraints.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_57\n\nLANGUAGE: Rust\nCODE:\n```\nr: &'c S\n```\n\n----------------------------------------\n\nTITLE: Splitting Strings using Regular Expressions in Rust\nDESCRIPTION: Splits a string using a regular expression pattern. Requires the `regex` crate. Uses `Regex::new` to compile the pattern (which can fail, hence `?`) and `split` to perform the splitting.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_103\n\nLANGUAGE: Rust\nCODE:\n```\n Regex::new(r\"\\s\")?.split(\"one two three\")\n```\n\n----------------------------------------\n\nTITLE: Using `Into` Trait for Type Computation in Rust\nDESCRIPTION: Shows how to perform type conversion using the `.into()` method, typically derived from implementing the `From` trait (`impl From<A> for B {}`). This represents a common, idiomatic way in Rust to handle explicit, infallible conversions defined by the user or standard library.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_183\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(x: A) -> B {\n    x.into()\n}\n```\n\n----------------------------------------\n\nTITLE: Obtaining Iterators in Rust\nDESCRIPTION: Methods for obtaining iterators from collections, showing the differences between into_iter(), iter(), and iter_mut(), along with basic Iterator usage.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_118\n\nLANGUAGE: rust\nCODE:\n```\n// Turn collection into iterator (consumes collection)\nc.into_iter()\n\n// Get borrowing iterator (doesn't consume collection)\nc.iter()\n\n// Get mutably borrowing iterator\nc.iter_mut()\n\n// Get next element from iterator\ni.next()\n\n// For loop (calls into_iter() implicitly)\nfor x in c {}\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Structs with Lifetime Parameters (Rust)\nDESCRIPTION: Shows how to define a struct that is generic over a lifetime `'a`. This is necessary when the struct contains references that are valid only for a specific duration, indicated by the lifetime parameter. Lifetimes function similarly to type parameters.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_180\n\nLANGUAGE: Rust\nCODE:\n```\nstruct S<'a> {\n    x: &'a u32\n}\n```\n\n----------------------------------------\n\nTITLE: Type Aliases and Casting in Rust - Rust\nDESCRIPTION: Explains type aliases with `type T = S;` as shorthand for existing types and the usage of special `Self` type aliases within impl blocks. Details method receiver syntaxes including `self`, `&self`, `&mut self`, and arbitrary self types such as `self: Box<Self>`. Introduces fully qualified syntax `<S as T>` to disambiguate method calls. Covers import renaming with `as` and primitive type casting using `as`. Highlights semantic implications such as potential truncation in casts.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_39\n\nLANGUAGE: Rust\nCODE:\n```\ntype T = S;\nSelf\nself\n&self\n&mut self\nself: Box<Self>\n<S as T>\na::b as c\nx as u32\n```\n\n----------------------------------------\n\nTITLE: Iterating and Mutating `&mut [T]` via Interior Mutability in Rust\nDESCRIPTION: Uses `std::cell::Cell` to work around borrowing rules for mutable slices (`&mut [T]`) where `T` implements `Copy`. It converts the mutable slice into a slice of `Cell`s, allowing immutable iteration while still permitting mutation of individual elements via `Cell::set`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_111\n\nLANGUAGE: Rust\nCODE:\n```\nCell::from_mut(mut_slice).as_slice_of_cells()\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust Macro with Variable Arguments\nDESCRIPTION: Defines a `macro_rules!` macro named `var_args` that accepts zero or more expressions (`$args:expr`) separated by commas. The `$($...)*` syntax handles this repetition.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_107\n\nLANGUAGE: Rust\nCODE:\n```\nmacro_rules! var_args { ($($args:expr),*) => {{ }} }\n```\n\n----------------------------------------\n\nTITLE: Declaring Lifetime Parameter - Rust\nDESCRIPTION: Declares a lifetime parameter `'a`. Lifetimes describe the duration for which a reference is valid during static analysis, ensuring references do not outlive the data they point to. They are typically used with generics.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\n'a\n```\n\n----------------------------------------\n\nTITLE: Exclusive Reference with Lifetime - Rust\nDESCRIPTION: Declares an exclusive (mutable) reference type `&'a mut S` annotated with a lifetime parameter `'a`. This requires the mutable reference to be valid for at least the duration specified by `'a`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\n&'a mut S\n```\n\n----------------------------------------\n\nTITLE: Struct with Lifetime Parameter - Rust\nDESCRIPTION: Declares a struct `S` that holds data with a lifetime specified by the parameter `'a`. This signals that the struct itself contains one or more references (or types containing references) whose validity is tied to `'a`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\nstruct S<'a> {}\n```\n\n----------------------------------------\n\nTITLE: Using Variable Arguments within a Rust Macro Expansion\nDESCRIPTION: Demonstrates how to use captured variable arguments (`$args`) within a macro's expansion body. This specific example iterates through the captured arguments and calls a function `f` for each one.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_108\n\nLANGUAGE: Rust\nCODE:\n```\n $( f($args); )*\n```\n\n----------------------------------------\n\nTITLE: Working with References and Lifetimes in Rust\nDESCRIPTION: This code snippet demonstrates the use of references, lifetimes and mutability in Rust.  It defines functions that take various combinations of references (including double references and mutable references) and returns either short or long lived references. Several test cases are shown using `ra` to exhibit the lifetime rules.  The code highlights potential issues related to mutability and aliasing. Compilation will fail in some cases. Dependencies are assumed to be the Rust programming language itself. Key parameters are the lifetime annotations `'a` and `'b`, which control the lifetime of the reference, and the `mut` keyword to indicate mutability.  The main output is the compilation success or failure; also, it showcases how compute takes &S and &S as parameters. There is a general understanding of Rust references, mutability and lifetimes.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_65\n\nLANGUAGE: Rust\nCODE:\n```\n// Return short ('b) reference\nfn f1sr<'b, 'a>(rb: &'b     &'a     S) -> &'b     S { *rb }\nfn f2sr<'b, 'a>(rb: &'b     &'a mut S) -> &'b     S { *rb }\nfn f3sr<'b, 'a>(rb: &'b mut &'a     S) -> &'b     S { *rb }\nfn f4sr<'b, 'a>(rb: &'b mut &'a mut S) -> &'b     S { *rb }\n\n// Return short ('b) mutable reference.\n// f1sm<'b, 'a>(rb: &'b     &'a     S) -> &'b mut S { *rb } // M\n// f2sm<'b, 'a>(rb: &'b     &'a mut S) -> &'b mut S { *rb } // M\n// f3sm<'b, 'a>(rb: &'b mut &'a     S) -> &'b mut S { *rb } // M\nfn f4sm<'b, 'a>(rb: &'b mut &'a mut S) -> &'b mut S { *rb }\n\n// Return long ('a) reference.\nfn f1lr<'b, 'a>(rb: &'b     &'a     S) -> &'a     S { *rb }\n// f2lr<'b, 'a>(rb: &'b     &'a mut S) -> &'a     S { *rb } // L\nfn f3lr<'b, 'a>(rb: &'b mut &'a     S) -> &'a     S { *rb }\n// f4lr<'b, 'a>(rb: &'b mut &'a mut S) -> &'a     S { *rb } // L\n\n// Return long ('a) mutable reference.\n// f1lm<'b, 'a>(rb: &'b     &'a     S) -> &'a mut S { *rb } // M\n// f2lm<'b, 'a>(rb: &'b     &'a mut S) -> &'a mut S { *rb } // M\n// f3lm<'b, 'a>(rb: &'b mut &'a     S) -> &'a mut S { *rb } // M\n// f4lm<'b, 'a>(rb: &'b mut &'a mut S) -> &'a mut S { *rb } // L\n\n// Now assume we have a `ra` somewhere\nlet mut ra: &'a mut S = …;\n\nlet rval = f1sr(&&*ra);       // OK\nlet rval = f2sr(&&mut *ra);\nlet rval = f3sr(&mut &*ra);\nlet rval = f4sr(&mut ra);\n\n//  rval = f1sm(&&*ra);       // Would be bad, since rval would be mutable\n//  rval = f2sm(&&mut *ra);   // reference obtained from broken mutability\n//  rval = f3sm(&mut &*ra);   // chain.\nlet rval = f4sm(&mut ra);\n\nlet rval = f1lr(&&*ra);\n//  rval = f2lr(&&mut *ra);   // If this worked we'd have `rval` and `ra` …\nlet rval = f3lr(&mut &*ra);\n//  rval = f4lr(&mut ra);     // … now (mut) aliasing `S` in compute below.\n\n//  rval = f1lm(&&*ra);       // Same as above, fails for mut-chain reasons.\n//  rval = f2lm(&&mut *ra);   //                    \"\n//  rval = f3lm(&mut &*ra);   //                    \"\n//  rval = f4lm(&mut ra);     // Same as above, fails for aliasing reasons.\n\n// Some fictitious place where we use `ra` and `rval`, both alive.\ncompute(ra, rval);\n```\n\n----------------------------------------\n\nTITLE: Casting Integer Types in Rust - Rust\nDESCRIPTION: Demonstrates explicit casting of unsigned or larger integer values to `i8` type in Rust, showcasing how excess bits are truncated and sign bits may affect the result. No external dependencies are required. The expressions `_257 as i8` and `_200 as i8` illustrate how values outside the `i8` range wrap around due to bit truncation. Inputs are integer values; output is a signed 8-bit integer. Limitations include possible misinterpretation of the sign in resulting values beyond the representable range.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_67\n\nLANGUAGE: Rust\nCODE:\n```\n_257 as i8\n```\n\nLANGUAGE: Rust\nCODE:\n```\n_200 as i8\n```\n\n----------------------------------------\n\nTITLE: Declaring Macro Fragments Using macro_rules! in Rust\nDESCRIPTION: Demonstrates usage of fragment specifiers in Rust's declarative macros via macro_rules! to capture various types of syntax elements such as types, expressions, identifiers, and patterns. Includes a sample macro declaration showing the capture of a type parameter with `$x:ty`. These macro fragments are essential for writing flexible and robust macros in Rust that parse and generate code accurately.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_152\n\nLANGUAGE: Rust\nCODE:\n```\nmacro_rules! my_macro {\n    ($x:ty) => { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Exclusive Borrow - Rust\nDESCRIPTION: Creates an exclusive (mutable) borrow of a value `s`. This expression evaluates to a mutable reference value (`&mut s`). Only one exclusive borrow is allowed at any given time for a specific piece of data.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n&mut s\n```\n\n----------------------------------------\n\nTITLE: Declaring Shared Reference Type - Rust\nDESCRIPTION: Declares a type that represents a shared reference to a value of type `S`. This type can hold any shared borrow `&s` of type `S`. This is a fundamental reference type in Rust's ownership system.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n&S\n```\n\n----------------------------------------\n\nTITLE: Function Types and Callable Traits in Rust\nDESCRIPTION: Examples of function reference types and callable traits. These are used to work with references to functions and types that can be called like functions, including closures.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\nfn() -> S\n```\n\nLANGUAGE: rust\nCODE:\n```\nFn() -> S\n```\n\nLANGUAGE: rust\nCODE:\n```\nAsyncFn() -> S\n```\n\n----------------------------------------\n\nTITLE: Handling Mutable References with Lifetime Constraints in Rust\nDESCRIPTION: This code discusses mutable references `mut r: &mut 'c S` and their scope-lifetime assurance in Rust. It illustrates how the `'c` lifetime parameter specifies the validity span of the reference, enforcing that only data with compatible lifetimes can be assigned or borrowed mutably. The example highlights the rules for safe mutation and borrow checking, preventing dangling references.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_59\n\nLANGUAGE: Rust\nCODE:\n```\nmut r: &mut 'c S\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Generics with Constraints in Rust\nDESCRIPTION: This snippet explains how to define generic types and functions in Rust, using type parameters with trait bounds (`where` clauses) to restrict type applicability. It covers trait bounds, compound bounds, lifetime bounds, and const generics. Key parameters include generic type parameters (e.g., `T`), traits (e.g., `R`, `S`), lifetimes (e.g., `'a`), and constant values as generic arguments. The snippet highlights different syntaxes for bounds, default parameters, generic associated types, and existential types for return values. Inputs are generic types or constants, and outputs are types or functions constrained by traits or lifetimes. Dependencies include Rust's trait system and lifetime semantics.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_40\n\nLANGUAGE: Rust\nCODE:\n```\nstruct S<T> {}\nS<T> where T: R\n// Trait bounds: multiple trait constraints on generic type parameters\n// Example: where T: R + S\n\nimpl<T> S<T> {}\n// Generic implementation for all types T\n\nimpl S<T> {}\n// Inherent implementation for specific type T\n\nfn f() -> impl T\n// Existential type return, returns some type implementing trait T\n\nfn f(x: &impl T)\n// Trait bound syntax for function parameters\n\nfn f(x: &dyn T)\n// Dynamic dispatch with trait objects\n\nfn f<X: T>(x: X)\n// Generic function that is monomorphized for each type implementing T\n\nwhere T: ?Sized\n// Opt out of the Sized trait bound for generic type T\n\nS<const N: usize>\n// Generic const parameter\n\nS<T = R>\n// Default generic parameters for Types and Consts\n\nfn f() -> impl T + 'a\n// Existential return with lifetime bound\n\nfn f() -> impl T + use<'a>\n// Existential return with use lifetime capture (unstable)\n\n```\n\n----------------------------------------\n\nTITLE: Shared Reference with Lifetime - Rust\nDESCRIPTION: Declares a shared reference type `&'a S` that is explicitly annotated with a lifetime parameter `'a`. This indicates that the reference must be valid for at least the duration specified by `'a`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\n&'a S\n```\n\n----------------------------------------\n\nTITLE: Dereferencing Reference - Rust\nDESCRIPTION: Uses the dereference operator `*` on a reference `r` (either shared `&` or exclusive `&mut`) to access the value that the reference points to. This operation yields the value itself, allowing reading or writing (if `r` is mutable).\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_17\n\nLANGUAGE: Rust\nCODE:\n```\n*r\n```\n\n----------------------------------------\n\nTITLE: Defining and Working with Traits in Rust\nDESCRIPTION: Examples of trait definition and implementation in Rust, showing basic traits, supertraits, and implementation for types. Traits define common behavior that types can implement.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\ntrait T {}\n```\n\nLANGUAGE: rust\nCODE:\n```\ntrait T : R {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl T for S {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nimpl !T for S {}\n```\n\n----------------------------------------\n\nTITLE: Defining Traits with Generics in Rust\nDESCRIPTION: This code demonstrates how to define traits with generic type parameters in Rust. It shows how the type parameter `I` can be used to allow users to customize the API and how associated types can be used to define output types. The code also shows how traits can be implemented for specific types and for generic types with constraints.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_171\n\nLANGUAGE: Rust\nCODE:\n```\ntrait A<I> { }\ntrait B { type O; }\n\n// Implementor adds (X, u32) to A.\nimpl A<u32> for X { }\n\n// Implementor adds family impl. (X, …) to A, user can materialze.\nimpl<T> A<T> for Y { }\n\n// Implementor must decide specific entry (X, O) added to B.\nimpl B for X { type O = u32; }\n```\n\n----------------------------------------\n\nTITLE: Declaring a Struct with Multiple Trait Bounds\nDESCRIPTION: This snippet shows how to define multiple trait bounds in a `where` clause. It demonstrates restricting a generic type `T` such that `T` must implement traits `X` and `Y`. It can be used to perform various operations with these trait bounds.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_167\n\nLANGUAGE: Rust\nCODE:\n```\nstruct S<T>\nwhere\n```\n\n----------------------------------------\n\nTITLE: Concatenating Strings using format! Macro in Rust\nDESCRIPTION: Concatenates variables `x` and `y` (which implement `Display`) into a new String using the `format!` macro. This allocates a new string. Consider `write!` or `std::ops::Add` if inputs aren't needed afterwards. Requires Rust edition '21 or later.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_98\n\nLANGUAGE: Rust\nCODE:\n```\nformat!(\"{x}{y}\")\n```\n\n----------------------------------------\n\nTITLE: Moving a Variable Value in Rust\nDESCRIPTION: This snippet illustrates move semantics where a value from variable 't' is moved into the new variable 'a'. After the move, the variable 't' becomes invalid and further access results in a compile-time error. If the underlying type 'S' implements the Copy trait, a copy is made instead. Dependencies: both 'S' and valid source variable 't'. Inputs are an initialized variable, and output is a new variable owning the value. Limitation: After the move, 't' should not be used unless it implements Copy.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_49\n\nLANGUAGE: Rust\nCODE:\n```\nlet a = t;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Closure Capture Modes and Anonymous Closure Types in Rust\nDESCRIPTION: This snippet demonstrates closures in Rust with emphasis on how local environment variables are captured: either moved into the closure or referenced. It shows example closure expressions with capture modes including move closures capturing ownership of variables 'y' and 'z', generating an anonymous closure type C1, and closure capturing by reference generating type C2. The snippet visually represents captured fields inside closure structs and notes function traits (FnOnce, FnMut, Fn) implementations depending on captured types. It clarifies how closures encapsulate environment state along with callable code.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_83\n\nLANGUAGE: rust\nCODE:\n```\nlet y = ...;\nlet z = ...;\n\nwith_closure(move |x| x + y.f() + z); // move captures y and z by value (closure type C1)\nwith_closure(|x| x + y.f() + z);      // captures y and z by reference (closure type C2)\n\n// Visualization:\n// C1 closure contains owned fields Y and Z\n// C2 closure contains pointer fields to Y and Z\n\n// Anonymous closure types are compiler-generated structs holding captured data\n// and implement FnOnce, FnMut, or Fn traits based on capture mode.\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Input Parameters in Rust\nDESCRIPTION: This code defines a trait `Query` with a generic input parameter `I`. The trait has a `search` method that takes a value of type `I` as input. Implementations are provided for `PostgreSQL` and `Sled` types with different types for `I`. The trait author assumes the implementor would customize the API in multiple ways for the same `Self` type, and users may want the ability to decide for which `I`-types behavior should be possible.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_173\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Query<I> {\n    fn search(&self, needle: I);\n}\n\nimpl Query<&str> for PostgreSQL { … }\nimpl Query<String> for PostgreSQL { … }\nimpl<T> Query<T> for Sled where T: ToU8Slice { … }\n\npostgres.search(\"SELECT …\");\npostgres.search(input.to_string());\nsled.search(file);\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Type Families Using impl<T> in Rust\nDESCRIPTION: Demonstrates how to write a generic implementation block 'impl<T>' for a struct 'S<T>' where 'T' must implement multiple traits (Absolute, Dim, Mul). Shows how the compiler materializes methods for concrete types that fulfill these trait bounds. Dependencies include defining the traits used in bounds. The snippet illustrates usage of generic code to abstractly define behaviors for families of types and how Rust monomorphizes functions at compile time.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_168\n\nLANGUAGE: Rust\nCODE:\n```\nimpl<T> S<T> where T: Absolute + Dim + Mul {\n    fn f(&self, x: T) { … };\n}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n// If compiler encounters this, it will\n// - check `0` and `x` fulfill the membership requirements of `T`\n// - create two new version of `f`, one for `char`, another one for `u32`.\n// - based on \"family implementation\" provided\ns.f(0_u32);\ns.f('x');\n```\n\n----------------------------------------\n\nTITLE: Trait with Lifetime Parameter - Rust\nDESCRIPTION: Declares a trait `T` with a lifetime parameter `'a`. Any type implementing this trait (`impl T for S`) might contain references whose validity is constrained by `'a`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_26\n\nLANGUAGE: Rust\nCODE:\n```\ntrait T<'a> {}\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion via Subtyping (Lifetimes) in Rust\nDESCRIPTION: Illustrates automatic type conversion based on Rust's subtyping rules, which primarily apply to lifetimes. Type `A` can be implicitly converted to `B` if they differ only in lifetimes and `A`'s lifetimes are subtypes of `B`'s (e.g., `&'static T` can become `&'a T`). The function implicitly returns `x` as type `B` due to these rules.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_186\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(x: A) -> B {\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Rust Type Sizing with Struct Definitions\nDESCRIPTION: Demonstrates how struct sizing (`Sized` vs. dynamically sized) is determined by its fields. Structs with only `Sized` fields are `Sized`. Structs containing a dynamically sized type (DST) become DSTs themselves. Generic structs have an implicit `Sized` bound unless `?Sized` is used. Zero-sized structs consume no memory.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_176\n\nLANGUAGE: Rust\nCODE:\n```\nstruct A { x: u8 }\nstruct B { x: [u8] }\nstruct C<T> { x: T }\nstruct D<T: ?Sized> { x: T }\nstruct E;\n```\n\n----------------------------------------\n\nTITLE: Rust Documentation Comment Syntax and Usage\nDESCRIPTION: This snippet explains Rust's various comment types used for documentation and internal annotations, including their syntax and typical usage contexts. It guides how to write effective documentation comments and notes the commonly discouraged block comments.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_43\n\nLANGUAGE: Rust\nCODE:\n```\n/// Outer line doc comment for documenting items such as traits or functions.\n//! Inner line doc comment, typically placed at the top of files.\n// Line comment for documenting code flow or internal notes.\n/* ... */ Block comment, generally discouraged due to UX issues.\n/** ... */ Outer block doc comment, used for detailed documentation.\n/*! ... */ Inner block doc comment, mainly for internal documentation.\n```\n\n----------------------------------------\n\nTITLE: Representing Vec<T> Memory Layout in Rust\nDESCRIPTION: Describes the memory layout of `Vec<T>`, a growable array (vector) in Rust. It consists of a pointer (`ptr`) to the heap allocation, the current length (`len` - number of initialized elements), and the total capacity (`capacity`) of the allocated buffer on the heap.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_85\n\nLANGUAGE: Rust\nCODE:\n```\nVec<T>\n```\n\n----------------------------------------\n\nTITLE: Implicit Type Coercion in Rust\nDESCRIPTION: Shows an example where Rust automatically coerces type `A` to type `B` without explicit syntax, typically when 'weakening' a type (e.g., `&mut T` to `&T`, `&T` to `*const T`) or via deref/unsizing coercions. The function body simply returns `x`, relying on the compiler's implicit coercion rules.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_185\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(x: A) -> B {\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Representing Box<T> Memory Layout in Rust\nDESCRIPTION: Describes the memory layout of `Box<T>`, a smart pointer in Rust that allocates data `T` on the heap. The stack proxy holds a pointer (`ptr`) and potentially metadata (`meta`) for unsized types (e.g., `Box<[T]>`) pointing to the heap-allocated `T`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_84\n\nLANGUAGE: Rust\nCODE:\n```\nBox<T>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variable Lifetimes and Drop in Rust\nDESCRIPTION: This snippet demonstrates how Rust manages the lifetime of values within scopes, particularly focusing on the `Drop` trait and the impact of bindings such as `_` and `ref` on when values are dropped. It uses a closure `f` to create pairs of `S` values and illustrates how values are handled based on their binding. The dependencies are the Rust standard library. The key parameter is the binding of the value to either the scope, immediately or reference to keep the value around longer. The output shows the timing of the dropped values, with some being immediately dropped, and others being dropped at the end of the scope.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_66\n\nLANGUAGE: Rust\nCODE:\n```\n{\n    let f = |x, y| (S(x), S(y)); // Function returning two 'Droppables'.\n\n    let (    x1, y) = f(1, 4);  // S(1) - Scope   S(4) - Scope\n    let (    x2, _) = f(2, 5);  // S(2) - Scope   S(5) - Immediately\n    let (ref x3, _) = f(3, 6);  // S(3) - Scope   S(6) - Scope\n\n    println!(\"…\");\n}\n```\n\n----------------------------------------\n\nTITLE: Conversion from &str to Hashable String Types\nDESCRIPTION: This snippet explains converting &str to different string-related types, such as String, CString, OsString, and PathBuf. It ensures data is properly transmuted into the target type, with usage of constructors like CString::new() and PathBuf::from(), and underscores the safety considerations of null-terminated strings and encoding compatibility.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_125\n\nLANGUAGE: Rust\nCODE:\n```\nx.to_string()\n```\n\nLANGUAGE: Rust\nCODE:\n```\nCString::new(x)?\n```\n\nLANGUAGE: Rust\nCODE:\n```\nPathBuf::from(x)\n```\n\n----------------------------------------\n\nTITLE: Implementing For Loop Support in Rust\nDESCRIPTION: How to make a custom collection work with for loops by implementing IntoIterator for the collection itself and its reference types.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_120\n\nLANGUAGE: rust\nCODE:\n```\n// Support for: for x in c {}\nimpl<T> IntoIterator for Collection<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n    \n    fn into_iter(self) -> Self::IntoIter {\n        // Create and return IntoIter<T>\n    }\n}\n\n// Support for: for x in &c {}\nimpl<T> IntoIterator for &Collection<T> {\n    type Item = &T;\n    type IntoIter = Iter<T>;\n    \n    fn into_iter(self) -> Self::IntoIter {\n        // Create and return Iter<T>\n    }\n}\n\n// Support for: for x in &mut c {}\nimpl<T> IntoIterator for &mut Collection<T> {\n    type Item = &mut T;\n    type IntoIter = IterMut<T>;\n    \n    fn into_iter(self) -> Self::IntoIter {\n        // Create and return IterMut<T>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Shared Slice Reference Type - Rust\nDESCRIPTION: Declares a type that represents a shared reference to a slice of elements of type `S`. A slice reference contains both the address of the first element (`addr`) and the number of elements (`count`).\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n&[S]\n```\n\n----------------------------------------\n\nTITLE: Initializing Application Main Function - Rust\nDESCRIPTION: Defines the entry point for a Rust application, printing \"Hello, world!\". This is the basic structure for an application's `main.rs` file. No dependencies required.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_131\n\nLANGUAGE: Rust\nCODE:\n```\n// src/main.rs (default application entry point)\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Library Public Function - Rust\nDESCRIPTION: Defines the entry point for a Rust library with a public function `f`. Demonstrates how to create a public function and a module with a non-public path. No external dependencies are required.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_132\n\nLANGUAGE: Rust\nCODE:\n```\n// src/lib.rs (default library entry point)\n\npub fn f() {}      // Is a public item in root, so it's accessible from the outside.\n\nmod m {\n    pub fn g() {}  // No public path (`m` not public) from root, so `g`\n}                  // is not accessible from the outside of the crate.\n```\n\n----------------------------------------\n\nTITLE: Let Ref Mut Destructuring - Rust\nDESCRIPTION: Shows how `ref mut` can be used within pattern matching, specifically struct destructuring. `let S { ref mut x } = s;` creates a mutable reference binding `x` that points to the `x` field within `s`. This is a shorthand for `let x = &mut s.x;`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_16\n\nLANGUAGE: Rust\nCODE:\n```\nlet S { ref mut x } = s;\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust Struct\nDESCRIPTION: This code snippet demonstrates how to define an empty struct in Rust. Structs are used to group related data together.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_139\n\nLANGUAGE: Rust\nCODE:\n```\nstruct X {}\n```\n\n----------------------------------------\n\nTITLE: Basic Iterator Usage Patterns in Rust\nDESCRIPTION: Overview of four common styles of collection iteration in Rust, including imperative for loops, functional chains, low-level iteration, and manual access.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_117\n\nLANGUAGE: rust\nCODE:\n```\n// Imperative style with for loop\nfor x in c { ... }\n\n// Functional style with iterator methods\nc.iter().map().filter()\n\n// Low-level iteration with next()\nc_iter.next()\n\n// Manual access with get()\nc.get(n)\n```\n\n----------------------------------------\n\nTITLE: Declaring Mutable Raw Pointer Type - Rust\nDESCRIPTION: Declares a type for a mutable raw pointer to data of type `S`. Like `*const S`, it provides no memory safety guarantees and requires `unsafe` blocks for dereferencing or manipulation.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\n*mut S\n```\n\n----------------------------------------\n\nTITLE: Declaring Trait Object Reference Type - Rust\nDESCRIPTION: Declares a special reference type that refers to a value implementing the trait `T`. This 'fat pointer' contains the address of the value (`addr`) and a vtable (virtual method table). The trait `T` must be object safe.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n&dyn T\n```\n\n----------------------------------------\n\nTITLE: Rust Common Operators and Syntax Conventions\nDESCRIPTION: This snippet mentions Rust's support for various operators and their overloading capabilities, emphasizing that operators behave consistently across the language. It highlights language features like numeric separators, literals, and type annotations.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_45\n\nLANGUAGE: Rust\nCODE:\n```\n+, *, %, =, ==, etc. - Supported operators, including overloading.\n1_234_567 - Numeric separator for readability.\n0xBEEF, 0o777, 0b1001 - Hexadecimal, octal, and binary literals.\nx; - Statement terminator.\nType suffixes like 1_u8 or 0xff - Numeric literal type annotations.\n```\n\n----------------------------------------\n\nTITLE: Trait Implementation and Tooling Recommendations - Rust\nDESCRIPTION: Encourages deriving common traits like Debug and Copy for usability, writing custom trait implementations when needed, and integrating tools like Clippy for linting, rustfmt for formatting, as well as unit and doc tests to maintain high code quality.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_196\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Debug, Copy, ...)]\n// Use clippy, rustfmt, #[test], doc tests to improve and verify code\n```\n\n----------------------------------------\n\nTITLE: Cow<'a, T> Structure Visualization\nDESCRIPTION: Illustrates the structure of `Cow<'a, T>` (Clone-on-Write) in Rust. It can either hold a read-only reference to `T` or own its `ToOwned` analog. This allows efficient borrowing when possible, and cloning only when mutation is needed.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_97\n\nLANGUAGE: rust\nCODE:\n```\n<code>Cow&lt;'a, T&gt;</code> {{ std(page=\"std/borrow/enum.Cow.html\") }}\n```\n\n----------------------------------------\n\nTITLE: Defining Blanket Trait Implementations with Rust's impl<T> Syntax\nDESCRIPTION: Shows how to implement a trait for any type 'T' that satisfies certain trait bounds, known as blanket implementations. Example provided implements 'Serialize' trait for any 'T' that implements 'ToHex'. This enables modular extension of traits to external or foreign types that conform to an interface. Requires the traits 'Serialize' and 'ToHex' to be defined. Inputs: any type implementing 'ToHex', Output: the type also implements 'Serialize'.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_169\n\nLANGUAGE: Rust\nCODE:\n```\n// Also implements Serialize for any type if that type already implements ToHex\nimpl<T> Serialize for T where T: ToHex { … }\n```\n\n----------------------------------------\n\nTITLE: Implementing Borrowing Iterators in Rust\nDESCRIPTION: How to create shared and mutable borrowing iterators for a custom collection, including convenience methods for obtaining these iterators.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_121\n\nLANGUAGE: rust\nCODE:\n```\n// Iterator struct for shared references\nstruct Iter<T> {}\n\n// Iterator struct for mutable references\nstruct IterMut<T> {}\n\n// Implement shared reference iteration\nimpl<T> Iterator for Iter<T> {\n    type Item = &T;\n    \n    fn next(&mut self) -> Option<Self::Item> {\n        // Return Some(&item) or None when done\n    }\n}\n\n// Implement mutable reference iteration\nimpl<T> Iterator for IterMut<T> {\n    type Item = &mut T;\n    \n    fn next(&mut self) -> Option<Self::Item> {\n        // Return Some(&mut item) or None when done\n    }\n}\n\n// Convenience methods for Collection\nimpl<T> Collection<T> {\n    fn iter(&self) -> Iter<T> {\n        // Create and return Iter<T>\n    }\n    \n    fn iter_mut(&mut self) -> IterMut<T> {\n        // Create and return IterMut<T>\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Number Conversions in Rust\nDESCRIPTION: This section provides methods for converting numbers between various primitive types and strings. It covers converting smaller integer types up to larger ones using try_from and casting, as well as string representation via to_string(). It also discusses the implications and limitations, such as truncation and potential misrepresentation when casting larger numbers to floating-point types.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_123\n\nLANGUAGE: Rust\nCODE:\n```\nu8::try_from(x)?\n```\n\nLANGUAGE: Rust\nCODE:\n```\nx as f32\n```\n\nLANGUAGE: Rust\nCODE:\n```\nx.to_string()\n```\n\nLANGUAGE: Rust\nCODE:\n```\nx.parse::<u8>()?\n```\n\n----------------------------------------\n\nTITLE: Embedding Rust Code Examples in Documentation Comments\nDESCRIPTION: Shows how Rust doc comments can contain code blocks that are automatically tested by cargo test, known as doc tests. The snippet illustrates the pattern for embedding Rust code examples in documentation to verify correctness and provide runnable samples. This includes the use of triple backticks and optional directives within code blocks to control compilation and execution behaviors.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_153\n\nLANGUAGE: Rust\nCODE:\n```\n/// Accepts an [`S`].\n///\n/// ```rust\n///     f(s);\n/// ```\n```\n\n----------------------------------------\n\nTITLE: Managing Testing and Benchmark Functions with Test Attributes in Rust\nDESCRIPTION: Applies test-related attributes such as #[test], #[ignore], #[should_panic], and #[bench] to designate test and benchmarking functions. These attributes enable cargo test and cargo bench to discover, select, or skip test functions, and set panic expectations. Use: functions to test/benchmark, often in test or bench modules/files. Output: test harness behaviors. Benchmarking support may be unstable or require nightly toolchains.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_159\n\nLANGUAGE: rust\nCODE:\n```\n#[test]\nfn it_works() { assert_eq!(2 + 2, 4); }\n\n#[ignore = \"temporarily flaky\"]\n#[test]\nfn flaky() { ... }\n\n#[should_panic]\n#[test]\nfn panics() { panic!(); }\n\n#[bench]\nfn bench_foo(b: &mut test::Bencher) { b.iter(|| 2 + 2); }\n```\n\n----------------------------------------\n\nTITLE: String Conversions to &str & String\nDESCRIPTION: This section details how to convert various Rust types to String or &str. It includes methods for valid UTF-8 conversion, such as from_utf8 for byte vectors and to_string() for string-like types. It ensures that data is correctly represented as UTF-8 strings, handling necessary dependencies and potential errors.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_124\n\nLANGUAGE: Rust\nCODE:\n```\nx.to_string()\n```\n\nLANGUAGE: Rust\nCODE:\n```\nString::from_utf8(x)?\n```\n\nLANGUAGE: Rust\nCODE:\n```\nstd::str::from_utf8(&x)?\n```\n\n----------------------------------------\n\nTITLE: Function Parameter with Lifetime - Rust\nDESCRIPTION: Declares a function `f` that takes a parameter `t` which is a shared reference annotated with lifetime `'a`. This explicitly names the lifetime of the input reference, allowing the compiler (or programmer) to relate input and output lifetimes.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_27\n\nLANGUAGE: Rust\nCODE:\n```\nfn f<'a>(t: &'a T)\n```\n\n----------------------------------------\n\nTITLE: Conversion from &Path and PathBuf to &str and String\nDESCRIPTION: This code demonstrates converting Path and PathBuf types to &str via to_str(), which may fail and thus require handling Option or Result. It also covers converting PathBuf to String through to_string() or from().\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_129\n\nLANGUAGE: Rust\nCODE:\n```\nx.to_str()? or Path::new(x)\n```\n\n----------------------------------------\n\nTITLE: Conversion from &CStr and &OsStr to String and PathBuf\nDESCRIPTION: This part provides methods to convert CStr and OsStr to Rust String and PathBuf. It emphasizes safety by converting via to_str() and handling possible errors with '?' operator. Also, demonstrates converting OsString to PathBuf or String through direct conversion and into_os_string().\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_126\n\nLANGUAGE: Rust\nCODE:\n```\nx.to_str()?.to_string()\n```\n\nLANGUAGE: Rust\nCODE:\n```\nOsString::from(x)\n```\n\n----------------------------------------\n\nTITLE: Applying Crate-Level Attributes in Rust Source Files\nDESCRIPTION: Contains examples of crate-level attributes applied to the whole crate, such as opting out of the Rust standard library with `#![no_std]` and enabling unstable features via `#![feature(xxx)]`. These attributes configure compilation behavior and feature usage globally within a crate or application, affecting everything from linking to entry point generation.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_154\n\nLANGUAGE: Rust\nCODE:\n```\n// Attributes usually found in toplevel project file.\n#![no_std]\n#![feature(xxx)]\n```\n\n----------------------------------------\n\nTITLE: Using Lifetime Parameters for Reference Tracking in Rust\nDESCRIPTION: Demonstrates how lifetime parameters in function signatures indicate which input a returned reference is based on. In this example, the returned reference is based on parameter 'c', allowing 'b' to be moved while 'c' remains locked.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_63\n\nLANGUAGE: rust\nCODE:\n```\nfn f<'b, 'c>(x: &'b S, y: &'c S) -> &'c u8 { … }\n\nlet b = S(1);\nlet c = S(2);\n\nlet r = f(&b, &c); // We know returned reference is `c`-based, which must stay locked,\n                   // while `b` is free to move.\n\nlet a = b;\n\nprint_byte(r);\n```\n\n----------------------------------------\n\nTITLE: Working with Closures in Rust\nDESCRIPTION: Examples of closures with different capture modes and argument patterns. Closures are anonymous functions that can capture values from their environment.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\n|| {}\n```\n\nLANGUAGE: rust\nCODE:\n```\n|x| {}\n```\n\nLANGUAGE: rust\nCODE:\n```\n|x| x + x\n```\n\nLANGUAGE: rust\nCODE:\n```\nmove |x| x + y\n```\n\nLANGUAGE: rust\nCODE:\n```\nasync |x| x + x\n```\n\nLANGUAGE: rust\nCODE:\n```\nasync move |x| x + y\n```\n\nLANGUAGE: rust\nCODE:\n```\nreturn || true\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Functions and Blocks in Rust\nDESCRIPTION: Examples of async functions and blocks that return Futures. These constructs are used for asynchronous programming, allowing operations to be suspended and resumed.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\nasync fn f() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nasync fn f() -> S {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nasync { x }\n```\n\nLANGUAGE: rust\nCODE:\n```\nasync move { x }\n```\n\n----------------------------------------\n\nTITLE: Generics Usage and Implementation Splitting in Rust - Rust\nDESCRIPTION: Recommends moderate use of generics to improve API flexibility while avoiding complexity. Shows splitting implementations per generic parameter to provide specialized behavior for certain types.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_195\n\nLANGUAGE: Rust\nCODE:\n```\nimpl<T> Point<T> { /* common methods */ }\nimpl Point<f32> { /* methods specific to f32 */ }\n```\n\n----------------------------------------\n\nTITLE: Conversion from Vec<u8> and &[u8] to String and CString\nDESCRIPTION: This snippet covers converting byte buffers to String and CString, utilizing from_utf8() and from_bytes_with_nul() for safe UTF-8 handling and proper C-style string formation, respectively. It highlights the importance of data validity and null-termination when interfacing with C libraries or OS functions.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_127\n\nLANGUAGE: Rust\nCODE:\n```\nString::from_utf8(x)?\n```\n\nLANGUAGE: Rust\nCODE:\n```\nCStr::from_bytes_with_nul(&x)?\n```\n\n----------------------------------------\n\nTITLE: Explaining Pointer Metadata for Rust References Rust\nDESCRIPTION: This snippet illustrates pointer metadata in Rust for multiple reference types. It differentiates between thin pointers (no metadata) and fat pointers that carry extra information such as length for slices or a vtable pointer for dynamic trait objects. Key types include &T for sized targets (thin pointer), &T for dynamically sized types with length metadata, &[T] slice references with length, &str string slices with byte length, and &'a dyn Trait fat pointers carrying a pointer to a vtable. Visualizations show pointer sizes and how metadata is stored, providing a conceptual understanding necessary for safe manipulation of unsized types and trait objects.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_82\n\nLANGUAGE: rust\nCODE:\n```\nNo direct executable Rust code; content includes conceptual illustrations and notation for pointer metadata in references such as:\n\n// Thin pointer example\n&'a T  // pointer size 2/4/8 bytes with no metadata\n\n// Fat pointer with length metadata for unsized types\n&'a T  // includes pointer and length\n\n// Slice reference\n&'a [T] // pointer + length\n\n// String slice\n&'a str // pointer + length byte count\n\n// Dynamic trait object\n&'a dyn Trait // pointer + pointer to vtable\n\nThe snippet uses diagrams and descriptions instead of runnable code.\n```\n\n----------------------------------------\n\nTITLE: Variable Unlocking After Last Reference Use in Rust\nDESCRIPTION: Shows how a variable is unlocked when the last use of any reference that may point to it ends. The variable 'c' remains locked while 's' is in use, but can be moved after 's' is no longer needed.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_64\n\nLANGUAGE: rust\nCODE:\n```\nlet mut c = S(2);\n\nlet r = f(&c);\nlet s = r;\n                    // <- Not here, `s` prolongs locking of `c`.\n\nprint_byte(s);\n\nlet a = c;          // <- But here, no more use of `r` or `s`.\n```\n\n----------------------------------------\n\nTITLE: Implementing Functionality for Types in Rust\nDESCRIPTION: Examples of implementation blocks for defining functionality on types. This shows how to add methods and associated functions to structs and other data types.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nimpl S {}\n```\n\n----------------------------------------\n\nTITLE: Using SeqCst Atomic Ordering in Rust\nDESCRIPTION: Description of the Sequential Consistency (SeqCst) memory ordering for atomic operations in Rust. SeqCst prevents reordering around atomic operations and ensures all unrelated reads and writes stay on the proper side of the operation.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_116\n\nLANGUAGE: markdown\nCODE:\n```\n| **`SeqCst`** {{ std(page=\"std/sync/atomic/enum.Ordering.html#variant.SeqCst\") }} | No reordering around atomic. All unrelated reads and writes stay on proper side. |\n```\n\n----------------------------------------\n\nTITLE: String Structure Visualization\nDESCRIPTION: Illustrates the memory layout of a `String` in Rust, showing the pointer to the heap-allocated buffer, the capacity, and the length. It highlights the difference between `String`, `&str`, and `&[char]`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_90\n\nLANGUAGE: rust\nCODE:\n```\n<code>String</code> {{ std(page=\"std/string/struct.String.html\") }}\n```\n\n----------------------------------------\n\nTITLE: Rust Abstract Machine Misconceptions\nDESCRIPTION: This snippet discusses common misconceptions about Rust's interaction with hardware, clarifying that Rust relies on an abstract machine model rather than direct CPU reasoning. It details how Rust handles invalid data, pointer provenance, and memory safety.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_47\n\n\n\n----------------------------------------\n\nTITLE: Closure Implementation Table\nDESCRIPTION: This table demonstrates the different ways a closure can capture its environment (by move, mutable reference, or reference) and which `Fn` traits it implements as a result.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_202\n\nLANGUAGE: Rust\nCODE:\n```\n &vert;&vert; { moved_s; }\n```\n\nLANGUAGE: Rust\nCODE:\n```\n &vert;&vert; { &mut s; }\n```\n\nLANGUAGE: Rust\nCODE:\n```\n &vert;&vert; { &s; }\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Check for Trait Object Safety in Rust\nDESCRIPTION: Provides a compile-time assertion using a `const` item assigned `None`. If the trait `T` is not object-safe (cannot be used to create a trait object like `&dyn T`), attempting to create the type `Option<&dyn T>` will result in a compilation error, thus acting as a safety check.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_113\n\nLANGUAGE: Rust\nCODE:\n```\nconst _: Option<&dyn T> = None;\n```\n\n----------------------------------------\n\nTITLE: Improving Code Quality Using Lint and Quality Attributes in Rust\nDESCRIPTION: Shows how #[allow], #[warn], #[deny], #[forbid], #[expect] manage linting levels for specified checks, while #[deprecated] and #[must_use] influence usage guidance and compiler checks. These attributes are placed above modules, items, or impl blocks, and control warnings, errors, or deprecated status. Required input: code elements to annotate. Output: compiler emissions or mandatory usage contracts. No external dependencies, but relies on rustc or clippy integration.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_158\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(dead_code)]\nfn unused() {}\n\n#[warn(clippy::all)]\nmod check_everything {}\n\n#[deny(missing_docs)]\nmod strict_docs {}\n\n#[forbid(unsafe_code)]\nmod safe_only {}\n\n#[expect(unreachable_code)]\nfn tricky() {}\n\n#[deprecated = \"use new_func instead\"]\nfn old_func() { }\n\n#[must_use = \"Return value must be handled\"]\nfn compute() -> i32 { 42 }\n```\n\n----------------------------------------\n\nTITLE: Cloning Variables for `move` Closures in Rust\nDESCRIPTION: Illustrates a pattern to explicitly clone variables (`outer.clone()`) from an outer scope before creating a `move` closure. This ensures the closure captures the cloned value (`c`) rather than potentially moving or borrowing the original `outer` variable.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_109\n\nLANGUAGE: Rust\nCODE:\n```\nwants_closure({ let c = outer.clone(); move || use_clone(c) })\n```\n\n----------------------------------------\n\nTITLE: Iterators Usage in Idiomatic Rust - Rust\nDESCRIPTION: Illustrates working with Rust iterators, mapping over ranges and filtering collections efficiently without explicit loops. Examples show lazy iterator creation using ranges and filters, capturing Rust's preference for iterator chains for sequence transformations.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_189\n\nLANGUAGE: Rust\nCODE:\n```\n(1..10).map(f).collect()\nnames.iter().filter(|x| x.starts_with(\"A\"))\n```\n\n----------------------------------------\n\nTITLE: Using a Macro Defined Within the Same Rust Crate\nDESCRIPTION: Shows how to define a macro (`internal_macro`) using `macro_rules!` and make it accessible only within the same crate by using `pub(crate) use internal_macro;`. This prevents the macro from being part of the crate's public API while allowing its use internally.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_115\n\nLANGUAGE: Rust\nCODE:\n```\nmacro_rules! internal_macro {}\npub(crate) use internal_macro;\n```\n\n----------------------------------------\n\nTITLE: Using Higher-Ranked Trait Bounds (HRTB) and Lifetimes in Rust\nDESCRIPTION: This snippet demonstrates how Rust supports higher-ranked trait bounds (`for<'a>`) which allow abstraction over all possible lifetimes, enabling more generic and flexible code patterns. It shows how to define traits and functions with higher-ranked lifetimes, function pointer types that accept parameters with any lifetime, and trait objects that incorporate such bounds. This mechanism extends Rust's borrowing and trait systems to scenarios where lifetimes are not fixed but universally quantified. Dependencies include understanding of lifetimes and traits in Rust.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_41\n\nLANGUAGE: Rust\nCODE:\n```\nfor<'a>\n// Marker for higher-ranked bounds, indicating generic over any lifetime\n\ntrait T: for<'a> R<'a> {}\n// Trait T requires implementing trait R for all lifetimes 'a\n\nfn(&'a u8)\n// Function pointer type with specific lifetime 'a\n\nfor<'a> fn(&'a u8)\n// Higher-ranked function pointer type accepting any lifetime\n\ndyn for<'a> Fn(&'a u8)\n// Trait object with higher-ranked lifetime bounds\n\nimpl<'a> T for fn(&'a u8) {}\n// Implementing trait T for fn pointer with specific lifetime\n\nimpl T for for<'a> fn(&'a u8) {}\n// Implementing trait T for fn pointer with any lifetime\n\n```\n\n----------------------------------------\n\nTITLE: Declaring Immutable Raw Pointer Type - Rust\nDESCRIPTION: Declares a type for an immutable raw pointer to data of type `S`. Raw pointers (`*const` and `*mut`) bypass Rust's ownership and borrowing rules, offering no memory safety guarantees. Their use requires `unsafe` blocks.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n*const S\n```\n\n----------------------------------------\n\nTITLE: Module Definition and Organization in Rust - Rust\nDESCRIPTION: Covers Rust module system syntax and semantics for organizing projects into smaller units. Defines inline modules using `mod m {}`, modules defined in separate files via `mod m;`, and namespace path expressions (`a::b`, `crate::b`, `self::b`, `super::b`, `::b`) to access items. Includes usage of `use` declarations to bring symbols into scope with renaming, glob imports, anonymous imports, and public visibility modifiers (`pub`, `pub(crate)`, `pub(super)`, etc.). Also references deprecated `extern crate` syntax and modern imports from external crates.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_38\n\nLANGUAGE: Rust\nCODE:\n```\nmod m {}\nmod m;\na::b\n::b\ncrate::b\nself::b\nsuper::b\nuse a::b;\nuse a::{b, c};\nuse a::b as x;\nuse a::b as _;\nuse a::*;\npub use a::b;\npub T\npub(crate) T\npub(super) T\npub(self) T\npub(in a::b) T\nextern crate a;\nextern \"C\" {}\nextern \"C\" fn f() {}\n```\n\n----------------------------------------\n\nTITLE: Unsafe Code in Rust\nDESCRIPTION: Examples of unsafe functions, traits, blocks, and implementations. Unsafe code bypasses some of Rust's safety guarantees and requires the programmer to uphold safety invariants manually.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nunsafe fn f() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nunsafe trait T {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nunsafe { f(); }\n```\n\nLANGUAGE: rust\nCODE:\n```\nunsafe impl T for S {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nunsafe extern \"abi\" {}\n```\n\nLANGUAGE: rust\nCODE:\n```\npub safe fn f();\n```\n\n----------------------------------------\n\nTITLE: Use of Attributes Governing Emitted Rust Code\nDESCRIPTION: Describes attributes affecting generated code in Rust, such as `#[non_exhaustive]` for forward-compatible structs/enums, `#[inline]` and variants to suggest inlining behavior, and `#[repr(C)]` for C-compatible layout of types. These attributes influence compiler code generation, API stability, and interoperability with other languages or systems.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_155\n\n\n\n----------------------------------------\n\nTITLE: Declaring an Array with Const Generic\nDESCRIPTION: This Rust snippet showcases the use of const generics. `MyArray` is a type constructor that accepts a concrete type `T` and a constant value `N` (of type `usize`) as a generic parameter to create a specific array type. It demonstrates the flexibility in specifying array sizes at compile time.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_165\n\nLANGUAGE: Rust\nCODE:\n```\nlet x: [u8; 4]; // \"array of 4 bytes\"\nlet y: [f32; 16]; // \"array of 16 floats\"\n\n// `MyArray` is type constructor requiring concrete type `T` and\n// concrete usize `N` to construct specific type.\nstruct MyArray<T, const N: usize> {\n    data: [T; N],\n}\n```\n\n----------------------------------------\n\nTITLE: Safe Rust Example\nDESCRIPTION: This code demonstrates a simple addition operation in safe Rust.  Safe Rust guarantees that the execution of this code is consistent with its specification. It does not guarantee that `y` is `2x`, as `X::add` might be implemented badly, nor that `y` is printed because `Y::fmt` may panic.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_204\n\nLANGUAGE: rust\nCODE:\n```\nlet y = x + x;  // Safe Rust only guarantees the execution of this code is consistent with\nprint(y);       // 'specification' (long story …). It does not guarantee that y is 2x\n                // (X::add might be implemented badly) nor that y is printed (Y::fmt may panic).\n```\n\n----------------------------------------\n\nTITLE: Panic Usage and Alternatives via Option and Result - Rust\nDESCRIPTION: Advises minimizing panics since they abort processes, preferring `Option` and `Result` return types to handle recoverable errors gracefully. Panics may be acceptable for programming errors or in `const` contexts, with clear documentation.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_194\n\nLANGUAGE: Rust\nCODE:\n```\npanic!();\n// Prefer Option<T> or Result<T,E> for recoverable errors.\n// Panics ok if explicitly requested or in const context like NonZero::new(1).unwrap()\n```\n\n----------------------------------------\n\nTITLE: Declaring Exclusive Reference Type - Rust\nDESCRIPTION: Declares a type that represents an exclusive (mutable) reference to a value of type `S`. This type allows mutation of the data it points to. Applies to other types like slices (`&mut [S]`) and trait objects (`&mut dyn S`) as well.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n&mut S\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Structs Opting Out of Sized Bound (Rust)\nDESCRIPTION: Demonstrates how to explicitly opt out of the default `Sized` bound for a generic type parameter using the `?Sized` trait bound in a `where` clause. This allows the generic type `S<T>` to be instantiated with dynamically sized types (DSTs) like `str`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_179\n\nLANGUAGE: Rust\nCODE:\n```\nstruct S<T> where T: ?Sized { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Creating Immutable Raw Pointer Expression - Rust\nDESCRIPTION: Creates an immutable raw pointer (`*const S`) directly from a value `s` without first creating a Rust reference (`&s`). This expression is facilitated by macros like `ptr::addr_of!()` and often considered esoteric.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\n&raw const s\n```\n\n----------------------------------------\n\nTITLE: Declaring a Struct with Type Parameter\nDESCRIPTION: This snippet defines a struct `S` that uses a generic type parameter `T`. The struct contains a field `x` of type `T`. This demonstrates how a generic type can be used within a struct definition, allowing the struct to hold different types based on the type parameter.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_164\n\nLANGUAGE: Rust\nCODE:\n```\n// S<> is type constructor with parameter T; user can supply any concrete type for T.\nstruct S<T> {\n    x: T\n}\n\n// Within 'concrete' code an existing type must be given for T.\nfn f() {\n    let x: S<f32> = S::new(0_f32);\n}\n```\n\n----------------------------------------\n\nTITLE: Unsafe Function Definition\nDESCRIPTION: This code defines an `unsafe` function that takes a raw mutable pointer to a `u8`. The function `my_native_lib` is assumed to be an external function that operates on this pointer. The author promises that `x` must always point to race-free, valid, aligned, initialized `u8` memory. The compiler will trust that this condition is upheld by the author.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_205\n\nLANGUAGE: rust\nCODE:\n```\n// `x` must always point to race-free, valid, aligned, initialized u8 memory.\nunsafe fn unsafe_f(x: *mut u8) {\n    my_native_lib(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Undefined Behavior Example\nDESCRIPTION: This code demonstrates how dereferencing a null pointer can lead to undefined behavior.  Even if the `else` branch is taken, the entire application is considered to have undefined behavior once the `unsafe` block has been executed. The effects of undefined behavior can be unpredictable and may not be immediately apparent.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_206\n\nLANGUAGE: rust\nCODE:\n```\nif maybe_true() {\n    let r: &u8 = unsafe { &*ptr::null() };   // Once this runs, ENTIRE app is undefined. Even if\n} else {                                     // line seemingly didn't do anything, app might now run\n    println!(\"the spanish inquisition\");     // both paths, corrupt database, or anything else.\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Via Mutable Dereference - Rust\nDESCRIPTION: Uses the dereference operator `*` with a mutable reference `r` on the left-hand side of an assignment. This moves or copies the value `s` into the memory location pointed to by `r`, effectively modifying the original data `r` references.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_18\n\nLANGUAGE: Rust\nCODE:\n```\n*r = s;\n```\n\n----------------------------------------\n\nTITLE: Struct Definitions and Potential Padding in Rust (Rust)\nDESCRIPTION: Declaration of a struct with fields: `struct S { b: B, c: C }`. The compiler may reorder fields or add padding bytes to satisfy alignment constraints unless platform or representation attributes enforce a particular layout.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_77\n\nLANGUAGE: Rust\nCODE:\n```\nstruct S { b: B, c: C }\n```\n\n----------------------------------------\n\nTITLE: Async Execution Flow Diagram\nDESCRIPTION: This diagram illustrates the execution flow of async code, showing how `.await` calls yield control and how the runtime manages future execution, including potential thread switching.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_199\n\nLANGUAGE: Rust\nCODE:\n```\n       consecutive_code();           consecutive_code();           consecutive_code();\nSTART --------------------> x.await --------------------> y.await --------------------> READY\n// ^                          ^     ^\n// Invoked via runtime        |     |\n// or an external .await      |     This might resume on another thread (next best available),\n//                            |     or NOT AT ALL if Future was dropped.\n//                            |\n//                            Execute `x`. If ready: just continue execution; if not, return\n//                            this thread to runtime.\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust Union\nDESCRIPTION: This code snippet demonstrates how to define a union in Rust. Unions are similar to structs but only one field can be active at any given time, saving memory.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_138\n\nLANGUAGE: Rust\nCODE:\n```\nunion X {}\n```\n\n----------------------------------------\n\nTITLE: Async Basics Table\nDESCRIPTION: This table explains the basic syntax and behavior of async/await in Rust, highlighting how async functions and blocks return futures and how execution is managed.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_198\n\n\n\n----------------------------------------\n\nTITLE: Representing LinkedList<T> Memory Layout in Rust\nDESCRIPTION: Describes the memory layout of `LinkedList<T>`, a doubly-linked list in Rust. It stores pointers to the head and tail nodes (`head`, `tail`) and the total length (`len`). Each node is individually heap-allocated and contains pointers to the previous (`prev`) and next (`next`) nodes along with the element `T`. Notes potential cache inefficiency due to scattered allocations.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_86\n\nLANGUAGE: Rust\nCODE:\n```\nLinkedList<T>\n```\n\n----------------------------------------\n\nTITLE: Proc Macro Attribute - Rust\nDESCRIPTION: Shows a basic procedural macro attribute definition. Demonstrates the required imports and structure for a procedural macro that simply returns the input token stream. Requires the `proc-macro` crate and `proc-macro = true` in Cargo.toml.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_137\n\nLANGUAGE: Rust\nCODE:\n```\n// src/lib.rs (default entry point for proc macros)\n\nextern crate proc_macro;  // Apparently needed to be imported like this.\n\nuse proc_macro::TokenStream;\n\n#[proc_macro_attribute]   // Crates can now use `#[my_attribute]`\npub fn my_attribute(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    item\n}\n```\n\nLANGUAGE: Rust\nCODE:\n```\n// Cargo.toml\n\n[package]\nname = \"my_crate\"\nversion = \"0.1.0\"\n\n[lib]\nproc-macro = true\n```\n\n----------------------------------------\n\nTITLE: Using #[macro_export], #[macro_use], and Procedural Macro Attributes in Rust\nDESCRIPTION: Shows how to export, import, or declare macros in Rust using #[macro_export], #[macro_use] for macro_rules!, and #[proc_macro], #[proc_macro_derive(...)] and #[proc_macro_attribute] for procedural macro crates. Use: above macro definitions or in macro-related modules/crates. Output: macro visibility in consuming code or enabling special invocation syntax. Requires correct placement in lib or proc-macro crates.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_162\n\nLANGUAGE: rust\nCODE:\n```\n#[macro_export]\nmacro_rules! exported { ... }\n\n#[macro_use]\nextern crate some_macros;\n\n#[proc_macro]\npub fn my_macro(input: TokenStream) -> TokenStream { ... }\n\n#[proc_macro_derive(MyTrait)]\npub fn derive_my_trait(input: TokenStream) -> TokenStream { ... }\n\n#[proc_macro_attribute]\npub fn my_attr(_attr: TokenStream, item: TokenStream) -> TokenStream { ... }\n```\n\n----------------------------------------\n\nTITLE: Extracting a Subslice with Offset and Length in Rust\nDESCRIPTION: Creates a subslice from `original_slice` starting at a given `offset` and having a specific `length`. This is achieved by first slicing from the `offset` to the end (`[offset..]`) and then taking the first `length` elements of that resulting slice (`[..length]`).\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_112\n\nLANGUAGE: Rust\nCODE:\n```\n&original_slice[offset..][..length]\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Iterator in Rust\nDESCRIPTION: Essential steps for implementing iterator support for a custom collection, showing how to create an iterator struct and implement the Iterator trait.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_119\n\nLANGUAGE: rust\nCODE:\n```\n// Define your collection\nstruct Collection<T> {}\n\n// Create iterator struct to hold iteration state\nstruct IntoIter<T> {}\n\n// Implement Iterator trait for your iterator\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    \n    fn next(&mut self) -> Option<Self::Item> {\n        // Return Some(item) or None when done\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Representing BinaryHeap<T> Memory Layout in Rust\nDESCRIPTION: Describes the memory layout of `BinaryHeap<T>`, a max-heap implemented using an underlying `Vec<T>` in Rust. It includes a pointer (`ptr`), capacity (`capacity`), and length (`len`) inherited from the vector. Elements are stored in the heap-allocated array such that the heap property is maintained (each element is larger than its children), allowing efficient retrieval of the maximum element.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_89\n\nLANGUAGE: Rust\nCODE:\n```\nBinaryHeap<T>\n```\n\n----------------------------------------\n\nTITLE: Defining Sized Types in Rust (Rust)\nDESCRIPTION: Defines a sized generic type T, representing any Rust type that has a known size at compile time. This type serves as a basic building block for more complex custom types and is subject to Rust's type system rules. Sized types are required when size and layout are well defined and known.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_71\n\nLANGUAGE: Rust\nCODE:\n```\nT\n```\n\n----------------------------------------\n\nTITLE: Arc<T> Structure Visualization\nDESCRIPTION: Illustrates the memory layout of `Arc<T>` in Rust, an atomically reference-counted pointer for shared ownership across multiple threads.  The contained type `T` must be `Send` and `Sync` for thread safety.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_95\n\nLANGUAGE: rust\nCODE:\n```\n<code>Arc&lt;T&gt;</code> {{ std(page=\"std/sync/struct.Arc.html\") }}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Scope and Drop Behavior in Rust\nDESCRIPTION: This Rust snippet demonstrates variable scope and the `Drop` trait. When 'c' is reassigned, the original value `S(2)` is dropped. At the closing brace `}`, the scope ends, and variables 'a' (containing the moved value from 't') and 'c' (containing `S(3)`) are dropped. 't' itself is not dropped because its value was moved to 'a'.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_51\n\nLANGUAGE: Rust\nCODE:\n```\n{\n    let mut c = S(2);\n    c = S(3);  // <- Drop called on `c` before assignment.\n    let t = S(1);\n    let a = t;\n}   // <- Scope of `a`, `t`, `c` ends here, drop called on `a`, `c`.\n```\n\n----------------------------------------\n\nTITLE: Constant and Compile-time Functions in Rust\nDESCRIPTION: Showing how to define functions that can be executed at compile time with 'const fn' and const blocks. These are used for computations that can be performed during compilation.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nconst fn f() {}\n```\n\nLANGUAGE: rust\nCODE:\n```\nconst { x }\n```\n\n----------------------------------------\n\nTITLE: Raw Const Pointers and Safety Considerations in Rust (Rust)\nDESCRIPTION: Represents unsafe raw pointers of type `*const T` which point to memory locations without any safety guarantees or lifetime tracking. Unlike references, raw pointers require explicit handling to avoid undefined behavior and offer unrestricted access to underlying memory.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_81\n\nLANGUAGE: Rust\nCODE:\n```\n*const T\n```\n\n----------------------------------------\n\nTITLE: Implementing a Struct with Trait Bound\nDESCRIPTION: This snippet showcases how to create a struct `Num` which uses a generic type `T`. It also uses a `where` clause to enforce a trait bound, i.e. `T` must implement the `Absolute` trait. The snippet limits the types `T` can be to members of the `Absolute` trait.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_166\n\nLANGUAGE: Rust\nCODE:\n```\n// Type can only be constructed for some `T` if that\n// T is part of `Absolute` membership list.\nstruct Num<T> where T: Absolute {\n    …\n}\n```\n\n----------------------------------------\n\nTITLE: Conversion from &CStr, &OsStr, &Path, &[u8] to &CStr / &OsStr / &Path\nDESCRIPTION: This snippet illustrates transforming various string-like types into reference types such as &CStr, &OsStr, and &Path, primarily via from_bytes_with_nul() or from() methods. Proper null-termination and encoding are emphasized for safety and correctness.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_130\n\nLANGUAGE: Rust\nCODE:\n```\nCStr::from_bytes_with_nul(&x)?\n```\n\nLANGUAGE: Rust\nCODE:\n```\nOsStr::from_encoded_bytes_unchecked(&x)\n```\n\nLANGUAGE: Rust\nCODE:\n```\nPath::new(x)\n```\n\n----------------------------------------\n\nTITLE: Rust Special Symbols and Their Meaning\nDESCRIPTION: This snippet details Rust's special symbols like '!', raw identifiers, wildcards, and statement terminators, explaining their purposes and typical use cases within the language. It covers syntax conventions and language-specific semantics.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_44\n\nLANGUAGE: Rust\nCODE:\n```\n! - Never type, represents functions that do not return.\nfn f() -> ! {}\nfn f() -> Result<(), !> {}\nfn f(x: !) {}\n_ - Wildcard pattern for matching or ignoring values.\nlet _ = x;\n_ = ignore_rval();\nx; - Statement terminator.\n\"r#foo\" - Raw identifier for compatibility.\n\"'r#a\" - Raw lifetime label (esoteric).</code>\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Output Parameters in Rust\nDESCRIPTION: This code defines a trait `Query` with an associated type `O`. The trait has a `search` method that takes a value of type `Self::O` as input. Implementations are provided for `PostgreSQL` and `Sled` types with different types for `O`. The trait author assumes the implementor would customize the API for `Self` type (but in only one way), and users do not need, or should not have, the ability to influence customization for specific `Self`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_174\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Query {\n    type O;\n    fn search(&self, needle: Self::O);\n}\n\nimpl Query for PostgreSQL { type O = String; …}\nimpl Query for Sled { type O = Vec<u8>; … }\n\npostgres.search(\"SELECT …\".to_string());\nsled.search(vec![0, 1, 2, 4]);\n```\n\n----------------------------------------\n\nTITLE: Recursive Function Calls and Stack Growth in Rust\nDESCRIPTION: This Rust example illustrates a recursive function call scenario. Each time function 'f' calls itself, a new stack frame is created on the call stack, and the value 'x' is moved into the parameter location of the new frame. Unbounded recursion consumes stack space and eventually leads to a stack overflow.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_53\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(x: S) {\n    if once() { f(x) } // <- We are here (before recursion)\n}\n\nlet a = S(1);\nf(a);\n```\n\n----------------------------------------\n\nTITLE: Conversion from &str, &CStr, &OsStr, &Path to byte slices\nDESCRIPTION: This section provides methods for converting string types to byte slices, including as_bytes() for &str and as_encoded_bytes() for OsStr. It highlights encoding considerations, ensuring that data can be safely serialized or transmitted at the byte level.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_128\n\nLANGUAGE: Rust\nCODE:\n```\nx.as_bytes()\n```\n\nLANGUAGE: Rust\nCODE:\n```\nx.to_bytes_with_nul()\n```\n\n----------------------------------------\n\nTITLE: Declaring a Stack Variable in Rust\nDESCRIPTION: This code snippet demonstrates how to declare a variable on the stack in Rust using the 'let' keyword. The variable 't' is assigned the value returned by the expression 'S(1)', where 'S' is a type or constructor. Requires knowledge of the structure or type 'S'. The expected input is a type constructor, and the output is a bound stack variable; the variable remains alive for the duration of its scope. Constraints: For asynchronous contexts, stack allocation might differ and involve heap placement via runtime.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_48\n\nLANGUAGE: Rust\nCODE:\n```\nlet t = S(1);\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait with Input and Output Parameters in Rust\nDESCRIPTION: This code defines a trait `Query` with a generic input parameter `I` and an associated type `O`. The trait has a `search` method that takes a value of type `I` as input and returns a value of type `Self::O`. Implementations are provided for `PostgreSQL` and `Sled` types with different types for `I` and `O`. Like examples above, in particular trait author assumes users may want ability to decide for which `I`-types ability should be possible, for given inputs, implementor should determine resulting output type.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_175\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Query<I> {\n    type O;\n    fn search(&self, needle: I) -> Self::O;\n}\n\nimpl Query<&str> for PostgreSQL { type O = String; … }\nimpl Query<CString> for PostgreSQL { type O = CString; … }\nimpl<T> Query<T> for Sled where T: ToU8Slice { type O = Vec<u8>; … }\n\npostgres.search(\"SELECT …\").to_uppercase();\nsled.search(&[1, 2, 3, 4]).pop();\n```\n\n----------------------------------------\n\nTITLE: Type-Safe Assignment in Rust\nDESCRIPTION: This code demonstrates Rust's strict type safety by attempting to assign the result of 'M::new()' to a variable of type 'S'. The assignment will fail at compile-time because the types are incompatible and Rust does not permit implicit conversion. Inputs: the constructor 'M::new()' and expected type 'S'. Output: A compile-error if the assignment types do not match. Prerequisites: Type definitions for 'M' and 'S'. Limitation: No implicit type conversion occurs between distinct types without explicit casting.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_50\n\nLANGUAGE: Rust\nCODE:\n```\nlet c: S = M::new();\n```\n\n----------------------------------------\n\nTITLE: Specifying Type Layout with #[repr] Attributes in Rust\nDESCRIPTION: Uses Rust's #[repr(...)] attribute with variants (C, u8, transparent, packed(1), align(8)) to control layout and alignment of structs and enums for FFI, correctness, and platform compatibility. These attributes are attached directly above type/enum definitions. Expected input: a type (struct, enum, union) definition. Output: modified memory layout of that type. Dependencies: standard Rust compiler; some settings are mildly unsafe or have UB risks when misused (e.g., packed).\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_156\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C, u8)]\nenum MyEnum { ... }\n\n#[repr(transparent)]\nstruct TransparentWrap(T);\n\n#[repr(packed(1))]\nstruct PackedStruct { ... }\n\n#[repr(align(8))]\nstruct SIMDAligned { ... }\n```\n\n----------------------------------------\n\nTITLE: Unsafe Raw Pointer Declaration in Rust\nDESCRIPTION: This snippet explains the declaration of a raw constant pointer in Rust. It emphasizes the unsafe nature of dereferencing such pointers and warns about potential undefined behavior when handling invalid pointers. Dependencies include understanding Rust's unsafe block and pointer semantics.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_55\n\nLANGUAGE: Rust\nCODE:\n```\nlet p: *const S = questionable_origin();\n```\n\n----------------------------------------\n\nTITLE: Unsound Code Example\nDESCRIPTION: This code shows an example of unsound code that uses `mem::transmute` to convert a reference of type `T` to a reference of type `u128`.  While the signature looks safe to users, if invoked with a type other than `u128`, it leads to undefined behavior. This creates a stability and security risk because seemingly safe operations can trigger UB.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_207\n\nLANGUAGE: rust\nCODE:\n```\nfn unsound_ref<T>(x: &T) -> &u128 {      // Signature looks safe to users. Happens to be\n    unsafe { mem::transmute(x) }         // ok if invoked with an &u128, UB for practically\n}                                        // everything else.\n```\n\n----------------------------------------\n\nTITLE: Handling Illegal State and Scoped Thread Safety in Rust - Rust\nDESCRIPTION: Shows advanced idiomatic patterns including using locks with careful unwraps to propagate poison errors and guaranteeing thread life cycles using scoped threads to ensure safety at compile time.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_192\n\nLANGUAGE: Rust\nCODE:\n```\nmy_lock.write().unwrap().guaranteed_at_compile_time_to_be_locked = 10;\nthread::scope(|s| { /* Threads can't exist longer than scope() */ });\n```\n\n----------------------------------------\n\nTITLE: Passing Values to Functions on the Stack in Rust\nDESCRIPTION: This Rust code shows how a value is moved onto the call stack when passed as an argument to a function. The value held by variable 'a' is moved to the stack location designated for the parameter 'x' when function 'f' is called. Inside 'f', 'x' acts like a local variable holding the moved value.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_52\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(x: S) { … }\n\nlet a = S(1); // <- We are here\nf(a);\n```\n\n----------------------------------------\n\nTITLE: Defining a Unit-Like Struct in Rust\nDESCRIPTION: This code snippet defines a unit-like struct. Unit-like structs don't have any fields and are primarily useful as markers.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_140\n\nLANGUAGE: Rust\nCODE:\n```\nstruct X;\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Data Structures and Globals - Rust\nDESCRIPTION: Illustrates how to define various Rust data types including structs (with named fields, tuple structs, and zero-sized unit structs), enums (unit, tuple, struct-like variants, with or without explicit discriminants), unions for FFI, static variables (global with 'static lifetime), constants, and variable bindings (immutable and mutable). Dependencies include Rust’s ownership and type systems. Key parameters are struct fields and enum variants; outputs are type declarations enabling structured data storage with Rust’s memory and safety guarantees. Limitations note that static variables can cause multiple instances due to crate imports and that unit structs occupy no space.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nstruct S {}\nstruct S { x: T }\nstruct S(T);\nstruct S;\nenum E {}\nenum E { A, B(), C {} }\nenum E { A = 1 }\nunion U {}\nstatic X: T = T();\nconst X: T = T();\nlet x: T;\nlet mut x: T;\nx = y;\n```\n\n----------------------------------------\n\nTITLE: Zero-Sized Types (ZST) Declaration in Rust (Rust)\nDESCRIPTION: Defines a zero-sized type via an empty struct, `struct S;`. Such types occupy no memory and are used for marker types or compile-time information, leveraging Rust's zero-cost abstractions.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_75\n\nLANGUAGE: Rust\nCODE:\n```\nstruct S;\n```\n\n----------------------------------------\n\nTITLE: Triggering Arithmetic Errors and Overflows in Rust - Rust\nDESCRIPTION: Showcases several arithmetic operations in Rust (division by zero, addition overflow, integer multiplication overflow, and floating-point quirks), including release vs debug mode differences. No additional dependencies are required. Each fragment demonstrates the consequences of operations such as division by zero (`200_u8 / 0_u8`), integer overflows (`200_u8 + 200_u8`), and floating-point special values (`0.0_f32 / 0.0_f32`). Inputs are literals and operations; outputs vary between compile errors, runtime panics, or wrapped values. Behavior differs between debug and release modes and is subject to Rust’s safety rules on numeric operations.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_68\n\nLANGUAGE: Rust\nCODE:\n```\n200_u8 / 0_u8\n```\n\nLANGUAGE: Rust\nCODE:\n```\n200_u8 / _0\n```\n\nLANGUAGE: Rust\nCODE:\n```\n200_u8 + 200_u8\n```\n\nLANGUAGE: Rust\nCODE:\n```\n200_u8 + _200\n```\n\nLANGUAGE: Rust\nCODE:\n```\n-128_i8 * -1\n```\n\nLANGUAGE: Rust\nCODE:\n```\n-128_i8 * _1neg\n```\n\nLANGUAGE: Rust\nCODE:\n```\n1_u8 / 2_u8\n```\n\nLANGUAGE: Rust\nCODE:\n```\n0.8_f32 + 0.1_f32\n```\n\nLANGUAGE: Rust\nCODE:\n```\n1.0_f32 / 0.0_f32\n```\n\nLANGUAGE: Rust\nCODE:\n```\n0.0_f32 / 0.0_f32\n```\n\nLANGUAGE: Rust\nCODE:\n```\nx < f32::NAN\n```\n\nLANGUAGE: Rust\nCODE:\n```\nx > f32::NAN\n```\n\nLANGUAGE: Rust\nCODE:\n```\nf32::NAN == f32::NAN\n```\n\n----------------------------------------\n\nTITLE: Splitting Strings by Whitespace in Rust\nDESCRIPTION: Splits a string `s` into an iterator of subslices, using any amount of consecutive whitespace as a separator.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_101\n\nLANGUAGE: Rust\nCODE:\n```\ns.split_whitespace()\n```\n\n----------------------------------------\n\nTITLE: Basic Cargo Build Command\nDESCRIPTION: This snippet demonstrates the basic cargo build command, which builds the Rust project in debug mode. Adding `--release` optimizes the build for production.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_142\n\nLANGUAGE: Shell\nCODE:\n```\ncargo <span class=\"cargo-prefix\">b</span>uild\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Specific Binary\nDESCRIPTION: Runs a specific binary within a multi-binary project. Can unify features with other dependents, which may be confusing.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_147\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run --bin b\n```\n\n----------------------------------------\n\nTITLE: Setting Cross-Compilation Environment Variables\nDESCRIPTION: Shows an example of setting environment variables for cross-compilation, specifically for the Android toolchain. These variables might be needed depending on the compiler's complaints.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_151\n\nLANGUAGE: Shell\nCODE:\n```\nset CC=C:\\[PATH_TO_TOOLCHAIN]\\prebuilt\\windows-x86_64\\bin\\aarch64-linux-android21-clang.cmd\nset CXX=C:\\[PATH_TO_TOOLCHAIN]\\prebuilt\\windows-x86_64\\bin\\aarch64-linux-android21-clang.cmd\nset AR=C:\\[PATH_TO_TOOLCHAIN]\\prebuilt\\windows-x86_64\\bin\\aarch64-linux-android-ar.exe\n…\n```\n\n----------------------------------------\n\nTITLE: Creating String and Character Literals in Rust\nDESCRIPTION: This snippet catalogs various ways to represent textual data in Rust, including string literals (with escapes), raw string literals, C-style raw and normal string literals for FFI, byte string literals, and character literals. It details the syntax for Unicode escapes, ASCII escapes, raw strings with hash delimiters, and byte literals. Inputs are string or character data in source code, output is UTF-8 or ASCII encoded literals with appropriate lifetime. It also notes common escape sequences and the distinction between string and byte literals, useful for different contexts such as FFI or binary data handling.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_42\n\nLANGUAGE: Rust\nCODE:\n```\n\"...\"\n// String literal with UTF-8 encoding and escape sequences\n\n\"\\n\\r\\t\\0\\\\\"\n// Common escape sequences for newline, carriage return, tab, null byte, backslash\n\n\"\\x36\"\n// ASCII escape sequence for byte value 0x36 ('6')\n\n\"\\u{7fff}\"\n// Unicode escape sequence for code point 0x7fff\n\nr\"...\"\n// Raw string literal, no escape processing\n\nr#\"...\"#\n// Raw string literal with # delimiters to allow inner quotes\n\nc\"...\"\n// C string literal for use with FFI, NUL-terminated\n\nb\"...\"\n// Byte string literal, ASCII only\n\nbr\"...\"\n// Raw byte string literal\n\nb'x'\n// Byte literal representing single u8 value\n\n'🦀'\n// Character literal, a Unicode scalar value\n\n```\n\n----------------------------------------\n\nTITLE: Creating Shared Borrow - Rust\nDESCRIPTION: Creates a shared borrow (reference) of a value `s`. This is an expression that evaluates to a reference value (e.g., `0x1234`) that can be stored in a shared reference type (`&S`). Multiple shared borrows are allowed simultaneously.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n&s\n```\n\n----------------------------------------\n\nTITLE: Appending to a Writable Target using write! Macro in Rust\nDESCRIPTION: Appends the `Display` representation of `y` to a `Write`-able target `x` (like a `String` or `File`) using the `write!` macro. This avoids allocating a new string if `x` already exists. Requires Rust edition '21 or later.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_99\n\nLANGUAGE: Rust\nCODE:\n```\nwrite!(x, \"{y}\")\n```\n\n----------------------------------------\n\nTITLE: Handling Type Inference in `try_for_each` Closures in Rust\nDESCRIPTION: Shows how to explicitly specify the `Ok` type (`Ok::<(), Error>(())`) within a closure passed to methods like `Iterator::try_for_each`. This helps the Rust compiler resolve type inference when the closure might otherwise seem ambiguous, especially when only returning `Ok(())`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_110\n\nLANGUAGE: Rust\nCODE:\n```\niter.try_for_each(|x| { Ok::<(), Error>(()) })?;\n```\n\n----------------------------------------\n\nTITLE: Builder Pattern Usage and Const Functions - Rust\nDESCRIPTION: Demonstrates defining builder-style APIs for ergonomic object creation and marking functions and code blocks as `const` where feasible, allowing compile-time evaluation.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_193\n\nLANGUAGE: Rust\nCODE:\n```\nCar::new(\"Model T\").hp(20).build();\n// Mark functions as `const` when possible and use `const { }` blocks for compile-time computation\n```\n\n----------------------------------------\n\nTITLE: Creating Mutable Raw Pointer Expression - Rust\nDESCRIPTION: Creates a mutable raw pointer (`*mut S`) directly from a value `s`. This is the mutable equivalent of `&raw const s` and is sometimes necessary for scenarios involving unaligned or packed struct fields. It's considered experimental and esoteric.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\n&raw mut s\n```\n\n----------------------------------------\n\nTITLE: Emphasizing Strong Types via Enums and Structs - Rust\nDESCRIPTION: Encourages defining explicit enums and newtypes instead of using primitives for clearer code semantics, type safety, and better API expressiveness. This snippet contrasts Rust's strong typing with error codes or booleans.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_191\n\nLANGUAGE: Rust\nCODE:\n```\nenum E { Invalid, Valid { /* fields */ } }\nenum E { Visible, Hidden }\nstruct Charge(f32);\n```\n\n----------------------------------------\n\nTITLE: Cargo Run Specific Package\nDESCRIPTION: Runs the main function of a sub-workspace within a larger project. Handles features more predictably than running a specific binary.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_148\n\nLANGUAGE: Shell\nCODE:\n```\ncargo run --<span class=\"cargo-prefix\">p</span>ackage w\n```\n\n----------------------------------------\n\nTITLE: Splitting Strings by Newlines in Rust\nDESCRIPTION: Splits a string `s` into an iterator of subslices based on newline characters (`\\n` or `\\r\\n`). Empty lines are included.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_102\n\nLANGUAGE: Rust\nCODE:\n```\ns.lines()\n```\n\n----------------------------------------\n\nTITLE: Slice Types Representing Dynamically Sized Arrays (Rust)\nDESCRIPTION: Describes the slice type `[T]`, a dynamically sized view over an unknown number of contiguous elements of type T. Slices do not carry size information themselves and are usually handled through references like `&[T]`. They are unsized and typically used for safe access to sequences of elements without ownership.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_74\n\nLANGUAGE: Rust\nCODE:\n```\n[T]\n```\n\n----------------------------------------\n\nTITLE: Controlling Linking and Symbol Naming with Rust Attributes\nDESCRIPTION: Demonstrates use of attributes affecting symbol names and binary linking: #[no_mangle], #[export_name], #[link_section], #[link], #[link_name], #[no_link], and #[used]. These attributes modify linking behavior or symbol export in compiled binaries, and are attached to functions, statics, or extern blocks. Expected input: Rust item to be exported or linked. Output: altered linkage or symbol table. Requires knowledge of FFI and linking conventions; some are 'unsafe' or platform-specific.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_157\n\nLANGUAGE: rust\nCODE:\n```\n#[no_mangle]\npub extern \"C\" fn exported() { ... }\n\n#[export_name = \"foo\"]\nstatic MY_SYMBOL: u32 = 0;\n\n#[link_section = \".special\"]\nstatic SPECIAL_VAR: u8 = 1;\n\n#[link(name=\"c\", kind=\"static\")]\nextern \"C\" {}\n\n#[link_name = \"bar\"]\nextern \"C\" { fn bar_fn(); }\n\n#[used]\nstatic IMPORTANT: u8 = 42;\n```\n\n----------------------------------------\n\nTITLE: Rust Abstract Machine Model Overview\nDESCRIPTION: This section provides an overview of Rust's internal abstract machine, illustrating how Rust writes code for an abstracted CPU, which differs from actual hardware. It explains the significance of the model for safety, optimization, and correctness.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_46\n\n\n\n----------------------------------------\n\nTITLE: Inspecting Unicode and UTF-8 Representations in Rust - Rust\nDESCRIPTION: Examines byte and character representations of strings containing Unicode symbols in Rust by using `as_bytes()` and `chars()` on string literals. No special dependencies are needed. The samples `let s = \"I ❤ Rust\"; let t = \"I ❤️ Rust\";` show differences in memory layout and encoding between similar-looking Unicode sequences, and how variation selectors result in different byte arrays and character vectors. Inputs are Unicode-containing strings; outputs are arrays of bytes or Unicode scalar values. Notably, visual character equivalence may not match underlying memory or character count.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_70\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = \"I ❤ Rust\"; \n```\n\nLANGUAGE: Rust\nCODE:\n```\nlet t = \"I ❤️ Rust\";\n```\n\nLANGUAGE: Rust\nCODE:\n```\ns.as_bytes()\n```\n\nLANGUAGE: Rust\nCODE:\n```\nt.as_bytes()\n```\n\nLANGUAGE: Rust\nCODE:\n```\ns.chars()\n```\n\nLANGUAGE: Rust\nCODE:\n```\nt.chars()\n```\n\n----------------------------------------\n\nTITLE: Stack Memory Reuse After Function Return in Rust\nDESCRIPTION: Demonstrates how stack memory might be reused after a function call (or a recursive call) completes and its stack frame is popped. Once the execution within 'f(x)' finishes (after the potential recursive call), the stack space previously used for parameters like 'x' becomes available and can be repurposed for new local variables, such as 'm'.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_54\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(x: S) {\n    if once() { f(x) }\n    let m = M::new() // <- We are here (after recursion)\n}\n\nlet a = S(1);\nf(a);\n```\n\n----------------------------------------\n\nTITLE: Building an offline copy of cheats.rs with Zola\nDESCRIPTION: This snippet demonstrates how to build an offline copy of the cheats.rs website using the Zola static site generator. It defines the base URL and output directory, which are essential parameters for generating the offline version.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/faq.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nzola build --base-url=\"$PWD/public/index.html\" --output-dir=\"$PWD/public\"\n```\n\n----------------------------------------\n\nTITLE: Assigning Via Dereference (Copy) - Rust\nDESCRIPTION: Uses the dereference operator `*` on the right-hand side of an assignment. If the value pointed to by `r` implements the `Copy` trait, this creates a copy of that value and assigns it to `s`. The original value remains accessible via `r`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_19\n\nLANGUAGE: Rust\nCODE:\n```\ns = *r;\n```\n\n----------------------------------------\n\nTITLE: Translation credit for cheats.rs\nDESCRIPTION: This HTML snippet shows how to properly attribute the original author (Ralf Biedert) when translating and hosting a modified version of the cheats.rs website. It's essential for respecting the original author's work while providing a translated version to a different audience.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/faq.md#_snippet_1\n\nLANGUAGE: html\nCODE:\n```\nTranslated and hosted by [YOU], based on cheats.rs (Ralf Biedert)\n```\n\n----------------------------------------\n\nTITLE: Pre-Build Script - Rust\nDESCRIPTION: Demonstrates a simple pre-build script to access environment variables.  Shows how to access `CARGO_CFG_TARGET_OS` to determine the target operating system.  Requires using `std::env` to access environment variables.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_136\n\nLANGUAGE: Rust\nCODE:\n```\n// build.rs (sample pre-build script)\n\nfn main() {\n    // You need to rely on env. vars for target; `#[cfg(…)]` are for host.\n    let target_os = env::var(\"CARGO_CFG_TARGET_OS\");\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Algorithm - Rust\nDESCRIPTION: Illustrates a benchmark using the experimental `test` feature.  Shows how to prevent optimizations using `black_box` and iterate over the code to be benchmarked. Requires enabling the `test` feature flag and using `extern crate test`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_135\n\nLANGUAGE: Rust\nCODE:\n```\n// benches/sample.rs (sample benchmark)\n\n#![feature(test)]   // #[bench] is still experimental\n\nextern crate test;  // Even in '18 this is needed for … reasons.\n                    // Normally you don't need this in '18 code.\n\nuse test::{black_box, Bencher};\n\n#[bench]\nfn my_algo(b: &mut Bencher) {\n    b.iter(|| black_box(my_crate::f())); // `black_box` prevents `f` from being optimized away.\n}\n```\n\n----------------------------------------\n\nTITLE: Representing VecDeque<T> Memory Layout in Rust\nDESCRIPTION: Describes the memory layout of `VecDeque<T>`, a double-ended queue implemented as a growable ring buffer in Rust. It uses a head index (`head`), length (`len`), pointer (`ptr`), and capacity (`capacity`). Data is stored in a contiguous heap allocation but treated as a ring buffer, meaning content might wrap around and appear non-contiguous logically.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_87\n\nLANGUAGE: Rust\nCODE:\n```\nVecDeque<T>\n```\n\n----------------------------------------\n\nTITLE: Implementing Iterator Interoperability in Rust\nDESCRIPTION: How to enable a custom collection to work with collect() and extend(), and adding additional iterator trait implementations for better functionality.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_122\n\nLANGUAGE: rust\nCODE:\n```\n// Support for: some_iter.collect::<Collection<_>>()\nimpl<T> FromIterator<T> for Collection<T> {\n    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n        // Build collection from iterator\n    }\n}\n\n// Support for: c.extend(other)\nimpl<T> Extend<T> for Collection<T> {\n    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n        // Add items from iterator to collection\n    }\n}\n\n// Additional traits for iterators\nimpl<T> DoubleEndedIterator for IntoIter<T> {\n    fn next_back(&mut self) -> Option<Self::Item> {\n        // Implementation\n    }\n}\n\nimpl<T> ExactSizeIterator for IntoIter<T> {}\n\nimpl<T> FusedIterator for IntoIter<T> {}\n```\n\n----------------------------------------\n\nTITLE: Async Caveats Table\nDESCRIPTION: This table outlines potential pitfalls when writing async code in Rust, such as blocking the executor, using thread-local storage incorrectly, and dealing with non-`Send` types.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_200\n\n\n\n----------------------------------------\n\nTITLE: Static Lifetime - Rust\nDESCRIPTION: The special lifetime `'static` denotes data that is valid for the entire duration of the program's execution. This applies to string literals, static variables, and leaks.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_28\n\nLANGUAGE: Rust\nCODE:\n```\n'static\n```\n\n----------------------------------------\n\nTITLE: Using Char and Str Types in Rust - Rust\nDESCRIPTION: Provides practical usage of the `char` and `str` types, demonstrating declaration, initialization, and properties relating to Unicode and UTF-8 encoding in Rust. No external dependencies are needed. Key code snippets include assignment of Unicode and emoji characters to `char`, as well as byte and character string initializations with `&str`. Inputs are literal values (characters or strings); outputs are variables holding those values. Note that certain Unicode symbols or grapheme clusters cannot be represented as a single `char` due to Unicode code point composition.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_69\n\nLANGUAGE: Rust\nCODE:\n```\nlet c = 'a';\n```\n\nLANGUAGE: Rust\nCODE:\n```\nlet c = '❤';\n```\n\nLANGUAGE: Rust\nCODE:\n```\nlet c = '❤️';\n```\n\nLANGUAGE: Rust\nCODE:\n```\nc = 0xffff_ffff;\n```\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = \"a\";\n```\n\nLANGUAGE: Rust\nCODE:\n```\nlet s = \"❤❤️\";\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Casting with `as` Keyword in Rust\nDESCRIPTION: Demonstrates using the `as` keyword for explicit type casting in Rust. This method allows conversions between certain primitive types, pointers, and integers, but it bypasses some compiler checks and should be used cautiously as it can lead to truncation, UB, or unexpected behavior.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_184\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(x: A) -> B {\n    x as B\n}\n```\n\n----------------------------------------\n\nTITLE: OsString Structure Visualization\nDESCRIPTION: Illustrates the memory layout of an `OsString` in Rust, representing a platform-specific string. The actual memory representation is platform-defined (e.g., WTF-8 on Windows).\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_92\n\nLANGUAGE: rust\nCODE:\n```\n<code>OsString</code> {{ std(page=\"std/ffi/struct.OsString.html\") }}\n```\n\n----------------------------------------\n\nTITLE: Let Ref Equivalent - Rust\nDESCRIPTION: Demonstrates the use of `let ref` binding. `let ref r = s;` is semantically equivalent to `let r = &s;`, creating a new binding `r` that is a shared reference to `s`. This form is deprecated.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\nlet ref r = s;\n```\n\n----------------------------------------\n\nTITLE: Controlling Documentation Generation and Appearance with #[doc] Attributes in Rust\nDESCRIPTION: Uses #[doc = ...], #[doc(alias = ...)], #[doc(hidden)], and crate-level doc attributes to specify documentation strings, aliases for search, hiding items from docs, setting favicon/logo/base/playground URLs, and suppressing source inclusion. Input: applied to structs, functions, modules, or crates. Output: modified rustdoc output. Requires rustdoc tool; some features useful for published crates or internal APIs.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_161\n\nLANGUAGE: rust\nCODE:\n```\n#[doc = \"This explains...\"]\nfn explained() {}\n\n#[doc(alias = \"alternative_name\")]\nmod my_mod {}\n\n#[doc(hidden)]\npub mod secret {}\n\n#![doc(html_favicon_url = \"favicon.ico\")]\n#![doc(html_logo_url = \"logo.png\")]\n#![doc(html_playground_url = \"https://play.rust-lang.org\")]\n#![doc(html_root_url = \"https://docs.rs/mycrate/1.0.0\")]\n#![doc(html_no_source)]\n```\n\n----------------------------------------\n\nTITLE: Using the Semver Trick for Type Unification Across Crate Versions in Rust\nDESCRIPTION: Describes the 'semver trick' pattern. A crate depends on its own *next* planned version (e.g., `my_crate = \"1.1.0\"` while developing `1.0.0`) in `Cargo.toml` and re-exports types from it. This allows different versions of the crate in a dependency tree to potentially use the unified types from the 'next' version, aiding compatibility.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_114\n\nLANGUAGE: Rust\nCODE:\n```\nmy_crate = \"next.version\"\n```\n\n----------------------------------------\n\nTITLE: Unsafe Union Types for Memory Reinterpretation in Rust (Rust)\nDESCRIPTION: Defines an unsafe union which can store one of multiple different types such as A, B, or C in the same memory location without enforcing safety guarantees about which variant is active. Accessing the wrong variant can lead to undefined behavior, so care is required when using unions.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_79\n\nLANGUAGE: Rust\nCODE:\n```\nunion { … }\n```\n\n----------------------------------------\n\nTITLE: Dereferencing Box - Rust\nDESCRIPTION: Shows a special case for `Box<T>`. Dereferencing a `Box<T>` (e.g., `*my_box`) on the right-hand side of an assignment is allowed even if `T` does not implement `Copy`. This moves the owned content out of the `Box`, consuming the `Box` in the process.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_21\n\nLANGUAGE: Rust\nCODE:\n```\ns = *my_box;\n```\n\n----------------------------------------\n\nTITLE: Unit Testing Inside Module - Rust\nDESCRIPTION: Demonstrates a unit test inside a module using `#[cfg(test)]`. Shows how to import items from the parent module and use `assert_eq!` for testing. No dependencies beyond the standard library are needed.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_133\n\nLANGUAGE: Rust\nCODE:\n```\n// src/my_module.rs (any file of your project)\n\nfn f() -> u32 { 0 }\n\n#[cfg(test)]\nmod test {\n    use super::f;           // Need to import items from parent module. Has\n                            // access to non-public members.\n    #[test]\n    fn ff() {\n        assert_eq!(f(), 0);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Check Command\nDESCRIPTION: This command checks the project for compile errors without generating the output binary. This is faster than a full build.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_143\n\nLANGUAGE: Shell\nCODE:\n```\ncargo <span class=\"cargo-prefix\">c</span>heck\n```\n\n----------------------------------------\n\nTITLE: Generic Type Conversion Function Signature in Rust\nDESCRIPTION: Illustrates the fundamental scenario of converting an input `x` of type `A` into an output of type `B` within a Rust function. This serves as the base case for discussing various conversion methods like computation, casting, coercion, and subtyping.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_182\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(x: A) -> B {\n    // How can you obtain B from A?\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Release Builds for Profiling (TOML)\nDESCRIPTION: This TOML snippet configures the release profile within a project's `Cargo.toml` file to include debug information (`debug = true`). Adding debug symbols to release builds is crucial for effective profiling with tools like Superluminal (Windows) or Instruments (macOS), as it allows these tools to map performance data back to the source code without sacrificing release-level optimizations.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_197\n\nLANGUAGE: toml\nCODE:\n```\n[profile.release]\ndebug = true\n```\n\n----------------------------------------\n\nTITLE: Controlling Formatting in Rust Code with Rustfmt Attributes\nDESCRIPTION: Illustrates use of #[rustfmt::skip], #![rustfmt::skip::macros(x)], and #![rustfmt::skip::attributes(x)] to prevent automatic reformatting of code or parts thereof when running cargo fmt. These attributes are file/module- or item-level and are used to preserve formatting for macros or custom syntaxes that rustfmt might incorrectly adjust. Requires rustfmt installed and invoked via cargo fmt.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_160\n\nLANGUAGE: rust\nCODE:\n```\n#[rustfmt::skip]\nfn ugly_but_necessary() { ... }\n\n#![rustfmt::skip::macros(my_macro)]\n#![rustfmt::skip::attributes(my_attr)]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Borrowing Issues Rust\nDESCRIPTION: This Rust code snippet demonstrates a potential issue with borrowing in Rust. It initializes variables, calls a function `f` with references to those variables, and then attempts to re-use the original variables. The key idea is that `f` potentially returns a reference to either `b` or `c`. Following this, assignment of `b` or `c` to `a` may or may not be valid. Depending on which variable was *really* borrowed, one of these operations can be considered invalid. The goal is to illustrate the problem that the compiler is *not* able to know which address will be returned when using references.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_62\n\nLANGUAGE: Rust\nCODE:\n```\n```\nlet b = S(1);\nlet c = S(2);\n\nlet r = f(&b, &c);\n\nlet a = b;   // Are we allowed to do this?\nlet a = c;   // Which one is _really_ borrowed?\n\nprint_byte(r);\n```\n```\n\n----------------------------------------\n\nTITLE: Implicit Conversion via Variance Rules (Lifetimes) in Rust\nDESCRIPTION: Shows automatic type conversion governed by Rust's variance rules for lifetimes within generic types (covariance, contravariance, invariance). Similar to subtyping, `A` converts implicitly to `B` if variance rules permit (e.g., covariance allows `Box<&'static T>` to become `Box<&'a T>`). The function returns `x` relying on these implicit rules.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_187\n\nLANGUAGE: Rust\nCODE:\n```\nfn f(x: A) -> B {\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Cross-Compilation Configuration TOML\nDESCRIPTION: Shows an example configuration for cross-compilation in the `~/.cargo/config.toml` file, specifying the linker for a target architecture.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_150\n\nLANGUAGE: TOML\nCODE:\n```\n[target.aarch64-linux-android]\nlinker = \"[PATH_TO_TOOLCHAIN]/aarch64-linux-android/bin/aarch64-linux-android-clang\"\n```\n\nLANGUAGE: TOML\nCODE:\n```\n[target.aarch64-linux-android]\nlinker = \"C:/[PATH_TO_TOOLCHAIN]/prebuilt/windows-x86_64/bin/aarch64-linux-android21-clang.cmd\"\n```\n\n----------------------------------------\n\nTITLE: Trait Definitions and the Sized Bound in Rust\nDESCRIPTION: Shows how traits interact with the `Sized` trait. Traits generally do not require implementers to be `Sized`, allowing implementation for DSTs. Traits can explicitly require `Sized` via a supertrait bound. Using `self` parameters may still restrict DST implementations due to stack placement requirements.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_177\n\nLANGUAGE: Rust\nCODE:\n```\ntrait F { fn f(&self); }\ntrait F: Sized {}\ntrait G { fn g(self); }\n```\n\n----------------------------------------\n\nTITLE: Defining Maybe Sized Types Using `?Sized` Bound (Rust)\nDESCRIPTION: Represents a generic type T that may or may not have a known size at compile time using the `?Sized` marker. This enables handling types like dynamically sized types (DSTs) such as slices or trait objects that require indirect referencing.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_72\n\nLANGUAGE: Rust\nCODE:\n```\nT: ?Sized\n```\n\n----------------------------------------\n\nTITLE: Closure Requirement Table\nDESCRIPTION: This table outlines the advantages and disadvantages of requiring `FnOnce`, `FnMut`, or `Fn` closures in function signatures.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_203\n\n\n\n----------------------------------------\n\nTITLE: Representing HashMap<K, V> Memory Layout in Rust (Simplified)\nDESCRIPTION: Describes the memory layout of `HashMap<K, V>`, Rust's standard hash map implemented using hashbrown (SwissTable). It includes metadata like bucket mask (`bmask`), control pointer (`ctrl`), items left marker (`left`), and length (`len`). The heap layout stores key-value pairs based on hash values. `HashSet<T>` has an identical layout but without storing values `V`. The heap visualization is explicitly noted as oversimplified.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_88\n\nLANGUAGE: Rust\nCODE:\n```\nHashMap<K, V>\n```\n\n----------------------------------------\n\nTITLE: Mutex<T> / RwLock<T> Structure Visualization\nDESCRIPTION: Illustrates the structure of `Mutex<T>` and `RwLock<T>` in Rust, providing mutually exclusive and read-write lock capabilities, respectively.  To be shared between decoupled threads, it needs to be held in `Arc`.  Inner fields depend on the platform.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_96\n\nLANGUAGE: rust\nCODE:\n```\n<code>Mutex&lt;T&gt;</code> {{ std(page=\"std/sync/struct.Mutex.html\") }} / <code>RwLock&lt;T&gt;</code> {{ std(page=\"std/sync/struct.RwLock.html\") }}\n```\n\n----------------------------------------\n\nTITLE: Rc<T> Structure Visualization\nDESCRIPTION: Illustrates the memory layout of `Rc<T>` in Rust, a reference-counted pointer for shared ownership within a single thread. It includes a pointer to the heap, metadata, strong and weak counts, and the contained value `T`. Mutation requires nested `Cell` or `RefCell`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_94\n\nLANGUAGE: rust\nCODE:\n```\n<code>Rc&lt;T&gt;</code> {{ std(page=\"std/rc/struct.Rc.html\") }}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Borrowed State in Rust\nDESCRIPTION: This snippet illustrates how borrowing a variable prevents modification through its original binding. It showcases the concept of a variable entering a borrowed state after its address is taken, and the subsequent attempt to modify the variable results in a potential compile-time error.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_60\n\nLANGUAGE: rust\nCODE:\n```\nlet mut b = S(0);\nlet r = &mut b;\n\nb = S(4);   // Will fail since `b` in borrowed state.\n\nprint_byte(r);\n```\n\n----------------------------------------\n\nTITLE: Immutable References and their Metadata in Rust (Rust)\nDESCRIPTION: Describes an immutable reference `&'a T`, which points safely to an instance of type T that must exist for at least lifetime `'a`. These references include pointer metadata such as size or vtable information, especially important for dynamically sized or trait object types.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_80\n\nLANGUAGE: Rust\nCODE:\n```\n&'a T\n```\n\n----------------------------------------\n\nTITLE: Cargo Build Timings\nDESCRIPTION: Shows the time taken by different crates during the build process. Useful for identifying bottlenecks.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_149\n\nLANGUAGE: Shell\nCODE:\n```\ncargo … --timings\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Structs with Implicit Sized Bound (Rust)\nDESCRIPTION: Shows a basic generic struct definition. By default, Rust adds an invisible bound `T: Sized` to type parameters, meaning the generic type `S<T>` can only be instantiated with types `T` whose size is known at compile time.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_178\n\nLANGUAGE: Rust\nCODE:\n```\nstruct S<T> { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Analyzing Rust Lifetime Variance and Borrowing Rules in Nested Scopes\nDESCRIPTION: This snippet models nested scope lifetimes with variables `a`, `b`, `c`, and reference `r: &'c S`. It demonstrates how the lifetime `'c` of the reference `r` is constrained by the lifetimes of data `a`, `b`, and `c`, emphasizing Rust's strict borrow rules and lifetime annotations. It showcases how the lifetime of `r` must not outlive the data it references, with explicit mention of invalid assignments due to lifetime constraints.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_58\n\nLANGUAGE: Rust\nCODE:\n```\nlet b = S(3);\n{\n    let c = S(2);\n    let r: &'c S = &c;\n    {\n        let a = S(0);\n        r = &a; // Invalid, as `a` does not live long enough\n        r = &b; // Valid, as `b` lives longer than `'c`\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Rust Cheat Sheet with Zola\nDESCRIPTION: Instructions for building and locally developing the cheats.rs website using Zola, a static site generator written in Rust. The command starts Zola's development server which watches for changes and auto-refreshes the browser.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nzola serve\n```\n\n----------------------------------------\n\nTITLE: Defining a Tuple Struct in Rust\nDESCRIPTION: This code defines a tuple struct. Tuple structs are similar to structs but their fields don't have names, only types.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_141\n\nLANGUAGE: Rust\nCODE:\n```\nstruct X();\n```\n\n----------------------------------------\n\nTITLE: Fixed-Size Arrays of Elements in Rust (Rust)\nDESCRIPTION: Defines a fixed-size array with `n` elements of type T, where the size `n` is a compile-time constant. The layout is contiguous for all array elements, and the total array size is the size of T multiplied by n.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_73\n\nLANGUAGE: Rust\nCODE:\n```\n[T; n]\n```\n\n----------------------------------------\n\nTITLE: Declaring Shared String Slice Reference Type - Rust\nDESCRIPTION: Declares a type that represents a shared reference to a string slice (`str`). Similar to a slice reference, it contains the starting address (`addr`) and the length in bytes (`byte_len`).\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n&str\n```\n\n----------------------------------------\n\nTITLE: Ref Binding - Rust\nDESCRIPTION: Uses the `ref` keyword in pattern matching to bind a variable `s` by reference instead of by value or mutation. This makes the resulting binding a reference type. This syntax is largely deprecated in favor of explicit `&` or `&mut`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\nref s\n```\n\n----------------------------------------\n\nTITLE: Tuple Type Representations and Layout Unspecified (Rust)\nDESCRIPTION: Defines tuple types like `(A, B, C)` containing multiple heterogeneous elements. Unless forced with explicit representation attributes such as `#[repr(C)]`, the memory layout is unspecified and subject to compiler decisions, which may rearrange fields or insert padding for optimization.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_76\n\nLANGUAGE: Rust\nCODE:\n```\n(A, B, C)\n```\n\n----------------------------------------\n\nTITLE: CString Structure Visualization\nDESCRIPTION: Illustrates the memory layout of a `CString` in Rust, which is a NUL-terminated string. It points to a heap-allocated buffer containing the string data, followed by a NUL terminator.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_91\n\nLANGUAGE: rust\nCODE:\n```\n<code>CString</code> {{ std(page=\"std/ffi/struct.CString.html\") }}\n```\n\n----------------------------------------\n\nTITLE: Assigning Via Dereference (Move Failure) - Rust\nDESCRIPTION: Illustrates a case where `s = *r;` will not compile. If the value pointed to by `r` does NOT implement the `Copy` trait, dereferencing it with `*r` would attempt to move the value out, which is not allowed if `r` is a shared borrow, as it would leave the original location empty while other references might still exist.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_20\n\nLANGUAGE: Rust\nCODE:\n```\ns = *r;\n```\n\n----------------------------------------\n\nTITLE: Enum Sum Types with Tagging in Rust (Rust)\nDESCRIPTION: Defines an enum `enum E { A, B, C }` representing a sum type where the stored value is exclusively one of the listed variants. The compiler automatically manages an internal tag to identify the active variant, sometimes utilizing unused bits in the payload to optimize tagging.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_78\n\nLANGUAGE: Rust\nCODE:\n```\nenum E { A, B, C }\n```\n\n----------------------------------------\n\nTITLE: Defining a Trait without Parameters in Rust\nDESCRIPTION: This code defines a simple trait `Query` without any generic parameters. The trait has a `search` method that takes a string slice as input. Implementations are provided for `PostgreSQL` and `Sled` types. This represents the simplest case where the trait author assumes neither the implementor nor the user needs to customize the API.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_172\n\nLANGUAGE: Rust\nCODE:\n```\ntrait Query {\n    fn search(&self, needle: &str);\n}\n\nimpl Query for PostgreSQL { … }\nimpl Query for Sled { … }\n\npostgres.search(\"SELECT …\");\n```\n\n----------------------------------------\n\nTITLE: PathBuf Structure Visualization\nDESCRIPTION: Illustrates the memory layout of a `PathBuf` in Rust, representing a platform-specific file path. It essentially encapsulates an `OsString`.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_93\n\nLANGUAGE: rust\nCODE:\n```\n<code>PathBuf</code> {{ std(page=\"std/path/struct.PathBuf.html\") }}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Generic Structs with Lifetimes (Rust)\nDESCRIPTION: Illustrates how to instantiate a generic struct that requires a lifetime parameter. The `'static` lifetime is one that can be explicitly named in non-generic code. Often, the compiler can infer the appropriate lifetime if it is omitted.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/content/_index.md#_snippet_181\n\nLANGUAGE: Rust\nCODE:\n```\nlet a: S<'static>;\nlet b: S;\n```\n\n----------------------------------------\n\nTITLE: Apache License 2.0 Boilerplate Notice Template\nDESCRIPTION: This is the standard boilerplate notice recommended by the Apache License 2.0 appendix. It should be included in project files, typically within comments, with the placeholders '[yyyy]' and '[name of copyright owner]' replaced with the actual year and copyright holder's name.\nSOURCE: https://github.com/ralfbiedert/cheats.rs/blob/master/static/fonts/LICENSE_OpenSans.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nCopyright [yyyy] [name of copyright owner]\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n```"
  }
]