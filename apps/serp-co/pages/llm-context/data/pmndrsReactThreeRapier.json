[
  {
    "owner": "pmndrs",
    "repo": "react-three-rapier",
    "content": "TITLE: Basic React Three Rapier Setup with RigidBody and Collider\nDESCRIPTION: Demonstrates the basic usage of React Three Rapier within a React Three Fiber application. Shows how to set up a Physics component with a RigidBody for a Torus and a CuboidCollider for a ground plane.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box, Torus } from \"@react-three/drei\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { Physics, RigidBody, CuboidCollider } from \"@react-three/rapier\";\n\nconst App = () => {\n  return (\n    <Canvas>\n      <Suspense>\n        <Physics debug>\n          <RigidBody colliders={\"hull\"} restitution={2}>\n            <Torus />\n          </RigidBody>\n\n          <CuboidCollider position={[0, -2, 0]} args={[20, 0.5, 20]} />\n        </Physics>\n      </Suspense>\n    </Canvas>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of React Three Rapier with React Three Fiber\nDESCRIPTION: A simple example showing how to set up a physics scene with React Three Rapier. It creates a torus that bounces on a flat surface using a RigidBody component with a hull collider.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box, Torus } from \"@react-three/drei\";\nimport { Canvas } from \"@react-three/fiber\";\nimport { Physics, RigidBody, CuboidCollider } from \"@react-three/rapier\";\n\nconst App = () => {\n  return (\n    <Canvas>\n      <Suspense>\n        <Physics debug>\n          <RigidBody colliders={\"hull\"} restitution={2}>\n            <Torus />\n          </RigidBody>\n\n          <CuboidCollider position={[0, -2, 0]} args={[20, 0.5, 20]} />\n        </Physics>\n      </Suspense>\n    </Canvas>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Applying Forces and Manipulating Rigid Bodies in React Three Rapier\nDESCRIPTION: This snippet shows how to access and manipulate rigid bodies using refs. It demonstrates applying impulses, forces, torques, and continuous forces to physics objects.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RigidBody, RapierRigidBody } from \"@react-three/rapier\";\n\nconst Scene = () => {\n  const rigidBody = useRef<RapierRigidBody>(null);\n\n  useEffect(() => {\n    if (rigidBody.current) {\n      // A one-off \"push\"\n      rigidBody.current.applyImpulse({ x: 0, y: 10, z: 0 }, true);\n\n      // A continuous force\n      rigidBody.current.addForce({ x: 0, y: 10, z: 0 }, true);\n\n      // A one-off torque rotation\n      rigidBody.current.applyTorqueImpulse({ x: 0, y: 10, z: 0 }, true);\n\n      // A continuous torque\n      rigidBody.current.addTorque({ x: 0, y: 10, z: 0 }, true);\n    }\n  }, []);\n\n  return (\n    <RigidBody ref={rigidBody}>\n      <mesh>\n        <boxBufferGeometry />\n        <meshStandardMaterial />\n      </mesh>\n    </RigidBody>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Applying Forces and Manipulating RigidBodies in React Three Rapier\nDESCRIPTION: Illustrates how to access and manipulate RigidBody instances using refs. It shows various methods to apply forces, impulses, and torques to physics objects.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RigidBody, RapierRigidBody } from \"@react-three/rapier\";\n\nconst Scene = () => {\n  const rigidBody = useRef<RapierRigidBody>(null);\n\n  useEffect(() => {\n    if (rigidBody.current) {\n      // A one-off \"push\"\n      rigidBody.current.applyImpulse({ x: 0, y: 10, z: 0 }, true);\n\n      // A continuous force\n      rigidBody.current.addForce({ x: 0, y: 10, z: 0 }, true);\n\n      // A one-off torque rotation\n      rigidBody.current.applyTorqueImpulse({ x: 0, y: 10, z: 0 }, true);\n\n      // A continuous torque\n      rigidBody.current.addTorque({ x: 0, y: 10, z: 0 }, true);\n    }\n  }, []);\n\n  return (\n    <RigidBody ref={rigidBody}>\n      <mesh>\n        <boxBufferGeometry />\n        <meshStandardMaterial />\n      </mesh>\n    </RigidBody>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring the Physics Component in React Three Rapier\nDESCRIPTION: Shows how to configure the Physics component with custom gravity, interpolation settings, and collider generation options. The Physics component is the root of the physics world and needs to be wrapped in Suspense.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst Scene = () => {\n  return (\n    <Canvas>\n      <Suspense>\n        <Physics gravity={[0, 1, 0]} interpolation={false} colliders={false}>\n          ...\n        </Physics>\n      </Suspense>\n    </Canvas>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic RigidBody in React Three Rapier\nDESCRIPTION: Demonstrates the simplest way to create a RigidBody component with a mesh. The RigidBody component is used to add physics properties to meshes in the scene.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst RigidBodyMesh = () => (\n  <RigidBody>\n    <mesh />\n  </RigidBody>\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring the Physics Component\nDESCRIPTION: Example of configuring the Physics component with custom gravity, disabled interpolation, and disabled automatic collider generation.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst Scene = () => {\n  return (\n    <Canvas>\n      <Suspense>\n        <Physics gravity={[0, 1, 0]} interpolation={false} colliders={false}>\n          ...\n        </Physics>\n      </Suspense>\n    </Canvas>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Instanced Rigid Bodies in React Three Rapier\nDESCRIPTION: Demonstrates how to use InstancedRigidBodies to create multiple physics-enabled instances efficiently. It shows setting up instances, accessing individual instances, and updating all instances simultaneously.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { InstancedRigidBodies, RapierRigidBody } from \"@react-three/rapier\";\n\nconst COUNT = 1000;\n\nconst Scene = () => {\n  const rigidBodies = useRef<RapierRigidBody[]>(null);\n\n  useEffect(() => {\n    if (!rigidBodies.current) {\n      return;\n    }\n\n    // You can access individual instanced by their index\n    rigidBodies.current[40].applyImpulse({ x: 0, y: 10, z: 0 }, true);\n    rigidBodies.current.at(100).applyImpulse({ x: 0, y: 10, z: 0 }, true);\n\n    // Or update all instances\n    rigidBodies.current.forEach((api) => {\n      api.applyImpulse({ x: 0, y: 10, z: 0 }, true);\n    });\n  }, []);\n\n  // We can set the initial positions, and rotations, and scales, of\n  // the instances by providing an array of InstancedRigidBodyProps\n  // which is the same as RigidBodyProps, but with an additional \"key\" prop.\n  const instances = useMemo(() => {\n    const instances: InstancedRigidBodyProps[] = [];\n\n    for (let i = 0; i < COUNT; i++) {\n      instances.push({\n        key: \"instance_\" + Math.random(),\n        position: [Math.random() * 10, Math.random() * 10, Math.random() * 10],\n        rotation: [Math.random(), Math.random(), Math.random()]\n      });\n    }\n\n    return instances;\n  }, []);\n\n  return (\n    <InstancedRigidBodies\n      ref={rigidBodies}\n      instances={instances}\n      colliders=\"ball\"\n    >\n      <instancedMesh args={[undefined, undefined, COUNT]} count={COUNT} />\n    </InstancedRigidBodies>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Instanced Rigid Bodies in React Three Rapier with TSX\nDESCRIPTION: This example demonstrates how to create multiple physics-enabled instances using InstancedRigidBodies component. It creates 1000 instanced rigid bodies with individual properties and shows how to access and manipulate them via refs.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { InstancedRigidBodies, RapierRigidBody } from \"@react-three/rapier\";\n\nconst COUNT = 1000;\n\nconst Scene = () => {\n  const rigidBodies = useRef<RapierRigidBody[]>(null);\n\n  useEffect(() => {\n    if (!rigidBodies.current) {\n      return;\n    }\n\n    // You can access individual instanced by their index\n    rigidBodies.current[40].applyImpulse({ x: 0, y: 10, z: 0 }, true);\n    rigidBodies.current.at(100).applyImpulse({ x: 0, y: 10, z: 0 }, true);\n\n    // Or update all instances\n    rigidBodies.current.forEach((api) => {\n      api.applyImpulse({ x: 0, y: 10, z: 0 }, true);\n    });\n  }, []);\n\n  // We can set the initial positions, and rotations, and scales, of\n  // the instances by providing an array of InstancedRigidBodyProps\n  // which is the same as RigidBodyProps, but with an additional \"key\" prop.\n  const instances = useMemo(() => {\n    const instances: InstancedRigidBodyProps[] = [];\n\n    for (let i = 0; i < COUNT; i++) {\n      instances.push({\n        key: \"instance_\" + Math.random(),\n        position: [Math.random() * 10, Math.random() * 10, Math.random() * 10],\n        rotation: [Math.random(), Math.random(), Math.random()]\n      });\n    }\n\n    return instances;\n  }, []);\n\n  return (\n    <InstancedRigidBodies\n      ref={rigidBodies}\n      instances={instances}\n      colliders=\"ball\"\n    >\n      <instancedMesh args={[undefined, undefined, COUNT]} count={COUNT} />\n    </InstancedRigidBodies>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Collision Events in React Three Rapier\nDESCRIPTION: Shows how to subscribe to collision and state events on a RigidBody. It demonstrates handling collision enter events, sleep and wake events, and accessing collision information.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nconst RigidBottle = () => {\n  const [isAsleep, setIsAsleep] = useState(false);\n\n  return (\n    <RigidBody\n      colliders=\"hull\"\n      onSleep={() => setIsAsleep(true)}\n      onWake={() => setIsAsleep(false)}\n      name=\"Bally McBallFace\"\n      onCollisionEnter={({ manifold, target, other }) => {\n        console.log(\n          \"Collision at world position \",\n          manifold.solverContactPoint(0)\n        );\n\n        if (other.rigidBodyObject) {\n          console.log(\n            // this rigid body's Object3D\n            target.rigidBodyObject.name,\n            \" collided with \",\n            // the other rigid body's Object3D\n            other.rigidBodyObject.name\n          );\n        }\n      }}\n    >\n      <Sphere>\n        <meshPhysicalMaterial color={isAsleep ? \"white\" : \"blue\"} />\n      </Sphere>\n    </RigidBody>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Collision Events and Sleep States in React Three Rapier\nDESCRIPTION: This example demonstrates how to subscribe to collision events and sleep state changes on rigid bodies. It shows how to access collision data, including contact points and interacting objects.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nconst RigidBottle = () => {\n  const [isAsleep, setIsAsleep] = useState(false);\n\n  return (\n    <RigidBody\n      colliders=\"hull\"\n      onSleep={() => setIsAsleep(true)}\n      onWake={() => setIsAsleep(false)}\n      name=\"Bally McBallFace\"\n      onCollisionEnter={({ manifold, target, other }) => {\n        console.log(\n          \"Collision at world position \",\n          manifold.solverContactPoint(0)\n        );\n\n        if (other.rigidBodyObject) {\n          console.log(\n            // this rigid body's Object3D\n            target.rigidBodyObject.name,\n            \" collided with \",\n            // the other rigid body's Object3D\n            other.rigidBodyObject.name\n          );\n        }\n      }}\n    >\n      <Sphere>\n        <meshPhysicalMaterial color={isAsleep ? \"white\" : \"blue\"} />\n      </Sphere>\n    </RigidBody>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Physics Debug Visualization in React Three Rapier\nDESCRIPTION: This example demonstrates how to enable the debug visualization for physics objects by using the debug prop on the Physics component. It shows the live representation of colliders for boxes and spheres.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box, Sphere } from \"@react-three/drei\";\nimport { RigidBody } from \"@react-three/rapier\";\n\nconst Scene = () => {\n  return (\n    <Physics debug>\n      <RigidBody>\n        <Box />\n      </RigidBody>\n      <RigidBody>\n        <Sphere />\n      </RigidBody>\n    </Physics>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Collision Groups in React Three Rapier\nDESCRIPTION: Demonstrates how to configure collision groups and solver groups for RigidBodies and Colliders using the interactionGroups helper function. It shows various ways to set up group memberships and interactions.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\n<CapsuleCollider collisionGroups={interactionGroups(0, [0, 1, 2])} />\n```\n\nLANGUAGE: tsx\nCODE:\n```\n<CapsuleCollider collisionGroups={interactionGroups([0, 5], 7)} />\n```\n\nLANGUAGE: tsx\nCODE:\n```\n<CapsuleCollider collisionGroups={interactionGroups(12)} />\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Mode in React Three Rapier\nDESCRIPTION: Demonstrates how to enable debug mode in React Three Rapier by setting the debug prop on the Physics component. This allows for visual representation of all colliders in the scene.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box, Sphere } from \"@react-three/drei\";\nimport { RigidBody } from \"@react-three/rapier\";\n\nconst Scene = () => {\n  return (\n    <Physics debug>\n      <RigidBody>\n        <Box />\n      </RigidBody>\n      <RigidBody>\n        <Sphere />\n      </RigidBody>\n    </Physics>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Basic RigidBody Component Usage\nDESCRIPTION: A minimal example showing how to wrap a mesh with a RigidBody component to add physics behavior.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst RigidBodyMesh = () => (\n  <RigidBody>\n    <mesh />\n  </RigidBody>\n);\n```\n\n----------------------------------------\n\nTITLE: Using Helper Functions for Type Conversion in React Three Rapier\nDESCRIPTION: Demonstrates the use of helper functions (vec3, quat, euler) for converting between Rapier and Three.js types. It shows how to access and set position, rotation, and angular velocity of RigidBodies.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RapierRigidBody, quat, vec3, euler } from \"@react-three/rapier\";\n\nconst Scene = () => {\n  const rigidBody = useRef<RapierRigidBody>(null);\n\n  useEffect(() => {\n    if (rigidBody.current) {\n      const position = vec3(rigidBody.current.translation());\n      const quaternion = quat(rigidBody.current.rotation());\n      const eulerRot = euler().setFromQuaternion(\n        quat(rigidBody.current.rotation())\n      );\n\n      // While Rapier's return types need conversion, setting values can be done directly with Three.js types\n      rigidBody.current.setTranslation(position, true);\n      rigidBody.current.setRotation(quaternion, true);\n      rigidBody.current.setAngvel({ x: 0, y: 2, z: 0 }, true);\n    }\n  }, []);\n\n  return (\n    <RigidBody ref={rigidBody}>\n      <mesh>\n        <boxBufferGeometry />\n        <meshStandardMaterial />\n      </mesh>\n    </RigidBody>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Contact Force Events in React Three Rapier\nDESCRIPTION: This snippet demonstrates how to handle contact force events on a RigidBody component. The event provides information about collision forces between objects, including total force and force direction.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n<RigidBody\n  colliders=\"ball\"\n  onContactForce={(payload) => {\n    console.log(`The total force generated was: ${payload.totalForce}`);\n  }}\n>\n  <Sphere>\n    <meshPhysicalMaterial color={\"grey\"} />\n  </Sphere>\n</RigidBody>\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic Colliders with Physics Component\nDESCRIPTION: Example showing how to configure automatic collider generation globally using the Physics component's colliders prop set to 'hull'.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst Scene = () => (\n  <Physics colliders=\"hull\">\n    <RigidBody>\n      <Box />\n    </RigidBody>\n    <RigidBody position={[0, 10, 0]}>\n      <Sphere />\n    </RigidBody>\n  </Physics>\n);\n```\n\n----------------------------------------\n\nTITLE: Setting Default Collider Types in React Three Rapier\nDESCRIPTION: Shows how to set default collider generation for all RigidBody components via the Physics component's colliders prop. Demonstrates applying hull colliders to all physics objects.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst Scene = () => (\n  <Physics colliders=\"hull\">\n    <RigidBody>\n      <Box />\n    </RigidBody>\n    <RigidBody position={[0, 10, 0]}>\n      <Sphere />\n    </RigidBody>\n  </Physics>\n);\n```\n\n----------------------------------------\n\nTITLE: Controlling Collider Generation for RigidBodies\nDESCRIPTION: Demonstrates how to disable automatic collider generation globally but enable it for specific RigidBody components with different collider types (cuboid and ball).\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst Scene = () => (\n  <Physics colliders={false}>\n    {/* Use an automatic CuboidCollider for all meshes inside this RigidBody */}\n    <RigidBody colliders=\"cuboid\">\n      <Box />\n    </RigidBody>\n\n    {/* Use an automatic BallCollider for all meshes inside this RigidBody */}\n    <RigidBody position={[0, 10, 0]} colliders=\"ball\">\n      <Sphere />\n    </RigidBody>\n  </Physics>\n);\n```\n\n----------------------------------------\n\nTITLE: Mixed Global and Local Collider Configuration\nDESCRIPTION: Example demonstrating how to disable automatic collider generation globally while enabling it for specific RigidBody components with different collider types.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst Scene = () => (\n  <Physics colliders={false}>\n    {/* Use an automatic CuboidCollider for all meshes inside this RigidBody */}\n    <RigidBody colliders=\"cuboid\">\n      <Box />\n    </RigidBody>\n\n    {/* Use an automatic BallCollider for all meshes inside this RigidBody */}\n    <RigidBody position={[0, 10, 0]} colliders=\"ball\">\n      <Sphere />\n    </RigidBody>\n  </Physics>\n);\n```\n\n----------------------------------------\n\nTITLE: Converting Between Rapier and Three.js Types in React Three Rapier\nDESCRIPTION: This example shows how to use helper functions (vec3, quat, euler) for converting between Rapier's physics types and Three.js types. It demonstrates getting and setting position, rotation, and angular velocity.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RapierRigidBody, quat, vec3, euler } from \"@react-three/rapier\";\n\nconst Scene = () => {\n  const rigidBody = useRef<RapierRigidBody>(null);\n\n  useEffect(() => {\n    if (rigidBody.current) {\n      const position = vec3(rigidBody.current.translation());\n      const quaternion = quat(rigidBody.current.rotation());\n      const eulerRot = euler().setFromQuaternion(\n        quat(rigidBody.current.rotation())\n      );\n\n      // While Rapier's return types need conversion, setting values can be done directly with Three.js types\n      rigidBody.current.setTranslation(position, true);\n      rigidBody.current.setRotation(quaternion, true);\n      rigidBody.current.setAngvel({ x: 0, y: 2, z: 0 }, true);\n    }\n  }, []);\n\n  return (\n    <RigidBody ref={rigidBody}>\n      <mesh>\n        <boxBufferGeometry />\n        <meshStandardMaterial />\n      </mesh>\n    </RigidBody>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Fixed Joint Between Two Bodies\nDESCRIPTION: Demonstrates creating a fixed joint that prevents any relative motion between two rigid bodies. This type of joint is useful for creating composite objects from multiple parts.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n\n  const joint = useFixedJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Orientation of the joint in bodyA's local space\n    [0, 0, 0, 1],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0],\n    // Orientation of the joint in bodyB's local space\n    [0, 0, 0, 1]\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Revolute Joint with Motor in React Three Rapier\nDESCRIPTION: This snippet demonstrates creating a wheel joint using the useRevoluteJoint hook and configuring a motor velocity. Revolute joints allow rotation around a single axis, similar to a hinge.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\nconst WheelJoint = ({ bodyA, bodyB }) => {\n  const joint = useRevoluteJoint(bodyA, bodyB, [\n    [0, 0, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n  ]);\n\n  useFrame(() => {\n    if (joint.current) {\n      joint.current.configureMotorVelocity(10, 2);\n    }\n  }, []);\n\n  return null;\n};\n```\n\n----------------------------------------\n\nTITLE: On-Demand Rendering Configuration in React Three Rapier\nDESCRIPTION: Shows how to configure on-demand rendering in React Three Rapier. This setup runs the physics simulation independently from the render loop, improving performance for scenes that don't require constant updates.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_28\n\nLANGUAGE: tsx\nCODE:\n```\n<Canvas frameloop=\"demand\">\n  <Physics updateLoop=\"independent\">...</Physics>\n</Canvas>\n```\n\n----------------------------------------\n\nTITLE: Manually Stepping Physics Simulation in React Three Rapier\nDESCRIPTION: This snippet demonstrates how to manually step the physics simulation using the step method from the useRapier hook. It steps the simulation by 1/60th of a second.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_28\n\nLANGUAGE: tsx\nCODE:\n```\nconst { step } = useRapier();\n\nstep(1 / 60);\n```\n\n----------------------------------------\n\nTITLE: World Snapshot Management in React Three Rapier\nDESCRIPTION: Illustrates how to take and restore snapshots of the physics world in React Three Rapier. This component provides functions to serialize the world state and later reconstruct it, useful for saving and loading physics states.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_29\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useRapier } from '@react-three/rapier';\n\nconst SnapshottingComponent = () => {\n  const { world, setWorld, rapier } = useRapier();\n  const worldSnapshot = useRef<Uint8Array>();\n\n  // Store the snapshot\n  const takeSnapshot = () => {\n    const snapshot = world.takeSnapshot()\n    worldSnapshot.current = snapshot\n  }\n\n  // Create a new World from the snapshot, and replace the current one\n  const restoreSnapshot = () => {\n    setWorld(rapier.World.restoreSnapshot(worldSnapshot.current))\n  }\n\n  return <>\n    <Rigidbody>...</RigidBody>\n    <Rigidbody>...</RigidBody>\n    <Rigidbody>...</RigidBody>\n    <Rigidbody>...</RigidBody>\n    <Rigidbody>...</RigidBody>\n  </>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Restoring World Snapshots in React Three Rapier\nDESCRIPTION: This snippet demonstrates how to create and restore world snapshots in React Three Rapier. It includes functions to take a snapshot of the current world state and restore it, as well as a component structure for using these functions.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_30\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useRapier } from '@react-three/rapier';\n\nconst SnapshottingComponent = () => {\n  const { world, setWorld, rapier } = useRapier();\n  const worldSnapshot = useRef<Uint8Array>();\n\n  // Store the snapshot\n  const takeSnapshot = () => {\n    const snapshot = world.takeSnapshot()\n    worldSnapshot.current = snapshot\n  }\n\n  // Create a new World from the snapshot, and replace the current one\n  const restoreSnapshot = () => {\n    setWorld(rapier.World.restoreSnapshot(worldSnapshot.current))\n  }\n\n  return <>\n    <Rigidbody>...</RigidBody>\n    <Rigidbody>...</RigidBody>\n    <Rigidbody>...</RigidBody>\n    <Rigidbody>...</RigidBody>\n    <Rigidbody>...</RigidBody>\n  </>\n}\n```\n\n----------------------------------------\n\nTITLE: Including Invisible Meshes in Collider Creation\nDESCRIPTION: Example showing how to include invisible meshes in collider generation using the includeInvisible flag, useful for physics objects that shouldn't be visible.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n<RigidBody colliders=\"hull\" includeInvisible>\n  <object3D>\n    <Suzanne visible={false} />\n  </object3D>\n</RigidBody>\n```\n\n----------------------------------------\n\nTITLE: Including Invisible Meshes in Collider Creation\nDESCRIPTION: Shows how to include invisible meshes in the automatic collider generation process by using the includeInvisible flag. This is useful for creating collision shapes from hidden geometry.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n<RigidBody colliders=\"hull\" includeInvisible>\n  <object3D>\n    <Suzanne visible={false} />\n  </object3D>\n</RigidBody>\n```\n\n----------------------------------------\n\nTITLE: Creating Sensor Colliders for Collision Detection in React Three Rapier\nDESCRIPTION: This example demonstrates creating a sensor collider that detects intersections without generating physical forces. Useful for trigger zones like goal detection or area effects.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\n<RigidBody>\n  <GoalPosts />\n\n  <CuboidCollider\n    args={[5, 5, 1]}\n    sensor\n    onIntersectionEnter={() => console.log(\"Goal!\")}\n  />\n</RigidBody>\n```\n\n----------------------------------------\n\nTITLE: Configuring Collision Groups in React Three Rapier\nDESCRIPTION: These examples demonstrate how to configure collision groups using the interactionGroups helper function. It shows various ways to specify which groups a collider belongs to and which groups it should interact with.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\n<CapsuleCollider collisionGroups={interactionGroups(0, [0, 1, 2])} />\n```\n\nLANGUAGE: tsx\nCODE:\n```\n<CapsuleCollider collisionGroups={interactionGroups([0, 5], 7)} />\n```\n\nLANGUAGE: tsx\nCODE:\n```\n<CapsuleCollider collisionGroups={interactionGroups(12)} />\n```\n\n----------------------------------------\n\nTITLE: Implementing a Spherical Joint Between Rigid Bodies in React Three Rapier\nDESCRIPTION: This snippet demonstrates creating a spherical joint (ball and socket) between two rigid bodies. Spherical joints prevent relative translational motion at the connection point but allow rotation in all directions.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n\n  const joint = useSphericalJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0]\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Spherical Joint for Ball-Socket Connections\nDESCRIPTION: Shows how to implement a spherical joint that allows rotation in all directions around a fixed point, similar to a ball and socket. This is useful for arms, chains, and other articulated objects.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n\n  const joint = useSphericalJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0]\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Prismatic Joint for Sliding Movements\nDESCRIPTION: Demonstrates implementing a prismatic joint that only allows relative movement along a single axis. This is useful for pistons, sliders, and other constrained linear motion systems.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n\n  const joint = usePrismaticJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0],\n    // Axis of the joint, expressed in the local-space of\n    // the rigid-bodies it is attached to. Cannot be [0,0,0].\n    [0, 1, 0]\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Revolute Joint Between Rigid Bodies in React Three Rapier\nDESCRIPTION: This snippet shows how to implement a revolute joint between two rigid bodies. Revolute joints act like hinges, allowing rotation around a single specified axis while preventing other movements.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n  \n  const joint = useRevoluteJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0],\n    // Axis of the joint, expressed in the local-space of\n    // the rigid-bodies it is attached to. Cannot be [0,0,0].\n    [0, 1, 0]\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Prismatic Joint Between Rigid Bodies in React Three Rapier\nDESCRIPTION: This example demonstrates creating a prismatic joint between two rigid bodies. Prismatic joints allow sliding along a single axis while preventing rotation and movement in other directions, ideal for pistons or sliders.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_25\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n\n  const joint = usePrismaticJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0],\n    // Axis of the joint, expressed in the local-space of\n    // the rigid-bodies it is attached to. Cannot be [0,0,0].\n    [0, 1, 0]\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Revolute Joint for Hinged Objects\nDESCRIPTION: Shows how to create a revolute joint that restricts movement to rotation around a single axis. This type of joint is ideal for doors, wheels, and other hinged components.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n  \n  const joint = useRevoluteJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0],\n    // Axis of the joint, expressed in the local-space of\n    // the rigid-bodies it is attached to. Cannot be [0,0,0].\n    [0, 1, 0]\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Compound Colliders for Instanced Meshes in React Three Rapier\nDESCRIPTION: This snippet shows how to create compound collision shapes for instanced meshes by providing multiple collider components in the colliderNodes prop. It combines box and sphere colliders for 500 instances.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  InstancedRigidBodies,\n  BoxCollider,\n  SphereCollider\n} from \"@react-three/rapier\";\nconst COUNT = 500;\n\nconst Scene = () => {\n  const instances = useMemo(() => {\n    const instances: InstancedRigidBodyProps[] = [];\n\n    for (let i = 0; i < COUNT; i++) {\n      instances.push({\n        key: \"instance_\" + Math.random(),\n        position: [Math.random() * 10, Math.random() * 10, Math.random() * 10],\n        rotation: [Math.random(), Math.random(), Math.random()]\n      });\n    }\n\n    return instances;\n  }, []);\n\n  return (\n    <InstancedRigidBodies\n      instances={instances}\n      colliders=\"ball\"\n      colliderNodes={[\n        <BoxCollider args={[0.5, 0.5, 0.5]} />,\n        <SphereCollider args={[0.5]} />\n      ]}\n    >\n      <instancedMesh args={[undefined, undefined, COUNT]} count={COUNT} />\n    </InstancedRigidBodies>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Fixed Joint Between Rigid Bodies in React Three Rapier\nDESCRIPTION: This example shows how to create a fixed joint between two rigid bodies. Fixed joints prevent any relative movement between the bodies, keeping them locked in position relative to each other.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n\n  const joint = useFixedJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Orientation of the joint in bodyA's local space\n    [0, 0, 0, 1],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0],\n    // Orientation of the joint in bodyB's local space\n    [0, 0, 0, 1]\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Handling Contact Force Events in RigidBody Components\nDESCRIPTION: Demonstrates how to implement contact force event handling on RigidBody components. The onContactForce callback provides detailed information about collision forces between physics objects.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\n<RigidBody\n  colliders=\"ball\"\n  onContactForce={(payload) => {\n    console.log(`The total force generated was: ${payload.totalForce}`);\n  }}\n>\n  <Sphere>\n    <meshPhysicalMaterial color={\"grey\"} />\n  </Sphere>\n</RigidBody>\n```\n\n----------------------------------------\n\nTITLE: Creating a Revolute Joint with Motor Control\nDESCRIPTION: Shows how to create a revolute joint (like a hinge) between two rigid bodies and control it programmatically. The example includes configuring the motor velocity during runtime.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\nconst WheelJoint = ({ bodyA, bodyB }) => {\n  const joint = useRevoluteJoint(bodyA, bodyB, [\n    [0, 0, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n  ]);\n\n  useFrame(() => {\n    if (joint.current) {\n      joint.current.configureMotorVelocity(10, 2);\n    }\n  }, []);\n\n  return null;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Rope Joint with Distance Constraints\nDESCRIPTION: Shows how to create a rope joint that limits the maximum distance between two bodies. This is useful for ropes, chains, and other distance-constrained connections.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_25\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n\n  const joint = useRopeJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0],\n    // The max distance between the two bodies / length of the rope\n    1\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Spring Joint with Stiffness and Damping\nDESCRIPTION: Demonstrates implementing a spring joint that applies forces proportional to the distance between two bodies. This includes configuration for stiffness, damping, and rest length.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_26\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n\n  const mass = 1;\n  const springRestLength = 0;\n  const stiffness = 1.0e3;\n  const criticalDamping = 2.0 * Math.sqrt(stiffness * mass);\n  const dampingRatio = props.jointNum / (props.total / 2);\n  const damping = dampingRatio * criticalDamping;\n\n  const joint = useSpringJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0],\n    // Spring rest length\n    springRestLength,\n    // Spring stiffness\n    stiffness,\n    // Spring damping\n    damping\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: RigidBody in Transformed Group\nDESCRIPTION: Example showing how RigidBodies work inside transformed groups, where the physics simulation runs in world space but is transformed to the object's local space.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from \"@react-three/drei\";\nimport { RigidBody, CuboidCollider } from \"@react-three/rapier\";\n\nconst Scene = () => (\n  <group position={[2, 5, 0]} rotation={[0, 0.3, 2]}>\n    <RigidBody>\n      <Box />\n      <CuboidCollider args={[0.5, 0.5, 0.5]} />\n    </RigidBody>\n  </group>\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Fixed Time Step for Physics Simulation\nDESCRIPTION: Shows how to set a specific fixed time step for physics simulation using the timeStep prop. This example sets the physics to update at 30 frames per second.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\n<Physics timeStep={1 / 30}>{/* ... */}</Physics>\n```\n\n----------------------------------------\n\nTITLE: Configuring Fixed Time Step for Physics Simulation in React Three Rapier\nDESCRIPTION: This snippet shows how to set a custom fixed time step for the physics simulation. The example sets the simulation to run at 30 frames per second instead of the default 60.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\n<Physics timeStep={1 / 30}>{/* ... */}</Physics>\n```\n\n----------------------------------------\n\nTITLE: Using RigidBodies with Transformed Parent Objects\nDESCRIPTION: Demonstrates how RigidBodies work inside transformed parent objects, where physics simulation runs in world space and is transformed to object local space. Shows collider integration in nested transforms.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Box } from \"@react-three/drei\";\nimport { RigidBody, CuboidCollider } from \"@react-three/rapier\";\n\nconst Scene = () => (\n  <group position={[2, 5, 0]} rotation={[0, 0.3, 2]}>\n    <RigidBody>\n      <Box />\n      <CuboidCollider args={[0.5, 0.5, 0.5]} />\n    </RigidBody>\n  </group>\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Variable Time Step for Physics Simulation\nDESCRIPTION: Demonstrates setting a variable time step that adjusts to the frame rate. This can be useful for games with variable frame rates but may cause simulation instability.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\n<Physics timeStep=\"vary\">{/* ... */}</Physics>\n```\n\n----------------------------------------\n\nTITLE: Configuring Variable Time Step for Physics Simulation in React Three Rapier\nDESCRIPTION: This snippet demonstrates how to set the physics simulation to use a variable time step that adjusts to the frame delta. Useful for variable frame rate applications but may cause simulation instability.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\n<Physics timeStep=\"vary\">{/* ... */}</Physics>\n```\n\n----------------------------------------\n\nTITLE: Using Attractor Component in React\nDESCRIPTION: Examples of using the Attractor component in React Three Fiber with different configurations, including standard attractors, repulsive attractors, and attractors with specific collision groups.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier-addons/README.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Attractor } from \"@react-three/rapier-addons\"\n\n// Standard attractor\n<Attractor range={10} strength={5} type=\"linear\" position={[5, -5, 0]} />\n\n// An attractor with negative strength, repels RigidBodies\n<Attractor range={10} strength={-5} position={[5, -5, 0]} />\n\n// You can also assign InteractionGroups.\n// An attractor belonging to group 0 only affecting bodies in group 2, and 3\n<Attractor range={10} strength={10} position={[5, -5, 0]} collisionGroups={interactionGroups(0, [2,3])} />\n```\n\n----------------------------------------\n\nTITLE: Creating Compound Colliders with Manual Collider Components\nDESCRIPTION: Shows how to create compound colliders by adding multiple collider components to a RigidBody. Demonstrates both automatic and manual collider creation within the same rigid body.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst Scene = () => (<>\n  {/* Make a compound shape with two custom BallColliders */}\n  <RigidBody position={[0, 10, 0]}>\n    <Sphere />\n    <BallCollider args={[0.5]} />\n    <BallCollider args={[0.5]} position={[1, 0, 0]} />\n  </RigidBody>\n\n  {/* Make a compound shape with two custom BallColliders, an automatic BallCollider,\n      Two automatic MeshColliders, based on two different shape types */}\n  <RigidBody position={[0, 10, 0]} colliders='ball'>\n    <MeshCollider type=\"trimesh\">\n      <mesh ... />\n    </MeshCollider>\n\n    <MeshCollider type=\"hull\">\n      <mesh ... />\n    </MeshCollider>\n\n    <Sphere />\n\n    <BallCollider args={[0.5]} />\n    <BallCollider args={[0.5]} position={[1, 0, 0]} />\n  </RigidBody>\n<>)\n```\n\n----------------------------------------\n\nTITLE: Defining AttractorProps Interface in TypeScript\nDESCRIPTION: TypeScript interface that defines the properties available for the Attractor component, including position, strength, range, type, gravitationalConstant, and collisionGroups.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier-addons/README.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\ntype AttractorProps = {\n  /**\n   * The relative position of this attractor\n   */\n  position?: Object3DProps[\"position\"];\n\n  /**\n   * The strength of the attractor.\n   * Positive values attract, negative values repel.\n   *\n   * @defaultValue 1\n   */\n  strength?: number;\n\n  /**\n   * The range of the attractor. Will not affect objects outside of this range.\n   *\n   * @defaultValue 10\n   * @min 0\n   */\n  range?: number;\n\n  /**\n   * The type of gravity to use.\n   * - static: The gravity is constant and does not change over time.\n   * - linear: The gravity is linearly interpolated the closer the object is to the attractor.\n   * - newtonian: The gravity is calculated using the newtonian gravity formula.\n   * @defaultValue \"static\"\n   */\n  type?: string;\n\n  /**\n   * The mass of the attractor. Used when type is `newtonian`.\n   * @defaultValue 6.673e-11\n   */\n  gravitationalConstant?: number;\n\n  /**\n   * The collision groups that this attractor will apply effects to. If a RigidBody contains one or more colliders that are in one of the mask group, it will be affected by this attractor.\n   * If not specified, the attractor will apply effects to all RigidBodies.\n   */\n  collisionGroups?: InteractionGroups;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Compound Colliders\nDESCRIPTION: Examples of creating compound colliders using a combination of automatic and custom collider components, useful for creating complex shapes or detecting collisions on specific parts of a mesh.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst Scene = () => (<>\n  {/* Make a compound shape with two custom BallColliders */}\n  <RigidBody position={[0, 10, 0]}>\n    <Sphere />\n    <BallCollider args={[0.5]} />\n    <BallCollider args={[0.5]} position={[1, 0, 0]} />\n  </RigidBody>\n\n  {/* Make a compound shape with two custom BallColliders, an automatic BallCollider,\n      Two automatic MeshColliders, based on two different shape types */}\n  <RigidBody position={[0, 10, 0]} colliders='ball'>\n    <MeshCollider type=\"trimesh\">\n      <mesh ... />\n    </MeshCollider>\n\n    <MeshCollider type=\"hull\">\n      <mesh ... />\n    </MeshCollider>\n\n    <Sphere />\n\n    <BallCollider args={[0.5]} />\n    <BallCollider args={[0.5]} position={[1, 0, 0]} />\n  </RigidBody>\n</>)\n```\n\n----------------------------------------\n\nTITLE: Proper World Access Pattern in React-Three-Rapier\nDESCRIPTION: Example demonstrating the recommended pattern for accessing the Rapier world properties within React components, ensuring proper synchronization with the component lifecycle.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/CHANGELOG.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// bad\nconst Component = () => {\n  const {world} = useRapier()\n\n  world.setGravity(...)\n\n  return null\n}\n\n// good\nconst Component = () => {\n  const {world} = useRapier()\n\n  useEffect(() => {\n    world.setGravity(...)\n  }, [])\n\n  return null\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring On-Demand Rendering in React Three Rapier\nDESCRIPTION: This code snippet shows how to set up on-demand rendering in React Three Rapier. It configures the Canvas to use demand-based frame looping and sets the Physics component to use an independent update loop.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_29\n\nLANGUAGE: tsx\nCODE:\n```\n<Canvas frameloop=\"demand\">\n  <Physics updateLoop=\"independent\">...</Physics>\n</Canvas>\n```\n\n----------------------------------------\n\nTITLE: Migrating from WorldApi to Singleton Instance in React-Three-Rapier\nDESCRIPTION: Example showing the migration from the deprecated WorldApi approach to the new singleton instance proxy pattern for accessing the Rapier world in version 1.0.0.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/CHANGELOG.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Before:\nimport { useRapier } from \"@react-three/rapier\";\n\nconst Component = () => {\n  const { world } = useRapier();\n\n  useEffect(() => {\n    // Access to the WorldApi (limited)\n    world.raw().bodies.forEach(() => {\n      // Do something\n    });\n\n    // Access the raw Rapier World instance\n    const rawWorldInstance = world.raw();\n    rawWorldInstance.raw().setGravity(new Vector3(0, -9.81, 0));\n  }, []);\n};\n```\n\nLANGUAGE: tsx\nCODE:\n```\n// Now:\nimport { useRapier } from \"@react-three/rapier\";\n\nconst Component = () => {\n  const { world } = useRapier();\n\n  useEffect(() => {\n    // Access the Rapier World instance directly\n    world.bodies.forEach(() => {\n      // Do something\n    });\n    world.setGravity(new Vector3(0, -9.81, 0));\n  }, []);\n};\n```\n\n----------------------------------------\n\nTITLE: Manual Stepping of Physics Simulation in React Three Rapier\nDESCRIPTION: Demonstrates how to manually step the physics simulation using the step method from the useRapier hook. This allows for fine-grained control over the physics update cycle.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_27\n\nLANGUAGE: tsx\nCODE:\n```\nconst { step } = useRapier();\n\nstep(1 / 60);\n```\n\n----------------------------------------\n\nTITLE: Collision Events on Individual Colliders in React Three Rapier\nDESCRIPTION: This snippet shows how to attach collision event handlers directly to collider components rather than rigid bodies. It demonstrates subscribing to collision enter and exit events on a CuboidCollider.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\n<CuboidCollider\n  onCollisionEnter={(payload) => {\n    /* ... */\n  }}\n  onCollisionExit={(payload) => {\n    /* ... */\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Implementing Sensors with Intersection Events\nDESCRIPTION: Demonstrates how to create a sensor collider that detects intersections without generating physical reactions. This example shows using onIntersectionEnter for goal detection in a game.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\n<RigidBody>\n  <GoalPosts />\n\n  <CuboidCollider\n    args={[5, 5, 1]}\n    sensor\n    onIntersectionEnter={() => console.log(\"Goal!\")}\n  />\n</RigidBody>\n```\n\n----------------------------------------\n\nTITLE: Adding Contact Force Events to Colliders in React Three Rapier\nDESCRIPTION: This snippet shows how to add contact force event handlers directly to a collider component instead of a RigidBody. This allows for more granular control over collision events.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\n<CapsuleCollider\n  onContactForce={(payload) => {\n    /* ... */\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: React Three Rapier Changelog Entry\nDESCRIPTION: A series of changelog entries documenting version changes, bug fixes, and feature additions to the React Three Rapier physics library. Includes updates to joints API, rigid body handling, collider systems, and physics debugging tools.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/CHANGELOG.md#2025-04-11_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n### Minor Changes\n\n- 02055ed: Removed joints api, replaced with RefObjects containing the joint instances\n- 25c4261: Update rapier to 0.11.1\n- 02055ed: Refreshed InstancedRigidBody component with support for dynamic count and fine-grain control over each instance\n- 02055ed: Remove RigidBody proxy apis for much needed simplification, add helper functions for dealing with Rapier math functions\n- 02055ed: Collider refs now return a single collider rather than an array, as it should be\n```\n\n----------------------------------------\n\nTITLE: Adding Contact Force Events to Colliders\nDESCRIPTION: Shows how to add contact force event handling directly to collider components instead of RigidBody components. This allows for more granular control over collision detection.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n<CapsuleCollider\n  onContactForce={(payload) => {\n    /* ... */\n  }}\n/>\n```\n\n----------------------------------------\n\nTITLE: Fork-and-Pull Git Workflow Steps for Contributing to @react-three/fiber\nDESCRIPTION: A numbered list of steps describing the fork-and-pull Git workflow for contributing code to the @react-three/fiber project. It includes forking, cloning, committing changes, pushing to the fork, and submitting a pull request.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/CONTRIBUTING.md#2025-04-11_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n1.  **Fork** the repo on GitHub\n2.  **Clone** the project to your own machine\n3.  **Commit** changes to your own branch  \n    This project uses `commitlint` and `conventional-commits` for commit messages.  \n    Please follow the [conventional commits](https://www.conventionalcommits.org/en/v1.0.0/) format.\n4.  **Push** your work back up to your fork\n5.  Submit a **Pull request** so that we can review your changes\n```\n\n----------------------------------------\n\nTITLE: Implementing a Spring Joint Between Rigid Bodies in React Three Rapier\nDESCRIPTION: This example demonstrates creating a spring joint with customizable stiffness and damping. Spring joints apply forces proportional to the distance between bodies, allowing for elastic connections with physics-based behavior.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_27\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n\n  const mass = 1;\n  const springRestLength = 0;\n  const stiffness = 1.0e3;\n  const criticalDamping = 2.0 * Math.sqrt(stiffness * mass);\n  const dampingRatio = props.jointNum / (props.total / 2);\n  const damping = dampingRatio * criticalDamping;\n\n  const joint = useSpringJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0],\n    // Spring rest length\n    springRestLength,\n    // Spring stiffness\n    stiffness,\n    // Spring damping\n    damping\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Rope Joint Between Rigid Bodies in React Three Rapier\nDESCRIPTION: This snippet shows how to implement a rope joint between two rigid bodies. Rope joints limit the maximum distance between bodies while allowing free movement within that range, simulating rope-like constraints.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/readme.md#2025-04-11_snippet_26\n\nLANGUAGE: tsx\nCODE:\n```\nconst JointedThing = () => {\n  const bodyA = useRef<RapierRigidBody>(null);\n  const bodyB = useRef<RapierRigidBody>(null);\n\n  const joint = useRopeJoint(bodyA, bodyB, [\n    // Position of the joint in bodyA's local space\n    [0, 0, 0],\n    // Position of the joint in bodyB's local space\n    [0, 0, 0],\n    // The max distance between the two bodies / length of the rope\n    1\n  ]);\n\n  return (\n    <group>\n      <RigidBody ref={bodyA}>\n        <mesh />\n      </RigidBody>\n      <RigidBody ref={bodyB}>\n        <mesh />\n      </RigidBody>\n    </group>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Compound Shapes for Instanced Meshes in React Three Rapier\nDESCRIPTION: Shows how to create compound shapes for instanced meshes by providing an array of Colliders in the colliderNodes prop. This allows for more complex physics interactions with instanced objects.\nSOURCE: https://github.com/pmndrs/react-three-rapier/blob/main/packages/react-three-rapier/readme.md#2025-04-11_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  InstancedRigidBodies,\n  BoxCollider,\n  SphereCollider\n} from \"@react-three/rapier\";\nconst COUNT = 500;\n\nconst Scene = () => {\n  const instances = useMemo(() => {\n    const instances: InstancedRigidBodyProps[] = [];\n\n    for (let i = 0; i < COUNT; i++) {\n      instances.push({\n        key: \"instance_\" + Math.random(),\n        position: [Math.random() * 10, Math.random() * 10, Math.random() * 10],\n        rotation: [Math.random(), Math.random(), Math.random()]\n      });\n    }\n\n    return instances;\n  }, []);\n\n  return (\n    <InstancedRigidBodies\n      instances={instances}\n      colliders=\"ball\"\n      colliderNodes={[\n        <BoxCollider args={[0.5, 0.5, 0.5]} />,\n        <SphereCollider args={[0.5]} />\n      ]}\n    >\n      <instancedMesh args={[undefined, undefined, COUNT]} count={COUNT} />\n    </InstancedRigidBodies>\n  );\n};\n```"
  }
]