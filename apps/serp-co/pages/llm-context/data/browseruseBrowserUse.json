[
  {
    "owner": "browser-use",
    "repo": "browser-use",
    "content": "TITLE: Basic Implementation of Browser Use API in Python\nDESCRIPTION: This snippet shows a basic implementation of the Browser Use API using Python's requests library. It includes functions to create a task, get task status, get task details, and wait for task completion. The main function demonstrates how to use these functions to create and monitor a browser automation task.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/cloud/implementation.mdx#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport json\nimport time\n\nimport requests\n\nAPI_KEY = 'your_api_key_here'\nBASE_URL = 'https://api.browser-use.com/api/v1'\nHEADERS = {'Authorization': f'Bearer {API_KEY}'}\n\n\ndef create_task(instructions: str):\n\t\"\"\"Create a new browser automation task\"\"\"\n\tresponse = requests.post(f'{BASE_URL}/run-task', headers=HEADERS, json={'task': instructions})\n\treturn response.json()['id']\n\n\ndef get_task_status(task_id: str):\n\t\"\"\"Get current task status\"\"\"\n\tresponse = requests.get(f'{BASE_URL}/task/{task_id}/status', headers=HEADERS)\n\treturn response.json()\n\n\ndef get_task_details(task_id: str):\n\t\"\"\"Get full task details including output\"\"\"\n\tresponse = requests.get(f'{BASE_URL}/task/{task_id}', headers=HEADERS)\n\treturn response.json()\n\n\ndef wait_for_completion(task_id: str, poll_interval: int = 2):\n\t\"\"\"Poll task status until completion\"\"\"\n\tcount = 0\n\tunique_steps = []\n\twhile True:\n\t\tdetails = get_task_details(task_id)\n\t\tnew_steps = details['steps']\n\t\t# use only the new steps that are not in unique_steps.\n\t\tif new_steps != unique_steps:\n\t\t\tfor step in new_steps:\n\t\t\t\tif step not in unique_steps:\n\t\t\t\t\tprint(json.dumps(step, indent=4))\n\t\tunique_steps = new_steps\n\t\tcount += 1\n\t\tstatus = details['status']\n\n\t\tif status in ['finished', 'failed', 'stopped']:\n\t\t\treturn details\n\t\ttime.sleep(poll_interval)\n\n\ndef main():\n\ttask_id = create_task('Open https://www.google.com and search for openai')\n\tprint(f'Task created with ID: {task_id}')\n\ttask_details = wait_for_completion(task_id)\n\tprint(f\"Final output: {task_details['output']}\")\n\n\nif __name__ == '__main__':\n\tmain()\n\n```\n\n----------------------------------------\n\nTITLE: Basic AI Agent Implementation\nDESCRIPTION: Example code showing how to create and run a basic AI agent using browser-use with OpenAI's GPT-4.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\nimport asyncio\nfrom dotenv import load_dotenv\nload_dotenv()\n\nasync def main():\n    agent = Agent(\n        task=\"Compare the price of gpt-4o and DeepSeek-V3\",\n        llm=ChatOpenAI(model=\"gpt-4o\"),\n    )\n    await agent.run()\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Using Sensitive Data Parameter with Browser Automation Agent in Python\nDESCRIPTION: This example demonstrates how to securely handle sensitive information like usernames and passwords by using the sensitive_data parameter. The model only sees placeholder keys (x_name, x_password) rather than the actual values, which are automatically substituted during execution while remaining hidden from the model.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/sensitive-data.mdx#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dotenv import load_dotenv\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\n\nload_dotenv()\n\n# Initialize the model\nllm = ChatOpenAI(\n    model='gpt-4o',\n    temperature=0.0,\n)\n\n# Define sensitive data\n# The model will only see the keys (x_name, x_password) but never the actual values\nsensitive_data = {'x_name': 'magnus', 'x_password': '12345678'}\n\n# Use the placeholder names in your task description\ntask = 'go to x.com and login with x_name and x_password then write a post about the meaning of life'\n\n# Pass the sensitive data to the agent\nagent = Agent(task=task, llm=llm, sensitive_data=sensitive_data)\n\nasync def main():\n    await agent.run()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Initializing Browser Use Agent with Basic Settings\nDESCRIPTION: Configures a Browser Use Agent with the required parameters: a task description and a LangChain chat model instance. These are the minimum parameters needed to create a functional agent.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use import Agent\nfrom langchain_openai import ChatOpenAI\n\nagent = Agent(\n    task=\"Search for latest news about AI\",\n    llm=ChatOpenAI(model=\"gpt-4o\"),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Browser Use Agent with Langchain OpenAI\nDESCRIPTION: Example Python script that creates a Browser Use agent with a specific task to compare prices. The agent uses GPT-4o via Langchain's OpenAI integration.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/quickstart.mdx#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\nfrom dotenv import load_dotenv\nload_dotenv()\n\nimport asyncio\n\nllm = ChatOpenAI(model=\"gpt-4o\")\n\nasync def main():\n    agent = Agent(\n        task=\"Compare the price of gpt-4o and DeepSeek-V3\",\n        llm=llm,\n    )\n    result = await agent.run()\n    print(result)\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Initializing OpenAI GPT-4o Model with Browser Use Agent\nDESCRIPTION: Demonstrates how to set up an OpenAI GPT-4o model with Browser Use Agent. This configuration is recommended for best performance, achieving 89% accuracy on the WebVoyager Dataset. Requires the OPENAI_API_KEY environment variable.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/supported-models.mdx#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\n\n# Initialize the model\nllm = ChatOpenAI(\n    model=\"gpt-4o\",\n    temperature=0.0,\n)\n\n# Create agent with the model\nagent = Agent(\n    task=\"Your task here\",\n    llm=llm\n)\n```\n\nLANGUAGE: bash\nCODE:\n```\nOPENAI_API_KEY=\n```\n\n----------------------------------------\n\nTITLE: Structured Output Implementation in Browser Use API (Python)\nDESCRIPTION: This snippet shows how to implement a task with structured JSON output using the Browser Use API. It defines a schema using Pydantic, creates a task with structured output expectations, and handles the parsing of the structured output.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/cloud/implementation.mdx#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport json\nimport os\nimport time\nimport requests\nfrom pydantic import BaseModel\nfrom typing import List\n\n\nAPI_KEY = os.getenv(\"API_KEY\")\nBASE_URL = 'https://api.browser-use.com/api/v1'\nHEADERS = {\n    \"Authorization\": f\"Bearer {API_KEY}\",\n    \"Content-Type\": \"application/json\"\n}\n\n\n# Define output schema using Pydantic\nclass SocialMediaCompany(BaseModel):\n    name: str\n    market_cap: float\n    headquarters: str\n    founded_year: int\n\n\nclass SocialMediaCompanies(BaseModel):\n    companies: List[SocialMediaCompany]\n\n\ndef create_structured_task(instructions: str, schema: dict):\n    \"\"\"Create a task that expects structured output\"\"\"\n    payload = {\n        \"task\": instructions,\n        \"structured_output_json\": json.dumps(schema)\n    }\n    response = requests.post(f\"{BASE_URL}/run-task\", headers=HEADERS, json=payload)\n    response.raise_for_status()\n    return response.json()[\"id\"]\n\n\ndef wait_for_task_completion(task_id: str, poll_interval: int = 5):\n    \"\"\"Poll task status until it completes\"\"\"\n    while True:\n        response = requests.get(f\"{BASE_URL}/task/{task_id}/status\", headers=HEADERS)\n        response.raise_for_status()\n        status = response.json()\n        if status == \"finished\":\n            break\n        elif status in [\"failed\", \"stopped\"]:\n            raise RuntimeError(f\"Task {task_id} ended with status: {status}\")\n        print(\"Waiting for task to finish...\")\n        time.sleep(poll_interval)\n\n\ndef fetch_task_output(task_id: str):\n    \"\"\"Retrieve the final task result\"\"\"\n    response = requests.get(f\"{BASE_URL}/task/{task_id}\", headers=HEADERS)\n    response.raise_for_status()\n    return response.json()[\"output\"]\n\n\ndef main():\n    schema = SocialMediaCompanies.model_json_schema()\n    task_id = create_structured_task(\n        \"Get me the top social media companies by market cap\",\n        schema\n    )\n    print(f\"Task created with ID: {task_id}\")\n\n    wait_for_task_completion(task_id)\n    print(\"Task completed!\")\n\n    output = fetch_task_output(task_id)\n    print(\"Raw output:\", output)\n\n    try:\n        parsed = SocialMediaCompanies.model_validate_json(output)\n        print(\"Parsed output:\")\n        print(parsed)\n    except Exception as e:\n        print(f\"Failed to parse structured output: {e}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n----------------------------------------\n\nTITLE: Configuring and Connecting to Real Chrome Browser in Python\nDESCRIPTION: This code demonstrates how to set up a connection to your real Chrome browser by specifying the path to the Chrome executable. It configures a Browser instance with the appropriate path for your operating system (with examples for macOS, Windows, and Linux), creates an Agent with this browser, and runs a task.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/real-browser.mdx#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use import Agent, Browser, BrowserConfig\nfrom langchain_openai import ChatOpenAI\nimport asyncio\n# Configure the browser to connect to your Chrome instance\nbrowser = Browser(\n    config=BrowserConfig(\n        # Specify the path to your Chrome executable\n        browser_binary_path='/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',  # macOS path\n        # For Windows, typically: 'C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe'\n        # For Linux, typically: '/usr/bin/google-chrome'\n    )\n)\n\n# Create the agent with your configured browser\nagent = Agent(\n    task=\"Your task here\",\n    llm=ChatOpenAI(model='gpt-4o'),\n    browser=browser,\n)\n\nasync def main():\n    await agent.run()\n\n    input('Press Enter to close the browser...')\n    await browser.close()\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Client Component for Agent Activity Recording (client.py)\nDESCRIPTION: Browser-Use agent client that implements a recording hook to capture activity at each step. Collects HTML, screenshots, URL history, model thoughts, outputs, actions, and extracted content, then sends them to the recording API server.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/hooks.mdx#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\n#\n# Client to record and save Browser-Use activity.\n# Save this code to client.py and run with `python client.py`\n#\n\nimport asyncio\nimport requests\nfrom dotenv import load_dotenv\nfrom pyobjtojson import obj_to_json\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\n\n# Load environment variables (for API keys)\nload_dotenv()\n\n\ndef send_agent_history_step(data):\n    \"\"\"Send the agent step data to the recording API\"\"\"\n    url = \"http://127.0.0.1:9000/post_agent_history_step\"\n    response = requests.post(url, json=data)\n    return response.json()\n\n\nasync def record_activity(agent_obj):\n    \"\"\"Hook function that captures and records agent activity at each step\"\"\"\n    website_html = None\n    website_screenshot = None\n    urls_json_last_elem = None\n    model_thoughts_last_elem = None\n    model_outputs_json_last_elem = None\n    model_actions_json_last_elem = None\n    extracted_content_json_last_elem = None\n\n    print('--- ON_STEP_START HOOK ---')\n    \n    # Capture current page state\n    website_html = await agent_obj.browser_context.get_page_html()\n    website_screenshot = await agent_obj.browser_context.take_screenshot()\n\n    # Make sure we have state history\n    if hasattr(agent_obj, \"state\"):\n        history = agent_obj.state.history\n    else:\n        history = None\n        print(\"Warning: Agent has no state history\")\n        return\n\n    # Process model thoughts\n    model_thoughts = obj_to_json(\n        obj=history.model_thoughts(),\n        check_circular=False\n    )\n    if len(model_thoughts) > 0:\n        model_thoughts_last_elem = model_thoughts[-1]\n\n    # Process model outputs\n    model_outputs = agent_obj.state.history.model_outputs()\n    model_outputs_json = obj_to_json(\n        obj=model_outputs,\n        check_circular=False\n    )\n    if len(model_outputs_json) > 0:\n        model_outputs_json_last_elem = model_outputs_json[-1]\n\n    # Process model actions\n    model_actions = agent_obj.state.history.model_actions()\n    model_actions_json = obj_to_json(\n        obj=model_actions,\n        check_circular=False\n    )\n    if len(model_actions_json) > 0:\n        model_actions_json_last_elem = model_actions_json[-1]\n\n    # Process extracted content\n    extracted_content = agent_obj.state.history.extracted_content()\n    extracted_content_json = obj_to_json(\n        obj=extracted_content,\n        check_circular=False\n    )\n    if len(extracted_content_json) > 0:\n        extracted_content_json_last_elem = extracted_content_json[-1]\n\n    # Process URLs\n    urls = agent_obj.state.history.urls()\n    urls_json = obj_to_json(\n        obj=urls,\n        check_circular=False\n    )\n    if len(urls_json) > 0:\n        urls_json_last_elem = urls_json[-1]\n\n    # Create a summary of all data for this step\n    model_step_summary = {\n        \"website_html\": website_html,\n        \"website_screenshot\": website_screenshot,\n        \"url\": urls_json_last_elem,\n        \"model_thoughts\": model_thoughts_last_elem,\n        \"model_outputs\": model_outputs_json_last_elem,\n        \"model_actions\": model_actions_json_last_elem,\n        \"extracted_content\": extracted_content_json_last_elem\n    }\n\n    print(\"--- MODEL STEP SUMMARY ---\")\n    print(f\"URL: {urls_json_last_elem}\")\n    \n    # Send data to the API\n    result = send_agent_history_step(data=model_step_summary)\n    print(f\"Recording API response: {result}\")\n\n\nasync def run_agent():\n    \"\"\"Run the Browser-Use agent with the recording hook\"\"\"\n    agent = Agent(\n        task=\"Compare the price of gpt-4o and DeepSeek-V3\",\n        llm=ChatOpenAI(model=\"gpt-4o\"),\n    )\n    \n    try:\n        print(\"Starting Browser-Use agent with recording hook\")\n        await agent.run(\n            on_step_start=record_activity,\n            max_steps=30\n        )\n    except Exception as e:\n        print(f\"Error running agent: {e}\")\n\n\nif __name__ == \"__main__\":\n    # Check if API is running\n    try:\n        requests.get(\"http://127.0.0.1:9000\")\n        print(\"Recording API is available\")\n    except:\n        print(\"Warning: Recording API may not be running. Start api.py first.\")\n    \n    # Run the agent\n    asyncio.run(run_agent())\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Output Format with Pydantic for Browser Use in Python\nDESCRIPTION: This code snippet shows how to define a custom output format using Pydantic models and use it with a Controller and Agent to fetch and structure data from Hacker News. It defines Post and Posts models, sets up a controller with the custom output model, and runs an agent to fetch and parse the first 5 'Show HN' posts.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/output-format.mdx#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n# Define the output format as a Pydantic model\nclass Post(BaseModel):\n\tpost_title: str\n\tpost_url: str\n\tnum_comments: int\n\thours_since_post: int\n\n\nclass Posts(BaseModel):\n\tposts: List[Post]\n\n\ncontroller = Controller(output_model=Posts)\n\n\nasync def main():\n\ttask = 'Go to hackernews show hn and give me the first  5 posts'\n\tmodel = ChatOpenAI(model='gpt-4o')\n\tagent = Agent(task=task, llm=model, controller=controller)\n\n\thistory = await agent.run()\n\n\tresult = history.final_result()\n\tif result:\n\t\tparsed: Posts = Posts.model_validate_json(result)\n\n\t\tfor post in parsed.posts:\n\t\t\tprint('\\n--------------------------------')\n\t\t\tprint(f'Title:            {post.post_title}')\n\t\t\tprint(f'URL:              {post.post_url}')\n\t\t\tprint(f'Comments:         {post.num_comments}')\n\t\t\tprint(f'Hours since post: {post.hours_since_post}')\n\telse:\n\t\tprint('No result')\n\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Accessing Agent Data in Hooks (Python)\nDESCRIPTION: Demonstrates how to access various data points from the agent instance within hooks. This includes model thoughts, outputs, actions, extracted content, visited URLs, and current page information.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/hooks.mdx#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nagent.state.history.model_thoughts()\nagent.state.history.model_outputs()\nagent.state.history.model_actions()\nagent.state.history.extracted_content()\nagent.state.history.urls()\nagent.browser_context.get_page_html()\nagent.browser_context.take_screenshot()\n```\n\n----------------------------------------\n\nTITLE: Initializing Browser with Basic Configuration in Python\nDESCRIPTION: Creates a basic browser configuration, initializes a Browser instance with the config, and sets up an Agent with the browser. Controls headless mode and security features.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/browser-settings.mdx#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use import BrowserConfig\n\n# Basic configuration\nconfig = BrowserConfig(\n    headless=False,\n    disable_security=False\n)\n\nbrowser = Browser(config=config)\n\nagent = Agent(\n    browser=browser,\n    # ...\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Browser-Aware Functions in browser-use\nDESCRIPTION: Demonstrates how to create an asynchronous function that interacts with the browser. By including a 'browser' parameter, the function gains access to the browser instance for performing web operations.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/custom-functions.mdx#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use import Browser, Controller, ActionResult\n\ncontroller = Controller()\n@controller.action('Open website')\nasync def open_website(url: str, browser: Browser):\n    page = await browser.get_current_page()\n    await page.goto(url)\n    return ActionResult(extracted_content='Website opened')\n```\n\n----------------------------------------\n\nTITLE: Basic Example of Using Agent Lifecycle Hooks in Python\nDESCRIPTION: Demonstrates how to implement a step hook function that monitors URL changes and pauses the agent on specific conditions. The hook provides access to all agent state and methods, allowing for custom behavior integration.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/hooks.mdx#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use import Agent\nfrom langchain_openai import ChatOpenAI\n\nasync def my_step_hook(agent):\n    # inside a hook you can access all the state and methods under the Agent object:\n    #   agent.settings, agent.state, agent.task\n    #   agent.controller, agent.llm, agent.browser, agent.browser_context\n    #   agent.pause(), agent.resume(), agent.add_new_task(...), etc.\n    \n    current_page = await agent.browser_context.get_current_page()\n    \n    visit_log = agent.state.history.urls()\n    current_url = current_page.url\n    previous_url = visit_log[-2] if len(visit_log) >= 2 else None\n    print(f\"Agent was last on URL: {previous_url} and is now on {current_url}\")\n    \n    if 'completed' in current_url:\n        agent.pause()\n        Path('result.txt').write_text(await current_page.content()) \n        input('Saved \"completed\" page content to result.txt, press [Enter] to resume...')\n        agent.resume()\n    \nagent = Agent(\n    task=\"Search for the latest news about AI\",\n    llm=ChatOpenAI(model=\"gpt-4o\"),\n)\n\nawait agent.run(\n    on_step_start=my_step_hook,\n    # on_step_end=...\n    max_steps=10\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring DeepSeek-V3 Model with Browser Use Agent\nDESCRIPTION: Demonstrates how to use DeepSeek-V3 model with Browser Use Agent. This model is noted for its low price, no rate limits, open-source nature, and good performance. Requires the DEEPSEEK_API_KEY environment variable.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/supported-models.mdx#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\nfrom pydantic import SecretStr\nfrom dotenv import load_dotenv\n\nload_dotenv()\napi_key = os.getenv(\"DEEPSEEK_API_KEY\")\n\n# Initialize the model\nllm=ChatOpenAI(base_url='https://api.deepseek.com/v1', model='deepseek-chat', api_key=SecretStr(api_key))\n\n# Create agent with the model\nagent = Agent(\n    task=\"Your task here\",\n    llm=llm,\n    use_vision=False\n)\n```\n\nLANGUAGE: bash\nCODE:\n```\nDEEPSEEK_API_KEY=\n```\n\n----------------------------------------\n\nTITLE: Task Control with Pause/Resume in Browser Use API (Python)\nDESCRIPTION: This snippet demonstrates how to implement task control with pause and resume functionality using the Browser Use API. It creates a task, pauses it after 5 seconds, waits for user input, and then resumes the task.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/cloud/implementation.mdx#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef control_task():\n    # Create a new task\n    task_id = create_task(\"Go to google.com and search for Browser Use\")\n\n    # Wait for 5 seconds\n    time.sleep(5)\n\n    # Pause the task\n    requests.put(f\"{BASE_URL}/pause-task?task_id={task_id}\", headers=HEADERS)\n    print(\"Task paused! Check the live preview.\")\n\n    # Wait for user input\n    input(\"Press Enter to resume...\")\n\n    # Resume the task\n    requests.put(f\"{BASE_URL}/resume-task?task_id={task_id}\", headers=HEADERS)\n\n    # Wait for completion\n    result = wait_for_completion(task_id)\n    print(f\"Task completed with output: {result['output']}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Anthropic Claude Model with Browser Use Agent\nDESCRIPTION: Shows how to integrate Anthropic's Claude model with Browser Use Agent. Includes a timeout parameter that can be increased for complex tasks. Requires the ANTHROPIC_API_KEY environment variable.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/supported-models.mdx#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_anthropic import ChatAnthropic\nfrom browser_use import Agent\n\n# Initialize the model\nllm = ChatAnthropic(\n    model_name=\"claude-3-5-sonnet-20240620\",\n    temperature=0.0,\n    timeout=100, # Increase for complex tasks\n)\n\n# Create agent with the model\nagent = Agent(\n    task=\"Your task here\",\n    llm=llm\n)\n```\n\nLANGUAGE: bash\nCODE:\n```\nANTHROPIC_API_KEY=\n```\n\n----------------------------------------\n\nTITLE: Configuring Memory Management in Browser Use Agent\nDESCRIPTION: Sets up the procedural memory system using Mem0 to optimize context window usage during long tasks. This system automatically summarizes the agent's conversation history at regular intervals.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use.agent.memory import MemoryConfig\n\nagent = Agent(\n    task=\"your task\",\n    llm=llm,\n    enable_memory=True,\n    memory_config=MemoryConfig(\n        agent_id=\"my_custom_agent\",\n        memory_interval=15\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Browser Use Agent Behavior\nDESCRIPTION: Sets advanced behavior options for the agent including custom controller for tool calling, vision capabilities, and conversation logging. These parameters control how the agent interacts with the web environment.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nagent = Agent(\n    task=\"your task\",\n    llm=llm,\n    controller=custom_controller,  # For custom tool calling\n    use_vision=True,              # Enable vision capabilities\n    save_conversation_path=\"logs/conversation\"  # Save chat logs\n)\n```\n\n----------------------------------------\n\nTITLE: Advanced Memory Configuration with MemoryConfig in Browser Use\nDESCRIPTION: Creates a detailed memory configuration using the MemoryConfig Pydantic model. This provides type-safe configuration of the memory system including embedding settings for retrieval.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use.agent.memory import MemoryConfig\n\nagent = Agent(\n    task=task_description,\n    llm=llm,\n    memory_config=MemoryConfig(\n        agent_id=\"my_agent\",\n        memory_interval=15,\n        embedder_provider=\"openai\",\n        embedder_model=\"text-embedding-3-large\",\n        embedder_dims=1536,\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Using a Separate Planner Model with Browser Use Agent\nDESCRIPTION: Configures the agent to use a separate model for high-level planning. This can reduce costs by using a smaller model for planning while using a more powerful model for execution.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\n\n# Initialize models\nllm = ChatOpenAI(model='gpt-4o')\nplanner_llm = ChatOpenAI(model='o3-mini')\n\nagent = Agent(\n    task=\"your task\",\n    llm=llm,\n    planner_llm=planner_llm,           # Separate model for planning\n    use_vision_for_planner=False,      # Disable vision for planner\n    planner_interval=4                 # Plan every 4 steps\n)\n```\n\n----------------------------------------\n\nTITLE: Registering Basic Functions in browser-use\nDESCRIPTION: Demonstrates how to register a basic synchronous function as an action in the browser-use Controller. This example shows a function that asks the user for information and returns the answer as an ActionResult.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/custom-functions.mdx#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use import Controller, ActionResult\n# Initialize the controller\ncontroller = Controller()\n\n@controller.action('Ask user for information')\ndef ask_human(question: str) -> str:\n    answer = input(f'\\n{question}\\nInput: ')\n    return ActionResult(extracted_content=answer)\n```\n\n----------------------------------------\n\nTITLE: Configuring Browser Use Agent with Message Context\nDESCRIPTION: Shows how to provide additional context to help the LLM understand the task better. This can be used to clarify task requirements or provide background information.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\n\nagent = Agent(\n    task=\"your task\",\n    message_context=\"Additional information about the task\",\n    llm = ChatOpenAI(model='gpt-4o')\n)\n```\n\n----------------------------------------\n\nTITLE: Connecting to External Browser Provider via WebSocket in Python\nDESCRIPTION: Sets up a BrowserConfig to connect to an external browser provider using a WebSocket URL. This approach enhances reliability and proxy capabilities for web scraping tasks.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/browser-settings.mdx#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nconfig = BrowserConfig(\n    wss_url=\"wss://your-browser-provider.com/ws\"\n)\n```\n\n----------------------------------------\n\nTITLE: Using One Controller with Multiple Agents in browser-use\nDESCRIPTION: Shows how to use a single Controller with multiple Agent instances. This allows for code reuse across different agents that may perform different tasks but need the same set of actions.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/custom-functions.mdx#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncontroller = Controller()\n\n# ... register actions to the controller\n\nagent = Agent(\n    task=\"Go to website X and find the latest news\",\n    llm=llm,\n    controller=controller\n)\n\n# Run the agent\nawait agent.run()\n\nagent2 = Agent(\n    task=\"Go to website Y and find the latest news\",\n    llm=llm,\n    controller=controller\n)\n\nawait agent2.run()\n```\n\n----------------------------------------\n\nTITLE: Accessing Browser Use Agent History\nDESCRIPTION: Shows how to access the execution history after running an agent. The AgentHistoryList object provides methods to retrieve visited URLs, screenshots, action names, extracted content, and errors.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example of accessing history\nhistory = await agent.run()\n\n# Access (some) useful information\nhistory.urls()              # List of visited URLs\nhistory.screenshots()       # List of screenshot paths\nhistory.action_names()      # Names of executed actions\nhistory.extracted_content() # Content extracted during execution\nhistory.errors()           # Any errors that occurred\nhistory.model_actions()     # All actions with their parameters\n```\n\n----------------------------------------\n\nTITLE: Passing Controller to Agent in browser-use\nDESCRIPTION: Shows how to pass a Controller with registered actions to the Agent constructor. This allows the Agent to use the custom functions registered with the Controller.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/custom-functions.mdx#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# ... then pass controller to the agent\nagent = Agent(\n    task=task,\n    llm=llm,\n    controller=controller\n)\n```\n\n----------------------------------------\n\nTITLE: Reusing Existing Browser Instance with Browser Use Agent\nDESCRIPTION: Demonstrates how to reuse an existing browser instance across multiple agent runs. This approach requires manually closing the browser after all operations are complete.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use import Agent, Browser\nfrom browser_use.browser.context import BrowserContext\n\n# Reuse existing browser\nbrowser = Browser()\nagent = Agent(\n    task=task1,\n    llm=llm,\n    browser=browser  # Browser instance will be reused\n)\n\nawait agent.run()\n\n# Manually close the browser\nawait browser.close()\n```\n\n----------------------------------------\n\nTITLE: Running Initial Actions without LLM in Browser Use\nDESCRIPTION: Configures the agent to perform a sequence of predefined actions before involving the LLM. Each action is defined as a dictionary with the action name as the key and parameters as the value.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ninitial_actions = [\n\t{'open_tab': {'url': 'https://www.google.com'}},\n\t{'open_tab': {'url': 'https://en.wikipedia.org/wiki/Randomness'}},\n\t{'scroll_down': {'amount': 1000}},\n]\nagent = Agent(\n\ttask='What theories are displayed on the page?',\n\tinitial_actions=initial_actions,\n\tllm=llm,\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Laminar with Browser Use Agent in Python\nDESCRIPTION: Example Python code showing how to initialize Laminar at the top of a project to automatically trace Browser Use and browser sessions. The code demonstrates creating an agent that opens Google and searches for 'Laminar AI'.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/observability.mdx#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\nimport asyncio\n\nfrom lmnr import Laminar\n# this line auto-instruments Browser Use and any browser you use (local or remote)\nLaminar.initialize(project_api_key=\"...\") # you can also pass project api key here\n\nasync def main():\n    agent = Agent(\n        task=\"open google, search Laminar AI\",\n        llm=ChatOpenAI(model=\"gpt-4o-mini\"),\n    )\n    result = await agent.run()\n    print(result)\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Setting Up Browser Context Configuration in Python\nDESCRIPTION: Creates a detailed BrowserContextConfig with custom settings for cookies, page load behavior, window size, locale, user agent, and domain restrictions. Shows how to initialize a browser context with these settings and create an agent using that context.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/browser-settings.mdx#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use.browser.context import BrowserContextConfig\n\nconfig = BrowserContextConfig(\n    cookies_file=\"path/to/cookies.json\",\n    wait_for_network_idle_page_load_time=3.0,\n    browser_window_size={'width': 1280, 'height': 1100},\n    locale='en-US',\n    user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36',\n    highlight_elements=True,\n    viewport_expansion=500,\n    allowed_domains=['google.com', 'wikipedia.org'],\n)\n\nbrowser = Browser()\ncontext = BrowserContext(browser=browser, config=config)\n\n\nasync def run_search():\n\tagent = Agent(\n\t\tbrowser_context=context,\n\t\ttask='Your task',\n\t\tllm=llm)\n```\n\n----------------------------------------\n\nTITLE: Using Persistent Browser Context with Browser Use Agent\nDESCRIPTION: Shows how to use a specific browser context for maintaining persistent sessions across multiple agent operations. This allows sharing cookies, local storage, and other session data between agents.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom browser_use import Agent, Browser\nfrom patchright.async_api import BrowserContext\n\n# Use specific browser context (preferred method)\nasync with await browser.new_context() as context:\n    agent = Agent(\n        task=task2,\n        llm=llm,\n        browser_context=context  # Use persistent context\n    )\n\n    # Run the agent\n    await agent.run()\n\n    # Pass the context to the next agent\n    next_agent = Agent(\n        task=task2,\n        llm=llm,\n        browser_context=context\n    )\n\n    ...\n\nawait browser.close()\n```\n\n----------------------------------------\n\nTITLE: Using Pydantic Models for Structured Parameters in browser-use\nDESCRIPTION: Shows how to use Pydantic models to define structured parameter schemas for complex actions. This approach provides better type safety and validation for function parameters.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/custom-functions.mdx#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\nfrom typing import Optional\nfrom browser_use import Controller, ActionResult, Browser\n\ncontroller = Controller()\n\nclass JobDetails(BaseModel):\n    title: str\n    company: str\n    job_link: str\n    salary: Optional[str] = None\n\n@controller.action(\n    'Save job details which you found on page',\n    param_model=JobDetails\n)\nasync def save_job(params: JobDetails, browser: Browser):\n    print(f\"Saving job: {params.title} at {params.company}\")\n\n    # Access browser if needed\n    page = browser.get_current_page()\n    await page.goto(params.job_link)\n```\n\n----------------------------------------\n\nTITLE: Configuring Novita AI Model with Browser Use Agent\nDESCRIPTION: Shows how to use Novita AI models with Browser Use Agent. Novita AI offers a wide range of models. You should choose a model that supports function calling. Requires the NOVITA_API_KEY environment variable.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/supported-models.mdx#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\nfrom pydantic import SecretStr\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\napi_key = os.getenv(\"NOVITA_API_KEY\")\n\n# Initialize the model\nllm = ChatOpenAI(base_url='https://api.novita.ai/v3/openai', model='deepseek/deepseek-v3-0324', api_key=SecretStr(api_key))\n\n# Create agent with the model\nagent = Agent(\n    task=\"Your task here\",\n    llm=llm,\n    use_vision=False\n)\n```\n\nLANGUAGE: bash\nCODE:\n```\nNOVITA_API_KEY=\n```\n\n----------------------------------------\n\nTITLE: Setting up Azure OpenAI with Browser Use Agent\nDESCRIPTION: Demonstrates configuration for Azure OpenAI service with Browser Use Agent. Utilizes SecretStr for secure API key handling and requires both AZURE_OPENAI_ENDPOINT and AZURE_OPENAI_KEY environment variables.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/supported-models.mdx#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import AzureChatOpenAI\nfrom browser_use import Agent\nfrom pydantic import SecretStr\nimport os\n\n# Initialize the model\nllm = AzureChatOpenAI(\n    model=\"gpt-4o\",\n    api_version='2024-10-21',\n    azure_endpoint=os.getenv('AZURE_OPENAI_ENDPOINT', ''),\n    api_key=SecretStr(os.getenv('AZURE_OPENAI_KEY', '')),\n)\n\n# Create agent with the model\nagent = Agent(\n    task=\"Your task here\",\n    llm=llm\n)\n```\n\nLANGUAGE: bash\nCODE:\n```\nAZURE_OPENAI_ENDPOINT=https://your-endpoint.openai.azure.com/\nAZURE_OPENAI_KEY=\n```\n\n----------------------------------------\n\nTITLE: Async Browser Agent Setup and Execution\nDESCRIPTION: Complete setup of browser agent with async execution for web querying about Langgraph.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/notebook/agent_browsing.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use import Agent, Browser, BrowserConfig\n\nconfig = BrowserConfig(\n\theadless=True,  # Run in headless mode\n\t# disable_security=True  # Uncomment if you want to disable security\n)\n\nbrowser = Browser(config=config)\n\n\nasync def main():\n\tagent = Agent(\n\t\ttask='What is Langgraph',\n\t\tllm=llm,  # Replace with your LLM configuration\n\t\tbrowser=browser,\n\t\tgenerate_gif=False,  # Disable GIF generation\n\t)\n\n\tresult = await agent.run()\n\n\tfor action in result.action_results():\n\t\tprint(action.extracted_content, end='\\r', flush=True)\n\t\tprint('\\n\\n')\n\n\tawait browser.close()\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing Google Gemini Model with Browser Use Agent\nDESCRIPTION: Shows how to use Google's Gemini model with Browser Use Agent. Uses dotenv to load environment variables. Requires the GEMINI_API_KEY environment variable.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/supported-models.mdx#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_google_genai import ChatGoogleGenerativeAI\nfrom browser_use import Agent\nfrom dotenv import load_dotenv\n\n# Read GEMINI_API_KEY into env\nload_dotenv()\n\n# Initialize the model\nllm = ChatGoogleGenerativeAI(model='gemini-2.0-flash-exp')\n\n# Create agent with the model\nagent = Agent(\n    task=\"Your task here\",\n    llm=llm\n)\n```\n\nLANGUAGE: bash\nCODE:\n```\nGEMINI_API_KEY=\n```\n\n----------------------------------------\n\nTITLE: Browser Agent Reuse Example\nDESCRIPTION: Example of reusing browser instance for multiple queries with simplified agent setup.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/notebook/agent_browsing.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nfrom langchain_openai import ChatOpenAI\n\nfrom browser_use import Browser, BrowserConfig\n\nconfig = BrowserConfig(\n\theadless=True,\n)\nbrowser = Browser(config=config)\nagent = Agent(\n\ttask='what is langchain',\n\tllm=llm,\n\tbrowser=browser,\n\tgenerate_gif=False,\n)\n\nresult = await agent.run()\nprint(result)\nawait browser.close()\n```\n\n----------------------------------------\n\nTITLE: Connecting to Chrome DevTools Protocol (CDP) in Python\nDESCRIPTION: Creates a configuration to connect to a Chrome instance using Chrome DevTools Protocol. Useful for connecting to local or cloud Chrome instances, including tools like headless-shell or browserless.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/browser-settings.mdx#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nconfig = BrowserConfig(\n    cdp_url=\"http://localhost:9222\"\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Python Client from OpenAPI Spec\nDESCRIPTION: Commands to generate a type-safe Python client library using openapi-python-client generator. Creates a Python package with full type hints, modern dataclasses, and async support.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/cloud/quickstart.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install the generator\npipx install openapi-python-client --include-deps\n\n# Generate the client\nopenapi-python-client generate --url http://api.browser-use.com/openapi.json\n```\n\n----------------------------------------\n\nTITLE: Connecting to Local Chrome Installation in Python\nDESCRIPTION: Configures browser-use to connect to an existing Chrome installation by specifying the binary path. This allows access to saved states and cookies from the local browser.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/browser-settings.mdx#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nconfig = BrowserConfig(\n    browser_binary_path=\"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\"\n)\n```\n\n----------------------------------------\n\nTITLE: Extending Default System Prompt in Python\nDESCRIPTION: Demonstrates how to extend the default system prompt with additional instructions. This example adds a rule to always visit Wikipedia first.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/system-prompt.mdx#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nextend_system_message = \"\"\"\nREMEMBER the most important RULE:\nALWAYS open first a new tab and go first to url wikipedia.com no matter the task!!!\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Server Component for Agent Activity Recording (api.py)\nDESCRIPTION: FastAPI server implementation that receives and stores agent activity data. Includes endpoints for recording step history and functionality to save screenshots. Designed to work with the Browser-Use client component.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/hooks.mdx#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#!/usr/bin/env python3\n\n#\n# FastAPI API to record and save Browser-Use activity data.\n# Save this code to api.py and run with `python api.py`\n# \n\nimport json\nimport base64\nfrom pathlib import Path\n\nfrom fastapi import FastAPI, Request\nimport prettyprinter\nimport uvicorn\n\nprettyprinter.install_extras()\n\n# Utility function to save screenshots\ndef b64_to_png(b64_string: str, output_file):\n    \"\"\"\n    Convert a Base64-encoded string to a PNG file.\n    \n    :param b64_string: A string containing Base64-encoded data\n    :param output_file: The path to the output PNG file\n    \"\"\"\n    with open(output_file, \"wb\") as f:\n        f.write(base64.b64decode(b64_string))\n\n# Initialize FastAPI app\napp = FastAPI()\n\n\n@app.post(\"/post_agent_history_step\")\nasync def post_agent_history_step(request: Request):\n    data = await request.json()\n    prettyprinter.cpprint(data)\n\n    # Ensure the \"recordings\" folder exists using pathlib\n    recordings_folder = Path(\"recordings\")\n    recordings_folder.mkdir(exist_ok=True)\n\n    # Determine the next file number by examining existing .json files\n    existing_numbers = []\n    for item in recordings_folder.iterdir():\n        if item.is_file() and item.suffix == \".json\":\n            try:\n                file_num = int(item.stem)\n                existing_numbers.append(file_num)\n            except ValueError:\n                # In case the file name isn't just a number\n                pass\n\n    if existing_numbers:\n        next_number = max(existing_numbers) + 1\n    else:\n        next_number = 1\n\n    # Construct the file path\n    file_path = recordings_folder / f\"{next_number}.json\"\n\n    # Save the JSON data to the file\n    with file_path.open(\"w\") as f:\n        json.dump(data, f, indent=2)\n\n    # Optionally save screenshot if needed\n    # if \"website_screenshot\" in data and data[\"website_screenshot\"]:\n    #     screenshot_folder = Path(\"screenshots\")\n    #     screenshot_folder.mkdir(exist_ok=True)\n    #     b64_to_png(data[\"website_screenshot\"], screenshot_folder / f\"{next_number}.png\")\n\n    return {\"status\": \"ok\", \"message\": f\"Saved to {file_path}\"}\n\nif __name__ == \"__main__\":\n    print(\"Starting Browser-Use recording API on http://0.0.0.0:9000\")\n    uvicorn.run(app, host=\"0.0.0.0\", port=9000)\n```\n\n----------------------------------------\n\nTITLE: Overriding Default System Prompt in Python\nDESCRIPTION: Shows how to completely override the default system prompt with custom instructions and create an agent with the custom prompt. This approach requires careful testing to maintain agent reliability.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/system-prompt.mdx#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Define your complete custom prompt\noverride_system_message = \"\"\"\nYou are an AI agent that helps users with web browsing tasks.\n\n[Your complete custom instructions here...]\n\"\"\"\n\n# Create agent with custom system prompt\nagent = Agent(\n    task=\"Your task here\",\n    llm=ChatOpenAI(model='gpt-4'),\n    override_system_message=override_system_message\n)\n```\n\n----------------------------------------\n\nTITLE: Playwright Browser Installation\nDESCRIPTION: Installing browser binaries required by Playwright.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/notebook/agent_browsing.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n!playwright install\n```\n\n----------------------------------------\n\nTITLE: Implementing Ollama Local Models with Browser Use Agent\nDESCRIPTION: Demonstrates how to use Ollama for local models with Browser Use Agent. Requires downloading Ollama, pulling a model that supports tool-calling, and starting the Ollama service. No environment variables needed.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/supported-models.mdx#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_ollama import ChatOllama\nfrom browser_use import Agent\nfrom pydantic import SecretStr\n\n\n# Initialize the model\nllm=ChatOllama(model=\"qwen2.5\", num_ctx=32000)\n\n# Create agent with the model\nagent = Agent(\n    task=\"Your task here\",\n    llm=llm\n)\n```\n\n----------------------------------------\n\nTITLE: Extending Planner System Prompt in Python\nDESCRIPTION: Demonstrates how to customize the planning agent's behavior by extending its system prompt and initializing an agent with specific LLM configurations.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/system-prompt.mdx#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nextend_planner_system_message = \"\"\"\nPRIORITIZE gathering information before taking any action.\nAlways suggest exploring multiple options before making a decision.\n\"\"\"\n\n# Create agent with extended planner system prompt\nllm = ChatOpenAI(model='gpt-4o')\nplanner_llm = ChatOpenAI(model='gpt-4o-mini')\n\nagent = Agent(\n\ttask=\"Your task here\",\n\tllm=llm,\n\tplanner_llm=planner_llm,\n\textend_planner_system_message=extend_planner_system_message\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Browser Agent Task with cURL\nDESCRIPTION: Example of creating a new browser automation task using the Browser Use Cloud API via a POST request. The task is specified in natural language and requires an API key for authentication.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/cloud/quickstart.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST https://api.browser-use.com/api/v1/run-task \\\n  -H \"Authorization: Bearer your_api_key_here\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"task\": \"Go to google.com and search for Browser Use\"\n  }'\n```\n\n----------------------------------------\n\nTITLE: Excluding Functions from Controller in browser-use\nDESCRIPTION: Demonstrates how to exclude specific actions from being used by the agent. This allows for more control over which functions the agent can access and use.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/custom-functions.mdx#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncontroller = Controller(exclude_actions=['open_tab', 'search_google'])\n```\n\n----------------------------------------\n\nTITLE: Setting up DeepSeek-R1 Model with Browser Use Agent\nDESCRIPTION: Shows how to use DeepSeek-R1 model with Browser Use Agent. This model doesn't support vision and is still being tested, with more functionality planned. Requires the DEEPSEEK_API_KEY environment variable.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/supported-models.mdx#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\nfrom pydantic import SecretStr\nfrom dotenv import load_dotenv\n\nload_dotenv()\napi_key = os.getenv(\"DEEPSEEK_API_KEY\")\n\n# Initialize the model\nllm=ChatOpenAI(base_url='https://api.deepseek.com/v1', model='deepseek-reasoner', api_key=SecretStr(api_key))\n\n# Create agent with the model\nagent = Agent(\n    task=\"Your task here\",\n    llm=llm,\n    use_vision=False\n)\n```\n\nLANGUAGE: bash\nCODE:\n```\nDEEPSEEK_API_KEY=\n```\n\n----------------------------------------\n\nTITLE: Disabling Memory in Agent Configuration - Python\nDESCRIPTION: Example showing how to disable the memory system in an agent by setting enable_memory to False during initialization. This can be useful for debugging or short tasks that don't require conversation history management.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/agent-settings.mdx#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nagent = Agent(\n    task=\"your task\",\n    llm=llm,\n    enable_memory=False\n)\n```\n\n----------------------------------------\n\nTITLE: Setting up X AI (Grok) Model with Browser Use Agent\nDESCRIPTION: Demonstrates how to use X AI (Grok) models with Browser Use Agent. X AI offers various models, and you should select one that supports function calling. Requires the GROK_API_KEY environment variable.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/supported-models.mdx#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_openai import ChatOpenAI\nfrom browser_use import Agent\nfrom pydantic import SecretStr\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\napi_key = os.getenv(\"GROK_API_KEY\")\n\n# Initialize the model\nllm = ChatOpenAI(\n    base_url='https://api.x.ai/v1',\n    model='grok-3-beta',\n    api_key=SecretStr(api_key)\n)\n\n# Create agent with the model\nagent = Agent(\n    task=\"Your task here\",\n    llm=llm,\n    use_vision=False\n)\n```\n\nLANGUAGE: bash\nCODE:\n```\nGROK_API_KEY=\n```\n\n----------------------------------------\n\nTITLE: Installing Laminar and Setting API Key in Bash\nDESCRIPTION: Commands to install the Laminar package and set up the required environment variable for project API key. This is the first step needed to integrate Laminar with Browser Use.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/observability.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install 'lmnr[all]'\nexport LMNR_PROJECT_API_KEY=<your-project-api-key>\n```\n\n----------------------------------------\n\nTITLE: Installing browser-use with pip\nDESCRIPTION: Basic installation command for the browser-use package, requiring Python 3.11 or higher.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install browser-use\n```\n\n----------------------------------------\n\nTITLE: Setting up Python Virtual Environment with uv\nDESCRIPTION: Creates a Python virtual environment using uv tool, specifying Python 3.11 which is required for Browser Use.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/quickstart.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nuv venv --python 3.11\n```\n\n----------------------------------------\n\nTITLE: Setting up LLM API Keys in .env File\nDESCRIPTION: Example of how to configure API keys for OpenAI and Anthropic in a .env file, which is necessary for using LLM models with Browser Use.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/quickstart.mdx#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nOPENAI_API_KEY=\nANTHROPIC_API_KEY=\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating a Python Virtual Environment with UV\nDESCRIPTION: Commands to create a Python 3.11 virtual environment using UV and activate it for the project.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/local-setup.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuv venv --python 3.11\nsource .venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Setting Up Environment Variables for LLM API Keys\nDESCRIPTION: Example .env file configuration showing how to set up API keys for various language models supported by the project.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/local-setup.mdx#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nOPENAI_API_KEY=...\nANTHROPIC_API_KEY=\nAZURE_ENDPOINT=\nAZURE_OPENAI_API_KEY=\nGEMINI_API_KEY=\nDEEPSEEK_API_KEY=\nGROK_API_KEY=\nNOVITA_API_KEY=\n```\n\n----------------------------------------\n\nTITLE: Installing browser-use with memory support\nDESCRIPTION: Installation command that includes memory functionality, restricted to Python versions below 3.13 due to PyTorch compatibility.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install \"browser-use[memory]\"\n```\n\n----------------------------------------\n\nTITLE: Environment Variables Configuration\nDESCRIPTION: Example .env file configuration showing supported API key settings for various AI providers.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nOPENAI_API_KEY=\nANTHROPIC_API_KEY=\nAZURE_OPENAI_ENDPOINT=\nAZURE_OPENAI_KEY=\nGEMINI_API_KEY=\nDEEPSEEK_API_KEY=\nGROK_API_KEY=\nNOVITA_API_KEY=\n```\n\n----------------------------------------\n\nTITLE: Installing Browser Use Package\nDESCRIPTION: Installs the browser-use package using uv package manager.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/quickstart.mdx#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nuv pip install browser-use\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Browser Use Evaluations\nDESCRIPTION: Environment variables configuration for accessing the Browser Use evaluation tools. These credentials must be added to the .env file after obtaining an API access key from the Browser Use account page.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/evaluations.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nEVALUATION_TOOL_URL= ...\nEVALUATION_TOOL_SECRET_KEY= ...\n```\n\n----------------------------------------\n\nTITLE: LLM Basic Test\nDESCRIPTION: Simple test invocation of the language model.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/notebook/agent_browsing.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nllm.invoke('hi')\n```\n\n----------------------------------------\n\nTITLE: Configuring Browser Use Evaluations with Command Line Arguments\nDESCRIPTION: Advanced command with various configuration flags for customizing the evaluation parameters. Options include controlling parallelization, limiting steps, specifying test range, and selecting the model to evaluate.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/evaluations.mdx#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython eval/service.py --parallel_runs 5 --parallel_evaluations 5 --max-steps 25 --start 0 --end 100 --model gpt-4o\n```\n\n----------------------------------------\n\nTITLE: OpenAI Chat Model Initialization\nDESCRIPTION: Setting up ChatOpenAI model with API key from user data.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/notebook/agent_browsing.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom google.colab import userdata\nfrom langchain_openai import ChatOpenAI\n\nllm = ChatOpenAI(model='gpt-4o-mini', temperature=0, api_key=userdata.get('Open_api_key'))\n```\n\n----------------------------------------\n\nTITLE: Generating TypeScript Definitions from OpenAPI Spec\nDESCRIPTION: Commands to generate TypeScript type definitions using openapi-typescript generator. Creates TypeScript definitions for use with any HTTP client.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/cloud/quickstart.mdx#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Install the generator\nnpm install -D openapi-typescript\n\n# Generate the types\nnpx openapi-typescript http://api.browser-use.com/openapi.json -o browser-use-api.ts\n```\n\n----------------------------------------\n\nTITLE: Result Processing\nDESCRIPTION: Processing and displaying final results from browser agent execution.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/notebook/agent_browsing.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfor action in result.action_results():\n\tif action.is_done:\n\t\tprint(action.extracted_content)\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Slack Bot\nDESCRIPTION: Environment variable configuration for Slack bot authentication using signing secret and bot token.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/integrations/slack/README.md#2025-04-22_snippet_0\n\nLANGUAGE: env\nCODE:\n```\nSLACK_SIGNING_SECRET=your-signing-secret\nSLACK_BOT_TOKEN=your-bot-token\n```\n\n----------------------------------------\n\nTITLE: Configuring Authentication and Cross-Site Token Cookies for X.com in JSON\nDESCRIPTION: This JSON snippet defines two cookies for the X.com domain. The 'auth_token' cookie likely stores the user's authentication token, while 'ct0' is typically used for cross-site request forgery protection. Both cookies are set for the root path of the .x.com domain.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/use-cases/twitter_cookies.txt#2025-04-22_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n[\n  {\n    \"name\": \"auth_token\",\n    \"value\": \"auth_token_cookie_value\",\n    \"domain\": \".x.com\",\n    \"path\": \"/\"\n  },\n  {\n    \"name\": \"ct0\",\n    \"value\": \"ct0_cookie_value\",\n    \"domain\": \".x.com\",\n    \"path\": \"/\"\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Cloning the Browser Use Repository using Git\nDESCRIPTION: Commands to clone the Browser Use GitHub repository and navigate to the project directory.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/local-setup.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/browser-use/browser-use\ncd browser-use\n```\n\n----------------------------------------\n\nTITLE: Installing Browser Use Community Node in Self-hosted n8n (Bash)\nDESCRIPTION: This command installs the Browser Use community node in a self-hosted n8n instance. It should be run in the n8n installation directory.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/n8n-integration.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install n8n-nodes-browser-use\n```\n\n----------------------------------------\n\nTITLE: Disabling Telemetry in Python Code\nDESCRIPTION: This Python code demonstrates how to disable telemetry for Browser Use programmatically. It imports the os module and sets the ANONYMIZED_TELEMETRY environment variable to \"false\".\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/telemetry.mdx#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport os\nos.environ[\"ANONYMIZED_TELEMETRY\"] = \"false\"\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with UV\nDESCRIPTION: Command to install the package in editable mode with all development dependencies using UV sync.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/local-setup.mdx#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Install the package in editable mode with all development dependencies\nuv sync\n```\n\n----------------------------------------\n\nTITLE: Disabling Telemetry via Environment Variable in Bash\nDESCRIPTION: This snippet shows how to disable telemetry for Browser Use by setting an environment variable in a .env file. It sets the ANONYMIZED_TELEMETRY variable to false.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/telemetry.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nANONYMIZED_TELEMETRY=false\n```\n\n----------------------------------------\n\nTITLE: Running Development Tasks with UV\nDESCRIPTION: Example commands for various development tasks including running demos, formatting code, executing tests, and building the package.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/local-setup.mdx#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nuv run examples/simple.py\nuv run ruff format examples/some/file.py\nuv run pytest\nuv build\n```\n\n----------------------------------------\n\nTITLE: Linking Browser Use n8n Node to Local Installation (Bash)\nDESCRIPTION: These commands link the developed Browser Use n8n node to the local n8n installation for testing.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/n8n-integration.mdx#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm link\nnpm link n8n-nodes-browser-use\n```\n\n----------------------------------------\n\nTITLE: Installing Patchright Dependency\nDESCRIPTION: Installs the patchright tool which is a dependency for Browser Use.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/quickstart.mdx#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nuv run patchright install\n```\n\n----------------------------------------\n\nTITLE: Building Browser Use n8n Node Code (Bash)\nDESCRIPTION: This command builds the code for the Browser Use n8n node during development.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/n8n-integration.mdx#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Installing Required Packages\nDESCRIPTION: Installation of LangChain, Google GenAI, Groq, and related dependencies using pip.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/notebook/agent_browsing.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n%pip install -U langgraph langchain_google_genai langchain_community langgraph-checkpoint-postgres  openai langchain_groq\n```\n\n----------------------------------------\n\nTITLE: Cloning Browser Use n8n Node Repository (Bash)\nDESCRIPTION: This command clones the Browser Use n8n node repository for development purposes.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/n8n-integration.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/draphonix/n8n-nodes-browser-use.git\n```\n\n----------------------------------------\n\nTITLE: Installing Playwright and Browser Dependencies\nDESCRIPTION: Silent installation of Playwright and additional browser automation dependencies.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/notebook/agent_browsing.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%%capture --no-stderr\n%pip install --upgrade --quiet  playwright > /dev/null\n%pip install --upgrade --quiet  lxml browser-use langchain_openai\n```\n\n----------------------------------------\n\nTITLE: Jupyter Notebook Event Loop Setup\nDESCRIPTION: Configuration of event loop for Jupyter notebooks using nest_asyncio.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/notebook/agent_browsing.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport nest_asyncio\n\nnest_asyncio.apply()\n```\n\n----------------------------------------\n\nTITLE: Installing Gradio UI Dependency\nDESCRIPTION: Command to install Gradio for the UI demo example.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nuv pip install gradio\n```\n\n----------------------------------------\n\nTITLE: AnyIO Version Constraint\nDESCRIPTION: Installing specific version of AnyIO package for compatibility.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/notebook/agent_browsing.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n!pip install \"anyio<4\"\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Browser Use n8n Node (Bash)\nDESCRIPTION: These commands navigate to the cloned repository directory and install the necessary dependencies for development.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/n8n-integration.mdx#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd n8n-nodes-browser-use\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Copying the Environment Configuration Example File\nDESCRIPTION: Command to copy the example environment file to create a new .env configuration file for the project.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/local-setup.mdx#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Copy the example environment file\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Installing Required Python Packages\nDESCRIPTION: pip command to install necessary Python packages for running the Slack bot including FastAPI, uvicorn, and slack_sdk.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/integrations/slack/README.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npip install fastapi uvicorn slack_sdk\n```\n\n----------------------------------------\n\nTITLE: Running Browser Use Evaluations\nDESCRIPTION: Command to execute the evaluation service for Browser Use agent. This runs the Python script located in the eval directory.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development/evaluations.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython eval/service.py\n```\n\n----------------------------------------\n\nTITLE: Running Gradio Demo\nDESCRIPTION: Command to run the Gradio UI demo example.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/README.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npython examples/ui/gradio_demo.py\n```\n\n----------------------------------------\n\nTITLE: Installing Patchright Chromium\nDESCRIPTION: Command to install the Chromium browser using Patchright.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npatchright install chromium\n```\n\n----------------------------------------\n\nTITLE: Installing Mintlify CLI for Browser Use Documentation Development\nDESCRIPTION: Command to install the Mintlify CLI globally using npm. This tool is required to preview documentation changes locally.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -g mintlify\n```\n\n----------------------------------------\n\nTITLE: Running Mintlify Local Development Server\nDESCRIPTION: Command to start the Mintlify development server in the docs directory. This will launch a local preview of the documentation at http://localhost:3000.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmintlify dev\n```\n\n----------------------------------------\n\nTITLE: Running Mintlify Development Server for Browser Use Documentation\nDESCRIPTION: Command to start the Mintlify development server from the root of the documentation directory where the mint.json configuration file is located.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmintlify dev\n```\n\n----------------------------------------\n\nTITLE: Installing Mintlify CLI with npm or yarn\nDESCRIPTION: Commands to install the Mintlify CLI globally using either npm or yarn package managers. This is a prerequisite step for local development.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development.mdx#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -g mintlify\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn global add mintlify\n```\n\n----------------------------------------\n\nTITLE: Validating Documentation Links\nDESCRIPTION: Command to run the Mintlify link validator, which checks for broken links in the documentation.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development.mdx#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmintlify broken-links\n```\n\n----------------------------------------\n\nTITLE: Updating Mintlify CLI to Latest Version\nDESCRIPTION: Commands to update the Mintlify CLI to the latest version using either npm or yarn package managers.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development.mdx#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -g mintlify@latest\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn global upgrade mintlify\n```\n\n----------------------------------------\n\nTITLE: Activating Python Virtual Environment\nDESCRIPTION: Commands to activate the Python virtual environment on different operating systems.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/quickstart.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# For Mac/Linux:\nsource .venv/bin/activate\n\n# For Windows:\n.venv\\Scripts\\activate\n```\n\n----------------------------------------\n\nTITLE: Running Mintlify on Custom Port\nDESCRIPTION: Command to start the Mintlify development server on a custom port (3333 in this example) using the --port flag.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development.mdx#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmintlify dev --port 3333\n```\n\n----------------------------------------\n\nTITLE: Starting Ngrok for Local Server Exposure\nDESCRIPTION: Command to start ngrok for exposing local server to the internet on port 3000.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/examples/integrations/slack/README.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nngrok http 3000\n```\n\n----------------------------------------\n\nTITLE: Port Conflict Resolution Message\nDESCRIPTION: Example message displayed when Mintlify encounters a port conflict and automatically tries the next available port.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/development.mdx#2025-04-22_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nPort 3000 is already in use. Trying 3001 instead.\n```\n\n----------------------------------------\n\nTITLE: Academic Citation Format\nDESCRIPTION: BibTeX citation format for referencing the browser-use project in academic work.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/README.md#2025-04-22_snippet_7\n\nLANGUAGE: bibtex\nCODE:\n```\n@software{browser_use2024,\n  author = {Müller, Magnus and Žunič, Gregor},\n  title = {Browser Use: Enable AI to control your browser},\n  year = {2024},\n  publisher = {GitHub},\n  url = {https://github.com/browser-use/browser-use}\n}\n```\n\n----------------------------------------\n\nTITLE: Installation Command for Agent Activity Recording System\nDESCRIPTION: Command to install the required dependencies for the complete agent activity recording system example. Includes FastAPI, Uvicorn, and other utilities needed for both server and client components.\nSOURCE: https://github.com/browser-use/browser-use/blob/main/docs/customize/hooks.mdx#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install fastapi uvicorn prettyprinter pyobjtojson dotenv browser-use langchain-openai\n```"
  }
]