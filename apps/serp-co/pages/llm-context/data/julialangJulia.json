[
  {
    "owner": "julialang",
    "repo": "julia",
    "content": "TITLE: Defining a Basic Julia Function using 'function' Keyword\nDESCRIPTION: Demonstrates the standard syntax for defining a function `f` in Julia using the `function` keyword. This function accepts two arguments, `x` and `y`, and implicitly returns the value of the last evaluated expression, which is their sum (`x + y`). The REPL output confirms the creation of a generic function `f` with one method.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_0\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function f(x, y)\n           x + y\n       end\nf (generic function with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Recommended Iteration Paradigms for Julia Arrays\nDESCRIPTION: This snippet shows best practices for iterating over arrays in Julia using two paradigms: iterating directly over elements and iterating over indices with eachindex. It clarifies that the index type returned by eachindex may be Int or CartesianIndex, depending on the underlying array structure. No dependencies are needed. No inputs or outputs; the code demonstrates idiomatic patterns for efficient array traversal.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\nfor a in A\n    # Do something with the element a\nend\n\nfor i in eachindex(A)\n    # Do something with i and/or A[i]\nend\n```\n\n----------------------------------------\n\nTITLE: Ensuring Type Stability in Function Return Values - Julia\nDESCRIPTION: Demonstrates the importance of type-stable returns by comparing a version that may return either an Int or the type of x, and a fixed version that always returns the type of x using zero(x). Useful to ensure compiler optimizations and reliable type inference.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\npos(x) = x < 0 ? 0 : x\n```\n\nLANGUAGE: julia\nCODE:\n```\npos(x) = x < 0 ? zero(x) : x\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized vs. Abstract-Typed Julia Structs\nDESCRIPTION: Compares two approaches for defining structs where a field can hold related types. `MyType{T<:AbstractFloat}` uses a type parameter `T` for the field `a`, making the field's concrete type known from the struct instance's type. `MyStillAmbiguousType` directly types the field `a` as `AbstractFloat`, which is less specific and hinders optimization. Parameterization is preferred.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_13\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> mutable struct MyType{T<:AbstractFloat}\n           a::T\n       end\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> mutable struct MyStillAmbiguousType\n           a::AbstractFloat\n       end\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with Optional Arguments and Defaults in Julia\nDESCRIPTION: Provides an example of a function with optional arguments by assigning default values in the signature. Uses the Dates module to construct dates, with month and day parameters being optional and defaulting to 1. All dependencies are standard: the function uses the Dates module and expects correct types for each argument. Inputs are integers for year, month, and day; missing month/day are defaulted. Output is a Date object or an error if arguments are invalid.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\njulia> using Dates\n\njulia> function date(y::Int64, m::Int64=1, d::Int64=1)\n           err = Dates.validargs(Date, y, m, d)\n           err === nothing || throw(err)\n           return Date(Dates.UTD(Dates.totaldays(y, m, d)))\n       end\ndate (generic function with 3 methods)\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> date(2000, 12, 12)\n2000-12-12\n\njulia> date(2000, 12)\n2000-12-01\n\njulia> date(2000)\n2000-01-01\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> methods(date)\n# 3 methods for generic function \"date\" from Main:\n [1] date(y::Int64, m::Int64, d::Int64)\n     @ REPL[2]:1\n [2] date(y::Int64, m::Int64)\n     @ REPL[2]:1\n [3] date(y::Int64)\n     @ REPL[2]:1\n```\n\n----------------------------------------\n\nTITLE: Creating Arrays with Comprehensions in Julia\nDESCRIPTION: Introduces array comprehensions using the `[ F(vars...) for vars in iterables... ]` syntax. This example constructs a 1D array (Vector) by iterating through indices of an existing vector `x` and computing a weighted average of neighboring elements. The resulting array's element type is determined automatically based on the computation result type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nA = [ F(x, y, ...) for x=rx, y=ry, ... ]\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> x = rand(8)\n8-element Vector{Float64}:\n 0.843025\n 0.869052\n 0.365105\n 0.699456\n 0.977653\n 0.994953\n 0.41084\n 0.809411\n\njulia> [ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]\n6-element Vector{Float64}:\n 0.736559\n 0.57468\n 0.685417\n 0.912429\n 0.8446\n 0.656511\n```\n\n----------------------------------------\n\nTITLE: Declaring Abstract Types - Julia\nDESCRIPTION: This snippet demonstrates the syntax and usage of the 'abstract type' keyword in Julia to define new abstract types and establish subtype relationships. It shows how to declare both base abstract types and those that inherit from other abstract types using the '<:' operator, which creates hierarchical organization in the type system. No external dependencies are required; these declarations are a core feature of Julia. Inputs are type names (optionally with a supertype); output is a new abstract type node available for subtype relationships, but cannot be instantiated directly.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nabstract type \\u00abname\\u00bb end\nabstract type \\u00abname\\u00bb <: \\u00absupertype\\u00bb end\n```\n\n----------------------------------------\n\nTITLE: Diagnosing Type Stability with @code_warntype in Julia\nDESCRIPTION: This snippet demonstrates the use of the @code_warntype macro to display the type inference results for a Julia function f that internally calls another function pos. It shows how variable types are inferred, highlighting type instabilities (non-concrete types) to diagnose performance issues. Required dependencies: Julia Base macros. The main parameter is the argument to f (a Float64 in the example); output is the type-annotated IR of function f as inferred by Julia. Limitations include interpretation of complex type instabilities, and the analysis heavily relies on Julia's own SSA IR representation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_32\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @noinline pos(x) = x < 0 ? 0 : x;\n\njulia> function f(x)\n           y = pos(x)\n           return sin(y*x + 1)\n       end;\n\njulia> @code_warntype f(3.2)\nMethodInstance for f(::Float64)\n  from f(x) @ Main REPL[9]:1\nArguments\n  #self#::Core.Const(f)\n  x::Float64\nLocals\n  y::Union{Float64, Int64}\nBody::Float64\n1 ─      (y = Main.pos(x))\n│   %2 = (y * x)::Float64\n│   %3 = (%2 + 1)::Float64\n│   %4 = Main.sin(%3)::Float64\n└──      return %4\n```\n\n----------------------------------------\n\nTITLE: Illustrating Supported Index Types in Julia Array Indexing\nDESCRIPTION: Provides concrete examples of various supported index types for Julia arrays as described in the preceding text. It demonstrates indexing a 3x3 matrix `A` using a scalar integer, a vector of integers, a matrix of integers, an empty vector (`[]`), a range (`1:2:5`), the colon operator (`:`) for selecting entire dimensions, and slicing that results in a column matrix. Requires a pre-defined 3x3 matrix `A`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_27\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> A = reshape(collect(1:2:18), (3, 3))\n3×3 Matrix{Int64}:\n 1   7  13\n 3   9  15\n 5  11  17\n\njulia> A[4]\n7\n\njulia> A[[2, 5, 8]]\n3-element Vector{Int64}:\n  3\n  9\n 15\n\njulia> A[[1 4; 3 8]]\n2×2 Matrix{Int64}:\n 1   7\n 5  15\n\njulia> A[[]]\nInt64[]\n\njulia> A[1:2:5]\n3-element Vector{Int64}:\n 1\n 5\n 9\n\njulia> A[2, :]\n3-element Vector{Int64}:\n  3\n  9\n 15\n\njulia> A[:, 3]\n3-element Vector{Int64}:\n 13\n 15\n 17\n\njulia> A[:, 3:3]\n3×1 Matrix{Int64}:\n 13\n 15\n 17\n```\n\n----------------------------------------\n\nTITLE: Skipping Missing Values with skipmissing in Julia\nDESCRIPTION: Shows how to use the `skipmissing` function to ignore `missing` values during computations like `sum`. Requires no external packages as `skipmissing` is a Julia base function. Takes an array and wraps it in an iterator that filters out `missing` elements. Output is the reduction result over non-missing entries. Limitations: only functions compatible with iterators are supported.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\njulia> sum(skipmissing([1, missing]))\n1\n```\n\n----------------------------------------\n\nTITLE: Defining Type-Constrained Methods for a Function (Julia)\nDESCRIPTION: This snippet demonstrates how to define a Julia function with type-annotated arguments so that it only applies to arguments of type Float64. This enables Julia's multiple dispatch system to select the most appropriate method based on types. No external dependencies are required, and the function 'f' takes two Float64 parameters and returns 2x+y as a Float64. If called with non-Float64 types, it throws a MethodError.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(x::Float64, y::Float64) = 2x + y\nf (generic function with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Creating Typed Arrays with Comprehensions in Julia\nDESCRIPTION: Shows how to explicitly specify the element type of an array created using a comprehension by prepending the type name (e.g., `Float32`) to the comprehension expression. This forces the result to be stored with the specified precision.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nFloat32[ 0.25*x[i-1] + 0.5*x[i] + 0.25*x[i+1] for i=2:length(x)-1 ]\n```\n\n----------------------------------------\n\nTITLE: Illustrating For Loop Variable Scope (New Variable) in Julia\nDESCRIPTION: Demonstrates the scoping behavior of `for` loops in Julia. The loop `for j = 1:3` introduces a new iteration variable `j` that is local to the loop's body. After the loop finishes, attempting to access `j` results in an `UndefVarError` because the loop-local `j` does not exist in the outer scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_20\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for j = 1:3\n           println(j)\n       end\n1\n2\n3\n\njulia> j\nERROR: UndefVarError: `j` not defined in `Main`\n```\n\n----------------------------------------\n\nTITLE: Julia Array Indexing Using Matrix Indices\nDESCRIPTION: Illustrates the effect of using a matrix as an index when accessing elements of a Julia array `A`. The example shows that indexing with a 2x2 matrix results in a 2x2 matrix output, effectively using the matrix elements as indices into the original array. Requires a pre-defined 4D array `A`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_20\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> A = reshape(collect(1:16), (2, 2, 2, 2));\n\njulia> A[[1 2; 1 2]]\n2×2 Matrix{Int64}:\n 1  2\n 1  2\n\njulia> A[[1 2; 1 2], 1, 2, 1]\n2×2 Matrix{Int64}:\n 5  6\n 5  6\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using Keyword Arguments with Defaults in Julia\nDESCRIPTION: Shows definition and usage of functions with keyword arguments. Keyword arguments are specified after a semicolon in the function signature and can have type annotations and default values. Examples include fixed and varargs signatures, collecting extra keyword arguments, and runtime construction of key=>value pairs and splash/merge of named tuple options. Functions may require keywords, throw errors on missing required keyword, and rightmost duplicated keyword takes precedence in merged calls. No special dependencies, input/output structures determined by function logic.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\nfunction plot(x, y; style=\"solid\", width=1, color=\"black\")\n    ###\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(; x::Int=1)\n    ###\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction plot(x...; style=\"solid\")\n    ###\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(x; y=0, kwargs...)\n    ###\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(x; y)\n    ###\nend\nf(3, y=5) # ok, y is assigned\nf(3)      # throws UndefKeywordError(:y)\n```\n\n----------------------------------------\n\nTITLE: Creating Callable Objects (Functors) in Julia\nDESCRIPTION: Demonstrates how to make a Julia struct `Polynomial` callable like a function (a functor). This is achieved by defining methods directly on the type, such as `(p::Polynomial)(x)` to evaluate the polynomial and `(p::Polynomial)()` as a shorthand. The function body operates on the instance `p`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\njulia> struct Polynomial{R}\n           coeffs::Vector{R}\n       end\n\njulia> function (p::Polynomial)(x)\n           v = p.coeffs[end]\n           for i = (length(p.coeffs)-1):-1:1\n               v = v*x + p.coeffs[i]\n           end\n           return v\n       end\n\njulia> (p::Polynomial)() = p(5)\n```\n\n----------------------------------------\n\nTITLE: Defining a Function using Multiple Dispatch (Idiomatic Julia)\nDESCRIPTION: Shows the preferred Julia way to implement the `mynorm` function using multiple dispatch. By defining separate methods specialized for `Vector` and `Matrix` types, the compiler can choose the correct, optimized code path at compile time, leading to better performance and clearer code.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nmynorm(x::Vector) = sqrt(real(dot(x, x)))\nmynorm(A::Matrix) = maximum(svdvals(A))\n```\n```\n\n----------------------------------------\n\nTITLE: Using Operators as Functions - Julia\nDESCRIPTION: Shows how operators in Julia can be used both in infix notation and as regular functional calls. Addition is performed via standard infix and via the '+' function applied to multiple arguments. This demonstrates that operators except for certain short-circuiting ones behave as first-class functions. No dependencies required, and both forms produce the same output. Inputs are integers; output is their numeric sum.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_13\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> 1 + 2 + 3\n6\n\njulia> +(1, 2, 3)\n6\n```\n\n----------------------------------------\n\nTITLE: Indexing Multidimensional Julia Arrays with Various Index Types\nDESCRIPTION: Demonstrates various ways to index a 4-dimensional Julia array `A`. It shows indexing with all scalar indices yielding a single element, indexing with all vector indices yielding a 4D array, and indexing with a mix of vectors and scalars yielding a 3D array, illustrating how dimensionality changes based on index types. Requires a pre-defined 4D array `A`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_19\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> A = reshape(collect(1:16), (2, 2, 2, 2))\n2×2×2×2 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1  3\n 2  4\n\n[:, :, 2, 1] =\n 5  7\n 6  8\n\n[:, :, 1, 2] =\n  9  11\n 10  12\n\n[:, :, 2, 2] =\n 13  15\n 14  16\n\njulia> A[1, 2, 1, 1] # all scalar indices\n3\n\njulia> A[[1, 2], [1], [1, 2], [1]] # all vector indices\n2×1×2×1 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1\n 2\n\n[:, :, 2, 1] =\n 5\n 6\n\njulia> A[[1, 2], [1], [1, 2], 1] # a mix of index types\n2×1×2 Array{Int64, 3}:\n[:, :, 1] =\n 1\n 2\n\n[:, :, 2] =\n 5\n 6\n```\n\n----------------------------------------\n\nTITLE: Accessing Fields of a Composite Type Instance in Julia\nDESCRIPTION: Shows how to access individual fields of a Foo instance using dot notation. Each access retrieves the current field value by name. Inputs are the instance and field request; outputs are the exact stored values. This is the canonical way to obtain field values in Julia objects.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nfoo.bar\n\"Hello, world.\"\n\nfoo.baz\n23\n\nfoo.qux\n1.5\n```\n\n----------------------------------------\n\nTITLE: General Syntax for Julia Array Indexing\nDESCRIPTION: Presents the general syntax for accessing elements or subarrays of an n-dimensional array `A` in Julia. `I_1` through `I_n` represent indices for each dimension, which can be scalars, arrays, ranges, or other supported index types. `X` is the resulting element or subarray.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_18\n\nLANGUAGE: plaintext\nCODE:\n```\nX = A[I_1, I_2, ..., I_n]\n```\n\n----------------------------------------\n\nTITLE: Defining a Parametric Composite Type in Julia\nDESCRIPTION: Defines a parametric composite type `Point{T}` using the `struct` keyword. This type represents a point with two coordinates, `x` and `y`, both constrained to be of the same type `T`. `T` acts as a type parameter that can be replaced by any concrete type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_22\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct Point{T}\n           x::T\n           y::T\n       end\n```\n\n----------------------------------------\n\nTITLE: Defining a Parametric Struct with a Custom Constructor in Julia\nDESCRIPTION: Defines a parametric struct Polar{T<:Real} subtype of Number, representing a polar-form complex number with fields r and Θ. Adds a custom constructor to promote arguments to a common Real type using Julia's promote system. Fundamental to defining new numeric types; no external dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_68\n\nLANGUAGE: julia\nCODE:\n```\nstruct Polar{T<:Real} <: Number\\n    r::T\\n    Θ::T\\nend\\n\\nPolar(r::Real,Θ::Real) = Polar(promote(r,Θ)...)\n```\n\n----------------------------------------\n\nTITLE: Using `broadcast` for Elementwise Array Operations in Julia\nDESCRIPTION: Shows the use of the `broadcast` function in Julia to perform elementwise addition (+) on arrays of different sizes (`a` and `A`, `a` and `b`). `broadcast` automatically expands singleton dimensions to match corresponding dimensions without allocating extra memory, providing an efficient alternative to manual replication.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_39\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> broadcast(+, a, A)\n2×3 Matrix{Float64}:\n 1.20813  1.82068  1.25387\n 1.56851  1.86401  1.67846\n\njulia> b = rand(1,2)\n1×2 Matrix{Float64}:\n 0.867535  0.00457906\n\njulia> broadcast(+, a, b)\n2×2 Matrix{Float64}:\n 1.71056  0.847604\n 1.73659  0.873631\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Functions with Custom Iterables in Julia\nDESCRIPTION: Shows how implementing the iteration interface allows custom types like `Squares` to work seamlessly with built-in Julia functions such as `in` (membership testing) and `sum` (aggregation).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_3\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> 25 in Squares(10)\ntrue\n\njulia> sum(Squares(100))\n338350\n```\n\n----------------------------------------\n\nTITLE: Converting Characters to Integers in Julia\nDESCRIPTION: Shows conversion of a `Char` to its numeric Unicode code point using the `Int` function and inspects the resulting type. No dependencies outside of Julia base. The input is a character value, output is its integer code point and the integer type used on the platform.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> c = Int('x')\n120\n\njulia> typeof(c)\nInt64\n```\n\n----------------------------------------\n\nTITLE: Defining Methods for Parametric Types in Julia\nDESCRIPTION: Illustrates defining functions that operate on parametric types like `Point`. It first shows an incorrect definition `norm(p::Point{Real})` which fails for `Point{Float64}` arguments due to type invariance. Then, it presents the correct approach using `norm(p::Point{<:Real})`, which accepts any `Point` whose type parameter `T` is a subtype of `Real`. This utilizes the `<:` syntax within the type declaration for subtype constraints, enabling methods to work on a family of related parametric types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\nfunction norm(p::Point{Real})\n    sqrt(p.x^2 + p.y^2)\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction norm(p::Point{<:Real})\n    sqrt(p.x^2 + p.y^2)\nend\n```\n\n----------------------------------------\n\nTITLE: Syntax for Julia Broadcast Indexed Assignment\nDESCRIPTION: Shows the syntax for broadcast assignment in Julia using the `.=` operator. This assigns the elements of `X` (or broadcasts `X` if it's a scalar or has compatible dimensions) element-wise to the locations specified by the indices `I_1` through `I_n` in array `A`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_24\n\nLANGUAGE: plaintext\nCODE:\n```\nA[I_1, I_2, ..., I_n] .= X\n```\n\n----------------------------------------\n\nTITLE: Copying the Custom SparseArray in Julia\nDESCRIPTION: Demonstrates that the `copy` function works correctly for the custom `SparseArray`. This relies on the implementation of `similar` (to create a new instance of the same type and shape) and the element-wise access methods (`getindex`/`setindex!`) provided for the `SparseArray` type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_19\n\nLANGUAGE: jldoctest squarevectype\nCODE:\n```\njulia> copy(A)\n3×3 SparseArray{Float64, 2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n 3.0  6.0  9.0\n```\n\n----------------------------------------\n\nTITLE: Function Call Equivalent to Julia Array Indexing\nDESCRIPTION: Shows the explicit function call `getindex(A, I_1, ..., I_n)` which is equivalent to the standard Julia array indexing syntax `A[I_1, ..., I_n]` when the `end` keyword is not used.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_21\n\nLANGUAGE: plaintext\nCODE:\n```\nX = getindex(A, I_1, I_2, ..., I_n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Strings and Escaping Quotes in Julia\nDESCRIPTION: Demonstrates string literal creation with both regular and triple quotes to embed characters like double quotes inside strings. No dependencies required. Input is a string assignment; output shows the string with preserved escapes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> str = \"Hello, world.\\n\"\n\"Hello, world.\\n\"\n\njulia> \"\"\"Contains \"quote\" characters\"\"\"\n\"Contains \\\"quote\\\" characters\"\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Dot Fusion Performance in Julia\nDESCRIPTION: Compares the execution time and memory allocations of applying the functions `f` (standard vectorized), `fdot` (macro dot fusion), and `f.` (function broadcasting) to a large random array. Demonstrates that `fdot(x)` and `f.(x)` are significantly faster and allocate less memory than `f(x)` due to loop fusion.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_47\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest dotfuse; filter = r\"[0-9\\.]+ seconds \\(.*\\)\"\njulia> x = rand(10^6);\n\njulia> @time f(x);\n  0.019049 seconds (16 allocations: 45.777 MiB, 18.59% gc time)\n\njulia> @time fdot(x);\n  0.002790 seconds (6 allocations: 7.630 MiB)\n\njulia> @time f.(x);\n  0.002626 seconds (8 allocations: 7.630 MiB)\n```\n```\n\n----------------------------------------\n\nTITLE: Defining and Instantiating a Basic Julia Struct\nDESCRIPTION: Demonstrates the basic definition of a Julia `struct` named `Foo` with fields `bar` and `baz`. It shows how to use the automatically provided default constructor to create an instance of `Foo` by supplying values for its fields, and how to access these fields.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_0\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct Foo\n           bar\n           baz\n       end\n\njulia> foo = Foo(1, 2)\nFoo(1, 2)\n\njulia> foo.bar\n1\n\njulia> foo.baz\n2\n```\n\n----------------------------------------\n\nTITLE: Working with Named Tuples in Julia\nDESCRIPTION: Demonstrates automatic type inference and explicit construction of named tuples using macro and parameterized types. The @NamedTuple macro and NamedTuple type syntax are used to create types with named fields of specific types. Pragmatic for structured, lightweight data grouping.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_42\n\nLANGUAGE: julia\nCODE:\n```\njulia> typeof((a=1,b=\"hello\")) # prints in macro form\n@NamedTuple{a::Int64, b::String}\n\njulia> NamedTuple{(:a, :b), Tuple{Int64, String}} # long form of the type\n@NamedTuple{a::Int64, b::String}\n```\n\n----------------------------------------\n\nTITLE: Unpacking Collections into Arguments (Splatting) in Julia Function Calls\nDESCRIPTION: Explains and demonstrates the \"splatting\" feature in Julia function calls. The `...` operator used after a collection (`x...`) unpacks the elements of that collection (e.g., a `Vector`) and passes them as individual, separate arguments to the function being called.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_10\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function threeargs(a, b, c)\n           println(\"a = $a::$(typeof(a))\")\n           println(\"b = $b::$(typeof(b))\")\n           println(\"c = $c::$(typeof(c))\")\n       end\nthreeargs (generic function with 1 method)\n\njulia> x = [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> threeargs(x...)\na = 1::Int64\nb = 2::Int64\nc = 3::Int64\n```\n\n----------------------------------------\n\nTITLE: Copying and Viewing Slices for Performance - Base Julia - Julia\nDESCRIPTION: Contrasts copying vs. viewing array slices in function processing in Julia. The `fcopy` function creates a new array for each slice, while `fview` uses the `@views` macro to avoid memory copies and operate in-place. Benchmarked with the `@time` macro, the code reveals reduced allocations and improved runtime with view-based approaches. Only standard libraries are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_45\n\nLANGUAGE: julia\nCODE:\n```\njulia> fcopy(x) = sum(x[2:end-1]);\n\njulia> @views fview(x) = sum(x[2:end-1]);\n\njulia> x = rand(10^6);\n\njulia> @time fcopy(x);\n  0.003051 seconds (3 allocations: 7.629 MB)\n\njulia> @time fview(x);\n  0.001020 seconds (1 allocation: 16 bytes)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Argument Passing (Immutable Types) in Julia\nDESCRIPTION: Illustrates Julia's pass-by-sharing argument mechanism with immutable types. When an immutable value (`x = 10`) is passed to a function, reassigning the function's parameter (`y = 17`) creates a new local binding for `y` and does not modify the original variable `x` in the caller's scope, as the binding itself cannot be changed from within the function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = 10\n10\n\njulia> function change_value!(y)\n           y = 17\n       end\nchange_value! (generic function with 1 method)\n\njulia> change_value!(x)\n17\n\njulia> x # x is unchanged!\n10\n```\n\n----------------------------------------\n\nTITLE: Defining Efficient vs. Inefficient Julia Structs for Callable Objects\nDESCRIPTION: Contrasts two ways to create a struct wrapper for a callable object. Using `f::Function` is inefficient because `Function` is an abstract type, leading to dynamic dispatch. The preferred method uses parameterization `struct MyCallableWrapper{F} f::F end`. This allows the compiler to specialize on the concrete type `F` of the callable, improving performance. Note `F<:Function` is omitted to allow any callable type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\nstruct MyCallableWrapper\n    f::Function\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nstruct MyCallableWrapper{F}\n    f::F\nend\n```\n\n----------------------------------------\n\nTITLE: Using 'end' Keyword and Matrix Indices in Julia Array Indexing\nDESCRIPTION: Provides examples of Julia array indexing using the `end` keyword to refer to the last index of a dimension (e.g., `2:end-1`). It also demonstrates indexing with a matrix containing indices. Requires a pre-defined 4x4 matrix `x`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_22\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = reshape(1:16, 4, 4)\n4×4 reshape(::UnitRange{Int64}, 4, 4) with eltype Int64:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> x[2:3, 2:end-1]\n2×2 Matrix{Int64}:\n 6  10\n 7  11\n\njulia> x[1, [2 3; 4 1]]\n2×2 Matrix{Int64}:\n  5  9\n 13  1\n```\n\n----------------------------------------\n\nTITLE: Understanding `for` Loop Translation in Julia\nDESCRIPTION: This snippet shows the internal mechanism of a Julia `for` loop. It demonstrates how the loop syntax is translated into explicit calls to the `iterate` function, highlighting the core of Julia's iteration protocol.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nnext = iterate(iter)\nwhile next !== nothing\n    (item, state) = next\n    # body\n    next = iterate(iter, state)\nend\n```\n\n----------------------------------------\n\nTITLE: Constraining Parametric Abstract Types in Julia\nDESCRIPTION: Declares a parametric abstract type Pointy{T} where T must be a subtype of Real. This restricts the instantiable types to those following type constraint rules, improving type safety. Julia-only syntax is used, with TypeError feedback when constraints are violated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\nabstract type Pointy{T<:Real} end\n```\n\n----------------------------------------\n\nTITLE: Defining an Interval Type with Rounding Interface in Julia\nDESCRIPTION: Implements an immutable struct 'Interval' with generic min and max fields, and overloads the round function to round both endpoints based on a given RoundingMode. Demonstrates how the custom type integrates with Julia's round, floor, ceil, and trunc functions. Requires only base Julia and works with any type supporting rounding. Inputs are Interval instances and rounding modes; outputs are new Interval instances with rounded endpoints. Throws InexactError if conversion fails, as per Julia rounding conventions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\nstruct Interval{T}\n    min::T\n    max::T\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nBase.round(x::Interval, r::RoundingMode) = Interval(round(x.min, r), round(x.max, r))\n```\n\nLANGUAGE: julia\nCODE:\n```\nx = Interval(1.7, 2.2)\n```\n\nLANGUAGE: julia\nCODE:\n```\nround(x)\n```\n\nLANGUAGE: julia\nCODE:\n```\nfloor(x)\n```\n\nLANGUAGE: julia\nCODE:\n```\nceil(x)\n```\n\nLANGUAGE: julia\nCODE:\n```\ntrunc(x)\n```\n\n----------------------------------------\n\nTITLE: Slurping in Variadic and Single Argument Function Definitions - Julia\nDESCRIPTION: Highlights the difference between slurping in variadic function argument positions (not legal except at the end) versus within single-argument destructuring. The first example shows an error when using '...' in a non-final argument; the second demonstrates permitted usage by destructuring a tuple. Only Julia Base is necessary. Inputs are variadic forms and tuples; outputs include function objects or compilation errors.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_23\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> f(x..., y) = x\nERROR: syntax: invalid \"...\" on non-final argument\nStacktrace:\n[...]\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> f((x..., y)) = x\nf (generic function with 1 method)\n\njulia> f((1, 2, 3))\n(1, 2)\n```\n\n----------------------------------------\n\nTITLE: Specializing `sum` for Performance on a Custom Type in Julia\nDESCRIPTION: Illustrates specializing a generic function (`sum`) for a custom type (`Squares`). By providing a method `Base.sum(S::Squares)` that uses a direct mathematical formula, it achieves better performance than the default iterative summation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_6\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Base.sum(S::Squares) = (n = S.count; return n*(n+1)*(2n+1)÷6)\n\njulia> sum(Squares(1803))\n1955361914\n```\n\n----------------------------------------\n\nTITLE: Interpolating Expressions in Strings using $() in Julia\nDESCRIPTION: Shows how to interpolate the result of an arbitrary Julia expression into a string by enclosing the expression in parentheses immediately following the `$` sign, like `$(expression)`. The shortest complete expression following `$` is evaluated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_26\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> \"1 + 2 = $(1 + 2)\"\n\"1 + 2 = 3\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom `convert` Method in Julia\nDESCRIPTION: Provides a template for defining a new `convert` method for a custom type `MyType`. It uses `import Base: convert` to extend the standard `convert` function and defines a method that takes `Type{MyType}` and an argument `x`, calling the `MyType(x)` constructor. This allows implicit conversion to `MyType` where applicable.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nimport Base: convert\nconvert(::Type{MyType}, x) = MyType(x)\n```\n\n----------------------------------------\n\nTITLE: Performing a Parallel Write to Array using @threads - Julia\nDESCRIPTION: Demonstrates how to parallelize a for-loop with the Threads.@threads macro such that each thread writes its thread ID to assigned indices of an array. Requires Julia's Threads module and a multi-threaded Julia session. The input is a range and an array; the output is the array filled according to the Thread assignment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_12\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> Threads.@threads for i = 1:10\n           a[i] = Threads.threadid()\n       end\n```\n\n----------------------------------------\n\nTITLE: Defining Arithmetic Operators Using promote in Julia\nDESCRIPTION: Shows how generic methods for arithmetic operators (`+`, `-`, `*`, `/`) are defined for `Number` types in Julia. These methods use `promote` to convert operands to a common type before performing the operation, ensuring broad compatibility.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n+(x::Number, y::Number) = +(promote(x,y)...)\n-(x::Number, y::Number) = -(promote(x,y)...)\n*(x::Number, y::Number) = *(promote(x,y)...)\n/(x::Number, y::Number) = /(promote(x,y)...)\n```\n\n----------------------------------------\n\nTITLE: Comparing and Performing Arithmetic on Characters in Julia\nDESCRIPTION: Illustrates comparison operators and arithmetic over character values, showing character case order, difference, and simple increments. The input is character literals and operations; output reveals logical and new character results.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> 'A' < 'a'\ntrue\n\njulia> 'A' <= 'a' <= 'Z'\nfalse\n\njulia> 'A' <= 'X' <= 'Z'\ntrue\n\njulia> 'x' - 'a'\n23\n\njulia> 'A' + 1\n'B': ASCII/Unicode U+0042 (category Lu: Letter, uppercase)\n```\n\n----------------------------------------\n\nTITLE: Finding All String/Regex Matches in Julia\nDESCRIPTION: A new method `findall(pattern, string)` allows finding all occurrences of a string or regular expression pattern within a given string.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_110\n\nLANGUAGE: julia\nCODE:\n```\nfindall(pattern::Union{String, Regex}, string::String)\n```\n\n----------------------------------------\n\nTITLE: Defining Numerical Abstract Types Hierarchy - Julia\nDESCRIPTION: This code block defines a hierarchy of numeric abstract types in Julia, structuring relationships among number-related types. It establishes foundational types like Number and Real, and refines them into more specific abstract types for floating point and (signed/unsigned) integer types. These declarations organize numerical types for better method specialization and code reuse, and are integral to Julia's standard library. There are no required dependencies; these are language core constructs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nabstract type Number end\nabstract type Real          <: Number end\nabstract type AbstractFloat <: Real end\nabstract type Integer       <: Real end\nabstract type Signed        <: Integer end\nabstract type Unsigned      <: Integer end\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Julia's Pass-by-Sharing Argument Behavior\nDESCRIPTION: Defines a function `f` to illustrate Julia's \"pass-by-sharing\" argument convention. The statement `x[1] = 42` modifies the mutable object referred to by `x`, making the change visible to the caller. The assignment `y = 7 + y` creates a new binding for `y` within the function, referencing a new value, and does not affect the original object passed by the caller.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(x, y)\n    x[1] = 42    # mutates x\n    y = 7 + y    # new binding for y, no mutation\n    return y\nend\n```\n\n----------------------------------------\n\nTITLE: Infinite Rationals and Their Types in Julia\nDESCRIPTION: Demonstrates creation of infinite rationals (with denominator 0) and inspection of their types using Julia's built-in Rational type. No external dependencies are necessary. Inputs are numerators with zero denominator; outputs are infinite rational values and their types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\njulia> 5//0\n1//0\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = -3//0\n-1//0\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> typeof(x)\nRational{Int64}\n```\n\n----------------------------------------\n\nTITLE: Propagating `missing` through Mathematical Operations in Julia\nDESCRIPTION: Demonstrates how standard mathematical operators (`+`, `*`) and functions (`abs`) propagate `missing` values. If any operand or argument is `missing`, the result is also `missing`, reflecting the uncertainty introduced by the missing value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_0\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> missing + 1\nmissing\n\njulia> \"a\" * missing\nmissing\n\njulia> abs(missing)\nmissing\n```\n\n----------------------------------------\n\nTITLE: Destructuring NamedTuples Using Property Syntax in Julia\nDESCRIPTION: Demonstrates assigning variables by property names from a NamedTuple using Julia's destructuring syntax with (; ...). This pattern assigns each variable on the left to the property of the expression on the right with the same name, leveraging getproperty. No dependencies required; works with standard NamedTuples and compatible structures. Inputs are NamedTuples or structs with properties matching variables in the destructuring. Output is that variables receive corresponding property values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\njulia> (; b, a) = (a=1, b=2, c=3)\n(a = 1, b = 2, c = 3)\n\njulia> a\n1\n\njulia> b\n2\n```\n\n----------------------------------------\n\nTITLE: Creating Basic and Typed Array Literals in Julia\nDESCRIPTION: Demonstrates creating 1D arrays (Vectors) in Julia using square bracket literals. Shows automatic element type determination based on common promotion types of the arguments (Int promotes to Float64 when mixed with Float64 or Rational). Also illustrates how to explicitly specify the element type using `T[...]` syntax (e.g., `Float32[...]`) and how an empty literal `[]` creates a `Vector{Any}`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_1\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [1, 2, 3] # An array of `Int`s\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> promote(1, 2.3, 4//5) # This combination of Int, Float64 and Rational promotes to Float64\n(1.0, 2.3, 0.8)\n\njulia> [1, 2.3, 4//5] # Thus that's the element type of this Array\n3-element Vector{Float64}:\n 1.0\n 2.3\n 0.8\n\njulia> Float32[1, 2.3, 4//5] # Specify element type manually\n3-element Vector{Float32}:\n 1.0\n 2.3\n 0.8\n\njulia> []\nAny[]\n```\n\n----------------------------------------\n\nTITLE: Including a Julia File and Calling Functions - Julia REPL\nDESCRIPTION: These REPL commands show how to include a Julia module file and invoke a module function. 'include(\"Tmp.jl\")' loads or refreshes the module code into the REPL session; 'Tmp.say_hello()' executes a function from the loaded module, demonstrating dynamic development cycles. This workflow presumes a correctly-defined Tmp.jl under the working directory. Output from say_hello is presented as an example.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/workflow-tips.md#_snippet_1\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> include(\"Tmp.jl\")\n\njulia> Tmp.say_hello()\nHello!\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing Named Tuples in Julia - Julia\nDESCRIPTION: Demonstrates named tuple construction, and access via integer index and by field name. Named tuples associate names to values, providing more readable data structures. No dependencies required. Construction uses the (name=value, ...) syntax. Input is pairs of names and values; outputs include named tuples and element access.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_18\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = (a=2, b=1+2)\n(a = 2, b = 3)\n\njulia> x[1]\n2\n\njulia> x.a\n2\n```\n\n----------------------------------------\n\nTITLE: Resolving Method Ambiguity in Julia (jldoctest)\nDESCRIPTION: This doctest shows how to resolve the method ambiguity demonstrated previously for function `g`. By defining a more specific method `g(x::Float64, y::Float64)` that handles the exact intersection case (`Float64`, `Float64`), Julia now has a unique, most specific method to dispatch to when called with `g(2.0, 3.0)`. This resolves the ambiguity and allows the call to execute successfully.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_14\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> g(x::Float64, y::Float64) = 2x + 2y\ng (generic function with 3 methods)\n\njulia> g(2.0, 3)\n7.0\n\njulia> g(2, 3.0)\n8.0\n\njulia> g(2.0, 3.0)\n10.0\n```\n\n----------------------------------------\n\nTITLE: Simulating File Execution of Summation Loop Showing Ambiguity Warning (Julia)\nDESCRIPTION: Demonstrates executing the summation code as if it were in a file, using `include_string` within a `jldoctest`. In this non-interactive context, the assignment `s = t` inside the loop is ambiguous because a global variable `s` already exists. Julia resolves this by treating `s` inside the loop as a *new* local variable, emitting a warning. This leads to an `UndefVarError` when `t = s + i` is evaluated, as the local `s` hasn't been assigned yet.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_13\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> code = \"\"\"\n       s = 0 # global\n       for i = 1:10\n           t = s + i # new local `t`\n           s = t # new local `s` with warning\n       end\n       s, # global\n       @isdefined(t) # global\n       \"\"\"\n\njulia> include_string(Main, code)\n┌ Warning: Assignment to `s` in soft scope is ambiguous because a global variable by the same name exists: `s` will be treated as a new local. Disambiguate by using `local s` to suppress this warning or `global s` to assign to the existing global variable.\n└ @ string:4\nERROR: LoadError: UndefVarError: `s` not defined in local scope\n```\n\n----------------------------------------\n\nTITLE: Incorrect Piping with Anonymous Function due to Operator Precedence in Julia\nDESCRIPTION: Contrasts with the previous example, showing incorrect behavior when parentheses are omitted around the anonymous function in a pipe chain. Without parentheses, `x -> x^2 |> sum |> sqrt` is parsed as an anonymous function whose body includes the pipes, leading to unexpected results when broadcasted.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_40\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> 1:3 .|> x -> x^2 |> sum |> sqrt\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n```\n\n----------------------------------------\n\nTITLE: Piping Output with `|>` Operator in Julia\nDESCRIPTION: Shows function chaining or piping in Julia using the `|>` operator. The output of the expression on the left (`1:10 |> sum`) is passed as the input to the function on the right (`sqrt`). This calculates the square root of the sum of numbers from 1 to 10.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_36\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> 1:10 |> sum |> sqrt\n7.416198487095663\n```\n\n----------------------------------------\n\nTITLE: Modifying Mutable Arguments within Julia Functions\nDESCRIPTION: Demonstrates Julia's pass-by-sharing with mutable types. When a mutable object (like a `Vector`) is passed to a function, modifying the *contents* of the object via the function parameter (`A[1] = 5`) affects the original object (`x`), because both the external variable `x` and the internal parameter `A` refer to the same underlying mutable data structure.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_6\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> function change_array!(A)\n           A[1] = 5\n       end\nchange_array! (generic function with 1 method)\n\njulia> change_array!(x)\n5\n\njulia> x\n3-element Vector{Int64}:\n 5\n 2\n 3\n```\n\n----------------------------------------\n\nTITLE: Checking Membership in Sorted Collections with `insorted` in Julia\nDESCRIPTION: The `insorted(element, collection)` function efficiently determines if `element` is present within a `collection` that is assumed to be sorted. It typically uses binary search or similar optimized algorithms.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_69\n\nLANGUAGE: julia\nCODE:\n```\nsorted_vec = [10, 20, 30, 40, 50]\ninsorted(30, sorted_vec) # Returns true\ninsorted(35, sorted_vec) # Returns false\n```\n\n----------------------------------------\n\nTITLE: Using a Julia Struct with an Inner Constructor Invariant\nDESCRIPTION: Demonstrates the usage of the `OrderedPair` struct with its inner constructor invariant. It shows a successful instantiation (`OrderedPair(1, 2)`) where the condition `x <= y` holds, and an unsuccessful attempt (`OrderedPair(2, 1)`) that triggers the error defined within the inner constructor.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> OrderedPair(1, 2)\nOrderedPair(1, 2)\n\njulia> OrderedPair(2,1)\nERROR: out of order\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] OrderedPair(::Int64, ::Int64) at ./none:4\n [3] top-level scope\n```\n\n----------------------------------------\n\nTITLE: Parsing Dates Using DateFormat and Broadcasting - Julia Dates Module - Julia\nDESCRIPTION: These code snippets illustrate parsing date strings into Date objects in Julia with different techniques, including direct constructor calls with the dateformat string macro, explicit DateFormat objects, and broadcasting over arrays. Dependencies are only the Dates module. Key parameters include the date string, the DateFormat (created via the macro or constructor), and, for broadcasting, a vector of date strings. Outputs are new Date instances or vectors thereof. Passing an empty string will throw an ArgumentError.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> for i = 1:10^5\n           Date(\"2015-01-01\", dateformat\"y-m-d\")\n       end\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> df = DateFormat(\"y-m-d\");\n\njulia> dt = Date(\"2015-01-01\",df)\n2015-01-01\n\njulia> dt2 = Date(\"2015-01-02\",df)\n2015-01-02\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> years = [\"2015\", \"2016\"];\n\njulia> Date.(years, DateFormat(\"yyyy\"))\n2-element Vector{Date}:\n 2015-01-01\n 2016-01-01\n```\n\n----------------------------------------\n\nTITLE: Enumerating Method Signatures with the methods Function (Julia)\nDESCRIPTION: This code shows the usage of the 'methods' function in Julia to enumerate all available methods for a given function object. It returns the list of defined method signatures matching the function's name, aiding debugging and introspection. There are no dependencies besides having the function defined.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> methods(f)\n```\n\n----------------------------------------\n\nTITLE: Partial (Omitted) and Over-Indexed Access in Multidimensional Julia Arrays\nDESCRIPTION: This code illustrates how Julia handles omitted and extra indices in multidimensional arrays. Specifically, it shows array creation with reshape, omission of trailing indices if dimensions are one, and failed access if omitted indices skip dimensions with length greater than one. Also demonstrates linear indexing and accessing vectors as if they're two-dimensional. Limitations: Omitted indices must correspond to size-one trailing dimensions; over-indexing only works when extra indices are the first element.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\njulia> A = reshape(1:24, 3, 4, 2, 1)\n3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64:\n[:, :, 1, 1] =\n 1  4  7  10\n 2  5  8  11\n 3  6  9  12\n\n[:, :, 2, 1] =\n 13  16  19  22\n 14  17  20  23\n 15  18  21  24\n\njulia> A[1, 3, 2] # Omits the fourth dimension (length 1)\n19\n\njulia> A[1, 3] # Attempts to omit dimensions 3 & 4 (lengths 2 and 1)\nERROR: BoundsError: attempt to access 3×4×2×1 reshape(::UnitRange{Int64}, 3, 4, 2, 1) with eltype Int64 at index [1, 3]\n\njulia> A[19] # Linear indexing\n19\n\njulia> A = [8, 6, 7]\n3-element Vector{Int64}:\n 8\n 6\n 7\n\njulia> A[2, 1]\n6\n```\n\n----------------------------------------\n\nTITLE: Error Handling for Out-of-Bounds String Indexing in Julia\nDESCRIPTION: Illustrates that accessing a string outside valid index bounds throws a `BoundsError`, including informative diagnostics. Inputs are out-of-range indices; outputs are error messages with context.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> str[begin-1]\nERROR: BoundsError: attempt to access 14-codeunit String at index [0]\n[...]\n\njulia> str[end+1]\nERROR: BoundsError: attempt to access 14-codeunit String at index [15]\n[...]\n```\n\n----------------------------------------\n\nTITLE: Checking UTF-8 Validity of Byte Array Content in Julia\nDESCRIPTION: Shows the use of the `isvalid` function to check if a string containing mixed byte and UTF-8 sequences forms a valid UTF-8 string. The example uses the byte sequence from the previous snippet, which includes `\\xff`, resulting in `false` because `0xff` is not a valid start byte in UTF-8.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_58\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> isvalid(\"DATA\\xff\\u2200\")\nfalse\n```\n\n----------------------------------------\n\nTITLE: Safely Accessing Global State in Precompiled Julia Modules\nDESCRIPTION: Shows incorrect and correct ways to reference global state (e.g., `Base.stdout`) from another module within a precompiled module. Directly assigning the global variable (`mystdout = Base.stdout`) captures the potentially incorrect compile-time value. Recommended solutions are using an accessor function (`getstdout()`) which fetches the current value at runtime, or performing the assignment within the `__init__()` function to ensure the runtime value is captured after the module loads.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\n#mystdout = Base.stdout #= will not work correctly, since this will copy Base.stdout into this module =#\n# instead use accessor functions:\ngetstdout() = Base.stdout #= best option =#\n# or move the assignment into the runtime:\n__init__() = global mystdout = Base.stdout #= also works =#\n```\n\n----------------------------------------\n\nTITLE: Declaring Global Constants in Julia\nDESCRIPTION: Illustrates how to declare a global constant in Julia using the `const` keyword. Declaring global variables as constants allows the Julia compiler to make significant performance optimizations because the variable's type and value are known and fixed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nconst DEFAULT_VAL = 0\n```\n```\n\n----------------------------------------\n\nTITLE: Type Subtyping Using Parametric Abstract Types in Julia\nDESCRIPTION: Demonstrates Julia subtyping with parametric abstract types, showing that Pointy{T} for any T (including both types and values) is always a subtype of either its parametric family (e.g. Pointy) or, under appropriate constraints, a specific instance. The code makes use of simple subtype (`<:`) queries and returns boolean results, showing the effect of parameter values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\njulia> Pointy{Int64} <: Pointy\ntrue\n\njulia> Pointy{1} <: Pointy\ntrue\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Varargs and Splatting in Julia Functions\nDESCRIPTION: Demonstrates creating functions that accept a variable number of arguments (varargs) using the ellipsis syntax (...), and calling such functions with argument splatting. No special dependencies, works with all Julia collections and iterables. The function 'bar' takes two fixed arguments and a variable rest, returning a tuple. Examples show different input forms including tuples and arrays, as well as splatting into functions with and without varargs signatures. Incorrect argument counts when splatting result in method errors. Outputs depend on function but often return tuples showing fixed and rest arguments.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\njulia> bar(a, b, x...) = (a, b, x)\nbar (generic function with 1 method)\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> bar(1, 2)\n(1, 2, ())\n\njulia> bar(1, 2, 3)\n(1, 2, (3,))\n\njulia> bar(1, 2, 3, 4)\n(1, 2, (3, 4))\n\njulia> bar(1, 2, 3, 4, 5, 6)\n(1, 2, (3, 4, 5, 6))\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = (3, 4)\n(3, 4)\n\njulia> bar(1, 2, x...)\n(1, 2, (3, 4))\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = (2, 3, 4)\n(2, 3, 4)\n\njulia> bar(1, x...)\n(1, 2, (3, 4))\n\njulia> x = (1, 2, 3, 4)\n(1, 2, 3, 4)\n\njulia> bar(x...)\n(1, 2, (3, 4))\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = [3, 4]\n2-element Vector{Int64}:\n 3\n 4\n\njulia> bar(1, 2, x...)\n(1, 2, (3, 4))\n\njulia> x = [1, 2, 3, 4]\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> bar(x...)\n(1, 2, (3, 4))\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> baz(a, b) = a + b;\n\njulia> args = [1, 2]\n2-element Vector{Int64}:\n 1\n 2\n\njulia> baz(args...)\n3\n\njulia> args = [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> baz(args...)\nERROR: MethodError: no method matching baz(::Int64, ::Int64, ::Int64)\nThe function `baz` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  baz(::Any, ::Any)\n   @ Main none:1\n\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Chained Assignment and Expression Evaluation - Julia Doctest - Julia\nDESCRIPTION: This snippet showcases how chained assignment works in Julia, with the result of one assignment directly used in another expression. It highlights Julia's evaluation model where assignments return the assigned value and can be composed with further operations. The test uses only base Julia features with integer arithmetic.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> a = (b = 2+2) + 3\\n7\\n\\njulia> a\\n7\\n\\njulia> b\\n4\n```\n\n----------------------------------------\n\nTITLE: Chained Comparison Evaluation and Short-Circuiting - Julia\nDESCRIPTION: This snippet demonstrates Julia's ability to chain comparison operators and shows how evaluation order affects side effects. Defines a function 'v(x)' that prints and returns its input, then uses it in chained comparisons to illustrate evaluation order. No external dependencies beyond Julia base. Inputs are integers, outputs include printed side effects and resulting boolean values. The behavior warns about using expressions with side effects in chained comparisons.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> v(x) = (println(x); x)\nv (generic function with 1 method)\n\njulia> v(1) < v(2) <= v(3)\n2\n1\n3\ntrue\n\njulia> v(1) > v(2) <= v(3)\n2\n1\nfalse\n```\n\n----------------------------------------\n\nTITLE: Using the :: Operator for Type Assertions in Julia\nDESCRIPTION: This Julia snippet demonstrates how to use the :: operator to assert that the result of an expression is of a particular type. An error is thrown if the assertion fails; otherwise the value is returned as-is. This technique is helpful for runtime type checking and can catch errors caused by incorrect types. No external dependencies are required; it is built into the Julia language.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> (1+2)::AbstractFloat\nERROR: TypeError: in typeassert, expected AbstractFloat, got a value of type Int64\n\njulia> (1+2)::Int\n3\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with try/catch and Sequential Code - Julia\nDESCRIPTION: Defines verbose_fussy_sqrt, a function that demonstrates control flow around error-prone code. It prints a message before and after attempting to compute a square root, but only proceeds if no exception is raised. Dependencies are base Julia and previously defined fussy_sqrt; demonstrates error propagation and program halt on error.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\njulia> function verbose_fussy_sqrt(x)\n           println(\"before fussy_sqrt\")\n           r = fussy_sqrt(x)\n           println(\"after fussy_sqrt\")\n           return r\n       end\nverbose_fussy_sqrt (generic function with 1 method)\n\njulia> verbose_fussy_sqrt(2)\nbefore fussy_sqrt\nafter fussy_sqrt\n1.4142135623730951\n\njulia> verbose_fussy_sqrt(-1)\nbefore fussy_sqrt\nERROR: negative x not allowed\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] fussy_sqrt at ./none:1 [inlined]\n [3] verbose_fussy_sqrt(::Int64) at ./none:3\n [4] top-level scope\n\n```\n\n----------------------------------------\n\nTITLE: Using try/catch for Graceful Exception Handling - Julia\nDESCRIPTION: This example demonstrates basic usage of try/catch to intercept exceptions. If sqrt is called with a non-numeric argument, the exception is caught and a user message is printed instead of halting execution. No external dependencies. Inputs expected: numeric types; outputs: printed user guidance on error.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\njulia> try\n           sqrt(\"ten\")\n       catch e\n           println(\"You should have entered a numeric value\")\n       end\nYou should have entered a numeric value\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Julia and Evaluating a String in C\nDESCRIPTION: Demonstrates the basic steps to embed Julia in a C program: include the header (`julia.h`), initialize the Julia runtime (`jl_init`), execute a Julia command as a string (`jl_eval_string`), and perform cleanup before exiting (`jl_atexit_hook`). Requires linking against `libjulia`. The `JULIA_DEFINE_FAST_TLS` macro is recommended for performance in executables.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <julia.h>\nJULIA_DEFINE_FAST_TLS // only define this once, in an executable (not in a shared library) if you want fast code.\n\nint main(int argc, char *argv[])\n{\n    /* required: setup the Julia context */\n    jl_init();\n\n    /* run Julia commands */\n    jl_eval_string(\"print(sqrt(2.0))\");\n\n    /* strongly recommended: notify Julia that the\n         program is about to terminate. this allows\n         Julia time to cleanup pending write requests\n         and run all finalizers\n    */\n    jl_atexit_hook(0);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Julia Array with Concrete Type `Float64`\nDESCRIPTION: Contrasts the abstract type example by creating a `Vector` parameterized with the concrete type `Float64`. When elements are pushed, they are converted to `Float64`. This allows Julia to store the array as a contiguous block of memory containing 64-bit floating-point values, enabling more efficient operations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_11\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> a = Float64[]\nFloat64[]\n\njulia> push!(a, 1); push!(a, 2.0); push!(a,  π)\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.141592653589793\n```\n\n----------------------------------------\n\nTITLE: Multiple Dispatch Among Several Methods (Julia)\nDESCRIPTION: This snippet shows function 'f' with two methods (one for Float64,Float64 and another for Number,Number) being called with various argument type combinations. It demonstrates Julia's multiple dispatch mechanism, selecting the most specific applicable method at runtime. The snippet's inputs include different combinations of Ints and Floats, and outputs show appropriate results or fallbacks.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(2.0, 3.0)\n7.0\n\njulia> f(2, 3.0)\n1.0\n\njulia> f(2.0, 3)\n1.0\n\njulia> f(2, 3)\n1\n```\n\n----------------------------------------\n\nTITLE: Basic String Interpolation using $ in Julia\nDESCRIPTION: Demonstrates how to embed the values of variables (`greet`, `whom`) directly into a string literal using the `$` symbol prefix. The system implicitly rewrites this into a `string()` call, providing a convenient way to construct strings from variables.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_25\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> greet = \"Hello\"; whom = \"world\";\n\njulia> \"$greet, $whom.\\n\"\n\"Hello, world.\\n\"\n```\n\n----------------------------------------\n\nTITLE: Distributing and Parallelizing Array Operations with DistributedArrays.jl and CUDA.jl (Julia)\nDESCRIPTION: This Julia REPL session walks through setting up a Julia process with multiple workers, importing DistributedArrays and CUDA packages, creating and operating on local, distributed, and GPU-backed arrays. Key functions include distribute for splitting an array across processes, and CuArray for moving data to a CUDA GPU. All operations are demonstrated using elementwise arithmetic, equality checks, and type verification. Dependencies: DistributedArrays.jl, CUDA.jl, a compatible CUDA device. Inputs are arrays of Float64; outputs are results of array operations and their types. Requires running Julia with parallel processes and GPU support.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_44\n\nLANGUAGE: julia-repl\nCODE:\n```\n$ ./julia -p 4\n\njulia> addprocs()\n\njulia> @everywhere using DistributedArrays\n\njulia> using CUDA\n\njulia> B = ones(10_000) ./ 2;\n\njulia> A = ones(10_000) .* π;\n\njulia> C = 2 .* A ./ B;\n\njulia> all(C .≈ 4*π)\ntrue\n\njulia> typeof(C)\nVector{Float64} (alias for Array{Float64, 1})\n\njulia> dB = distribute(B);\n\njulia> dA = distribute(A);\n\njulia> dC = 2 .* dA ./ dB;\n\njulia> all(dC .≈ 4*π)\ntrue\n\njulia> typeof(dC)\nDistributedArrays.DArray{Float64,1,Vector{Float64}}\n\njulia> cuB = CuArray(B);\n\njulia> cuA = CuArray(A);\n\njulia> cuC = 2 .* cuA ./ cuB;\n\njulia> all(cuC .≈ 4*π);\ntrue\n\njulia> typeof(cuC)\nCuArray{Float64,1}\n```\n\n----------------------------------------\n\nTITLE: Testing for Special Numeric Values with isequal, isfinite, isinf, and isnan - Julia\nDESCRIPTION: This snippet demonstrates the use of 'isequal' in Julia to test for numerical equivalence even between NaN values and distinguish signed zeros. Also shows type-flexibility between NaN and NaN32. No external dependencies are required. Inputs are various numeric values; outputs are booleans showing the result of 'isequal' for each pair. This aids in robust numeric comparisons.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> isequal(NaN, NaN)\ntrue\n\njulia> isequal([1 NaN], [1 NaN])\ntrue\n\njulia> isequal(NaN, NaN32)\ntrue\n```\n\n----------------------------------------\n\nTITLE: Using @main Macro for Automatic Entry Point Execution (Bash/Julia)\nDESCRIPTION: Demonstrates the Julia 1.11+ `@main` macro for defining an application entry point. It defines a `main` function inline using `-e` and applies the `@main` macro to it. Because `@main` is used, Julia automatically executes `Main.main(Base.ARGS)` after the expression is evaluated, printing \"Hello World!\". This provides a standardized way to define executable scripts.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ julia -e '(@main)(args) = println(\"Hello World!\")'\n```\n\n----------------------------------------\n\nTITLE: Using `convert` for Type Conversion in Julia\nDESCRIPTION: Demonstrates basic type conversion using the `convert` function in Julia. It shows converting an `Int64` to `UInt8`, `AbstractFloat` (which results in `Float64`), and converting an `Array{Any}` to `Array{Float64}`. Includes checks using `typeof`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_0\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = 12\n12\n\njulia> typeof(x)\nInt64\n\njulia> xu = convert(UInt8, x)\n0x0c\n\njulia> typeof(xu)\nUInt8\n\njulia> xf = convert(AbstractFloat, x)\n12.0\n\njulia> typeof(xf)\nFloat64\n\njulia> a = Any[1 2 3; 4 5 6]\n2×3 Matrix{Any}:\n 1  2  3\n 4  5  6\n\njulia> convert(Array{Float64}, a)\n2×3 Matrix{Float64}:\n 1.0  2.0  3.0\n 4.0  5.0  6.0\n```\n\n----------------------------------------\n\nTITLE: Applying All Performance Macros for Numerical Derivatives in Julia\nDESCRIPTION: Presents the combined usage of @fastmath, @inbounds, and @simd macros to optimize finite difference calculations and norm computation over vectors. The included functions initialize, compute derivatives, and calculate the norm of arrays, with performance measured in a main loop using @time. Output demonstrates raw speed and result accuracy, depending on math mode. Dependencies: Standard Julia, including array constructors and @time. Inputs: vector length and data; outputs: L2 norm and timings. Limitations: performance and numeric results may vary by hardware and configuration; unsafe if invariant macro requirements are not met.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_59\n\nLANGUAGE: julia\nCODE:\n```\nfunction init!(u::Vector)\n    n = length(u)\n    dx = 1.0 / (n-1)\n    @fastmath @inbounds @simd for i in 1:n #by asserting that `u` is a `Vector` we can assume it has 1-based indexing\n        u[i] = sin(2pi*dx*i)\n    end\nend\n\nfunction deriv!(u::Vector, du)\n    n = length(u)\n    dx = 1.0 / (n-1)\n    @fastmath @inbounds du[1] = (u[2] - u[1]) / dx\n    @fastmath @inbounds @simd for i in 2:n-1\n        du[i] = (u[i+1] - u[i-1]) / (2*dx)\n    end\n    @fastmath @inbounds du[n] = (u[n] - u[n-1]) / dx\nend\n\nfunction mynorm(u::Vector)\n    n = length(u)\n    T = eltype(u)\n    s = zero(T)\n    @fastmath @inbounds @simd for i in 1:n\n        s += u[i]^2\n    end\n    @fastmath @inbounds return sqrt(s)\nend\n\nfunction main()\n    n = 2000\n    u = Vector{Float64}(undef, n)\n    init!(u)\n    du = similar(u)\n\n    deriv!(u, du)\n    nu = mynorm(du)\n\n    @time for i in 1:10^6\n        deriv!(u, du)\n        nu = mynorm(du)\n    end\n\n    println(nu)\nend\n\nmain()\n\n```\n\n----------------------------------------\n\nTITLE: Separating Conversion and Computation Logic in Julia\nDESCRIPTION: Demonstrates a pattern in Julia where function logic is split into two methods. One method handles type conversion or promotion (e.g., using `convert` or `promote`), and the other performs the core computation on the expected type(s). This aids compiler optimization and reduces complexity.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\ncomplexfunction(arg::Int) = ...\ncomplexfunction(arg::Any) = complexfunction(convert(Int, arg))\n\nmatmul(a::T, b::T) = ...\nmatmul(a, b) = matmul(promote(a, b)...)\n```\n\n----------------------------------------\n\nTITLE: Using @lock Macro for Thread-Safe Mutation in Julia\nDESCRIPTION: Demonstrates the use of the `@lock` macro with a `ReentrantLock` to ensure thread-safe mutation of a shared array (`my_variable`). The macro automatically acquires the lock before executing the expression and releases it afterwards, preventing data races.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_18\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> my_lock = ReentrantLock();\n\njulia> my_variable = [1, 2, 3];\n\njulia> @lock my_lock my_variable[1] = 100\n100\n```\n\n----------------------------------------\n\nTITLE: Comparing Non-Atomic vs Atomic Increments in Julia Threads\nDESCRIPTION: Contrasts a non-thread-safe increment operation using `Ref` within a `@threads` loop, which leads to a race condition and an incorrect final sum, with a thread-safe version using `Atomic{Int64}` and `atomic_add!`, which produces the correct result by ensuring atomic updates.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_21\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Base.Threads\n\njulia> Threads.nthreads()\n4\n\njulia> acc = Ref(0)\nBase.RefValue{Int64}(0)\n\njulia> @threads for i in 1:1000\n          acc[] += 1\n       end\n\njulia> acc[]\n926\n\njulia> acc = Atomic{Int64}(0)\nAtomic{Int64}(0)\n\njulia> @threads for i in 1:1000\n          atomic_add!(acc, 1)\n       end\n\njulia> acc[]\n1000\n```\n\n----------------------------------------\n\nTITLE: Demonstrating bar Function Usage - Julia REPL - Julia\nDESCRIPTION: This snippet illustrates how to call the bar function in the Julia REPL, passing two arrays [1, 2] as arguments and observing the result. No dependencies are required other than the definition of bar itself. The input consists of the two integer lists; the output is the result of bar for those inputs, shown as 1 in this example.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_4\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> bar([1, 2], [1, 2])\n1\n```\n\n----------------------------------------\n\nTITLE: Ensuring Type Stability of Variables in Loops - Julia\nDESCRIPTION: Highlights a performance anti-pattern where a local variable in a function changes type in a loop (from Int to Float64). Initializes x as 1 (an Int), but divides by rand() (a Float64), so x changes type on the first iteration. Demonstrates the need to initialize variables with the correct type to maintain type stability for compiler optimizations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nfunction foo()\n    x = 1\n    for i = 1:10\n        x /= rand()\n    end\n    return x\nend\n```\n\n----------------------------------------\n\nTITLE: Using nextfloat and prevfloat for Adjacent Representable Floating-Point Values (Julia)\nDESCRIPTION: Shows how to find the next and previous representable floating-point numbers using nextfloat and prevfloat, and how these relate to the underlying binary representation using bitstring. This is useful for ULP computations and floating-point analysis. No external dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = 1.25f0\n1.25f0\n\njulia> nextfloat(x)\n1.2500001f0\n\njulia> prevfloat(x)\n1.2499999f0\n\njulia> bitstring(prevfloat(x))\n\"00111111100111111111111111111111\"\n\njulia> bitstring(x)\n\"00111111101000000000000000000000\"\n\njulia> bitstring(nextfloat(x))\n\"00111111101000000000000000000001\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Exception with Fields and showerror Override - Julia\nDESCRIPTION: Defines a custom exception MyUndefVarError carrying additional information (the missing variable's symbol), and customizes its error message by overriding Base.showerror. This pattern allows refined diagnostic messages for domain-specific errors. Base Julia is required; fields should be supplied to constructors, and showerror must match the intended format.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\njulia> struct MyUndefVarError <: Exception\n           var::Symbol\n       end\n\njulia> Base.showerror(io::IO, e::MyUndefVarError) = print(io, e.var, \" not defined\")\n\n```\n\n----------------------------------------\n\nTITLE: Parallel Job Processing with Channels and Tasks in Julia REPL\nDESCRIPTION: Implements a parallel producer-consumer queue in Julia using channels and tasks, with jobs and results coordinating via two separate channels. Dependencies include Channel, put!, take!, Threads.@spawn, errormonitor, @elapsed, and random/sleep functions. make_jobs sends job ids to 'jobs'; do_work processes jobs by simulating random execution time, sending results as tuples to 'results.' The main loop spawns four workers, feeds jobs, and collects results including their timings. The snippet reports execution for all jobs and demonstrates parallel task coordination and synchronization.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/asynchronous-programming.md#_snippet_9\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> const jobs = Channel{Int}(32);\n\njulia> const results = Channel{Tuple}(32);\n\njulia> function do_work()\n           for job_id in jobs\n               exec_time = rand()\n               sleep(exec_time)                # simulates elapsed time doing actual work\n                                               # typically performed externally.\n               put!(results, (job_id, exec_time))\n           end\n       end;\n\njulia> function make_jobs(n)\n           for i in 1:n\n               put!(jobs, i)\n           end\n       end;\n\njulia> n = 12;\n\njulia> errormonitor(Threads.@spawn make_jobs(n)); # feed the jobs channel with \"n\" jobs\n\njulia> for i in 1:4 # start 4 tasks to process requests in parallel\n           errormonitor(Threads.@spawn do_work())\n       end\n\njulia> @elapsed while n > 0 # print out results\n           job_id, exec_time = take!(results)\n           println(\"$job_id finished in $(round(exec_time; digits=2)) seconds\")\n           global n = n - 1\n       end\n4 finished in 0.22 seconds\n3 finished in 0.45 seconds\n1 finished in 0.5 seconds\n7 finished in 0.14 seconds\n2 finished in 0.78 seconds\n5 finished in 0.9 seconds\n9 finished in 0.36 seconds\n6 finished in 0.87 seconds\n8 finished in 0.79 seconds\n10 finished in 0.64 seconds\n12 finished in 0.5 seconds\n11 finished in 0.97 seconds\n0.029772311\n```\n\n----------------------------------------\n\nTITLE: Querying Field Names of a Composite Type in Julia\nDESCRIPTION: Demonstrates obtaining the field names of a struct type using the fieldnames function. Input is the type Foo, output is a tuple of symbols representing the field names. This is a standard Julia reflection facility with no external dependencies and requires only the prior typedef.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nfieldnames(Foo)\n(:bar, :baz, :qux)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Precompilation Pitfall with Global Counters in Julia\nDESCRIPTION: Demonstrates a common precompilation issue where a global counter, implemented using a `let` block within a `mutable struct` definition, gets its value frozen during compilation. Consequently, every time the precompiled module is loaded, the counter resets to its compile-time value instead of continuing incrementation, failing to generate unique IDs across program runs or sessions. This highlights the need to avoid relying on mutable global state captured at compile time for such purposes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nmutable struct UniquedById\n    myid::Int\n    let counter = 0\n        UniquedById() = new(counter += 1)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Column-Major vs. Row-Major Access Performance in Julia\nDESCRIPTION: Times the execution of the four array copying functions (`copy_cols`, `copy_rows`, `copy_col_row`, `copy_row_col`) defined previously. The results demonstrate that accessing matrix elements column by column (`copy_cols`, `copy_col_row`) is significantly faster due to Julia's column-major memory layout.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_52\n\nLANGUAGE: julia-repl\nCODE:\n```\n```julia-repl\njulia> x = randn(10000);\n\njulia> fmt(f) = println(rpad(string(f)*\": \", 14, ' '), @elapsed f(x))\n\njulia> map(fmt, [copy_cols, copy_rows, copy_col_row, copy_row_col]);\ncopy_cols:    0.331706323\ncopy_rows:    1.799009911\ncopy_col_row: 0.415630047\ncopy_row_col: 1.721531501\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Loops with Cartesian Product Syntax in Julia\nDESCRIPTION: Demonstrates Julia's shorthand syntax for creating nested loops by separating the iterables with a comma (`for i = 1:2, j = 3:4`). This construct iterates through the Cartesian product of the specified ranges. The inner loop (over `j`) runs completely for each iteration of the outer loop (over `i`), printing all combinations of `(i, j)`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_24\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for i = 1:2, j = 3:4\n           println((i, j))\n       end\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)\n```\n\n----------------------------------------\n\nTITLE: Implementing sub2ind via Looping (Julia)\nDESCRIPTION: Implements the sub2ind_loop function, which takes a tuple of dimensions and n integer indices, and returns the 1-based linear offset for the n-dimensional indices into a flat array. Uses a runtime loop to accumulate the offset. Inputs: dims (NTuple), I... (indices); Output: linear index; Limitations: expects all indices present, minimal error checking. No external dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_72\n\nLANGUAGE: julia\nCODE:\n```\nfunction sub2ind_loop(dims::NTuple{N}, I::Integer...) where N\n    ind = I[N] - 1\n    for i = N-1:-1:1\n        ind = I[i]-1 + dims[i]*ind\n    end\n    return ind + 1\nend;\n\nsub2ind_loop((3, 5), 1, 2)\n4\n```\n\n----------------------------------------\n\nTITLE: Accessing Stack Frame Information in Julia\nDESCRIPTION: Shows how to retrieve a specific `StackFrame` from the result of `stacktrace()` and access its individual fields. These fields provide detailed information about the frame, including the function name (`func`), file path (`file`), line number (`line`), lambda info (`linfo`), inlining status (`inlined`), C function flag (`from_c`), and pointer value (`pointer`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_3\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> frame = stacktrace()[3]\neval(::Module, ::Expr) at REPL.jl:5\n\njulia> frame.func\n:eval\n\njulia> frame.file\nSymbol(\"~/julia/usr/share/julia/stdlib/v0.7/REPL/src/REPL.jl\")\n\njulia> frame.line\n5\n\njulia> frame.linfo\nMethodInstance for eval(::Module, ::Expr)\n\njulia> frame.inlined\nfalse\n\njulia> frame.from_c\nfalse\n\njulia> frame.pointer\n0x00007f92d6293171\n```\n\n----------------------------------------\n\nTITLE: Generating Methods Dynamically using eval and quote in Julia\nDESCRIPTION: Demonstrates programmatic code generation in Julia. A loop iterates through a list of mathematical function symbols (`:sin`, `:cos`, etc.). Inside the loop, `eval(quote(...))` is used to construct and evaluate code that defines a new method for each function (e.g., `Base.sin`) specialized for the `MyNumber` struct. The generated methods apply the corresponding `Base` function to the `x` field of the `MyNumber` instance.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_50\n\nLANGUAGE: jldoctest\nCODE:\n```\nfor op = (:sin, :cos, :tan, :log, :exp)\n    eval(quote\n        Base.$op(a::MyNumber) = MyNumber($op(a.x))\n    end)\nend\n# output\n```\n\n----------------------------------------\n\nTITLE: Using the Ternary Operator for Conditional Selection - Julia\nDESCRIPTION: Demonstrates Julia's ternary operator 'a ? b : c' for choosing between two expressions based on a boolean condition. Variables x and y are compared, and an appropriate message is printed. The snippet illustrates straightforward conditional value selection in a single expression.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = 1; y = 2;\n\njulia> println(x < y ? \"less than\" : \"not less than\")\nless than\n\njulia> x = 1; y = 0;\n\njulia> println(x < y ? \"less than\" : \"not less than\")\nnot less than\n```\n\n----------------------------------------\n\nTITLE: Defining an IndexCartesian AbstractArray (SparseArray) in Julia\nDESCRIPTION: Defines a custom N-dimensional `SparseArray` subtype using a `Dict` for storage. It implements `size`, `similar`, `getindex`, and `setindex!` for Cartesian indexing (`IndexCartesian`), as required for this style. `getindex` defaults to returning `zero(T)` for elements not explicitly stored in the dictionary, mimicking sparse behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_16\n\nLANGUAGE: jldoctest squarevectype\nCODE:\n```\njulia> struct SparseArray{T,N} <: AbstractArray{T,N}\n           data::Dict{NTuple{N,Int}, T}\n           dims::NTuple{N,Int}\n       end\n\njulia> SparseArray(::Type{T}, dims::Int...) where {T} = SparseArray(T, dims);\n\njulia> SparseArray(::Type{T}, dims::NTuple{N,Int}) where {T,N} = SparseArray{T,N}(Dict{NTuple{N,Int}, T}(), dims);\n\njulia> Base.size(A::SparseArray) = A.dims\n\njulia> Base.similar(A::SparseArray, ::Type{T}, dims::Dims) where {T} = SparseArray(T, dims)\n\njulia> Base.getindex(A::SparseArray{T,N}, I::Vararg{Int,N}) where {T,N} = get(A.data, I, zero(T))\n\njulia> Base.setindex!(A::SparseArray{T,N}, v, I::Vararg{Int,N}) where {T,N} = (A.data[I] = v)\n```\n\n----------------------------------------\n\nTITLE: Creating Vector using Julia Nested Comprehension with Dependent Ranges\nDESCRIPTION: Illustrates a Julia array comprehension with nested `for` loops. The inner loop's range (`j=1:i`) depends on the current value of the outer loop variable (`i`). The expression generates a 1-dimensional `Vector` containing tuples `(i, j)` for `i` from 1 to 3 and `j` from 1 to `i`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_16\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [(i, j) for i=1:3 for j=1:i]\n6-element Vector{Tuple{Int64, Int64}}:\n (1, 1)\n (2, 1)\n (2, 2)\n (3, 1)\n (3, 2)\n (3, 3)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Automatic Method Specialization in Julia REPL\nDESCRIPTION: This REPL session shows calls to the `mysum` function (defined previously) with different specific argument types (`Int` and `Float64`). Although only one method was defined for `mysum(::Real, ::Real)`, Julia's compiler automatically generates specialized, efficient code versions for `(Int, Int)` and `(Float64, Float64)` at compile time, which is reflected in the specific return types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_12\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> mysum(1, 2)\n3\n\njulia> mysum(1.0, 2.0)\n3.0\n```\n\n----------------------------------------\n\nTITLE: Initializing Arrays Using zeros Function in Julia Language\nDESCRIPTION: Demonstrates how to initialize two-dimensional arrays with different element types using Julia's zeros function. The examples show variant calling conventions: explicitly specifying the element type and dimensions as separate arguments, passing dimensions as a tuple, and omitting the element type to default to Float64. No external dependencies are required. The main parameter is dimensions (either as separate arguments or a tuple) and, optionally, the element type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> zeros(Int8, 2, 3)\n2×3 Matrix{Int8}:\n 0  0  0\n 0  0  0\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> zeros(Int8, (2, 3))\n2×3 Matrix{Int8}:\n 0  0  0\n 0  0  0\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> zeros((2, 3))\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing Tuples in Julia - Julia\nDESCRIPTION: Exemplifies Julia tuple creation with multiple values, single values, and heterogeneous types. Also illustrates index-based access. Tuples are immutable and can contain values of any type. This feature requires only Julia Base. Construction uses parentheses and commas; access is by integer index. Inputs are literals; outputs are tuples or tuple elements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_17\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> (1, 1+1)\n(1, 2)\n\njulia> (1,)\n(1,)\n\njulia> x = (0.0, \"hello\", 6*7)\n(0.0, \"hello\", 42)\n\njulia> x[2]\n\"hello\"\n```\n\n----------------------------------------\n\nTITLE: Extracting Element Type Parameter Using Triangular Dispatch - Julia\nDESCRIPTION: This snippet defines an abstract type AbstractArray and a method eltype using triangular dispatch to extract the type parameter T from any concrete subtype. No dependencies are required; it relies solely on parametric types and dispatch. eltype(::Type{<:AbstractArray{T}}) returns T, the element type for compatible array types; it does not match non-concrete UnionAll types. The abstract definition allows for extension to other array subtypes in Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\nabstract type AbstractArray{T, N} end\neltype(::Type{<:AbstractArray{T}}) where {T} = T\n```\n\n----------------------------------------\n\nTITLE: Referencing Capture Groups in String Replacement in Julia\nDESCRIPTION: Explains how to use the `replace` function with a regex and a substitution string prefixed with `s`. Captured groups can be referenced in the substitution using `\\n` for the nth group or `\\g<groupname>` for named groups. `\\0` or `\\g<0>` refers to the entire match.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_51\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> replace(\"first second\", r\"(\\w+) (?<agroup>\\w+)\" => s\"\\g<agroup> \\1\")\n\"second first\"\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Multiple Containers Simultaneously Using zip in Julia\nDESCRIPTION: Shows how to iterate over multiple collections (here, two arrays derived from matrices `[1 2 3]` and `[4 5 6 7]`) in parallel using the `zip` function. The `for` loop iterates as long as *all* zipped iterators have elements. In each iteration, it assigns a tuple `(j, k)` containing the corresponding elements from each container and prints the tuple. The loop stops when the shorter iterator (`[1 2 3]`) is exhausted.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_26\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for (j, k) in zip([1 2 3], [4 5 6 7])\n           println((j,k))\n       end\n(1, 4)\n(2, 5)\n(3, 6)\n```\n\n----------------------------------------\n\nTITLE: Dispatching on Val Instances in Julia\nDESCRIPTION: This example demonstrates function dispatch using `Val` instances. It defines two methods for the `firstlast` function, one that accepts `Val{true}` and another for `Val{false}`. Calling `firstlast` with `Val(true)` or `Val(false)` invokes the corresponding method, effectively dispatching based on the boolean value wrapped by `Val`. Requires the `Val` type definition.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_77\n\nLANGUAGE: jldoctest valtype\nCODE:\n```\njulia> firstlast(::Val{true}) = \"First\"\nfirstlast (generic function with 1 method)\n\njulia> firstlast(::Val{false}) = \"Last\"\nfirstlast (generic function with 2 methods)\n\njulia> firstlast(Val(true))\n\"First\"\n\njulia> firstlast(Val(false))\n\"Last\"\n```\n\n----------------------------------------\n\nTITLE: Specifying IndexStyle Trait for Custom Array Types in Julia\nDESCRIPTION: This snippet shows how to declare that a custom AbstractArray subtype should use fast linear (IndexLinear) iteration by defining the IndexStyle trait. This impacts eachindex and index behavior. Prerequisites include defining MyArray as an AbstractArray implementation. No direct inputs or outputs as this is a trait customization declaration.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\nBase.IndexStyle(::Type{<:MyArray}) = IndexLinear()\n```\n\n----------------------------------------\n\nTITLE: Variable Assignment and Unicode Names - Julia Doctest - Julia\nDESCRIPTION: This snippet illustrates assigning different data types to variables, including strings and variables with names in Unicode and various letter cases. It highlights Julia's case sensitivity and support for internationalization. No additional setup is required; standard Julia base is sufficient. The snippet shows various assignments and resulting output values, including a variable with a non-Latin string.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = 1.0\\n1.0\\n\\njulia> y = -3\\n-3\\n\\njulia> Z = \\\"My string\\\"\\n\\\"My string\\\"\\n\\njulia> customary_phrase = \\\"Hello world!\\\"\\n\\\"Hello world!\\\"\\n\\njulia> UniversalDeclarationOfHumanRightsStart = \\\"人人生而自由，在尊严和权利上一律平等。\\\"\\n\\\"人人生而自由，在尊严和权利上一律平等。\\\"\n```\n\n----------------------------------------\n\nTITLE: Improving Performance by Copying Non-Contiguous Array Views in Julia\nDESCRIPTION: Compares the performance of repeated matrix multiplications within a function `iterated_neural_network` when operating on a non-contiguous `view` versus a contiguous copy (`A[inds, inds]`) created from shuffled indices. Shows that explicitly copying the data into a contiguous array before repeated access significantly speeds up computation, outweighing the copy overhead.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_53\n\nLANGUAGE: julia-repl\nCODE:\n```\n```julia-repl\njulia> using Random\n\njulia> A = randn(3000, 3000);\n\njulia> x = randn(2000);\n\njulia> inds = shuffle(1:3000)[1:2000];\n\njulia> function iterated_neural_network(A, x, depth)\n           for _ in 1:depth\n               x .= max.(0, A * x)\n           end\n           argmax(x)\n       end\n\njulia> @time iterated_neural_network(view(A, inds, inds), x, 10)\n  0.324903 seconds (12 allocations: 157.562 KiB)\n1569\n\njulia> @time iterated_neural_network(A[inds, inds], x, 10)\n  0.054576 seconds (13 allocations: 30.671 MiB, 13.33% gc time)\n1569\n```\n```\n\n----------------------------------------\n\nTITLE: Complex Destructuring Assignment and Modifying Structures - Julia\nDESCRIPTION: Demonstrates destructuring on both arrays and nested tuples, and shows how destructuring can be combined with updating data structures via setindex!. No special dependencies are needed. Example initializes a vector and destructures a tuple, showing the updated vector and unpacked variables. Inputs are tuples; outputs are changed vectors and scalars.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_21\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> X = zeros(3);\n\njulia> X[1], (a, b) = (1, (2, 3))\n(1, (2, 3))\n\njulia> X\n3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> a\n2\n\njulia> b\n3\n```\n\n----------------------------------------\n\nTITLE: Performing Basic CPU Profiling with @profile in Julia\nDESCRIPTION: This snippet demonstrates how to use the `@profile` macro from the `Profile` module to collect CPU profiling data for a function call (`foo()`) and then print the collected profile results using `Profile.print()`. This is the primary method for enabling profiling for a specific code block.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Profile/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Profile\n\njulia> @profile foo()\n\njulia> Profile.print()\nOverhead ╎ [+additional indent] Count File:Line; Function\n=========================================================\n    ╎147  @Base/client.jl:506; _start()\n        ╎ 147  @Base/client.jl:318; exec_options(opts::Base.JLOptions)\n...\n```\n\n----------------------------------------\n\nTITLE: Generic Allocation and Copy with Element Type Transformation - Julia\nDESCRIPTION: This function defines copy_with_eltype, producing a new array of the same shape and type as input but with the desired Eltype, and copies the data. It combines similar to allocate an uninitialized array and copyto! to fill it, ensuring the output is mutable and does not alias the original. It depends on the AbstractArray API, specifically similar and copyto! methods being defined for the input type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\ncopy_with_eltype(input, Eltype) = copyto!(similar(input, Eltype), input)\n```\n\n----------------------------------------\n\nTITLE: Conditional Platform Implementation with @static Blocks - Julia\nDESCRIPTION: This snippet shows how to use the @static macro to perform platform-specific actions inside a conditional control structure in Julia. Depending on whether the platform is Linux, Apple, or neither, it calls the appropriate function for each OS or falls back to a generic handler. Dependencies are limited to the base Julia Sys module; each of the platform-specific functions ('linux_specific_thing', 'apple_specific_thing', 'generic_thing') must be implemented elsewhere.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/handling-operating-system-variation.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n@static if Sys.islinux()\n    linux_specific_thing(a)\nelseif Sys.isapple()\n    apple_specific_thing(a)\nelse\n    generic_thing(a)\nend\n```\n\n----------------------------------------\n\nTITLE: Constraining Composite Parametric Types in Julia\nDESCRIPTION: Shows how to constrain type parameters for composite types (Point{T}) so that T must be a subtype of Real and sets them as subtypes of Pointy{T}. Each instance will have x and y fields of type T. This ensures only valid numeric types are structurally permitted.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\nstruct Point{T<:Real} <: Pointy{T}\n    x::T\n    y::T\nend\n```\n\n----------------------------------------\n\nTITLE: Using Do-Block Syntax for Resource Management with `open` in Julia\nDESCRIPTION: Shows how the `do` block syntax can be used with functions like `open` to manage resources. The anonymous function defined by the `do io ... end` block receives the opened file stream (`io`) and operates on it. The `open` function ensures the file is closed afterwards, even if errors occur.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\nopen(\"outfile\", \"w\") do io\n    write(io, data)\nend\n```\n\n----------------------------------------\n\nTITLE: Using LazyString and @lazy_str for Efficient Conditional Warnings in Julia\nDESCRIPTION: Explains techniques to delay materialization of interpolated strings when issuing deprecation or warning messages, using LazyString and the @lazy_str macro for improved performance in Julia 1.8+. The examples illustrate deprecation warnings with and without lazy string constructs. Dependencies: Julia 1.8 or later. Inputs: object for interpolation; outputs: warning when triggered. Limitation: Lazy string approach is more efficient only for conditional paths—useful in library development or performance-sensitive diagnostic code.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_64\n\nLANGUAGE: julia\nCODE:\n```\nBase.depwarn(\"`foo` is deprecated for type $(typeof(x))\", :bar)\n\n```\n\nLANGUAGE: julia\nCODE:\n```\nBase.depwarn(lazy\"`foo` is deprecated for type $(typeof(x))\", :bar)\n\n```\n\nLANGUAGE: julia\nCODE:\n```\nBase.depwarn(LazyString(\"`foo` is deprecated for type \", typeof(x)), :bar)\n\n```\n\n----------------------------------------\n\nTITLE: Filtering Arrays in Julia using Functions and Indexing\nDESCRIPTION: Julia provides higher-order functions `filter` (returns new array) and `filter!` (modifies in-place) for filtering. Logical indexing (`x[x.>3]`) is also possible but may create temporary arrays; `filter!` is often more efficient for in-place modification.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\nfilter(z->z>3, x)\n```\n\nLANGUAGE: julia\nCODE:\n```\nfilter!(z->z>3, x)\n```\n\nLANGUAGE: julia\nCODE:\n```\nx[x.>3]\n```\n\nLANGUAGE: julia\nCODE:\n```\nx = x[x.>3]\n```\n\n----------------------------------------\n\nTITLE: Redefining a Julia `const` Variable (Permitted with `const` Keyword)\nDESCRIPTION: Demonstrates that redefining a Julia `const` variable is permitted if the `const` keyword is used again for the redefinition (as of Julia 1.12, previously restricted/discouraged). This example redefines the constant `y` from `1.0` to `2.0`. Note that redefining constants can trigger significant recompilation and should be used cautiously.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_29\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> const y = 1.0\n1.0\n\njulia> const y = 2.0\n2.0\n```\n```\n\n----------------------------------------\n\nTITLE: Using CartesianIndex for Multidimensional Array Indexing in Julia\nDESCRIPTION: This snippet demonstrates the creation and reshaping of a 3D array, shows how to access elements using regular indices as well as with CartesianIndex objects, and checks for equivalence. No special dependencies are needed; the code illustrates core Julia Base array and Cartesian indexing functionality. The array A is created with reshape, indexed using both (i, j, k) indices and a CartesianIndex, and the result is a scalar. Limitations: CartesianIndex cannot incorporate the 'end' keyword in indices.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\njulia> A = reshape(1:32, 4, 4, 2);\n\njulia> A[3, 2, 1]\n7\n\njulia> A[CartesianIndex(3, 2, 1)] == A[3, 2, 1] == 7\ntrue\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Broadcasting for Custom Array Types - Julia\nDESCRIPTION: Illustrates usage of a custom array type, ArrayAndChar, with the broadcasting interface in Julia. The code demonstrates instance creation, elementwise addition with a scalar, and broadcasting batch addition using an array, showing how custom containers integrate natively with Julia broadcast operations. Dependencies include the custom ArrayAndChar type and Julia standard broadcasting. Inputs are the array and character, and the outputs are ArrayAndChar objects containing the results. This snippet is for demonstration and documentation use.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\njulia> a = ArrayAndChar([1 2; 3 4], 'x')\n2×2 ArrayAndChar{Int64, 2} with char 'x':\n 1  2\n 3  4\n\njulia> a .+ 1\n2×2 ArrayAndChar{Int64, 2} with char 'x':\n 2  3\n 4  5\n\njulia> a .+ [5,10]\n2×2 ArrayAndChar{Int64, 2} with char 'x':\n  6   7\n 13  14\n```\n\n----------------------------------------\n\nTITLE: Assigning and Reassigning Variables - Julia REPL - Julia\nDESCRIPTION: This snippet demonstrates how to assign values to variables, perform arithmetic operations on variables, reassign variables to new values or types, and illustrates Julia's flexibility in variable naming. It requires the Julia REPL environment and no external dependencies. Inputs include integer and string literals; outputs display the evaluated results of each expression. This is aimed at newcomers learning basic variable usage and assignment in Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n# Assign the value 10 to the variable x\\njulia> x = 10\\n10\\n\\n# Doing math with x's value\\njulia> x + 1\\n11\\n\\n# Reassign x's value\\njulia> x = 1 + 1\\n2\\n\\n# You can assign values of other types, like strings of text\\njulia> x = \\\"Hello World!\\\"\\n\\\"Hello World!\\\"\n```\n\n----------------------------------------\n\nTITLE: Spawning and Reducing Parallel Computations with Futures in Julia REPL\nDESCRIPTION: This sequence uses Julia's @everywhere to define a function on all processes, then utilizes @spawnat to run 'count_heads' concurrently on two processes. The individual results are fetched via 'fetch' and summed. Assumes Distributed, Main module, and that 'count_heads.jl' exists with the correct function. All code should be run in Julia REPL with multiple processes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_17\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @everywhere include_string(Main, $(read(\"count_heads.jl\", String)), \"count_heads.jl\")\n\njulia> a = @spawnat :any count_heads(100000000)\nFuture(2, 1, 6, nothing)\n\njulia> b = @spawnat :any count_heads(100000000)\nFuture(3, 1, 7, nothing)\n\njulia> fetch(a)+fetch(b)\n100001564\n```\n\n----------------------------------------\n\nTITLE: Pointwise Indexing with Arrays of CartesianIndex in Julia\nDESCRIPTION: This snippet accesses diagonal elements of a matrix by indexing with an array of CartesianIndex objects. It first extracts a page/slice from a 3D array, then demonstrates indexing into that slice using a collection of CartesianIndex, creating a vector of diagonal elements. No external libraries are required. Inputs are the matrix (page) and the list of indices, outputs are a vector of integers. Does not support use of 'end' inside CartesianIndex-based indices.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\njulia> page = A[:, :, 1]\n4×4 Matrix{Int64}:\n 1  5   9  13\n 2  6  10  14\n 3  7  11  15\n 4  8  12  16\n\njulia> page[[CartesianIndex(1, 1),\n             CartesianIndex(2, 2),\n             CartesianIndex(3, 3),\n             CartesianIndex(4, 4)]]\n4-element Vector{Int64}:\n  1\n  6\n 11\n 16\n```\n\n----------------------------------------\n\nTITLE: Examples of Indexed Assignment in Julia Arrays\nDESCRIPTION: Demonstrates indexed assignment in Julia. It first initializes a 3x3 matrix `x`, then assigns a scalar value `-9` to a single element `x[3, 3]`, and finally assigns a 2x2 matrix to a slice `x[1:2, 1:2]`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_26\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = collect(reshape(1:9, 3, 3))\n3×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> x[3, 3] = -9;\n\njulia> x[1:2, 1:2] = [-1 -4; -2 -5];\n\njulia> x\n3×3 Matrix{Int64}:\n -1  -4   7\n -2  -5   8\n  3   6  -9\n```\n\n----------------------------------------\n\nTITLE: Defining Random Sampling from a Custom Object (Die) in Julia\nDESCRIPTION: Implements the `rand(rng::AbstractRNG, d::Random.SamplerTrivial{Die})` method to define how to generate a random value *from* an existing instance `d` of the `Die` type. This method samples a random integer between 1 and the number of sides (`d[].nsides`) of the given `Die` object. It uses `SamplerTrivial` as no pre-computation is needed for this simple sampling.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Random.rand(rng::AbstractRNG, d::Random.SamplerTrivial{Die}) = rand(rng, 1:d[].nsides);\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple Functions with `∘` Operator in Julia\nDESCRIPTION: Demonstrates the extended function composition syntax in Julia v1.4, allowing multiple functions (`f`, `g`, `h`) to be composed directly using the `∘` operator (typed as `\\circ<tab>`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_90\n\nLANGUAGE: julia\nCODE:\n```\n∘(f, g, h)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Regex Literal in Julia\nDESCRIPTION: Shows how to define a Perl-compatible regular expression using the `r\"...\"` non-standard string literal syntax in Julia. The example defines a regex to match lines starting with optional whitespace followed by a '#' or the end of the line, and confirms its type is `Regex`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_42\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> re = r\"^\\s*(?:#|$)\"\nr\"^\\s*(?:#|$)\"\n\njulia> typeof(re)\nRegex\n```\n\n----------------------------------------\n\nTITLE: Creating and Initializing a SharedArray in Julia REPL\nDESCRIPTION: Demonstrates adding worker processes, loading the `SharedArrays` module on all workers, creating a 3x4 `SharedArray` of integers, and initializing it in parallel such that each element contains the ID of the worker process that initialized it, using `localindices` for partitioning. It also shows modifying a single element.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\njulia> using Distributed\n\njulia> addprocs(3)\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia> @everywhere using SharedArrays\n\njulia> S = SharedArray{Int,2}((3,4), init = S -> S[localindices(S)] = repeat([myid()], length(localindices(S))))\n3×4 SharedMatrix{Int64}:\n 2  2  3  4\n 2  3  3  4\n 2  3  4  4\n\njulia> S[3,2] = 7\n7\n\njulia> S\n3×4 SharedMatrix{Int64}:\n 2  2  3  4\n 2  3  3  4\n 2  7  4  4\n```\n\n----------------------------------------\n\nTITLE: Signature for Custom Broadcast Output Allocation in Julia\nDESCRIPTION: Presents the method signature `Base.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})` which must be implemented to control how the output array is allocated for a custom broadcast destination style (`DestStyle`) and element type (`ElType`). The `bc` argument is a `Broadcasted` object representing the lazy broadcast operation, containing information about the function and arguments.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nBase.similar(bc::Broadcasted{DestStyle}, ::Type{ElType})\n```\n```\n\n----------------------------------------\n\nTITLE: Assigning a Broadcast Style to `ArrayAndChar` in Julia\nDESCRIPTION: Defines the `Base.BroadcastStyle` method for the custom `ArrayAndChar` type. It returns `Broadcast.ArrayStyle{ArrayAndChar}()`, signaling that this type should generally behave like an array during broadcasting but allows for customization, particularly in output allocation via implementing a specialized `similar` method.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest ArrayAndChar; output = false\nBase.BroadcastStyle(::Type{<:ArrayAndChar}) = Broadcast.ArrayStyle{ArrayAndChar}()\n# output\n\n```\n```\n\n----------------------------------------\n\nTITLE: Summing Arrays with Missing Values in Julia\nDESCRIPTION: Demonstrates that arithmetic reduction functions like `sum` return `missing` if any element in the array is `missing`. This behavior is standard in Julia, requiring no extra dependencies. The input is any array containing at least one `missing` value; the output is always `missing` if so. No parameters or special setup are needed. Limitations: this can propagate missingness through data pipelines unintentionally.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\njulia> sum([1, missing])\nmissing\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invariance of Parametric Abstract Types in Julia\nDESCRIPTION: Shows that parametric abstract types in Julia are invariant with respect to their parameters, meaning that Pointy{Float64} is not a subtype of Pointy{Real}, and vice versa. No dependencies or special environment required, and this invariance is reflected in the type system's strictness.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\njulia> Pointy{Float64} <: Pointy{Real}\nfalse\n\njulia> Pointy{Real} <: Pointy{Float64}\nfalse\n```\n\n----------------------------------------\n\nTITLE: Destructuring Assignment and Multiple Return Values - Julia\nDESCRIPTION: Illustrates destructuring assignment, where a tuple or iterable is unpacked into individual variables. Includes an example function returning a tuple, explicit variable assignment, and variable swapping. Destructuring works with any iterator and simplifies accessing multiple returned values. Only Julia Base is needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_19\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> (a, b, c) = 1:3\n1:3\n\njulia> b\n2\n```\n\nLANGUAGE: jldoctest foofunc\nCODE:\n```\njulia> function foo(a, b)\n           a+b, a*b\n       end\nfoo (generic function with 1 method)\n```\n\nLANGUAGE: jldoctest foofunc\nCODE:\n```\njulia> foo(2, 3)\n(5, 6)\n```\n\nLANGUAGE: jldoctest foofunc\nCODE:\n```\njulia> x, y = foo(2, 3)\n(5, 6)\n\njulia> x\n5\n\njulia> y\n6\n```\n\nLANGUAGE: jldoctest foofunc\nCODE:\n```\njulia> y, x = x, y\n(5, 6)\n\njulia> x\n6\n\njulia> y\n5\n```\n\n----------------------------------------\n\nTITLE: Applying Elementary Functions to Complex Numbers in Julia\nDESCRIPTION: Demonstrates use of standard elementary mathematical functions such as sqrt(), cos(), exp(), and sinh() on complex numbers. Requires only the Julia Base library. Inputs are complex values; outputs are complex-valued function results, highlighting Julia's extension of functions to the complex domain.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> sqrt(1im)\n0.7071067811865476 + 0.7071067811865475im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> sqrt(1 + 2im)\n1.272019649514069 + 0.7861513777574233im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> cos(1 + 2im)\n2.0327230070196656 - 3.0518977991517997im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> exp(1 + 2im)\n-1.1312043837568135 + 2.4717266720048188im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> sinh(1 + 2im)\n-0.4890562590412937 + 1.4031192506220405im\n```\n\n----------------------------------------\n\nTITLE: Defining a Recursive Fibonacci Function with Integer Type Constraint\nDESCRIPTION: Defines a recursive function `fib` to compute Fibonacci numbers using the compact assignment form. It includes an argument type declaration `n::Integer`, specifying that the function should only be called with arguments `n` that are subtypes of the abstract type `Integer`. This helps ensure correctness and can aid dispatch, though it doesn't typically impact performance.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nfib(n::Integer) = n ≤ 2 ? one(n) : fib(n-1) + fib(n-2)\n```\n\n----------------------------------------\n\nTITLE: Vectorized Dot Operator for Elementwise Power in Julia - Julia\nDESCRIPTION: This snippet demonstrates the use of the vectorized dot (broadcast) operator for performing elementwise power (`.^`) on an array. The input is a standard Julia vector and a scalar; the result is a new vector with each element raised to the specified power. Requires basic understanding of Julia arrays and broadcasting; output is a vector of the same length as the input.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> [1, 2, 3] .^ 3\n3-element Vector{Int64}:\n  1\n  8\n 27\n```\n\n----------------------------------------\n\nTITLE: Adding See Also References in Documentation - Julia - Julia\nDESCRIPTION: This snippet shows how to refer to related functions using a See also section in Julia markdown. The references use backtick notation and Julia's documentation cross-references with @ref. This improves discoverability for related APIs and helps users find similar functionality.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nSee also [`bar!`](@ref), [`baz`](@ref), [`baaz`](@ref).\n```\n\n----------------------------------------\n\nTITLE: Creating SubString Views and Using the @views Macro in Julia\nDESCRIPTION: Shows how to create a substring view using `SubString(str, start, stop)` and how the `@views` macro can be used to automatically yield `SubString` results from slices. This enables efficient, non-copying views of parts of strings. No external requirements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\njulia> str = \"long string\"\n\"long string\"\n\njulia> substr = SubString(str, 1, 4)\n\"long\"\n\njulia> typeof(substr)\nSubString{String}\n\njulia> @views typeof(str[1:4]) # @views converts slices to SubStrings\nSubString{String}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Type Bounds for Floating-Point Types with typemin and typemax (Julia)\nDESCRIPTION: Shows how to obtain the minimum and maximum values representable for Float16, Float32, and Float64 using typemin and typemax. Useful for understanding the IEEE 754 representation in Julia. No external dependencies; input is a floating-point type, output displays its numerical type bounds.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\njulia> (typemin(Float16),typemax(Float16))\n(-Inf16, Inf16)\n\njulia> (typemin(Float32),typemax(Float32))\n(-Inf32, Inf32)\n\njulia> (typemin(Float64),typemax(Float64))\n(-Inf, Inf)\n```\n\n----------------------------------------\n\nTITLE: Constructing and Reducing Rational Numbers in Julia\nDESCRIPTION: Demonstrates the construction of rational numbers using the //' operator and shows automatic reduction to lowest terms, preserving non-negative denominators. These examples use only Julia Base types and functions. Inputs are numerators and denominators; outputs are normalized rational expressions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> 2//3\n2//3\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 6//9\n2//3\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> -4//8\n-1//2\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 5//-15\n-1//3\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> -4//-12\n1//3\n```\n\n----------------------------------------\n\nTITLE: Square Matrix Multiplication with Output Type Computation Using promote_op - Julia\nDESCRIPTION: This function provides a generic square-matrix multiplication implementation in Julia. It defines op as the kernel operation, computes the output type R via promote_op (taking into account eltype of inputs), allocates a matching output array, and computes the result using nested loops. Comments contrast alternative output type deduction strategies and their pitfalls. Requires AbstractMatrix types supporting eltype, similar, promote_op, and standard array interfaces.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\nfunction matmul(a::AbstractMatrix, b::AbstractMatrix)\n    op = (ai, bi) -> ai * bi + ai * bi\n\n    ## this is insufficient because it assumes `one(eltype(a))` is constructable:\n    # R = typeof(op(one(eltype(a)), one(eltype(b))))\n\n    ## this fails because it assumes `a[1]` exists and is representative of all elements of the array\n    # R = typeof(op(a[1], b[1]))\n\n    ## this is incorrect because it assumes that `+` calls `promote_type`\n    ## but this is not true for some types, such as Bool:\n    # R = promote_type(ai, bi)\n\n    # this is wrong, since depending on the return value\n    # of type-inference is very brittle (as well as not being optimizable):\n    # R = Base.return_types(op, (eltype(a), eltype(b)))\n\n    ## but, finally, this works:\n    R = promote_op(op, eltype(a), eltype(b))\n    ## although sometimes it may give a larger type than desired\n    ## it will always give a correct type\n\n    output = similar(b, R, (size(a, 1), size(b, 2)))\n    if size(a, 2) > 0\n        for j in 1:size(b, 2)\n            for i in 1:size(a, 1)\n                ## here we don't use `ab = zero(R)`,\n                ## since `R` might be `Any` and `zero(Any)` is not defined\n                ## we also must declare `ab::R` to make the type of `ab` constant in the loop,\n                ## since it is possible that typeof(a * b) != typeof(a * b + a * b) == R\n                ab::R = a[i, 1] * b[1, j]\n                for k in 2:size(a, 2)\n                    ab += a[i, k] * b[k, j]\n                end\n                output[i, j] = ab\n            end\n        end\n    end\n    return output\nend\n```\n\n----------------------------------------\n\nTITLE: Ensuring File Closure with finally in Julia\nDESCRIPTION: This snippet demonstrates using a try/finally block in Julia to ensure that a file is closed after operations are completed, regardless of whether an exception occurs. The finally section guarantees the execution of close(f) after leaving the try block, making it suitable for managing resources such as files or network streams. The code assumes the presence of the open and close functions, with the file f being an I/O object.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_40\n\nLANGUAGE: julia\nCODE:\n```\nf = open(\"file\")\ntry\n    # operate on file f\nfinally\n    close(f)\nend\n```\n\n----------------------------------------\n\nTITLE: Global Variable Propagation in Julia Remote Calls\nDESCRIPTION: Defines a global variable `A` in the `Main` module on the local process. Then, `remotecall_fetch(()->sum(A), 2)` executes a closure on worker 2. Because the closure references the global `A`, Julia automatically sends the value of `A` to worker 2 and defines `Main.A` on that worker before executing `sum(A)`. The result of the sum is then returned to the local process.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_13\n\nLANGUAGE: julia-repl\nCODE:\n```\nA = rand(10,10)\nremotecall_fetch(()->sum(A), 2)\n```\n\n----------------------------------------\n\nTITLE: Building and Summing Arrays with Preallocated Output - Base Julia - Julia\nDESCRIPTION: Demonstrates memory- and performance-optimized in-place array construction using preallocated storage. `xinc!` writes results directly into a supplied vector, while `loopinc_prealloc` reuses memory by passing the same vector in each loop iteration, greatly reducing allocations and execution time. The function is generic over type T and supports any AbstractVector subtype.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_43\n\nLANGUAGE: julia\nCODE:\n```\njulia> function xinc!(ret::AbstractVector{T}, x::T) where T\n           for i in 1:3000\n               ret[i] = x+i\n           end\n           nothing\n       end;\n\njulia> function loopinc_prealloc()\n           ret = Vector{Int}(undef, 3000)\n           y = 0\n           for i = 1:10^5\n               xinc!(ret, i)\n               y += ret[2]\n           end\n           return y\n       end;\n```\n\n----------------------------------------\n\nTITLE: Handling Large Integer Calculations with BigInt in Julia\nDESCRIPTION: Shows an example of integer overflow when calculating `10^19` using standard `Int64` arithmetic, resulting in an incorrect negative value. It then demonstrates how using `BigInt` (via `big(10)`) allows for arbitrary-precision arithmetic, yielding the correct large integer result.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> 10^19\n-8446744073709551616\n\njulia> big(10)^19\n10000000000000000000\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing an Outer-Only Constructor in Julia\nDESCRIPTION: This snippet redefines the `SummedArray` struct, providing only an outer constructor within the `struct` definition block. This suppresses the generation of default constructors. The provided constructor takes a `Vector{T}`, automatically determines a wider type `S` using `widen(T)` for the sum, and uses `new{T,S}` to create the instance. This enforces the constraint that `S` should be a wider type than `T` and prevents users from manually specifying `T` and `S` (as shown by the `ERROR`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_25\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct SummedArray{T<:Number,S<:Number}\n           data::Vector{T}\n           sum::S\n           function SummedArray(a::Vector{T}) where T\n               S = widen(T)\n               new{T,S}(a, sum(S, a))\n           end\n       end\n\njulia> SummedArray(Int32[1; 2; 3], Int32(6))\nERROR: MethodError: no method matching SummedArray(::Vector{Int32}, ::Int32)\nThe type `SummedArray` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  SummedArray(::Vector{T}) where T\n   @ Main none:4\n\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Rational (NaN) Construction in Julia\nDESCRIPTION: Shows error handling when attempting to construct a rational value with both numerator and denominator zero (NaN for rationals). Only Julia Base is needed. Input is zero-over-zero construction; output is an error message.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\njulia> 0//0\nERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Describing SharedArray Constructor Syntax in Julia\nDESCRIPTION: Defines the syntax for creating a `SharedArray` in Julia, specifying the element type `T`, number of dimensions `N`, tuple of dimensions `dims`, an optional initialization function `init`, and an optional list of participating worker process IDs `pids`. Only `isbits` types are supported for the elements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\nSharedArray{T,N}(dims::NTuple; init=false, pids=Int[])\n```\n\n----------------------------------------\n\nTITLE: If Blocks Returning Values - Julia\nDESCRIPTION: Example of using the value returned from an if-else block, leveraging Julia's feature where such blocks evaluate to the value of their last executed statement. The result is directly assigned to a variable. Useful for concise conditional value selection.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = 3\n3\n\njulia> if x > 0\n           \"positive!\"\n       else\n           \"negative...\"\n       end\n\"positive!\"\n```\n\n----------------------------------------\n\nTITLE: Comparing Version Numbers using Literals in Julia\nDESCRIPTION: Demonstrates using version number literals (`v\"...\"`) and the `VERSION` constant for conditional execution based on the Julia version. It shows a comparison to check if the current version is within the 0.2 release series, using the special `v\"0.3-\"` literal. This Julia-specific notation signifies a version strictly lower than any `0.3.0` release, including pre-releases like `0.3.0-rc1`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_61\n\nLANGUAGE: julia\nCODE:\n```\nif v\"0.2\" <= VERSION < v\"0.3-\"\n    # do something specific to 0.2 release series\nend\n```\n\n----------------------------------------\n\nTITLE: Specialized Addition Function for Integers - Julia\nDESCRIPTION: This function definition demonstrates Julia's method specialization by explicitly typing both function parameters as 'Int'. The snippet shows the compiler's ability to generate specialized method implementations for specific concrete types, improving performance over generic functions by leveraging static dispatch. The function takes two integers and returns their sum using '+'. No external dependencies are required, but both arguments must be of type 'Int'. Inputs: two Int-typed variables; output: their sum.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nfunction myplus(x::Int,y::Int)\n    x+y\nend\n```\n\n----------------------------------------\n\nTITLE: Basic Error Handling with StackTrace in Julia\nDESCRIPTION: Illustrates using a `try...catch` block to handle an error (an `UndefVarError` caused by accessing `undeclared_variable` in `bad_function`). Calling `stacktrace()` inside the `catch` block captures the stack trace at that point, showing the call originated from the `catch` block itself (line 4), not the line where the error occurred (line 2 in `example`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_4\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @noinline bad_function() = undeclared_variable\nbad_function (generic function with 1 method)\n\njulia> @noinline example() = try\n           bad_function()\n       catch\n           stacktrace()\n       end\nexample (generic function with 1 method)\n\njulia> example()\n7-element Array{Base.StackTraces.StackFrame,1}:\n example() at REPL[2]:4\n top-level scope\n eval at boot.jl:317 [inlined]\n[...]\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Functions with Dot Syntax in Julia\nDESCRIPTION: Illustrates the application of Julia's dot syntax (`f.(...)`) for broadcasting arbitrary functions elementwise over arrays or collections. Examples include type conversion (`convert.`), mathematical functions (`ceil.`), and string manipulation (`string.`) applied to vectors and matrices.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_40\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> convert.(Float32, [1, 2])\n2-element Vector{Float32}:\n 1.0\n 2.0\n\njulia> ceil.(UInt8, [1.2 3.4; 5.6 6.7])\n2×2 Matrix{UInt8}:\n 0x02  0x04\n 0x06  0x07\n\njulia> string.(1:3, \". \", [\"First\", \"Second\", \"Third\"])\n3-element Vector{String}:\n \"1. First\"\n \"2. Second\"\n \"3. Third\"\n```\n\n----------------------------------------\n\nTITLE: Including Julia Source Files\nDESCRIPTION: Demonstrates code inclusion using `include(\"source.jl\")`. This command evaluates the contents of the specified file (`source.jl`) directly within the global scope of the module where the `include` call is made. The path is interpreted relative to the file containing the call, or the current working directory (`pwd()`) if called from the REPL. The included file is re-evaluated every time `include` is called.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\ninclude(\"source.jl\")\n```\n\n----------------------------------------\n\nTITLE: Measuring Performance and Allocation with @time (Function Argument)\nDESCRIPTION: Demonstrates the performance benefit of passing variables as function arguments instead of relying on globals. The `sum_arg` function takes `x` as an argument. Using `@time` shows significantly less memory allocation and faster execution compared to the `sum_global` example, highlighting the importance of avoiding type-unstable globals for performance. Requires `x` to be defined. The small allocation reported is due to `@time` itself in the global scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_6\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest sumarg; setup = :(using Random; Random.seed!(1234)), filter = r\"[0-9\\.]+ seconds \\(.*\\)\"\njulia> x = rand(1000);\n\njulia> function sum_arg(x)\n           s = 0.0\n           for i in x\n               s += i\n           end\n           return s\n       end;\n\njulia> @time sum_arg(x)\n  0.007551 seconds (3.98 k allocations: 200.548 KiB, 99.77% compilation time)\n523.0007221951678\n\njulia> @time sum_arg(x)\n  0.000006 seconds (1 allocation: 16 bytes)\n523.0007221951678\n```\n```\n\n----------------------------------------\n\nTITLE: Using Atomic Operations for Thread-Safe Counter in Julia\nDESCRIPTION: Illustrates atomic operations using `Threads.Atomic{Int}` and `Threads.atomic_add!`. An atomic integer `i` is safely incremented by multiple threads concurrently within a `@threads` loop, avoiding race conditions. The example shows the final sum and the intermediate values captured by each thread.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_20\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> i = Threads.Atomic{Int}(0);\n\njulia> ids = zeros(4);\n\njulia> old_is = zeros(4);\n\njulia> Threads.@threads for id in 1:4\n           old_is[id] = Threads.atomic_add!(i, id)\n           ids[id] = id\n       end\n\njulia> old_is\n4-element Vector{Float64}:\n 0.0\n 1.0\n 7.0\n 3.0\n\njulia> i[]\n 10\n\njulia> ids\n4-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n 4.0\n```\n\n----------------------------------------\n\nTITLE: Defining a Julia Module and Exporting Names\nDESCRIPTION: Illustrates the definition of a simple Julia module named `NiceStuff` using the `jldoctest` format. It uses the `export` keyword to make the function `nice` and the constant `DOG` available for import via `using .NiceStuff`. It also defines a struct `Dog` which is not exported but accessible via a qualified name (`NiceStuff.Dog`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_3\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> module NiceStuff\n       export nice, DOG\n       struct Dog end      # singleton type, not exported\n       const DOG = Dog()   # named instance, exported\n       nice(x) = \"nice $x\" # function, exported\n       end;\n```\n\n----------------------------------------\n\nTITLE: Using else and finally Together in Julia try Expressions\nDESCRIPTION: This code snippet demonstrates the use of catch, else, and finally blocks in Julia's try expression syntax. Here, the else block provides the expression's return value when no error occurs, while the finally block ensures that certain code always executes afterward. This pattern is especially valuable for managing post-processing steps or cleanup regardless of normal or abnormal control flow.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_43\n\nLANGUAGE: julia\nCODE:\n```\njulia> try\n           0\n       catch\n           1\n       else\n           2\n       finally\n           3\n       end\n2\n```\n\n----------------------------------------\n\nTITLE: Using :: for Local Variable Declarations in Julia\nDESCRIPTION: This code illustrates how to use the :: operator to specify local variable types, either in a declaration or as the left-hand side of an assignment. This enforces that the variable always has the given type within its scope, aiding in type stability and performance. No external libraries are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nlocal x::Int8  # in a local declaration\nx::Int8 = 10   # as the left-hand side of an assignment\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Julia's Allocation Profiler with PProf.jl\nDESCRIPTION: This Julia snippet shows a simple example of profiling memory allocations using `Profile.Allocs.@profile` with a specified `sample_rate` on a function `my_function()`. It clears previous allocation data and uses `PProf.Allocs.pprof()` to visualize the collected profile. Requires `Profile` and `PProf` packages.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nusing Profile, PProf\nProfile.Allocs.clear()\nProfile.Allocs.@profile sample_rate=0.0001 my_function()\nPProf.Allocs.pprof()\n```\n```\n\n----------------------------------------\n\nTITLE: Using Do-Block Syntax with `map` in Julia\nDESCRIPTION: Illustrates the use of Julia's `do` block syntax to pass an anonymous function to `map`. The `do x ... end` block defines an anonymous function with argument `x`, which is passed as the first argument to `map`. This syntax is clearer for multi-line anonymous functions compared to the standard lambda syntax.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nmap([A, B, C]) do x\n    if x < 0 && iseven(x)\n        return 0\n    elseif x == 0\n        return 1\n    else\n        return x\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Numerical Type Conversions and Rounding in Julia\nDESCRIPTION: This code snippet presents interactive examples of converting values between types using Int8 and rounding using round(Int8, ...). It illustrates Julia's behavior when handling in-range and out-of-range values, both for integers and floating-point types, including automatic type conversion, result truncation, and the raising of InexactError exceptions for unsupported conversions. Expected inputs are integer or floating-point numbers; outputs are either converted Int8 values or runtime errors with stacktraces, showing Julia's type system and rounding conventions in practice. No external dependencies are required, and all interactions occur in the Julia REPL or compatible Jupyter-like environment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\njulia> Int8(127)\n127\n\njulia> Int8(128)\nERROR: InexactError: trunc(Int8, 128)\nStacktrace:\n[...]\n\njulia> Int8(127.0)\n127\n\njulia> Int8(3.14)\nERROR: InexactError: Int8(3.14)\nStacktrace:\n[...]\n\njulia> Int8(128.0)\nERROR: InexactError: Int8(128.0)\nStacktrace:\n[...]\n\njulia> 127 % Int8\n127\n\njulia> 128 % Int8\n-128\n\njulia> round(Int8,127.4)\n127\n\njulia> round(Int8,127.6)\nERROR: InexactError: Int8(128.0)\nStacktrace:\n[...]\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling Julia Methods Dispatching on Container Struct Parameters\nDESCRIPTION: Shows how to define multiple methods for a function (`myfunc`) that dispatch based on the specific type parameters of `MySimpleContainer`. This allows tailoring behavior based on both the container type (e.g., `<:AbstractArray`) and the element type (e.g., `<:Integer`, `<:AbstractFloat`), or even specific container types like `Vector{T} where T <: Integer`. Calling `myfunc` with different `MySimpleContainer` instances demonstrates the correct method dispatch.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_21\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:Integer}})\n           return c.a[1]+1\n       end\nmyfunc (generic function with 1 method)\n\njulia> function myfunc(c::MySimpleContainer{<:AbstractArray{<:AbstractFloat}})\n           return c.a[1]+2\n       end\nmyfunc (generic function with 2 methods)\n\njulia> function myfunc(c::MySimpleContainer{Vector{T}}) where T <: Integer\n           return c.a[1]+3\n       end\nmyfunc (generic function with 3 methods)\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> myfunc(MySimpleContainer(1:3))\n2\n\njulia> myfunc(MySimpleContainer(1.0:3))\n3.0\n\njulia> myfunc(MySimpleContainer([1:3;]))\n4\n```\n\n----------------------------------------\n\nTITLE: Concatenation, Permutation, and Finding Methods in Arrays via JuliaDoc - Julia\nDESCRIPTION: Aggregates documentation for a range of cohesive array operations, including concatenation, joining, stacking, and permutation functions like `cat`, `vcat`, `hcat`, `permutedims`, and various searching methods. The `@docs` macro block covers both out-of-place and in-place variants, as well as combinatorial utilities. Dependencies include Julia Base, used exclusively for API documentation generation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/arrays.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.cat\nBase.vcat\nBase.hcat\nBase.hvcat\nBase.hvncat\nBase.stack\nBase.vect\nBase.circshift\nBase.circshift!\nBase.circcopy!\nBase.findall(::Any)\nBase.findall(::Function, ::Any)\nBase.findfirst(::Any)\nBase.findfirst(::Function, ::Any)\nBase.findlast(::Any)\nBase.findlast(::Function, ::Any)\nBase.findnext(::Any, ::Integer)\nBase.findnext(::Function, ::Any, ::Integer)\nBase.findprev(::Any, ::Integer)\nBase.findprev(::Function, ::Any, ::Integer)\nBase.permutedims\nBase.permutedims!\nBase.PermutedDimsArray\nBase.promote_shape\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Reverse Iteration for a Custom Type in Julia\nDESCRIPTION: Shows how to enable reverse iteration for the custom `Squares` type. This requires defining an `iterate` method specifically for `Iterators.Reverse{Squares}`, allowing iteration from the last element to the first.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_7\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Base.iterate(rS::Iterators.Reverse{Squares}, state=rS.itr.count) = state < 1 ? nothing : (state*state, state-1)\n\njulia> collect(Iterators.reverse(Squares(4)))\n4-element Vector{Int64}:\n 16\n  9\n  4\n  1\n```\n\n----------------------------------------\n\nTITLE: Defining an Immutable Composite Type with struct in Julia\nDESCRIPTION: Illustrates how to define an immutable composite type Foo with one untyped field and two typed fields. Demonstrates the struct keyword, field naming, and type annotations (::Int, ::Float64), as well as the effect of omitting a type (defaults to Any). No external dependencies are required; this uses standard Julia syntax for type definitions. Intended as a concise example of composite type construction.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nstruct Foo\n    bar\n    baz::Int\n    qux::Float64\nend\n```\n\n----------------------------------------\n\nTITLE: Concatenating Invalid UTF-8 Strings in Julia\nDESCRIPTION: Illustrates a potential outcome when concatenating invalid UTF-8 strings in Julia. Two strings, `a` (\"\\xe2\\x88\") and `b` (\"\\x80\"), each contain an invalid sequence treated as one character. When concatenated via `string(a, b)`, the resulting string `c` forms the single valid character '∀'. This demonstrates that the length of the concatenated string (`length(c) == 1`) may not equal the sum of the lengths of the input strings (`length(a) + length(b) == 1 + 1 == 2`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_23\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> a, b = \"\\xe2\\x88\", \"\\x80\"\n(\"\\xe2\\x88\", \"\\x80\")\n\njulia> c = string(a, b)\n\"∀\"\n\njulia> collect.([a, b, c])\n3-element Vector{Vector{Char}}:\n ['\\xe2\\x88']\n ['\\x80']\n ['∀']\n\njulia> length.([a, b, c])\n3-element Vector{Int64}:\n 1\n 1\n 1\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Concurrent Writes with ReentrantLock in Julia\nDESCRIPTION: This Julia code explicitly uses a `ReentrantLock` (`l`) to synchronize access to `stdout` among three concurrently spawned tasks. Each task acquires the lock before calling `write` and releases it afterward using a `try...finally` block, ensuring that the writes happen sequentially and the output is not interleaved. It depends on the `Threads` module and requires a `ReentrantLock` to be defined.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\njulia> l = ReentrantLock();\n\njulia> @sync for i in 1:3\n           Threads.@spawn begin\n               lock(l)\n               try\n                   write(stdout, string(i), \" Foo \", \" Bar \")\n               finally\n                   unlock(l)\n               end\n           end\n       end\n1 Foo  Bar 2 Foo  Bar 3 Foo  Bar\n```\n\n----------------------------------------\n\nTITLE: Collecting Non-Missing Values from skipmissing in Julia\nDESCRIPTION: Describes how to convert the filtered `skipmissing` iterator back into a dense array of non-missing values using the `collect` function. This is often required to materialize filtered results for downstream processing. Input is a `skipmissing` iterator; output is an array with only non-missing entries. Assumes caller wants all valid values as a new array.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\njulia> collect(x)\n3-element Vector{Int64}:\n 3\n 2\n 1\n```\n\n----------------------------------------\n\nTITLE: Defining a Parametric Composite Type as a Subtype in Julia\nDESCRIPTION: Defines a parametric composite type Point{T} with two fields x and y, each of type T, and declares it a subtype of the parametric abstract type Pointy{T}. Requires no dependencies outside Julia and demonstrates how concrete types participate in parametric hierarchies. Useful for modeling data structures parameterized over element types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nstruct Point{T} <: Pointy{T}\n    x::T\n    y::T\nend\n```\n\n----------------------------------------\n\nTITLE: Efficient String Creation for I/O with println in Julia\nDESCRIPTION: Contrasts string interpolation and direct argument passing to println, emphasizing overhead differences during file I/O in Julia. The snippets show that using interpolation forms an intermediate string, while passing values as separate arguments writes data directly, thus being more efficient and often more readable. Prerequisites: File handle or I/O object. Inputs: values or function results; outputs: lines written to file. Limitation: Only relevant for I/O-bound code.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_63\n\nLANGUAGE: julia\nCODE:\n```\nprintln(file, \"$a $b\")\n\n```\n\nLANGUAGE: julia\nCODE:\n```\nprintln(file, a, \" \", b)\n\n```\n\nLANGUAGE: julia\nCODE:\n```\nprintln(file, \"$(f(a))$(f(b))\")\n\n```\n\nLANGUAGE: julia\nCODE:\n```\nprintln(file, f(a), f(b))\n\n```\n\n----------------------------------------\n\nTITLE: Using map with Named and Anonymous Functions - Julia\nDESCRIPTION: Demonstrates applying a function to every element of a collection with 'map'. First, the standard 'round' function is used; second, an anonymous function computes a quadratic polynomial. The map function returns a new array with processed elements. No additional dependencies beyond base Julia are required. Input is an array; output is an array of transformed elements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_16\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> map(round, [1.2, 3.5, 1.7])\n3-element Vector{Float64}:\n 1.0\n 4.0\n 2.0\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> map(x -> x^2 + 2x - 1, [1, 3, -1])\n3-element Vector{Int64}:\n  2\n 14\n -2\n```\n\n----------------------------------------\n\nTITLE: Tuple and Property Argument Destructuring in Julia Functions\nDESCRIPTION: Shows defining functions where arguments are destructured tuples or properties, so inner variables are automatically extracted. Includes usage of destructuring in single-argument anonymous functions. Dependencies are none; for property destructuring, argument must be a struct or NamedTuple with matching properties. The function 'gap' destructures (min, max) pairs, and 'foo' destructures x and y from either tuples or custom types. Inputs are tuples or structs as shown, output depends on function logic (e.g., returns the difference or sum).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\njulia> minmax(x, y) = (y < x) ? (y, x) : (x, y)\nminmax (generic function with 1 method)\n\njulia> gap((min, max)) = max - min\ngap (generic function with 1 method)\n\njulia> gap(minmax(10, 2))\n8\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> foo((; x, y)) = x + y\nfoo (generic function with 1 method)\n\njulia> foo((x=1, y=2))\n3\n\njulia> struct A\n           x\n           y\n       end\n\njulia> foo(A(3, 4))\n7\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> map(((x, y),) -> x + y, [(1, 2), (3, 4)])\n2-element Vector{Int64}:\n 3\n 7\n```\n\n----------------------------------------\n\nTITLE: Querying Negative Strides Due to Reversed Slicing (Julia)\nDESCRIPTION: Shows how to compute the stride for a dimension with reversed indices in a SubArray (view), resulting in a negative stride value. Uses stride(V, 3) to expose that moving along the third dimension moves backwards in memory. Requires input view V with third-dimension indices specified in decreasing order. Output: negative integer, indicating backward traversal in the memory buffer. Highlights nuances of memory access with advanced slicing.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_46\n\nLANGUAGE: julia\nCODE:\n```\njulia> stride(V, 3)\n-35\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Catch-All Method in Julia (jldoctest)\nDESCRIPTION: This doctest demonstrates defining a catch-all method for function `f` that accepts arguments of any type (`Any` by default because no types are specified). It shows how `methods(f)` lists this new, less specific method and how it's invoked when no other, more specific method matches the argument types (e.g., `String` and `Int`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_9\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> f(x,y) = println(\"Whoa there, Nelly.\")\nf (generic function with 3 methods)\n\njulia> methods(f)\n# 3 methods for generic function \"f\" from Main:\n [1] f(x::Float64, y::Float64)\n     @ none:1\n [2] f(x::Number, y::Number)\n     @ none:1\n [3] f(x, y)\n     @ none:1\n\njulia> f(\"foo\", 1)\nWhoa there, Nelly.\n```\n\n----------------------------------------\n\nTITLE: Querying All Dimension Strides with strides Function (Julia)\nDESCRIPTION: Shows how to query the full tuple of strides for each dimension of a standard Julia Array using the strides() function. Uses the three-dimensional array A created previously, returning (1, 5, 35). No external dependencies, works with any AbstractArray. Input: array A; Output: tuple of stride values, one per dimension. These describe the memory offset between neighboring elements along each axis.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_43\n\nLANGUAGE: julia\nCODE:\n```\njulia> strides(A)\n(1, 5, 35)\n```\n\n----------------------------------------\n\nTITLE: Optimizing Vectorized Operations with Dot Fusion in Julia\nDESCRIPTION: Defines two functions, `f` using standard element-wise operators and `fdot` using the `@.` macro for dot fusion. Dot fusion combines nested vectorized calls into a single loop, avoiding intermediate array allocations and improving performance compared to `f`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_46\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest dotfuse\njulia> f(x) = 3x.^2 + 4x + 7x.^3;\n\njulia> fdot(x) = @. 3x^2 + 4x + 7x^3; # equivalent to 3 .* x.^2 .+ 4 .* x .+ 7 .* x.^3\n```\n```\n\n----------------------------------------\n\nTITLE: Generating a Blank Julia Package with PkgTemplates - Julia\nDESCRIPTION: This snippet uses the PkgTemplates package to programmatically create a new package directory ('MyPkg') for structured Julia development. The snippet defines and applies a default template object. Required dependencies: the PkgTemplates Julia package must be installed. The generated directory includes starter source and test files for package development.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/workflow-tips.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing PkgTemplates\nt = Template()\nt(\"MyPkg\")\n```\n\n----------------------------------------\n\nTITLE: Taking a Streaming Heap Snapshot in Julia\nDESCRIPTION: Demonstrates taking a heap snapshot using the streaming option (`streaming=true`) by providing a file path prefix (\"snapshot\"). This streams the snapshot data into multiple files, helping to avoid out-of-memory errors during the capture process for large heaps. Requires the `Profile` module.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Profile/docs/src/index.md#_snippet_3\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Profile\n\njulia> Profile.take_heap_snapshot(\"snapshot\"; streaming=true)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic For Loop with a Range in Julia\nDESCRIPTION: Demonstrates a `for` loop iterating over a range object `1:3`, which represents the sequence of integers 1, 2, and 3. In each iteration, the loop variable `i` takes on the next value from the range, and this value is printed within the loop body.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_18\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for i = 1:3\n           println(i)\n       end\n1\n2\n3\n```\n\n----------------------------------------\n\nTITLE: Calling C Functions with stdcall Convention Using ccall in Julia\nDESCRIPTION: This Julia snippet demonstrates how to call the C function gethostname using the stdcall calling convention (commonly required on Windows platforms). It initializes a buffer for the hostname, then uses ccall to invoke the function, specifying argument and return types for FFI correctness. Requires access to libc (or equivalent), proper platform setup, and correct buffer sizing; returns an error code in err. Ensure the target C function supports stdcall on the system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\nhn = Vector{UInt8}(undef, 256)\nerr = ccall(:gethostname, stdcall, Int32, (Ptr{UInt8}, UInt32), hn, length(hn))\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Scopes in Julia with Zero-Argument `let`\nDESCRIPTION: Shows the use of a zero-argument `let` block in Julia to introduce a new scope block without creating any new variable bindings immediately. This example demonstrates nested scopes: the outer `let` contains a local `x` initialized to 1, and the inner `let` introduces another, separate local `x` initialized to 2. The outer `x` remains unaffected and its value (1) is returned.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_21\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> let\n           local x = 1\n           let\n               local x = 2\n           end\n           x\n       end\n1\n```\n```\n\n----------------------------------------\n\nTITLE: Broken Multi-Threaded Summation with Data Race - Julia\nDESCRIPTION: Implements sum_multi_bad, an incorrect attempt at parallelizing a summation function using Threads.@threads leading to a data race. Demonstrates that simply parallelizing accumulation over shared variable 's' is incorrect and yields unreliable results. Accepts an iterable as input and returns an incorrect sum.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_15\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> function sum_multi_bad(a)\n           s = 0\n           Threads.@threads for i in a\n               s += i\n           end\n           s\n       end\nsum_multi_bad (generic function with 1 method)\n\njulia> sum_multi_bad(1:1_000_000)\n70140554652\n```\n\n----------------------------------------\n\nTITLE: Measuring Performance and Allocation with @time (Global Variable)\nDESCRIPTION: Uses the `@time` macro to measure the performance and memory allocation of the `sum_global` function, which operates on an untyped global variable `x`. The output shows significant memory allocation (indicating type instability) and the difference between the first run (including compilation) and subsequent runs. Requires prior definition of `sum_global` and global `x`. The `jldoctest` environment sets up the example.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest; setup = :(using Random; Random.seed!(1234)), filter = r\"[0-9\\.]+ seconds \\(.*\\)\"\njulia> x = rand(1000);\n\njulia> function sum_global()\n           s = 0.0\n           for i in x\n               s += i\n           end\n           return s\n       end;\n\njulia> @time sum_global()\n  0.011539 seconds (9.08 k allocations: 373.386 KiB, 98.69% compilation time)\n523.0007221951678\n\njulia> @time sum_global()\n  0.000091 seconds (3.49 k allocations: 70.156 KiB)\n523.0007221951678\n```\n```\n\n----------------------------------------\n\nTITLE: Basic For Loop Syntax in Julia\nDESCRIPTION: Demonstrates the standard syntax for a `for` loop in Julia, used to iterate over elements in an iterable object `iter`. The loop variable `i` takes the value of each element in sequence.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nfor i in iter   # or  \"for i = iter\"\n    # body\nend\n```\n\n----------------------------------------\n\nTITLE: Defining an Outer Constructor for a Julia Struct (Zero Arguments)\nDESCRIPTION: Defines a zero-argument outer constructor method for the `Foo` struct. This method calls the previously defined single-argument constructor with a default value of `0`, effectively initializing both `bar` and `baz` to `0`. Includes an example call.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Foo() = Foo(0)\nFoo\n\njulia> Foo()\nFoo(0, 0)\n```\n\n----------------------------------------\n\nTITLE: Defining an Outer Constructor for Convenient Object Creation in Julia\nDESCRIPTION: This snippet defines an outer constructor method for the `ConstrainedType` struct (defined previously). This method simplifies object creation by only requiring the first argument `A`. It assumes the existence of a function `compute_B(A)` which calculates the required second argument `B` based on `A`. It then calls the two-argument inner constructor `ConstrainedType(A, computed_B)` to perform the actual instantiation and validation. This pattern provides a user-friendly interface when some fields can be derived from others.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nConstrainedType(A) = ConstrainedType(A, compute_B(A))\n```\n```\n\n----------------------------------------\n\nTITLE: Concatenating Strings Using the * Operator in Julia\nDESCRIPTION: Shows how to use the infix multiplication operator `*` for string concatenation in Julia. This example achieves the same result as using the `string()` function, combining `greet`, \", \", `whom`, and \".\\n\". The surrounding text explains that `*` is chosen over `+` because string concatenation is non-commutative, aligning with mathematical conventions where `*` often denotes non-commutative operations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_24\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> greet * \", \" * whom * \".\\n\"\n\"Hello, world.\\n\"\n```\n\n----------------------------------------\n\nTITLE: Querying Year and Quarter Information from Date in Julia\nDESCRIPTION: Demonstrates checking if a year is leap, calculating the day of the year, the quarter, and the day of quarter for a Date. Each function returns an integer or boolean as appropriate. Requires the Dates module and a Date input.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> Dates.isleapyear(t)\nfalse\n\njulia> Dates.dayofyear(t)\n31\n\njulia> Dates.quarterofyear(t)\n1\n\njulia> Dates.dayofquarter(t)\n31\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid UTF-8 Sequences in Julia Strings\nDESCRIPTION: Illustrates how Julia processes strings containing invalid UTF-8 byte sequences according to specific parsing rules. The example shows an overlong encoding ('\\xc0\\xa0'), malformed sequences ('\\xe2\\x88', '\\xe2'), and a too-high code point ('\\xf7\\xbf\\xbf\\xbf') being represented as distinct invalid characters. `isvalid.(collect(s))` confirms the invalidity of the resulting characters derived from the malformed sequences.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_21\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> s = \"\\xc0\\xa0\\xe2\\x88\\xe2|\"\n\"\\xc0\\xa0\\xe2\\x88\\xe2|\"\n\njulia> foreach(display, s)\n'\\xc0\\xa0': [overlong] ASCII/Unicode U+0020 (category Zs: Separator, space)\n'\\xe2\\x88': Malformed UTF-8 (category Ma: Malformed, bad data)\n'\\xe2': Malformed UTF-8 (category Ma: Malformed, bad data)\n'|': ASCII/Unicode U+007C (category Sm: Symbol, math)\n\njulia> isvalid.(collect(s))\n4-element BitArray{1}:\n 0\n 0\n 0\n 1\n\njulia> s2 = \"\\xf7\\xbf\\xbf\\xbf\"\n\"\\U1fffff\"\n\njulia> foreach(display, s2)\n'\\U1fffff': Unicode U+1FFFFF (category In: Invalid, too high)\n```\n\n----------------------------------------\n\nTITLE: Declaring Parametric Abstract Types in Julia\nDESCRIPTION: Declares an abstract type with a parameter T using Julia syntax. This enables a family of abstract types (Pointy{T}), each differentiated by the type or value assigned to T. No direct dependencies are required other than Julia; this forms the foundational basis for subtyping and polymorphic relationships among user-defined types. No value or field is stored, making it purely a type taxonomy declaration.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\nabstract type Pointy{T} end\n```\n\n----------------------------------------\n\nTITLE: Illustrating Distinct Scope of Julia `for` Loop Iteration Variable\nDESCRIPTION: Defines a Julia function `f` to show that a `for` loop's iteration variable (`i`) is always a new variable, distinct from any variable `i` existing in the outer scope (within the function `f`). The loop iterates with its own `i` from 1 to 3. The function returns the value of the outer `i` (0), which remains unaffected by the loop.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_24\n\nLANGUAGE: julia-repl\nCODE:\n```\n```julia-repl enable_doctest_when_deprecation_warning_is_removed\njulia> function f()\n           i = 0\n           for i = 1:3\n               # empty\n           end\n           return i\n       end;\n\njulia> f()\n0\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring Vararg Tuple Types in Julia\nDESCRIPTION: Shows how to define tuple types that accept a variable number of trailing elements of a specific type using Vararg{T}. Demonstrates the use of isa to confirm tuple value conformity and explains that only trailing positions can be vararg. Essential for varargs function signatures.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_41\n\nLANGUAGE: julia\nCODE:\n```\njulia> mytupletype = Tuple{AbstractString,Vararg{Int}}\nTuple{AbstractString, Vararg{Int64}}\n\njulia> isa((\"1\",), mytupletype)\ntrue\n\njulia> isa((\"1\",1), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2), mytupletype)\ntrue\n\njulia> isa((\"1\",1,2,3.0), mytupletype)\nfalse\n```\n\n----------------------------------------\n\nTITLE: Writing to and Reading from Files - Julia\nDESCRIPTION: Illustrates writing a string to a file and reading its entire contents using `write(filename, content)` and `read(filename, String)`. The first example writes \"Hello, World!\" to hello.txt and returns the byte count, the second reads the contents back as a string. Relies on basic Julia file I/O functions. Inputs are the filename and string data; outputs are the written byte count or file contents. File I/O permissions and file existence are constraints.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_5\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> write(\"hello.txt\", \"Hello, World!\")\\n13\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> read(\"hello.txt\", String)\\n\"Hello, World!\"\n```\n\n----------------------------------------\n\nTITLE: Defining Chunked Parallel Advection using remotecall_wait in Julia REPL\nDESCRIPTION: Defines the function `advection_shared!`, which implements parallel advection using manual chunking based on `SharedArray`. It iterates through the participating processes (`procs(q)`) and uses `Threads.@spawn` to asynchronously launch `remotecall_wait` calls. Each remote call executes `advection_shared_chunk!(q, u)` on a specific worker `p`, which computes its assigned chunk. `@sync` waits for all spawned tasks to complete.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\njulia> function advection_shared!(q, u)\n           @sync begin\n               for p in procs(q)\n                   Threads.@spawn remotecall_wait(advection_shared_chunk!, p, q, u)\n               end\n           end\n           q\n       end;\n```\n\n----------------------------------------\n\nTITLE: Removing Internal Newlines with Backslash in Triple-Quoted Julia Strings\nDESCRIPTION: Illustrates using a backslash (`\\`) at the very end of a line within a triple-quoted string literal to remove the newline character that would normally follow. This allows joining lines while respecting overall dedentation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_36\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> \"\"\"\n         Averylong\\\n         word\"\"\"\n\"Averylongword\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Variable Types with :: in Julia Functions\nDESCRIPTION: This Julia snippet showcases a function with a variable annotated using the :: operator to enforce a specific type (Int8). Every value assigned to the variable is converted to that type, and the function returns the value. This form of annotation is useful for performance and reliability, ensuring variables have predictable types. No special dependencies are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> function foo()\n           x::Int8 = 100\n           x\n       end\nfoo (generic function with 1 method)\n\njulia> x = foo()\n100\n\njulia> typeof(x)\nInt8\n```\n\n----------------------------------------\n\nTITLE: Using if Statements without Parentheses - Julia - julia\nDESCRIPTION: Demonstrates the preferred Julia syntax for conditional statements by omitting parentheses around conditions in if or while statements. No dependencies are required other than the Julia standard environment. The code expects a boolean expression and results in control flow based on the condition evaluation. Parentheses are not required and omitting them leads to cleaner, idiomatic Julia code.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nif a == b\n\n```\n\n----------------------------------------\n\nTITLE: Examining Floating-Point Zero and Signed Zero Representation (Julia)\nDESCRIPTION: This snippet explores the existence of positive and negative zero in floating-point arithmetic and how their binary representations differ even though they compare as equal. Shows how to use the bitstring function to inspect the raw bits. No dependencies required; input/output in the Julia REPL.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\njulia> 0.0 == -0.0\ntrue\n\njulia> bitstring(0.0)\n\"0000000000000000000000000000000000000000000000000000000000000000\"\n\njulia> bitstring(-0.0)\n\"1000000000000000000000000000000000000000000000000000000000000000\"\n```\n\n----------------------------------------\n\nTITLE: Verifying Self-Referential Object Construction in Julia\nDESCRIPTION: Creates an instance `x` of the `SelfReferential` struct (using the definition with the inner constructor). It then uses the identity comparison operator `===` to verify that the object `x`, its `obj` field (`x.obj`), and the `obj` field of the object referenced by `x.obj` (`x.obj.obj`) all point to the exact same object in memory, confirming the self-referential nature.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_10\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = SelfReferential();\n\njulia> x === x\ntrue\n\njulia> x === x.obj\ntrue\n\njulia> x === x.obj.obj\ntrue\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Self-Referential Struct in Julia\nDESCRIPTION: Demonstrates attempting to create an instance `b` of the previously defined `SelfReferential` struct by passing an existing instance `a` to its default constructor. This highlights the bootstrapping problem: how to create the very first instance when none exist.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_8\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> b = SelfReferential(a)\n```\n\n----------------------------------------\n\nTITLE: Performing Multi-Dimensional Array Concatenation in Julia\nDESCRIPTION: Demonstrates concatenation along higher dimensions (3rd, 4th, etc.) using multiple semicolons. The number of semicolons indicates the dimension along which to concatenate (`;` for dim 1, `;;` for dim 2, `;;;` for dim 3, etc.). Fewer semicolons take precedence, concatenating lower dimensions first.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_6\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [1; 2;; 3; 4;; 5; 6;;;\n        7; 8;; 9; 10;; 11; 12]\n2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n```\n\n----------------------------------------\n\nTITLE: Propagating `missing` through Equality and Comparison Operators in Julia\nDESCRIPTION: Shows that standard equality (`==`) and comparison operators (`<`, `>=`) return `missing` when comparing with a `missing` value. This includes comparing `missing` with itself (`missing == missing`), highlighting that `==` cannot be used to test for missingness. Use `ismissing(x)` instead.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_1\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> missing == 1\nmissing\n\njulia> missing == missing\nmissing\n\njulia> missing < 1\nmissing\n\njulia> 2 >= missing\nmissing\n```\n\n----------------------------------------\n\nTITLE: Creating a Zero-Dimensional Array in Julia\nDESCRIPTION: This Julia code demonstrates the creation of a zero-dimensional array of `Float64` using the `zeros()` function without any arguments. The output shows the type (`Array{Float64,0}`) and the single element (`0.0`) contained within it. This illustrates the basic syntax for initializing such arrays.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\njulia> A = zeros()\n0-dimensional Array{Float64,0}:\n0.0\n```\n\n----------------------------------------\n\nTITLE: Sorting an Array in Reverse Order - Julia\nDESCRIPTION: Shows usage of the rev keyword to sort an array in descending order. This snippet highlights keyword-based customization of sorting. The function returns a new array and requires no explicit dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/sort.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njldoctest\\njulia> sort([2,3,1], rev=true)\\n3-element Vector{Int64}:\\n 3\\n 2\\n 1\n```\n\n----------------------------------------\n\nTITLE: Comparing Default and Explicit Inner Constructors in Julia\nDESCRIPTION: Compares two structs, `T1` which relies on the automatically generated default constructor, and `T2` which has an explicit inner constructor mimicking the default behavior. Both structs have a single field `x` of type `Int64`. The examples demonstrate that both constructors behave identically, accepting `Int64` and also automatically converting compatible types like `Float64` to `Int64` upon instantiation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_6\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct T1\n           x::Int64\n       end\n\njulia> struct T2\n           x::Int64\n           T2(x) = new(x)\n       end\n\njulia> T1(1)\nT1(1)\n\njulia> T2(1)\nT2(1)\n\njulia> T1(1.0)\nT1(1)\n\njulia> T2(1.0)\nT2(1)\n```\n\n----------------------------------------\n\nTITLE: Scoping Pitfall with Variables in try/catch/else/finally - Julia\nDESCRIPTION: Demonstrates the scoping rules in Julia's try/catch/else/finally constructs: variables defined in try are not accessible in else/finally unless declared as local in an enclosing scope. An interactive example for attempting to use a variable defined in try within else, showing error message details.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_39\n\nLANGUAGE: julia\nCODE:\n```\njulia> try\n           foo = 1\n       catch\n       else\n           foo\n       end\nERROR: UndefVarError: `foo` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\n\n```\n\n----------------------------------------\n\nTITLE: Using Function Types as First-Class Objects in Julia\nDESCRIPTION: Assigns the type of the previously defined function `foo41` to the variable `T`. It then confirms that this function type `T` is a first-class object and indeed a subtype of the base `Function` type using the `<:` operator.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_52\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> T = typeof(foo41)\ntypeof(foo41) (singleton type of function foo41, subtype of Function)\n\njulia> T <: Function\ntrue\n```\n\n----------------------------------------\n\nTITLE: Displaying Ranges for Primitive Integer Types in Julia\nDESCRIPTION: Uses a `for` loop and string interpolation to iterate through various primitive integer types (both signed and unsigned) and print their minimum and maximum representable values using `typemin` and `typemax`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> for T in [Int8,Int16,Int32,Int64,Int128,UInt8,UInt16,UInt32,UInt64,UInt128]\n           println(\"$(lpad(T,7)): [$(typemin(T)),$(typemax(T))]\")\n       end\n   Int8: [-128,127]\n  Int16: [-32768,32767]\n  Int32: [-2147483648,2147483647]\n  Int64: [-9223372036854775808,9223372036854775807]\n Int128: [-170141183460469231731687303715884105728,170141183460469231731687303715884105727]\n  UInt8: [0,255]\n UInt16: [0,65535]\n UInt32: [0,4294967295]\n UInt64: [0,18446744073709551615]\nUInt128: [0,340282366920938463463374607431768211455]\n```\n```\n\n----------------------------------------\n\nTITLE: Efficient Parallel Remote Execution using `remotecall_fetch` in Julia\nDESCRIPTION: This Julia snippet demonstrates an efficient method for executing a function `foo` on multiple worker processes in parallel using the `Distributed` package. It utilizes `remotecall_fetch` within a `Threads.@spawn` call inside a `@sync` block, fetching results directly and minimizing network round-trips (one per worker). This approach is generally faster than separately spawning tasks and then fetching results.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_66\n\nLANGUAGE: julia\nCODE:\n```\nusing Distributed\n\nresponses = Vector{Any}(undef, nworkers())\n@sync begin\n    for (idx, pid) in enumerate(workers())\n        Threads.@spawn responses[idx] = remotecall_fetch(foo, pid, args...)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Using the 'return' Keyword for Early Exit in a Julia Function\nDESCRIPTION: Defines a function `g` that demonstrates the use of the `return` keyword. The keyword causes the function to immediately stop execution and return the value of the expression `x * y`. The subsequent line `x + y` is never reached or evaluated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nfunction g(x, y)\n    return x * y\n    x + y\nend\n```\n\n----------------------------------------\n\nTITLE: Capturing Substrings with Regex Groups in Julia\nDESCRIPTION: Shows how to define a regular expression with a capturing group `(.*?)` to extract specific parts of the matched string. The `match` function returns a `RegexMatch` object where captured substrings can be accessed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_46\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> m = match(r\"^\\s*(?:#\\s*(.*?)\\s*$)\", \"# a comment \")\nRegexMatch(\"# a comment \", 1=\"a comment\")\n```\n\n----------------------------------------\n\nTITLE: Importing Specific Identifiers and Module Name with `using` in Julia\nDESCRIPTION: Shows how to import specific identifiers (`nice`, `DOG`) along with the module name (`NiceStuff`) itself by explicitly listing the module name in the `using` statement.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_9\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using .NiceStuff: nice, DOG, NiceStuff\n```\n\n----------------------------------------\n\nTITLE: Constructing Instances of Parametric Types in Julia\nDESCRIPTION: Demonstrates different ways to construct instances of the parametric `Point{T}` type. It shows explicit construction by providing the type parameter (`Point{Float64}(1.0, 2.0)`). It also covers implicit construction where the type parameter is inferred from the arguments (`Point(1.0, 2.0)` infers `Float64`, `Point(1, 2)` infers `Int64`). The example highlights `MethodError` exceptions: one occurs when the wrong number of arguments is provided to the explicit constructor, and another when argument types are mismatched for the implicit constructor (`Point(1, 2.5)`), preventing unambiguous inference of the type parameter `T`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_25\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> p = Point{Float64}(1.0, 2.0)\nPoint{Float64}(1.0, 2.0)\n\njulia> typeof(p)\nPoint{Float64}\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Point{Float64}(1.0)\nERROR: MethodError: no method matching Point{Float64}(::Float64)\nThe type `Point{Float64}` exists, but no method is defined for this combination of argument types when trying to construct it.\n[...]\n\njulia> Point{Float64}(1.0, 2.0, 3.0)\nERROR: MethodError: no method matching Point{Float64}(::Float64, ::Float64, ::Float64)\nThe type `Point{Float64}` exists, but no method is defined for this combination of argument types when trying to construct it.\n[...]\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> p1 = Point(1.0,2.0)\nPoint{Float64}(1.0, 2.0)\n\njulia> typeof(p1)\nPoint{Float64}\n\njulia> p2 = Point(1,2)\nPoint{Int64}(1, 2)\n\njulia> typeof(p2)\nPoint{Int64}\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Point(1,2.5)\nERROR: MethodError: no method matching Point(::Int64, ::Float64)\nThe type `Point` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  Point(::T, !Matched::T) where T\n   @ Main none:2\n\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Using Numeric Literal Coefficients for Cleaner Mathematical Expressions in Julia\nDESCRIPTION: Exemplifies Julia's feature allowing adjacent numeric literals and variables to indicate multiplication, streamlining polynomial and exponential math code. These examples require no dependencies beyond Julia Base. Inputs are numeric coefficients and variables; outputs demonstrate the parsed results and computed values. The feature has higher precedence than multiplication/division, but slightly lower than unary operators. When used incorrectly (e.g., juxtaposed parenthesized expressions), it results in MethodError from attempted function application.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = 3\n3\n\njulia> 2x^2 - 3x + 1\n10\n\njulia> 1.5x^2 - .5x + 1\n13.0\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 2^2x\n64\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 2(x-1)^2 - 3(x-1) + 1\n3\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (x-1)x\n6\n```\n\n----------------------------------------\n\nTITLE: Using Type{T} for Type Assertions in Julia\nDESCRIPTION: Demonstrates the use of the `Type{T}` type selector for checking type identity. `isa(A, Type{B})` evaluates to true if and only if `A` and `B` are the exact same type object. The examples show `isa(Float64, Type{Float64})` is true, while `isa(Real, Type{Float64})` is false.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_55\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> isa(Float64, Type{Float64})\ntrue\n\njulia> isa(Real, Type{Float64})\nfalse\n\njulia> isa(Real, Type{Real})\ntrue\n\njulia> isa(Float64, Type{Real})\nfalse\n```\n\n----------------------------------------\n\nTITLE: Efficient Filtering with Known Dimension Using Val and N-Parameterization - Base Julia - Julia\nDESCRIPTION: Showcases how to appropriately use type-parameterized values (`Val(N)`) when the dimension `N` is obtained from the type context (an AbstractArray type parameter). This allows for type stability and enables the compiler to optimize the output array's type. Dependencies are limited to Julia Base, and the snippet assumes a `filter` function is defined for arrays and kernels.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_40\n\nLANGUAGE: julia\nCODE:\n```\nfunction filter3(A::AbstractArray{T,N}) where {T,N}\n    kernel = array3(1, Val(N))\n    filter(A, kernel)\nend\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic Operations with Complex Numbers in Julia\nDESCRIPTION: Shows multiple arithmetic operations (multiplication, division, addition, subtraction, integer exponentiation, float exponentiation, and juxtaposed multiplication with literals) on complex numbers using Julia's built-in operators and type system. No special dependencies are required; standard Julia syntax and built-in types are used. Inputs are various combinations of complex number literals; outputs are the computed complex results, handling both integers and floats.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> (1 + 2im)*(2 - 3im)\n8 + 1im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (1 + 2im)/(1 - 2im)\n-0.6 + 0.8im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (1 + 2im) + (1 - 2im)\n2 + 0im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (-3 + 2im) - (5 - 1im)\n-8 + 3im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (-1 + 2im)^2\n-3 - 4im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (-1 + 2im)^2.5\n2.729624464784009 - 6.9606644595719im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (-1 + 2im)^(1 + 1im)\n-0.27910381075826657 + 0.08708053414102428im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 3(2 - 5im)\n6 - 15im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 3(2 - 5im)^2\n-63 - 60im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 3(2 - 5im)^-1.0\n0.20689655172413793 + 0.5172413793103449im\n```\n\n----------------------------------------\n\nTITLE: Sorting by a Key Function (Transformation) - Julia\nDESCRIPTION: Explains the use of the by keyword to sort an array according to a transformation of its values, such as by absolute value. No extra packages are needed; key functions are passed directly. Output is a sorted array based on the key rather than the value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/sort.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia-repl\\njulia> sort(v, by=abs)\\n5-element Vector{Float64}:\\n -0.0104452\\n  0.297288\\n  0.382396\\n -0.597634\\n -0.839027\n```\n\n----------------------------------------\n\nTITLE: Defining a Function Supporting Do-Block Syntax in Julia\nDESCRIPTION: Provides the implementation pattern for a function (`open`) that supports the `do` block syntax. It accepts a function `f` as its first argument, performs setup (opening the file), executes the passed function `f` within a `try` block, and guarantees resource cleanup (closing the file) in a `finally` block.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\nfunction open(f::Function, args...)\n    io = open(args...)\n    try\n        f(io)\n    finally\n        close(io)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Using the `@.` Macro for Automatic Dot Syntax Application in Julia\nDESCRIPTION: Illustrates the `@.` macro, which automatically adds dots to every function call, operation, and assignment within an expression, converting it to use broadcasting and fusion. The example calculates `sin(cos(Y))` elementwise for each element in `Y` and stores the result in a pre-allocated vector `X` using in-place assignment (`.=`). This is equivalent to writing `X .= sin.(cos.(Y))`. Pre-allocating `X` with `similar(Y)` improves efficiency.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_43\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Y = [1.0, 2.0, 3.0, 4.0];\n\njulia> X = similar(Y); # pre-allocate output array\n\njulia> @. X = sin(cos(Y)) # equivalent to X .= sin.(cos.(Y))\n4-element Vector{Float64}:\n  0.5143952585235492\n -0.4042391538522658\n -0.8360218615377305\n -0.6080830096407656\n```\n\n----------------------------------------\n\nTITLE: Ensuring Correct Operator Precedence in Custom Printing in Julia\nDESCRIPTION: Extends pretty-printing for the Polar type by defining a custom show_unquoted method that inserts parentheses based on operator precedence. This ensures that expressions containing Polar instances remain correctly parenthesized when printed as part of larger expressions. Relies on Julia's operator_precedence function for infix operator context.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_73\n\nLANGUAGE: julia\nCODE:\n```\nfunction Base.show_unquoted(io::IO, z::Polar, ::Int, precedence::Int)\\n    if Base.operator_precedence(:*) <= precedence\\n        print(io, \"(\")\\n        show(io, z)\\n        print(io, \")\")\\n    else\\n        show(io, z)\\n    end\\nend\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Union Types and Diagonal Dispatch - Julia\nDESCRIPTION: Shows how to use Union{Nothing, T} in method signatures for flexible dispatch. Allows the first argument to be Nothing or T, while the second remains restricted to T. Inputs: x::Union{Nothing,T}, y::T; Outputs: as defined by the function. Shows how type relations influence function matching in the presence of Union types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nf(x::Union{Nothing,T}, y::T) where {T} = ...\n```\n\n----------------------------------------\n\nTITLE: Return Value of Destructuring Assignment in Julia\nDESCRIPTION: Shows that a destructuring assignment (`x, y = [2, 3]`) in Julia evaluates to the entire right-hand side collection (`[2, 3]`). The example contrasts implicitly returning this original collection from the function `twothreearr` versus explicitly constructing and returning a new tuple `(x, y)` composed of the assigned variables in `twothreetup`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_12\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function twothreetup()\n           x, y = [2, 3] # assigns 2 to x and 3 to y\n           x, y # returns a tuple\n       end\ntwothreetup (generic function with 1 method)\n\njulia> function twothreearr()\n           x, y = [2, 3] # returns an array\n       end\ntwothreearr (generic function with 1 method)\n\njulia> twothreetup()\n(2, 3)\n\njulia> twothreearr()\n2-element Vector{Int64}:\n 2\n 3\n```\n\n----------------------------------------\n\nTITLE: Using `missing` with Short-Circuiting Operators (`||`, `&&`) - Non-Error Cases in Julia\nDESCRIPTION: Illustrates scenarios where short-circuiting operators (`&&` in this case) do not throw an error when encountering `missing`. This occurs either when the operator short-circuits before reaching `missing` (e.g., `false && missing`) or when `missing` is the last operand evaluated (e.g., `true && missing`). The result propagates `missing` if it depends on the missing value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_10\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> true && missing\nmissing\n\njulia> false && missing\nfalse\n```\n\n----------------------------------------\n\nTITLE: Using @eval with a begin-end Block for Multi-Line Code Generation in Julia\nDESCRIPTION: Shows that the `@eval` macro is not limited to single expressions and can be used to evaluate larger blocks of code. By passing a `begin ... end` block containing multiple lines of code to `@eval`, complex code generation tasks can be performed dynamically within the program.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_54\n\nLANGUAGE: julia\nCODE:\n```\n@eval begin\n    # multiple lines\nend\n```\n\n----------------------------------------\n\nTITLE: Defining and Modifying a Mutable Composite Type with mutable struct in Julia\nDESCRIPTION: Illustrates the definition of a mutable struct Bar with one untyped and one typed field, followed by creating an instance and modifying its fields. Showcases mutability by both changing typed and untyped fields, including using rational numbers. No dependencies other than the mutable struct feature in standard Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\nmutable struct Bar\n    baz\n    qux::Float64\nend\n\nbar = Bar(\"Hello\", 1.5);\n\nbar.qux = 2.0\n2.0\n\nbar.baz = 1//2\n1//2\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Sum Function for Real Numbers in Julia\nDESCRIPTION: This snippet defines a Julia function `mysum` that takes two arguments, both constrained to be subtypes of `Real`. The function calculates and returns their sum using the `+` operator. This single method definition handles various specific `Real` types (like Int, Float64) due to multiple dispatch on the underlying `+` operator.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nmysum(x::Real, y::Real) = x + y\n```\n\n----------------------------------------\n\nTITLE: Calling a Generated Function and Observing Behavior in Julia\nDESCRIPTION: Demonstrates calling the previously defined generated function `foo` with different argument types (`Int` and `String`). It shows that `Core.println(x)` inside the generated function's definition prints the *type* of the argument (`Int64`, `String`) the first time it's called with that type. The returned value (`x` or `y`) is the result of executing the generated code (`x * x` or equivalent).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_63\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = foo(2); # note: output is from println() statement in the body\nInt64\n\njulia> x           # now we print x\n4\n\njulia> y = foo(\"bar\");\nString\n\njulia> y\n\"barbar\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Float32 Literals in Julia (Julia)\nDESCRIPTION: Shows how to write float literals of type Float32 using 'f' notation instead of 'e' for the exponent, and demonstrates type introspection. No dependencies required; outputs show Float32 formatted values and how to explicitly create float32 literals or parse them with correct syntax in Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = 0.5f0\n0.5f0\n\njulia> typeof(x)\nFloat32\n\njulia> 2.5f-4\n0.00025f0\n```\n\n----------------------------------------\n\nTITLE: Creating a Julia Task using @task\nDESCRIPTION: Creates a Julia `Task` object named `t` using the `@task` macro. The task is defined to execute a block of code: first `sleep(5)` (pausing for 5 seconds) and then `println(\"done\")`. The output shows the `Task` object is created in a runnable state but hasn't started execution yet. This is equivalent to `Task(()->begin; sleep(5); println(\"done\"); end)`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/asynchronous-programming.md#_snippet_0\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> t = @task begin; sleep(5); println(\"done\"); end\nTask (runnable) @0x00007f13a40c0eb0\n```\n\n----------------------------------------\n\nTITLE: Parsing Function Definitions with Parameters and Where Constraints – Julia\nDESCRIPTION: Demonstrates a Julia function definition with argument type annotation, keyword parameters with defaults, and a 'where' clause expressing a type constraint. When parsed, this snippet is converted into a nested AST that encodes argument binding, default values, parameter types, the where constraint, and a return expression.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ast.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(x::T; k = 1) where T\n    return x+1\nend\n```\n\n----------------------------------------\n\nTITLE: Remote Computation with Remote Data Creation in Julia (@spawnat)\nDESCRIPTION: This snippet demonstrates Method 2 for the same remote computation. `@spawnat :any rand(1000,1000)^2` instructs an arbitrary worker process to *first* create the random matrix (`rand(1000,1000)`) and *then* square it (`^2`) entirely on the worker. The result future is stored in `Bref`, and `fetch(Bref)` retrieves only the final computed matrix. This minimizes data transfer compared to Method 1, as the large initial matrix is never sent from the local process.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_12\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> Bref = @spawnat :any rand(1000,1000)^2;\n\n[...]\n\njulia> fetch(Bref);\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Docstring for a Function - Julia\nDESCRIPTION: Shows how to attach a string docstring immediately above a function definition. This string will be registered by Julia's documentation system. There must be no intervening blank lines or comments. This pattern applies widely for documenting any object supported by docstrings.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n\"Tell whether there are too foo items in the array.\"\nfoo(xs::Array) = ...\n```\n\n----------------------------------------\n\nTITLE: Returning Non-Boolean Values from Conditional Chains in Julia\nDESCRIPTION: Demonstrates that while intermediate operands of `&&` and `||` must be boolean, the final expression in a conditional chain can be of any type. The value of this final expression (here, a tuple `(1, 2, 3)`) is evaluated and returned only if the preceding conditions allow the evaluation to reach it (e.g., when the first operand is `true` for `&&`). If the chain short-circuits earlier, the boolean value causing the short-circuit is returned (e.g., `false`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_16\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> true && (x = (1, 2, 3))\n(1, 2, 3)\n\njulia> false && (x = (1, 2, 3))\nfalse\n```\n\n----------------------------------------\n\nTITLE: Defining Unsigned Binary and Octal Literals in Julia\nDESCRIPTION: Shows the syntax for unsigned integer literals using binary (`0b` prefix) and octal (`0o` prefix). Similar to hexadecimal literals, these produce unsigned integer types, and the size is determined by the minimal necessary bits, influenced by leading zeros if present.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> x = 0b10\n0x02\n\njulia> typeof(x)\nUInt8\n\njulia> x = 0o010\n0x08\n\njulia> typeof(x)\nUInt8\n\njulia> x = 0x00000000000000001111222233334444\n0x00000000000000001111222233334444\n\njulia> typeof(x)\nUInt128\n```\n```\n\n----------------------------------------\n\nTITLE: Composing `sqrt` and `+` Functions in Julia\nDESCRIPTION: Demonstrates basic function composition in Julia using the `∘` operator (typed as `\\circ<tab>`). `(sqrt ∘ +)(3, 6)` is equivalent to `sqrt(+(3, 6))`, first adding 3 and 6, then taking the square root of the sum.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_34\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> (sqrt ∘ +)(3, 6)\n3.0\n```\n\n----------------------------------------\n\nTITLE: Initializing Small Nonzero Array to Avoid Subnormals in Julia\nDESCRIPTION: Shows how to prefill an array with small random values in order to avoid generating subnormals during computation. The snippet multiplies random floats by a small constant. Input: intended array length and type; Output: nonzero-initialized array. Limitation: Useful only when subnormal performance issues are anticipated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_65\n\nLANGUAGE: julia\nCODE:\n```\na = rand(Float32,1000) * 1.f-9\n\n```\n\n----------------------------------------\n\nTITLE: Equality Comparison of Zero-valued FixedPeriod and OtherPeriod Types - Julia\nDESCRIPTION: This snippet illustrates that zero-valued FixedPeriod and OtherPeriod objects now compare equal in Julia's Dates module, providing more intuitive and consistent comparisons. For instance, Year(0) == Day(0) now gives true, while nonzero period comparisons are unchanged. Dependencies are limited to the Dates module, and applies when comparing periods with zero values.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_75\n\nLANGUAGE: julia\nCODE:\n```\nusing Dates\n@assert Year(0) == Day(0) # Evaluates to true\n@assert Year(1) != Day(1) # Evaluates to true, nonzero values unchanged\n```\n\n----------------------------------------\n\nTITLE: Illustrating AST-Based Macro Dispatch vs Runtime Types in Julia\nDESCRIPTION: Demonstrates a key aspect of macro dispatch: it is based on the types of the Abstract Syntax Tree (AST) nodes passed to the macro, not the runtime types of the values those nodes evaluate to. A method `macro m(::Int)` is added. `@m 2` matches this method because `2` is an `Int` literal in the AST. However, `@m x` (where `x` is a variable holding the integer 2) does not match `::Int`; instead, it matches the variadic `args...` method because `x` is a `Symbol` node in the AST.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_48\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> macro m(::Int)\n           println(\"An Integer\")\n       end\n@m (macro with 3 methods)\n\njulia> @m 2\nAn Integer\n\njulia> x = 2\n2\n\njulia> @m x\n1 arguments\n```\n\n----------------------------------------\n\nTITLE: Running a Julia Script with Arguments (Bash)\nDESCRIPTION: Demonstrates the basic syntax for executing a Julia script (`script.jl`) from the command line, passing command-line arguments (`arg1`, `arg2`, etc.) to the script. These arguments become available within the script via the `ARGS` global constant.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ julia script.jl arg1 arg2...\n```\n\n----------------------------------------\n\nTITLE: Running Julia from the Command Line (Shell)\nDESCRIPTION: This snippet demonstrates the basic syntax for executing the Julia interpreter from a command line. It outlines the structure where optional switches precede the program file (if any) and its arguments, separated by '--'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\njulia [switches] -- [programfile] [args...]\n```\n\n----------------------------------------\n\nTITLE: Explicitly Modifying Global Variable in Loop using `global` (Julia)\nDESCRIPTION: Shows the explicit and unambiguous way to modify a global variable `s` from within a loop scope in Julia. Using the `global` keyword before `s += i` explicitly declares the intention to modify the global variable `s`, resolving any potential soft scope ambiguity. This was necessary in non-interactive contexts before Julia 1.5 and remains the clearest way to express this intent.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\ns = 0\nfor i = 1:10\n    global s += i\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Macro in Julia\nDESCRIPTION: Introduces a basic macro definition using the `macro` keyword. The `@sayhello` macro takes no arguments and returns a quoted expression `:( println(\"Hello, world!\") )`, which will replace calls to `@sayhello` during compilation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_19\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> macro sayhello()\n           return :( println(\"Hello, world!\") )\n       end\n@sayhello (macro with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic with BigInt and BigFloat Types in Julia\nDESCRIPTION: Demonstrates construction and usage of arbitrary-precision integer (BigInt) and floating-point (BigFloat) numbers in Julia. These snippets utilize constructors, string macros (big\"...\"), and parse for conversion, showing arithmetic operations, type promotion, and precision control. The examples require Julia's Base library and depend on the GMP and MPFR libraries for large number computations. Inputs include string or numeric type values; outputs are arbitrary-precision results as BigInt or BigFloat. Constraints include requiring explicit constructors for interoperability and an understanding that unsigned arbitrary-precision integer types are not available in Base.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\njulia> BigInt(typemax(Int64)) + 1\n9223372036854775808\n\njulia> big\"123456789012345678901234567890\" + 1\n123456789012345678901234567891\n\njulia> parse(BigInt, \"123456789012345678901234567890\") + 1\n123456789012345678901234567891\n\njulia> string(big\"2\"^200, base=16)\n\"100000000000000000000000000000000000000000000000000\"\n\njulia> 0x100000000000000000000000000000000-1 == typemax(UInt128)\ntrue\n\njulia> 0x000000000000000000000000000000000\n0\n\njulia> typeof(ans)\nBigInt\n\njulia> big\"1.23456789012345678901\"\n1.234567890123456789010000000000000000000000000000000000000000000000000000000004\n\njulia> parse(BigFloat, \"1.23456789012345678901\")\n1.234567890123456789010000000000000000000000000000000000000000000000000000000004\n\njulia> BigFloat(2.0^66) / 3\n2.459565876494606882133333333333333333333333333333333333333333333333333333333344e+19\n\njulia> factorial(BigInt(40))\n815915283247897734345611269596115894272000000000000\n```\n\n----------------------------------------\n\nTITLE: MethodError for Unsupported Argument Types or Arity (Julia)\nDESCRIPTION: This snippet exemplifies Julia's response to unsupported function argument types or numbers, resulting in a MethodError. It includes cases where a non-numeric string is provided or the function is called with no arguments, showing Julia's explicit error reporting and signature hints. No dependencies are involved.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(\"foo\", 3)\nERROR: MethodError: no method matching f(::String, ::Int64)\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  f(!Matched::Number, ::Number)\n   @ Main none:1\n  f(!Matched::Float64, !Matched::Float64)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> f()\nERROR: MethodError: no method matching f()\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  f(!Matched::Float64, !Matched::Float64)\n   @ Main none:1\n  f(!Matched::Number, !Matched::Number)\n   @ Main none:1\n\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum and Maximum Integer Values in Julia\nDESCRIPTION: Shows the use of `typemin` and `typemax` functions to get the minimum and maximum representable values for a specific integer type (`Int32` in this example).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> (typemin(Int32), typemax(Int32))\n(-2147483648, 2147483647)\n```\n```\n\n----------------------------------------\n\nTITLE: Function Call Equivalent to Julia Indexed Assignment\nDESCRIPTION: Shows the explicit function call `setindex!(A, X, I_1, ..., I_n)` which is the underlying function equivalent to the standard Julia indexed assignment syntax `A[I_1, ..., I_n] = X` when the `end` keyword is not used.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_25\n\nLANGUAGE: plaintext\nCODE:\n```\nsetindex!(A, X, I_1, I_2, ..., I_n)\n```\n\n----------------------------------------\n\nTITLE: Array Construction and Concatenation in Julia\nDESCRIPTION: In Julia, `[x,y,z]` creates a 3-element vector. Vertical concatenation uses `vcat(x,y,z)` or semicolons `[x; y; z]`. Horizontal concatenation uses `hcat(x,y,z)` or spaces `[x y z]`. Block matrices use `hvcat` or a combination `[a b; c d]`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n[x,y,z] # Creates a Vector{Any} with elements x, y, z\n```\n\nLANGUAGE: julia\nCODE:\n```\nvcat(x,y,z)\n```\n\nLANGUAGE: julia\nCODE:\n```\n[x; y; z]\n```\n\nLANGUAGE: julia\nCODE:\n```\nhcat(x,y,z)\n```\n\nLANGUAGE: julia\nCODE:\n```\n[x y z]\n```\n\nLANGUAGE: julia\nCODE:\n```\nhvcat(...)\n```\n\nLANGUAGE: julia\nCODE:\n```\n[a b; c d]\n```\n\n----------------------------------------\n\nTITLE: Using esc() in a Macro for Proper Hygiene in Julia\nDESCRIPTION: Revises the `@time` macro to correctly handle hygiene by using `esc()`. Wrapping the input expression `ex` with `$(esc(ex))` instructs the macro expander to leave the expression as is, ensuring it gets evaluated in the context where the macro is *called*, rather than where the macro is *defined*. This resolves the issue shown in the previous `MyModule` example.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_44\n\nLANGUAGE: julia\nCODE:\n```\nmacro time(ex)\n    ...\n    local val = $(esc(ex))\n    ...\nend\n```\n\n----------------------------------------\n\nTITLE: Checking Type Membership with isa in Julia\nDESCRIPTION: Demonstrates usage of the isa function to check if a given object is an instance of a specified type. Returns true or false depending on the object's type, allowing for runtime verification and dispatch logic. Accepts any value and type as parameters.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_63\n\nLANGUAGE: julia\nCODE:\n```\nisa(1, Int)\\nisa(1, AbstractFloat)\n```\n\n----------------------------------------\n\nTITLE: Calculating Row Norms using Fused Broadcast in Julia\nDESCRIPTION: Demonstrates normalizing the rows of a matrix `x` to have Euclidean norm one using broadcasted division (`./=`) and element-wise square root (`sqrt.`). This initial approach uses fused broadcasting, which recomputes `sqrt(d[i])` for every element in row `i`, potentially leading to redundant calculations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_48\n\nLANGUAGE: julia\nCODE:\n```\n```julia\njulia> x = rand(1000, 1000);\n\njulia> d = sum(abs2, x; dims=2);\n\njulia> @time x ./= sqrt.(d);\n  0.002049 seconds (4 allocations: 96 bytes)\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Summation with Inbounds Optimization in Julia\nDESCRIPTION: Defines a `sum` function for `AbstractArray` types. It uses `@inbounds` within the loop to signal the compiler that bounds checking for the array access `A[i]` can be skipped, potentially improving performance, especially in tight loops or for enabling SIMD vectorization. The loop iterates using `eachindex(A)` for safe index handling across different array types, including those with custom indices.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/boundscheck.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nfunction sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i in eachindex(A)\n        @inbounds r += A[i]\n    end\n    return r\nend\n```\n\n----------------------------------------\n\nTITLE: Accessing a Julia Array Returned from a C Call\nDESCRIPTION: This C snippet shows how to handle a Julia array returned by a Julia function called from C. It retrieves the Julia function `reverse` using `jl_get_function`, calls it with array `x` using `jl_call1`, and casts the returned `jl_value_t*` to a `jl_array_t*`. The data of the returned array `y` can then be accessed using `jl_array_data`. Assumes `jl_base_module`, `func`, and `x` are appropriately defined.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_29\n\nLANGUAGE: c\nCODE:\n```\njl_function_t *func  = jl_get_function(jl_base_module, \"reverse\");\njl_array_t *y = (jl_array_t*)jl_call1(func, (jl_value_t*)x);\n```\n\n----------------------------------------\n\nTITLE: Creating and Inspecting Cmd Objects - Julia\nDESCRIPTION: Shows how to construct a Julia Cmd object using backtick syntax, demonstrates that creating such an object does not execute the command immediately, and inspects the resulting object's type. Cmd objects represent external commands and can be used with Julia process management functions. No external dependencies are required for constructing Cmd objects; the key output is the Cmd object itself.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> `echo hello`\n`echo hello`\n```\n```\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> mycommand = `echo hello`\n`echo hello`\n\njulia> typeof(mycommand)\nCmd\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Generic and Specific addone Functions - julia\nDESCRIPTION: Illustrates several function definitions for an addone function that adds one to its argument, with increasing generality: specific to Int, Integer, Number, and then any type supporting + and oneunit. Demonstrates idiomatic function design in Julia and the benefits of writing generic code. Inputs: argument x of variable type; outputs: x incremented by one (in the same type as x). Relies on Julia's multiple dispatch, the oneunit function, and the + operator.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\naddone(x::Int) = x + 1                 # works only for Int\naddone(x::Integer) = x + oneunit(x)    # any integer type\naddone(x::Number) = x + oneunit(x)     # any numeric type\naddone(x) = x + oneunit(x)             # any type supporting + and oneunit\n```\n\n----------------------------------------\n\nTITLE: Querying Documentation in Julia REPL - Julia\nDESCRIPTION: Shows example queries using Julia's REPL help mode syntax. Typing a question mark '?' followed by a function, macro, or string macro name allows users to access documentation for that object directly in the REPL or notebook environments such as IJulia, VS Code, Pluto, or Juno. No external dependencies are required. The snippet demonstrates three common query forms: function (cos), macro (@time), and string macro (r\"\").\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n?cos\n?@time\n?r\"\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Sum using Julia Generator Expression\nDESCRIPTION: Shows how to use a generator expression `(1/n^2 for n=1:1000)` as an argument to the `sum` function. This calculates the sum of the series 1/n² for n from 1 to 1000 efficiently without creating an intermediate array to store the values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_13\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> sum(1/n^2 for n=1:1000)\n1.6439345666815615\n```\n\n----------------------------------------\n\nTITLE: Implementing Producer-Consumer with Julia Channels\nDESCRIPTION: Defines a `producer` function that accepts a `Channel` and uses `put!` to send values (\"start\", 2, 4, 6, 8, \"stop\") into it. A `Channel` named `chnl` is created by passing the `producer` function to the `Channel` constructor; this automatically schedules the `producer` function to run in a new task bound to the channel. Subsequent `take!(chnl)` calls retrieve the values sequentially from the channel, demonstrating communication between the implicitly running producer task and the consumer (the main REPL task). The producer task suspends after each `put!` until the value is taken.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/asynchronous-programming.md#_snippet_3\n\nLANGUAGE: jldoctest producer\nCODE:\n```\njulia> function producer(c::Channel)\n           put!(c, \"start\")\n           for n=1:4\n               put!(c, 2n)\n           end\n           put!(c, \"stop\")\n       end;\n\njulia> chnl = Channel(producer);\n\njulia> take!(chnl)\n\"start\"\n\njulia> take!(chnl)\n2\n\njulia> take!(chnl)\n4\n\njulia> take!(chnl)\n6\n\njulia> take!(chnl)\n8\n\njulia> take!(chnl)\n\"stop\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic While Loop in Julia\nDESCRIPTION: Shows a simple `while` loop that initializes a variable `i` to 1 outside the loop. The loop continues executing its body as long as the condition `i <= 3` evaluates to `true`. Inside the loop, the current value of `i` is printed, and `i` is incremented using `global i += 1` because the loop introduces a new scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_17\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> i = 1;\n\njulia> while i <= 3\n           println(i)\n           global i += 1\n       end\n1\n2\n3\n```\n\n----------------------------------------\n\nTITLE: Printing a Sequence with a While Loop - Julia\nDESCRIPTION: Demonstrates a common error when using a global variable inside a local soft scope, resulting in an UndefVarError due to Julia's scoping rules. Shows how attempting to increment a global variable 'i' inside a while loop at the top level leads to an undefined variable error unless properly scoped with a let block or function. No dependencies are required, and the key variable 'i' is intended to count integers from 1 to 5 and print them. This pattern is limited by Julia’s global versus local variable rules, especially in non-function top-level script code.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n# Print the numbers 1 through 5\\ni = 0\\nwhile i < 5\\n    i += 1     # ERROR: UndefVarError: `i` not defined\\n    println(i)\\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Julia Module and Using It - Julia\nDESCRIPTION: This snippet demonstrates how to define a simple Julia module in a file (Tmp.jl) and load it in the Julia REPL environment. The module encapsulates user-defined functions, allowing for reloading and flexible experimentation by calling include repeatedly. Dependencies include the Julia language runtime and access to the REPL or command line. The primary function illustrated is say_hello, and it also highlights the module's role in isolating code state.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/workflow-tips.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nmodule Tmp\n\nsay_hello() = println(\"Hello!\")\n\n# Your other definitions here\n\nend # module\n\nusing .Tmp\n```\n\n----------------------------------------\n\nTITLE: Distributed Parallel Reduction Loop in Julia\nDESCRIPTION: Executes a distributed for loop over a large range, calling Int(rand(Bool)) in each iteration. The results are summed in parallel using the (+) reduction operator via @distributed. Requires the Distributed standard library and is intended for execution in a multi-process Julia session. The output is a single integer representing the sum across all processes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\nnheads = @distributed (+) for i = 1:200000000\n    Int(rand(Bool))\nend\n```\n\n----------------------------------------\n\nTITLE: Using Type{T} in Constructors for Type Sharpening in Julia\nDESCRIPTION: Defines `WrapType{T}` and contrasts its default constructor with a specialized one using `Type{T}`. The default `WrapType(Float64)` yields `WrapType{DataType}(Float64)`, capturing the type less precisely. The specialized constructor `WrapType(::Type{T}) where T = WrapType{Type{T}}(T)` allows `WrapType(Float64)` to create `WrapType{Type{Float64}}(Float64)`, sharpening the field type for potential performance benefits.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_59\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct WrapType{T}\n       value::T\n       end\n\njulia> WrapType(Float64) # default constructor, note DataType\nWrapType{DataType}(Float64)\n\njulia> WrapType(::Type{T}) where T = WrapType{Type{T}}(T)\nWrapType\n\njulia> WrapType(Float64) # sharpened constructor, note more precise Type{Float64}\nWrapType{Type{Float64}}(Float64)\n```\n\n----------------------------------------\n\nTITLE: Logical (Boolean Mask) Indexing in Julia Arrays\nDESCRIPTION: This snippet illustrates logical (mask-based) indexing. A 3D array is created and reshaped, and elements are selected using a boolean array or logical mask. It demonstrates creating boolean masks manually and with map(ispow2, x), and shows direct use of the mask for selection. Inputs are arrays and boolean masks; outputs are filtered vectors. Efficient as long as mask shapes match, and findall is not strictly required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = reshape(1:12, 2, 3, 2)\n2×3×2 reshape(::UnitRange{Int64}, 2, 3, 2) with eltype Int64:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\njulia> x[:, [true false; false true; true false]]\n2×3 Matrix{Int64}:\n 1  5   9\n 2  6  10\n\njulia> mask = map(ispow2, x)\n2×3×2 Array{Bool, 3}:\n[:, :, 1] =\n 1  0  0\n 1  1  0\n\n[:, :, 2] =\n 0  0  0\n 1  0  0\n\njulia> x[mask]\n4-element Vector{Int64}:\n 1\n 2\n 4\n 8\n\njulia> x[vec(mask)] == x[mask] # we can also index with a single Boolean vector\ntrue\n```\n\n----------------------------------------\n\nTITLE: Optimized Collection with `collect` on Custom Iterables in Julia\nDESCRIPTION: Demonstrates the benefit of defining `eltype` and `length`. The `collect` function can now preallocate a `Vector{Int}` of the correct size for the `Squares` object, avoiding inefficient resizing.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> collect(Squares(4))\n4-element Vector{Int64}:\n  1\n  4\n  9\n 16\n```\n\n----------------------------------------\n\nTITLE: Adding Trailing Dimensions with Terminating Semicolons in Julia\nDESCRIPTION: Shows how trailing semicolons in an array literal can be used to add trailing dimensions of size 1 to the resulting array. A single trailing `;;` creates a 2D Matrix, while `;;;` creates a 3D array.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_9\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [1;;]\n1×1 Matrix{Int64}:\n 1\n\njulia> [2; 3;;;]\n2×1×1 Array{Int64, 3}:\n[:, :, 1] =\n 2\n 3\n```\n\n----------------------------------------\n\nTITLE: Singular Value Decomposition Output in Julia\nDESCRIPTION: Julia's `svd` function returns singular values as a vector, unlike MATLAB which typically returns them as a dense diagonal matrix.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nsvd(A)\n```\n\n----------------------------------------\n\nTITLE: Defining the Regex String Literal Macro (`@r_str`) in Julia\nDESCRIPTION: This Julia macro `r_str` defines the behavior for the `r\"\"` non-standard string literal. It accepts the literal string content `p` as input and constructs a `Regex` object from it. This allows compile-time regex compilation for efficiency.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_55\n\nLANGUAGE: julia\nCODE:\n```\nmacro r_str(p)\n    Regex(p)\nend\n```\n\n----------------------------------------\n\nTITLE: Calling a Defined Julia Function\nDESCRIPTION: Shows how to call a previously defined Julia function `f` using the traditional parenthesis syntax with arguments. In this example, `f` is called with `2` and `3`, and it returns their sum, `5`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> f(2, 3)\n5\n```\n\n----------------------------------------\n\nTITLE: Defining Random Generation for a Custom Type (Die) in Julia\nDESCRIPTION: Defines a custom struct `Die` with a number of sides `nsides`. It then implements the `rand(rng::AbstractRNG, ::Random.SamplerType{Die})` method to specify how to generate a random instance of `Die`. Calling `rand(Die)` will now produce a `Die` object whose `nsides` field is a random integer between 4 and 20.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\nstruct Die\n    nsides::Int # number of sides\nend\n\nRandom.rand(rng::AbstractRNG, ::Random.SamplerType{Die}) = Die(rand(rng, 4:20))\n\n# output\n\n```\n\n----------------------------------------\n\nTITLE: Performing Vertical Array Concatenation in Julia\nDESCRIPTION: Illustrates vertical concatenation in Julia using semicolons (`;`) or newlines between arguments within square brackets. Contrasts this with comma-separated arguments, which create an array *of* the arguments rather than concatenating their contents. Shows how ranges and individual elements are concatenated vertically into a single Vector.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [1:2, 4:5] # Has a comma, so no concatenation occurs. The ranges are themselves the elements\n2-element Vector{UnitRange{Int64}}:\n 1:2\n 4:5\n\njulia> [1:2; 4:5]\n4-element Vector{Int64}:\n 1\n 2\n 4\n 5\n\njulia> [1:2\n        4:5\n        6]\n5-element Vector{Int64}:\n 1\n 2\n 4\n 5\n 6\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Generated Function in Julia\nDESCRIPTION: Defines a generated function `foo` using the `@generated` macro. Inside the function body, it prints the *type* of the input argument `x` using `Core.println` and returns a quoted expression `:(x * x)`. This expression will form the actual method body for the specific input types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_62\n\nLANGUAGE: julia\nCODE:\n```\njulia> @generated function foo(x)\n           Core.println(x)\n           return :(x * x)\n       end\nfoo (generic function with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Julia Help Mode for a Keyword\nDESCRIPTION: This documentation-like excerpt shows the use of Julia's help mode by typing ? begin at the REPL prompt. The output includes related search terms and a brief description, illustrating how users can learn about Julia keywords and blocks by querying their documentation from within the REPL. This is accessed interactively in the Julia REPL environment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/getting-started.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nhelp?> begin\\nsearch: begin disable_sigint reenable_sigint\\n\\n  begin\\n\\n  begin...end denotes a block of code.\n```\n\n----------------------------------------\n\nTITLE: Type Promotion with Complex and Other Numeric Types in Julia\nDESCRIPTION: Illustrates automatic promotion and conversion between complex, integer, fractional, and real types in Julia arithmetic operations. No additional dependencies are required beyond Julia's built-in numeric types. The code takes various numerical type combinations as inputs and produces results that demonstrate appropriate type conversions and promotions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> 2(1 - 1im)\n2 - 2im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (2 + 3im) - 1\n1 + 3im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (1 + 2im) + 0.5\n1.5 + 2.0im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (2 + 3im) - 0.5im\n2.0 + 2.5im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 0.75(1 + 2im)\n0.75 + 1.5im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (2 + 3im) / 2\n1.0 + 1.5im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> (1 - 3im) / (2 + 2im)\n-0.5 - 1.0im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 2im^2\n-2 + 0im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1 + 3/4im\n1.0 - 0.75im\n```\n\n----------------------------------------\n\nTITLE: Checking Substring/Character Presence with occursin in Julia\nDESCRIPTION: Shows how to use the `occursin(needle, haystack)` function to check if a substring (`needle` as a string) or a specific character (`needle` as a char literal) is present within another string (`haystack`), returning `true` or `false`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_40\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> occursin(\"world\", \"Hello, world.\")\ntrue\n\njulia> occursin(\"o\", \"Xylophon\")\ntrue\n\njulia> occursin(\"a\", \"Xylophon\")\nfalse\n\njulia> occursin('o', \"Xylophon\")\ntrue\n```\n\n----------------------------------------\n\nTITLE: Using Extended Indexing on a Custom Type in Julia\nDESCRIPTION: Demonstrates using the extended `getindex` methods defined for `Squares`. It shows indexing with a floating-point number (which gets converted) and with a vector of indices to retrieve multiple elements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_13\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Squares(10)[[3,4.,5]]\n3-element Vector{Int64}:\n  9\n 16\n 25\n```\n\n----------------------------------------\n\nTITLE: Assigning and Calling a Julia Function via Another Variable\nDESCRIPTION: Demonstrates that functions are first-class objects in Julia. The function object `f` is assigned to a new variable `g`. Subsequently, `g` can be called exactly like `f`, passing arguments `2` and `3` to produce the result `5`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_3\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> g = f;\n\njulia> g(2, 3)\n5\n```\n\n----------------------------------------\n\nTITLE: Defining UInt Type Alias Based on System Architecture in Julia\nDESCRIPTION: Creates a constant UInt as an alias for either UInt64 or UInt32, depending on the system's integer representation. Relies on the pre-defined Int type in Julia to determine the correct association. No external dependencies, and the resulting UInt reflects the platform's native pointer size, ensuring type correctness in portable code.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_61\n\nLANGUAGE: julia\nCODE:\n```\nif Int === Int64\\n    const UInt = UInt64\\nelse\\n    const UInt = UInt32\\nend\n```\n\n----------------------------------------\n\nTITLE: Inefficient Vector-Matrix Addition via Replication in Julia\nDESCRIPTION: Demonstrates adding a vector `a` to each column of a matrix `A` by first replicating `a` to match the dimensions of `A` using `repeat`. This approach is memory-inefficient compared to broadcasting, especially for large arrays.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_38\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> a = rand(2, 1); A = rand(2, 3);\n\njulia> repeat(a, 1, 3) + A\n2×3 Matrix{Float64}:\n 1.20813  1.82068  1.25387\n 1.56851  1.86401  1.67846\n```\n\n----------------------------------------\n\nTITLE: Annotating Vectorized Operations with @inbounds and @simd in Julia\nDESCRIPTION: Demonstrates the application of Julia macros (@noinline, @inbounds, @simd) to control vectorization and bounds-checking in numerical routines. The core functions calculate inner products in a vectorized way and compare their performance, with benchmarking performed using repeated randomized data. The timeit function tests and reports GFlop/sec rates with and without SIMD annotations, highlighting the usage and impact of these macros. Dependencies: Standard Julia language; requires an installation with random and timing support. Inputs: array lengths and repeat counts; outputs: performance measurements. Limitations: unsafe operations if bounds assumptions are violated; macros must be used with caution.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_58\n\nLANGUAGE: julia\nCODE:\n```\n@noinline function inner(x, y)\n    s = zero(eltype(x))\n    for i in eachindex(x, y)\n        @inbounds s += x[i]*y[i]\n    end\n    return s\nend\n\n@noinline function innersimd(x, y)\n    s = zero(eltype(x))\n    @simd for i in eachindex(x, y)\n        @inbounds s += x[i] * y[i]\n    end\n    return s\nend\n\nfunction timeit(n, reps)\n    x = rand(Float32, n)\n    y = rand(Float32, n)\n    s = zero(Float64)\n    time = @elapsed for j in 1:reps\n        s += inner(x, y)\n    end\n    println(\"GFlop/sec        = \", 2n*reps / time*1E-9)\n    time = @elapsed for j in 1:reps\n        s += innersimd(x, y)\n    end\n    println(\"GFlop/sec (SIMD) = \", 2n*reps / time*1E-9)\nend\n\ntimeit(1000, 1000)\n\n```\n\n----------------------------------------\n\nTITLE: Renaming an Entire Package During Import with `as` in Julia\nDESCRIPTION: Illustrates renaming an entire imported package using the `as` keyword. `import BenchmarkTools as BT` makes the `BenchmarkTools` module accessible via the shorter alias `BT`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nimport BenchmarkTools as BT\n```\n\n----------------------------------------\n\nTITLE: Loading Only the Module Name with `import` in Julia\nDESCRIPTION: Illustrates the use of the `import` keyword to load a locally defined module `NiceStuff` in a `jldoctest` context. Unlike `using`, `import .NiceStuff` only brings the module name `NiceStuff` into the current scope. Accessing any members (exported or not) requires using qualified names like `NiceStuff.DOG` or `NiceStuff.nice`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_6\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> import .NiceStuff\n```\n\n----------------------------------------\n\nTITLE: Defining Nested UnionAll Types in Julia\nDESCRIPTION: Demonstrates the creation of two constant types, `T1` and `T2`, using nested `where` clauses with `Array`. `T1` represents a concrete type of 1D arrays containing 1D arrays where inner element types can vary based on the inner `where T`. `T2` represents an abstract `UnionAll` type of 1D arrays where all inner arrays must have the same element type `T`, specified by the outer `where T`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_47\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> const T1 = Array{Array{T, 1} where T, 1}\nVector{Vector} (alias for Array{Array{T, 1} where T, 1})\n\njulia> const T2 = Array{Array{T, 1}, 1} where T\nArray{Vector{T}, 1} where T\n```\n\n----------------------------------------\n\nTITLE: Implementing Operations on Julia Container Struct via Element Dispatch\nDESCRIPTION: Demonstrates a common pattern for working with concretely typed containers like `MySimpleContainer`. An outer function `sumfoo` iterates through the container `c.a`. Inside the loop, it calls another function `foo(x)` which uses multiple dispatch to handle different element types (`Integer`, `AbstractFloat`) appropriately. This allows optimized code generation for each element type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_20\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function sumfoo(c::MySimpleContainer)\n           s = 0\n           for x in c.a\n               s += foo(x)\n           end\n           s\n       end\nsumfoo (generic function with 1 method)\n\njulia> foo(x::Integer) = x\nfoo (generic function with 1 method)\n\njulia> foo(x::AbstractFloat) = round(x)\nfoo (generic function with 2 methods)\n```\n\n----------------------------------------\n\nTITLE: Extracting Substrings with Range Indexing in Julia\nDESCRIPTION: Shows substring extraction in Julia using range indexing, emphasizing that both start and end indices must be valid byte indices. `s[1:1]` extracts \"∀\", `s[1:2]` throws a `StringIndexError` as index 2 is invalid, and `s[1:4]` correctly extracts \"∀ \".\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_17\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> s[1:1]\n\"∀\"\n\njulia> s[1:2]\nERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'∀', [4]=>' '\nStacktrace:\n[...]\n\njulia> s[1:4]\n\"∀ \"\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Collections (Arrays) with For Loops in Julia\nDESCRIPTION: Shows `for` loops iterating over different collection types: an array of integers `[1,4,0]` and an array of strings `[\"foo\",\"bar\",\"baz\"]`. It demonstrates using the `in` keyword (for the integer array) and its Unicode alias `∈` (for the string array) as alternatives to `=` when specifying the collection to iterate over.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_19\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for i in [1,4,0]\n           println(i)\n       end\n1\n4\n0\n\njulia> for s ∈ [\"foo\",\"bar\",\"baz\"]\n           println(s)\n       end\nfoo\nbar\nbaz\n```\n\n----------------------------------------\n\nTITLE: Generating Methods Dynamically using the @eval Macro in Julia\nDESCRIPTION: Illustrates the idiomatic Julia approach for dynamic code generation using the `@eval` macro. The `@eval` macro simplifies the common `eval(quote(...))` or `eval(:(...))` pattern. In the loop, `@eval Base.$op(a::MyNumber) = MyNumber($op(a.x))` directly evaluates the provided expression in the current scope, defining the methods for `MyNumber` more compactly.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_53\n\nLANGUAGE: julia\nCODE:\n```\nfor op = (:sin, :cos, :tan, :log, :exp)\n    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))\nend\n```\n\n----------------------------------------\n\nTITLE: Field Tab Completion and Type Inference - Julia-REPL\nDESCRIPTION: These snippets show tab completion on field names of objects, including complex numbers, module contents, and outputs from functions. Type inference is used to suggest context-relevant completions only when types are stable, assisting users in discovering available fields and methods. All functionality built-in; usage is within the Julia REPL.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_21\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> x = 3 + 4im;\n\njulia> x.[TAB][TAB]\nim re\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> import UUIDs\n\njulia> UUIDs.uuid[TAB][TAB]\nuuid1        uuid4         uuid5        uuid_version\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> split(\"\",\" \")[1].[TAB]\nlastindex  offset  string\n```\n\n----------------------------------------\n\nTITLE: Replacing Array Elements Based on Condition in Julia\nDESCRIPTION: Julia uses a combination of element-wise comparison (`.<`) and broadcasting assignment (`.=`) to replace elements that meet a specific condition.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\nA[A .< threshold] .= 0\n```\n\n----------------------------------------\n\nTITLE: Inspecting Function Methods in the REPL (Julia)\nDESCRIPTION: This snippet demonstrates how to inspect a function in Julia within the REPL to see how many methods have been defined. Typing the function's name returns information about its generic methods, useful for understanding a function's specialization and extensibility. No dependencies are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> f\nf (generic function with 2 methods)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Multiple Dispatch for Macros in Julia\nDESCRIPTION: Illustrates that Julia macros, like functions, are generic and support multiple dispatch. Several methods are defined for the `@m` macro: one with no arguments (implicitly), one accepting variable arguments (`args...`), and one specifically for two arguments (`x,y`). Calls like `@m \"asd\"` and `@m 1 2` dispatch to the appropriate method based on the number of arguments provided.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_47\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> macro m end\n@m (macro with 0 methods)\n\njulia> macro m(args...)\n           println(\"$(length(args)) arguments\")\n       end\n@m (macro with 1 method)\n\njulia> macro m(x,y)\n           println(\"Two arguments\")\n       end\n@m (macro with 2 methods)\n\njulia> @m \"asd\"\n1 arguments\n\njulia> @m 1 2\nTwo arguments\n```\n\n----------------------------------------\n\nTITLE: Documenting Array Manipulation and Mapping Utilities - Julia\nDESCRIPTION: This snippet includes cumulant and difference operations, array repetition and rotation, and extended mapping functions (e.g., `mapslices`). It leverages the `@docs` macro for aggregating documentation and presumes users are familiar with Julia arrays. Essential for guiding users in common array data manipulations; dependencies are handled by Julia Base.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/arrays.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.accumulate\nBase.accumulate!\nBase.cumprod\nBase.cumprod!\nBase.cumsum\nBase.cumsum!\nBase.diff\nBase.repeat\nBase.rot180\nBase.rotl90\nBase.rotr90\nBase.mapslices\nBase.eachrow\nBase.eachcol\nBase.eachslice\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Caching in Julia Generated Functions\nDESCRIPTION: Illustrates the caching behavior of generated functions. Calling `foo(4)` after `foo(2)` (both `Int64`) does not trigger the `Core.println` statement again, indicating that the generated code for `Int64` was cached and reused. The result `16` is returned directly.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_64\n\nLANGUAGE: julia\nCODE:\n```\njulia> foo(4)\n16\n```\n\n----------------------------------------\n\nTITLE: Optimizing Closure Performance Using Let Blocks in Julia\nDESCRIPTION: This snippet shows a closure pattern (abmult3) that fully avoids boxing captured variables by using a let block, resulting in maximum performance in Julia. The let block creates a new scope for the captured variable r, which is then closed over without further mutation. Only Julia base is needed. Main parameter is r (Int); output is a closure function that multiplies its argument by the absolute value of r. This approach is most performant and preferred when the captured variable will not be modified after closure creation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\nfunction abmult3(r::Int)\n    if r < 0\n        r = -r\n    end\n    f = let r = r\n            x -> x * r\n    end\n    return f\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple TCP Server with Sockets in Julia\nDESCRIPTION: This snippet creates a basic TCP server that listens on port 2000 using the Sockets standard library in Julia. The server uses multithreading (@spawn in conjunction with errormonitor) to handle incoming connections and prints 'Hello World' whenever a client connects. Requires Julia with Sockets and Threads enabled. Input: TCP connections to port 2000. Output: Prints to STDOUT for every new client connection. Server process is persistent and will run indefinitely.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_10\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Sockets\n\njulia> errormonitor(Threads.@spawn begin\n           server = listen(2000)\n           while true\n               sock = accept(server)\n               println(\"Hello World\\n\")\n           end\n       end)\nTask (runnable) @0x00007fd31dc11ae0\n```\n\n----------------------------------------\n\nTITLE: Binary and Text Output with write and print - Julia\nDESCRIPTION: Contrasts the use of `write` and `print` for output in Julia. When using `write(stdout, 0x61);`, the raw byte is written (as 'a'), while `print(stdout, 0x61)` outputs the integer representation (97). These examples clarify the difference between binary and textual output. The code uses Julia's REPL and doctest environments. Inputs are the data to output; outputs are either a byte or its textual representation. No third-party dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> write(stdout, 0x61);  # suppress return value 1 with ;\\na\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> print(stdout, 0x61)\\n97\n```\n\n----------------------------------------\n\nTITLE: Defining the Paths Map for a Julia Package Directory\nDESCRIPTION: Julia code defining a `Dict` named `paths` that maps package identifiers (represented as tuples of UUID and package name Symbol) to the absolute path of their corresponding entry-point source file (`src/PackageName.jl`). This example assumes the package directory is located at '/home/me/AnimalPackages/'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\npaths = Dict(\\n    (UUID(\\\"00000000-0000-0000-0000-000000000000\\\"), :Aardvark) =>\\n        \\\"/home/me/AnimalPackages/Aardvark/src/Aardvark.jl\\\",\\n    (UUID(\\\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\\\"), :Bobcat) =>\\n        \\\"/home/me/AnimalPackages/Bobcat/src/Bobcat.jl\\\",\\n    (UUID(\\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\"), :Cobra) =>\\n        \\\"/home/me/AnimalPackages/Cobra/src/Cobra.jl\\\",\\n    (UUID(\\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"), :Dingo) =>\\n        \\\"/home/me/AnimalPackages/Dingo/src/Dingo.jl\\\",\\n)\n```\n\n----------------------------------------\n\nTITLE: Assigning Global Variables in Julia REPL (Explicit)\nDESCRIPTION: Explicitly demonstrates creating a global variable `x` in the Julia REPL using the `global` keyword. This reinforces the concept that top-level assignments in the REPL result in global variables.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_4\n\nLANGUAGE: julia-repl\nCODE:\n```\n```julia-repl\njulia> global x = 1.0\n```\n```\n\n----------------------------------------\n\nTITLE: Generating a Package and Modifying LOAD_PATH - Julia REPL\nDESCRIPTION: This mixed-mode snippet (Pkg REPL and Julia REPL) demonstrates how to generate a new Julia package with the pkg> generate command, then updates the Julia LOAD_PATH variable to include the project's current directory. The required dependency is Julia with its built-in Pkg REPL. These commands are typically used for temporary or experimental package development, and users must repeat the LOAD_PATH adjustment after restarting Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/workflow-tips.md#_snippet_3\n\nLANGUAGE: julia-repl\nCODE:\n```\npkg> generate MyPkg            # type ] to enter pkg mode\njulia> push!(LOAD_PATH, pwd())   # hit backspace to exit pkg mode\n```\n\n----------------------------------------\n\nTITLE: Working with Hexadecimal Floating-Point Literals (Julia)\nDESCRIPTION: Demonstrates Julia's support for hexadecimal floating-point literals (Float64 only), using a 'p' to denote the binary exponent. Shows parsing, assignment, and type introspection. Useful for precise binary floating-point manipulation and debugging. No additional dependencies required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\njulia> 0x1p0\n1.0\n\njulia> 0x1.8p3\n12.0\n\njulia> x = 0x.4p-1\n0.125\n\njulia> typeof(x)\nFloat64\n```\n\n----------------------------------------\n\nTITLE: Quoting Code to Create Expr Objects in Julia\nDESCRIPTION: Covers quoting a code statement to create an Expr, including both short (parentheses) and block (quote...end) forms. This is a principal mechanism for capturing code structure in macros and code manipulation. Inputs: statement(s) in quote; output: Expr; may include runtime line annotations in code blocks.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> ex = :(a+b*c+1)\n:(a + b * c + 1)\n\njulia> typeof(ex)\nExpr\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia>      :(a + b*c + 1)       ==\n       Meta.parse(\"a + b*c + 1\") ==\n       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)\ntrue\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> ex = quote\n           x = 1\n           y = 2\n           x + y\n       end\nquote\n    #= none:2 =#\n    x = 1\n    #= none:3 =#\n    y = 2\n    #= none:4 =#\n    x + y\nend\n\njulia> typeof(ex)\nExpr\n```\n\n----------------------------------------\n\nTITLE: Documenting Core String Types and Functions in Julia\nDESCRIPTION: This code snippet aggregates references to the Julia Core and Base string types, such as AbstractString, Char, SubString, and their associated methods, including but not limited to string length, repetition, matching, splitting, padding, encoding conversions, and pattern matching with regular expressions. The `@docs` macro is utilized to generate documentation for each listed symbol within Julia's documentation framework. No explicit dependencies are required except the Julia standard library. Inputs and outputs depend on the individual function or type; each is identified by its signature, with key parameters typically being strings or characters. Limitations and detailed constraints vary per method, and this block is meant for readers to discover string APIs programmatically or via documentation tools.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/strings.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCore.AbstractString\nCore.AbstractChar\nCore.Char\nBase.codepoint\nBase.length(::AbstractString)\nBase.sizeof(::AbstractString)\nBase.:*(::Union{AbstractChar, AbstractString}, ::Union{AbstractChar, AbstractString}...)\nBase.:^(::Union{AbstractString, AbstractChar}, ::Integer)\nBase.string\nBase.repeat(::AbstractString, ::Integer)\nBase.repeat(::AbstractChar, ::Integer)\nBase.repr(::Any)\nCore.String(::AbstractString)\nBase.SubString\nBase.LazyString\nBase.@lazy_str\nBase.transcode\nBase.unsafe_string\nBase.ncodeunits(::AbstractString)\nBase.codeunit\nBase.codeunits\nBase.ascii\nBase.Regex\nBase.@r_str\nBase.SubstitutionString\nBase.@s_str\nBase.@raw_str\nBase.@b_str\nBase.Docs.@html_str\nBase.Docs.@text_str\nBase.isvalid(::Any)\nBase.isvalid(::Any, ::Any)\nBase.isvalid(::AbstractString, ::Integer)\nBase.match\nBase.eachmatch\nBase.RegexMatch\nBase.keys(::RegexMatch)\nBase.isless(::AbstractString, ::AbstractString)\nBase.:(==)(::AbstractString, ::AbstractString)\nBase.cmp(::AbstractString, ::AbstractString)\nBase.lpad\nBase.rpad\nBase.ltruncate\nBase.rtruncate\nBase.ctruncate\nBase.findfirst(::AbstractString, ::AbstractString)\nBase.findnext(::AbstractString, ::AbstractString, ::Integer)\nBase.findnext(::AbstractChar, ::AbstractString, ::Integer)\nBase.findlast(::AbstractString, ::AbstractString)\nBase.findlast(::AbstractChar, ::AbstractString)\nBase.findprev(::AbstractString, ::AbstractString, ::Integer)\nBase.occursin\nBase.reverse(::Union{String,SubString{String}})\nBase.replace(::IO, s::AbstractString, ::Pair...)\nBase.eachsplit\nBase.eachrsplit\nBase.split\nBase.rsplit\nBase.strip\nBase.lstrip\nBase.rstrip\nBase.startswith\nBase.endswith\nBase.contains\nBase.first(::AbstractString, ::Integer)\nBase.last(::AbstractString, ::Integer)\nBase.uppercase\nBase.lowercase\nBase.titlecase\nBase.uppercasefirst\nBase.lowercasefirst\nBase.join\nBase.chop\nBase.chopprefix\nBase.chopsuffix\nBase.chomp\nBase.thisind\nBase.nextind(::AbstractString, ::Integer, ::Integer)\nBase.prevind(::AbstractString, ::Integer, ::Integer)\nBase.textwidth\nBase.isascii\nBase.iscntrl\nBase.isdigit\nBase.isletter\nBase.islowercase\nBase.isnumeric\nBase.isprint\nBase.ispunct\nBase.isspace\nBase.isuppercase\nBase.isxdigit\nBase.escape_string\nBase.escape_raw_string\nBase.unescape_string\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct with Incomplete Initialization in Julia\nDESCRIPTION: Defines a `mutable struct` `Incomplete` with a single field `data`. Its inner constructor `Incomplete() = new()` uses the `new()` function without arguments to return an instance where the `data` field is left uninitialized. This demonstrates the possibility of returning incompletely initialized objects from constructors.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_11\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> mutable struct Incomplete\n           data\n           Incomplete() = new()\n       end\n```\n\n----------------------------------------\n\nTITLE: Dynamically Generating and Evaluating Expressions in Julia\nDESCRIPTION: Shows how to programmatically construct an `Expr` object using the `Expr` constructor. It highlights the difference between embedding a variable's *value* (`a`) at construction time versus embedding a *symbol* (`:b`) whose value is resolved at evaluation time.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_16\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> a = 1;\n\njulia> ex = Expr(:call, :+, a, :b)\n:(1 + b)\n\njulia> a = 0; b = 2;\n\njulia> eval(ex)\n3\n```\n\n----------------------------------------\n\nTITLE: Initializing and Rooting Pointers Before Assigning Julia Values in C\nDESCRIPTION: Shows that `jl_value_t*` variables can be initialized to `NULL`, pushed onto the GC stack using `JL_GC_PUSH*`, and then assigned actual Julia values later. This pattern ensures the pointers are rooted before any Julia allocation that might trigger GC occurs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_17\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *ret1 = NULL, *ret2 = NULL;\nJL_GC_PUSH2(&ret1, &ret2);\nret1 = jl_eval_string(\"sqrt(2.0)\");\nret2 = jl_eval_string(\"sqrt(3.0)\");\n// Use ret1 and ret2\nJL_GC_POP();\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Integer Indexing (`getindex`) in Julia\nDESCRIPTION: Defines the `getindex` method for the `Squares` type to allow accessing elements using integer indices (e.g., `S[i]`). Includes bounds checking to ensure the index is valid.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_8\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function Base.getindex(S::Squares, i::Int)\n           1 <= i <= S.count || throw(BoundsError(S, i))\n           return i*i\n       end\n```\n\n----------------------------------------\n\nTITLE: Using Arithmetic with end Index and Indexing in Julia\nDESCRIPTION: Shows advanced string indexing using arithmetic and integer division on the `end` keyword for positions such as the penultimate character and halfway point. This demonstrates index calculations for extracting specific characters.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\njulia> str[end-1]\n'.': ASCII/Unicode U+002E (category Po: Punctuation, other)\n\njulia> str[end\\u00F72]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n```\n\n----------------------------------------\n\nTITLE: Developing and Reloading Julia Code in a Redefinable Module (Julia)\nDESCRIPTION: Demonstrates a workflow for iterative development in Julia by wrapping user code within a module instead of defining types in Main, thereby allowing types and constants to be redefined during a REPL session. Shows the pattern for including module code, constructing objects, invoking functions, and reloading code to apply changes. Requires file structure with the module code in 'mynewcode.jl' and assumes that 'ObjConstructor' and 'somefunction'/'someotherfunction' are defined appropriately within the module. Inputs are not user-driven, but based on changes to the module file; after reload, old objects must be reconstructed due to type changes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\ninclude(\"mynewcode.jl\")              # this defines a module MyModule\nobj1 = MyModule.ObjConstructor(a, b)\nobj2 = MyModule.somefunction(obj1)\n# Got an error. Change something in \"mynewcode.jl\"\ninclude(\"mynewcode.jl\")              # reload the module\nobj1 = MyModule.ObjConstructor(a, b) # old objects are no longer valid, must reconstruct\nobj2 = MyModule.somefunction(obj1)   # this time it worked!\nobj3 = MyModule.someotherfunction(obj2, c)\n...\n```\n\n----------------------------------------\n\nTITLE: Wrapping an Existing C Array as a Julia Array\nDESCRIPTION: This C code shows how to create a Julia array (`jl_array_t*`) that acts as a thin wrapper around an existing, pre-allocated C array (`existingArray`). It uses `jl_ptr_to_array_1d`, providing the array type, the pointer to the C data, the length, and a boolean flag (0 here) indicating that Julia should not take ownership of the memory (i.e., not free it when the Julia array is garbage collected). Assumes `array_type` was previously obtained via `jl_apply_array_type`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_25\n\nLANGUAGE: c\nCODE:\n```\ndouble *existingArray = (double*)malloc(sizeof(double)*10);\njl_array_t *x = jl_ptr_to_array_1d(array_type, existingArray, 10, 0);\n```\n\n----------------------------------------\n\nTITLE: Tracing Errors Through Nested Calls with catch_backtrace in Julia\nDESCRIPTION: Illustrates tracing an error through a deeper call stack (`grandparent` -> `parent` -> `child`). The `child` function explicitly throws an error. The `catch` block in `grandparent` uses `stacktrace(catch_backtrace())` to capture the stack trace associated with the error, correctly showing the sequence of calls leading to the `error` function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_6\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @noinline child() = error(\"Whoops!\")\nchild (generic function with 1 method)\n\njulia> @noinline parent() = child()\nparent (generic function with 1 method)\n\njulia> @noinline function grandparent()\n           try\n               parent()\n           catch err\n               println(\"ERROR: \", err.msg)\n               stacktrace(catch_backtrace())\n           end\n       end\ngrandparent (generic function with 1 method)\n\njulia> grandparent()\nERROR: Whoops!\n10-element Array{Base.StackTraces.StackFrame,1}:\n error at error.jl:33 [inlined]\n child() at REPL[1]:1\n parent() at REPL[2]:1\n grandparent() at REPL[3]:3\n[...]\n```\n\n----------------------------------------\n\nTITLE: Enforcing Type Parameter Constraints with an Inner Constructor in Julia\nDESCRIPTION: This code defines a `ConstrainedType` struct in Julia, correctly enforcing a relationship between its type parameters `N` and `M`. It uses an inner constructor method that takes two `Array` arguments. Inside the constructor, it checks if the dimension `M` of the second array `B` is exactly one greater than the dimension `N` of the first array `A`. If the condition `N + 1 == M` is not met, it throws an `ArgumentError`; otherwise, it creates the struct instance using `new{T,N,M}(A, B)`. This pattern allows for validation and enforcement of complex relationships between type parameters during object instantiation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nstruct ConstrainedType{T,N,M}\n    A::Array{T,N}\n    B::Array{T,M}\n    function ConstrainedType(A::Array{T,N}, B::Array{T,M}) where {T,N,M}\n        N + 1 == M || throw(ArgumentError(\"second argument should have one more axis\" ))\n        new{T,N,M}(A, B)\n    end\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Range Objects in Julia\nDESCRIPTION: Julia's colon syntax (`a:b` or `a:b:c`) creates efficient `AbstractRange` objects, which represent sequences without storing all elements explicitly. To get a full `Vector`, use `collect()`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\na:b # Creates an AbstractRange object\n```\n\nLANGUAGE: julia\nCODE:\n```\na:b:c # Creates an AbstractRange object with step c\n```\n\nLANGUAGE: julia\nCODE:\n```\ncollect(a:b) # Converts the range to a Vector\n```\n\n----------------------------------------\n\nTITLE: Defining a General Outer Constructor with Promotion in Julia\nDESCRIPTION: Defines a highly flexible outer constructor `Point(x::Real, y::Real) = Point(promote(x,y)...)` for the `Point` struct. It accepts any two `Real` arguments. The `promote(x,y)` function converts both arguments to a common, promoted type (e.g., `Int` and `Float64` become `Float64`). The `...` (splatting) operator passes the elements of the tuple returned by `promote` as individual arguments to the appropriate inner `Point{T}` constructor.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_20\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Point(x::Real, y::Real) = Point(promote(x,y)...);\n```\n\n----------------------------------------\n\nTITLE: Defining a Closure that Captures a Variable in Julia\nDESCRIPTION: This snippet defines a higher-order Julia function abmult that returns a closure, f, capturing and multiplying by the absolute value of its parameter r (of type Int). It demonstrates how closure capturing works internally in Julia, affecting performance due to boxing of shared variables. Only the Julia language is required, no external packages. The main parameter is r (Int); input/output is the returned closure (f), which multiplies its argument by |r|. Performance may be suboptimal if the captured variable is not type stable or unnecessarily boxed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\nfunction abmult(r::Int)\n    if r < 0\n        r = -r\n    end\n    f = x -> x * r\n    return f\nend\n```\n\n----------------------------------------\n\nTITLE: Defining the Roots Map for a Julia Package Directory\nDESCRIPTION: Julia code defining a `Dict` named `roots` that maps package names (Symbols) to their corresponding UUIDs for the example package directory. It demonstrates UUID assignment rules: nil UUID for packages without Project.toml (Aardvark), a dummy UUID hashed from the path for packages with Project.toml but no explicit UUID (Bobcat), and the actual UUID specified in Project.toml (Cobra, Dingo).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nroots = Dict(\\n    :Aardvark => UUID(\\\"00000000-0000-0000-0000-000000000000\\\"), # no project file, nil UUID\\n    :Bobcat   => UUID(\\\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\\\"), # dummy UUID based on path\\n    :Cobra    => UUID(\\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\"), # UUID from project file\\n    :Dingo    => UUID(\\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"), # UUID from project file\\n)\n```\n\n----------------------------------------\n\nTITLE: Context-sensitive Pretty-printing with IOContext in Julia\nDESCRIPTION: Redefines Base.show for the Polar type to return a compact or full output depending on the presence of the :compact property in the IOContext. When :compact is true, the method emits a shorter rℯΘim form; otherwise, it defaults to full r * exp(Θim) display. Enables adaptive formatting based on the environment (e.g., array display).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_74\n\nLANGUAGE: julia\nCODE:\n```\nfunction Base.show(io::IO, z::Polar)\\n    if get(io, :compact, false)::Bool\\n        print(io, z.r, \"\\u212F\", z.Θ, \"im\")\\n    else\\n        print(io, z.r, \" * exp(\", z.Θ, \"im)\")\\n    end\\nend\n```\n\n----------------------------------------\n\nTITLE: Iterating and Reducing with skipmissing Iterator in Julia\nDESCRIPTION: Exemplifies how the iterator returned by `skipmissing` can be used with various reduction and mapping functions, such as `maximum`, `sum`, and `mapreduce`. The snippet creates a `skipmissing` iterator for an array, then applies these functions. Inputs must be arrays containing `missing` values. Outputs are results over non-missing elements only. All functions shown accept the iterator directly.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = skipmissing([3, missing, 2, 1])\nskipmissing(Union{Missing, Int64}[3, missing, 2, 1])\n\njulia> maximum(x)\n3\n\njulia> sum(x)\n6\n\njulia> mapreduce(sqrt, +, x)\n4.146264369941973\n```\n\n----------------------------------------\n\nTITLE: Command Interpolation with Variables and Containers - Julia\nDESCRIPTION: Shows how Julia's command construction supports interpolation of variables, arrays, and multiple arrays. Interpolation ensures arguments with spaces or shell-special characters are correctly handled, including generating argument Cartesian products. Use cases range from passing dynamic file lists to emulating shell brace expansion without manual escaping or string construction. No external dependencies except for referenced command-line tools.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> file = \"/etc/passwd\"\n\"/etc/passwd\"\n\njulia> `sort $file`\n`sort /etc/passwd`\n```\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> file = \"/Volumes/External HD/data.csv\"\n\"/Volumes/External HD/data.csv\"\n\njulia> `sort $file`\n`sort '/Volumes/External HD/data.csv'`\n```\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> path = \"/Volumes/External HD\"\n\"/Volumes/External HD\"\n\njulia> name = \"data\"\n\"data\"\n\njulia> ext = \"csv\"\n\"csv\"\n\njulia> `sort $path/$name.$ext`\n`sort '/Volumes/External HD/data.csv'`\n```\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> files = [\"/etc/passwd\",\"/Volumes/External HD/data.csv\"]\n2-element Vector{String}:\n \"/etc/passwd\"\n \"/Volumes/External HD/data.csv\"\n\njulia> `grep foo $files`\n`grep foo /etc/passwd '/Volumes/External HD/data.csv'`\n```\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> names = [\"foo\",\"bar\",\"baz\"]\n3-element Vector{String}:\n \"foo\"\n \"bar\"\n \"baz\"\n\njulia> `grep xylophone $names.txt`\n`grep xylophone foo.txt bar.txt baz.txt`\n```\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> names = [\"foo\",\"bar\",\"baz\"]\n3-element Vector{String}:\n \"foo\"\n \"bar\"\n \"baz\"\n\njulia> exts = [\"aux\",\"log\"]\n2-element Vector{String}:\n \"aux\"\n \"log\"\n\njulia> `rm -f $names.$exts`\n`rm -f foo.aux foo.log bar.aux bar.log baz.aux baz.log`\n```\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> `rm -rf $[\"foo\",\"bar\",\"baz\",\"qux\"].$[\"aux\",\"log\",\"pdf\"]`\n`rm -rf foo.aux foo.log foo.pdf bar.aux bar.log bar.pdf baz.aux baz.log baz.pdf qux.aux qux.log qux.pdf`\n```\n```\n\n----------------------------------------\n\nTITLE: Defining an Advanced `@assert` Macro with Optional Message in Julia\nDESCRIPTION: Defines an improved `@assert` macro that accepts an optional second argument for a custom error message using varargs (`msgs...`). If a message is provided (`!isempty(msgs)`), it's used in the `AssertionError`; otherwise, the string representation of the expression `ex` is used as the message.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\njulia> macro assert(ex, msgs...)\n           msg_body = isempty(msgs) ? ex : msgs[1]\n           msg = string(msg_body)\n           return :($ex ? nothing : throw(AssertionError($msg)))\n       end\n@assert (macro with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Constructing Complex Numbers from Variables in Julia\nDESCRIPTION: Shows two equivalent approaches to constructing a complex value from numeric variables: using explicit multiplication with 'im', or via the more efficient complex(a, b) function. Both approaches are available in Julia Base. Inputs are separate real and imaginary components, outputs are the constructed complex values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> a = 1; b = 2; a + b*im\n1 + 2im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> a = 1; b = 2; complex(a, b)\n1 + 2im\n```\n\n----------------------------------------\n\nTITLE: Searching and Finding Indices with skipmissing in Julia\nDESCRIPTION: Shows how search-related functions like `findall`, `findfirst`, and `argmax` operate correctly with iterators from `skipmissing`, returning indices referencing both the filtered object and the original array. This makes it possible to locate entries, such as matching a value or finding a maximum, without encountering issues caused by missing values. Inputs: a skipmissing iterator; Outputs: indices. All functions used are in Julia Base.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\njulia> findall(==(1), x)\n1-element Vector{Int64}:\n 4\n\njulia> findfirst(!iszero, x)\n1\n\njulia> argmax(x)\n1\n```\n\n----------------------------------------\n\nTITLE: Creating Arrays Containing `missing` Values in Julia\nDESCRIPTION: Demonstrates the standard syntax for creating arrays (like `Vector`) that can hold both non-missing values (e.g., `Int64`) and `missing` values. The resulting array's element type becomes a `Union` type, specifically `Union{Missing, T}`, where `T` is the type of the non-missing elements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_11\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [1, missing]\n2-element Vector{Union{Missing, Int64}}:\n 1\n  missing\n```\n\n----------------------------------------\n\nTITLE: Converting Integers to Characters in Julia\nDESCRIPTION: Illustrates converting an integer code point into a `Char` value. This simple use of the `Char` constructor does not validate if the input is a valid Unicode point. Input is an integer; output is the represented character.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> Char(120)\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n```\n\n----------------------------------------\n\nTITLE: Decoupling Expression Building for sub2ind Generated Function (Julia)\nDESCRIPTION: Demonstrates extracting the code-generating logic into a helper function (sub2ind_gen_impl), which returns an Expr for the index calculation. Also defines a @generated sub2ind_gen function that delegates to this implementation. Inputs: dims::Type{T}, I...; Outputs: Expr for index calculation or error; Limitations: partial indexing not supported without full indices. Dependencies: None beyond Julia base.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_75\n\nLANGUAGE: julia\nCODE:\n```\nfunction sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N\n    length(I) == N || return :(error(\"partial indexing is unsupported\"))\n    ex = :(I[$N] - 1)\n    for i = (N - 1):-1:1\n        ex = :(I[$i] - 1 + dims[$i] * $ex)\n    end\n    return :($ex + 1)\nend;\n\n@generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n    return sub2ind_gen_impl(dims, I...)\nend;\n\nsub2ind_gen((3, 5), 1, 2)\n4\n```\n\n----------------------------------------\n\nTITLE: Defining and Instantiating Julia Structs with Container Fields\nDESCRIPTION: Defines three structs with container fields demonstrating varying levels of type specificity: `MySimpleContainer` (fully parameterized, preferred), `MyAmbiguousContainer` (abstract container type), and `MyAlsoAmbiguousContainer` (unparameterized `Array`). Instantiating them shows that `MySimpleContainer` yields the most specific type information (e.g., `MySimpleContainer{UnitRange{Int64}}`), allowing for better compiler optimization.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_19\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct MySimpleContainer{A<:AbstractVector}\n           a::A\n       end\n\njulia> struct MyAmbiguousContainer{T}\n           a::AbstractVector{T}\n       end\n\njulia> struct MyAlsoAmbiguousContainer\n           a::Array\n       end\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> c = MySimpleContainer(1:3);\n\njulia> typeof(c)\nMySimpleContainer{UnitRange{Int64}}\n\njulia> c = MySimpleContainer([1:3;]);\n\njulia> typeof(c)\nMySimpleContainer{Vector{Int64}}\n\njulia> b = MyAmbiguousContainer(1:3);\n\njulia> typeof(b)\nMyAmbiguousContainer{Int64}\n\njulia> b = MyAmbiguousContainer([1:3;]);\n\njulia> typeof(b)\nMyAmbiguousContainer{Int64}\n\njulia> d = MyAlsoAmbiguousContainer(1:3);\n\njulia> typeof(d), typeof(d.a)\n(MyAlsoAmbiguousContainer, Vector{Int64})\n\njulia> d = MyAlsoAmbiguousContainer(1:1.0:3);\n\njulia> typeof(d), typeof(d.a)\n(MyAlsoAmbiguousContainer, Vector{Float64})\n```\n\n----------------------------------------\n\nTITLE: Sorting Arrays in Julia with C qsort via @ccall and C-Compatible Function Pointers\nDESCRIPTION: This example shows how to sort a Julia array using the C qsort function called via @ccall, passing a Julia comparison function as a C function pointer. It demonstrates conversion of the Julia array to a pointer, calculation of type sizes, and correct assembly of arguments. The technique requires knowledge of C and Julia type layouts and careful memory management for safe operations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> A = [1.3, -2.7, 4.4, 3.1];\n\njulia> @ccall qsort(A::Ptr{Cdouble}, length(A)::Csize_t, sizeof(eltype(A))::Csize_t, mycompare_c::Ptr{Cvoid})::Cvoid\n\njulia> A\n4-element Vector{Float64}:\n -2.7\n  1.3\n  3.1\n  4.4\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Union Types in Julia\nDESCRIPTION: Demonstrates defining a type alias `IntOrString` as a Union of `Int` and `AbstractString`. It shows successful type assertions (`::`) for instances of `Int` and `AbstractString`, and a `TypeError` when attempting to assert a `Float64` against this Union type, as `Float64` is not part of the defined union.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_21\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> IntOrString = Union{Int,AbstractString}\nUnion{Int64, AbstractString}\n\njulia> 1 :: IntOrString\n1\n\njulia> \"Hello!\" :: IntOrString\n\"Hello!\"\n\njulia> 1.0 :: IntOrString\nERROR: TypeError: in typeassert, expected Union{Int64, AbstractString}, got a value of type Float64\n```\n\n----------------------------------------\n\nTITLE: Defining a Self-Referential Mutable Struct in Julia\nDESCRIPTION: Defines a `mutable struct` named `SelfReferential` with a single field `obj` which is also of type `SelfReferential`. This structure illustrates the concept of recursive data types where an object refers to another object of the same type, posing a challenge for initial construction.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_7\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> mutable struct SelfReferential\n           obj::SelfReferential\n       end\n```\n\n----------------------------------------\n\nTITLE: Introducing Dynamic Scoping with ScopedValue in Julia\nDESCRIPTION: This snippet demonstrates dynamic scoping using `ScopedValue` from `Base.ScopedValues`. A `ScopedValue` `x` is created with a default value. The `with` function creates a dynamic scope where `x` is temporarily assigned a new value (5). Inside the `with` block, `f()` observes the dynamically scoped value. Outside the block, `x` reverts to its previous value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.ScopedValues\n\nx = ScopedValue(1)\nf() = @show x[]\nwith(x=>5) do\n    f() # 5\nend\nf() # 1\n```\n\n----------------------------------------\n\nTITLE: Constructing DateTime and Date Values - Julia Dates Module - Julia\nDESCRIPTION: This set of code snippets demonstrates various ways to construct DateTime and Date objects in Julia using the Dates module. It shows constructors with different numbers of arguments to specify varying degrees of temporal precision (from just the year to full date and time with milliseconds), and the use of Period types (Year, Month, Day) for initialization. No external dependencies are required beyond the built-in Dates module. Inputs are numeric year, month, day, etc., or Period objects, and outputs are DateTime or Date instances. Errors occur if constructor arguments are invalid.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> DateTime(2013)\n2013-01-01T00:00:00\n\njulia> DateTime(2013,7)\n2013-07-01T00:00:00\n\njulia> DateTime(2013,7,1)\n2013-07-01T00:00:00\n\njulia> DateTime(2013,7,1,12)\n2013-07-01T12:00:00\n\njulia> DateTime(2013,7,1,12,30)\n2013-07-01T12:30:00\n\njulia> DateTime(2013,7,1,12,30,59)\n2013-07-01T12:30:59\n\njulia> DateTime(2013,7,1,12,30,59,1)\n2013-07-01T12:30:59.001\n\njulia> Date(2013)\n2013-01-01\n\njulia> Date(2013,7)\n2013-07-01\n\njulia> Date(2013,7,1)\n2013-07-01\n\njulia> Date(Dates.Year(2013),Dates.Month(7),Dates.Day(1))\n2013-07-01\n\njulia> Date(Dates.Month(7),Dates.Year(2013))\n2013-07-01\n```\n\n----------------------------------------\n\nTITLE: Implementing a Julia Package Extension Module\nDESCRIPTION: This Julia code snippet illustrates the typical structure of a package extension module (`FooExt`). It begins by importing the main package (`MyPackage`) and the trigger dependency (`ExtDep`). It then extends a function (`MyPackage.func`) from the main package to handle types defined in the trigger package (`ExtDep.SomeStruct`). Extension code resides in files like `ext/FooExt.jl`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nmodule FooExt\n\n# Load main package and triggers\nusing MyPackage, ExtDep\n\n# Extend functionality in main package with types from the triggers\nMyPackage.func(x::ExtDep.SomeStruct) = ...\n\nend\n```\n\n----------------------------------------\n\nTITLE: Verifying Total Thread Count at Runtime - Julia REPL\nDESCRIPTION: Demonstrates querying the total number of available execution threads after Julia startup, using Threads.nthreads() at the REPL. No dependencies beyond Julia's standard library. This returns the current number of threads as an integer.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_2\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> Threads.nthreads()\n4\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Power Iteration Method for Arrays (Julia)\nDESCRIPTION: This Julia function implements the well-known power iteration method for finding the dominant eigenvector and eigenvalue of a matrix. The routine is fully generic, making no assumptions about the underlying array type, so it works with ordinary, distributed, and GPU-backed matrices and vectors. The only requirements are that the input types support matrix multiplication, normalization, and division. Inputs: matrix M and vector v; Outputs: estimated dominant eigenvector and eigenvalue (tuple). No explicit dependencies, but full compatibility with packages like DistributedArrays.jl and CUDA.jl.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_45\n\nLANGUAGE: julia\nCODE:\n```\nfunction power_method(M, v)\n    for i in 1:100\n        v = M*v\n        v /= norm(v)\n    end\n\n    return v, norm(M*v) / norm(v)  # or  (M*v) ./ v\nend\n```\n\n----------------------------------------\n\nTITLE: Instantiating Parameterized Julia Struct with Abstract Type Parameter\nDESCRIPTION: Shows that the benefits of parameterization are lost if the parameterized struct (`MyType`) is explicitly instantiated with an abstract type parameter (`AbstractFloat`). In this case, the field `m.a` can change type at runtime, similar to the `MyStillAmbiguousType` example, leading to potential performance issues.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_15\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> m = MyType{AbstractFloat}(3.2)\nMyType{AbstractFloat}(3.2)\n\njulia> typeof(m.a)\nFloat64\n\njulia> m.a = 4.5f0\n4.5f0\n\njulia> typeof(m.a)\nFloat32\n```\n\n----------------------------------------\n\nTITLE: Setting up the Test Environment for a Julia Package using Pkg/Shell\nDESCRIPTION: Demonstrates navigating into the `test` directory of the `Example` package using `cd`, activating a dedicated test environment using the Pkg REPL command `pkg> activate .`, and adding the standard `Test` library as a dependency for this environment using `pkg> add Test`. This isolates test dependencies from the main package dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\nshell> cd test\n```\n\nLANGUAGE: julia\nCODE:\n```\npkg> activate .\n(test) pkg> add Test\n```\n\n----------------------------------------\n\nTITLE: Example File Structure for Nested Julia Workspaces\nDESCRIPTION: This snippet illustrates a possible file structure for nested workspaces in Julia. The root `Project.toml` defines a workspace including `MyPackage`. `MyPackage` itself contains a `Project.toml` defining another workspace including `test`. A single `Manifest.toml` is generated and stored at the root level, managing dependencies for all projects within the nested workspace structure.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_18\n\nLANGUAGE: plaintext\nCODE:\n```\nProject.toml # projects = [\"MyPackage\"]\nManifest.toml\nMyPackage/\n    Project.toml # projects = [\"test\"]\n    test/\n        Project.toml\n```\n\n----------------------------------------\n\nTITLE: Identifying REPL Frames in Julia Stack Traces\nDESCRIPTION: Repeats the `example()` function definition and call to explicitly highlight the presence of REPL-specific frames (like `REPL.jl`, `event.jl`, and `boot.jl`) often seen when calling `stacktrace()` from the interactive Julia prompt. These frames represent the REPL's internal workings.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_2\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> example() = stacktrace()\nexample (generic function with 1 method)\n\njulia> example()\n7-element Array{Base.StackTraces.StackFrame,1}:\n example() at REPL[1]:1\n top-level scope\n eval at boot.jl:317 [inlined]\n eval(::Module, ::Expr) at REPL.jl:5\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n macro expansion at REPL.jl:116 [inlined]\n (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a MultiSelectMenu in Julia\nDESCRIPTION: Illustrates the creation and usage of a `MultiSelectMenu` from `REPL.TerminalMenus`. This menu allows the user to select multiple items from the provided list. The `request` function returns a `Set` containing the indices of all selected items, or an empty set if the menu is canceled.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\n# here we use the default `pagesize` 10\nmenu = MultiSelectMenu(options)\n\n# `request` returns a `Set` of selected indices\n# if the menu us canceled (ctrl-c or q), return an empty set\nchoices = request(\"Select the fruits you like:\", menu)\n\nif length(choices) > 0\n    println(\"You like the following fruits:\")\n    for i in choices\n        println(\"  - \", options[i])\n    end\nelse\n    println(\"Menu canceled.\")\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Typed Global Variable upon Assignment in Julia\nDESCRIPTION: Demonstrates declaring a typed global variable (`x`) in Julia (feature added in version 1.8). The syntax `x::Float64 = 2.718` assigns the value `2.718` and simultaneously declares that the global variable `x` must always hold a value compatible with type `Float64`. This type constraint allows for compiler optimizations. The function `f`'s return type is inferred as `Float64`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_30\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> x::Float64 = 2.718\n2.718\n\njulia> f() = x\nf (generic function with 1 method)\n\njulia> Base.return_types(f)\n1-element Vector{Any}:\n Float64\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Parameterized Julia Tasks\nDESCRIPTION: Shows two methods for creating a `Task` that executes a function (`mytask`) requiring arguments. Since the `Task` constructor expects a zero-argument function, the first method uses an anonymous function `() -> mytask(7)` to wrap the call. The second method uses the `@task mytask(7)` macro, which provides a more concise, equivalent syntax for the same purpose. Both approaches create a `Task` object (`taskHdl`) that, when scheduled, will execute `mytask(7)`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/asynchronous-programming.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nfunction mytask(myarg)\n    ...\nend\n\ntaskHdl = Task(() -> mytask(7))\n# or, equivalently\ntaskHdl = @task mytask(7)\n```\n\n----------------------------------------\n\nTITLE: Using Julia Packages (Importing Exports)\nDESCRIPTION: Shows package loading with `using X`. Similar to `import X`, this loads the package identified as `X` and makes its module available. Additionally, `using X` brings all names exported by package `X` into the current module's namespace, allowing them to be used without qualification (e.g., `function_name` instead of `X.function_name`). The package loading mechanism itself is the same as `import X`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nusing X\n```\n\n----------------------------------------\n\nTITLE: Receiving IPv6 Multicast Packets with UDP in Julia\nDESCRIPTION: This snippet shows how to listen for UDP multicast packets over IPv6. It binds a UDPSocket to port 6789 on all IPv6 interfaces, joins the specified multicast group, and prints the received message. After receiving one message, it leaves the group and closes the socket. Inputs: UDP multicast traffic to the IPv6 group address. Output: Multicast message contents as string. Requires Sockets and IPv6 multicast network capability.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\nusing Sockets\ngroup = Sockets.IPv6(\"ff05::5:6:7\")\nsocket = Sockets.UDPSocket()\nbind(socket, Sockets.IPv6(\"::\"), 6789)\njoin_multicast_group(socket, group)\nprintln(String(recv(socket)))\nleave_multicast_group(socket, group)\nclose(socket)\n```\n\n----------------------------------------\n\nTITLE: Handling Inf and NaN in Complex Numbers in Julia\nDESCRIPTION: Shows how Inf and NaN propagate into the real and imaginary parts of a complex number in Julia. This relies on special floating-point values recognized by Julia Base. Inputs are expressions involving Inf or NaN; outputs are complex numbers with those values in their imaginary parts.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1 + Inf*im\n1.0 + Inf*im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1 + NaN*im\n1.0 + NaN*im\n```\n\n----------------------------------------\n\nTITLE: Underlying Iteration Mechanism in Julia\nDESCRIPTION: Illustrates the lower-level translation of a Julia `for` loop. It uses the `iterate` function, which returns a tuple `(element, state)` or `nothing` when iteration is complete. The `state` object is passed to the next `iterate` call.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nnext = iterate(iter)\nwhile next !== nothing\n    (i, state) = next\n    # body\n    next = iterate(iter, state)\nend\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Function Application in Julia\nDESCRIPTION: To apply a scalar function element-wise to an array in Julia, use the dot syntax `f.(A)`. Standard function application `f(A)` might be defined differently (e.g., matrix operations).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nf.(A)\n```\n\n----------------------------------------\n\nTITLE: Declaring C Main Function Signature\nDESCRIPTION: Standard C main function signature used as an example for demonstrating how to call C functions accepting `char**` arguments from Julia. This signature takes an argument count (`argc`) and an array of string arguments (`argv`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\nint main(int argc, char **argv);\n```\n\n----------------------------------------\n\nTITLE: Using Numbered Prompts and Output History in Julia REPL\nDESCRIPTION: Demonstrates the usage of numbered prompts after they have been enabled. It shows how input prompts are prefixed with `In [n]:` and outputs with `Out[n]:`. Previous results can be accessed using the `Out[n]` variable, and the entire history is stored in the `Out` dictionary.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_33\n\nLANGUAGE: julia-repl\nCODE:\n```\nIn [1]: 5 + 3\nOut[1]: 8\n\nIn [2]: Out[1] + 5\nOut[2]: 13\n\nIn [3]: Out\nOut[3]: Dict{Int64, Any} with 2 entries:\n  2 => 13\n  1 => 8\n```\n\n----------------------------------------\n\nTITLE: Slicing the Custom SparseArray in Julia\nDESCRIPTION: Shows that indexing the `SparseArray` with ranges (slicing) returns another `SparseArray` instance, not a standard `Array`. This behavior is crucial for maintaining the array's custom type during operations and is enabled by the custom `similar(A::SparseArray, ::Type{T}, dims::Dims)` method defined for `SparseArray`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_18\n\nLANGUAGE: jldoctest squarevectype\nCODE:\n```\njulia> A[1:2,:]\n2×3 SparseArray{Float64, 2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n```\n\n----------------------------------------\n\nTITLE: Defining promote_rule for Rational Type Interactions in Julia\nDESCRIPTION: Presents the promotion rules defined for Julia's `Rational` type. These rules handle promotion between `Rational` and `Integer`, between two different `Rational` types, and between `Rational` and `AbstractFloat`, ensuring seamless interoperation with other numeric types. Requires importing `promote_rule` from `Base`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nimport Base: promote_rule\npromote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\npromote_rule(::Type{Rational{T}}, ::Type{Rational{S}}) where {T<:Integer,S<:Integer} = Rational{promote_type(T,S)}\npromote_rule(::Type{Rational{T}}, ::Type{S}) where {T<:Integer,S<:AbstractFloat} = promote_type(T,S)\n```\n\n----------------------------------------\n\nTITLE: Creating C Function Pointers with Closures using @cfunction in Julia\nDESCRIPTION: Illustrates creating a C-callable function pointer from a Julia closure using `@cfunction`. The `$` syntax before the function name (`cmp`) indicates it's a closure. The resulting `Base.CFunction` object (`callback`) encapsulates the closure's environment and is passed to a C `qsort` function via `@ccall`. This requires careful garbage collection management (automatic within `@ccall`, manual with `GC.@preserve` otherwise) and relies on LLVM trampolines, potentially limiting platform compatibility (e.g., ARM, PowerPC).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nfunction qsort(a::Vector{T}, cmp) where T\n    isbits(T) || throw(ArgumentError(\"this method can only qsort isbits arrays\"))\n    callback = @cfunction $cmp Cint (Ref{T}, Ref{T})\n    # Here, `callback` isa Base.CFunction, which will be converted to Ptr{Cvoid}\n    # (and protected against finalization) by the ccall\n    @ccall qsort(a::Ptr{T}, length(a)::Csize_t, Base.elsize(a)::Csize_t, callback::Ptr{Cvoid})\n    # We could instead use:\n    #    GC.@preserve callback begin\n    #        use(Base.unsafe_convert(Ptr{Cvoid}, callback))\n    #    end\n    # if we needed to use it outside of a `ccall`\n    return a\nend\n```\n\n----------------------------------------\n\nTITLE: Setting JULIA_NUM_THREADS Environment Variable - C Shell / CMD\nDESCRIPTION: Shows how to set the JULIA_NUM_THREADS environment variable on C shell (Linux/macOS) or CMD (Windows) before launching Julia. Ensures Julia starts with the specified thread count. Syntax uses the 'set' command.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nset JULIA_NUM_THREADS=4\n```\n\n----------------------------------------\n\nTITLE: Sending IPv6 Multicast Packets with UDP in Julia\nDESCRIPTION: This code demonstrates sending a single string message over an IPv6 UDP multicast group. It creates a UDPSocket, sends a message to group 'ff05::5:6:7' on port 6789, then closes the socket. No need to join the group for sending. Inputs: IPv6 multicast address, port, and message string. Output: Datagram transmitted to the specified multicast group. Supports only environments with IPv6 and multicast support enabled.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nusing Sockets\ngroup = Sockets.IPv6(\"ff05::5:6:7\")\nsocket = Sockets.UDPSocket()\nsend(socket, group, 6789, \"Hello over IPv6\")\nclose(socket)\n```\n\n----------------------------------------\n\nTITLE: Combining Horizontal and Vertical Concatenation in Julia\nDESCRIPTION: Shows how to combine single semicolons (`;` or newlines) for vertical concatenation and spaces (or tabs) for horizontal concatenation within the same array literal expression. Demonstrates that spaces/tabs have higher precedence, performing horizontal concatenation first before vertical concatenation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [1 2\n        3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> [zeros(Int, 2, 2) [1; 2]\n        [3 4]            5]\n3×3 Matrix{Int64}:\n 0  0  1\n 0  0  2\n 3  4  5\n\njulia> [[1 1]; 2 3; [4 4]]\n3×2 Matrix{Int64}:\n 1  1\n 2  3\n 4  4\n```\n\n----------------------------------------\n\nTITLE: Exponentiation Associativity\nDESCRIPTION: Julia evaluates chained exponentiation right-to-left (`a^b^c` is `a^(b^c)`), whereas MATLAB evaluates it left-to-right (`a^b^c` is `(a^b)^c`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\na^b^c # Evaluated as a^(b^c) in Julia\n```\n\nLANGUAGE: matlab\nCODE:\n```\na^b^c % Evaluated as (a^b)^c in MATLAB\n```\n\n----------------------------------------\n\nTITLE: Analyzing Alias Propagation via Array Operations - Julia\nDESCRIPTION: This example demonstrates how EscapeAnalysis tracks escape propagation through arrayref/arrayset chains using a Julia array of Any populated with SafeRef wrappers. The function is called via code_escapes, initializes an empty Any array, inserts a SafeRef-wrapped input, returns the first element and the length. Dependencies include SafeRef and code_escapes. Inputs are String; outputs are a tuple accessed from the array. Highlights how aliasing occurs through arrays, as well as conservative handling of thrown exceptions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\ncode_escapes((String,)) do s\n    ary = Any[]\n    push!(ary, SafeRef(s))\n    return ary[1], length(ary)\nend\n```\n\n----------------------------------------\n\nTITLE: Indexing Near String End and Using prevind in Julia\nDESCRIPTION: Demonstrates indexing relative to the end of a UTF-8 string and the use of `prevind` for safe navigation. `s[end-1]` works because the last two characters ('y' and ' ') are single-byte. `s[end-2]` fails because index 9 falls within the multi-byte character '∃'. `s[prevind(s, end, 2)]` correctly retrieves '∃' by finding the valid starting index two characters before the end.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_16\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> s[end-1]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n\njulia> s[end-2]\nERROR: StringIndexError: invalid index [9], valid nearby indices [7]=>'∃', [10]=>' '\nStacktrace:\n[...]\n\njulia> s[prevind(s, end, 2)]\n'∃': Unicode U+2203 (category Sm: Symbol, math)\n```\n\n----------------------------------------\n\nTITLE: Accessing DataType Field Types in Julia\nDESCRIPTION: Demonstrates accessing the types of fields within a defined struct (`Point`). The `.types` property of the struct's type object returns an `svec` (SimpleVector) containing the types of each field. For the previously defined `Point` struct, it shows `Int64` for `x` and `Any` for the untyped field `y`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/reflection.md#_snippet_1\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Point.types\nsvec(Int64, Any)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Iterable Type `Squares` in Julia\nDESCRIPTION: This snippet defines a custom struct `Squares` holding a count and implements the mandatory `iterate` method. This makes instances of `Squares` iterable, returning square numbers sequentially.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_1\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct Squares\n           count::Int\n       end\n\njulia> Base.iterate(S::Squares, state=1) = state > S.count ? nothing : (state*state, state+1)\n```\n\n----------------------------------------\n\nTITLE: Calling External Library Functions Using @ccall in Julia\nDESCRIPTION: These code snippets demonstrate how to call external C functions directly from Julia using the @ccall macro. The examples include calls to the standard C library's clock and getenv functions, showing how to handle return types and manage pointers and strings safely in Julia. Dependencies include the external shared library (such as libc), and type annotations are critical for proper function invocation and data marshalling.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> t = @ccall clock()::Int32\n2292761\n\njulia> typeof(t)\nInt32\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> path = @ccall getenv(\"SHELL\"::Cstring)::Cstring\nCstring(@0x00007fff5fbffc45)\n\njulia> unsafe_string(path)\n\"/bin/bash\"\n```\n\n----------------------------------------\n\nTITLE: Element-wise Logical Comparisons in Julia\nDESCRIPTION: Standard logical comparison operators (`==`, `<`, `>` etc.) in Julia do not perform element-wise comparison on arrays. Use the dot syntax (`.==`, `.<`, `.>`) for element-wise operations, which return boolean arrays.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nA == B # Compares arrays A and B as whole objects\n```\n\nLANGUAGE: julia\nCODE:\n```\nA .== B # Performs element-wise comparison\n```\n\n----------------------------------------\n\nTITLE: Using lock() Function for Thread Safety in Julia\nDESCRIPTION: Shows two alternative ways to achieve thread safety using the `lock()` function: a do-block syntax which automatically handles locking and unlocking, and an explicit `lock()`/`unlock()` pair within a `try...finally` block to guarantee the lock is released even if errors occur. Both methods modify `my_variable` safely, assuming `my_lock` and `my_variable` are defined as in the previous example.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_19\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> lock(my_lock) do\n           my_variable[1] = 100\n       end\n100\n\njulia> begin\n           lock(my_lock)\n           try\n               my_variable[1] = 100\n           finally\n               unlock(my_lock)\n           end\n       end\n100\n```\n\n----------------------------------------\n\nTITLE: Using `missing` in Control Flow Statements (`if`) in Julia\nDESCRIPTION: Demonstrates that using a `missing` value directly in a boolean context required by control flow statements like `if` is not allowed. Because it's uncertain whether the condition would be `true` or `false`, Julia throws a `TypeError`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_8\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> if missing\n           println(\"here\")\n       end\nERROR: TypeError: non-boolean (Missing) used in boolean context\n```\n\n----------------------------------------\n\nTITLE: Broadcasting a Function with Multiple Arguments in Julia\nDESCRIPTION: Shows how dot syntax (`.`) facilitates broadcasting when a function takes multiple arguments. It applies `f(x, y) = 3x + 4y` elementwise first with a scalar (`pi`) and a vector (`A`), and then with two vectors (`A` and `B`). These operations are equivalent to `broadcast(f, pi, A)` and `broadcast(f, A, B)` respectively.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_42\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> f(x, y) = 3x + 4y;\n\njulia> A = [1.0, 2.0, 3.0];\n\njulia> B = [4.0, 5.0, 6.0];\n\njulia> f.(pi, A)\n3-element Vector{Float64}:\n 13.42477796076938\n 17.42477796076938\n 21.42477796076938\n\njulia> f.(A, B)\n3-element Vector{Float64}:\n 19.0\n 26.0\n 33.0\n```\n\n----------------------------------------\n\nTITLE: Assignment versus Mutation with Arrays - Julia Doctest (mutation_vs_rebind) - Julia\nDESCRIPTION: This snippet distinguishes assignment (binding a name to a value) from mutation (changing the contents of a mutable object) using Julia arrays. It starts by binding 'a' to an array and 'b' to the same reference, showing that initial assignment does not create a new array. The code then mutates the array via an index and demonstrates how 'a' can be rebound to a different value while 'b' still references the mutated array. This is useful for understanding memory and object references in Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> a = [1,2,3] # an array of 3 integers\\n3-element Vector{Int64}:\\n 1\\n 2\\n 3\\n\\njulia> b = a   # both b and a are names for the same array!\\n3-element Vector{Int64}:\\n 1\\n 2\\n 3\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> a[1] = 42     # change the first element\\n42\\n\\njulia> a = 3.14159   # a is now the name of a different object\\n3.14159\\n\\njulia> b   # b refers to the original array object, which has been mutated\\n3-element Vector{Int64}:\\n 42\\n  2\\n  3\n```\n\n----------------------------------------\n\nTITLE: Declaring and Evaluating Compound Expressions in Julia - Julia\nDESCRIPTION: Demonstrates the use of a multiline begin block for grouping multiple expressions, evaluating them in order, and returning the value of the last subexpression. No special dependencies required; variables x and y are declared and summed within the block, and the result is assigned to z. The output shows the evaluated sum as the result of the entire block.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> z = begin\n           x = 1\n           y = 2\n           x + y\n       end\n3\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-IEEE Semantics of @fastmath in Julia Functions\nDESCRIPTION: Shows how using @fastmath macro can break IEEE guarantees, with specific emphasis on isnan checks. The example contrasts the result of a function with and without @fastmath when checking for NaN. This illustrates that the macro can change semantic results, particularly for special floating-point values. Prerequisites: Julia 1.0 or later. Inputs: NaN; Output: Boolean values. Limitation: Results may be surprising; always use @fastmath cautiously if IEEE conformance matters.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_60\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> f(x) = isnan(x);\n\njulia> f(NaN)\ntrue\n\njulia> f_fast(x) = @fastmath isnan(x);\n\njulia> f_fast(NaN)\nfalse\n\n```\n\n----------------------------------------\n\nTITLE: Assigning Global Variables in Julia REPL (Implicit)\nDESCRIPTION: Shows that assigning a variable `x` at the top level in the Julia REPL implicitly creates a global variable. This behavior is highlighted as potentially leading to performance issues discussed in the document.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_3\n\nLANGUAGE: julia-repl\nCODE:\n```\n```julia-repl\njulia> x = 1.0\n```\n```\n\n----------------------------------------\n\nTITLE: Broadcasted Assignment for Indexing - Julia\nDESCRIPTION: Prescribes explicit broadcasting assignment using '.=' or 'fill!' when assigning non-array or scalar values over selected indices. Code examples show preferred alternatives to implicit broadcasting. Requires Base Julia; inputs are indexed arrays and values, output is mutation of the array as per broadcasting.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_151\n\nLANGUAGE: julia\nCODE:\n```\nA[I...] .= x\nfill!(view(A, I...), x)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Integer Overflow and Wrapping in Julia - Julia\nDESCRIPTION: This snippet demonstrates how Julia's native Int type behaves when arithmetic operations overflow, showcasing wraparound behavior at the type's bounds. No external dependencies are needed besides Julia itself. Variables x, y, and z are used to explore overflow resulting from addition and multiplication, emphasizing the contrast to mathematical integer behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = typemax(Int)\n9223372036854775807\n\njulia> y = x+1\n-9223372036854775808\n\njulia> z = -y\n-9223372036854775808\n\njulia> 2*z\n0\n```\n\n----------------------------------------\n\nTITLE: Defining and Overloading Methods for Parametric Arrays - Julia\nDESCRIPTION: This snippet shows how to define multiple Julia methods using parametric type signatures for the `Array` type. It demonstrates how signatures can be written with or without specifying parameter constraints or type annotations, enabling method dispatch on different array types. Requires Julia base language. Each method accepts an array and returns a unique integer, showing the effect of type signatures on method selection. Inputs are arrays of different types; outputs are corresponding integers for each method.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nf1(A::Array) = 1\nf2(A::Array{Int}) = 2\nf3(A::Array{T}) where {T<:Any} = 3\nf4(A::Array{Any}) = 4\n```\n\n----------------------------------------\n\nTITLE: Allocating GSL Structures Using @ccall - Julia\nDESCRIPTION: This code illustrates defining an opaque Julia struct for a C library type and wrapping a C function (gsl_permutation_alloc) that returns a pointer to this type. Using the @ccall macro, it calls the external allocation function and handles failure cases, returning the pointer or throwing an error if memory cannot be allocated. Requires access to the \"libgsl\" library. Input: integer n (number of elements). Output: Ptr{gsl_permutation} or an error.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\nmutable struct gsl_permutation\nend\n\n# The corresponding C signature is\n#     gsl_permutation * gsl_permutation_alloc (size_t n);\nfunction permutation_alloc(n::Integer)\n    output_ptr = @ccall \"libgsl\".gsl_permutation_alloc(n::Csize_t)::Ptr{gsl_permutation}\n    if output_ptr == C_NULL # Could not allocate memory\n        throw(OutOfMemoryError())\n    end\n    return output_ptr\nend\n```\n\n----------------------------------------\n\nTITLE: Filtering Elements in Julia Nested Comprehension\nDESCRIPTION: Demonstrates filtering within a nested Julia array comprehension using the `if` keyword. It builds upon the previous example but only includes tuples `(i, j)` in the resulting `Vector` if the condition `i+j == 4` is true.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_17\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [(i, j) for i=1:3 for j=1:i if i+j == 4]\n2-element Vector{Tuple{Int64, Int64}}:\n (2, 2)\n (3, 1)\n```\n\n----------------------------------------\n\nTITLE: Reading, Processing, and Writing with Channels in Julia\nDESCRIPTION: Demonstrates concurrent task scheduling using Julia channels, showing how multiple tasks can read data from one channel, process it, and write results to another. Dependencies include the Channel type, put! and take! for communication, and Threads.@spawn for parallel execution. Requires n (number of concurrent tasks) to be defined, along with channels c1 and c2. Inputs are items provided on c1; outputs are processed results sent to c2. The foo function is spawned n times, and each task blocks until data is available.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/asynchronous-programming.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n# Given Channels c1 and c2,\nc1 = Channel(32)\nc2 = Channel(32)\n\n# and a function `foo` which reads items from c1, processes the item read\n# and writes a result to c2,\nfunction foo()\n    while true\n        data = take!(c1)\n        [...]               # process data\n        put!(c2, result)    # write out result\n    end\nend\n\n# we can schedule `n` instances of `foo` to be active concurrently.\nfor _ in 1:n\n    errormonitor(Threads.@spawn foo())\nend\n```\n\n----------------------------------------\n\nTITLE: Specialization Behavior on Type Arguments - Julia\nDESCRIPTION: Demonstrates the difference between unspecialized and specialized function definitions in Julia with respect to type arguments (Type and Type{T}). The first version does not trigger specialization, while the second with a type parameter does. Requires only Julia Base. Key parameters: t (type or Type{T}); output is a summed value based on ones of the type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\nfunction f_type(t)  # or t::Type\n    x = ones(t, 10)\n    return sum(map(sin, x))\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction g_type(t::Type{T}) where T\n    x = ones(T, 10)\n    return sum(map(sin, x))\nend\n```\n\n----------------------------------------\n\nTITLE: Experimental Multi-threaded Task Spawning in Julia\nDESCRIPTION: Introduces the experimental `Threads.@spawn` macro, which creates and runs a task on any available thread, facilitating parallel execution.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_104\n\nLANGUAGE: julia\nCODE:\n```\nThreads.@spawn <expression>\n```\n\n----------------------------------------\n\nTITLE: Creating Output Redirection with pipeline in Julia\nDESCRIPTION: Demonstrates the preferred Julia-native method for redirecting the output of an external command (`ls`) to a file (`files.txt`) using the `pipeline` function within `run`. This approach mimics shell redirection (`>`) without invoking an OS shell, offering better performance and cross-platform compatibility.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nrun(pipeline(`ls`, \"files.txt\"))\n```\n\n----------------------------------------\n\nTITLE: Using `missing` with Short-Circuiting Operators (`||`, `&&`) - Error Cases in Julia\nDESCRIPTION: Shows that the short-circuiting boolean operators (`||`, `&&`) also disallow `missing` values in contexts where the `missing` value's evaluation is necessary to determine whether to evaluate the subsequent operand. This results in a `TypeError`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_9\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> missing || false\nERROR: TypeError: non-boolean (Missing) used in boolean context\n\njulia> missing && false\nERROR: TypeError: non-boolean (Missing) used in boolean context\n\njulia> true && missing && false\nERROR: TypeError: non-boolean (Missing) used in boolean context\n```\n\n----------------------------------------\n\nTITLE: Self-reference in Julia Types using typeof\nDESCRIPTION: Demonstrates that the DataType object in Julia is its own type and that Union is also a DataType. Highlights the fully object-oriented nature of Julia's type system for introspection and meta-programming. No dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_65\n\nLANGUAGE: julia\nCODE:\n```\ntypeof(DataType)\\ntypeof(Union)\n```\n\n----------------------------------------\n\nTITLE: Custom Binary BroadcastStyle Method for Output Container Precedence - Julia\nDESCRIPTION: Provides an example for defining how Julia's broadcast machinery selects output container type precedence when combining different source types. This Base.BroadcastStyle method ensures that tuple containers take precedence over zero-dimensional arrays, affecting the resulting structure of broadcasted output. Inputs are style types; output is a Style instance indicating container selection. Used by developers creating custom containers or interaction rules between heterogeneous broadcast participants. No external dependencies required other than Julia broadcast framework.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nBase.BroadcastStyle(::Broadcast.Style{Tuple}, ::Broadcast.AbstractArrayStyle{0}) = Broadcast.Style{Tuple}()\n```\n\n----------------------------------------\n\nTITLE: Sending Custom Type Instances via RemoteChannel in Julia\nDESCRIPTION: Creates an instance of `MyType` (defined in `DummyModule`) locally and sends it to worker 2 using `put!` on a `RemoteChannel` specifically targeting worker 2. This demonstrates that data of custom types can be sent between processes as long as the type definition is loaded on the receiving process, even if the defining module is not explicitly `using`-ed in the receiver's scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_8\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> put!(RemoteChannel(2), MyType(7))\nRemoteChannel{Channel{Any}}(2, 1, 13)\n```\n\n----------------------------------------\n\nTITLE: Executing a Macro with Arguments in Julia\nDESCRIPTION: Shows how to call the parameterized `@sayhello` macro with a string literal argument `\"human\"`. The macro expands, interpolating the argument, and the resulting code is executed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_23\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> @sayhello(\"human\")\nHello, human\n```\n\n----------------------------------------\n\nTITLE: Interaction of Optional Arguments and Method Specialization in Julia\nDESCRIPTION: Illustrates how defining a more specialized method (`f(a::Int,b::Int) = a-2b`) can affect calls that use default optional arguments. The call `f()` (which translates to `f(1,2)`) will now invoke the more specific `Int` method instead of the original generic method.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\nf(a::Int,b::Int) = a-2b\n```\n\n----------------------------------------\n\nTITLE: Comparing Behavior After Method Redefinition in Julia\nDESCRIPTION: Compares the output of calling `f`, `g`, `gen1`, and `gen2` with an integer argument (`1`) after `f` has been redefined. It shows that `f` and `g` use the new `Int` definition, `gen2` (which generates `:(f(x))`) also uses the new definition at runtime, but `gen1` (which called `f(x)` during generation) still uses the 'original definition' available when `gen1` was defined.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_68\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(1)\n\"definition for Int\"\n\njulia> g(1)\n\"definition for Int\"\n\njulia> gen1(1)\n\"original definition\"\n\njulia> gen2(1)\n\"definition for Int\"\n```\n\n----------------------------------------\n\nTITLE: Testing for `missing` using `isequal` and `===` in Julia\nDESCRIPTION: Illustrates that the special comparison operators `isequal` and `===` do not propagate `missing`. They always return a `Bool` value, considering `missing` as equal only to itself and different from any other value. These can be reliably used to check if a value is `missing`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> missing === 1\nfalse\n\njulia> isequal(missing, 1)\nfalse\n\njulia> missing === missing\ntrue\n\njulia> isequal(missing, missing)\ntrue\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Pipe Operator `.|>` in Julia\nDESCRIPTION: Illustrates the use of the broadcasting pipe operator `.|>`. It applies a corresponding function from the right-hand side array (`[uppercase, reverse, titlecase, length]`) to each element of the left-hand side array (`[\"a\", \"list\", \"of\", \"strings\"]`) individually.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_38\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [\"a\", \"list\", \"of\", \"strings\"] .|> [uppercase, reverse, titlecase, length]\n4-element Vector{Any}:\n  \"A\"\n  \"tsil\"\n  \"Of\"\n 7\n```\n\n----------------------------------------\n\nTITLE: Using tonext with Do-Block Syntax for Complex Date Rules in Julia\nDESCRIPTION: Uses a do-block to express a compound temporal condition (finding the 4th Thursday of November, i.e., Thanksgiving) and applies tonext to find the next matching Date from a start. The temporal predicate is evaluated for each candidate Date.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\njulia> Dates.tonext(Date(2014,7,13)) do x\n           # Return true on the 4th Thursday of November (Thanksgiving)\n           Dates.dayofweek(x) == Dates.Thursday &&\n           Dates.dayofweekofmonth(x) == 4 &&\n           Dates.month(x) == Dates.November\n       end\n2014-11-27\n```\n\n----------------------------------------\n\nTITLE: Default Broadcast Output Allocation using `similar` in Julia\nDESCRIPTION: Displays the default fallback implementation of `Base.similar` for broadcasting operations using the `Broadcast.DefaultArrayStyle{N}`. It allocates a standard Julia `Array` with the specified element type (`ElType`) and dimensions derived from the broadcast operation's axes (`axes(bc)`), which are computed from the input arguments.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nsimilar(bc::Broadcasted{DefaultArrayStyle{N}}, ::Type{ElType}) where {N,ElType} =\n    similar(Array{ElType}, axes(bc))\n```\n```\n\n----------------------------------------\n\nTITLE: Measuring Julia Function Compilation and Execution Time with @time and @eval - Julia\nDESCRIPTION: This snippet demonstrates how Julia's @time macro can be used with @eval to measure both compilation and execution times of a function. The first invocation includes compilation overhead, while subsequent runs are faster. Dependencies include the LinearAlgebra library for matrix operations and access to Julia's REPL environment. Key outputs include detailed allocations and time statistics; inputs are two randomly generated matrices multiplied together. Limitations include environmental variability in timing results due to system load and precompilation status.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_54\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> foo() = rand(2,2) * rand(2,2)\nfoo (generic function with 1 method)\n\njulia> @time @eval foo();\n  0.252395 seconds (1.12 M allocations: 56.178 MiB, 2.93% gc time, 98.12% compilation time)\n\njulia> @time @eval foo();\n  0.000156 seconds (63 allocations: 2.453 KiB)\n```\n\n----------------------------------------\n\nTITLE: Avoiding Pipeline Deadlock with Julia Tasks\nDESCRIPTION: Demonstrates a pattern to avoid deadlocks when reading from and writing to a pipeline within a single Julia process. It uses `Threads.@spawn` to create separate asynchronous tasks for the writing and reading operations, allowing them to proceed concurrently without blocking each other. The main process then waits for the writer and fetches the result from the reader.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nwriter = Threads.@spawn write(process, \"data\")\nreader = Threads.@spawn do_compute(read(process, String))\nwait(writer)\nfetch(reader)\n```\n\n----------------------------------------\n\nTITLE: Reading Byte Arrays from Standard Input - Julia\nDESCRIPTION: Shows how to initialize a zeroed `Vector{UInt8}` and then read input from stdin directly into this pre-allocated array using `read!`. The snippet highlights Julia's low-level I/O interface and buffer operations for efficient byte input. Dependencies are standard Julia. Parameters include the buffer array and the input stream; contents of the buffer are replaced by streamed bytes. Intended for terminal/repl execution with user interaction.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_1\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> x = zeros(UInt8, 4)\\n4-element Vector{UInt8}:\\n 0x00\\n 0x00\\n 0x00\\n 0x00\\n\\njulia> read!(stdin, x)\\nabcd\\n4-element Vector{UInt8}:\\n 0x61\\n 0x62\\n 0x63\\n 0x64\n```\n\n----------------------------------------\n\nTITLE: Combining try/catch/else/finally for Exception Handling in Julia\nDESCRIPTION: This snippet shows a try/catch/else/finally expression in Julia, where the catch block handles an exception with a return value, and the finally block executes cleanup code without affecting the main value. It demonstrates that the result of the overall expression is determined by the catch or else block, while finally always runs at the end. This pattern is useful for robust error handling and resource management.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_42\n\nLANGUAGE: julia\nCODE:\n```\njulia> try\n           error(\"\")\n       catch\n           1\n       else\n           2\n       finally\n           3\n       end\n1\n```\n\n----------------------------------------\n\nTITLE: Extending `getindex` for Non-Integer and Iterable Indices in Julia\nDESCRIPTION: Adds more `getindex` methods to the `Squares` type. One method handles any `Number` by converting it to `Int`, and another handles iterable indices (like ranges or vectors) by applying the integer index logic to each element.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_12\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Base.getindex(S::Squares, i::Number) = S[convert(Int, i)]\n\njulia> Base.getindex(S::Squares, I) = [S[i] for i in I]\n```\n\n----------------------------------------\n\nTITLE: Querying Promotion Result Type with promote_type in Julia\nDESCRIPTION: Demonstrates the usage of the `promote_type` function to determine the resulting type when promoting `Int8` and `Int64` without having actual values. It shows that the result type is `Int64`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_11\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> promote_type(Int8, Int64)\nInt64\n```\n\n----------------------------------------\n\nTITLE: Initializing Julia Array with Abstract Type `Real`\nDESCRIPTION: Demonstrates creating a Julia `Vector` parameterized with the abstract type `Real`. Pushing elements of different concrete subtypes (like `Int`, `Float64`, `Irrational`) is possible, but because the container must hold any `Real`, it stores pointers to individually allocated objects, leading to potential performance issues compared to concretely typed arrays.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_10\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> a = Real[]\nReal[]\n\njulia> push!(a, 1); push!(a, 2.0); push!(a, π)\n3-element Vector{Real}:\n 1\n 2.0\n π = 3.1415926535897...\n```\n\n----------------------------------------\n\nTITLE: C Function Pointer and qsort Callback Signature Example in C\nDESCRIPTION: This C code provides a prototype for a C function pointer typedef and the signature for the standard library qsort function. It is included as context for constructing compatible Julia function pointers and callbacks passed to C APIs. Only structure and type signatures are provided; users must ensure their Julia callbacks match these signatures for safe interoperability.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\ntypedef returntype (*functiontype)(argumenttype, ...);\n\nvoid qsort(void *base, size_t nitems, size_t size,\n           int (*compare)(const void*, const void*));\n```\n\n----------------------------------------\n\nTITLE: Accessing Uninitialized Fields in Julia\nDESCRIPTION: Creates an instance `z` of the `Incomplete` struct, which has an uninitialized `data` field due to its constructor using `new()`. Attempting to access `z.data` immediately throws an `UndefRefError`, showcasing Julia's strict handling of uninitialized references to prevent errors related to null values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_12\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> z = Incomplete();\n\njulia> z.data\nERROR: UndefRefError: access to undefined reference\n```\n\n----------------------------------------\n\nTITLE: Using Scoped Values for Permission Checking in Julia\nDESCRIPTION: Provides a practical example of using a `ScopedValue` (`LEVEL`) to manage user permission levels in a simulated web application. The `serve` function determines the permission level and sets it using `with` before spawning a handler task. The `open` function later checks this scoped value to authorize database access, avoiding the need to pass the permission level explicitly through the call stack.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.ScopedValues\n\nconst LEVEL = ScopedValue(:GUEST)\n\nfunction serve(request, response)\n    level = isAdmin(request) ? :ADMIN : :GUEST\n    with(LEVEL => level) do\n        Threads.@spawn handle(request, response)\n    end\nend\n\nfunction open(connection::Database)\n    level = LEVEL[]\n    if level !== :ADMIN\n        error(\"Access disallowed\")\n    end\n    # ... open connection\nend\n\nfunction handle(request, response)\n    # ...\n    open(Database(#=...=#))\n    # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Using Slurping for Destructuring Assignment (Final and Eager) - Julia\nDESCRIPTION: Explains the use of the '...' slurping syntax in assignments for collecting remaining elements into a variable. First example slurps the tail of an iterator, producing a collection, and second shows slurping in non-final positions for eager collection. Requires Julia 1.6 or later for slurping in assignments, and 1.9 for slurping in non-final positions. Input can be any iterable; output demonstrates extracted elements and collections.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_22\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> a, b... = \"hello\"\n\"hello\"\n\njulia> a\n'h': ASCII/Unicode U+0068 (category Ll: Letter, lowercase)\n\njulia> b\n\"ello\"\n\njulia> a, b... = Iterators.map(abs2, 1:4)\nBase.Generator{UnitRange{Int64}, typeof(abs2)}(abs2, 1:4)\n\njulia> a\n1\n\njulia> b\nBase.Iterators.Rest{Base.Generator{UnitRange{Int64}, typeof(abs2)}, Int64}(Base.Generator{UnitRange{Int64}, typeof(abs2)}(abs2, 1:4), 1)\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> a, b..., c = 1:5\n1:5\n\njulia> a\n1\n\njulia> b\n3-element Vector{Int64}:\n 2\n 3\n 4\n\njulia> c\n5\n\njulia> front..., tail = \"Hi!\"\n\"Hi!\"\n\njulia> front\n\"Hi\"\n\njulia> tail\n'!': ASCII/Unicode U+0021 (category Po: Punctuation, other)\n```\n\n----------------------------------------\n\nTITLE: Testing Complex Tuple Subtyping with Diagonal Variables - Julia\nDESCRIPTION: Shows two complex subtype queries involving tuples with invariant and covariant type occurrences. These illustrate how diagonal/concrete variable rules affect Julia's subtyping results. Inputs: Tuple type expressions; Outputs: subtype result (true/false). Helps clarify subtleties in the interaction between positional variance and diagonal type variables.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nTuple{Int,Int8,Vector{Integer}} <: Tuple{T,T,Vector{Union{Integer,T}}} where T\n```\n\nLANGUAGE: julia\nCODE:\n```\nTuple{Int,Int8,Vector{Any}} <: Tuple{T,T,Vector{Union{Integer,T}}} where T\n```\n\n----------------------------------------\n\nTITLE: Inspecting Macro Expansion using `@macroexpand` Macro in Julia\nDESCRIPTION: Demonstrates the `@macroexpand` macro, a convenient alternative to the `macroexpand` function for viewing the code generated by another macro call (`@sayhello \"human\"`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_25\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> @macroexpand @sayhello \"human\"\n:(println(\"Hello, \", \"human\"))\n```\n\n----------------------------------------\n\nTITLE: Defining Functions for Column vs. Row Array Copying in Julia\nDESCRIPTION: Provides four functions (`copy_cols`, `copy_rows`, `copy_col_row`, `copy_row_col`) to create a square matrix by copying an input vector. These functions use different strategies (column slicing, row slicing, nested loops with varying order) to populate the matrix, setting up a comparison of memory access patterns.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_51\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nfunction copy_cols(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for i = inds\n        out[:, i] = x\n    end\n    return out\nend\n\nfunction copy_rows(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for i = inds\n        out[i, :] = x\n    end\n    return out\nend\n\nfunction copy_col_row(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for col = inds, row = inds\n        out[row, col] = x[row]\n    end\n    return out\nend\n\nfunction copy_row_col(x::Vector{T}) where T\n    inds = axes(x, 1)\n    out = similar(Array{T}, inds, inds)\n    for row = inds, col = inds\n        out[row, col] = x[col]\n    end\n    return out\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Freeing Allocated GSL Structures Using @ccall - Julia\nDESCRIPTION: This function wraps the C function gsl_permutation_free via Julia's @ccall macro to free memory previously allocated for a GSL permutation. It takes as input a pointer obtained from the allocator and forwards it directly to the deallocator, following GSL usage patterns. Requires the \"libgsl\" library and a valid Ptr{gsl_permutation}. No return value (Cvoid).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\n# The corresponding C signature is\n#     void gsl_permutation_free (gsl_permutation * p);\nfunction permutation_free(p::Ptr{gsl_permutation})\n    @ccall \"libgsl\".gsl_permutation_free(p::Ptr{gsl_permutation})::Cvoid\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom String Literal Macro with a Flag in Julia\nDESCRIPTION: This Julia code snippet demonstrates how to define a custom non-standard string literal macro (`@foo_str`) that accepts two arguments: the string content `str` and a `flag` string. This allows for more complex custom literal behaviors based on flags provided after the closing quote (e.g., `foo\"string\"flag`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_60\n\nLANGUAGE: julia\nCODE:\n```\nmacro foo_str(str, flag)\n    # do stuff\nend\n```\n\n----------------------------------------\n\nTITLE: Appending Elements to Typed Vectors Using Parametric Methods in Julia\nDESCRIPTION: Defines a 'myappend' function that appends an element to a vector only if the element's type matches the vector's element type, enforcing type safety with type parameters in the signature. Demonstrates single-line and return-typed variations, and shows error handling when types do not align. Inputs are a vector and a value, outputs a new vector with the element appended; raises MethodError if types mismatch; requires Julia's type-constrained method definitions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nfunction myappend(v::Vector{T}, x::T) where {T}\n    return [v..., x]\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\n(myappend(v::Vector{T}, x::T)::Vector) where {T} = [v..., x]\n\nmyappend([1,2,3],4)\nmyappend([1,2,3],2.5)\nmyappend([1.0,2.0,3.0],4.0)\nmyappend([1.0,2.0,3.0],4)\n```\n\n----------------------------------------\n\nTITLE: Functional and Anonymous File Processing Patterns - Julia\nDESCRIPTION: Demonstrates higher-order file processing via `open` with a function argument and the `do` block syntax. Defines a function `read_and_capitalize` that reads and uppercases file content, then shows usage as both named function and anonymous `do` block. Outputs the processed result, automatically managing the file's open/closed state. Dependencies: Julia base. Suitable for single-use file processing patterns.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nfunction read_and_capitalize(f::IOStream)\\n    return uppercase(read(f, String))\\nend\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> open(read_and_capitalize, \"hello.txt\")\\n\"HELLO AGAIN.\"\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> open(\"hello.txt\") do f\\n           uppercase(read(f, String))\\n       end\\n\"HELLO AGAIN.\"\n```\n\n----------------------------------------\n\nTITLE: Inspecting Variables in Custom REPL Module Context in Julia\nDESCRIPTION: Shows how functions like `varinfo()` operate within the currently active REPL module context. This example defines a custom module `CustomMod`, activates it in the REPL using `REPL.activate`, and then uses `varinfo()` to list the variables defined within that specific module.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_31\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> module CustomMod\n           export var, f\n           var = 1\n           f(x) = x^2\n       end;\n\njulia> REPL.activate(CustomMod)\n\n(Main.CustomMod) julia> varinfo()\n  name         size summary\n  ––––––––– ––––––– ––––––––––––––––––––––––––––––––––\n  CustomMod         Module\n  f         0 bytes f (generic function with 1 method)\n  var       8 bytes Int64\n```\n\n----------------------------------------\n\nTITLE: Direct Construction and Comparison of Expr in Julia\nDESCRIPTION: Illustrates direct construction of an Expr (in prefix notation) and checks equivalence with a parsed expression. This is key for generating code programmatically and ensuring that code representations are consistent regardless of construction method. Inputs: operator and arguments as Symbols or values; output: Expr and boolean for equality.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> ex2 = Expr(:call, :+, 1, 1)\n:(1 + 1)\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> ex1 == ex2\ntrue\n```\n\n----------------------------------------\n\nTITLE: Preserving Shell Quoting and Interpolation Semantics - Julia\nDESCRIPTION: Shows how Julia's command backtick syntax preserves the quoting and interpolation rules familiar from POSIX shells. Demonstrates use of single and double quotes within commands, passing variables into command arguments, and running the result to obtain output consistent with shell behavior. Useful for translating shell one-liners or scripts. Julia must have access to called programs such as perl.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> A = `perl -le '$|=1; for (0..3) { print }'`\n`perl -le '$|=1; for (0..3) { print }'`\n\njulia> run(A);\n0\n1\n2\n3\n\njulia> first = \"A\"; second = \"B\";\n\njulia> B = `perl -le 'print for @ARGV' \"1: $first\" \"2: $second\"`\n`perl -le 'print for @ARGV' '1: A' '2: B'`\n\njulia> run(B);\n1: A\n2: B\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Markdown Docstring for a Function - Julia\nDESCRIPTION: Illustrates a multi-line Markdown docstring for a function using triple double quotes. Markdown syntax is supported for code, lists, and formatting. The docstring describes the function, its parameters, and optional arguments ('x[, y]'). Docstrings should appear directly before the function to be associated, with no intervening blank lines or comments.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\n    bar(x[, y])\n\nCompute the Bar index between `x` and `y`.\n\nIf `y` is unspecified, compute the Bar index between all pairs of columns of `x`.\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Custom Operator with Complex Rationals in Julia\nDESCRIPTION: This snippet shows an example of using the previously defined `⊘` operator with complex integer arguments. It creates a complex number `z` where both the real and imaginary parts are `OurRational{Int64}` instances. The `typeof` calls confirm the resulting type and its relationship to `Complex{<:OurRational}`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_23\n\nLANGUAGE: jldoctest rational\nCODE:\n```\njulia> z = (1 + 2im) ⊘ (1 - 2im);\n\njulia> typeof(z)\nComplex{OurRational{Int64}}\n\njulia> typeof(z) <: Complex{<:OurRational}\ntrue\n```\n\n----------------------------------------\n\nTITLE: Preserving Initial Newline in Triple-Quoted Strings in Julia\nDESCRIPTION: Shows that if there is content (even just whitespace or another newline) on the line immediately following the opening `\"\"\"`, the initial newline is preserved. Here, the first line after `\"\"\"` is blank, resulting in a leading `\\n`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\n\nhello\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Printing and Interpreting Profiling Results - Julia\nDESCRIPTION: Shows how to print out and interpret profiling results after executing profiled code using the Profile.print() function in Julia. The snippet illustrates the hierarchical (tree) view that displays sampled call stack information and cost percentages associated with source locations. No additional dependencies are required and the code expects that the profile buffer contains recent run information. The main input is the function call Profile.print(), and the output is a formatted breakdown of the call tree and associated sample counts.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_1\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> Profile.print()\n80 ./event.jl:73; (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n 80 ./REPL.jl:97; macro expansion\n  80 ./REPL.jl:66; eval_user_input(::Any, ::Base.REPL.REPLBackend)\n   80 ./boot.jl:235; eval(::Module, ::Any)\n    80 ./<missing>:?; anonymous\n     80 ./profile.jl:23; macro expansion\n      52 ./REPL[1]:2; myfunc()\n       38 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type{B...\n        38 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr{F...\n       14 ./random.jl:278; rand\n        14 ./random.jl:277; rand\n         14 ./random.jl:366; rand\n          14 ./random.jl:369; rand\n      28 ./REPL[1]:3; myfunc()\n       28 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinear,...\n        3  ./reduce.jl:426; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\n        25 ./reduce.jl:428; mapreduce_impl(::Base.#identity, ::Base.#scalarmax, ::Array{F...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Column-Major Array Storage in Julia\nDESCRIPTION: Illustrates Julia's column-major memory layout by showing how a 2x2 `Matrix` is flattened into a `Vector` using `[:]`. The elements are ordered column by column (`[1, 3, 2, 4]`), which is important for performance when iterating over arrays.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_50\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> x = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> x[:]\n4-element Vector{Int64}:\n 1\n 3\n 2\n 4\n```\n```\n\n----------------------------------------\n\nTITLE: Handling `missing` with Logical OR (`|`) - Non-Propagation Case in Julia\nDESCRIPTION: Shows how the logical OR operator (`|`) handles `missing` based on three-valued logic. If one operand is `true`, the result is always `true`, regardless of whether the other operand is `missing`, because the outcome is certain. Thus, `missing` does not propagate in this specific case.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> true | true\ntrue\n\njulia> true | false\ntrue\n\njulia> false | true\ntrue\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> true | missing\ntrue\n\njulia> missing | true\ntrue\n```\n\n----------------------------------------\n\nTITLE: Dynamically Linking libjulia in Python using ctypes\nDESCRIPTION: Illustrates loading the Julia shared library (`libjulia`) in Python using the `ctypes` module. It highlights the necessity of the `RTLD_GLOBAL` flag for dynamic linking on some systems and shows how to define argument types for and call the `jl_init` function from Python.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> julia=CDLL('./libjulia.dylib',RTLD_GLOBAL)\n>>> julia.jl_init.argtypes = []\n>>> julia.jl_init()\n250593296\n```\n\n----------------------------------------\n\nTITLE: Converting Rationals to Floating-Point Numbers in Julia\nDESCRIPTION: Shows the use of float() to convert rational values to floating-point. The examples demonstrate identity relations, behavior for zero denominators, and type preservation. Only Julia Base is required. Inputs are rationals; outputs are floats or errors for invalid conversion.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> float(3//4)\n0.75\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> a = 1; b = 2;\n\njulia> isequal(float(a//b), a/b)\ntrue\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> a, b = 0, 0\n(0, 0)\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> float(a//b)\nERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\nStacktrace:\n[...]\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> a/b\nNaN\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> a, b = 0, -1\n(0, -1)\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> float(a//b), a/b\n(0.0, -0.0)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Macro Expansion using `macroexpand` Function in Julia\nDESCRIPTION: Uses the `macroexpand` function to reveal the expression that results from expanding the `@sayhello(\"human\")` macro call. This is useful for debugging macros by showing the exact code generated before compilation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_24\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> ex = macroexpand(Main, :(@sayhello(\"human\")) )\n:(Main.println(\"Hello, \", \"human\"))\n\njulia> typeof(ex)\nExpr\n```\n\n----------------------------------------\n\nTITLE: Type Promotion and Explicit Conversion with BigInt in Julia\nDESCRIPTION: Shows how arithmetic between Julia's primitive types and BigInt requires explicit promotion and constructors. Demonstrates underflow/overflow behaviors in primitive types versus correct value growth in BigInt. These examples need only Julia Base. Inputs are integer types, and outputs demonstrate the resulting types after operations. No automatic conversion occurs; explicit use of BigInt is mandatory for large-integer correctness.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = typemin(Int64)\n-9223372036854775808\n\njulia> x = x - 1\n9223372036854775807\n\njulia> typeof(x)\nInt64\n\njulia> y = BigInt(typemin(Int64))\n-9223372036854775808\n\njulia> y = y - 1\n-9223372036854775809\n\njulia> typeof(y)\nBigInt\n```\n\n----------------------------------------\n\nTITLE: Accessing Macro Invocation Location using `__source__` in Julia\nDESCRIPTION: Defines a macro `@__LOCATION__` that returns the implicit `__source__` argument as a `QuoteNode`. It demonstrates how to access this `LineNumberNode` object, which contains the line number (`__source__.line`) and file name (`__source__.file` as a Symbol) of the macro invocation site.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\njulia> macro __LOCATION__(); return QuoteNode(__source__); end\n@__LOCATION__ (macro with 1 method)\n\njulia> dump(\n            @__LOCATION__(\n       ))\nLineNumberNode\n  line: Int64 2\n  file: Symbol none\n```\n\n----------------------------------------\n\nTITLE: Querying First-Dimension Stride with Julia's Base Array (Julia)\nDESCRIPTION: Demonstrates how to instantiate a three-dimensional Array of random Float64 numbers and query its stride along the first dimension. Relies on Julia Base's rand and stride functions; requires no external dependencies. 'A' is a 5x7x2 array, stride(A, 1) yields 1, reflecting column-major storage. Input: none or user-defined array; Output: stride value (Int). The operation assumes the array is contiguous and mutable.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_42\n\nLANGUAGE: julia\nCODE:\n```\njulia> A = rand(5, 7, 2);\n\njulia> stride(A, 1)\n1\n```\n\n----------------------------------------\n\nTITLE: Accessing PowerShell from Julia REPL Shell Mode on Windows\nDESCRIPTION: This example provides a workaround for the Shell mode limitation on Windows by explicitly launching PowerShell. Typing `powershell` within the Julia REPL's Shell mode (`shell>`) starts an interactive PowerShell session.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\njulia> ; # upon typing ;, the prompt changes (in place) to: shell>\n\nshell> powershell\nWindows PowerShell\nCopyright (C) Microsoft Corporation. All rights reserved.\nPS C:\\Users\\elm>\n```\n\n----------------------------------------\n\nTITLE: Accessing SubArray Indices Tuple in Julia\nDESCRIPTION: Accesses the `indices` field of the previously created `SubArray` `S1`. The output displays the tuple containing the indices (`Base.Slice(Base.OneTo(2))`, `1`, `2:3`) that define the view relative to the parent array. This demonstrates how the indices used to create the view are stored within the `SubArray` object.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest subarray\njulia> S1.indices\n(Base.Slice(Base.OneTo(2)), 1, 2:3)\n```\n```\n\n----------------------------------------\n\nTITLE: Inspecting AST of a Quoted Symbol in Julia\nDESCRIPTION: Shows how the Julia parser represents a simple quoted symbol like `:x` using a `QuoteNode` object. The `dump` function reveals the internal structure, where the `value` field holds the `Symbol` itself.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_13\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> dump(Meta.parse(\":x\"))\nQuoteNode\n  value: Symbol x\n```\n\n----------------------------------------\n\nTITLE: Errors from Function Application Syntax with Parenthesized Expressions in Julia\nDESCRIPTION: Demonstrates incorrect use of juxtaposition, where a parenthesized expression or a variable is followed by another parenthesis, causing Julia to interpret the expression as a function call. The resulting error (MethodError: objects of type Int64 are not callable) shows the importance of distinguishing multiplication from function application. No dependencies beyond Julia Base. Inputs are non-function values with direct parenthesized application; output is an error message.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\njulia> (x-1)(x+1)\nERROR: MethodError: objects of type Int64 are not callable\n\njulia> x(x+1)\nERROR: MethodError: objects of type Int64 are not callable\n```\n\n----------------------------------------\n\nTITLE: Comparing with `missing` using `isless` in Julia\nDESCRIPTION: Demonstrates the behavior of the `isless` operator with `missing` values. `isless` considers `missing` to be greater than any other value, including `Inf`, but returns `false` when comparing `missing` with itself. This behavior influences sorting, placing `missing` values last.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_3\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> isless(1, missing)\ntrue\n\njulia> isless(missing, Inf)\nfalse\n\njulia> isless(missing, missing)\nfalse\n```\n\n----------------------------------------\n\nTITLE: Handling No Match Found with match in Julia\nDESCRIPTION: Provides an example of checking the return value of the `match` function. If `match` returns `nothing`, it indicates no match was found, and the code handles this case accordingly using an `if` statement. Requires a `line` variable to be defined.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_45\n\nLANGUAGE: julia\nCODE:\n```\nm = match(r\"^\\s*(?:#|$)\", line)\nif m === nothing\n    println(\"not a comment\")\nelse\n    println(\"blank or comment\")\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring a Julia Project Environment in TOML\nDESCRIPTION: This TOML snippet demonstrates how to define a Julia project using a project file with the package's name, unique identifier (UUID), and its dependencies under the `[deps]` section. Required for establishing the roots map in a Julia environment, this file is essential for package discovery and dependency management. The parameters 'name', 'uuid', and each entry in '[deps]' specify the main package and its direct dependencies; values should be replaced with actual package UUIDs relevant for the project.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\nname = \"App\"\nuuid = \"8f986787-14fe-4607-ba5d-fbff2944afa9\"\n\n[deps]\nPriv = \"ba13f791-ae1d-465a-978b-69c3ad90f72b\"\nPub  = \"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"\n```\n\n----------------------------------------\n\nTITLE: Documenting Filesystem Base Functions in Julia\nDESCRIPTION: This snippet uses Julia's doc macro to document an extensive set of filesystem functions from the Base module, including file and directory management, querying metadata, permissions, symbolic and hard links, and temporary file operations. The list is intended for API documentation and may require Julia's standard library to be available. The main parameters are file paths, functions, or data depending on the operation, and most functions interact with the operating system's file and directory structures. The expected output is the documentation for each function in Julia's doc system, and the snippet is best viewed within Julia's documentation generation tools.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/file.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.read(::String)\nBase.write(::String, ::Any)\nBase.Filesystem.pwd\nBase.Filesystem.cd(::AbstractString)\nBase.Filesystem.cd(::Function)\nBase.Filesystem.readdir\nBase.Filesystem.walkdir\nBase.Filesystem.mkdir\nBase.Filesystem.mkpath\nBase.Filesystem.hardlink\nBase.Filesystem.symlink\nBase.Filesystem.readlink\nBase.Filesystem.chmod\nBase.Filesystem.chown\nBase.RawFD\nBase.stat\nBase.Filesystem.diskstat\nBase.Filesystem.lstat\nBase.Filesystem.ctime\nBase.Filesystem.mtime\nBase.Filesystem.filemode\nBase.Filesystem.filesize\nBase.Filesystem.uperm\nBase.Filesystem.gperm\nBase.Filesystem.operm\nBase.Filesystem.cp\nBase.download\nBase.Filesystem.mv\nBase.Filesystem.rename\nBase.Filesystem.rm\nBase.Filesystem.touch\nBase.Filesystem.tempname\nBase.Filesystem.tempdir\nBase.Filesystem.mktemp(::AbstractString)\nBase.Filesystem.mktemp(::Function, ::AbstractString)\nBase.Filesystem.mktempdir(::AbstractString)\nBase.Filesystem.mktempdir(::Function, ::AbstractString)\nBase.Filesystem.isblockdev\nBase.Filesystem.ischardev\nBase.Filesystem.isdir\nBase.Filesystem.isfifo\nBase.Filesystem.isfile\nBase.Filesystem.islink\nBase.Filesystem.ismount\nBase.Filesystem.ispath\nBase.Filesystem.issetgid\nBase.Filesystem.issetuid\nBase.Filesystem.issocket\nBase.Filesystem.issticky\nBase.Filesystem.homedir\nBase.Filesystem.dirname\nBase.Filesystem.basename\nBase.Filesystem.isabspath\nBase.Filesystem.isdirpath\nBase.Filesystem.joinpath\nBase.Filesystem.abspath\nBase.Filesystem.normpath\nBase.Filesystem.realpath\nBase.Filesystem.relpath\nBase.Filesystem.expanduser\nBase.Filesystem.contractuser\nBase.Filesystem.samefile\nBase.Filesystem.splitdir\nBase.Filesystem.splitdrive\nBase.Filesystem.splitext\nBase.Filesystem.splitpath\n```\n```\n\n----------------------------------------\n\nTITLE: Annotating and Converting Array Elements - Julia\nDESCRIPTION: Demonstrates how to use type annotations and the convert function when extracting values from an Array of Any, enforcing that values conform to a specific type (Int32). Dependencies include the core Julia language. Arguments like 'a' are an Array{Any,1}, and 'x' is annotated as Int32. Shows both direct annotation and the use of convert for type conversion. Raises a runtime error if the type constraint is not satisfied.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nfunction foo(a::Array{Any,1})\n    x = a[1]::Int32\n    b = x+1\n    ...\nend\n```\n\n----------------------------------------\n\nTITLE: Per-Element aliasing with Constant Array Dimensions - Julia\nDESCRIPTION: This code analyzes escape relationships when array index and dimension are known at compile-time, allowing per-element aliasing through arrayref/arrayset. The function takes two String arguments, constructs a statically-sized Vector{Any} of length 2, and sets each entry to a SafeRef of the inputs. It returns the first element and the length. Dependencies include SafeRef and code_escapes. This precise scenario enables further optimizations (e.g., load-forwarding and scalar replacement) since aliasing can be determined per element.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\ncode_escapes((String,String)) do s, t\n    ary = Vector{Any}(undef, 2)\n    ary[1] = SafeRef(s)\n    ary[2] = SafeRef(t)\n    return ary[1], length(ary)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Generated Function Summing Multidimensional Arrays - Julia\nDESCRIPTION: This code defines a generated function mysum that computes the sum of all elements of an N-dimensional array A by dynamically generating an appropriate number of nested loops using the @nloops and @nref macros. It leverages Julia's @generated function capability to specialize code according to input array dimensionality. Dependencies are Base.Cartesian macros and a compatible type for zero(T). Input is an array A of arbitrary element type and dimension; output is the total sum s after traversing all elements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/cartesian.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n@generated function mysum(A::Array{T,N}) where {T,N}\\n    quote\\n        s = zero(T)\\n        @nloops $N i A begin\\n            s += @nref $N A i\\n        end\\n        s\\n    end\\nend\n```\n\n----------------------------------------\n\nTITLE: Extracting Real and Imaginary Parts, Conjugate, and Other Attributes from Complex Numbers in Julia\nDESCRIPTION: Shows use of built-in functions real(), imag(), conj(), abs(), abs2(), and angle() to extract properties from complex numbers. These snippets depend only on Julia Base and require a complex number input. Outputs include the real part, imaginary part, complex conjugate, magnitude, square magnitude, and phase angle in radians.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> z = 1 + 2im\n1 + 2im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> real(1 + 2im) # real part of z\n1\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> imag(1 + 2im) # imaginary part of z\n2\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> conj(1 + 2im) # complex conjugate of z\n1 - 2im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> abs(1 + 2im) # absolute value of z\n2.23606797749979\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> abs2(1 + 2im) # squared absolute value\n5\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> angle(1 + 2im) # phase angle in radians\n1.1071487177940904\n```\n\n----------------------------------------\n\nTITLE: Reading All Lines or Characters from Standard Input - Julia\nDESCRIPTION: Presents two idiomatic loops for processing every line or character in stdin: one using `eachline(stdin)` for line-by-line iteration, and one using a `while !eof(stdin)` loop with `read(stdin, Char)` for character-level input. Dependencies are Julia built-ins. Inputs are the stdin stream; outputs are processed via print statements. Intended for terminal or script workflows.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nfor line in eachline(stdin)\\n    print(\"Found $line\")\\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nwhile !eof(stdin)\\n    x = read(stdin, Char)\\n    println(\"Found: $x\")\\nend\n```\n\n----------------------------------------\n\nTITLE: Selecting Array Slices with selectdim and copy - Julia\nDESCRIPTION: Updates array slicing practices by switching from 'slicedim' to 'copy(selectdim(...))', where 'selectdim' always returns a view rather than an actual array copy. This ensures consistent, memory-efficient slicing, with copying performed only when necessary. Input: array, dimension, and index; output: view or copy of the specified slice.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_155\n\nLANGUAGE: julia\nCODE:\n```\ncopy(selectdim(A, d, i))\n```\n\n----------------------------------------\n\nTITLE: Checking if Objects are Types using Abstract `Type` in Julia\nDESCRIPTION: Demonstrates that the unparameterized `Type` serves as an abstract type whose instances are all type objects. `isa(Type{Float64}, Type)`, `isa(Float64, Type)`, and `isa(Real, Type)` all evaluate to true because the first argument in each case is a type object.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_57\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> isa(Type{Float64}, Type)\ntrue\n\njulia> isa(Float64, Type)\ntrue\n\njulia> isa(Real, Type)\ntrue\n```\n\n----------------------------------------\n\nTITLE: Distinguishing Signed Zeros with isequal - Julia\nDESCRIPTION: This code compares negative and positive zero both with '==' and 'isequal' functions. While '==' returns true, 'isequal' distinguishes them, returning false, which is crucial in some numerical applications. Inputs are -0.0 and 0.0; outputs are boolean values showing the distinction made by isequal. No additional dependencies are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\njulia> -0.0 == 0.0\ntrue\n\njulia> isequal(-0.0, 0.0)\nfalse\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Exception Types in try/catch - Julia\nDESCRIPTION: Defines sqrt_second, a function that computes the square root of the second element of x (if indexable), or of x itself, handling DomainError and BoundsError accordingly. Uses structured exception matching in the catch block. Dependencies are base Julia and sqrt; inputs can be arrays or numbers, and outputs vary according to error-handling logic.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\njulia> sqrt_second(x) = try\n           sqrt(x[2])\n       catch y\n           if isa(y, DomainError)\n               sqrt(complex(x[2], 0))\n           elseif isa(y, BoundsError)\n               sqrt(x)\n           end\n       end\nsqrt_second (generic function with 1 method)\n\njulia> sqrt_second([1 4])\n2.0\n\njulia> sqrt_second([1 -4])\n0.0 + 2.0im\n\njulia> sqrt_second(9)\n3.0\n\njulia> sqrt_second(-9)\nERROR: DomainError with -9.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\n```\n\n----------------------------------------\n\nTITLE: Array Assignment Behavior in Julia\nDESCRIPTION: In Julia, assigning an array variable `B` to `A` makes `A` refer to the same array object as `B`. Modifications to `B` will affect `A`. Use `copy()` to create an independent copy.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nA = B\n```\n\nLANGUAGE: julia\nCODE:\n```\nA = copy(B)\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Annotated Strings in Julia\nDESCRIPTION: Shows how to create a `Base.AnnotatedString`, which wraps a standard string and allows associating metadata (like `:word => :greeting` or `:face => :magenta`) with specific character ranges. It demonstrates that standard string functions like `length` and `lpad` operate on the underlying string, often preserving annotations. Concatenation using `Base.annotatedstring` or the `*` operator also preserves annotations from both operands.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_63\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> str = Base.AnnotatedString(\"hello there\",\n               [(1:5, :word, :greeting), (7:11, :label, 1)])\n\"hello there\"\n\njulia> length(str)\n11\n\njulia> lpad(str, 14)\n\"   hello there\"\n\njulia> typeof(lpad(str, 7))\nBase.AnnotatedString{String}\n\njulia> str2 = Base.AnnotatedString(\" julia\", [(2:6, :face, :magenta)])\n\" julia\"\n\njulia> Base.annotatedstring(str, str2)\n\"hello there julia\"\n\njulia> str * str2 == Base.annotatedstring(str, str2) # *-concatenation still works\ntrue\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to Julia Installer Script (Mac/Linux)\nDESCRIPTION: Demonstrates how to pass command-line arguments to the Julia installer script downloaded via curl. The '-s' flag to 'sh' reads commands from standard input, and '-- <ARGS>' separates script arguments from shell options. Replace '<ARGS>' with specific arguments like '--yes' for non-interactive mode or '--default-channel' to set the initial Julia channel.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/installation.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -fsSL https://install.julialang.org | sh -s -- <ARGS>\n```\n\n----------------------------------------\n\nTITLE: Declaring Parametric Primitive Types in Julia\nDESCRIPTION: Demonstrates the declaration of a primitive type Ptr{T} parameterized on T, with different bit sizes for 32- or 64-bit architectures. The type parameter T is not used structurally, solely as a type tag. This pattern underlies Julia's pointer type system and is critical for FFI and memory management.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_45\n\nLANGUAGE: julia\nCODE:\n```\n# 32-bit system:\nprimitive type Ptr{T} 32 end\n\n# 64-bit system:\nprimitive type Ptr{T} 64 end\n```\n\n----------------------------------------\n\nTITLE: LaTeX and Unicode Symbol Input via Tab Completion - Julia-REPL\nDESCRIPTION: These snippets show how to input Unicode math and special symbols via LaTeX shorthands and tab completion in the Julia REPL, including inside strings and identifiers. No dependencies beyond the standard Julia REPL; supported out-of-the-box. Inputs start with a backslash LaTeX command, followed by [TAB], producing the Unicode equivalent.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_18\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> \\pi[TAB]\njulia> π\nπ = 3.1415926535897...\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> e\\_1[TAB] = [1,0]\njulia> e₁ = [1,0]\n2-element Vector{Int64}:\n 1\n 0\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> e\\^1[TAB] = [1 0]\njulia> e¹ = [1 0]\n1×2 Matrix{Int64}:\n 1  0\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> \\sqrt[TAB]2     # √ is equivalent to the sqrt function\njulia> √2\n1.4142135623730951\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> \\hbar[TAB](h) = h / 2\\pi[TAB]\njulia> ħ(h) = h / 2π\nħ (generic function with 1 method)\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> \\h[TAB]\n\\hat              \\hermitconjmatrix  \\hkswarow          \\hrectangle\n\\hatapprox        \\hexagon           \\hookleftarrow     \\hrectangleblack\n\\hbar             \\hexagonblack      \\hookrightarrow    \\hslash\n\\heartsuit        \\hksearow          \\house             \\hspace\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> α=\"\\alpha[TAB]\"   # LaTeX completion also works in strings\njulia> α=\"α\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating Method Ambiguity in Julia\nDESCRIPTION: Presents a common scenario causing method ambiguity in Julia. Two methods for function `f` are defined, one specializing the second argument (`y::Int`) and the other specializing the first (`x::Int`). Calling `f` with two `Int` arguments becomes ambiguous.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\nf(x, y::Int) = 1\nf(x::Int, y) = 2\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Julia Cmd Objects via `env`\nDESCRIPTION: Illustrates setting environment variables for a command run via a Julia `Cmd` object using the `env` keyword argument. This argument accepts a collection (like a Tuple or Dict) mapping variable names to values. The specified environment variables are made available to the executed command (`sh -c \"echo foo \\$HOWLONG\"`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\n# jldoctest\njulia> run(Cmd(`sh -c \"echo foo \\$HOWLONG\"`, env=(\"HOWLONG\" => \"ever!\",)));\nfoo ever!\n```\n\n----------------------------------------\n\nTITLE: Using Raw Strings for LaTeX in Julia Docstrings\nDESCRIPTION: This snippet shows an alternative method for including LaTeX in Julia docstrings using the `raw` string macro (`raw\"...\"`) with the `@doc` macro. This avoids the need to escape backslashes.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n@doc raw\"``\\LaTeX`` syntax in a docstring.\" functionname\n```\n\n----------------------------------------\n\nTITLE: Array Comparison Involving NaN - Julia\nDESCRIPTION: Shows how Julia's '==' operator handles arrays with NaN elements, resulting in false even for elementwise-identical arrays. This behavior follows from NaN comparison rules. Julia base language is the only dependency. The input is two arrays with identical NaN placements; the output is a boolean 'false'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> [1 NaN] == [1 NaN]\nfalse\n```\n\n----------------------------------------\n\nTITLE: Using a Custom TestSet with @testset Macro in Julia\nDESCRIPTION: Illustrates how to invoke a test set using the custom `CustomTestSet` type defined previously. It demonstrates passing options (`foo=4`) to the custom testset constructor via the `@testset` macro and shows how nested testsets inherit the type but not necessarily the specific options.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\n@testset CustomTestSet foo=4 \"custom testset inner 2\" begin\n    # this testset should inherit the type, but not the argument.\n    @testset \"custom testset inner\" begin\n        @test true\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Broadcast Style for a Type in Julia\nDESCRIPTION: Illustrates how to define a custom broadcast style (`MyStyle`) inheriting from `Broadcast.BroadcastStyle` and associate it with a custom type (`MyType`) by defining a `Base.BroadcastStyle` method. This mechanism allows developers to override default broadcasting behavior, potentially controlling the output type and implementation strategy for operations involving `MyType`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nstruct MyStyle <: Broadcast.BroadcastStyle end\nBase.BroadcastStyle(::Type{<:MyType}) = MyStyle()\n```\n```\n\n----------------------------------------\n\nTITLE: Example Package Directory Structure for Julia\nDESCRIPTION: Illustrates the file and directory layout for a sample Julia package directory containing packages Aardvark, Bobcat, Cobra, and Dingo. Shows the placement of source files (`src/*.jl`) and configuration files (`Project.toml`) which determine dependencies and UUIDs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nAardvark/\\n    src/Aardvark.jl:\\n        import Bobcat\\n        import Cobra\\n\\nBobcat/\\n    Project.toml:\\n        [deps]\\n        Cobra = \\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\"\\n        Dingo = \\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"\\n\\n    src/Bobcat.jl:\\n        import Cobra\\n        import Dingo\\n\\nCobra/\\n    Project.toml:\\n        uuid = \\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\"\\n        [deps]\\n        Dingo = \\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"\\n\\n    src/Cobra.jl:\\n        import Dingo\\n\\nDingo/\\n    Project.toml:\\n        uuid = \\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"\\n\\n    src/Dingo.jl:\\n        # no imports\n```\n\n----------------------------------------\n\nTITLE: Using a Standard Library Module in Julia\nDESCRIPTION: Provides a simple example of loading a standard library module (`Test`) that ships with Julia. These modules behave like packages but do not require explicit installation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nusing Test\n```\n\n----------------------------------------\n\nTITLE: Orthogonal Design using Wrapper Function in Julia\nDESCRIPTION: Demonstrates simplifying multi-argument dispatch using orthogonal design. Instead of multiple `f` methods, a core `f(x::A, y::A)` is defined, and a generic `f(x, y)` calls a helper function `g` to convert arguments to type `A` before calling the core method.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_44\n\nLANGUAGE: julia\nCODE:\n```\nf(x::A, y::A) = ...\nf(x, y) = f(g(x), g(y))\n```\n\n----------------------------------------\n\nTITLE: Combining `using` and `import` for a Module in Julia\nDESCRIPTION: Shows the combined effect of using both `using` and `import` for the same module (`NiceStuff`). `using .NiceStuff` brings exported names and the module name into scope, while `import .NiceStuff: nice` specifically allows adding methods to the `nice` function without qualification.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_16\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using .NiceStuff         # exported names and the module name\n\njulia> import .NiceStuff: nice  # allows adding methods to unqualified functions\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Macro Illustrating Parse-Time vs. Runtime Execution\nDESCRIPTION: Defines a macro `@twostep` that demonstrates the two stages of macro execution. The `println` call inside the macro definition executes at parse time (when the macro is expanded), while the `println` call within the returned quoted expression executes at runtime (when the generated code is evaluated).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_26\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> macro twostep(arg)\n           println(\"I execute at parse time. The argument is: \", arg)\n           return :(println(\"I execute at runtime. The argument is: \", $arg))\n       end\n@twostep (macro with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Alias Analysis Limitation with Non-constant Array Indices - Julia\nDESCRIPTION: This example illustrates the limitations of EscapeAnalysis when array indices are determined dynamically (e.g., within loops or control-flow). The function receives two Strings, initializes a two-element Any array, sets elements to SafeRef-wrapped arguments, then returns the first element and the array's length. Because the indices involved may stem from phi nodes or other non-constant sources, the analysis more conservatively propagates escape information to both involved elements. Requires SafeRef and code_escapes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\ncode_escapes((String,String)) do s, t\n    ary = Any[nothing, nothing]\n    ary[1] = SafeRef(s)\n    ary[2] = SafeRef(t)\n    return ary[1], length(ary)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Function and Inspecting LLVM Code for Different Struct Types\nDESCRIPTION: Defines a simple function `func` operating on `MyType`. Suggests using `code_llvm` to compare the generated low-level machine code when `func` is called with a concretely parameterized `MyType{Float64}` versus an abstractly parameterized `MyType{AbstractFloat}`. The concretely typed version allows the compiler to generate shorter, faster code as no runtime type checks are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nfunc(m::MyType) = m.a+1\n```\n\nLANGUAGE: julia\nCODE:\n```\ncode_llvm(func, Tuple{MyType{Float64}})\ncode_llvm(func, Tuple{MyType{AbstractFloat}})\n```\n\n----------------------------------------\n\nTITLE: Repeating Strings and Joining Array Elements in Julia\nDESCRIPTION: Illustrates two common string operations: `repeat(str, n)` concatenates the string `str` with itself `n` times. `join(array, delim, last_delim)` concatenates elements of a string array using `delim` between elements and `last_delim` before the final element.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_41\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> repeat(\".:Z:.\", 10)\n\".:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:..:Z:.\"\n\njulia> join([\"apples\", \"bananas\", \"pineapples\"], \", \", \" and \")\n\"apples, bananas and pineapples\"\n```\n\n----------------------------------------\n\nTITLE: Example Output of Signal-Triggered CPU Profiling in Julia\nDESCRIPTION: This shows the typical output when CPU profiling is triggered on a running Julia process using a signal (`SIGINFO` on macOS/FreeBSD, `SIGUSR1` on Linux). It includes an initial stack trace at the signal time, a notification that a profile is being collected (default 1 second), and finally the profile report grouped by thread and task.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Profile/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> foo()\n##== the user sends a trigger while foo is running ==##\nload: 2.53  cmd: julia 88903 running 6.16u 0.97s\n\n======================================================================================\nInformation request received. A stacktrace will print followed by a 1.0 second profile\n======================================================================================\n\nsignal (29): Information request: 29\n__psynch_cvwait at /usr/lib/system/libsystem_kernel.dylib (unknown line)\n_pthread_cond_wait at /usr/lib/system/libsystem_pthread.dylib (unknown line)\n...\n\n======================================================================\nProfile collected. A report will print if the Profile module is loaded\n======================================================================\n\nOverhead ╎ [+additional indent] Count File:Line; Function\n=========================================================\nThread 1 Task 0x000000011687c010 Total snapshots: 572. Utilization: 100%\n   ╎147 @Base/client.jl:506; _start()\n       ╎ 147 @Base/client.jl:318; exec_options(opts::Base.JLOptions)\n...\n\nThread 2 Task 0x0000000116960010 Total snapshots: 572. Utilization: 0%\n   ╎572 @Base/task.jl:587; task_done_hook(t::Task)\n      ╎ 572 @Base/task.jl:879; wait()\n...\n```\n\n----------------------------------------\n\nTITLE: Defining and Instantiating Julia Struct with Untyped Field\nDESCRIPTION: Defines a struct `MyAmbiguousType` with an untyped field `a`. This allows `a` to hold values of any type, but prevents the compiler from optimizing code involving this struct effectively, as the type of `a` is not known statically. Instantiating it with different types (`String`, `Int`) results in objects of the same struct type (`MyAmbiguousType`), demonstrating the ambiguity.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_12\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct MyAmbiguousType\n           a\n       end\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> b = MyAmbiguousType(\"Hello\")\nMyAmbiguousType(\"Hello\")\n\njulia> c = MyAmbiguousType(17)\nMyAmbiguousType(17)\n\njulia> typeof(b)\nMyAmbiguousType\n\njulia> typeof(c)\nMyAmbiguousType\n```\n\n----------------------------------------\n\nTITLE: Standard Primitive Types Declaration - Julia\nDESCRIPTION: This code block illustrates the language-level definition of Julia's standard primitive types, such as floating-point numbers, booleans, characters, and (signed/unsigned) integers of various bit sizes. Declarations specify the type name, supertype, and storage size, forming the low-level representation of fundamental numeric and character types in Julia. No external dependencies are required. Inputs and outputs are as per the 'primitive type' declaration; most types must be in multiples of 8 bits.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nprimitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end\n\nprimitive type Bool <: Integer 8 end\nprimitive type Char <: AbstractChar 32 end\n\nprimitive type Int8    <: Signed   8 end\nprimitive type UInt8   <: Unsigned 8 end\nprimitive type Int16   <: Signed   16 end\nprimitive type UInt16  <: Unsigned 16 end\nprimitive type Int32   <: Signed   32 end\nprimitive type UInt32  <: Unsigned 32 end\nprimitive type Int64   <: Signed   64 end\nprimitive type UInt64  <: Unsigned 64 end\nprimitive type Int128  <: Signed   128 end\nprimitive type UInt128 <: Unsigned 128 end\n```\n\n----------------------------------------\n\nTITLE: Integer Literals and Domain Errors in Julia\nDESCRIPTION: In Julia, literal numbers without a decimal point (e.g., `42`) are integers. Operations expecting floating-point numbers might throw a domain error if given integers where the result is not representable as an integer (e.g., negative integer powers).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n42 # Integer literal\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> a = -1; 2^a\nERROR: DomainError with -1.0:\nExponentiation yielding a complex result requires a complex argument.\nReplace x^y with complex(x)^y, Complex{Real}(x)^y, or similar.\n```\n\n----------------------------------------\n\nTITLE: Evaluating and Invoking New Methods with World Age Considerations in Julia\nDESCRIPTION: Explores world age behavior by defining and attempting to invoke a new function 'newfun' within 'tryeval', illustrating why immediate invocation fails due to Julia's method visibility constraints. Demonstrates how @eval creates a method visible in a newer world, and shows how future REPL calls can access the new method. Also presents the correct pattern using '@invokelatest' for immediate invocation of newly defined methods. Depends on Julia's Tasks, world age tracking, and 'Base.@invokelatest'; inputs are none, outputs depend on function definition visibility in the current runtime context.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nfunction tryeval()\n    @eval newfun() = 1\n    newfun()\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\ntryeval()\nnewfun()\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction tryeval2()\n    @eval newfun2() = 2\n    @invokelatest newfun2()\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\ntryeval2()\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug-Level Messages with ConsoleLogger (Julia REPL)\nDESCRIPTION: Demonstrates creating a `ConsoleLogger` that outputs log messages with a level of `Debug` or higher to the standard error stream (`stderr`). It shows how to apply this logger temporarily for a block of code using `with_logger` and how to set it as the global logger using `global_logger`.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Logging/docs/src/index.md#_snippet_3\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Logging\n\n# Create a ConsoleLogger that prints any log messages with level >= Debug to stderr\njulia> debuglogger = ConsoleLogger(stderr, Logging.Debug)\n\n# Enable debuglogger for a task\njulia> with_logger(debuglogger) do\n           @debug \"a context specific log message\"\n       end\n\n# Set the global logger\njulia> global_logger(debuglogger)\n```\n\n----------------------------------------\n\nTITLE: Type Conversion in Function Arguments - julia\nDESCRIPTION: Shows contrasting approaches for handling argument types in functions: converting types inside the function versus requiring the correct type as arguments. The recommended idiomatic Julia style is for the caller to ensure correct types before calling the function, thereby clarifying intent and simplifying the function definition. Inputs: variables x and y, expected to be convertible to Int; outputs: result of foo function. No external dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nfunction foo(x, y)\n    x = Int(x); y = Int(y)\n    ...\nend\nfoo(x, y)\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction foo(x::Int, y::Int)\n    ...\nend\nfoo(Int(x), Int(y))\n```\n\n----------------------------------------\n\nTITLE: Implementing Test.get_test_counts for Custom TestSets in Julia\nDESCRIPTION: Provides an implementation of the `Test.get_test_counts` method for the `CustomTestSet` type. This function iterates through the results stored in the custom testset, aggregates counts of different result types (Pass, Fail, Error, Broken), handles cumulative counts from nested testsets, formats the duration, and returns a `Test.TestCounts` object. This allows the custom testset's results to be correctly reported within the broader test summary.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nusing Test: AbstractTestSet, Pass, Fail, Error, Broken, get_test_counts, TestCounts, format_duration\n\nfunction Test.get_test_counts(ts::CustomTestSet)\n    passes, fails, errors, broken = 0, 0, 0, 0\n    # cumulative results\n    c_passes, c_fails, c_errors, c_broken = 0, 0, 0, 0\n\n    for t in ts.results\n        # count up results\n        isa(t, Pass)   && (passes += 1)\n        isa(t, Fail)   && (fails  += 1)\n        isa(t, Error)  && (errors += 1)\n        isa(t, Broken) && (broken += 1)\n        # handle children\n        if isa(t, AbstractTestSet)\n            tc = get_test_counts(t)::TestCounts\n            c_passes += tc.passes + tc.cumulative_passes\n            c_fails  += tc.fails + tc.cumulative_fails\n            c_errors += tc.errors + tc.cumulative_errors\n            c_broken += tc.broken + tc.cumulative_broken\n        end\n    end\n    # get a duration, if we have one\n    duration = format_duration(ts)\n    return TestCounts(true, passes, fails, errors, broken, c_passes, c_fails, c_errors, c_broken, duration)\nend\n```\n\n----------------------------------------\n\nTITLE: Handling MethodError for Invalid supertype Calls in Julia\nDESCRIPTION: Illustrates that calling supertype on unsupported type objects (like Union types) raises a MethodError. This ensures type hierarchy traversal is only valid on applicable DataTypes. Useful for understanding and debugging method dispatch errors.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_67\n\nLANGUAGE: julia\nCODE:\n```\nsupertype(Union{Float64,Int64})\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Internals and Compiler-Related Functions/Macros\nDESCRIPTION: This block uses the `@docs` directive to list functions and macros related to Julia's internals, garbage collection, and compilation process. It includes garbage collection control (`GC.gc`, `GC.enable`, `GC.@preserve`), metaprogramming tools (`Meta.lower`, `Meta.parse`, `QuoteNode`), code introspection (`macroexpand`, `code_lowered`, `code_typed`), and precompilation utilities (`precompile`, `jit_total_bytes`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.GC.gc\nBase.GC.enable\nBase.GC.@preserve\nBase.GC.safepoint\nBase.GC.enable_logging\nBase.GC.logging_enabled\nMeta.lower\nMeta.@lower\nMeta.parse(::AbstractString, ::Int)\nMeta.parse(::AbstractString)\nMeta.ParseError\nCore.QuoteNode\nBase.macroexpand\nBase.@macroexpand\nBase.@macroexpand1\nBase.code_lowered\nBase.code_typed\nBase.precompile\nBase.jit_total_bytes\n```\n```\n\n----------------------------------------\n\nTITLE: Viewing S-Expression Forms with Meta.show_sexpr in Julia\nDESCRIPTION: Utilizes Meta.show_sexpr to render an Expr as an S-expression tuple, which is particularly familiar for users with Lisp backgrounds. This is handy for both learning and debugging metaprogramming code, by exposing the raw structure. Input: Expr; output: tuple representation as text.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> Meta.show_sexpr(ex3)\n(:call, :/, (:call, :+, 4, 4), 2)\n```\n\n----------------------------------------\n\nTITLE: Function Composition Equivalent to Piping in Julia\nDESCRIPTION: Demonstrates the function composition equivalent of the previous piping example. `(sqrt ∘ sum)(1:10)` achieves the same result as `1:10 |> sum |> sqrt` by first composing `sqrt` and `sum`, then applying the composed function to `1:10`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_37\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> (sqrt ∘ sum)(1:10)\n7.416198487095663\n```\n\n----------------------------------------\n\nTITLE: Case-sensitive Tab Completion in Julia REPL - Julia-REPL\nDESCRIPTION: Demonstrates that REPL tab completion in Julia is case sensitive, producing different sets of completions for lowercase and capitalized prefixes. No external dependencies are required, and usage is strictly by initiating completions within the interactive environment. Input consists of partial, case-sensitive names.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_17\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> stri[TAB]\nstride     strides     string      strip\n\njulia> Stri[TAB]\nStridedArray    StridedMatrix    StridedVecOrMat  StridedVector    String\n```\n\n----------------------------------------\n\nTITLE: Multiplying with Boolean Values in Julia - Julia\nDESCRIPTION: This snippet illustrates multiplication with the Boolean value false (0) and special floating-point values NaN and Inf. In Julia, multiplying by false results in a strong zero (0.0), preventing potential NaN propagation. Dependencies include Julia REPL and knowledge of floating-point representations (NaN, Inf). The output is always 0.0 for such products.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> NaN * false\n0.0\n\njulia> false * Inf\n0.0\n```\n\n----------------------------------------\n\nTITLE: Problematic Dispatch on Abstract Container Element Type in Julia\nDESCRIPTION: Shows an example method signature that dispatches on the element type (`Date`) of an abstract container (`AbstractArray`). This pattern is discouraged as it often leads to ambiguities when combined with methods dispatching on specific container types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_48\n\nLANGUAGE: julia\nCODE:\n```\n-(A::AbstractArray{T}, b::Date) where {T<:Date}\n```\n\n----------------------------------------\n\nTITLE: Removing a Julia Object Reference from Global IdDict in C\nDESCRIPTION: Demonstrates how to remove a reference (e.g., the wrapped `rvar` from the previous example) from the global `IdDict` (`refs`) used for GC protection. This is done by calling the Julia `delete!` function via `jl_call2`. Once removed and if no other references exist, the object can be garbage collected.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_20\n\nLANGUAGE: c\nCODE:\n```\njl_function_t* delete = jl_get_function(jl_base_module, \"delete!\");\njl_call2(delete, refs, rvar);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Per-Iteration Scope in Julia `for` Loops\nDESCRIPTION: Illustrates that variables introduced within a Julia `for` loop body or as iteration variables (`j` in this case) are freshly allocated for each iteration, behaving as if the loop body were enclosed in a `let` block. Closures created in different iterations capture distinct instances of the iteration variable `j`, leading to `Fs[1]()` returning 1 and `Fs[2]()` returning 2.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_23\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> Fs = Vector{Any}(undef, 2);\n\njulia> for j = 1:2\n           Fs[j] = ()->j\n       end\n\njulia> Fs[1]()\n1\n\njulia> Fs[2]()\n2\n```\n```\n\n----------------------------------------\n\nTITLE: Efficiently Retrieving Multiple Date Fields with Compound Methods in Julia\nDESCRIPTION: Demonstrates methods for extracting tuples of related fields (year, month, day) from a Date in a single operation. Using these compound accessors is more efficient than multiple individual field retrievals. The only dependency is the Dates module.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> Dates.yearmonth(t)\n(2014, 1)\n\njulia> Dates.monthday(t)\n(1, 31)\n\njulia> Dates.yearmonthday(t)\n(2014, 1, 31)\n```\n\n----------------------------------------\n\nTITLE: Importing Julia Packages\nDESCRIPTION: Illustrates package loading using `import X`. This statement loads the package identified as `X` within the current project's context (determined by project/manifest files and UUIDs) and makes the resulting module available under the name `X` in the importing module. The package is loaded only once per Julia session, even if imported multiple times.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nimport X\n```\n\n----------------------------------------\n\nTITLE: Representing Advection Kernel Update Rule in Julia-like Syntax\nDESCRIPTION: Shows the mathematical update rule for a simple advection kernel, often implemented in parallel computing scenarios. The value of element `q[i,j]` at time `t+1` is computed based on its value at time `t` and the corresponding value in array `u` at time `t`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nq[i,j,t+1] = q[i,j,t] + u[i,j,t]\n```\n\n----------------------------------------\n\nTITLE: Selective Destructuring Assignment (Ignored Elements) - Julia\nDESCRIPTION: Shows usage of underscores '_' to ignore certain outputs during destructuring assignment from an iterator. This is a convention for variables that are intentionally not used, improving code clarity. Only Julia Base is required. Input is an iterable; output demonstrates extracting only the needed element.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_20\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> _, _, _, d = 1:10\n1:10\n\njulia> d\n4\n```\n\n----------------------------------------\n\nTITLE: Parsing TOML String Data in Julia\nDESCRIPTION: Demonstrates how to parse a string containing TOML formatted data into a Julia Dictionary using the `TOML.parse` function from the `TOML` standard library. The input is a multiline string representing a TOML structure, and the output is a `Dict{String, Any}`.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/TOML/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> using TOML\n\njulia> data = \"\"\"\n           [database]\n           server = \"192.168.1.1\"\n           ports = [ 8001, 8001, 8002 ]\n       \"\"\" fraudsters;\n\njulia> TOML.parse(data)\nDict{String, Any} with 1 entry:\n  \"database\" => Dict{String, Any}(\"server\"=>\"192.168.1.1\", \"ports\"=>[8001, 8001…\n```\n\n----------------------------------------\n\nTITLE: Result of Regex String Literal Macro Expansion in Julia\nDESCRIPTION: This Julia code represents the object created by the `@r_str` macro expansion for the literal `r\"^\\s*(?:#|$)\"`. It's a `Regex` object initialized with the pattern string, demonstrating the compile-time evaluation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_56\n\nLANGUAGE: julia\nCODE:\n```\nRegex(\"^\\\\s*(?:#|\\$)\")\n```\n\n----------------------------------------\n\nTITLE: Resolving Method Ambiguity with a More Specific Method in Julia\nDESCRIPTION: Shows the standard way to resolve the method ambiguity presented previously. A third, more specific method `f(x::Int, y::Int)` is defined, which explicitly handles the case where both arguments are `Int`, thus resolving the ambiguity.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_39\n\nLANGUAGE: julia\nCODE:\n```\nf(x::Int, y::Int) = 3\n```\n\n----------------------------------------\n\nTITLE: Accessing C Global Variables via cglobal in Julia REPL\nDESCRIPTION: Demonstrates the use of cglobal to retrieve a pointer to a global variable (here, errno) from a native library (e.g., libc) in Julia. The snippet is intended for interactive REPL use, returning a pointer (Ptr{Int32}) to the requested global variable. Be cautious: the location and usage of system symbols like errno may vary, and using cglobal on such symbols can have platform-specific effects or show unexpected pointers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\njulia> cglobal((:errno, :libc), Int32)\nPtr{Int32} @0x00007f418d0816b8\n```\n\n----------------------------------------\n\nTITLE: Launching a 32-bit Ubuntu Environment for Julia Build - Shell - Shell\nDESCRIPTION: Uses Docker shell commands to pull and run a 32-bit Ubuntu container, suitable for compiling and debugging 32-bit Julia builds on a 64-bit host. Requires Docker to be installed and running. Commands include pulling the container and launching a bash session; expected output is an interactive shell in a fresh 32-bit userland. No arguments needed; use 'exit' to leave the session.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_22\n\nLANGUAGE: sh\nCODE:\n```\n$ docker pull i386/ubuntu\n$ docker run --platform i386 -i -t i386/ubuntu /bin/bash\n```\n\n----------------------------------------\n\nTITLE: Using Numeric Literal Coefficients and Juxtaposition in Expressions - Julia\nDESCRIPTION: This code snippet illustrates how Julia interprets numeric literal coefficients (e.g., '2x') and their precedence over binary operations, especially exponents. Shows how expressions like '2x^2' and '2^2x' are parsed and evaluated in Julia, yielding different results due to precedence rules. Inputs are assignments to variable x; outputs are resulting numeric evaluations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = 3; 2x^2\n18\n\njulia> x = 3; 2^2x\n64\n```\n\n----------------------------------------\n\nTITLE: Defining and Profiling a Julia Function - Julia\nDESCRIPTION: Defines a test function that generates a 200x200x400 random array and finds its maximum, then demonstrates running and profiling it with Julia's built-in profiling tools. The examples assume that packages like Profile are readily available and that code is executed at the Julia REPL prompt. Inputs are provided interactively, output is generated as profile statistics or values, and the approach does not require any external dependencies beyond the standard Julia library. Limitations include the need for code to be run at the REPL and adherence to proper environment setup.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_0\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> function myfunc()\n           A = rand(200, 200, 400)\n           maximum(A)\n       end\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> myfunc() # run once to force compilation\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Profile\n\njulia> @profile myfunc()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Arithmetic Operators in Julia - Julia\nDESCRIPTION: This snippet demonstrates basic arithmetic operations in Julia, showcasing addition, subtraction, and a combination of multiplication and division. It requires Julia to be installed and can be run in the Julia REPL. Each expression outputs the result of the arithmetic, illustrating the syntax and behavior of Julia's arithmetic operators; all operands are numeric literals and results are of numeric type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1 + 2 + 3\n6\n\njulia> 1 - 2\n-1\n\njulia> 3*2/12\n0.5\n```\n\n----------------------------------------\n\nTITLE: Illustrating Local Scope within REPL `for` Loop (Julia)\nDESCRIPTION: Demonstrates soft scope in a Julia REPL `for` loop using `jldoctest`. Since the global variable `x` is not defined before the loop, the assignment `x = \"hello\"` creates a new variable `x` local to the loop's scope. Consequently, attempting to access `x` outside the loop results in an `UndefVarError` because it remains undefined in the global scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_10\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for i = 1:3\n           x = \"hello\" # new local\n           println(x)\n       end\nhello\nhello\nhello\n\njulia> x\nERROR: UndefVarError: `x` not defined in `Main`\n```\n\n----------------------------------------\n\nTITLE: Writing Log Events to a File using SimpleLogger (Julia REPL)\nDESCRIPTION: Illustrates how to redirect log messages to a file. It involves opening a file, creating a `SimpleLogger` associated with the file's IO stream, using `with_logger` for task-specific logging, flushing the buffer, setting the logger globally with `global_logger`, logging another message, and finally closing the file stream.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Logging/docs/src/index.md#_snippet_2\n\nLANGUAGE: julia-repl\nCODE:\n```\n# Load the logging module\njulia> using Logging\n\n# Open a textfile for writing\njulia> io = open(\"log.txt\", \"w+\")\nIOStream(<file log.txt>)\n\n# Create a simple logger\njulia> logger = SimpleLogger(io)\nSimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())\n\n# Log a task-specific message\njulia> with_logger(logger) do\n           @info(\"a context specific log message\")\n       end\n\n# Write all buffered messages to the file\njulia> flush(io)\n\n# Set the global logger to logger\njulia> global_logger(logger)\nSimpleLogger(IOStream(<file log.txt>), Info, Dict{Any,Int64}())\n\n# This message will now also be written to the file\njulia> @info(\"a global log message\")\n\n# Close the file\njulia> close(io)\n```\n\n----------------------------------------\n\nTITLE: Executing Shell Commands Explicitly in Julia\nDESCRIPTION: Shows how to execute a complex shell command, including redirection (`>`), by invoking the shell (`sh -c`) via Julia's `run` function. This approach interacts directly with the operating system shell but is generally discouraged in favor of Julia's native `pipeline` function for better portability, speed, and error handling.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nrun(`sh -c \"ls > files.txt\"`)\n```\n\n----------------------------------------\n\nTITLE: Constructing the Paths Map to Package Entry Points in Julia\nDESCRIPTION: This Julia dictionary maps (UUID, Symbol) pairs to the absolute file paths of each package's entry point. It is dynamically determined based on manifest information, available depot paths, and filesystem checks. Each dictionary entry gives the main module's source file path for each package in the environment, with the required keys being package UUIDs and names. This map enables Julia's package loader to locate entry points for both vendored and installed packages.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\npaths = Dict(\n    # Priv \\u2013 the private one:\n    (UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\"), :Priv) =>\n        # relative entry-point inside `App` repo:\n        \"/home/me/projects/App/deps/Priv/src/Priv.jl\",\n    # Priv \\u2013 the public one:\n    (UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"), :Priv) =>\n        # package installed in the system depot:\n        \"/usr/local/julia/packages/Priv/HDkr/src/Priv.jl\",\n    # Pub:\n    (UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"), :Pub) =>\n        # package installed in the user depot:\n        \"/home/me/.julia/packages/Pub/oKpw/src/Pub.jl\",\n    # Zebra:\n    (UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"), :Zebra) =>\n        # package installed in the system depot:\n        \"/usr/local/julia/packages/Zebra/me9k/src/Zebra.jl\",\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Integer Literals in Julia\nDESCRIPTION: Demonstrates how standard integer literals are represented in Julia. The code shows simple integer values being interpreted directly.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> 1\n1\n\njulia> 1234\n1234\n```\n```\n\n----------------------------------------\n\nTITLE: Iterating Over a Julia Channel using a for Loop\nDESCRIPTION: Demonstrates iterating over a `Channel` using a `for` loop. A new `Channel` is created with the `producer` function (defined previously) bound to it. The `for` loop automatically calls `take!` on the channel in each iteration, assigning the received value to `x` and executing the loop body (printing the value). The loop continues until the channel is closed, which happens automatically when the bound producer task finishes execution.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/asynchronous-programming.md#_snippet_4\n\nLANGUAGE: jldoctest producer\nCODE:\n```\njulia> for x in Channel(producer)\n           println(x)\n       end\nstart\n2\n4\n6\n8\nstop\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Julia `let` Block Scope and Variable Shadowing\nDESCRIPTION: Illustrates using a `let` block to introduce multiple local variables (`x`, `z`) in Julia. The local `x` (value 1) shadows the global `x` (value -1). Accessing the global `y` is allowed within the `let` block. Attempting to print the local `z` before it has been assigned a value results in an `UndefVarError` because `z` is local to the `let` block but uninitialized.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_18\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> x, y, z = -1, -1, -1;\n\njulia> let x = 1, z\n           println(\"x: $x, y: $y\") # x is local variable, y the global\n           println(\"z: $z\") # errors as z has not been assigned yet but is local\n       end\nx: 1, y: -1\nERROR: UndefVarError: `z` not defined in local scope\n```\n```\n\n----------------------------------------\n\nTITLE: Overloading Property Access and Mutation for a Custom Type in Julia\nDESCRIPTION: Overrides 'propertynames', 'getproperty', and 'setproperty!' for the Point struct to expose 'x' and 'y' as virtual properties, while still allowing access to original storage fields ('r' and 'ϕ'). Handles custom logic for both retrieval and mutation, including updating the underlying polar coordinates when properties are set in Cartesian form. Requires standard Julia functions (cos, sin, atan, sqrt) and the modified Point definition. Inputs include property names and values; outputs computed or updated field values, returning the assigned value for mutation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\nBase.propertynames(::Point, private::Bool=false) = private ? (:x, :y, :r, :ϕ) : (:x, :y)\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction Base.getproperty(p::Point, s::Symbol)\n    if s === :x\n        return getfield(p, :r) * cos(getfield(p, :ϕ))\n    elseif s === :y\n        return getfield(p, :r) * sin(getfield(p, :ϕ))\n    else\n        # This allows accessing fields with p.r and p.ϕ\n        return getfield(p, s)\n    end\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction Base.setproperty!(p::Point, s::Symbol, f)\n    if s === :x\n        y = p.y\n        setfield!(p, :r, sqrt(f^2 + y^2))\n        setfield!(p, :ϕ, atan(y, f))\n        return f\n    elseif s === :y\n        x = p.x\n        setfield!(p, :r, sqrt(x^2 + f^2))\n        setfield!(p, :ϕ, atan(f, x))\n        return f\n    else\n        # This allow modifying fields with p.r and p.ϕ\n        return setfield!(p, s, f)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Annotating Global Variables with :: for Type Stability in Julia\nDESCRIPTION: This code demonstrates using type annotations on global variables in Julia (version 1.8 and later) to ensure type stability. Assigning an incompatible type (e.g., Float to an Int-annotated variable) results in an error. It also shows how attempting an incompatible assignment inside a function using global will trigger an error at runtime. No extra dependencies are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> x::Int = 10\n10\n\njulia> x = 3.5\nERROR: InexactError: Int64(3.5)\n\njulia> function foo(y)\n           global x = 15.8    # throws an error when foo is called\n           return x + y\n       end\nfoo (generic function with 1 method)\n\njulia> foo(10)\nERROR: InexactError: Int64(15.8)\n```\n\n----------------------------------------\n\nTITLE: Defining an Inner Constructor with Invariant Checking in Julia\nDESCRIPTION: Defines a Julia `struct` named `OrderedPair` with fields `x` and `y` of type `Real`. It includes an inner constructor that enforces the invariant `x <= y`. If `x > y`, it throws an error; otherwise, it uses the special `new` function to create and return the object.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_3\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct OrderedPair\n           x::Real\n           y::Real\n           OrderedPair(x,y) = x > y ? error(\"out of order\") : new(x,y)\n       end\n```\n\n----------------------------------------\n\nTITLE: Illustrating Strided vs. Non-Strided Arrays in Julia\nDESCRIPTION: Provides examples of Julia array types and views, classifying them as strided or non-strided based on their memory layout. Strided arrays have elements stored with fixed memory strides, which is necessary for leveraging efficient BLAS and LAPACK routines. Non-strided examples include ranges (which have no underlying storage) and views created with non-contiguous indices.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\n```julia\n1:5   # not strided (there is no storage associated with this array.)\nVector(1:5)  # is strided with strides (1,)\nA = [1 5; 2 6; 3 7; 4 8]  # is strided with strides (1,4)\nV = view(A, 1:2, :)   # is strided with strides (1,4)\nV = view(A, 1:2:3, 1:2)   # is strided with strides (2,4)\nV = view(A, [1,2,4], :)   # is not strided, as the spacing between rows is not fixed.\n```\n```\n\n----------------------------------------\n\nTITLE: Combining Dot Syntax with Function Chaining (`|>`) in Julia\nDESCRIPTION: Demonstrates combining dot syntax with the pipe operator `|>` for function chaining. The `.|>` operator applies functions from an array elementwise to the corresponding elements of a range (`1:5`). For each number `n` in `1:5`, it computes `n |> funcs[n]`, where `funcs` is the array of functions `[x->x^2, inv, x->2*x, -, isodd]`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_44\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> 1:5 .|> [x->x^2, inv, x->2*x, -, isodd]\n5-element Vector{Real}:\n    1\n    0.5\n    6\n   -4\n true\n```\n\n----------------------------------------\n\nTITLE: Defining and Instantiating Parametric Structs in Julia\nDESCRIPTION: Defines a parametric struct `Point{T<:Real}` with fields `x::T` and `y::T`. It demonstrates various ways to construct instances: implicitly inferring `T` from arguments (`Point(1,2)` results in `Point{Int64}`, `Point(1.0,2.5)` results in `Point{Float64}`), explicitly specifying `T` (`Point{Int64}(1, 2)`), and shows cases leading to errors like `MethodError` for mismatched argument types (`Point(1,2.5)`) or `InexactError` for conversion failure (`Point{Int64}(1.0,2.5)`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_15\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct Point{T<:Real}\n           x::T\n           y::T\n       end\n\njulia> Point(1,2) ## implicit T ##\nPoint{Int64}(1, 2)\n\njulia> Point(1.0,2.5) ## implicit T ##\nPoint{Float64}(1.0, 2.5)\n\njulia> Point(1,2.5) ## implicit T ##\nERROR: MethodError: no method matching Point(::Int64, ::Float64)\nThe type `Point` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  Point(::T, ::T) where T<:Real at none:2\n\njulia> Point{Int64}(1, 2) ## explicit T ##\nPoint{Int64}(1, 2)\n\njulia> Point{Int64}(1.0,2.5) ## explicit T ##\nERROR: InexactError: Int64(2.5)\nStacktrace:\n[...]\n\njulia> Point{Float64}(1.0, 2.5) ## explicit T ##\nPoint{Float64}(1.0, 2.5)\n\njulia> Point{Float64}(1,2) ## explicit T ##\nPoint{Float64}(1.0, 2.0)\n```\n\n----------------------------------------\n\nTITLE: Performing Asynchronous File I/O with Tasks and Threads in Julia\nDESCRIPTION: This snippet illustrates asynchronous file writing using Tasks and Threads. A file 'foo.txt' is opened and written to in a background task, which is waited on before reading the lines from the file to confirm the write operation. Dependencies: none beyond Julia standard library. Input: file path, data string. Output: File written, contents read back as a vector of strings. Demonstrates use of @spawn and wait for task management.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_17\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> task = Threads.@spawn open(\"foo.txt\", \"w\") do io\n           write(io, \"Hello, World!\")\n       end;\n\njulia> wait(task)\n\njulia> readlines(\"foo.txt\")\n1-element Vector{String}:\n \"Hello, World!\"\n```\n\n----------------------------------------\n\nTITLE: Using Type Parameters in Functions for Specialization - Julia\nDESCRIPTION: Shows how variable construction at runtime impacts performance due to lack of type specialization, especially when assigning types with runtime logic (e.g., choosing Float32 or Float64). Also demonstrates a type annotation that can hinder performance. The code defines a function nr that constructs a type based on a precision argument, builds a Complex number, and type-annotates the result, impacting performance unless a function barrier is used. No external dependencies are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\nfunction nr(a, prec)\n    ctype = prec == 32 ? Float32 : Float64\n    b = Complex{ctype}(a)\n    c = (b + 1.0f0)::Complex{ctype}\n    abs(c)\nend\n```\n\n----------------------------------------\n\nTITLE: Triggering a Runtime Error Due to Uninitialized Variable in If Block - Julia\nDESCRIPTION: Demonstrates a common pitfall in Julia where a variable declared conditionally is not initialized on all code paths, resulting in a runtime UndefVarError. The function 'test' omits initialization of 'relation' for one branch, showcasing the importance of full variable initialization in control flow.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> function test(x,y)\n           if x < y\n               relation = \"less than\"\n           elseif x == y\n               relation = \"equal to\"\n           end\n           println(\"x is \", relation, \" y.\")\n       end\ntest (generic function with 1 method)\n\njulia> test(1,2)\nx is less than y.\n\njulia> test(2,1)\nERROR: UndefVarError: `relation` not defined in local scope\nStacktrace:\n [1] test(::Int64, ::Int64) at ./none:7\n```\n\n----------------------------------------\n\nTITLE: Enforcing Field Type Constraints in Composite Types in Julia\nDESCRIPTION: Shows error behavior when attempting to construct a Foo object with a value for 'baz' that cannot be exactly converted to Int. Demonstrates type checking and conversion during construction, and provides an example that raises an InexactError. No extra dependencies, highlighting a core Julia error message for failed conversion.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nFoo((), 23.5, 1)\nERROR: InexactError: Int64(23.5)\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Accurate Error Stack Trace with catch_backtrace in Julia\nDESCRIPTION: Demonstrates using `catch_backtrace()` within a `catch` block to obtain the stack trace associated with the caught exception, rather than the current execution context. Passing the result of `catch_backtrace()` to `stacktrace()` provides a more accurate trace, correctly identifying the function (`bad_function`) and line number (`REPL[2]:2`) where the error originated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_5\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @noinline bad_function() = undeclared_variable\nbad_function (generic function with 1 method)\n\njulia> @noinline example() = try\n           bad_function()\n       catch\n           stacktrace(catch_backtrace())\n       end\nexample (generic function with 1 method)\n\njulia> example()\n8-element Array{Base.StackTraces.StackFrame,1}:\n bad_function() at REPL[1]:1\n example() at REPL[2]:2\n[...]\n```\n\n----------------------------------------\n\nTITLE: Testing Approximate Equality (Passing) in Julia\nDESCRIPTION: Demonstrates using the `≈` operator (representing `isapprox`) within a `@test` macro for floating-point comparisons in Julia. This test passes because 1 is approximately equal to 0.999999999 within the default tolerance.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\njulia> @test 1 ≈ 0.999999999\nTest Passed\n```\n\n----------------------------------------\n\nTITLE: Defining a Method for Abstract Number Types (Julia)\nDESCRIPTION: This code defines another method for the function 'f' in Julia, which accepts any subtypes of the abstract type 'Number' for both arguments. It demonstrates increasing generality by allowing different numeric types and calculates '2x - y'. The snippet also shows using this method with a Float64 and an Int, and no additional dependencies are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(x::Number, y::Number) = 2x - y\nf (generic function with 2 methods)\n\njulia> f(2.0, 3)\n1.0\n```\n\n----------------------------------------\n\nTITLE: Creating Julia Views with Linear and Extended Slicing\nDESCRIPTION: This Julia code demonstrates creating `SubArray` views from a parent 2D array `A`. It shows creating a 1D view using linear indexing (`2:7`) and another view using standard slicing (`:`) combined with appending an extra dimension (`1:1`), illustrating the flexibility of the `view` function and how view dimensionality can differ from the parent. No external dependencies are required beyond base Julia functionality.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nA = reshape(1:35, 5, 7) # A 2d parent Array\nS = view(A, 2:7)         # A 1d view created by linear indexing\nS = view(A, :, :, 1:1)   # Appending extra indices is supported\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Julia Macro to Inspect Arguments\nDESCRIPTION: Defines a macro `@showarg` that uses `show(x)` to print the structure of its argument `x`. Demonstrates that macros receive arguments as expressions (like `:(1 + 1)`), symbols (`:a`), or literals (`1`, `\"Yo!\"`), revealing the unevaluated code structure passed to the macro. String interpolation results in an `Expr`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\njulia> macro showarg(x)\n           show(x)\n           # ... remainder of macro, returning an expression\n       end\n@showarg (macro with 1 method)\n\njulia> @showarg(a)\n:a\n\njulia> @showarg(1+1)\n:(1 + 1)\n\njulia> @showarg(println(\"Yo!\"))\n:(println(\"Yo!\"))\n\njulia> @showarg(1)        # Numeric literal\n1\n\njulia> @showarg(\"Yo!\")    # String literal\n\"Yo!\"\n\njulia> @showarg(\"Yo! $(\"hello\")\")    # String with interpolation is an Expr rather than a String\n:(\"Yo! $(\"hello\")\")\n```\n\n----------------------------------------\n\nTITLE: Handling Mutable State in Scoped Values with Concurrency in Julia\nDESCRIPTION: Highlights the potential pitfalls of storing mutable objects (like `Dict`) in `ScopedValue`s when used with concurrency, showing an invalid usage that leads to race conditions. It then demonstrates the correct approach: ensuring each concurrent task operates on a separate instance of the mutable object, created within its own dynamic scope using `with(sval_dict => Dict())`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.ScopedValues\nimport Base.Threads: @spawn\n\nconst sval_dict = ScopedValue(Dict())\n\n# Example of using a mutable value wrongly\n@sync begin\n    # `Dict` is not thread-safe the usage below is invalid\n    @spawn (sval_dict[][:a] = 3)\n    @spawn (sval_dict[][:b] = 3)\nend\n\n@sync begin\n    # If we instead pass a unique dictionary to each\n    # task we can access the dictionaries race free.\n    with(sval_dict => Dict()) do\n        @spawn (sval_dict[][:a] = 3)\n    end\n    with(sval_dict => Dict()) do\n        @spawn (sval_dict[][:b] = 3)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining the Base64 Module in Julia\nDESCRIPTION: Declares the Base64 module and documents its core API using a structured metadata and docs system. The snippet relies on Julia's built-in documentation syntax and metadata macros, assuming dependency on Julia's standard doc system. The main entries provide references to types and functions for encoding, decoding, and stream operations in base64, expecting users to access more detailed documentation for each entry. The block itself does not define implementations, but lists components with their doc signatures as the entry point for further lookup.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Base64/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nEditURL = \"https://github.com/JuliaLang/julia/blob/master/stdlib/Base64/docs/src/index.md\"\n```\n\n# Base64\n\n```@docs\nBase64.Base64\nBase64.Base64EncodePipe\nBase64.base64encode\nBase64.Base64DecodePipe\nBase64.base64decode\nBase64.stringmime\n```\n```\n\n----------------------------------------\n\nTITLE: Looking Up a Package Dependency by UUID in the Dependency Graph (Julia)\nDESCRIPTION: This single-line Julia example demonstrates querying the dependency graph to find which UUID a named dependency maps to in a given package context. It requires a properly initialized 'graph' dictionary as shown in previous snippets. Inputs are the parent package's UUID and the dependency name as a Symbol, and the output is the UUID of the dependency package, enabling context-aware dependency resolution.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\ngraph[UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\")][:Priv]\n```\n\n----------------------------------------\n\nTITLE: Inspecting Environment Variables in Julia - Julia\nDESCRIPTION: This snippet shows how to retrieve the value of the JULIA_EDITOR environment variable in a Julia session by indexing into the ENV dictionary. The lookup returns the value if set, or raises a KeyError if the key is missing. The key must be a string matching the name of the desired variable. This operation can be used for both transient and persistent variable inspection.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/environment-variables.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nENV[\"JULIA_EDITOR\"]\n```\n\n----------------------------------------\n\nTITLE: Lexical Scoping Using Module and Function - Julia\nDESCRIPTION: Shows how lexical scoping works in Julia by defining a variable and function within a module. The function 'foo' accesses the variable 'x' defined in the same module, not one from the caller’s context. No external dependencies are required. The code demonstrates how scope is determined by definition location, not by where a function is called or imported. Expected output is the value of 'x' from within the module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_2\n\nLANGUAGE: jldoctest moduleBar\nCODE:\n```\njulia> module Bar\\n           x = 1\\n           foo() = x\\n       end;\n```\n\n----------------------------------------\n\nTITLE: Escaping Literal Dollar Signs in Julia Strings\nDESCRIPTION: Shows how to include a literal dollar sign (`$`) character within a string that uses interpolation syntax by escaping it with a preceding backslash (`\\$`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_29\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> print(\"I have \\$100 in my account.\\n\")\nI have $100 in my account.\n```\n\n----------------------------------------\n\nTITLE: Creating a 1D Julia Array in C\nDESCRIPTION: This C snippet demonstrates how to create a 1-dimensional Julia array of Float64 elements with a specified length (10). It first gets the array type using `jl_apply_array_type` with the Julia float64 type (`jl_float64_type`) and dimension 1, then allocates the array using `jl_alloc_array_1d`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_24\n\nLANGUAGE: c\nCODE:\n```\njl_value_t* array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 1);\njl_array_t* x          = jl_alloc_array_1d(array_type, 10);\n```\n\n----------------------------------------\n\nTITLE: Documenting Internal and Helper Date Functions in Julia (Julia)\nDESCRIPTION: This @docs block documents lower-level, not-exported date and time functions within the Dates namespace. These include floorceil (internal rounding), epochdays2date and epochms2datetime (converting from epoch representations), and date2epochdays/date2epochms (opposite conversions). Dependencies: Julia's Dates module, understanding of epoch-based time. Inputs vary per function. Outputs include date/time types or integers. These are not intended for external use and are not automatically exported.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\nDates.floorceil\nDates.epochdays2date\nDates.epochms2datetime\nDates.date2epochdays\nDates.datetime2epochms\n```\n\n----------------------------------------\n\nTITLE: Defining a Summation Loop Potentially Ambiguous in File Scope (Julia)\nDESCRIPTION: Presents a Julia code snippet intended to sum numbers from 1 to 10 using a `for` loop. This code's behavior, specifically regarding the scope of variables `s` and `t`, depends critically on whether it's run interactively in the REPL or executed from a file, highlighting the context-dependent nature of Julia's soft scope rules.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\ns = 0\nfor i = 1:10\n    t = s + i\n    s = t\nend\ns\n@isdefined(t)\n```\n\n----------------------------------------\n\nTITLE: Generating Unicode and Emoji Completion Table with Julia Markdown - Julia\nDESCRIPTION: This Julia script processes available LaTeX and emoji tab completion symbols in the Julia REPL, merges them with Unicode names loaded from a UnicodeData TXT file, and generates a well-formatted Markdown table for documentation. It defines utility functions to gather tab completions, look up Unicode metadata, handle Unicode character formatting (especially for combining characters), and assemble the entries into a Markdown table with code-formatted completion sequences. Prerequisites include the Julia standard library, knowledge of UnicodeData.txt file placement, and a correct Markdown.jl setup. Inputs are sets of completion symbol mappings and the Unicode data file; output is a Markdown document containing the table, intended for inclusion in Julia's documentation system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/unicode-input.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nimport REPL, Markdown\nconst NBSP = '\\u00A0'\n\nfunction tab_completions(symbols...)\n    completions = Dict{String, Vector{String}}()\n    for each in symbols, (k, v) in each\n        completions[v] = push!(get!(completions, v, String[]), k)\n    end\n    return completions\nend\n\nfunction unicode_data()\n    file = normpath(@__DIR__, \"..\", \"..\", \"..\", \"..\", \"..\", \"doc\", \"UnicodeData.txt\")\n    names = Dict{UInt32, String}()\n    open(file) do unidata\n        for line in readlines(unidata)\n            id, name, desc = split(line, \";\")[[1, 2, 11]]\n            codepoint = parse(UInt32, \"0x$id\")\n            names[codepoint] = titlecase(lowercase(\n                name == \"\" ? desc : desc == \"\" ? name : \"$name / $desc\"))\n        end\n    end\n    return names\nend\n\n# Surround combining characters with no-break spaces (i.e '\\u00A0'). Follows the same format\n# for how unicode is displayed on the unicode.org website:\n# https://util.unicode.org/UnicodeJsps/character.jsp?a=0300\nfunction fix_combining_chars(char)\n    cat = Base.Unicode.category_code(char)\n    return cat == 6 || cat == 8 ? \"$NBSP$char$NBSP\" : \"$char\"\nend\n\nfunction table_entries(completions, unicode_dict)\n    entries = Any[Any[\n        [\"Code point(s)\"],\n        [\"Character(s)\"],\n        [\"Tab completion sequence(s)\"],\n        [\"Unicode name(s)\"],\n    ]]\n    for (chars, inputs) in sort!(collect(completions), by = first)\n        code_points, unicode_names, characters = String[], String[], String[]\n        for char in chars\n            push!(code_points, \"U+$(uppercase(string(UInt32(char), base = 16, pad = 5)))\")\n            push!(unicode_names, get(unicode_dict, UInt32(char), \"(No Unicode name)\"))\n            push!(characters, isempty(characters) ? fix_combining_chars(char) : \"$char\")\n        end\n        inputs_md = []\n        for (i, input) in enumerate(inputs)\n            i > 1 && push!(inputs_md, \", \")\n            push!(inputs_md, Markdown.Code(\"\", input))\n        end\n        push!(entries, [\n            [join(code_points, \" + \")],\n            [join(characters)],\n            inputs_md,\n            [join(unicode_names, \" + \")],\n        ])\n    end\n    table = Markdown.Table(entries, [:l, :c, :l, :l])\n    # We also need to wrap the Table in a Markdown.MD \"document\"\n    return Markdown.MD([table])\nend\n\ntable_entries(\n    tab_completions(\n        REPL.REPLCompletions.latex_symbols,\n        REPL.REPLCompletions.emoji_symbols\n    ),\n    unicode_data()\n)\n```\n\n----------------------------------------\n\nTITLE: Building the Dependency Graph from a Project Manifest in Julia\nDESCRIPTION: This code constructs the full dependency graph (as a Julia dictionary), mapping package UUIDs to dictionaries of their named dependencies. It is typically built by parsing the manifest file and is used by Julia to resolve indirect dependencies, even when packages share the same name. Each key is a UUID, and each value is a dictionary mapping dependency names to UUIDs. Requires correct UUIDs and a manifest structure consistent with the TOML manifest.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\ngraph = Dict(\n    # Priv \\u2013 the private one:\n    UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\") => Dict(\n        :Pub   => UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"),\n        :Zebra => UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"),\n    ),\n    # Priv \\u2013 the public one:\n    UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\") => Dict(),\n    # Pub:\n    UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\") => Dict(\n        :Priv  => UUID(\"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"),\n        :Zebra => UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"),\n    ),\n    # Zebra:\n    UUID(\"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\") => Dict(),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Footnote References in Markdown\nDESCRIPTION: This snippet illustrates the Markdown syntax for creating footnote references within text. Numbered footnotes use `[^N]` and named footnotes use `[^name]`, where 'name' is alphanumeric.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\nA paragraph containing a numbered footnote [^1] and a named one [^named].\n```\n\n----------------------------------------\n\nTITLE: Using Machine Epsilon (eps) and ULP Computation in Julia (Julia)\nDESCRIPTION: Demonstrates how to retrieve machine epsilon for Float32 and Float64, both via the type and via value arguments. Shows how the eps function computes the distance to the next representable value at 1.0, at other values (1000., 1e-27), and at zero, providing insight into floating-point precision properties. No special dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\njulia> eps(Float32)\n1.1920929f-7\n\njulia> eps(Float64)\n2.220446049250313e-16\n\njulia> eps() # same as eps(Float64)\n2.220446049250313e-16\n\njulia> eps(1.0)\n2.220446049250313e-16\n\njulia> eps(1000.)\n1.1368683772161603e-13\n\njulia> eps(1e-27)\n1.793662034335766e-43\n\njulia> eps(0.0)\n5.0e-324\n```\n\n----------------------------------------\n\nTITLE: Checking Singleton Property of Parametric Types in Julia\nDESCRIPTION: Defines a parametric struct `NoFieldsParam{T}`. It shows that the base parametric type `NoFieldsParam` itself is not a singleton because it has different instances like `NoFieldsParam{Int}` and `NoFieldsParam{Bool}`. However, a fully parameterized type like `NoFieldsParam{Int}` (which is immutable and effectively has no fields) is a singleton type, confirmed by `Base.issingletontype` and instance identity check (`===`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_50\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct NoFieldsParam{T}\n       end\n\njulia> Base.issingletontype(NoFieldsParam) # Can't be a singleton type ...\nfalse\n\njulia> NoFieldsParam{Int}() isa NoFieldsParam # ... because it has ...\ntrue\n\njulia> NoFieldsParam{Bool}() isa NoFieldsParam # ... multiple instances.\ntrue\n\njulia> Base.issingletontype(NoFieldsParam{Int}) # Parametrized, it is a singleton.\ntrue\n\njulia> NoFieldsParam{Int}() === NoFieldsParam{Int}()\ntrue\n```\n\n----------------------------------------\n\nTITLE: Defining a Function to Construct Expressions in Julia\nDESCRIPTION: Presents a function `math_expr` that takes an operation symbol and two operands (which can be values or other expressions) and returns a new `Expr` object representing the function call. It demonstrates creating and evaluating a nested expression.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_17\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function math_expr(op, op1, op2)\n           expr = Expr(:call, op, op1, op2)\n           return expr\n       end\nmath_expr (generic function with 1 method)\n\njulia>  ex = math_expr(:+, 1, Expr(:call, :*, 4, 5))\n:(1 + 4 * 5)\n\njulia> eval(ex)\n21\n```\n\n----------------------------------------\n\nTITLE: Example Doctest for Matrix Creation - Julia - Julia\nDESCRIPTION: This snippet demonstrates documenting a self-contained code example for creating a matrix variable a and showing its printed output using the jldoctest format. The doctest format enables automated testing of documentation examples and encourages readers to try out code in the REPL. Both assignment and expected display are included.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\nSome nice documentation here.\n\n# Examples\n```jldoctest\njulia> a = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n```\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Converting `Union{Missing, T}` Array to `T` Array (Success Case) in Julia\nDESCRIPTION: Illustrates how an array with an element type allowing `missing` (e.g., `Vector{Union{Missing, String}}`) can be converted to an array type without `missing` (e.g., `Vector{String}`) using `convert`. This is successful only if the array does not actually contain any `missing` values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_13\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = Union{Missing, String}[\"a\", \"b\"]\n2-element Vector{Union{Missing, String}}:\n \"a\"\n \"b\"\n\njulia> convert(Array{String}, x)\n2-element Vector{String}:\n \"a\"\n \"b\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Indirect C Calls with dlsym and @ccall in Julia\nDESCRIPTION: Defines a Julia macro `@dlsym` that uses `Libdl.dlsym` to look up a function pointer from a dynamically loaded library handle (`mylibvar`). The macro caches the pointer in a `Ref` to avoid repeated lookups. The example shows how to open a library with `Libdl.dlopen` and then use the macro within an indirect `@ccall` to call the C function (`myfunc`) via the retrieved pointer.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\nmacro dlsym(lib, func)\n    z = Ref{Ptr{Cvoid}}(C_NULL)\n    quote\n        let zlocal = $z[]\n            if zlocal == C_NULL\n                zlocal = dlsym($(esc(lib))::Ptr{Cvoid}, $(esc(func)))::Ptr{Cvoid}\n                $z[] = zlocal\n            end\n            zlocal\n        end\n    end\nend\n\nmylibvar = Libdl.dlopen(\"mylib\")\n@ccall $(@dlsym(mylibvar, \"myfunc\"))()::Cvoid\n```\n\n----------------------------------------\n\nTITLE: Instantiating Packages in Julia Pkg REPL\nDESCRIPTION: This command is executed within Julia's package management mode (accessed by typing ']'). It resolves dependencies listed in the current environment's `Project.toml` and installs the necessary packages. If a `Manifest.toml` file is also present (copied from a previous version, for instance), `instantiate` will attempt to install the exact versions specified in the manifest, provided they are compatible with the current Julia version.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_38\n\nLANGUAGE: julia-repl\nCODE:\n```\ninstantiate\n```\n\n----------------------------------------\n\nTITLE: Determining Default Integer Type Based on System Architecture in Julia\nDESCRIPTION: Illustrates that the default type for an integer literal (e.g., `1`) depends on whether the target system has a 32-bit or 64-bit architecture, resulting in `Int32` or `Int64` respectively. This requires running the code on different architectures to see the different outputs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```julia-repl\n# 32-bit system:\njulia> typeof(1)\nInt32\n\n# 64-bit system:\njulia> typeof(1)\nInt64\n```\n```\n\n----------------------------------------\n\nTITLE: Using Libdl Module for Dynamic Linking in Julia\nDESCRIPTION: This snippet references the Libdl module in Julia, which provides a set of tools for dynamic linking and loading shared libraries at runtime. It enables users to access all exported functions and constants from Libdl, and is a prerequisite for any dynamic library operations in Julia. The primary output is the ability to use dynamic linking primitives in Julia code.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Libdl/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nLibdl\n```\n\n----------------------------------------\n\nTITLE: Displaying Expression Structure with dump in Julia\nDESCRIPTION: Uses the dump function to recursively display the structure of an Expr object. This assists developers in understanding the full tree of an expression, often used in debugging and metaprogramming scenarios. Inputs: any Expr; outputs: human-readable indented display; requires no external dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> dump(ex2)\nExpr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Int64 1\n    3: Int64 1\n```\n\n----------------------------------------\n\nTITLE: Constraining Varargs by Type Parameters in Julia\nDESCRIPTION: Shows a `getindex` method definition for `AbstractArray` where the number of `indices` (variable arguments of type `Number`) is constrained to be equal to the dimensionality `N` of the array `A`. This uses `Vararg{Number,N}` and a `where {T,N}` clause to link the varargs count to a type parameter.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nfunction getindex(A::AbstractArray{T,N}, indices::Vararg{Number,N}) where {T,N}\n```\n\n----------------------------------------\n\nTITLE: Reusing Outer Variable in Julia `for` Loop with `outer` Keyword\nDESCRIPTION: Shows how to explicitly reuse an existing local variable (`i` defined within function `f`) as the iteration variable in a Julia `for` loop by using the `outer` keyword. This causes the loop to modify the outer `i` variable. The function `f` subsequently returns the final value of this outer `i` after the loop completes (3).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_25\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> function f()\n           i = 0\n           for outer i = 1:3\n               # empty\n           end\n           return i\n       end;\n\njulia> f()\n3\n```\n```\n\n----------------------------------------\n\nTITLE: Constructing Complex Numbers in Julia - julia\nDESCRIPTION: Demonstrates two different idioms for constructing complex numbers in Julia: one using the concrete type constructor Complex{Float64}, and the other using the generic complex function along with type promotion. The preferred method leverages Julia's generic functions for type flexibility and extensibility. Inputs: a value x to be converted to complex; outputs: a Complex number. Dependency: Julia's base Complex type and related functions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nComplex{Float64}(x)\n```\n\nLANGUAGE: julia\nCODE:\n```\ncomplex(float(x))\n```\n\n----------------------------------------\n\nTITLE: Constructing Rational with Mixed Integer Types in Julia\nDESCRIPTION: Shows an example of calling the `Rational` constructor with arguments of different integer types (`Int8`, `Int32`). Demonstrates how the outer constructor promotes the arguments, resulting in a `Rational{Int32}`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_8\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = Rational(Int8(15),Int32(-5))\n-3//1\n\njulia> typeof(x)\nRational{Int32}\n```\n\n----------------------------------------\n\nTITLE: Inputting Escaped Characters Using C-Style Escapes in Julia\nDESCRIPTION: Demonstrates usage of standard C escaped character sequences in Julia, converting them to their integer Unicode code point values. No dependencies. Input is single-quoted escape; output is integer value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> Int('\\0')\n0\n\njulia> Int('\\t')\n9\n\njulia> Int('\\n')\n10\n\njulia> Int('\\e')\n27\n\njulia> Int('\\x7f')\n127\n\njulia> Int('\\177')\n127\n```\n\n----------------------------------------\n\nTITLE: Defining Documentation Metadata in Julia Markdown - Julia\nDESCRIPTION: This snippet sets up metadata for the documentation file, including the Edit URL for version control integration and a configuration for doctest setup, ensuring that the Artifacts module is available during doctests. This ensures seamless coordination between docs rendering and Julia's documentation tooling.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Artifacts/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nEditURL = \"https://github.com/JuliaLang/julia/blob/master/stdlib/Artifacts/docs/src/index.md\"\n```\n```\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nDocTestSetup = :(using Artifacts)\n```\n```\n\n----------------------------------------\n\nTITLE: Opening and Streaming File Contents - Julia\nDESCRIPTION: Shows how to manually open a file using `open(filename)` to get an IOStream, and how to read all lines with `readlines(f)`. Highlights manual resource management (file must be closed explicitly). Suitable for sequential reading of text files; uses Julia's built-in I/O types. Input is a filename; output is a vector of lines. Remember to close the stream to avoid resource leaks.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_6\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> f = open(\"hello.txt\")\\nIOStream(<file hello.txt>)\\n\\njulia> readlines(f)\\n1-element Vector{String}:\\n \"Hello, World!\"\n```\n\n----------------------------------------\n\nTITLE: Listing Core Julia Object Functions for Documentation\nDESCRIPTION: This block utilizes the `@docs` directive to list fundamental functions and types related to object identity, equality, comparison, type inspection, conversion, promotion, hashing, finalization, copying, and property/field access available across all Julia objects. It instructs the documentation generator to incorporate documentation for these items under the 'All Objects' category.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCore.:(===)\nCore.isa\nBase.isequal\nBase.isless\nBase.isunordered\nBase.ifelse\nCore.typeassert\nCore.typeof\nCore.tuple\nBase.ntuple\nBase.objectid\nBase.hash\nBase.finalizer\nBase.finalize\nBase.copy\nBase.deepcopy\nBase.getproperty\nBase.setproperty!\nBase.replaceproperty!\nBase.swapproperty!\nBase.modifyproperty!\nBase.setpropertyonce!\nBase.propertynames\nBase.hasproperty\nCore.getfield\nCore.setfield!\nCore.modifyfield!\nCore.replacefield!\nCore.swapfield!\nCore.setfieldonce!\nCore.isdefined\nCore.isdefinedglobal\nBase.@isdefined\nBase.convert\nBase.promote\nBase.oftype\nBase.widen\nBase.identity\nBase.WeakRef\n```\n```\n\n----------------------------------------\n\nTITLE: Converting `Union{Missing, T}` Array to `T` Array (Error Case) in Julia\nDESCRIPTION: Demonstrates that attempting to `convert` an array of type `Union{Missing, T}` (e.g., `Vector{Union{Missing, String}}`) to an array of type `T` (e.g., `Array{String}`) will fail with a `MethodError` if the array contains any `missing` values. This is because there is no method to convert the `missing` object to the target type `T`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_14\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> y = Union{Missing, String}[missing, \"b\"]\n2-element Vector{Union{Missing, String}}:\n missing\n \"b\"\n\njulia> convert(Array{String}, y)\nERROR: MethodError: Cannot `convert` an object of type Missing to an object of type String\n```\n\n----------------------------------------\n\nTITLE: Switching Julia Depot Path with Trailing Colon - Shell\nDESCRIPTION: This shell command sets JULIA_DEPOT_PATH to a specific directory, appending a colon to trigger expansion to Julia's default system depot locations for bundled resources. All package operations (e.g., registry cloning, package installation) will write to the specified directory, while keeping access to system resources. Should be set before launching Julia or placed in shell startup files. On Windows, use ';' as a separator.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/environment-variables.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nexport JULIA_DEPOT_PATH=\"/foo/bar:\"\n```\n\n----------------------------------------\n\nTITLE: Optimizing Untyped Global Variable Access in Julia\nDESCRIPTION: Demonstrates a way to mitigate performance issues when using untyped global variables. By annotating the type of the global variable `x` (`x::Vector{Float64}`) at the point of use within the function `loop_over_global`, the compiler can generate more optimized code compared to accessing an untyped global directly. It assumes `x` is defined globally.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nglobal x = rand(1000)\n\nfunction loop_over_global()\n    s = 0.0\n    for i in x::Vector{Float64}\n        s += i\n    end\n    return s\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Three-Valued Logic to any and all Functions in Julia\nDESCRIPTION: Shows how the logical functions `any` and `all` follow three-valued logic when encountering missing values in input arrays. Depending on the input, these functions may return `missing`, `true`, or `false`. Inputs: arrays containing boolean and `missing` values. Output is the result according to Julia's three-valued logic for aggregation. No special dependencies needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\njulia> all([true, missing])\nmissing\n\njulia> all([false, missing])\nfalse\n\njulia> any([true, missing])\ntrue\n\njulia> any([false, missing])\nmissing\n```\n\n----------------------------------------\n\nTITLE: Executing Code Only in Julia REPL Startup (Julia)\nDESCRIPTION: Shows how to use the `atreplinit` function within a `startup.jl` file. Code placed inside the `do...end` block passed to `atreplinit` will only execute when Julia is started in its interactive mode (the REPL). It will not run when Julia executes a script non-interactively. The `repl` argument passed to the block provides access to the REPL object itself.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\natreplinit() do repl\n    # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Explicitly Defining Default Parametric Constructors in Julia\nDESCRIPTION: Illustrates the explicit Julia code that is equivalent to the default constructors automatically provided for the parametric struct `Point{T<:Real}`. It defines an inner constructor `Point{T}(x,y) where {T<:Real} = new(x,y)` called when type `T` is explicitly specified (e.g., `Point{Int64}(1,2)`), and an outer constructor `Point(x::T, y::T) where {T<:Real} = Point{T}(x,y)` called when `T` is implicitly inferred from arguments of the same type (e.g., `Point(1,2)`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_16\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct Point{T<:Real}\n           x::T\n           y::T\n           Point{T}(x,y) where {T<:Real} = new(x,y)\n       end\n\njulia> Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);\n```\n\n----------------------------------------\n\nTITLE: Logical Array Comparison with Missing Values in Julia\nDESCRIPTION: Illustrates how array-wide comparison using `==` returns `missing` if the result cannot be determined due to `missing` entries. The snippet compares different arrays including missing values, demonstrating Julia's three-valued logic. Dependencies: none beyond Julia Base. Inputs are arrays with possible `missing`; outputs can be `missing`, `true`, or `false`. Limitation: equality is undecidable if any compared elements are missing.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\njulia> [1, missing] == [2, missing]\nfalse\n\njulia> [1, missing] == [1, missing]\nmissing\n\njulia> [1, 2, missing] == [1, missing, 2]\nmissing\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Syntax Elements and Keywords for Documentation\nDESCRIPTION: This block uses the `@docs` directive from Julia's documentation system to enumerate various language keywords, syntax constructs, and operators under the 'Keywords' category. It serves as a reference point for the documentation generator to include details about module definition, control flow, scope, types, metaprogramming, and operators.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nmodule\nexport\npublic\nimport\nusing\nas\nbaremodule\nfunction\nmacro\nreturn\ndo\nbegin\nend\nlet\nif\nfor\nwhile\nbreak\ncontinue\ntry\nfinally\nquote\nlocal\nglobal\nouter\nconst\nstruct\nmutable struct\n@kwdef\nabstract type\nprimitive type\nwhere\n...\n;\n=\n?:\n.=\n.\n->\n::\n[]\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Discrete Distribution Structure in Julia\nDESCRIPTION: Defines the `DiscreteDistribution` struct in Julia, designed to hold a vector of probabilities representing a discrete probability distribution. This structure serves as the basis for subsequent examples demonstrating optimized random sampling.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nstruct DiscreteDistribution{V <: AbstractVector}\n    probabilities::V\nend\n```\n\n----------------------------------------\n\nTITLE: Verifying Non-Type Objects Are Not Instances of `Type` in Julia\nDESCRIPTION: Shows that objects which are not types are not instances of the abstract `Type`. Both `isa(1, Type)` and `isa(\"foo\", Type)` evaluate to false, confirming that only type objects belong to the abstract `Type`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_58\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> isa(1, Type)\nfalse\n\njulia> isa(\"foo\", Type)\nfalse\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Unboxing a Float64 Result from Julia in C\nDESCRIPTION: Illustrates how to retrieve a value returned by `jl_eval_string`, check if it is of the expected Julia type (`jl_float64_type`) using `jl_typeis`, and convert (unbox) it to a native C `double` using `jl_unbox_float64`. Includes basic error checking for the type. The `jl_value_t*` points to a heap-allocated Julia object.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");\n\nif (jl_typeis(ret, jl_float64_type)) {\n    double ret_unboxed = jl_unbox_float64(ret);\n    printf(\"sqrt(2.0) in C: %e \\n\", ret_unboxed);\n}\nelse {\n    printf(\"ERROR: unexpected return type from sqrt(::Float64)\\n\");\n}\n```\n\n----------------------------------------\n\nTITLE: Multiplying Input by Rational Literal in Julia Function - Julia\nDESCRIPTION: Introduces a generic function h(x) that multiplies its argument by a Rational literal (2//1). This approach minimizes type disruption compared to floating-point literals but may promote integer inputs to Rational outputs. The snippet compares behavior for Rational, float, and integer inputs, illustrating intermediate type promotion. No external modules are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\njulia> h(x) = 2//1 * x\nh (generic function with 1 method)\n\njulia> h(1//2)\n1//1\n\njulia> h(1/2)\n1.0\n\njulia> h(1)\n2//1\n```\n\n----------------------------------------\n\nTITLE: Creating Byte Array Literals in Julia\nDESCRIPTION: Demonstrates the creation of a byte array literal (`b\"...\"`) in Julia using a mix of ASCII characters ('DATA'), a hexadecimal byte escape (`\\xff`), and a Unicode escape (`\\u2200`). The Unicode escape is automatically encoded into its UTF-8 byte sequence. The resulting object is of type `Base.CodeUnits{UInt8, String}`, representing a read-only array of bytes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_57\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> b\"DATA\\xff\\u2200\"\n8-element Base.CodeUnits{UInt8, String}:\n 0x44\n 0x41\n 0x54\n 0x41\n 0xff\n 0xe2\n 0x88\n 0x80\n```\n\n----------------------------------------\n\nTITLE: Specialization Behavior on Function Arguments - Julia\nDESCRIPTION: Illustrates Julia's specialization heuristics for Function arguments. The first two forms with function or Function as the parameter do not trigger specialization, while adding a type parameter (where {H}) does. Takes a function and a number, returns an ntuple of the results. No libraries required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\nf_func(f, num) = ntuple(f, div(num, 2))\ng_func(g::Function, num) = ntuple(g, div(num, 2))\n```\n\nLANGUAGE: julia\nCODE:\n```\nh_func(h::H, num) where {H} = ntuple(h, div(num, 2))\n```\n\n----------------------------------------\n\nTITLE: Dispatching One Argument at a Time (Name Cascade) in Julia\nDESCRIPTION: Demonstrates the \"name cascade\" pattern for handling multi-argument dispatch. The main function `f` dispatches on the first argument (`x`) and calls internal, type-specific functions (`_fA`, `_fB`). These internal functions then handle dispatch based on the second argument `y`, avoiding ambiguities between the `A` and `B` cases for `x`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_47\n\nLANGUAGE: julia\nCODE:\n```\nf(x::A, y) = _fA(x, y)\nf(x::B, y) = _fB(x, y)\n```\n\n----------------------------------------\n\nTITLE: Using a Package with an @main Entry Point (Bash/Julia)\nDESCRIPTION: Demonstrates how using a package (`Hello`) that defines an `@main` function triggers its execution. Executing `julia -e 'using Hello'` loads the package and brings `main` into the `Main` namespace, causing the function to run. In contrast, `julia -e 'import Hello'` loads the package but doesn't bring `main` into `Main`, so it doesn't execute automatically. Execution depends on the `main` binding being present in `Main` when `@main` was used.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ julia -e 'using Hello'\n$ julia -e 'import Hello' # N.B.: Execution depends on the binding not whether the package is loaded\n```\n\n----------------------------------------\n\nTITLE: Using a Custom String Literal Macro with a Flag in Julia\nDESCRIPTION: This Julia syntax example demonstrates how to invoke a custom non-standard string literal macro (`foo_str`) that accepts a flag. The `flag` part immediately follows the closing double quote of the string literal `\"str\"`, passing its content as the second argument to the macro.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_61\n\nLANGUAGE: julia\nCODE:\n```\nfoo\"str\"flag\n```\n\n----------------------------------------\n\nTITLE: Testing Approximate Equality with Custom Tolerance in Julia\nDESCRIPTION: Illustrates specifying a custom relative tolerance (`rtol`) for the `isapprox` function (`≈`) directly within the `@test` macro call. The test `@test 1 ≈ 0.999999 rtol=1e-5` passes because the difference is within the specified tolerance.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\njulia> @test 1 ≈ 0.999999  rtol=1e-5\nTest Passed\n```\n\n----------------------------------------\n\nTITLE: Defining Rational Constructor Using promote in Julia\nDESCRIPTION: Illustrates an outer constructor method for the `Rational` type in Julia. It accepts two `Integer` arguments, promotes them to a common integer type using `promote`, and then calls the inner constructor with the promoted values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nRational(n::Integer, d::Integer) = Rational(promote(n,d)...)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Ambiguity in Julia (jldoctest)\nDESCRIPTION: This doctest illustrates a method ambiguity scenario in Julia. Two methods for function `g` are defined: `g(x::Float64, y)` and `g(x, y::Float64)`. When called with `g(2.0, 3.0)`, both methods are applicable, but neither is strictly more specific than the other. Consequently, Julia raises a `MethodError` indicating the ambiguity and listing the candidate methods.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_13\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> g(x::Float64, y) = 2x + y\ng (generic function with 1 method)\n\njulia> g(x, y::Float64) = x + 2y\ng (generic function with 2 methods)\n\njulia> g(2.0, 3)\n7.0\n\njulia> g(2, 3.0)\n8.0\n\njulia> g(2.0, 3.0)\nERROR: MethodError: g(::Float64, ::Float64) is ambiguous.\n\nCandidates:\n  g(x, y::Float64)\n    @ Main none:1\n  g(x::Float64, y)\n    @ Main none:1\n\nPossible fix, define\n  g(::Float64, ::Float64)\n\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Array Assignment and Growth in Julia\nDESCRIPTION: Julia does not automatically grow arrays on assignment. Assigning to an out-of-bounds index throws an error. Use functions like `push!` or `append!` for efficient vector growth.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\na[5] = 7 # Throws BoundsError if length(a) < 5\n```\n\nLANGUAGE: julia\nCODE:\n```\npush!(a, val) # Appends val, growing vector 'a'\n```\n\nLANGUAGE: julia\nCODE:\n```\nappend!(a, collection) # Appends elements from collection, growing 'a'\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling a Local Variable in Julia Function - Julia\nDESCRIPTION: This snippet demonstrates how variable assignment inside a Julia function introduces a new local variable, regardless of the global context. Dependencies are standard Julia base functions (no external dependencies). The parameter x is defined locally inside the greet function and printed, showing that its scope does not leak outside the function. The output illustrates local/global scope separation, and REPL error output is included to show undefined global variable behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> function greet()\n           x = \"hello\" # new local\n           println(x)\n       end\ngreet (generic function with 1 method)\n\njulia> greet()\nhello\n\njulia> x # global\nERROR: UndefVarError: `x` not defined in `Main`\n```\n\n----------------------------------------\n\nTITLE: Resolving Container/Element Type Ambiguity via Specific Method\nDESCRIPTION: Demonstrates the \"band-aid\" approach to resolving ambiguity between methods dispatching on abstract container element types and specific container types. A highly specific method is defined for the exact combination (`MyArrayType{Date}`, `Date`) that causes the conflict.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_50\n\nLANGUAGE: julia\nCODE:\n```\n-(A::MyArrayType{T}, b::Date) where {T<:Date} = ...\n```\n\n----------------------------------------\n\nTITLE: Initializing Structs with Plain Data Types in Julia\nDESCRIPTION: Defines a struct `HasPlain` containing a 'plain data' field `n::Int`. The inner constructor `HasPlain() = new()` uses `new()` without providing a value for `n`. Instantiating `HasPlain()` shows that the initial content of the plain data field `n` is undefined, typically resulting in a garbage value, unlike reference fields which error on access if uninitialized.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_13\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> struct HasPlain\n           n::Int\n           HasPlain() = new()\n       end\n\njulia> HasPlain()\nHasPlain(438103441441)\n```\n\n----------------------------------------\n\nTITLE: Importing Julia Module Names with Relative Paths (REPL Success)\nDESCRIPTION: Illustrates the correct method for importing a name (`add_D`) from a submodule (`ParentModule.SubA`) when the parent module (`ParentModule`) has been defined directly in the REPL. It uses a relative path starting with `.` (`import .ParentModule.SubA: add_D`) to reference the module relative to the current scope (Main), successfully resolving the import.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_25\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> import .ParentModule.SubA: add_D\n\n```\n\n----------------------------------------\n\nTITLE: Checking Subtyping Between Parametric Types in Julia\nDESCRIPTION: Illustrates how concrete instances of a parametric composite type (Point{T}) relate as subtypes to their matching parametric abstract types (Pointy{T}). Various choices of T are shown, and subtype checks yield expected true or false values depending on parameter invariance or covariance.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\njulia> Point{Float64} <: Pointy{Float64}\ntrue\n\njulia> Point{Real} <: Pointy{Real}\ntrue\n\njulia> Point{AbstractString} <: Pointy{AbstractString}\ntrue\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `is`: Use `===` in Julia\nDESCRIPTION: The `is` function for identity comparison in Julia has been deprecated. The `===` operator, which was previously an alias for `is`, should now be used directly for checking object identity.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_181\n\nLANGUAGE: julia\nCODE:\n```\n===\n```\n\n----------------------------------------\n\nTITLE: Preferred Non-Parametric Signature for Function Definitions - Julia - julia\nDESCRIPTION: Shows the recommended pattern for function signatures by specifying the type directly instead of introducing unnecessary static parameters. Here, the function foo is defined with the argument x constrained to Real. This leads to simpler, more maintainable code with no loss in performance, requiring only the Julia standard types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nfoo(x::Real) = ...\n\n```\n\n----------------------------------------\n\nTITLE: Appending to Julia Depot Path with Leading Colon - Shell\nDESCRIPTION: This command adds '/foo/bar' at the end of Julia's default depot search paths by setting JULIA_DEPOT_PATH with a leading colon. It preserves default user and system depots, and appends the additional location for package and resource discovery. Set before starting Julia, or add to shell configuration. Replace ':' with ';' on Windows.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/environment-variables.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nexport JULIA_DEPOT_PATH=\":/foo/bar\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Generated Function with Type-Based Conditional Logic in Julia\nDESCRIPTION: Defines a generated function `bar` that returns different quoted expressions based on the type of the input `x`. If `x` is a subtype of `Integer`, it returns `:(x ^ 2)`; otherwise, it returns `:(x)`. Calls demonstrate this conditional behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_70\n\nLANGUAGE: julia\nCODE:\n```\njulia> @generated function bar(x)\n           if x <: Integer\n               return :(x ^ 2)\n           else\n               return :(x)\n           end\n       end\nbar (generic function with 1 method)\n\njulia> bar(4)\n16\n\njulia> bar(\"baz\")\n\"baz\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Testing a Julia Startup File (Bash)\nDESCRIPTION: This snippet first uses `echo` and redirection to create a `startup.jl` file in the default Julia configuration directory (`~/.julia/config/`). This file contains a `println` statement. The second line starts an interactive Julia session, demonstrating that the code within `startup.jl` is executed automatically upon Julia's initialization, before the REPL prompt appears.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ echo 'println(\"Greetings! 你好! 안녕하세요?\")' > ~/.julia/config/startup.jl\n$ julia\n```\n\n----------------------------------------\n\nTITLE: Type Conversion and Errors with Typed Globals in Julia\nDESCRIPTION: Illustrates behavior when assigning to a typed global variable (`y::Int`) in Julia (version 1.8+). Assigning a `Float64` value (`1.0`) succeeds because Julia automatically attempts conversion using `convert(Int, 1.0)`, resulting in `y` holding the integer `1`. Assigning `3.14` fails with an `InexactError` because `3.14` cannot be losslessly converted to the declared type `Int`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_31\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> global y::Int\n\njulia> y = 1.0\n1.0\n\njulia> y\n1\n\njulia> y = 3.14\nERROR: InexactError: Int64(3.14)\nStacktrace:\n[...]\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Julia Function using Compact Assignment Form\nDESCRIPTION: Illustrates the alternative, more concise syntax for defining a function `f` in Julia using the assignment form. This is suitable when the function body consists of a single expression (`x + y`). This definition is equivalent to the standard `function...end` block for single-expression functions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_1\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> f(x, y) = x + y\nf (generic function with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Array Auto-Growth in MATLAB\nDESCRIPTION: MATLAB automatically grows arrays when assigning to an index beyond the current bounds, filling intermediate elements with zeros.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_2\n\nLANGUAGE: matlab\nCODE:\n```\na(4) = 3.2 % Creates a = [0 0 0 3.2]\n```\n\nLANGUAGE: matlab\nCODE:\n```\na(5) = 7   % Grows a to [0 0 0 3.2 7]\n```\n\n----------------------------------------\n\nTITLE: Meaning of Regex Flags in Perl/Julia\nDESCRIPTION: Lists and describes the standard Perl regex flags (i, m, s, x) which are also used in Julia to modify regex behavior. `i` enables case-insensitive matching, `m` treats the string as multiple lines (^/$ match line breaks), `s` makes `.` match any character including newline, and `x` ignores whitespace and enables comments.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_53\n\nLANGUAGE: text\nCODE:\n```\ni   Do case-insensitive pattern matching.\n\n    If locale matching rules are in effect, the case map is taken\n    from the current locale for code points less than 255, and\n    from Unicode rules for larger code points. However, matches\n    that would cross the Unicode rules/non-Unicode rules boundary\n    (ords 255/256) will not succeed.\n\nm   Treat string as multiple lines. That is, change \"^\" and \"$\"\n    from matching the start or end of the string to matching the\n    start or end of any line anywhere within the string.\n\ns   Treat string as single line. That is, change \".\" to match any\n    character whatsoever, even a newline, which normally it would\n    not match.\n\n    Used together, as r\"\"ms, they let the \".\" match any character\n    whatsoever, while still allowing \"^\" and \"$\" to match,\n    respectively, just after and just before newlines within the\n    string.\n\nx   Tells the regular expression parser to ignore most whitespace\n    that is neither backslashed nor within a character class. You\n    can use this to break up your regular expression into\n    (slightly) more readable parts. The '#' character is also\n    treated as a metacharacter introducing a comment, just as in\n    ordinary code.\n```\n\n----------------------------------------\n\nTITLE: Configuring Package Extensions and Weak Dependencies in Julia Project.toml\nDESCRIPTION: This TOML snippet demonstrates how to define package extensions within a Julia project's `Project.toml` file. It shows the `[weakdeps]` section listing potential dependencies (ExtDep, OtherExtDep) with their UUIDs, and the `[extensions]` section defining extensions (BarExt, FooExt) and their trigger packages. An extension is loaded only when all its trigger packages are loaded.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_15\n\nLANGUAGE: toml\nCODE:\n```\nname = \"MyPackage\"\n\n[compat]\nExtDep = \"1.0\"\nOtherExtDep = \"1.0\"\n\n[weakdeps]\nExtDep = \"c9a23...\" # uuid\nOtherExtDep = \"862e...\" # uuid\n\n[extensions]\nBarExt = [\"ExtDep\", \"OtherExtDep\"]\nFooExt = \"ExtDep\"\n...\n```\n\n----------------------------------------\n\nTITLE: Constructing NamedTuple Instances in Julia\nDESCRIPTION: Shows two ways to construct named tuple values: specifying both names and types (automatic argument conversion), or specifying just names (argument types used as-is). The relevant constructor enforces arity and field order, used for convenient data packaging.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_44\n\nLANGUAGE: julia\nCODE:\n```\njulia> @NamedTuple{a::Float32,b::String}((1, \"\"))\n(a = 1.0f0, b = \"\")\n\njulia> NamedTuple{(:a, :b)}((1, \"\"))\n(a = 1, b = \"\")\n```\n\n----------------------------------------\n\nTITLE: Shadowing Exported Constants and Functions - Julia Doctest with Filter - Julia\nDESCRIPTION: This snippet shows how local variable assignments can shadow exported constants and functions such as 'pi', 'sqrt', and 'length' in Julia. It demonstrates both reassignment and definition of local functions that share names with built-ins. The context warns of potential confusion. No additional libraries are needed, and expressions are evaluated interactively with feedback shown for each assignment or function definition.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> pi = 3\\n3\\n\\njulia> pi\\n3\\n\\njulia> sqrt = 4\\n4\\n\\njulia> length() = 5\\nlength (generic function with 1 method)\\n\\njulia> Base.length\\nlength (generic function with 79 methods)\n```\n\n----------------------------------------\n\nTITLE: Defining Local Variable in a Top-level Begin Block - Julia\nDESCRIPTION: Shows a practical example of declaring a local variable inside a begin block at the top level, using the 'local' keyword. This demonstrates how the local variable 'x' inside the block does not affect the global 'x', and both can coexist independently. No dependencies are needed. The code outputs both inner and outer values of 'x', highlighting scope separation between block-level local and global variables in Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = 1\\n       begin\\n           local x = 0\\n           @show x\\n       end\\n       @show x;\\nx = 0\\nx = 1\n```\n\n----------------------------------------\n\nTITLE: Defining `connect` and `kill` Methods for Custom Julia Cluster Managers\nDESCRIPTION: Specifies the required `connect` and `kill` function signatures for a custom Julia `ClusterManager` (represented by the placeholder type `FooManager`). `connect` must establish communication with a worker (`pid`) using configuration (`config`) and return a pair of `IO` objects for reading and writing, potentially using an in-memory `BufferStream`. `kill` is responsible for terminating the specified worker process (`pid`) and performing necessary cleanup, such as closing associated `IO` objects on the master process. Implementing these methods allows replacement of the default transport layer behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_43\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nconnect(manager::FooManager, pid::Integer, config::WorkerConfig)\nkill(manager::FooManager, pid::Int, config::WorkerConfig)\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Methods within Local Scope in Julia\nDESCRIPTION: This Julia snippet, using `jldoctest` format, shows how to define methods for a function `g` within the local scope of another function `f`. The outer function `f` captures a variable `x` and returns the inner function `g`, which acts as a closure. The example demonstrates calling the returned function `h` (which is `g` closed over `x=3`) with different argument types, triggering different methods of `g`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_53\n\nLANGUAGE: julia\nCODE:\n```\njulia> function f(x)\n           g(y::Int) = y + x\n           g(y) = y - x\n           g\n       end\nf (generic function with 1 method)\n\njulia> h = f(3);\n\njulia> h(4)\n7\n\njulia> h(4.0)\n1.0\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Global Constants Simultaneously in Julia\nDESCRIPTION: Shows the syntax for declaring multiple global constants (`a`, `b`) in a single `const` statement in Julia using tuple assignment syntax. Both `a` and `b` are declared as constants in the global scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_27\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> const a, b = 1, 2\n(1, 2)\n```\n```\n\n----------------------------------------\n\nTITLE: Starting Julia with Pre-loaded Files on Multiple Processes\nDESCRIPTION: Illustrates the command-line invocation for launching Julia with `<n>` worker processes (`-p <n>`), pre-loading `file1.jl` and `file2.jl` on all processes (master and workers) using the `-L` flag, and then executing `driver.jl` on the master process (which always has ID 1).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia -p <n> -L file1.jl -L file2.jl driver.jl\n```\n\n----------------------------------------\n\nTITLE: Handling `missing` with Logical AND (`&`) - Non-Propagation Case in Julia\nDESCRIPTION: Shows how the logical AND operator (`&`) handles `missing`. If one operand is `false`, the result is definitively `false`, regardless of the other operand. Therefore, `missing` does not propagate when combined with `false` using `&`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_6\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> false & false\nfalse\n\njulia> false & true\nfalse\n\njulia> false & missing\nfalse\n```\n\n----------------------------------------\n\nTITLE: Branching on Operating System with Sys.iswindows - Julia\nDESCRIPTION: This snippet shows how to execute platform-specific code in Julia using the Sys.iswindows function inside a conditional statement. It allows execution of windows_specific_thing(a) only when running on Windows, leveraging the Sys module. There are no external dependencies beyond base Julia; argument 'a' should be properly defined beforehand.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/handling-operating-system-variation.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nif Sys.iswindows()\n    windows_specific_thing(a)\nend\n```\n\n----------------------------------------\n\nTITLE: Building and Summing Arrays Without Preallocation - Base Julia - Julia\nDESCRIPTION: Provides a reference for generating arrays in a loop using array comprehensions, which allocates a new array on each call. `xinc` returns a new array, and `loopinc` sums over a slice on each iteration, resulting in high memory usage and significant time spent in allocation and garbage collection. No special dependencies are needed; input range and functions are straightforward.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_42\n\nLANGUAGE: julia\nCODE:\n```\njulia> function xinc(x)\n           return [x + i for i  in 1:3000]\n       end;\n\njulia> function loopinc()\n           y = 0\n           for i = 1:10^5\n               ret = xinc(i)\n               y += ret[2]\n           end\n           return y\n       end;\n```\n\n----------------------------------------\n\nTITLE: Terminating Loops Early Using the break Keyword in Julia\nDESCRIPTION: Provides examples of using the `break` keyword to exit loops prematurely. The first example shows a `while true` loop that would otherwise run indefinitely, but is terminated when `i` reaches 3. The second example shows a `for` loop intended to iterate from 1 to 1000, but it also terminates early using `break` when `j` reaches 3.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_22\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> i = 1;\n\njulia> while true\n           println(i)\n           if i >= 3\n               break\n           end\n           global i += 1\n       end\n1\n2\n3\n\njulia> for j = 1:1000\n           println(j)\n           if j >= 3\n               break\n           end\n       end\n1\n2\n3\n```\n\n----------------------------------------\n\nTITLE: Optimizing Row Normalization by Unfusing Broadcasts in Julia\nDESCRIPTION: Presents three optimized methods for row normalization by explicitly calculating `sqrt.(d)` before the division broadcast. Using a temporary variable `s`, wrapping in `identity`, or using `map` avoids redundant `sqrt` calculations within the main broadcast loop, significantly speeding up the operation at the cost of a small allocation for the intermediate result.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_49\n\nLANGUAGE: julia\nCODE:\n```\n```julia\njulia> @time let s = sqrt.(d); x ./= s end;\n  0.000809 seconds (5 allocations: 8.031 KiB)\n\njulia> @time x ./= identity(sqrt.(d));\n  0.000608 seconds (5 allocations: 8.031 KiB)\n\njulia> @time x ./= map(sqrt, d);\n  0.000611 seconds (4 allocations: 8.016 KiB)\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Day of Week and Related Information in Julia\nDESCRIPTION: Shows multiple query functions: day of week, day name, and the ordinal week number in the month, demonstrated using a Date instance. Outputs include both numeric and string representations. The implementation requires only the Dates module and a Date object.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> t = Date(2014, 1, 31)\n2014-01-31\n\njulia> Dates.dayofweek(t)\n5\n\njulia> Dates.dayname(t)\n\"Friday\"\n\njulia> Dates.dayofweekofmonth(t) # 5th Friday of January\n5\n```\n\n----------------------------------------\n\nTITLE: Comparing Types of Plain vs Interpolated Strings in Julia\nDESCRIPTION: Uses `typeof` on quoted expressions to show that a plain string literal (`:(\"a should equal b\")`) has type `String`, while a string literal with interpolation (`:(\"a ($a) should equal b ($b)!\")`) results in an `Expr`. This highlights why macros need to handle interpolated strings differently if they are intended as messages, as they receive the expression structure, not the evaluated string.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_40\n\nLANGUAGE: julia\nCODE:\n```\njulia> typeof(:(\"a should equal b\"))\nString\n\njulia> typeof(:(\"a ($a) should equal b ($b)!\"))\nExpr\n```\n\n----------------------------------------\n\nTITLE: Calculating Square Root of Negative Number Using Complex Input in Julia\nDESCRIPTION: This snippet demonstrates how to obtain the complex square root of a negative number in Julia. By explicitly constructing a complex number (`-2.0+0im`), the `sqrt` function correctly computes and returns the complex result (`0.0 + 1.4142135623730951im`), avoiding the `DomainError` encountered with real inputs. This highlights Julia's type-dispatch mechanism.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_15\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> sqrt(-2.0+0im)\n0.0 + 1.4142135623730951im\n```\n```\n\n----------------------------------------\n\nTITLE: Defining an Outer Constructor with Type Conversion in Julia\nDESCRIPTION: Defines an additional outer constructor method `Point(x::Int64, y::Float64)` for the `Point` struct. This specific method handles the case where the first argument is an `Int64` and the second is a `Float64`. It uses `convert(Float64, x)` to explicitly convert the integer `x` to `Float64` before calling the general `Point{Float64}` constructor, thus enabling the construction `Point(1, 2.5)`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_17\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Point(x::Int64, y::Float64) = Point(convert(Float64,x),y);\n```\n\n----------------------------------------\n\nTITLE: Defining a Mutable Point Type in Julia\nDESCRIPTION: Defines a simple mutable struct 'Point' with polar coordinate fields 'r' and 'ϕ'. The Point constructor allows instantiation with floating point values, and serves as the object for subsequent property overloading demonstrations. Requires only the Julia standard library and is foundational for property interface customization. Inputs are numeric values for radius and angle; outputs a Point struct instance.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\nmutable struct Point\n    r::Float64\n    ϕ::Float64\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\np = Point(7.0, pi/4)\n```\n\n----------------------------------------\n\nTITLE: Using Julia `let` to Fix Closure Variable Capture in Loops\nDESCRIPTION: Solves the closure issue from the previous example using a `let` block inside the `while` loop. `let i = i` creates a new, distinct local variable `i` for each iteration, initialized with the current value of the outer `i`. Each closure now captures its own unique iteration-local `i`, resulting in the expected behavior where `Fs[1]()` returns 1 and `Fs[2]()` returns 2.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_20\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> Fs = Vector{Any}(undef, 2); i = 1;\n\njulia> while i <= 2\n           let i = i\n               Fs[i] = ()->i\n           end\n           global i += 1\n       end\n\njulia> Fs[1]()\n1\n\njulia> Fs[2]()\n2\n```\n```\n\n----------------------------------------\n\nTITLE: Documenting Numeric Data Format Functions - Julia - Julia\nDESCRIPTION: Lists utility functions for converting and parsing numeric data formats in Julia, gathered into a @docs block for inclusion in automated documentation. These functions provide conversions between types, bitstring representations, and hexadecimal encoding/decoding. The referenced names must correspond to available functions in Julia Base; this snippet is designed for documentation build tools, not for execution.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/numbers.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nBase.digits\\nBase.digits!\\nBase.bitstring\\nBase.parse\\nBase.tryparse\\nBase.big\\nBase.signed\\nBase.unsigned\\nBase.float(::Any)\\nBase.Math.significand\\nBase.Math.exponent\\nBase.complex(::Complex)\\nBase.bswap\\nBase.hex2bytes\\nBase.hex2bytes!\\nBase.bytes2hex\\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Updating (Mutating) Operators in Julia - Julia\nDESCRIPTION: This snippet presents the use of updating operators (e.g., +=) that update and rebind the left-hand variable with the result of the operation. It shows initializing a value, updating it with an operator, and checking the variable's value afterward. This is standard Julia code with no dependencies; updating operators can implicitly change the variable's type, as further explained in a related snippet.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = 1\n1\n\njulia> x += 3\n4\n\njulia> x\n4\n```\n\n----------------------------------------\n\nTITLE: Defining and Installing a Custom Date Locale in Julia\nDESCRIPTION: Shows the construction of French language lists for months and days, their abbreviations, and how to register a custom DateLocale with the Dates.LOCALES registry. Key parameters are vectors of localized strings. This enables further locale-based querying.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\njulia> french_months = [\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\",\n                        \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\"];\n\njulia> french_months_abbrev = [\"janv\",\"févr\",\"mars\",\"avril\",\"mai\",\"juin\",\n                              \"juil\",\"août\",\"sept\",\"oct\",\"nov\",\"déc\"];\n\njulia> french_days = [\"lundi\",\"mardi\",\"mercredi\",\"jeudi\",\"vendredi\",\"samedi\",\"dimanche\"];\n\njulia> Dates.LOCALES[\"french\"] = Dates.DateLocale(french_months, french_months_abbrev, french_days, [\"\"]);\n```\n\n----------------------------------------\n\nTITLE: Replacing Array Elements Based on Condition in MATLAB\nDESCRIPTION: MATLAB uses logical indexing for assignment to replace elements that meet a specific condition.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_26\n\nLANGUAGE: matlab\nCODE:\n```\nA(A < threshold) = 0\n```\n\n----------------------------------------\n\nTITLE: Discouraged Base Type Overloading for Custom Display - Julia - julia\nDESCRIPTION: An example of extending the Base.show method for Vector{MyType} to customize how vectors are displayed. Altering standard display methods for built-in container types can lead to unexpected behaviors and should be avoided. The pattern does not require any additional packages, but it is demonstrated as something to avoid rather than to implement.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nshow(io::IO, v::Vector{MyType}) = ...\n\n```\n\n----------------------------------------\n\nTITLE: Importing Specific Identifiers with `using` in Julia\nDESCRIPTION: Demonstrates importing only specified identifiers (`nice`, `DOG`) from the `NiceStuff` module using the `using .ModuleName: identifier1, identifier2` syntax. The module name itself (`NiceStuff`) is not brought into the current namespace by this statement.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_8\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using .NiceStuff: nice, DOG\n```\n\n----------------------------------------\n\nTITLE: Determining the Type of an Anonymous Function (Closure) in Julia\nDESCRIPTION: Creates an anonymous function (closure) `x -> x + 1` and uses `typeof` to inspect its type. The output shows a generated name (like `var\"#9#10\"`), indicating that closures have their own distinct types, separate from named functions or other closures.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_53\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> typeof(x -> x + 1)\nvar\"#9#10\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Shared State in Distributed Loops in Julia\nDESCRIPTION: Demonstrates an anti-pattern: trying to update a shared array across processes using a parallel for loop. Each process receives its own copy of 'a', so the array will not be initialized as intended. Highlights limitations of memory sharing across processes in Julia's distributed computation. No dependencies other than standard library, but not functionally correct.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\na = zeros(100000)\n@distributed for i = 1:100000\n    a[i] = i\nend\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Auto-Vectorization with VecElement in Julia\nDESCRIPTION: Provides an example demonstrating how Julia's compiler *might* auto-vectorize operations on tuples of `VecElement{Float32}` when compiled with `-O3`. It defines an `add` function for element-wise addition on `m128` (a type alias for `NTuple{4,VecElement{Float32}}`) and uses `code_native` to show that the `triple` function can generate SIMD `addps` instructions. However, this auto-vectorization is not guaranteed and future use relies more on libraries using `llvmcall`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/simd-types.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nconst m128 = NTuple{4,VecElement{Float32}}\n\nfunction add(a::m128, b::m128)\n    (VecElement(a[1].value+b[1].value),\n     VecElement(a[2].value+b[2].value),\n     VecElement(a[3].value+b[3].value),\n     VecElement(a[4].value+b[4].value))\nend\n\ntriple(c::m128) = add(add(c,c),c)\n\ncode_native(triple,(m128,))\n```\n\n----------------------------------------\n\nTITLE: Merging Environment Maps in a Julia Environment Stack\nDESCRIPTION: Julia code demonstrating how the `roots`, `graph`, and `paths` dictionaries from multiple environments (`envᵢ` represented by `rootsᵢ`, `graphᵢ`, `pathsᵢ`) in an environment stack are merged using `reduce` and `merge`. The `reverse` function is used because `merge` prioritizes the keys from later arguments in case of collisions, ensuring that environments appearing earlier in the `LOAD_PATH` stack take precedence.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nroots = reduce(merge, reverse([roots₁, roots₂, …]))\\ngraph = reduce(merge, reverse([graph₁, graph₂, …]))\\npaths = reduce(merge, reverse([paths₁, paths₂, …]))\n```\n\n----------------------------------------\n\nTITLE: Defining a Concrete AbstractArray Subtype Without Parameters - Julia\nDESCRIPTION: This snippet defines BitVector as a concrete subtype of AbstractArray with fixed parameters (element type Bool and dimension 1). It demonstrates that not all subtypes of AbstractArray declare explicit type parameters, causing issues with introspective methods relying on parameter lists. No dependencies are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\nstruct BitVector <: AbstractArray{Bool, 1}; end\n```\n\n----------------------------------------\n\nTITLE: Documenting Multiplication Operator and Overloads - Julia - Julia\nDESCRIPTION: This code block provides two docstring examples for the generic multiplication operator function (*) in Julia: one for generic arguments and one for AbstractString arguments. The generic docstring describes n-ary multiplication, while the string variant explains concatenation behavior. This pattern demonstrates documenting both general and overload-specific behaviors for operators.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\n    *(x, y, z...)\n\nMultiplication operator. `x * y * z *...` calls this function with multiple\narguments, i.e. `*(x, y, z...)`.\n\"\"\"\nfunction *(x, y, z...)\n    # ... [implementation sold separately] ...\nend\n\n\"\"\"\n    *(x::AbstractString, y::AbstractString, z::AbstractString...)\n\nWhen applied to strings, concatenates them.\n\"\"\"\nfunction *(x::AbstractString, y::AbstractString, z::AbstractString...)\n    # ... [insert secret sauce here] ...\nend\n```\n\n----------------------------------------\n\nTITLE: Calling C Function with SIMD Arguments from Julia\nDESCRIPTION: Illustrates how to call a C function (like `dist`) that uses native SIMD types (`__m256`) from Julia. It defines a corresponding Julia type `m256` as `NTuple{8, VecElement{Float32}}`, creates instances of this type, and uses `@ccall` to invoke the C function, passing and receiving the SIMD values. Requires appropriate hardware support (AVX).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\nconst m256 = NTuple{8, VecElement{Float32}}\n\na = m256(ntuple(i -> VecElement(sin(Float32(i))), 8))\nb = m256(ntuple(i -> VecElement(cos(Float32(i))), 8))\n\nfunction call_dist(a::m256, b::m256)\n    @ccall \"libdist\".dist(a::m256, b::m256)::m256\nend\n\nprintln(call_dist(a,b))\n```\n\n----------------------------------------\n\nTITLE: Zero-Argument Function Calls in Julia\nDESCRIPTION: Calling a function with zero arguments in Julia requires empty parentheses `()`, unlike MATLAB where they are often optional.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nrand()\n```\n\n----------------------------------------\n\nTITLE: Nested Quoting and Multi-Level Interpolation in Julia\nDESCRIPTION: Demonstrates how quote expressions can be nested and how interpolation with one or two dollar signs ($, $$) results in shallow or deep evaluation, respectively. This enables construction of code that is evaluated at different macro or runtime levels. Inputs: Expr and variables; outputs: nested quoted Exprs or their values after eval.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = :(1 + 2);\n\njulia> e = quote quote $x end end\nquote\n    #= none:1 =#\n    $(Expr(:quote, quote\n    #= none:1 =#\n    $(Expr(:$, :x))\nend))\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> eval(e)\nquote\n    #= none:1 =#\n    1 + 2\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> e = quote quote $$x end end\nquote\n    #= none:1 =#\n    $(Expr(:quote, quote\n    #= none:1 =#\n    $(Expr(:$, :(1 + 2)))\nend))\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> eval(e)\nquote\n    #= none:1 =#\n    3\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Type Alias for Parametric Types in Julia\nDESCRIPTION: Defines `Vector{T}` as a shorthand alias for `Array{T, 1}` using concise function-like syntax. This is equivalent to `const Vector = Array{T,1} where T`, creating a convenient alias for the abstract type representing all one-dimensional arrays.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_48\n\nLANGUAGE: julia\nCODE:\n```\nVector{T} = Array{T, 1}\n```\n\n----------------------------------------\n\nTITLE: Defining main Function Without @main Opt-in (Bash/Julia)\nDESCRIPTION: Demonstrates that simply defining a function named `main` inline using `-e` without using the `@main` macro does not trigger automatic execution upon script completion. The `@main` macro is required to explicitly opt into this behavior for the `Main.main` function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ julia -e 'main(args) = println(\"Hello World!\")'\n```\n\n----------------------------------------\n\nTITLE: Lexical Scoping with Function Calls in Julia\nDESCRIPTION: This example shows that a function `f` defined in the global scope captures variables based on lexical scope at the time of definition. Calling `f` inside a `let` block that redefines `x` does not change the value of `x` observed by `f`, which still refers to the global `x`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nx = 1\nf() = @show x\nlet x = 5\n    f() # 1\nend\nf() # 1\n```\n\n----------------------------------------\n\nTITLE: Documenting Date and Time Formatter Types in Julia (Julia)\nDESCRIPTION: This @docs macro documents several formatter types for displaying or parsing dates/times in standardized ways: ISODateTimeFormat, ISODateFormat, ISOTimeFormat, and RFC1123Format. Used throughout Julia for formatting/parsing compliance with international date formats and HTTP headers. Inputs are generally format strings or constructors, outputs are format objects used with format/parse operations. Dependencies: Dates module. Not directly a function call, but type or object definitions.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\nISODateTimeFormat\nISODateFormat\nISOTimeFormat\nRFC1123Format\n```\n\n----------------------------------------\n\nTITLE: Defining a Package with an @main Entry Point (Julia)\nDESCRIPTION: Defines a simple Julia module `Hello` that exports a `main` function. The `@main` macro is applied to this function definition within the module, making `Hello.main` eligible for automatic execution when the package containing this module is loaded in a way that brings `main` into the `Main` namespace (e.g., via `using Hello`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nmodule Hello\n\nexport main\n(@main)(args) = println(\"Hello from the package!\")\n\nend\n```\n\n----------------------------------------\n\nTITLE: Requiring and Checking Array Indexing Styles in JuliaDoc - Julia\nDESCRIPTION: Documents functions for enforcing and examining Julia array offset/indexing conventions. The snippet uses the `@docs` macro to generate documentation for functions like `require_one_based_indexing` and `has_offset_axes`, useful for authors implementing custom array types or needing index safety checks. Assumes user context within array indexing APIs in Julia. Input/output is for documentation purposes only.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/arrays.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.require_one_based_indexing\nBase.has_offset_axes\n```\n```\n\n----------------------------------------\n\nTITLE: GC Rooting an Array of Julia Values in C using JL_GC_PUSHARGS\nDESCRIPTION: Shows how to use the `JL_GC_PUSHARGS` macro to root an array of `jl_value_t*` pointers on the C stack. This is useful when dealing with a variable number of arguments or more than six values. The macro takes the array pointer and its size. Remember to pair with `JL_GC_POP`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_15\n\nLANGUAGE: c\nCODE:\n```\njl_value_t **args;\nJL_GC_PUSHARGS(args, 2); // args can now hold 2 `jl_value_t*` objects\nargs[0] = some_value;\nargs[1] = some_other_value;\n// Do something with args (e.g. call jl_... functions)\nJL_GC_POP();\n```\n\n----------------------------------------\n\nTITLE: Using `let` Blocks to Avoid Global Variable Propagation in Julia Remote Calls\nDESCRIPTION: Illustrates how to prevent unintended global variable creation on remote workers. Global `A` is referenced directly in a remote call, causing `Main.A` to be defined on worker 2. Global `B` is referenced inside a `let B = B` block within the closure passed to `remotecall_fetch`. This captures the *value* of `B` lexically, so the closure sent to worker 2 references a local variable, and `Main.B` is *not* defined on worker 2. The `varinfo()` output from worker 2 confirms only `A` exists globally there.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_15\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> A = rand(10,10);\n\njulia> remotecall_fetch(()->A, 2);\n\njulia> B = rand(10,10);\n\njulia> let B = B\n           remotecall_fetch(()->B, 2)\n       end;\n\njulia> @fetchfrom 2 InteractiveUtils.varinfo()\nname           size summary\n––––––––– ––––––––– ––––––––––––––––––––––\nA         800 bytes 10×10 Array{Float64,2}\nBase                Module\nCore                Module\nMain                Module\n```\n\n----------------------------------------\n\nTITLE: Using Anonymous Functions for Conditional Logic in Julia\nDESCRIPTION: This Julia snippet presents the recommended approach for achieving conditional behavior similar to the problematic `f2` example. Instead of conditionally defining named methods, it uses an `if/else` expression to assign the appropriate anonymous function (`x -> x + 1` or `x -> x - 1`) to the local variable `g`. This ensures clear and predictable behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_55\n\nLANGUAGE: julia\nCODE:\n```\nfunction f2(inc)\n    g = if inc\n        x -> x + 1\n    else\n        x -> x - 1\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Running External Commands and Capturing Output - Julia\nDESCRIPTION: Demonstrates running a Cmd object using the run function to execute an external command, sending output to stdout, and showcases how to read output as a String or a chomped String using read or readchomp. Useful for capturing external command results within Julia. Requires that the invoked programs (e.g., echo) are available on the system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> run(mycommand);\nhello\n```\n```\n\nLANGUAGE: jldoctest\njulia> read(`echo hello`, String)\n\"hello\\n\"\n\njulia> readchomp(`echo hello`)\n\"hello\"\n```\nCODE:\n```\nundefined\n```\n\n----------------------------------------\n\nTITLE: Obtaining a Sort Permutation Vector - Julia\nDESCRIPTION: Demonstrates how to compute a permutation vector that orders an array, then apply it to access the sorted values. This technique is useful for indirect sorting or when tracking element movement is important. Standard Base functions sortperm and array indexing are used.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/sort.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia-repl\\njulia> v = randn(5)\\n5-element Vector{Float64}:\\n  0.297288\\n  0.382396\\n -0.597634\\n -0.0104452\\n -0.839027\\n\\njulia> p = sortperm(v)\\n5-element Vector{Int64}:\\n 5\\n 3\\n 4\\n 1\\n 2\\n\\njulia> v[p]\\n5-element Vector{Float64}:\\n -0.839027\\n -0.597634\\n -0.0104452\\n  0.297288\\n  0.382396\n```\n\n----------------------------------------\n\nTITLE: Sorting by a Key Function and in Reverse - Julia\nDESCRIPTION: Shows how to combine by with the rev keyword for sorting by a transformed value in descending order. An example is given for sorting by the absolute value of array elements in reverse. Requires only Julia Base and works on arrays of any comparable numeric type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/sort.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia-repl\\njulia> sort(v, by=abs, rev=true)\\n5-element Vector{Float64}:\\n -0.839027\\n -0.597634\\n  0.382396\\n  0.297288\\n -0.0104452\n```\n\n----------------------------------------\n\nTITLE: Inspecting Types with typeof in Julia\nDESCRIPTION: Shows how to use the typeof function to retrieve the type of a given object, including types themselves. Provides insight into Julia's type system hierarchy, illustrating that types are also objects with types, such as DataType and Union. No dependencies beyond core Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_64\n\nLANGUAGE: julia\nCODE:\n```\ntypeof(Rational{Int})\\ntypeof(Union{Real,String})\n```\n\n----------------------------------------\n\nTITLE: Throwing ErrorException Using error() - Julia\nDESCRIPTION: A new function fussy_sqrt is defined that computes the square root if input is non-negative and raises a descriptive error otherwise. The error function creates and throws an ErrorException, halting execution and displaying a custom message. No external dependencies; limitations: only real numeric types are valid for input.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\njulia> fussy_sqrt(x) = x >= 0 ? sqrt(x) : error(\"negative x not allowed\")\nfussy_sqrt (generic function with 1 method)\n\njulia> fussy_sqrt(2)\n1.4142135623730951\n\njulia> fussy_sqrt(-1)\nERROR: negative x not allowed\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] fussy_sqrt(::Int64) at ./none:1\n [3] top-level scope\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Arrays Filled with `missing` Values in Julia\nDESCRIPTION: Shows the recommended method for creating an array (e.g., a `Matrix`) that is initialized entirely with `missing` values. This is done by specifying the element type as `Union{Missing, T}` (where `T` is the intended non-missing type) and passing `missing` along with the desired dimensions to the `Array` constructor.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_12\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Array{Union{Missing, String}}(missing, 2, 3)\n2×3 Matrix{Union{Missing, String}}:\n missing  missing  missing\n missing  missing  missing\n```\n\n----------------------------------------\n\nTITLE: Detailed Allocation Profiling Workflow in Julia REPL\nDESCRIPTION: This Julia REPL session demonstrates a more complete workflow for allocation profiling. It includes estimating total allocations using `@time`, clearing profiler data, running `Profile.Allocs.@profile` with a tuned `sample_rate`, fetching the results (`Profile.Allocs.fetch()`), inspecting the number of samples, and visualizing the profile using `PProf.Allocs.pprof()`, excluding C frames. Requires `Profile` and `PProf` packages.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_14\n\nLANGUAGE: julia-repl\nCODE:\n```\n```julia-repl\njulia> import Profile\n\njulia> @time my_function()  # Estimate allocations from a (second-run) of the function\n  0.110018 seconds (1.50 M allocations: 58.725 MiB, 17.17% gc time)\n500000\n\njulia> Profile.Allocs.clear()\n\njulia> Profile.Allocs.@profile sample_rate=0.001 begin   # 1.5 M * 0.001 = ~1.5K allocs.\n           my_function()\n       end\n500000\n\njulia> prof = Profile.Allocs.fetch();  # If you want, you can also manually inspect the results.\n\njulia> length(prof.allocs)  # Confirm we have expected number of allocations.\n1515\n\njulia> using PProf  # Now, visualize with an external tool, like PProf or ProfileCanvas.\n\njulia> PProf.Allocs.pprof(prof; from_c=false)  # You can optionally pass in a previously fetched profile result.\nAnalyzing 1515 allocation samples... 100%|████████████████████████████████| Time: 0:00:00\nMain binary filename not available.\nServing web UI on http://localhost:62261\n\"alloc-profile.pb.gz\"\n```\n```\n\n----------------------------------------\n\nTITLE: Indexing skipmissing Iterator and Handling Errors in Julia\nDESCRIPTION: Demonstrates how objects created by `skipmissing` support indexing using the parent array's indices, but throw a `MissingException` if a missing value's index is accessed. This is useful for robust code that warns when indexing falls on a missing entry. Inputs are arrays wrapped with `skipmissing`, and indexing is performed. Output is element retrieval or an error if the value was missing. Limitations: Indices for missing values cannot be used.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\njulia> x[1]\n3\n\njulia> x[2]\nERROR: MissingException: the value at index (2,) is missing\n[...]\n```\n\n----------------------------------------\n\nTITLE: Forcing Specialization with Vararg Type Parameter - Julia\nDESCRIPTION: Shows how to force Julia to specialize on the number of arguments for Any-typed Varargs by introducing an explicit type parameter N. Useful for functions that need to accept arguments of different types and get specialized versions for each argument count.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\nh_vararg(x::Vararg{Any, N}) where {N} = tuple(x...)\n```\n\n----------------------------------------\n\nTITLE: Defining a Julia Function with an Explicit Return Type Declaration\nDESCRIPTION: Illustrates how to declare the return type of a Julia function using the `::TypeName` syntax after the function signature. The function `g(x, y)::Int8` is defined to always return a value converted to the `Int8` type, regardless of the types of `x` and `y`. The `typeof` call confirms the return type is indeed `Int8`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_11\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function g(x, y)::Int8\n           return x * y\n       end;\n\njulia> typeof(g(1, 2))\nInt8\n```\n\n----------------------------------------\n\nTITLE: Enforcing Function Return Type with :: in Julia\nDESCRIPTION: This Julia snippet shows how to enforce a specific return type (Float64) for a function using the :: operator. The value returned by the function is always converted to the declared type. Parameters, such as x, are used in the calculation, and care should be taken that the conversion to the output type is valid. No external dependencies are necessary.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nfunction sinc(x)::Float64\n    if x == 0\n        return 1\n    end\n    return sin(pi*x)/(pi*x)\nend\n```\n\n----------------------------------------\n\nTITLE: Equivalent Nested Scope Creation using Julia `let` with Assignment\nDESCRIPTION: Presents an alternative syntax achieving the same nested scope effect as the zero-argument `let` example. Here, `let x = 1` explicitly creates the outer scope and its local variable `x`. The inner `let x = 2` creates a nested scope with its own distinct local `x`. The outer `x` retains its value (1), which is returned by the outer `let` block.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_22\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> let x = 1\n           let x = 2\n           end\n           x\n       end\n1\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous Functions in Julia - Julia\nDESCRIPTION: Shows two syntaxes for creating anonymous functions in Julia: the arrow form and a function block style. Both create a function of one parameter that computes a quadratic polynomial. These functions can be used immediately or passed to higher-order functions. No dependencies required. Input is a single numeric argument; output is the polynomial result. Names are compiler-generated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_15\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x -> x^2 + 2x - 1\n#2 (generic function with 1 method)\n\njulia> function (x)\n           x^2 + 2x - 1\n       end\n#5 (generic function with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Observing Effects of Pass-by-Sharing in Julia REPL\nDESCRIPTION: This Julia REPL session demonstrates the effects of calling the previously defined function `f` which exemplifies pass-by-sharing. An array `a` and an integer `b` are defined. Calling `f(a, b)` modifies the content of `a` (because arrays are mutable) but leaves `b` unchanged (because the function rebinds `y` locally instead of mutating the original immutable integer).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_6\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> a = [4, 5, 6]\n3-element Vector{Int64}:\n 4\n 5\n 6\n\njulia> b = 3\n3\n\njulia> f(a, b) # returns 7 + b == 10\n10\n\njulia> a  # a[1] is changed to 42 by f\n3-element Vector{Int64}:\n 42\n  5\n  6\n\njulia> b  # not changed\n3\n```\n\n----------------------------------------\n\nTITLE: Illustrating Module Scope Differences Across Julia Processes\nDESCRIPTION: Shows that after loading `DummyModule` everywhere using `@everywhere include`, `using .DummyModule` only brings it into scope on the main process (where `using` is called). Attempting to use `MyType(7)` directly on worker 2 via `fetch(@spawnat 2 MyType(7))` fails with `UndefVarError`. However, using the fully qualified name `DummyModule.MyType(7)` succeeds because the module *is* loaded on the worker, even if not in its `Main` scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_7\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using .DummyModule\n\njulia> MyType(7)\nMyType(7)\n\njulia> fetch(@spawnat 2 MyType(7))\nERROR: On worker 2:\nUndefVarError: `MyType` not defined in `Main`\n⋮\n\njulia> fetch(@spawnat 2 DummyModule.MyType(7))\nMyType(7)\n```\n\n----------------------------------------\n\nTITLE: Accessing Match Details from RegexMatch Object in Julia\nDESCRIPTION: Details how to retrieve information from a `RegexMatch` object (`m`) returned by `match`. It shows accessing the full matched substring (`m.match`), an array of captured substrings (`m.captures`), the starting offset of the match (`m.offset`), and a vector of offsets for captured substrings (`m.offsets`). Explains how `nothing` and zero offsets indicate non-matching captures.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_48\n\nLANGUAGE: jldoctest acdmatch\nCODE:\n```\njulia> m = match(r\"(a|b)(c)?(d)\", \"acd\")\nRegexMatch(\"acd\", 1=\"a\", 2=\"c\", 3=\"d\")\n\njulia> m.match\n\"acd\"\n\njulia> m.captures\n3-element Vector{Union{Nothing, SubString{String}}}:\n \"a\"\n \"c\"\n \"d\"\n\njulia> m.offset\n1\n\njulia> m.offsets\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> m = match(r\"(a|b)(c)?(d)\", \"ad\")\nRegexMatch(\"ad\", 1=\"a\", 2=nothing, 3=\"d\")\n\njulia> m.match\n\"ad\"\n\njulia> m.captures\n3-element Vector{Union{Nothing, SubString{String}}}:\n \"a\"\n nothing\n \"d\"\n\njulia> m.offset\n1\n\njulia> m.offsets\n3-element Vector{Int64}:\n 1\n 0\n 2\n```\n\n----------------------------------------\n\nTITLE: Avoiding Recursion in Julia Method Cascades Using Explicit Types\nDESCRIPTION: This Julia code demonstrates a robust design pattern for method cascades with default arguments, avoiding infinite recursion. It introduces a `NoPad` struct to explicitly signal that padding is complete or not needed. The default method calls the padding method, which then calls the core computation method using `NoPad`, breaking the potential recursive loop found in simpler designs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_52\n\nLANGUAGE: julia\nCODE:\n```\nstruct NoPad end  # indicate that no padding is desired, or that it's already applied\n\nmyfilter(A, kernel) = myfilter(A, kernel, Replicate())  # default boundary conditions\n\nfunction myfilter(A, kernel, ::Replicate)\n    Apadded = replicate_edges(A, size(kernel))\n    myfilter(Apadded, kernel, NoPad())  # indicate the new boundary conditions\nend\n\n# other padding methods go here\n\nfunction myfilter(A, kernel, ::NoPad)\n    # Here's the \"real\" implementation of the core computation\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Global Constants in Julia using `const`\nDESCRIPTION: Demonstrates how to declare global constants (`e`, `pi`) in Julia using the `const` keyword in the global scope. This informs the compiler that the variable binding itself (the association between the name and the value) will not change, which can enable performance optimizations. Note that `const` applies only in global scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_26\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> const e  = 2.71828182845904523536;\n\njulia> const pi = 3.14159265358979323846;\n```\n```\n\n----------------------------------------\n\nTITLE: Handling `missing` with Logical OR (`|`) - Propagation Case in Julia\nDESCRIPTION: Illustrates the propagation of `missing` with the logical OR operator (`|`) when one operand is `false`. In this scenario, the result depends on the value of the other operand. Since the other operand is `missing` (unknown), the overall result is also `missing`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> false | true\ntrue\n\njulia> true | false\ntrue\n\njulia> false | false\nfalse\n\njulia> false | missing\nmissing\n\njulia> missing | false\nmissing\n```\n\n----------------------------------------\n\nTITLE: Defining Julia Struct Equivalent to C Struct with Array\nDESCRIPTION: Shows the Julia equivalent of a C struct containing a fixed-size array. The array `A` is defined using `NTuple{3, Cint}`, ensuring proper memory layout compatibility with the C version. It also notes the difference in indexing conventions (1-based in Julia vs. 0-based in C).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nstruct B\n    A::NTuple{3, Cint}\nend\n\nb_a_2 = B.A[3]  # note the difference in indexing (1-based in Julia, 0-based in C)\n```\n\n----------------------------------------\n\nTITLE: Documenting Rounding Functions in Julia Dates (Julia)\nDESCRIPTION: This @docs code block documents the use of the Base.floor, Base.ceil, and Base.round methods for Julia Dates types. These functions enable rounding of Date and DateTime values to resolutions like months or minutes, with custom rounding modes. Dependencies include Julia 1.x and use of the Dates standard library; main parameters are TimeType objects, Periods, and optionally a RoundingMode. Returns a new time value rounded as specified. Constraints: Works only with compatible Date/Time types and period inputs.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nBase.floor(::Dates.TimeType, ::Dates.Period)\nBase.ceil(::Dates.TimeType, ::Dates.Period)\nBase.round(::Dates.TimeType, ::Dates.Period, ::RoundingMode{:NearestTiesUp})\n```\n\n----------------------------------------\n\nTITLE: Remote Computation with Local Data Creation in Julia (@spawnat)\nDESCRIPTION: This snippet demonstrates Method 1 for remote computation. A large random matrix `A` is created on the local process. Then, `@spawnat :any A^2` sends this potentially large matrix `A` to an arbitrary worker process for squaring. The result (a future) is stored in `Bref`, and `fetch(Bref)` retrieves the computed matrix back to the local process. This approach involves significant data transfer *to* the worker.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_11\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> A = rand(1000,1000);\n\njulia> Bref = @spawnat :any A^2;\n\n[...]\n\njulia> fetch(Bref);\n```\n\n----------------------------------------\n\nTITLE: Defining Fortran Subroutine with Variable Length Strings\nDESCRIPTION: Example Fortran subroutine definition that accepts two variable-length string arguments (`character(len=*)`). This is used to illustrate how Fortran compilers handle such arguments by passing hidden length arguments, which need to be accounted for when calling from Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_14\n\nLANGUAGE: fortran\nCODE:\n```\nsubroutine test(str1, str2)\ncharacter(len=*) :: str1,str2\n```\n\n----------------------------------------\n\nTITLE: Fetching and Taking Elements After Channel Closure in Julia REPL\nDESCRIPTION: Demonstrates the behavior of fetch and take! on a closed channel in Julia, showing that fetch can return remaining values multiple times, but take! removes them and returns an error when empty. Requires a previously closed channel with values remaining. The snippet should be executed in the Julia REPL, and responses are printed directly. Shows how closed channels still allow draining preexisting items but error on empty.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/asynchronous-programming.md#_snippet_8\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> fetch(c) # Any number of `fetch` calls succeed.\n1\n\njulia> fetch(c)\n1\n\njulia> take!(c) # The first `take!` removes the value.\n1\n\njulia> take!(c) # No more data available on a closed channel.\nERROR: InvalidStateException: Channel is closed.\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Simple Triple-Quoted String in Julia\nDESCRIPTION: A basic example showing a single-line string defined using triple quotes. In this simple case, it behaves like a standard double-quoted string.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"hello\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Referencing Artifact Management API Endpoints - Julia\nDESCRIPTION: This snippet generates API documentation references for key functions and macros in the Artifacts module, such as artifact_meta, artifact_hash, find_artifacts_toml, @artifact_str, artifact_exists, artifact_path, and select_downloadable_artifacts. It uses Julia's documentation tools to automatically document these endpoints within the documentation output, facilitating discoverability for users and developers. No additional dependencies are needed beyond Julia 1.6 and the Artifacts module.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Artifacts/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nArtifacts.artifact_meta\nArtifacts.artifact_hash\nArtifacts.find_artifacts_toml\nArtifacts.@artifact_str\nArtifacts.artifact_exists\nArtifacts.artifact_path\nArtifacts.select_downloadable_artifacts\n```\n```\n\n----------------------------------------\n\nTITLE: Saving Profile Results to a File with Custom Display Size in Julia\nDESCRIPTION: Illustrates how to save profiling results to a file (`/tmp/prof.txt`) while controlling the output width. It uses an `open` block to manage the file stream and passes an `IOContext` to `Profile.print`, setting the `:displaysize` property to `(24, 500)` to ensure wider lines for deeply nested code, preventing truncation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nopen(\"/tmp/prof.txt\", \"w\") do s\n    Profile.print(IOContext(s, :displaysize => (24, 500)))\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Julia Function with Exception Handling (Julia)\nDESCRIPTION: This Julia code defines a function `foo` containing a `try-catch` block. It initializes variables `x` and `y`, calls an opaque function (`opaque`), potentially modifies `y` again, and then explicitly throws an error within the `try` block. The `catch` block is empty. The function returns a tuple `(x, y)`. This function serves as the source code for demonstrating Julia's SSA IR representation of exception handling using PhiC and Upsilon nodes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n@noinline opaque() = invokelatest(identity, nothing) # Something opaque\nfunction foo()\n    local y\n    x = 1\n    try\n        y = 2\n        opaque()\n        y = 3\n        error()\n    catch\n    end\n    (x, y)\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing Arrays with Undef Argument - Julia\nDESCRIPTION: Demonstrates the updated way to construct uninitialized arrays and vectors by passing 'undef' as the first argument in constructors. Dependencies include Julia Base, with no additional packages required. Key parameters are type, dimensionality, and shape; inputs are types and dimensions, outputs are uninitialized arrays with specified properties. Prior approaches using just size/shape in the constructor are deprecated.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_149\n\nLANGUAGE: julia\nCODE:\n```\nVector(undef, 3)\nMatrix{Int}(undef, (2, 4))\nArray{Float32,3}(undef, 11, 13, 17)\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Inspecting Parametric Types in Julia\nDESCRIPTION: Shows how concrete types like `Point{Float64}` and `Point{AbstractString}` are derived from the parametric type `Point{T}` by specifying the type parameter. It demonstrates subtype relationships: concrete `Point` types are subtypes of the general `Point` type (`Point{Float64} <: Point`), but unrelated types are not (`Float64 <: Point` is false). Crucially, it illustrates the *invariance* of Julia's type parameters: `Point{Float64}` is not a subtype of `Point{Int64}` or `Point{Real}`, even though `Float64 <: Real`. This means the type parameter must match exactly for subtyping between parametric types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_23\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Point{Float64}\nPoint{Float64}\n\njulia> Point{AbstractString}\nPoint{AbstractString}\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Point{Float64} <: Point\ntrue\n\njulia> Point{AbstractString} <: Point\ntrue\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Float64 <: Point\nfalse\n\njulia> AbstractString <: Point\nfalse\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Point{Float64} <: Point{Int64}\nfalse\n\njulia> Point{Float64} <: Point{Real}\nfalse\n```\n\n----------------------------------------\n\nTITLE: Comparing `eval` on Quoted Expressions vs. `QuoteNode` in Julia\nDESCRIPTION: Illustrates the difference between evaluating a standard quoted expression with interpolation (`Meta.quot(Expr(:$, :(1+2)))`) which executes the interpolated code, and evaluating a `QuoteNode` which treats the content literally, preventing interpolation and evaluation of the `$` expression.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_12\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> eval(Meta.quot(Expr(:$, :(1+2))))\n3\n\njulia> eval(QuoteNode(Expr(:$, :(1+2))))\n:($(Expr(:$, :(1 + 2))))\n```\n\n----------------------------------------\n\nTITLE: Controlling Bounds Checking (Julia Flag)\nDESCRIPTION: The `--check-bounds` command-line flag controls whether Julia performs runtime array bounds checking. An exact match of this flag is required for a package image cache to be valid, as it alters generated code.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n--check-bounds\n```\n\n----------------------------------------\n\nTITLE: Checking Type Properties of Julia `Array`\nDESCRIPTION: Uses Julia's introspection functions (`isconcretetype`, `isabstracttype`, `isstructtype`) to demonstrate that the base `Array` type itself is not concrete, while fully specified types like `Array{Int,1}` are concrete. This reinforces the recommendation to avoid declaring struct fields simply as `a::Array` and instead use specific parameterization like `a::Array{T,N}`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_17\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> !isconcretetype(Array), !isabstracttype(Array), isstructtype(Array), !isconcretetype(Array{Int}), isconcretetype(Array{Int,1})\n(true, true, true, true, true)\n```\n\n----------------------------------------\n\nTITLE: Documenting C Standard Library Bindings in Julia - Julia\nDESCRIPTION: This code snippet uses Julia's `@docs` macro to document several symbols from the Base.Libc module, which acts as an interface to C standard library functions and structures within Julia. It includes memory management (e.g., malloc, calloc), string and memory manipulation (e.g., memcpy, memset), error handling (e.g., errno, strerror), time formatting and conversion, as well as file and system call interfaces. Each identifier listed will be included in Julia's documentation generation process, ensuring that users have access to detailed API references. This snippet requires that the Base.Libc module is available and is intended for inclusion in generated documentation; it does not execute any runtime logic. Inputs are the symbol names; output is structured documentation for each listed item.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/libc.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.Libc.malloc\nBase.Libc.calloc\nBase.Libc.realloc\nBase.Libc.memcpy\nBase.Libc.memmove\nBase.Libc.memset\nBase.Libc.memcmp\nBase.Libc.free\nBase.Libc.errno\nBase.Libc.strerror\nBase.Libc.GetLastError\nBase.Libc.FormatMessage\nBase.Libc.time(::Base.Libc.TmStruct)\nBase.Libc.strftime\nBase.Libc.strptime\nBase.Libc.TmStruct\nBase.Libc.FILE\nBase.Libc.dup\nBase.Libc.flush_cstdio\nBase.Libc.systemsleep\nBase.Libc.mkfifo\n```\n```\n\n----------------------------------------\n\nTITLE: Appending ! to Mutating Functions - julia\nDESCRIPTION: Presents the Julia convention of appending ! (bang) to functions that mutate at least one of their arguments. Both forms of the function for doubling array values are shown, with and without the exclamation mark. Highlights the importance of naming conventions for code clarity and communicating intent. Inputs: AbstractArray of Number; outputs: the mutated array. Relies on Julia's array and mutation syntax (for, eachindex, array indexing).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nfunction double(a::AbstractArray{<:Number})\n    for i in eachindex(a)\n        a[i] *= 2\n    end\n    return a\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction double!(a::AbstractArray{<:Number})\n    for i in eachindex(a)\n        a[i] *= 2\n    end\n    return a\nend\n```\n\n----------------------------------------\n\nTITLE: Testing a Local Julia Package and Running Tests - Julia REPL\nDESCRIPTION: This snippet demonstrates importing a Julia package ('MyPkg') from the current project directory and running a test file (typically named 'runtests.jl'). Required prerequisites include having the package source and the test file in the working directory. These commands enable iterative development and testing cycles, especially when combined with Revise.jl for automatic tracking of code changes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/workflow-tips.md#_snippet_4\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using MyPkg\n\njulia> include(\"runtests.jl\")\n```\n\n----------------------------------------\n\nTITLE: Splat Operator in Julia\nDESCRIPTION: The splat operator `...` in Julia unpacks the elements of a collection and passes them as individual arguments to a function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\n...\n```\n\nLANGUAGE: julia\nCODE:\n```\nxs=[1,2]; f(xs...)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Hygiene Problem with Macro Call Context in Julia\nDESCRIPTION: This snippet demonstrates a scenario where macro hygiene becomes crucial. A module `MyModule` defines its own `time_ns` function and then calls the imported `Base.@time` macro with `time_ns()`. Without proper handling, the `time_ns` inside the macro might incorrectly resolve to `Base.time_ns` instead of the intended `MyModule.time_ns`, showcasing the need for the called expression to be resolved in the macro's call environment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_43\n\nLANGUAGE: julia\nCODE:\n```\nmodule MyModule\nimport Base.@time\n\ntime_ns() = ... # compute something\n\n@time time_ns()\nend\n```\n\n----------------------------------------\n\nTITLE: Evaluating Expressions with Side-Effects using `eval` in Julia\nDESCRIPTION: Illustrates that `eval` can execute expressions that modify the global scope. Evaluating the expression `:(x = 1)` assigns the value `1` to the global variable `x`, which can then be accessed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_15\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> ex = :(x = 1)\n:(x = 1)\n\njulia> x\nERROR: UndefVarError: `x` not defined in `Main`\n\njulia> eval(ex)\n1\n\njulia> x\n1\n```\n\n----------------------------------------\n\nTITLE: Defining the Val Parametric Type and Constructor in Julia\nDESCRIPTION: This snippet defines the `Val{x}` struct, a parametric type that takes a value `x` as a parameter. It also defines a constructor `Val(x)` which creates an instance `Val{x}()`. This pattern allows Julia functions to dispatch based on specific values rather than just types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_76\n\nLANGUAGE: jldoctest valtype\nCODE:\n```\njulia> struct Val{x}\n       end\n\njulia> Val(x) = Val{x}()\nVal\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Array Views and Related Types - Julia\nDESCRIPTION: Lists view-related functions and types in Julia with the `@docs` macro, such as `view`, the `@view` macro, and handling parent array interfaces. Provides documentation stubs for array reshaping, slicing, and views for efficient array manipulation without copying. Built for the Julia documentation system, requires no runtime input/output.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/arrays.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.view\nBase.@view\nBase.@views\nBase.parent\nBase.parentindices\nBase.selectdim\nBase.reinterpret\nBase.reshape\nBase.insertdims\nBase.dropdims\nBase.vec\nBase.SubArray\n```\n```\n\n----------------------------------------\n\nTITLE: Building Julia in Debug Mode - Shell\nDESCRIPTION: This shell snippet demonstrates how to navigate to the Julia source root and build Julia in debug mode using 'make debug'. This process generates an executable suitable for debugging with gdb, providing necessary debugging symbols. The command should be run from within the root directory of a checked-out Julia source tree, and outputs the debug build or failures to the terminal.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/backtraces.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n\"$ cd <julia_root>\\n$ make debug\\n\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Macro with Arguments in Julia\nDESCRIPTION: Defines a macro `@sayhello` that accepts one argument `name`. Inside the macro, the argument is interpolated (`$name`) into the returned quoted expression, allowing the macro to generate customized code based on its inputs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_22\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> macro sayhello(name)\n           return :( println(\"Hello, \", $name) )\n       end\n@sayhello (macro with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Installing Juliaup via zypper on openSUSE Tumbleweed\nDESCRIPTION: Installs Juliaup using the zypper package manager on openSUSE Tumbleweed Linux distribution. This command typically requires root privileges to execute successfully.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/installation.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nzypper install juliaup\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Integer Overflow Wraparound Behavior in Julia\nDESCRIPTION: Illustrates Julia's default integer overflow behavior. Adding 1 to the maximum value of `Int64` (`typemax(Int64)`) results in the minimum value (`typemin(Int64)`), demonstrating wraparound or modular arithmetic.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> x = typemax(Int64)\n9223372036854775807\n\njulia> x + 1\n-9223372036854775808\n\njulia> x + 1 == typemin(Int64)\ntrue\n```\n```\n\n----------------------------------------\n\nTITLE: Custom Broadcasted Negation for OrdinalRange - Julia\nDESCRIPTION: Defines a custom method for optimizing broadcasted negation over ordinal ranges in Julia. This overrides broadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) to produce a new range instead of computing and allocating an array, exploiting the structure of ranges for efficient computation. Requires understanding of Julia's type system and Broadcast machinery. Input is an OrdinalRange; output is a corresponding range negated in start, step and of the same length. This improves efficiency for 1-dimensional array styles operating on ranges.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nbroadcasted(::DefaultArrayStyle{1}, ::typeof(-), r::OrdinalRange) = range(-first(r), step=-step(r), length=length(r))\n```\n\n----------------------------------------\n\nTITLE: Generating Instances of a Custom Type (Die) in Julia\nDESCRIPTION: Shows usage examples for generating instances of the custom `Die` type defined previously. It demonstrates creating a single random `Die` using `rand(Die)`, creating one with a specific RNG, generating a vector of random `Die` objects, and filling a pre-allocated vector using `rand!`. These examples rely on the prior definition of the `Die` struct and its associated `rand(rng, ::Random.SamplerType{Die})` method.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_3\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> rand(Die)\nDie(5)\n\njulia> rand(Xoshiro(0), Die)\nDie(10)\n\njulia> rand(Die, 3)\n3-element Vector{Die}:\n Die(9)\n Die(15)\n Die(14)\n\njulia> a = Vector{Die}(undef, 3); rand!(a)\n3-element Vector{Die}:\n Die(19)\n Die(7)\n Die(17)\n```\n\n----------------------------------------\n\nTITLE: Simultaneous Sine and Cosine Calculation (Degrees) in Julia\nDESCRIPTION: The `sincosd(x)` function computes both the sine and cosine of `x` simultaneously, where `x` is specified in degrees.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_114\n\nLANGUAGE: julia\nCODE:\n```\nsincosd(x)\n```\n\n----------------------------------------\n\nTITLE: Decoupling Sampler Pre-computation in Julia\nDESCRIPTION: Demonstrates how to optimize repeated random sampling from the same distribution (e.g., `1:20`) by pre-computing a `Sampler` object. The `Sampler` (`sp`) is created once using `Random.Sampler(rng, 1:20)` and then reused within the loop via `rand(rng, sp)`, avoiding redundant setup costs on each iteration.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nrng = Xoshiro()\nsp = Random.Sampler(rng, 1:20) # or Random.Sampler(Xoshiro, 1:20)\nfor x in X\n    n = rand(rng, sp) # similar to n = rand(rng, 1:20)\n    # use n\nend\n```\n\n----------------------------------------\n\nTITLE: Sending IP Multicast Packets with UDP in Julia\nDESCRIPTION: This snippet demonstrates sending a UDP multicast packet using Julia. It creates a UDPSocket and sends a string message ('Hello over IPv4') to the multicast group address and port 6789, then closes the socket. No need to join the multicast group as a sender. Inputs: Multicast address, port, and message. Output: Datagram sent to multicast group. Requires Sockets standard library and endpoint must accept UDP datagrams on the specified group/port.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nusing Sockets\ngroup = ip\"228.5.6.7\"\nsocket = Sockets.UDPSocket()\nsend(socket, group, 6789, \"Hello over IPv4\")\nclose(socket)\n```\n\n----------------------------------------\n\nTITLE: Less Efficient Parallel Remote Execution using `@spawnat` and `fetch` in Julia\nDESCRIPTION: This Julia snippet shows a less performant approach for parallel remote execution using the `Distributed` package. It first uses `@spawnat` to asynchronously start the function `foo` on each worker, storing references. Then, it retrieves results serially using `fetch`. This method incurs two network calls per worker (`@spawnat` and `fetch`) and serializes the fetching step, often resulting in poorer performance compared to using `remotecall_fetch`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_67\n\nLANGUAGE: julia\nCODE:\n```\nusing Distributed\n\nrefs = Vector{Any}(undef, nworkers())\nfor (idx, pid) in enumerate(workers())\n    refs[idx] = @spawnat pid foo(args...)\nend\nresponses = [fetch(r) for r in refs]\n```\n\n----------------------------------------\n\nTITLE: Avoiding Parentheses in Conditions - Anti-pattern Example - Julia - julia\nDESCRIPTION: Shows a discouraged code pattern in Julia where parentheses are unnecessarily used around the test condition in an if statement. This example does not require any dependencies. While it is syntactically allowed, it is non-idiomatic and should be avoided for clarity and consistency. This is provided as a contrast to best practices and should not be imitated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nif (a == b)\n\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of Julia's Automatic C Type Conversion ('cconvert' and 'unsafe_convert') (Julia)\nDESCRIPTION: This code snippet manually reproduces the internal steps Julia performs during a @ccall, including cconvert for argument conversion, GC.@preserve for garbage collection safety, and direct use of unsafe_convert to obtain pointers or raw values for C interoperability. Inputs are any values compatible with cconvert and unsafe_convert for the target C types, and the code requires the C function to be valid in the loaded library. The output is the same as using @ccall, though the process reveals the necessary memory safety steps that must be taken when interoperating with C.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nc_x = Base.cconvert(Int32, x)\nc_y = Base.cconvert(Float64, y)\nGC.@preserve c_x c_y begin\n    @ccall \"libfoo\".foo(\n        Base.unsafe_convert(Int32, c_x)::Int32,\n        Base.unsafe_convert(Float64, c_y)::Float64\n    )::Cvoid\nend\n```\n\n----------------------------------------\n\nTITLE: Renaming Imports with `as` Keyword in Julia\nDESCRIPTION: Julia v1.6 introduces the `as` keyword for renaming imported modules and identifiers. This applies to `import A as B`, `import A: x as y`, `import A.x as y`, and `using A: x as y` syntax.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_53\n\nLANGUAGE: julia\nCODE:\n```\nimport MyModule as MM\nimport Base: read as base_read\nimport Base.Filesystem as FS\nusing StatsBase: countmap as cm\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ineffective Use of Val Parameterization - Base Julia - Julia\nDESCRIPTION: This function attempts to forward an unknown runtime value as a Val parameter, inadvertently making the return type unpredictable. It highlights a common pitfall when using value-type parameters without compile-time knowledge, causing type instability. The code shows the proper context where Val usage may not improve performance.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_39\n\nLANGUAGE: julia\nCODE:\n```\nfunction call_array3(fillval, n)\n    A = array3(fillval, Val(n))\nend\n```\n\n----------------------------------------\n\nTITLE: Running the Built Julia Executable - Shell\nDESCRIPTION: This shell command executes the compiled Julia binary, launching an interactive Julia prompt in the terminal. The command must be run from the top level of the built Julia source directory. Inputs are entered interactively, and a Julia banner should appear if the build was successful.\nSOURCE: https://github.com/julialang/julia/blob/master/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n./julia\n```\n\n----------------------------------------\n\nTITLE: Demonstrating MethodError for Unhandled Parametric Constructor Arguments in Julia\nDESCRIPTION: Attempts to call the `Point` constructor with arguments `Point(1.5, 2)`, which have types `Float64` and `Int64` respectively. This call results in a `MethodError` because, even with the previously added `Point(::Int64, ::Float64)` constructor, there is no specific method defined to handle the `(Float64, Int64)` argument type combination.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_19\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Point(1.5,2)\nERROR: MethodError: no method matching Point(::Float64, ::Int64)\nThe type `Point` exists, but no method is defined for this combination of argument types when trying to construct it.\n\nClosest candidates are:\n  Point(::T, !Matched::T) where T<:Real\n   @ Main none:1\n  Point(!Matched::Int64, !Matched::Float64)\n   @ Main none:1\n\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Streams with Julia REPL - Julia\nDESCRIPTION: Demonstrates the use of Julia's `write` function to output a string to standard out, and `read` to obtain a character from standard input via the Julia REPL. This showcases the synchronous interface for handling streaming I/O, where `write` returns the number of bytes written and `read` retrieves a character object. Dependencies include the Julia standard library. Inputs are the string to write and the type to read; outputs are the byte count (for write) and a character (for read). Should be invoked in an interactive REPL or terminal environment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_0\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> write(stdout, \"Hello World\");  # suppress return value 11 with ;\\nHello World\\njulia> read(stdin, Char)\\n\\n'\\n': ASCII/Unicode U+000a (category Cc: Other, control)\n```\n\n----------------------------------------\n\nTITLE: Documenting API Surface of InteractiveUtils Standard Library - Julia\nDESCRIPTION: Enumerates and documents the public API of the InteractiveUtils module for display in Julia's documentation system. Each entry in the code snippet refers to a function, macro, or type aimed at introspection (e.g., 'apropos', 'methodswith'), editing source files ('edit', 'define_editor'), code display ('less'), code analysis ('@code_lowered', '@code_typed', 'code_warntype', etc.), and clipboard access. The snippet assumes that the functions macros and types are loaded via the standard Julia environment—no additional dependencies must be imported by the user. The output will be a rendered API listing, not actual code execution. Usage is limited to Julia documentation workflows.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/InteractiveUtils/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nInteractiveUtils.apropos\nInteractiveUtils.varinfo\nInteractiveUtils.versioninfo\nInteractiveUtils.methodswith\nInteractiveUtils.subtypes\nInteractiveUtils.supertypes\nInteractiveUtils.edit(::AbstractString, ::Integer)\nInteractiveUtils.edit(::Any)\nInteractiveUtils.@edit\nInteractiveUtils.define_editor\nInteractiveUtils.less(::AbstractString)\nInteractiveUtils.less(::Any)\nInteractiveUtils.@less\nInteractiveUtils.@which\nInteractiveUtils.@functionloc\nInteractiveUtils.@code_lowered\nInteractiveUtils.@code_typed\nInteractiveUtils.code_warntype\nInteractiveUtils.@code_warntype\nInteractiveUtils.code_llvm\nInteractiveUtils.@code_llvm\nInteractiveUtils.code_native\nInteractiveUtils.@code_native\nInteractiveUtils.@time_imports\nInteractiveUtils.@trace_compile\nInteractiveUtils.@trace_dispatch\nInteractiveUtils.clipboard\n```\n```\n\n----------------------------------------\n\nTITLE: Passing and Modifying C Values via @ccall - Julia\nDESCRIPTION: This snippet demonstrates how to use Julia's @ccall macro to call a C function that modifies its inputs by passing pointers to variables using Ref. It sets up two Ref{Cint} and Ref{Cfloat} variables, calls the external foo function, then shows how their values can be accessed after the call. Requires the foo symbol to be available (e.g., from a shared library loaded in the Julia process). Inputs: uninitialized Ref-wrapped variables. Outputs: modified Ref-wrapped variables reflecting changes made by the C function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nwidth = Ref{Cint}(0)\nrange = Ref{Cfloat}(0)\n@ccall foo(width::Ref{Cint}, range::Ref{Cfloat})::Cvoid\n```\n\n----------------------------------------\n\nTITLE: Grouping Tests with a Basic Test Set in Julia\nDESCRIPTION: Illustrates grouping related tests using the `@testset` macro. All tests within the \"Foo Tests\" set are executed, and since all pass, a summary showing 3 passes is printed. Test sets create their own local scope.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> @testset \"Foo Tests\" begin\n           @test foo(\"a\")   == 1\n           @test foo(\"ab\")  == 4\n           @test foo(\"abc\") == 9\n       end;\nTest Summary: | Pass  Total  Time\nFoo Tests     |    3      3  0.0s\n```\n\n----------------------------------------\n\nTITLE: Improved Exception Propagation for Failed Tasks in Julia\nDESCRIPTION: When `wait`, `@sync`, or `fetch` is called on a failing `Task`, the exception is now propagated as a `TaskFailedException` wrapping the original task. This allows inspection of both the original failure location within the task and the location of the `wait` call.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_117\n\nLANGUAGE: julia\nCODE:\n```\ntry\n    t = @async error(\"failed inside task\")\n    wait(t)\ncatch e\n    println(e) # TaskFailedException wraps the ErrorException\nend\n```\n\n----------------------------------------\n\nTITLE: Using Overloaded Instance Properties in Julia\nDESCRIPTION: Tests the new overloaded property interface for the Point struct. Shows access to the virtual properties 'x' and 'y', mutation of 'y', and resulting changes in the underlying polar coordinates. Only depends on the previous overloads. Inputs include a Point instance and new property values; outputs are property values after getter/setter logic is applied.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\npropertynames(p)\n```\n\nLANGUAGE: julia\nCODE:\n```\np.x\n```\n\nLANGUAGE: julia\nCODE:\n```\np.y = 4.0\n```\n\nLANGUAGE: julia\nCODE:\n```\np.r\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Outer Constructor with Type Conversion in Julia\nDESCRIPTION: Demonstrates the successful use of the previously defined outer constructor `Point(::Int64, ::Float64)`. The call `Point(1, 2.5)` now works, invoking the custom constructor which converts the integer `1` to `1.0` and creates an instance `p` of type `Point{Float64}`. The `typeof` function call confirms the resulting type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_18\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> p = Point(1,2.5)\nPoint{Float64}(1.0, 2.5)\n\njulia> typeof(p)\nPoint{Float64}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invariance Between Parametric Types in Julia\nDESCRIPTION: Reinforces parameter invariance with composite types: demonstrates that Point{Float64} is not a subtype of Pointy{Real}, but is a subtype of Pointy{<:Real} due to the use of type constraints. No additional dependencies are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\njulia> Point{Float64} <: Pointy{Real}\nfalse\n\njulia> Point{Float64} <: Pointy{<:Real}\ntrue\n```\n\n----------------------------------------\n\nTITLE: Checking for Julia Exceptions in C\nDESCRIPTION: This C code snippet demonstrates how to detect if an exception occurred during the execution of Julia code called from C. It uses `jl_exception_occurred()` which returns a non-NULL `jl_value_t*` if an exception is pending. If an exception exists, its type is printed as a string using `jl_typeof_str`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_32\n\nLANGUAGE: c\nCODE:\n```\nif (jl_exception_occurred())\n    printf(\"%s \\n\", jl_typeof_str(jl_exception_occurred()));\n```\n\n----------------------------------------\n\nTITLE: Determining the Type of a Struct Definition in Julia\nDESCRIPTION: Shows that the type of a struct definition itself (like `Point`) is `DataType`. This highlights that types in Julia are first-class objects.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/reflection.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> typeof(Point)\nDataType\n```\n\n----------------------------------------\n\nTITLE: Illustrating For Loop Variable Scope (Shadowing) in Julia\nDESCRIPTION: Demonstrates that if a variable exists in the enclosing scope with the same name as the `for` loop iteration variable, the loop variable creates a new local variable that shadows the outer one. Here, an outer `j` is initialized to 0. Inside the loop `for j = 1:3`, the loop's `j` takes values 1, 2, 3. After the loop, the outer `j` retains its original value of 0, unaffected by the loop.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_21\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> j = 0;\n\njulia> for j = 1:3\n           println(j)\n       end\n1\n2\n3\n\njulia> j\n0\n```\n\n----------------------------------------\n\nTITLE: Defining Advection Kernel Function for Array Chunk in Julia REPL\nDESCRIPTION: Defines the function `advection_chunk!` using `@everywhere` for availability on all workers. This function implements the core advection computation (`q[i,j,t+1] = q[i,j,t] + u[i,j,t]`) over specified row, column, and time ranges (`irange`, `jrange`, `trange`). Includes a `@show` statement to display the ranges being processed by the worker.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\njulia> @everywhere function advection_chunk!(q, u, irange, jrange, trange)\n           @show (irange, jrange, trange)  # display so we can see what's happening\n           for t in trange, j in jrange, i in irange\n               q[i,j,t+1] = q[i,j,t] + u[i,j,t]\n           end\n           q\n       end\n```\n\n----------------------------------------\n\nTITLE: Calling LLVM Intrinsics Directly Using llvmcall in Julia\nDESCRIPTION: Illustrates how to call an LLVM intrinsic function directly from Julia, bypassing the usual C ABI, using the llvmcall calling convention. This is typically used for low-level or platform-specific operations, such as querying CUDA thread indices on GPU. No additional runtime dependencies are required, but correct signature and intrinsic name are essential. Returns the result of the intrinsic (here an Int32), with no arguments; use with caution as there is no Julia runtime compatibility validation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\nccall(\"llvm.nvvm.read.ptx.sreg.tid.x\", llvmcall, Int32, ())\n```\n\n----------------------------------------\n\nTITLE: Listening on Various Socket Types with Sockets in Julia\nDESCRIPTION: This group of snippets demonstrates different usages of the listen function to create servers on various interfaces (IPv4 localhost, IPv6, all interfaces, UNIX domain sockets, and Windows named pipes). It shows how to instantiate TCPServer or PipeServer objects by specifying ports, IPs, or socket names. No external dependencies beyond Julia's Sockets standard library. Input parameters are the target address and port or pipe/socket name. Output: Returns a server object for incoming connections. Platform and protocol context may affect result type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_11\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> listen(2000) # Listens on localhost:2000 (IPv4)\nSockets.TCPServer(active)\n\njulia> listen(ip\"127.0.0.1\",2000) # Equivalent to the first\nSockets.TCPServer(active)\n\njulia> listen(ip\"::1\",2000) # Listens on localhost:2000 (IPv6)\nSockets.TCPServer(active)\n\njulia> listen(IPv4(0),2001) # Listens on port 2001 on all IPv4 interfaces\nSockets.TCPServer(active)\n\njulia> listen(IPv6(0),2001) # Listens on port 2001 on all IPv6 interfaces\nSockets.TCPServer(active)\n\njulia> listen(\"testsocket\") # Listens on a UNIX domain socket\nSockets.PipeServer(active)\n\njulia> listen(\"\\\\.\\\\pipe\\\\testsocket\") # Listens on a Windows named pipe\nSockets.PipeServer(active)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inline LaTeX Syntax in Markdown\nDESCRIPTION: This snippet illustrates rendering mathematical expressions using LaTeX syntax inline within text. The LaTeX code is enclosed in double backticks (``` `` ```).\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\nA paragraph containing some ``\\LaTeX`` markup.\n```\n\n----------------------------------------\n\nTITLE: Defining a Julia Comparison Function with Cint Return Type\nDESCRIPTION: This Julia snippet defines a comparison function mycompare, returning a value as required by the C qsort convention. The function compares two elements and returns -1, 0, or 1 based on their ordering. It must be paired with the correct calling signature and data types to be passed as a function pointer to external C code. Requires method signature annotation for Cint return value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> function mycompare(a, b)::Cint\n           return (a < b) ? -1 : ((a > b) ? +1 : 0)\n       end;\n```\n\n----------------------------------------\n\nTITLE: Basic If-Elseif-Else Conditional Statement - Julia\nDESCRIPTION: Presents the fundamental if-elseif-else conditional structure in Julia, printing different messages depending on value comparisons between x and y. No external dependencies are required. Each block is only evaluated if its corresponding condition is true, enforcing strict boolean usage in conditions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nif x < y\n    println(\"x is less than y\")\nelseif x > y\n    println(\"x is greater than y\")\nelse\n    println(\"x is equal to y\")\nend\n```\n\n----------------------------------------\n\nTITLE: Checking for Regex Matches with occursin in Julia\nDESCRIPTION: Demonstrates using the `occursin` function to check if a given string contains a match for the specified regular expression. It returns `true` if a match is found and `false` otherwise. The example tests the regex `r\"^\\s*(?:#|$)\"` against two strings.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_43\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> occursin(r\"^\\s*(?:#|$)\", \"not a comment\")\nfalse\n\njulia> occursin(r\"^\\s*(?:#|$)\", \"# a comment\")\ntrue\n```\n\n----------------------------------------\n\nTITLE: Operator Precedence Lookup with Base.operator_precedence - Julia\nDESCRIPTION: Examples of using Julia's built-in 'Base.operator_precedence' function to find the precedence (as integer ranks) for various operators, and 'Base.operator_associativity' to determine associativity. Requires Julia 1.x base. Inputs are operator symbols; outputs are precedence or associativity values. Demonstrates how to programmatically inspect operator behaviors.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\njulia> Base.operator_precedence(:+), Base.operator_precedence(:*), Base.operator_precedence(:.)\n(11, 12, 17)\n\njulia> Base.operator_precedence(:sin), Base.operator_precedence(:+=), Base.operator_precedence(:(=))  # (Note the necessary parens on `:(=)`)\n(0, 1, 1)\n\njulia> Base.operator_associativity(:-), Base.operator_associativity(:+), Base.operator_associativity(:^)\n(:left, :none, :right)\n\njulia> Base.operator_associativity(:⊗), Base.operator_associativity(:sin), Base.operator_associativity(:→)\n(:left, :none, :right)\n```\n\n----------------------------------------\n\nTITLE: Documenting Logging Event Creation Functions/Types (Julia Docs)\nDESCRIPTION: A directive for Julia's documentation generator (Documenter.jl) to include documentation for the specified macros, types, and constants related to creating log events (e.g., @logmsg, LogLevel, Debug, Info, Warn, Error).\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Logging/docs/src/index.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nLogging.@logmsg\nLogging.LogLevel\nLogging.Debug\nLogging.Info\nLogging.Warn\nLogging.Error\nLogging.BelowMinLevel\nLogging.AboveMaxLevel\n```\n\n----------------------------------------\n\nTITLE: Rounding Mode Argument for `rem2pi` Function in Julia\nDESCRIPTION: The `rem2pi` function in Julia now accepts an optional `RoundingMode` argument `r`. The call `rem2pi(x, r::RoundingMode)` computes `rem(x, 2pi, r::RoundingMode)` but potentially with greater accuracy than the direct `rem` call.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_174\n\nLANGUAGE: julia\nCODE:\n```\nrem2pi(x, r::RoundingMode)\n```\n\n----------------------------------------\n\nTITLE: Using Type Annotation to Optimize Captured Variables in Closures in Julia\nDESCRIPTION: This code snippet improves a closure for multiplication by using an explicit type annotation inside the function (abmult2). The inner variable r is explicitly typed as Int, informing the Julia parser and partially avoiding unnecessary boxing, enhancing performance. Dependencies: Julia base language. The key parameter is r0 (Int); the output is a closure function that multiplies by the absolute value of r0. Improves type stability but may still result in boxing if the variable is reassigned.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\nfunction abmult2(r0::Int)\n    r::Int = r0\n    if r < 0\n        r = -r\n    end\n    f = x -> x * r\n    return f\nend\n```\n\n----------------------------------------\n\nTITLE: Documenting Indexable Collection Functions in Julia\nDESCRIPTION: A documentation system directive (`@docs`) to include documentation for functions specific to indexable collections in Julia, primarily focusing on element access (`getindex`), element modification (`setindex!`), and obtaining boundary indices (`firstindex`, `lastindex`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.getindex\nBase.setindex!\nBase.firstindex\nBase.lastindex\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Logging from Julia REPL\nDESCRIPTION: Shows how to define a function with a debug message and then enable the display of these messages for functions defined in the REPL (which belong to the `Main` module) by setting the `ENV[\"JULIA_DEBUG\"]` variable within the Julia session.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Logging/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> foo() = @debug \"foo\"\nfoo (generic function with 1 method)\n\njulia> foo()\n\njulia> ENV[\"JULIA_DEBUG\"] = Main\nMain\n\njulia> foo()\n┌ Debug: foo\n└ @ Main REPL[1]:1\n```\n\n----------------------------------------\n\nTITLE: Creating Array and Value-Constrained Diagonal Methods - Julia\nDESCRIPTION: Defines a function with one Array argument and two others constrained to the same element type T. In this case, T is unambiguously resolved by the Array type. Dependencies: Julia. Inputs: a::Array{T}, x::T, y::T; Outputs: as implemented. Useful when element and value types must align, especially for algorithms like broadcasting.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nf(a::Array{T}, x::T, y::T) where {T} = ...\n```\n\n----------------------------------------\n\nTITLE: Creating Tables in Markdown\nDESCRIPTION: This snippet illustrates the syntax for creating basic tables in Markdown. It requires a header row, a separator line with hyphens (`-`) and optional colons (`:`) for alignment, and subsequent data rows. Cells are separated by pipes (`|`) and only inline elements are allowed within cells.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_22\n\nLANGUAGE: markdown\nCODE:\n```\n| Column One | Column Two | Column Three |\n|:---------- | ---------- |:------------:|\n| Row `1`    | Column `2` |              |\n| *Row* 2    | **Row** 2  | Column ``3`` |\n```\n\n----------------------------------------\n\nTITLE: Sorting an Array in Ascending Order - Julia\nDESCRIPTION: Demonstrates basic usage of the sort function to order an array in ascending order. Requires no additional dependencies beyond Julia Base. The input is a one-dimensional array, and the output is a sorted copy, leaving the original unchanged.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/sort.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njldoctest\\njulia> sort([2,3,1])\\n3-element Vector{Int64}:\\n 1\\n 2\\n 3\n```\n\n----------------------------------------\n\nTITLE: Dynamically Constructing @ccall with Eval in Julia\nDESCRIPTION: Demonstrates how to use `@eval` and string manipulation (`string(\"a\", \"b\")`) to construct and execute a `@ccall` expression dynamically at runtime. This approach is useful when the function name is not known until runtime but operates only at the top level and can be slow and leak memory. Indirect calls are generally preferred.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\n@eval @ccall \"lib\".$(string(\"a\", \"b\"))()::Cint\n```\n\n----------------------------------------\n\nTITLE: Explicitly Managing Shared Libraries with Libdl in Julia\nDESCRIPTION: Demonstrates the manual management of a shared library's lifecycle using the `Libdl` module. It shows how to explicitly open a library (`Libdl.dlopen`), retrieve a function symbol's address (`Libdl.dlsym`), call the function using an indirect `@ccall` with the obtained pointer (`sym`), and finally close the library (`Libdl.dlclose`). This pattern is useful for reloading updated C code without restarting Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nlib = Libdl.dlopen(\"./my_lib.so\") # Open the library explicitly.\nsym = Libdl.dlsym(lib, :my_fcn)   # Get a symbol for the function to call.\n@ccall $sym(...) # Use the pointer `sym` instead of the library.symbol tuple.\nLibdl.dlclose(lib) # Close the library explicitly.\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Pitfalls with @inbounds in Julia\nDESCRIPTION: Presents a potentially unsafe `sum` function implementation demonstrating a common pitfall. While using `@inbounds` for performance, it iterates from `1:length(A)`, implicitly assuming 1-based indexing. This assumption makes the function unsafe when used with arrays having custom indices (like `OffsetArrays`), as the bounds check that would normally catch the invalid access is skipped by `@inbounds`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/boundscheck.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nfunction sum(A::AbstractArray)\n    r = zero(eltype(A))\n    for i in 1:length(A)\n        @inbounds r += A[i]\n    end\n    return r\nend\n```\n\n----------------------------------------\n\nTITLE: Conceptual Structure of a Phi Node in Julia IR (Julia)\nDESCRIPTION: This code defines the conceptual structure `PhiNode` used internally in Julia's compiler IR. It contains `edges` (a vector of predecessor basic block/statement numbers) and `values` (a corresponding vector of SSA values or constants from those predecessors). Phi nodes are fundamental to SSA form, merging values from different control flow paths.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nstruct PhiNode\n    edges::Vector{Int32}\n    values::Vector{Any}\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Package Dependencies in a Manifest File (TOML)\nDESCRIPTION: This TOML file defines a possible Manifest.toml for a Julia project, listing all direct and indirect dependencies under sections per package. Each package may have sub-entries like 'deps', 'uuid', 'path', 'git-tree-sha1', and 'version'. The structure supports distinguishing packages with the same name but different UUIDs. This file is required by Julia's package manager to represent the full dependency graph.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[[Priv]] # the private one\ndeps = [\"Pub\", \"Zebra\"]\nuuid = \"ba13f791-ae1d-465a-978b-69c3ad90f72b\"\npath = \"deps/Priv\"\n\n[[Priv]] # the public one\nuuid = \"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"\ngit-tree-sha1 = \"1bf63d3be994fe83456a03b874b409cfd59a6373\"\nversion = \"0.1.5\"\n\n[[Pub]]\nuuid = \"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"\ngit-tree-sha1 = \"9ebd50e2b0dd1e110e842df3b433cb5869b0dd38\"\nversion = \"2.1.4\"\n\n  [Pub.deps]\n  Priv = \"2d15fe94-a1f7-436c-a4d8-07a9a496e01c\"\n  Zebra = \"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"\n\n[[Zebra]]\nuuid = \"f7a24cb4-21fc-4002-ac70-f0e3a0dd3f62\"\ngit-tree-sha1 = \"e808e36a5d7173974b90a15a353b564f3494092f\"\nversion = \"3.4.2\"\n```\n\n----------------------------------------\n\nTITLE: In-place Array Sorting with Mutating Function - Julia\nDESCRIPTION: Illustrates mutation of an array using the sort! (bang) version of the function, which directly edits the input array. The example demonstrates allocation in one step and sorting in-place for efficiency. No external dependencies are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/sort.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njldoctest\\njulia> a = [2,3,1];\\n\\njulia> sort!(a);\\n\\njulia> a\\n3-element Vector{Int64}:\\n 1\\n 2\\n 3\n```\n\n----------------------------------------\n\nTITLE: Illustrating Subnormal Identity Violations in Julia\nDESCRIPTION: Demonstrates how enabling zeroing of subnormals can break floating point identity relations in Julia. Specifically, it shows that subtraction of nearly equal subnormal values may yield zero while the values remain non-equal, depending on the setting of set_zero_subnormals. Dependencies: Julia with subnormal support. Inputs: two small float values; Output: result of subtraction and equality check. Limitation: Only relevant for hardware supporting subnormal numbers and for algorithms sensitive to tiny differences.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_62\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = 3f-38; y = 2f-38;\n\njulia> set_zero_subnormals(true); (x - y, x == y)\n(0.0f0, false)\n\njulia> set_zero_subnormals(false); (x - y, x == y)\n(1.0000001f-38, false)\n\n```\n\n----------------------------------------\n\nTITLE: Inserting a Breakpoint on jl_breakpoint from GDB (GDB Command)\nDESCRIPTION: This GDB command sets a breakpoint on Julia's jl_breakpoint function. It allows pausing execution whenever jl_breakpoint is called in the Julia process, enabling context-specific inspection during debugging. No additional parameters are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_3\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) break jl_breakpoint\n```\n\n----------------------------------------\n\nTITLE: Querying Supertypes with supertype in Julia\nDESCRIPTION: Uses the supertype function to inspect the parent type of a variety of standard Julia types. Demonstrates the use of supertypes for understanding type hierarchies; returns Any for abstract base types. Only works for types that are DataTypes and raises an error otherwise.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_66\n\nLANGUAGE: julia\nCODE:\n```\nsupertype(Float64)\\nsupertype(Number)\\nsupertype(AbstractString)\\nsupertype(Any)\n```\n\n----------------------------------------\n\nTITLE: Concurrent Asynchronous Connections with Sockets and @sync in Julia\nDESCRIPTION: This snippet concurrently performs HTTP GET requests to multiple hostnames over TCP (port 80) using coroutines launched with Threads.@spawn. The @sync macro ensures the main program waits for all spawned tasks to complete. Inputs: List of hostnames. Outputs: Each connection is written to, and a line is read and printed indicating completion for each host. Dependencies: Sockets and multithreading enabled. Demonstrates batching of concurrent network tasks.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_18\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Sockets\n\njulia> @sync for hostname in (\"google.com\", \"github.com\", \"julialang.org\")\n           Threads.@spawn begin\n               conn = connect(hostname, 80)\n               write(conn, \"GET / HTTP/1.1\\r\\nHost:$(hostname)\\r\\n\\r\\n\")\n               readline(conn, keep=true)\n               println(\"Finished connection to $(hostname)\")\n           end\n       end\nFinished connection to google.com\nFinished connection to julialang.org\nFinished connection to github.com\n```\n\n----------------------------------------\n\nTITLE: Fine-Grained Customization of MultiSelectMenu in Julia REPL\nDESCRIPTION: Demonstrates more detailed customization of a `MultiSelectMenu` using constructor arguments. This example changes the cursor character (`cursor`), and the strings used for checked (`checked`) and unchecked (`unchecked`) items, in addition to setting the charset to unicode and defining the pagesize.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_38\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> menu = MultiSelectMenu(options, pagesize=5, charset=:unicode, checked=\"YEP!\", unchecked=\"NOPE\", cursor='⧐');\n\njulia> request(menu)\njulia> request(menu)\n[press: Enter=toggle, a=all, n=none, d=done, q=abort]\n   NOPE apple\n   YEP! orange\n   NOPE grape\n ⧐ YEP! strawberry\n↓  NOPE blueberry\n```\n\n----------------------------------------\n\nTITLE: Invoking Lexically Scoped Function from Another Context - Julia\nDESCRIPTION: Demonstrates importing the previously defined module 'Bar', assigning a different value to 'x' in the global context, and calling 'Bar.foo()' to show that the function refers to the module's 'x' variable due to lexical scoping. No dependencies are required, but it builds on the preceding module definition. The output reveals that variable lookup in Julia functions obeys lexical, not dynamic scope, reinforcing the principle of scope encapsulation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_3\n\nLANGUAGE: jldoctest moduleBar\nCODE:\n```\njulia> import .Bar\\n\\njulia> x = -1;\\n\\njulia> Bar.foo()\\n1\n```\n\n----------------------------------------\n\nTITLE: Handling Errors During Test Evaluation in Julia\nDESCRIPTION: Shows how the `@test` macro handles cases where the expression itself throws an error during evaluation. Calling `foo(:cat)` results in a `MethodError` because `length` is not defined for `Symbol`, leading to an `Error During Test` result.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> @test foo(:cat) == 1\nError During Test\n  Test threw an exception of type MethodError\n  Expression: foo(:cat) == 1\n  MethodError: no method matching length(::Symbol)\n  The function `length` exists, but no method is defined for this combination of argument types.\n\n  Closest candidates are:\n    length(::SimpleVector) at essentials.jl:256\n    length(::Base.MethodList) at reflection.jl:521\n    length(::MethodTable) at reflection.jl:597\n    ...\n  Stacktrace:\n  [...]\nERROR: There was an error during testing\n```\n\n----------------------------------------\n\nTITLE: Searching for Characters from Offsets using findnext/findprev in Julia\nDESCRIPTION: Demonstrates using `findnext(char, string, offset)` and `findprev(char, string, offset)` to search for a character within a string, starting the search *after* (`findnext`) or *before* (`findprev`) a specified byte index `offset`. Returns `nothing` if not found within the search range.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_39\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> findnext('o', \"xylophone\", 1)\n4\n\njulia> findnext('o', \"xylophone\", 5)\n7\n\njulia> findprev('o', \"xylophone\", 5)\n4\n\njulia> findnext('o', \"xylophone\", 8)\n```\n\n----------------------------------------\n\nTITLE: Disambiguating Capture Groups in String Replacement in Julia\nDESCRIPTION: Demonstrates using the `\\g<n>` syntax (e.g., `\\g<0>`) within an `s\"...\"` substitution string for `replace`. This syntax can disambiguate capture group references from subsequent literal digits in the replacement string.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_52\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> replace(\"a\", r\".\" => s\"\\g<0>1\")\n\"a1\"\n```\n\n----------------------------------------\n\nTITLE: Convenient Reading Methods for Input Buffers - Julia\nDESCRIPTION: Demonstrates reading a fixed number of bytes from stdin into a newly allocated array using `read(stdin, 4)`, and reading an entire line using `readline(stdin)`. These convenience methods abstract buffer management for common input patterns. No special dependencies except Julia standard library. Parameters include the input stream and byte count or line ending. Outputs are a vector of bytes or a string, respectively. Intended for interactive console use.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_2\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> read(stdin, 4)\\nabcd\\n4-element Vector{UInt8}:\\n 0x61\\n 0x62\\n 0x63\\n 0x64\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> readline(stdin)\\nabcd\\n\"abcd\"\n```\n\n----------------------------------------\n\nTITLE: Adding Local Worker Processes in Julia Distributed\nDESCRIPTION: Adds `N` local worker processes using the `addprocs` function. The package environment (active project, LOAD_PATH, DEPOT_PATH) is automatically propagated to these workers.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\naddprocs(N::Int)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Global Variable Scope Issue in Julia Loops\nDESCRIPTION: Presents a common scenario where assigning to a global variable (`x`) inside a local scope (like a `while` loop) works interactively in the REPL (Julia >= 1.5) due to 'soft scope' rules, but throws an `UndefVarError` in scripts. To fix this in scripts, the variable must be explicitly marked `global` within the loop, enclosed in a `let` block, or the logic moved into a function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nx = 0\nwhile x < 10\n    x += 1\nend\n```\n\n----------------------------------------\n\nTITLE: Calling Fortran Subroutine with Variable Length Strings from Julia\nDESCRIPTION: Illustrates how to call a Fortran subroutine (like `test`) accepting variable-length strings from Julia using `ccall`. The strings are passed as `Ptr{UInt8}`, and their lengths (obtained via `sizeof`) are passed as separate trailing arguments of type `Csize_t`, corresponding to the hidden arguments expected by the Fortran compiler.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nstr1 = \"foo\"\nstr2 = \"bar\"\nccall(:test, Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Csize_t, Csize_t),\n                    str1, str2, sizeof(str1), sizeof(str2))\n```\n\n----------------------------------------\n\nTITLE: Inefficient Character Iteration Using Index Loop and Try-Catch in Julia\nDESCRIPTION: Presents a verbose and inefficient method for iterating through the characters of a UTF-8 string in Julia. It loops through every byte index from `firstindex(s)` to `lastindex(s)`, attempting `println(s[i])` and catching the expected `StringIndexError` for invalid indices within multi-byte characters.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_18\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for i = firstindex(s):lastindex(s)\n           try\n               println(s[i])\n           catch\n               # ignore the index error\n           end\n       end\n∀\n\nx\n\n∃\n\ny\n```\n\n----------------------------------------\n\nTITLE: Declaring an Inline Function Using @inline Macro - Julia\nDESCRIPTION: This code demonstrates usage of the @inline macro to annotate a function for inlining by the Julia compiler. Decorated functions (like myfunction) will be transformed by the macro to include metadata for the compiler. No extra dependencies are required other than having the macro definition. x is the input parameter; output is the product x*(x+3), with an added inline hint to the compiler.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/meta.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n@inline function myfunction(x)\n    x*(x+3)\nend\n\n```\n\n----------------------------------------\n\nTITLE: Defining C Struct with Fixed-Size Array\nDESCRIPTION: Defines a simple C struct `B` containing a fixed-size integer array `A`. This serves as a basis for comparison with the equivalent Julia struct definition, demonstrating how array members are handled.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_16\n\nLANGUAGE: c\nCODE:\n```\nstruct B {\n    int A[3];\n};\n\nb_a_2 = B.A[2];\n```\n\n----------------------------------------\n\nTITLE: Defining Diagonal Methods with Repeated Type Variables - Julia\nDESCRIPTION: Demonstrates a method f with two arguments constrained to have the same type via a where T clause. This style is used for diagonal types to enforce the invariant that both input arguments be of identical type. Dependencies: Julia. Inputs: x and y of type T; Outputs: as implemented in the function body. Useful for type-stable and constrained argument methods.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nf(x::T, y::T) where {T} = ...\n```\n\n----------------------------------------\n\nTITLE: Documenting Utility Collection Types in Julia\nDESCRIPTION: A documentation system directive (`@docs`) to include documentation for utility types often used in conjunction with collections, specifically `Base.Pair` (representing a key-value pair) and `Iterators.Pairs` (an iterator over the pairs of a collection).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.Pair\nIterators.Pairs\n```\n\n----------------------------------------\n\nTITLE: Example of a Basic Block in Julia's SSA IR (Julia IR/LLVM-like)\nDESCRIPTION: This snippet isolates the first basic block (`1 ─ ... goto #3 if not %2`) from the `foo` function's SSA IR shown previously. A basic block is a sequence of instructions with a single entry point and a single exit point. Here, it computes `sin(x)` (%1), compares `x` to 5.0 (%2), and terminates with a conditional branch.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_3\n\nLANGUAGE: llvm\nCODE:\n```\n1 ─ %1 = invoke Main.sin(x::Float64)::Float64\n│   %2 = Base.lt_float(x, 5.0)::Bool\n└──      goto #3 if not %2\n```\n\n----------------------------------------\n\nTITLE: Expression Interpolation with $ in Julia\nDESCRIPTION: Explains how to interpolate values and expressions into quoted code using the $ syntax, central for generating dynamic code. Demonstrates variable and tuple insertion, syntax errors for misusage, and notes on its similarity to string/command interpolation. Inputs: variables/expressions; output: Expr with interpolated content or error if misapplied.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> a = 1;\n\njulia> ex = :($a + b)\n:(1 + b)\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> $a + b\nERROR: syntax: \"$\" expression outside quote\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> ex = :(a in $:((1,2,3)) )\n:(a in (1, 2, 3))\n```\n\n----------------------------------------\n\nTITLE: Example of a Type-Unstable Function in Julia\nDESCRIPTION: Defines a function `unstable` whose return type depends on the runtime *value* of its boolean argument `flag`, returning either an `Int` or a `Float64`. This behavior is called \"type instability\" because the compiler cannot predict a single, concrete return type based only on the input type (`Bool`), potentially hindering performance optimization.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_13\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function unstable(flag::Bool)\n           if flag\n               return 1\n           else\n               return 1.0\n           end\n       end\nunstable (generic function with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Referencing Mappings with Julia Syntax (Markdown)\nDESCRIPTION: These inline code snippets use Julia syntax to illustrate how the 'roots', 'graph', and 'paths' internal maps are referenced during package import resolution. They do not execute code but demonstrate key parameters such as package names, UUIDs, and the use of the Julia import mechanism. The examples help clarify the mapping relationships for package resolution within the documentation context.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n`import X`\n```\n\nLANGUAGE: julia\nCODE:\n```\n`roots[:X]`\n```\n\nLANGUAGE: julia\nCODE:\n```\n`graph[context][:X]`\n```\n\nLANGUAGE: julia\nCODE:\n```\n`paths[uuid,:X]`\n```\n\n----------------------------------------\n\nTITLE: Conditional Evaluation with Side Effects in Ternary Expressions - Julia\nDESCRIPTION: Demonstrates that in Julia's ternary operator, only the selected branch is evaluated, so side effects and computations are not executed in unselected branches. The v(x) function prints its argument, and only the chosen branch's print/output occurs depending on the conditional's result.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> v(x) = (println(x); x)\nv (generic function with 1 method)\n\njulia> 1 < 2 ? v(\"yes\") : v(\"no\")\nyes\n\"yes\"\n\njulia> 1 > 2 ? v(\"yes\") : v(\"no\")\nno\n\"no\"\n```\n\n----------------------------------------\n\nTITLE: Profiling the Julia Profiler Itself\nDESCRIPTION: Demonstrates a technique to profile the execution of `Profile.print` itself. It first fetches the current profile data into a variable `data`, clears the profiler's buffer using `Profile.clear()`, runs `Profile.print` under `@profile` using the previously captured `data`, and finally calls `Profile.print()` again to display the profile results of the `Profile.print` call.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\ndata = copy(Profile.fetch())\nProfile.clear()\n@profile Profile.print(stdout, data) # Prints the previous results\nProfile.print()                      # Prints results from Profile.print()\n```\n\n----------------------------------------\n\nTITLE: Defining an Example Julia Function for SSA IR Demonstration (Julia)\nDESCRIPTION: This Julia code defines a function `foo` that takes a `Float64` argument, calculates `sin(x)`, conditionally adds `cos(x)` based on whether `x > 5.0`, and returns the sum of `exp(2)` and the result. It serves as the input source code for demonstrating Julia's SSA IR generation process.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nfunction foo(x)\n    y = sin(x)\n    if x > 5.0\n        y = y + cos(x)\n    end\n    return exp(2) + y\nend\n```\n\n----------------------------------------\n\nTITLE: Documenting Error Output in Doctest - Julia - Julia\nDESCRIPTION: This snippet shows the use of the jldoctest block for illustrating an error case, demonstrating integer division by zero in Julia and indicating how to use [...] to truncate non-deterministic stack trace output. This approach helps demonstrate error handling and output expectations in the REPL.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> div(1, 0)\nERROR: DivideError: integer division error\n[...]\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Variadic Tuple Types with Free Variables - Julia REPL - Julia\nDESCRIPTION: Explores how Tuple types parameterized by Vararg with free type variables behave. The first intersection works as expected, giving Tuple{Int64, Float64}, but the second, due to the type's scope for T, yields Union{}. Dependencies: Base Julia type system. Inputs: Parameterized Tuple types; Output: Intersected type or Union{}. Useful for understanding generic tuple constraints.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_8\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> typeintersect(Tuple{Vararg{T} where T}, Tuple{Int,Float64})\nTuple{Int64, Float64}\n\njulia> typeintersect(Tuple{Vararg{T}} where T, Tuple{Int,Float64})\nUnion{}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Julia's SSA IR for a Simple Function (Julia IR/LLVM-like)\nDESCRIPTION: This code block displays the Julia SSA IR generated for the `foo` function, triggered by `@code_typed`. It demonstrates the transformation into basic blocks (e.g., `1 ─`, `2 ─`, `3 ┄`), SSA values (e.g., `%1`, `%2`), function calls (`invoke`), conditional branching (`goto #3 if not %2`), and Phi nodes (`φ`) for merging values (`%6`) from different control flow paths (#1 and #2). Note: While resembling LLVM IR syntax, this is Julia's specific SSA IR.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_2\n\nLANGUAGE: llvm\nCODE:\n```\nCodeInfo(\n1 ─ %1 = invoke Main.sin(x::Float64)::Float64\n│   %2 = Base.lt_float(x, 5.0)::Bool\n└──      goto #3 if not %2\n2 ─ %4 = invoke Main.cos(x::Float64)::Float64\n└── %5 = Base.add_float(%1, %4)::Float64\n3 ┄ %6 = φ (#2 => %5, #1 => %1)::Float64\n│   %7 = Base.add_float(7.38905609893065, %6)::Float64\n└──      return %7\n) => Float64\n```\n\n----------------------------------------\n\nTITLE: Disabling AVX2 in OpenBLAS Build (Makefile)\nDESCRIPTION: Sets `OPENBLAS_NO_AVX2 = 1` in `Make.user` to prevent the OpenBLAS build from using AVX2 instructions. This serves as a workaround for OpenBLAS compilation failures, especially when `OPENBLAS_DYNAMIC_ARCH = 1` is needed but the toolchain (e.g., old binutils) is incompatible.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_8\n\nLANGUAGE: Makefile\nCODE:\n```\nOPENBLAS_NO_AVX2 = 1\n```\n\n----------------------------------------\n\nTITLE: Declaring Primitive Types - Julia\nDESCRIPTION: This snippet provides the general syntax to declare a primitive type in Julia, optionally as a subtype of another existing type, with a specified number of bits for storage. The 'primitive type' keyword introduces a new concrete type whose data is stored as bits, and it can form part of Julia's type hierarchy. Inputs are a type name, optional supertype, and bit size; output is a new primitive type. This feature is built into Julia and does not require dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nprimitive type \\u00abname\\u00bb \\u00abbits\\u00bb end\nprimitive type \\u00abname\\u00bb <: \\u00absupertype\\u00bb \\u00abbits\\u00bb end\n```\n\n----------------------------------------\n\nTITLE: Defining a Non-main Function Inline (Bash/Julia)\nDESCRIPTION: Shows that defining a function named `hello` (not `main`) inline using `-e` does not result in its automatic execution. The special behavior triggered by the `@main` macro only applies to a function named `main` in the `Main` module when explicitly opted into with the macro.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ julia -e 'hello(args) = println(\"Hello World!\")'\n```\n\n----------------------------------------\n\nTITLE: Implementing `firstindex` and `lastindex` for `begin`/`end` Indexing in Julia\nDESCRIPTION: Defines the `firstindex` and `lastindex` methods for the `Squares` type. These methods are necessary to support using the `begin` and `end` keywords within indexing expressions (e.g., `S[end]`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_10\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Base.firstindex(S::Squares) = 1\n\njulia> Base.lastindex(S::Squares) = length(S)\n```\n\n----------------------------------------\n\nTITLE: Executing a Basic Failing Unit Test in Julia\nDESCRIPTION: Illustrates a failing test case using the `@test` macro in Julia. The condition `foo(\"f\") == 20` evaluates to false (1 == 20), resulting in a `Test Failed` message and an error being thrown.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> @test foo(\"f\") == 20\nTest Failed at none:1\n  Expression: foo(\"f\") == 20\n   Evaluated: 1 == 20\n\nERROR: There was an error during testing\n```\n\n----------------------------------------\n\nTITLE: Testing for Value Equality with isequal for Arrays in Julia\nDESCRIPTION: Demonstrates the use of `isequal` to check if arrays are equal, treating `missing` as equal to other `missing` values. Unlike `==`, this function returns `true` or `false` even with missing values. Inputs: arrays with or without `missing`. Output: Boolean indicating structural equality under Julia's value equality semantics. No external dependencies required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\njulia> isequal([1, missing], [1, missing])\ntrue\n\njulia> isequal([1, 2, missing], [1, missing, 2])\nfalse\n```\n\n----------------------------------------\n\nTITLE: Type-Stable N-Dimensional Array Construction Using Value Types (Val) - Base Julia - Julia\nDESCRIPTION: Illustrates a type-stable approach for constructing constant N-dimensional arrays by passing dimension `N` as a type parameter via `Val{N}`. This method leverages Julia's compile-time inference to produce efficient code generation. Only works efficiently when the dimension parameter is known at compile time or comes from the array's type domain.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\njulia> function array3(fillval, ::Val{N}) where N\n           fill(fillval, ntuple(d->3, Val(N)))\n       end\narray3 (generic function with 1 method)\n\njulia> array3(5.0, Val(2))\n3×3 Matrix{Float64}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n```\n\n----------------------------------------\n\nTITLE: Distributing Work Using SharedArrays in Julia\nDESCRIPTION: Uses a SharedArray to allow safe, parallel updates to array indices in a distributed loop. Requires the 'SharedArrays' module, enabled with 'using SharedArrays'. Each worker can modify distinct parts of the shared array concurrently, bypassing the limitations of single-process memory. Suitable for smaller-scale shared updates across processes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nusing SharedArrays\n\na = SharedArray{Float64}(10)\n@distributed for i = 1:10\n    a[i] = i\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Exception Type - Julia\nDESCRIPTION: This example shows how to define a custom exception type in Julia as a subtype of Exception. There are no dependencies beyond base Julia. The struct MyCustomException can be thrown using the throw function and used to signal user-defined error conditions. No arguments are defined in this minimal example.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\njulia> struct MyCustomException <: Exception end\n\n```\n\n----------------------------------------\n\nTITLE: Applying the Wall-Time Profiler to Compute-Bound Tasks in Julia\nDESCRIPTION: Demonstrates the use of the wall-time profiler (`Profile.@profile_walltime`) on a compute-bound workload. The example spawns multiple tasks (`N_TASKS`) that perform a CPU-intensive calculation (`sum_of_sqrt`). This shows that the wall-time profiler can still be effective for identifying performance hotspots in compute-heavy code, as it samples tasks proportionally to the wall time they exist, including their active computation time.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.Threads\nusing Profile\nusing PProf\n\nch = Channel(1)\n\nconst MAX_ITERS = (1 << 22)\nconst N_TASKS = (1 << 12)\n\nfunction spawn_a_task_waiting_on_channel()\n    Threads.@spawn begin\n        take!(ch)\n    end\nend\n\nfunction sum_of_sqrt()\n    sum_of_sqrt = 0.0\n    for i in 1:MAX_ITERS\n        sum_of_sqrt += sqrt(i)\n    end\n    return sum_of_sqrt\nend\n\nfunction spawn_a_bunch_of_compute_heavy_tasks()\n    Threads.@sync begin\n        for i in 1:N_TASKS\n            Threads.@spawn begin\n                sum_of_sqrt()\n            end\n        end\n    end\nend\n\nfunction main()\n    spawn_a_task_waiting_on_channel()\n    spawn_a_bunch_of_compute_heavy_tasks()\nend\n\nProfile.@profile_walltime main()\n```\n\n----------------------------------------\n\nTITLE: Setting JULIA_NUM_THREADS Environment Variable - Bash\nDESCRIPTION: Shows how to configure the number of Julia threads by exporting the JULIA_NUM_THREADS environment variable in a Bash shell before starting Julia. No dependencies except shell access and Julia installed. Input is the desired thread count as an environment variable; Julia reads this on startup.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport JULIA_NUM_THREADS=4\n```\n\n----------------------------------------\n\nTITLE: Accessing Regex Captures by Name or Index in Julia\nDESCRIPTION: Shows how to define named capture groups (e.g., `?<hour>`) in a regex and access the captured values from the `RegexMatch` object using either the group name (as a Symbol, e.g., `m[:minute]`) or its numerical index (e.g., `m[2]`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_50\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> m=match(r\"(?<hour>\\d+):(?<minute>\\d+)\",\"12:45\")\nRegexMatch(\"12:45\", hour=\"12\", minute=\"45\")\n\njulia> m[:minute]\n\"45\"\n\njulia> m[2]\n\"45\"\n```\n\n----------------------------------------\n\nTITLE: Simple Summation Loop Potentially Ambiguous in File Scope (Julia)\nDESCRIPTION: Illustrates a common pattern for summing values using `s += i` within a `for` loop. While the intention to modify the global `s` is clear, this code exhibits soft scope ambiguity if executed from a file where `s` is a pre-existing global variable. This contrasts with its straightforward behavior in the REPL (modifying global `s`) or within a function (modifying local `s`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\ns = 0\nfor i = 1:10\n    s += i\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Factorial with Short-Circuit Guards in Julia\nDESCRIPTION: Defines a recursive function `fact(n)` that calculates the factorial of an integer `n`. It utilizes short-circuit evaluation: `||` for input validation (`n >= 0 || error(...)`) to ensure `n` is non-negative, and `&&` for the base case (`n == 0 && return 1`). The example demonstrates calls with valid inputs (5 and 0) and an invalid input (-1), showing the error handling triggered by the first short-circuit expression.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_13\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function fact(n::Int)\n           n >= 0 || error(\"n must be non-negative\")\n           n == 0 && return 1\n           n * fact(n-1)\n       end\nfact (generic function with 1 method)\n\njulia> fact(5)\n120\n\njulia> fact(0)\n1\n\njulia> fact(-1)\nERROR: n must be non-negative\nStacktrace:\n [1] error at ./error.jl:33 [inlined]\n [2] fact(::Int64) at ./none:2\n [3] top-level scope\n```\n\n----------------------------------------\n\nTITLE: Writing Unit Tests for a Greeting Function in Julia\nDESCRIPTION: Contains example unit tests for the `greet` function from the `Example` package, intended for `greeting_tests.jl`. It uses `@testset` for grouping (`Testset 3`) and employs `@test` to verify the function's exact string output and `@test_throws MethodError` to ensure calling the function with incorrect arguments raises the appropriate error.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\n@testset \"Testset 3\" begin\n    @test \"Hello world!\" == greet()\n    @test_throws MethodError greet(\"Antonia\")\nend\n```\n\n----------------------------------------\n\nTITLE: Accessing Default Properties of a Custom Type in Julia\nDESCRIPTION: Demonstrates the default behavior of property and field access for the 'Point' struct, showing how 'propertynames', 'getproperty', and direct field access with dot syntax are equivalent out-of-the-box. No dependencies beyond base Julia. Inputs are a Point instance and symbols for field names; outputs field values and lists of property names.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\npropertynames(p)\n```\n\nLANGUAGE: julia\nCODE:\n```\ngetproperty(p, :r), getproperty(p, :ϕ)\n```\n\nLANGUAGE: julia\nCODE:\n```\np.r, p.ϕ\n```\n\nLANGUAGE: julia\nCODE:\n```\ngetfield(p, :r), getproperty(p, :ϕ)\n```\n\n----------------------------------------\n\nTITLE: Handling Closed Channels and Exceptions in Julia REPL\nDESCRIPTION: Shows the behavior of Julia channels when closing channels and using put!, fetch, and take! on open and closed channels. Demonstrates type inference, exception handling when writing to a closed channel, and how remaining data can still be fetched or taken until the channel is emptied. No external dependencies except Julia Base. Users interactively issue put!, close, fetch, and take! statements in the REPL. Inputs are values inserted into the channel, and outputs/errors are observed via standard output.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/asynchronous-programming.md#_snippet_7\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> c = Channel(2);\n\njulia> put!(c, 1) # `put!` on an open channel succeeds\n1\n\njulia> close(c);\n\njulia> put!(c, 2) # `put!` on a closed channel throws an exception.\nERROR: InvalidStateException: Channel is closed.\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Multi-threaded Task Scheduling for Channels in Julia\nDESCRIPTION: The `Channel` constructor now accepts a `spawn=true` keyword argument. When `f` is a function, `Channel(f::Function, spawn=true)` schedules the created task on any available thread, similar to `Threads.@spawn`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_107\n\nLANGUAGE: julia\nCODE:\n```\nChannel(f::Function, spawn=true)\n```\n\n----------------------------------------\n\nTITLE: Scheduling and Waiting for a Julia Task\nDESCRIPTION: Demonstrates scheduling task `t` using `schedule(t)` and then immediately blocking the current execution flow until `t` completes using `wait(t)`. Unlike just scheduling, this combination forces the calling context (e.g., the REPL) to pause for the duration of the task's execution (5 seconds in this example) before proceeding.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/asynchronous-programming.md#_snippet_2\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> schedule(t); wait(t)\n```\n\n----------------------------------------\n\nTITLE: Conflicting Method Dispatching on Specific Container and Element Type\nDESCRIPTION: Illustrates a user-defined method that could create ambiguity with methods dispatching on abstract container element types (like the previous example). This method dispatches on a specific container `MyArrayType{T}` and its element type `b::T`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_49\n\nLANGUAGE: julia\nCODE:\n```\n-(A::MyArrayType{T}, b::T) where {T}\n```\n\n----------------------------------------\n\nTITLE: Collecting Variable Arguments (Slurping) in Julia Functions\nDESCRIPTION: Explains and demonstrates the \"slurping\" feature in Julia function definitions. The `...` operator used in `args...` within the function signature collects any number of trailing arguments passed during the function call into a single `Tuple` variable named `args`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_9\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function printargs(args...)\n           println(typeof(args))\n           for (i, arg) in enumerate(args)\n               println(\"Arg #$i = $arg\")\n           end\n       end\nprintargs (generic function with 1 method)\n\njulia> printargs(1, 2, 3)\nTuple{Int64, Int64, Int64}\nArg #1 = 1\nArg #2 = 2\nArg #3 = 3\n```\n\n----------------------------------------\n\nTITLE: Fetching Indexed Data Remotely Using remotecall_fetch and getindex - Julia (REPL)\nDESCRIPTION: This snippet highlights fetching a specific indexed value (element [1,1]) from a remote Future by passing the getindex function to remotecall_fetch. This approach is equivalent to direct Julia indexing, leveraging Distributed for efficient data access. Inputs include the function, worker ID, Future, and indices; output is the fetched element. Requires the Distributed module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_2\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> remotecall_fetch(getindex, 2, r, 1, 1)\n0.10824216411304866\n```\n\n----------------------------------------\n\nTITLE: Creating BitArrays from Generator Expressions - BitArray - Julia\nDESCRIPTION: Demonstrates how to construct a BitArray from a generator expression in Julia, enabling efficient boolean array creation based on a predicate. This method accepts any iterable, but is especially useful with generator expressions (e.g., isodd(x) for ranges) to create a BitArray with elements corresponding to the truth values of the predicate. The resulting BitArray is space-efficient and provides fast bitwise operations suitable for logical indexing or masking.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_164\n\nLANGUAGE: julia\nCODE:\n```\nBitArray(isodd(x) for x = 1:100)\n```\n\n----------------------------------------\n\nTITLE: Inspecting the Expression Structure of an Interpolated String using `dump`\nDESCRIPTION: Uses the `dump` function to reveal the internal `Expr` structure of a string literal containing interpolation (`:(\"a ($a) should equal b ($b)!\")`). It shows the expression head (`:string`) and its arguments (string parts and symbols), demonstrating that the macro receives an unevaluated expression representing the string concatenation, not the final string value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_41\n\nLANGUAGE: julia\nCODE:\n```\njulia> dump(:(\"a ($a) should equal b ($b)!\"))\nExpr\n  head: Symbol string\n  args: Array{Any}((5,))\n    1: String \"a (\"\n    2: Symbol a\n    3: String \") should equal b (\"\n    4: Symbol b\n    5: String \")!\"\n```\n\n----------------------------------------\n\nTITLE: Indexing UTF-8 Strings and Handling StringIndexError in Julia\nDESCRIPTION: Illustrates Julia's byte-based indexing for UTF-8 strings and the `StringIndexError` resulting from indexing into the middle of a multi-byte character. It shows accessing the first character ('∀' at index 1), failing at indices 2 and 3 within '∀', and successfully accessing the space character at index 4. This highlights that string indices refer to code units (bytes), not characters.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_15\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> s[1]\n'∀': Unicode U+2200 (category Sm: Symbol, math)\n\njulia> s[2]\nERROR: StringIndexError: invalid index [2], valid nearby indices [1]=>'∀', [4]=>' '\nStacktrace:\n[...]\n\njulia> s[3]\nERROR: StringIndexError: invalid index [3], valid nearby indices [1]=>'∀', [4]=>' '\nStacktrace:\n[...]\n\njulia> s[4]\n' ': ASCII/Unicode U+0020 (category Zs: Separator, space)\n```\n\n----------------------------------------\n\nTITLE: Disabling Julia PkgServer Protocol via Environment Variable (Bash)\nDESCRIPTION: Sets the `JULIA_PKG_SERVER` environment variable to an empty string in Bash to disable the PkgServer protocol. This forces the Julia package manager (Pkg.jl) to download packages directly from their source hosts (like GitHub or GitLab) instead of using the default package server (`https://pkg.julialang.org`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/environment-variables.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n export JULIA_PKG_SERVER=\"\" \n```\n\n----------------------------------------\n\nTITLE: Creating and Using a RadioMenu in Julia\nDESCRIPTION: Demonstrates how to create and display a `RadioMenu` using `REPL.TerminalMenus`. It initializes a `RadioMenu` with a specific `pagesize`, then uses the `request` function to present the menu to the user for single item selection. The function returns the index of the selected item or -1 if canceled.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\n# `pagesize` is the number of items to be displayed at a time.\n#  The UI will scroll if the number of options is greater\n#   than the `pagesize`\nmenu = RadioMenu(options, pagesize=4)\n\n# `request` displays the menu and returns the index after the\n#   user has selected a choice\nchoice = request(\"Choose your favorite fruit:\", menu)\n\nif choice != -1\n    println(\"Your favorite fruit is \", options[choice], \"!\")\nelse\n    println(\"Menu canceled.\")\nend\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Uniform Stride in a SubArray View (Julia)\nDESCRIPTION: Reshapes a range into a 5x2 matrix `A` (note the odd first dimension). It creates a similar view `A[2:2:4,:]` as the previous example. Computing the differences between consecutive elements after flattening reveals non-constant values (`2`, `3`, `2`), demonstrating a non-uniform stride. This illustrates why `SubArray` cannot guarantee fast linear indexing based solely on the *type* `StepRange` when combined with other slicing dimensions, as the actual stride depends on runtime parent array dimensions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> A = reshape(1:5*2, 5, 2)\n5×2 reshape(::UnitRange{Int64}, 5, 2) with eltype Int64:\n 1   6\n 2   7\n 3   8\n 4   9\n 5  10\n\njulia> diff(A[2:2:4,:][:])\n3-element Vector{Int64}:\n 2\n 3\n 2\n```\n```\n\n----------------------------------------\n\nTITLE: Minimal C Embedding Example for julia-config Demonstration\nDESCRIPTION: A concise C program embedding Julia, used as an example for demonstrating the `julia-config.jl` script. It initializes Julia (`jl_init`), evaluates a simple `println` statement using `jl_eval_string`, and calls the exit hook (`jl_atexit_hook`). Requires `julia.h` and linking against `libjulia`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#include <julia.h>\n\nint main(int argc, char *argv[])\n{\n    jl_init();\n    (void)jl_eval_string(\"println(sqrt(2.0))\");\n    jl_atexit_hook(0);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting Typed Code with Source Info using @code_typed in Julia\nDESCRIPTION: Demonstrates using the `@code_typed` macro with the `debuginfo=:source` keyword argument to view the type-inferred intermediate representation of a function call, including annotations mapping back to the original source code lines. The example inspects the `+(1, 1)` call. Requires the `InteractiveUtils` module for the macro.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/reflection.md#_snippet_7\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> InteractiveUtils.@code_typed debuginfo=:source +(1,1)\nCodeInfo(\n    @ int.jl:87 within `+`\n1 ─ %1 = intrinsic Base.add_int(x, y)::Int64\n└──      return %1\n) => Int64\n```\n\n----------------------------------------\n\nTITLE: Defining Worker-Specific Index Range Function for SharedArray in Julia REPL\nDESCRIPTION: Defines a function `myrange` using `@everywhere` to make it available on all workers. Given a `SharedArray` `q`, it calculates the row and column index ranges (`irange`, `jrange`) corresponding to the chunk of data assigned to the calling worker. It uses `indexpids` and distributes the columns (`size(q,2)`) among the workers (`procs(q)`). If the worker is not participating (`idx == 0`), it returns empty ranges.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\njulia> @everywhere function myrange(q::SharedArray)\n           idx = indexpids(q)\n           if idx == 0 # This worker is not assigned a piece\n               return 1:0, 1:0\n           end\n           nchunks = length(procs(q))\n           splits = [round(Int, s) for s in range(0, stop=size(q,2), length=nchunks+1)]\n           1:size(q,1), splits[idx]+1:splits[idx+1]\n       end\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Versioning Tools\nDESCRIPTION: This block uses the `@docs` directive to list tools related to handling version numbers in Julia. It includes the `VersionNumber` type for representing semantic versions and the `@v_str` macro for easily constructing `VersionNumber` objects from strings.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.VersionNumber\nBase.@v_str\n```\n```\n\n----------------------------------------\n\nTITLE: Using `<--` and `<-->` as Infix Operators in Julia\nDESCRIPTION: The arrow-like symbols `<--` and `<-->` are now available for use as infix operators in Julia. They share the same precedence and associativity as other arrow operators.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_48\n\nLANGUAGE: julia\nCODE:\n```\n# Example usage:\na <-- b\nc <--> d\n```\n\n----------------------------------------\n\nTITLE: Running Package Tests via Julia Pkg REPL and Example Output\nDESCRIPTION: Demonstrates executing the test suite using the Pkg REPL command `(Example) pkg> test`. The subsequent block shows typical output, including status information about the package and its dependencies (Project.toml, Manifest.toml), the 'Testing Running tests...' message, and a final summary table indicating the number of passing tests (`Test Summary: | Pass Total`).\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\n(Example) pkg> test\n```\n\nLANGUAGE: text\nCODE:\n```\n     Testing Example\n      Status `/tmp/jl_Yngpvy/Project.toml`\n  [fa318bd2] Example v0.1.0 `/home/src/Projects/tmp/errata/Example`\n  [8dfed614] Test `@stdlib/Test`\n      Status `/tmp/jl_Yngpvy/Manifest.toml`\n  [fa318bd2] Example v0.1.0 `/home/src/Projects/tmp/errata/Example`\n  [2a0f44e3] Base64 `@stdlib/Base64`\n  [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`\n  [56ddb016] Logging `@stdlib/Logging`\n  [d6f4376e] Markdown `@stdlib/Markdown`\n  [9a3f8284] Random `@stdlib/Random`\n  [ea8e919c] SHA `@stdlib/SHA`\n  [9e88b42a] Serialization `@stdlib/Serialization`\n  [8dfed614] Test `@stdlib/Test`\n     Testing Running tests...\nTest Summary: | Pass  Total\nExample tests |    9      9\n     Testing Example tests passed\n```\n\n----------------------------------------\n\nTITLE: Conceptual Structure of a Standard Julia Module\nDESCRIPTION: Provides a conceptual representation of a standard Julia `module` definition in terms of `baremodule`. It highlights that standard modules implicitly include `using Base` and define local `eval` and `include` functions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nbaremodule Mod\n\nusing Base\n\neval(x) = Core.eval(Mod, x)\ninclude(p) = Base.include(Mod, p)\n\n...\n\nend\n```\n\n----------------------------------------\n\nTITLE: Expanding Macros using InteractiveUtils.macroexpand in Julia\nDESCRIPTION: Illustrates the use of `InteractiveUtils.macroexpand` to get the expanded, unquoted expression (`Expr`) form of a macro call. The example expands the `@edit println(\"\")` macro call within the context of the current module (`@__MODULE__`). It requires the `InteractiveUtils` module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/reflection.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> InteractiveUtils.macroexpand(@__MODULE__, :(@edit println(\"\")) )\n:(InteractiveUtils.edit(println, InteractiveUtils.Tuple{(InteractiveUtils.Core).Typeof(\"\")}))\n```\n\n----------------------------------------\n\nTITLE: Inspecting Tuple Type Parameters - Julia REPL - Julia\nDESCRIPTION: This snippet demonstrates how to query the parameters of the built-in Tuple type within the Julia REPL. It shows that Tuple is parameterized by a single Vararg{Any}, meaning it can accommodate tuples of arbitrary types and length. Dependencies: None beyond Julia itself. Inputs: None; Outputs: Type object and its parameters. Useful as a foundational check for type relationships in Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_6\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Tuple\nTuple\n\njulia> Tuple.parameters\nsvec(Vararg{Any})\n```\n\n----------------------------------------\n\nTITLE: Defining the Command Literal Macro (`@cmd`) in Julia\nDESCRIPTION: This Julia macro `cmd` implements the backtick ``` ` ``` command literal syntax. It takes the string `str` within the backticks, uses internal functions like `shell_parse` to process it, and generates an expression (`Expr`) involving `cmd_gen` to create a command object at compile time.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_59\n\nLANGUAGE: julia\nCODE:\n```\nmacro cmd(str)\n    :(cmd_gen($(shell_parse(str)[1])))\nend\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Specific UUID Functions in Julia\nDESCRIPTION: This snippet employs the `@docs` block from Julia's documentation system (Documenter.jl). It instructs the system to automatically find and insert the documentation (docstrings) for the specified functions (`UUIDs.uuid1`, `UUIDs.uuid4`, `UUIDs.uuid5`, `UUIDs.uuid_version`) from the `UUIDs` standard library module into the final rendered documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/UUIDs/docs/src/index.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```@docs\nUUIDs.uuid1\nUUIDs.uuid4\nUUIDs.uuid5\nUUIDs.uuid_version\n```\n```\n\n----------------------------------------\n\nTITLE: Generic Addition Function Definition - Julia\nDESCRIPTION: The provided function defines a generic addition method 'myplus' in Julia that takes two arguments and returns their sum using the '+' operator. This example illustrates Julia's method dispatch system, where this generic method will be recompiled for each concrete argument type combination at runtime, ensuring performance and enabling method specialization. No explicit type annotations are used, so the parameters default to type 'Any'. Required dependency: the '+' operator must be defined for argument types. Inputs: two arguments (of any types supporting '+'); output: their sum.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nfunction myplus(x,y)\n    x+y\nend\n```\n\n----------------------------------------\n\nTITLE: Listing Julia System Interaction Functions and Macros\nDESCRIPTION: This block utilizes the `@docs` directive to list a wide range of functions, types, and macros for interacting with the underlying operating system and environment. This includes running external commands (`run`, `Cmd`, `pipeline`), managing processes (`kill`, `success`, `process_running`), environment variables (`ENV`, `withenv`), system information (`Sys.*`, `gethostname`, `getpid`), timing (`time`, `@time`), memory usage (`free_memory`), platform checks (`isunix`, `iswindows`), file system checks (`isexecutable`, `isreadable`), and the `@static` macro for conditional compilation based on system properties.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.run\nBase.devnull\nBase.success\nBase.process_running\nBase.process_exited\nBase.kill(::Base.Process, ::Integer)\nBase.Sys.set_process_title\nBase.Sys.get_process_title\nBase.ignorestatus\nBase.detach\nBase.Cmd\nBase.setenv\nBase.addenv\nBase.withenv\nBase.shell_escape\nBase.shell_split\nBase.shell_escape_posixly\nBase.shell_escape_csh\nBase.shell_escape_wincmd\nBase.escape_microsoft_c_args\nBase.setcpuaffinity\nBase.pipeline(::Any, ::Any, ::Any, ::Any...)\nBase.pipeline(::Base.AbstractCmd)\nBase.Libc.gethostname\nBase.Libc.getpid\nBase.Libc.time()\nBase.time_ns\nBase.@time\nBase.@showtime\nBase.@timev\nBase.@timed\nBase.@elapsed\nBase.@allocated\nBase.@allocations\nBase.@lock_conflicts\nBase.EnvDict\nBase.ENV\nBase.Sys.STDLIB\nBase.Sys.isunix\nBase.Sys.isapple\nBase.Sys.islinux\nBase.Sys.isbsd\nBase.Sys.isfreebsd\nBase.Sys.isopenbsd\nBase.Sys.isnetbsd\nBase.Sys.isdragonfly\nBase.Sys.iswindows\nBase.Sys.windows_version\nBase.Sys.free_memory\nBase.Sys.total_memory\nBase.Sys.free_physical_memory\nBase.Sys.total_physical_memory\nBase.Sys.uptime\nBase.Sys.isjsvm\nBase.Sys.loadavg\nBase.Sys.isexecutable\nBase.Sys.isreadable\nBase.Sys.iswritable\nBase.Sys.which\nBase.Sys.username\nBase.@static\n```\n```\n\n----------------------------------------\n\nTITLE: Julia Module Naming Convention Example\nDESCRIPTION: Provides an example of the recommended Julia style guide for naming modules using `UpperCamelCase` (e.g., `FastThings`). It also shows how using a plural name for the module can help avoid conflicts with similarly named types (e.g., `FastThing`) defined inside it.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nmodule FastThings\n\nstruct FastThing\n    ...\nend\n\nend\n```\n\n----------------------------------------\n\nTITLE: Documenting Range Constructors and Types in Julia\nDESCRIPTION: A documentation system directive (`@docs`) to include documentation for various range types and their abstract supertypes available in Julia's Base library, such as `AbstractRange`, `UnitRange`, and `LinRange`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.AbstractRange\nBase.OrdinalRange\nBase.AbstractUnitRange\nBase.StepRange\nBase.UnitRange\nBase.LinRange\n```\n\n----------------------------------------\n\nTITLE: Combining @fastmath and @simd Macros in Julia\nDESCRIPTION: Illustrates the usage of `@fastmath` followed by `@simd`. This combination is suggested to recover the broader optimization behavior of `@simd` from versions prior to Julia v1.10, specifically enabling floating-point operation reordering and contraction, alongside other potentially less safe optimizations from `@fastmath`. This is relevant because `@simd` alone now has more limited semantics.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n@fastmath @simd\n```\n\n----------------------------------------\n\nTITLE: Tuple Assignment in Julia\nDESCRIPTION: Julia uses tuples for returning and assigning multiple values. Parentheses are optional in assignment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n(a, b) = (1, 2)\n```\n\nLANGUAGE: julia\nCODE:\n```\na, b = 1, 2\n```\n\n----------------------------------------\n\nTITLE: Creating Lazy Maps with `Iterators.map` in Julia\nDESCRIPTION: `Iterators.map(f, iterators...)` provides an alternative syntax for creating a lazy map iterator, equivalent to the generator expression `(f(args...) for args in zip(iterators...))`. This avoids allocating an intermediate collection.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_65\n\nLANGUAGE: julia\nCODE:\n```\niter = Iterators.map(x -> x*x, 1:5) # Lazy iterator for squares\ncollect(iter) # [1, 4, 9, 16, 25]\n\n# Equivalent generator:\niter_gen = (x*x for x in 1:5)\n```\n\n----------------------------------------\n\nTITLE: Iterating Over String Characters Directly in Julia\nDESCRIPTION: Demonstrates the standard, idiomatic, and efficient way to iterate through the characters of a string in Julia. The `for c in s` loop directly accesses each `Char` in the string `s` without requiring manual index management or error handling.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_19\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for c in s\n           println(c)\n       end\n∀\n\nx\n\n∃\n\ny\n```\n\n----------------------------------------\n\nTITLE: `ans` Variable Behavior\nDESCRIPTION: Both Julia and MATLAB set the `ans` variable to the result of the last expression in an interactive session (REPL). However, Julia does not set `ans` when running scripts non-interactively, unlike MATLAB.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nans\n```\n\n----------------------------------------\n\nTITLE: Eliminating @time Overhead by Measuring within a Function\nDESCRIPTION: Illustrates how to get a more accurate measure of a function's allocation by running the `@time` macro inside another function (`time_sum`). This avoids the allocation overhead associated with running `@time` in the global scope, showing that the `sum_arg` function itself performs zero heap allocations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_7\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest sumarg; filter = r\"[0-9\\.]+ seconds\"\njulia> time_sum(x) = @time sum_arg(x);\n\njulia> time_sum(x)\n  0.000002 seconds\n523.0007221951678\n```\n```\n\n----------------------------------------\n\nTITLE: Spawning Interactive Tasks Using Base.Threads - Julia\nDESCRIPTION: Demonstrates launching a function asynchronously as an interactive task using Julia's @spawn macro from Base.Threads, useful for managing task responsiveness in thread pools. Dependency: using Base.Threads. Input: function f(); Output: Task handle executing f() on an interactive thread.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.Threads\n@spawn :interactive f()\n```\n\n----------------------------------------\n\nTITLE: Documenting Combinatorics Functions for Arrays - Julia\nDESCRIPTION: Groups and documents key combinatorics operations on Julia arrays, such as permutation inversion and reversal, using the `@docs` macro. Primarily intended for documentation purposes, this block references in-place and out-of-place combinatorial operators; all dependencies are in Julia Base, with no runtime parameters.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/arrays.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.invperm\nBase.isperm\nBase.permute!(::Any, ::AbstractVector)\nBase.invpermute!\nBase.reverse(::AbstractVector; kwargs...)\nBase.reverseind\nBase.reverse!\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Multidimensional Loops with @nloops - Julia\nDESCRIPTION: This code demonstrates the use of the @nloops macro to programmatically create three nested for-loops that iterate over the axes of a multidimensional array A in Julia. It accumulates the result of each element using s += @nref 3 A i, which is syntactic sugar for referencing array elements via generated indices. Dependencies include the Base.Cartesian module. Expected parameters: 3 (loop count), i (index symbol prefix), A (array), with the code block as the loop body. The input is a multidimensional array A, and the output is the sum stored in s.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/cartesian.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n@nloops 3 i A begin\\n    s += @nref 3 A i\\nend\n```\n\n----------------------------------------\n\nTITLE: Navigating and Activating Package Environment using Pkg/Shell\nDESCRIPTION: Shows the commands to navigate back to the root directory of the `Example` package from the `test` subdirectory using `cd ..` and then activate the package's main environment using the Pkg REPL command `pkg> activate .`. This prepares the environment for running the package tests.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\nshell> cd ..\n```\n\nLANGUAGE: julia\nCODE:\n```\npkg> activate .\n```\n\n----------------------------------------\n\nTITLE: Indexing Strings to Extract Characters in Julia\nDESCRIPTION: Demonstrates accessing characters from a string using integer, `begin`, or `end` indices. Shows 1-based indexing and how positions map to individual `Char` outputs. No dependencies. Inputs are a string and index expressions; outputs are single characters.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> str[begin]\n'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n\njulia> str[1]\n'H': ASCII/Unicode U+0048 (category Lu: Letter, uppercase)\n\njulia> str[6]\n',': ASCII/Unicode U+002C (category Po: Punctuation, other)\n\njulia> str[end]\n'\\n': ASCII/Unicode U+000A (category Cc: Other, control)\n```\n\n----------------------------------------\n\nTITLE: Handling Immutability and Conversion of Byte Array Literals in Julia\nDESCRIPTION: Illustrates that byte array literals create read-only `Base.CodeUnits` objects. Assigning `b\"123\"` to `x` allows element access (`x[1]`), but attempting to modify an element (`x[1] = 0x32`) throws a `CanonicalIndexError` because `setindex!` is not defined. It also shows how to convert the immutable `CodeUnits` object into a standard mutable `Vector{UInt8}`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_59\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = b\"123\"\n3-element Base.CodeUnits{UInt8, String}:\n 0x31\n 0x32\n 0x33\n\njulia> x[1]\n0x31\n\njulia> x[1] = 0x32\nERROR: CanonicalIndexError: setindex! not defined for Base.CodeUnits{UInt8, String}\n[...]\n\njulia> Vector{UInt8}(x)\n3-element Vector{UInt8}:\n 0x31\n 0x32\n 0x33\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Piracy via Method Extension in a Module - Julia - julia\nDESCRIPTION: Illustrates type piracy by extending the Base .* operator for Symbol types within a module. The snippet includes a minimal module definition, imports Base.*, and defines multiplication on Symbol arguments to return a new Symbol. No external dependencies are required, but the pattern should be avoided as it can unexpectedly impact unrelated code throughout the Julia environment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nmodule A\nimport Base.*\n*(x::Symbol, y::Symbol) = Symbol(x,y)\nend\n\n```\n\n----------------------------------------\n\nTITLE: Multi-level and Trait-Based Dispatch for map with AbstractArray - Julia\nDESCRIPTION: These snippets illustrate how to define multi-level and trait-based dispatch for map functions in Julia. The primary map function dispatches on the result of Base.IndexStyle to select special trait implementations (IndexCartesian or IndexLinear), enabling different algorithmic optimizations based on type traits. This approach allows for extensible and high-performance generic code. The sample assumes existence of trait types and Base.IndexStyle definitions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\nmap(f, a::AbstractArray, b::AbstractArray) = map(Base.IndexStyle(a, b), f, a, b)\n# generic implementation:\nmap(::Base.IndexCartesian, f, a::AbstractArray, b::AbstractArray) = ...\n# linear-indexing implementation (faster)\nmap(::Base.IndexLinear, f, a::AbstractArray, b::AbstractArray) = ...\n```\n\n----------------------------------------\n\nTITLE: Installing Juliaup via Homebrew (Mac/Linux)\nDESCRIPTION: Installs Juliaup, the Julia version manager, using the Homebrew package manager on macOS or Linux. After running this command, Juliaup must be updated using standard Homebrew commands (e.g., 'brew upgrade juliaup').\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/installation.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nbrew install juliaup\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Random Generation via Sampler in Julia\nDESCRIPTION: Shows the core method signature `rand(rng, sampler)` that needs to be implemented when defining random generation for a custom type or distribution `X`. The `sampler` argument is an object returned by `Sampler(rng, X, repetition)`, which may store pre-computed data to optimize sampling.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nrand(rng, sampler)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Uniform Stride in a SubArray View (Julia)\nDESCRIPTION: Reshapes a range into a 4x2 matrix `A`. It then creates a view `A[2:2:4,:]` using a step range for the first dimension and slicing for the second. It computes the differences between consecutive elements after flattening the view (`[:]`). The output shows a constant difference (`2`), indicating a uniform stride in this specific case, which could theoretically allow efficient linear indexing, although not guaranteed by the index types alone.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> A = reshape(1:4*2, 4, 2)\n4×2 reshape(::UnitRange{Int64}, 4, 2) with eltype Int64:\n 1  5\n 2  6\n 3  7\n 4  8\n\njulia> diff(A[2:2:4,:][:])\n3-element Vector{Int64}:\n 2\n 2\n 2\n```\n```\n\n----------------------------------------\n\nTITLE: Cartesian Indexing for Ref Types in Julia\nDESCRIPTION: `RefArray` and `RefValue` objects now support indexing using `CartesianIndex()` with `getindex` and `setindex!`, allowing zero-dimensional indexing.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_113\n\nLANGUAGE: julia\nCODE:\n```\nx = Ref(10)\nx[CartesianIndex()] # getindex\nx[CartesianIndex()] = 20 # setindex!\n```\n\n----------------------------------------\n\nTITLE: Fused Multiply-Add `mul!` Function in Julia\nDESCRIPTION: The five-argument `mul!(C, A, B, α, β)` function now implements an inplace fused multiply-add operation: `C = A * B * α + C * β`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_136\n\nLANGUAGE: julia\nCODE:\n```\nusing LinearAlgebra\nA = randn(3,2); B = randn(2,4); C = zeros(3,4)\nalpha = 2.0; beta = 0.5\nmul!(C, A, B, alpha, beta) # Computes C = A*B*alpha + C*beta\n```\n\n----------------------------------------\n\nTITLE: Allocating Julia Arrays with Various Dimensions in C\nDESCRIPTION: Declares C functions for allocating Julia array objects (`jl_array_t*`). `jl_new_array` allocates an array given its full type (`atype`, including element type and dimensions) and dimensions specified as a Julia tuple (`dims`). `jl_alloc_array_1d` is a convenience function for allocating a 1D array given its type (`atype`) and number of elements (`nr`). `jl_alloc_array_nd` allocates an N-dimensional array given its type (`atype`), a C array of dimension sizes (`dims`), and the number of dimensions (`ndims`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_16\n\nLANGUAGE: c\nCODE:\n```\njl_array_t *jl_new_array(jl_value_t *atype, jl_tuple_t *dims);\njl_array_t *jl_alloc_array_1d(jl_value_t *atype, size_t nr);\njl_array_t *jl_alloc_array_nd(jl_value_t *atype, size_t *dims, size_t ndims);\n```\n\n----------------------------------------\n\nTITLE: Creating Regex Objects Programmatically with Regex() in Julia\nDESCRIPTION: Demonstrates constructing a `Regex` object dynamically using the `Regex()` constructor, which takes a string argument. This allows incorporating variables and programmatically generated patterns into the regex. The example uses string concatenation and interpolation, including the `\\Q...\\E` sequence for literal matching, cautioning about potential `\\E` injection. Requires the `Dates` standard library.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_56\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using Dates\n\njulia> d = Date(1962,7,10)\n1962-07-10\n\njulia> regex_d = Regex(\"Day \" * string(day(d)))\nr\"Day 10\"\n\njulia> match(regex_d, \"It happened on Day 10\")\nRegexMatch(\"Day 10\")\n\njulia> name = \"Jon\"\n\"Jon\"\n\njulia> regex_name = Regex(\"[\\\"( ]\\Q$name\\E[\\\") ]\")  # interpolate value of name\nr\"[\\\"( ]\\QJon\\E[\\\") ]\"\n\njulia> match(regex_name, \" Jon \")\nRegexMatch(\" Jon \")\n\njulia> match(regex_name, \"[Jon]\") === nothing\ntrue\n```\n\n----------------------------------------\n\nTITLE: MethodError Due to Type Mismatch in Function Arguments (Julia)\nDESCRIPTION: This set of snippets illustrates Julia's strict method dispatch by demonstrating errors thrown when calling 'f' with mismatched argument types. If the method signature (e.g., (Float64, Float64)) is not matched, such as passing (Float64, Int64), (Float32, Float64), (Float64, String), or (String, String), Julia throws a MethodError. The errors provide hints about available methods, but no automatic conversion is performed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(2.0, 3)\nERROR: MethodError: no method matching f(::Float64, ::Int64)\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  f(::Float64, !Matched::Float64)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> f(Float32(2.0), 3.0)\nERROR: MethodError: no method matching f(::Float32, ::Float64)\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  f(!Matched::Float64, ::Float64)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> f(2.0, \"3.0\")\nERROR: MethodError: no method matching f(::Float64, ::String)\nThe function `f` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  f(::Float64, !Matched::Float64)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> f(\"2.0\", \"3.0\")\nERROR: MethodError: no method matching f(::String, ::String)\nThe function `f` exists, but no method is defined for this combination of argument types.\n```\n\n----------------------------------------\n\nTITLE: Adding Environment Variables to Julia Cmd with addenv\nDESCRIPTION: Illustrates using the `addenv` function to add or modify specific environment variables for a Julia `Cmd` object without replacing the entire environment. It takes a command and a variable mapping (here, a Pair), merging these with the existing environment before executing the command.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\n# jldoctest\njulia> run(addenv(`sh -c \"echo foo \\$HOWLONG\"`, \"HOWLONG\" => \"ever!\"));\nfoo ever!\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Generic Function Utilities\nDESCRIPTION: This block uses the `@docs` directive to list utilities and concepts related to generic functions in Julia, including the `Function` type itself, method introspection (`hasmethod`, `applicable`), method ambiguity checks (`isambiguous`), low-level invocation (`invoke`, `invokelatest`), constructor invocation (`new`), function composition (`|>`, `∘`), and function argument fixing (`Fix1`, `Fix2`, `splat`). It guides the documentation generator to include these items.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCore.Function\nBase.hasmethod\nCore.applicable\nBase.isambiguous\nCore.invoke\nBase.@invoke\nBase.invokelatest\nBase.@invokelatest\nnew\nBase.:(|>)\nBase.:(∘)\nBase.ComposedFunction\nBase.splat\nBase.Fix\nBase.Fix1\nBase.Fix2\n```\n```\n\n----------------------------------------\n\nTITLE: Interpolating Non-AbstractString Objects in Julia\nDESCRIPTION: Illustrates that string interpolation calls `string()` on the interpolated object, which typically uses `print` or `show` methods. This example shows a Vector being converted to its string representation `[1, 2, 3]` when interpolated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_27\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> v = [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> \"v: $v\"\n\"v: [1, 2, 3]\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Operator and Function Methods in Julia Documentation - Julia\nDESCRIPTION: This code snippet utilizes Julia's documentation macro syntax (```@docs ... ```) to specify a comprehensive list of core mathematical operator overloads and function signatures from Julia's Base and Math modules. These listings enable the inclusion of automatically generated documentation for each operator/function in documentation builds, specifying the parameters, their types, and associated methods. Dependencies include Julia's standard library, and any package that can generate documentation from these signatures (e.g., Documenter.jl). Inputs are operator or function signatures in Julia's method syntax; outputs are rendered API documentation pages. Content is limited to documented functions; external code execution is not performed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/math.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.:-(::Any)\nBase.:(+)\nBase.:-(::Any, ::Any)\nBase.:*(::Any, ::Any...)\nBase.:(/)\nBase.:\\(::Any, ::Any)\nBase.:^(::Number, ::Number)\nBase.fma\nBase.muladd\nBase.inv(::Number)\nBase.div\nBase.div(::Any, ::Any, ::RoundingMode)\nBase.fld\nBase.cld\nBase.mod\nBase.rem\nBase.rem(::Any, ::Any, ::RoundingMode)\nBase.rem2pi\nBase.Math.mod2pi\nBase.divrem\nBase.fldmod\nBase.fld1\nBase.mod1\nBase.fldmod1\nBase.:(//)\nBase.rationalize\nBase.numerator\nBase.denominator\nBase.:(<<)\nBase.:(>>)\nBase.:(>>>)\nBase.bitrotate\nBase.:(:)\nBase.range\nBase.OneTo\nBase.StepRangeLen\nBase.logrange\nBase.LogRange\nBase.:(==)\nBase.:(!=)\nBase.:(!==)\nBase.:(<)\nBase.:(<=)\nBase.:(>)\nBase.:(>=)\nBase.cmp\nBase.:(~)\nBase.:(&)\nBase.:(|)\nBase.xor\nBase.nand\nBase.nor\nBase.:(!)\n&&\n||\n```\n```\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.isapprox\nBase.sin(::Number)\nBase.cos(::Number)\nBase.sincos(::Float64)\nBase.tan(::Number)\nBase.Math.sind\nBase.Math.cosd\nBase.Math.tand\nBase.Math.sincosd\nBase.Math.sinpi\nBase.Math.cospi\nBase.Math.tanpi\nBase.Math.sincospi\nBase.sinh(::Number)\nBase.cosh(::Number)\nBase.tanh(::Number)\nBase.asin(::Number)\nBase.acos(::Number)\nBase.atan(::Number)\nBase.Math.asind\nBase.Math.acosd\nBase.Math.atand\nBase.Math.sec(::Number)\nBase.Math.csc(::Number)\nBase.Math.cot(::Number)\nBase.Math.secd\nBase.Math.cscd\nBase.Math.cotd\nBase.Math.asec(::Number)\nBase.Math.acsc(::Number)\nBase.Math.acot(::Number)\nBase.Math.asecd\nBase.Math.acscd\nBase.Math.acotd\nBase.Math.sech(::Number)\nBase.Math.csch(::Number)\nBase.Math.coth(::Number)\nBase.asinh(::Number)\nBase.acosh(::Number)\nBase.atanh(::Number)\nBase.Math.asech(::Number)\nBase.Math.acsch(::Number)\nBase.Math.acoth(::Number)\nBase.Math.sinc\nBase.Math.cosc\nBase.Math.deg2rad\nBase.Math.rad2deg\nBase.Math.hypot\nBase.log(::Number)\nBase.log(::Number, ::Number)\nBase.log2\nBase.log10\nBase.log1p\nBase.Math.frexp\nBase.exp(::Float64)\nBase.exp2\nBase.exp10\nBase.Math.ldexp\nBase.Math.modf\nBase.expm1\nBase.round\nBase.Rounding.RoundingMode\nBase.Rounding.RoundNearest\nBase.Rounding.RoundNearestTiesAway\nBase.Rounding.RoundNearestTiesUp\nBase.Rounding.RoundToZero\nBase.Rounding.RoundFromZero\nBase.Rounding.RoundUp\nBase.Rounding.RoundDown\nBase.round(::Complex{<: AbstractFloat}, ::RoundingMode, ::RoundingMode)\nBase.ceil\nBase.floor\nBase.trunc\nBase.unsafe_trunc\nBase.min\nBase.max\nBase.minmax\nBase.Math.clamp\nBase.Math.clamp!\nBase.abs\nBase.Checked\nBase.Checked.checked_abs\nBase.Checked.checked_neg\nBase.Checked.checked_add\nBase.Checked.checked_sub\nBase.Checked.checked_mul\nBase.Checked.checked_div\nBase.Checked.checked_rem\nBase.Checked.checked_fld\nBase.Checked.checked_mod\nBase.Checked.checked_cld\nBase.Checked.checked_pow\nBase.Checked.add_with_overflow\nBase.Checked.sub_with_overflow\nBase.Checked.mul_with_overflow\nBase.abs2\nBase.copysign\nBase.sign\nBase.signbit\nBase.flipsign\nBase.sqrt(::Number)\nBase.isqrt\nBase.Math.cbrt(::AbstractFloat)\nBase.fourthroot(::Number)\nBase.real\nBase.imag\nBase.reim\nBase.conj\nBase.angle\nBase.cis\nBase.cispi\nBase.binomial\nBase.factorial\nBase.gcd\nBase.lcm\nBase.gcdx\nBase.ispow2\nBase.nextpow\nBase.prevpow\nBase.nextprod\nBase.invmod\nBase.powermod\nBase.ndigits\nBase.add_sum\nBase.widemul\nBase.Math.evalpoly\nBase.Math.@evalpoly\nBase.FastMath.@fastmath\n```\n```\n\n----------------------------------------\n\nTITLE: Conceptual IR Transformation Using PiNodes for Type Refinement (Julia)\nDESCRIPTION: This snippet demonstrates the conceptual insertion of PiNodes into the IR based on the preceding type check. The `PiNode(x, Int)` associated with `%x_int` signifies that within the `if` branch, the compiler can assume `x` is an `Int`. Similarly, `PiNode(x, Float64)` associated with `%x_float` allows assuming `x` is a `Float64` in the `else` branch. This refined type information enables further optimizations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n%x::Union{Int, Float64} # %x is some Union{Int, Float64} typed ssa value\nif isa(x, Int)\n    %x_int = PiNode(x, Int)\n    # use %x_int\nelse\n    %x_float = PiNode(x, Float64)\n    # use %x_float\nend\n```\n\n----------------------------------------\n\nTITLE: Refactoring @time Macro to Use a Runtime Helper Function in Julia\nDESCRIPTION: Presents an alternative implementation strategy for the `@time` macro by deferring the main logic to a regular function `timeit` called at runtime. The macro itself becomes simpler, primarily responsible for wrapping the user's expression `expr` in an anonymous function `() -> $(esc(expr))` and passing this closure to `timeit`. This approach avoids potential scope changes but introduces the overhead of a function call.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_46\n\nLANGUAGE: julia\nCODE:\n```\nmacro time(expr)\n    return :(timeit(() -> $(esc(expr))))\nend\nfunction timeit(f)\n    t0 = time_ns()\n    val = f()\n    t1 = time_ns()\n    println(\"elapsed time: \", (t1-t0)/1e9, \" seconds\")\n    return val\nend\n```\n\n----------------------------------------\n\nTITLE: Command and Argument Introspection - Julia\nDESCRIPTION: Demonstrates how to access and iterate over the program name and its arguments as elements of a Cmd object's vector interface, making it easy to introspect or manipulate arguments programmatically. Useful for meta-programming or debugging constructed commands. No additional dependencies; input is a Cmd object.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_3\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> collect(`echo \"foo bar\"`)\n2-element Vector{String}:\n \"echo\"\n \"foo bar\"\n\njulia> `echo \"foo bar\"`[2]\n\"foo bar\"\n```\n```\n\n----------------------------------------\n\nTITLE: Invalid Syntax for Computed Type Parameters in Julia Struct Definition\nDESCRIPTION: This snippet shows an *invalid* attempt to define a Julia struct `ConstrainedType` where a type parameter (`N+1`) is computed directly from another parameter (`N`). Julia's type system does not allow computations or direct value constraints within the `struct` definition's parameter list. This serves as a counter-example before showing the correct approach using constructors.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nstruct ConstrainedType{T,N,N+1} # NOTE: INVALID SYNTAX\n    A::Array{T,N}\n    B::Array{T,N+1}\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Renamed fill! Methods on Special Matrices - Julia\nDESCRIPTION: Highlights renaming of 'fill!' to 'fillstored!' for Diagonal and AbstractTriangular matrices, via Base.LinAlg, to clarify the semantics of the method. The method mutates the stored elements of these types. Inputs: matrix and value; output: mutated matrix.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_157\n\nLANGUAGE: julia\nCODE:\n```\nBase.LinAlg.fillstored!(A, x)\n```\n\n----------------------------------------\n\nTITLE: Examining TypeName and Wrapper Fields for Parametric Types - Julia\nDESCRIPTION: This code snippet explores how to introspect and compare the internal metadata of Julia parametric types using the `.name` and `.wrapper` fields. The code inspects the `TypeName` object, prints its contents, and checks pointer equivalence of the wrapper field between different type instances. Useful for understanding how distinct parameterizations relate to each other. Inputs are type objects; outputs are internal details and memory pointers. Uses only Julia base.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> dump(Array{Int,1}.name)\nTypeName\n  name: Symbol Array\n  module: Module Core\n  names: empty SimpleVector\n  wrapper: UnionAll\n    var: TypeVar\n      name: Symbol T\n      lb: Union{}\n      ub: abstract type Any\n    body: UnionAll\n      var: TypeVar\n        name: Symbol N\n        lb: Union{}\n        ub: abstract type Any\n      body: mutable struct Array{T, N} <: DenseArray{T, N}\n  cache: SimpleVector\n    ...\n\n  linearcache: SimpleVector\n    ...\n\n  hash: Int64 -7900426068641098781\n  mt: MethodTable\n    name: Symbol Array\n    defs: Nothing nothing\n    cache: Nothing nothing\n    max_args: Int64 0\n    module: Module Core\n    : Int64 0\n    : Int64 0\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> pointer_from_objref(Array)\nPtr{Cvoid} @0x00007fcc7de64850\n\njulia> pointer_from_objref(Array.body.body.name.wrapper)\nPtr{Cvoid} @0x00007fcc7de64850\n\njulia> pointer_from_objref(Array{TV,NV})\nPtr{Cvoid} @0x00007fcc80c4d930\n\njulia> pointer_from_objref(Array{TV,NV}.name.wrapper)\nPtr{Cvoid} @0x00007fcc7de64850\n```\n\n----------------------------------------\n\nTITLE: Correct Usage: Calling Julia API from a Single User-Created Thread\nDESCRIPTION: This C code shows a *correct* way to use the Julia C API from a user-created thread. A new thread is created with `pthread_create` which then executes `func`. Inside `func`, `jl_init` is called, followed by other Julia API calls (`jl_eval_string`), and finally `jl_atexit_hook`. This is safe because all Julia API interactions happen within the *same* thread, even though it's not the main application thread.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_37\n\nLANGUAGE: c\nCODE:\n```\nvoid *func(void*)\n{\n    // Okay, all jl_...() calls from the same thread,\n    // even though it is not the main application thread\n    jl_init();\n    jl_eval_string(\"println(Threads.threadid())\");\n    jl_atexit_hook(0);\n    return NULL;\n}\n\nint main()\n{\n    pthread_t t;\n    // Create a new thread, which runs func()\n    pthread_create(&t, NULL, func, NULL);\n    pthread_join(t, NULL);\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Tuple/UnionAll Type Equivalence - Julia REPL - Julia\nDESCRIPTION: Computes a type equality involving a diagonal variable within a union, verifying that Tuple{Union{Nothing,T},T} where T is equivalent to Union{Tuple{Nothing,Any}, Tuple{T,T} where T}. Inputs: Types; Outputs: Boolean or type equivalence. Useful for understanding advanced type system equivalence handling in Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_15\n\nLANGUAGE: jldoctest\nCODE:\n```\n(Tuple{Union{Nothing,T},T} where T) == Union{Tuple{Nothing,Any}, Tuple{T,T} where T}\n```\n\n----------------------------------------\n\nTITLE: Introspecting Julia's UnionAll and TypeVar for Array Type - Julia\nDESCRIPTION: This snippet uses the `dump` function to inspect the internal representation of the `Array` type in Julia, revealing how `UnionAll` and nested `TypeVar`s define its parametric structure. It allows developers to see how type variables are bounded and wrapped, and the underlying fields of `Array` as a parametric type. Inputs are Julia's type objects; output is a tree-like structure showing type internals. No dependencies beyond Julia base.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> dump(Array)\nUnionAll\n  var: TypeVar\n    name: Symbol T\n    lb: Union{}\n    ub: abstract type Any\n  body: UnionAll\n    var: TypeVar\n      name: Symbol N\n      lb: Union{}\n      ub: abstract type Any\n    body: mutable struct Array{T, N} <: DenseArray{T, N}\n      ref::MemoryRef{T}\n      size::NTuple{N, Int64}\n```\n\n----------------------------------------\n\nTITLE: Setting Debug Information Level (Julia Flag)\nDESCRIPTION: The `-g` or `--debug-info` command-line flags control the inclusion of debug information in the generated native code. Package image caches are only considered valid if created with the exact same debug flag setting, as it impacts code generation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n-g, --debug-info\n```\n\n----------------------------------------\n\nTITLE: Using @static for Conditional ccall Declarations - Julia\nDESCRIPTION: This snippet demonstrates how to use the @static macro in Julia to conditionally choose function symbols within a ccall based on the operating system. It selects :_fopen for Windows and :fopen otherwise, ensuring the appropriate symbol is used at compile-time. No additional dependencies are required beyond Julia; arguments for ccall are omitted for brevity.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/handling-operating-system-variation.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nccall((@static Sys.iswindows() ? :_fopen : :fopen), ...)\n```\n\n----------------------------------------\n\nTITLE: Generating a Julia Package and Test Directory using Pkg/Shell\nDESCRIPTION: Lists shell and Julia Pkg REPL commands to generate a new package named `Example`, navigate into its directory using `cd`, create a `test` subdirectory using `mkdir`, and activate the package environment using `pkg> activate .`. This sequence sets up the basic project structure required before adding source code and tests.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\npkg> generate Example\n```\n\nLANGUAGE: shell\nCODE:\n```\nshell> cd Example\nshell> mkdir test\n```\n\nLANGUAGE: julia\nCODE:\n```\npkg> activate .\n```\n\n----------------------------------------\n\nTITLE: Connecting to a TCP Server Using Sockets in Julia\nDESCRIPTION: This snippet demonstrates establishing a TCP client connection on port 2000 using the connect function. After a server is running on the specified port, running this connects as a client. No additional dependencies beyond Sockets are required. Input is the TCP port to connect to (here, 2000). Output is a TCPSocket object and any data the server sends upon connection (such as a greeting message printed on the server side).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_12\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> connect(2000)\nTCPSocket(open, 0 bytes waiting)\n\njulia> Hello World\n```\n\n----------------------------------------\n\nTITLE: Defining Julia Strings with Unicode Escapes\nDESCRIPTION: Demonstrates how to create a Julia string literal containing Unicode characters specified via `\\u` escape sequences. The example assigns the string \"∀ x ∃ y\" to the variable `s`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_14\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> s = \"\\u2200 x \\u2203 y\"\n\"∀ x ∃ y\"\n```\n\n----------------------------------------\n\nTITLE: Julia Function with Keyword Arguments: circle - Julia\nDESCRIPTION: Defines a high-level Julia function that takes both positional and keyword arguments (with defaults and variadic keywords). The function header demonstrates default values, type annotations, and variable argument handling. Used to illustrate Julia's lowering and method generation for keyword arguments; depends on Julia's base language and type system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nfunction circle(center, radius; color = black, fill::Bool = true, options...)\n    # draw\nend\n```\n\n----------------------------------------\n\nTITLE: Using Basic Integer Indexing on a Custom Type in Julia\nDESCRIPTION: Demonstrates accessing an element of the `Squares` object using the integer indexing implemented via `getindex`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_9\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Squares(100)[23]\n529\n```\n\n----------------------------------------\n\nTITLE: Using JL_NOTSAFEPOINT Annotation - Julia GC Static Analyzer - C\nDESCRIPTION: This C code demonstrates how to use the JL_NOTSAFEPOINT annotation to mark a function as not triggering a GC safepoint, allowing values to remain unrooted safely across calls. Dependencies include the Julia runtime and the analyzer macros defined in analyzer_annotations.h. Inputs and outputs are typical for C functions, and care must be taken that no safepoints are actually present.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-sa.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid jl_get_one() JL_NOTSAFEPOINT {\n  return 1;\n}\n\njl_value_t *example() {\n  jl_value_t *val = jl_alloc_whatever();\n  // This is valid, even though `val` is unrooted, because\n  // jl_get_one is not a safepoint\n  jl_get_one();\n  return val;\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Broadcast and Vectorization Constructs via JuliaDoc - Julia\nDESCRIPTION: Showcases the interface for broadcasting and vectorization in Julia, including the `broadcast` function, in-place broadcasting, and broadcast style customization types/functions. This code snippet compiles documentation sections for these constructs using the `@docs` macro. Assumes user understanding of Julia's multiple dispatch and documentation system. There is no input or output except for generated documentation. Limitations: Only operates for documentation generation, not executable code.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/arrays.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.broadcast\nBase.Broadcast.broadcast!\nBase.@__dot__\nBase.Broadcast.BroadcastFunction\n```\n```\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.BroadcastStyle\nBase.Broadcast.AbstractArrayStyle\nBase.Broadcast.ArrayStyle\nBase.Broadcast.DefaultArrayStyle\nBase.Broadcast.broadcastable\nBase.Broadcast.combine_axes\nBase.Broadcast.combine_styles\nBase.Broadcast.result_style\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Variable in Julia `let` Block without Immediate Assignment\nDESCRIPTION: Shows how a `let` block creates a new hard scope in Julia. A variable `x` is introduced within the `let` scope without an initial value and is assigned later within a `for` loop. The final value assigned to `x` (4) within the loop is then returned as the result of the `let` block.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_17\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> var1 = let x\n           for i in 1:5\n               (i == 4) && (x = i; break)\n           end\n           x\n       end\n4\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying Methods for a Function in Julia\nDESCRIPTION: Demonstrates the use of the `methods()` function in Julia to list the available methods defined for a given function (represented here as `my_func`). According to the release notes, the output format for this is now prettified and colored consistently with method printing in stacktraces.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\nmethods(my_func)\n```\n\n----------------------------------------\n\nTITLE: Implementing Hypotenuse Calculation with Multiple 'return' Statements\nDESCRIPTION: Defines a function `hypot(x, y)` that calculates the length of the hypotenuse of a right triangle, using a method designed to avoid numerical overflow. It demonstrates a practical use case for the `return` keyword within conditional logic (`if` statements) to return different values based on the inputs `x` and `y`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_10\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function hypot(x, y)\n           x = abs(x)\n           y = abs(y)\n           if x > y\n               r = y/x\n               return x*sqrt(1 + r*r)\n           end\n           if y == 0\n               return x\n           end\n           r = x/y\n           return y*sqrt(1 + r*r)\n       end\nhypot (generic function with 1 method)\n\njulia> hypot(3, 4)\n5.0\n```\n\n----------------------------------------\n\nTITLE: Defining a Pathological Non-Deterministic Generated Function (Incorrect Usage) in Julia\nDESCRIPTION: Defines a generated function `baz` whose returned quoted expression depends on `rand()`. This introduces non-determinism into the code generation process, which is incorrect and can lead to undefined behavior and runtime corruption. This example explicitly demonstrates what *not* to do.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_71\n\nLANGUAGE: julia\nCODE:\n```\njulia> @generated function baz(x)\n           if rand() < .9\n               return :(x^2)\n           else\n               return :(\"boo!\")\n           end\n       end\nbaz (generic function with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Calling a Julia Function (sqrt) from C using jl_call1\nDESCRIPTION: This snippet demonstrates how to call the Julia `sqrt` function from C. It retrieves the function handle using `jl_get_function`, boxes a C double into a Julia `Float64` using `jl_box_float64`, and then calls the function with one argument using `jl_call1`. Requires linking against the Julia library and proper initialization.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_10\n\nLANGUAGE: c\nCODE:\n```\njl_function_t *func = jl_get_function(jl_base_module, \"sqrt\");\njl_value_t *argument = jl_box_float64(2.0);\njl_value_t *ret = jl_call1(func, argument);\n```\n\n----------------------------------------\n\nTITLE: Tab-completion of Function Keyword Arguments - Julia-REPL\nDESCRIPTION: Shows how keyword arguments are suggested after entering a semicolon and pressing tab during function calls. Useful for quickly discovering optional parameters for functions in the Base or user-defined libraries; leverages REPL's completion system and argument annotations.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_23\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> split(\"1 1 1\", [TAB]\nsplit(str::AbstractString; limit, keepempty) in Base at strings/util.jl:302\nsplit(str::T, splitter; limit, keepempty) where T<:AbstractString in Base at strings/util.jl:277\n```\n\n----------------------------------------\n\nTITLE: Type Promotion in Updating Operators in Julia - Julia\nDESCRIPTION: This snippet illustrates that Julia's updating operators can cause the type of the left-hand variable to change as a result of the operation and assignment. The example begins by creating a UInt8 variable, performs an in-place multiplication (with *=), and checks the resulting type. Dependencies: Julia REPL and understanding Julia's promotion/conversion behaviors.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = 0x01; typeof(x)\nUInt8\n\njulia> x *= 2 # Same as x = x * 2\n2\n\njulia> typeof(x)\nInt64\n```\n\n----------------------------------------\n\nTITLE: Creating a System Image with the New LLVM Pass Manager and Julia Plugin (Bash)\nDESCRIPTION: This sequence uses Julia's codegen plugin with LLVM's new pass manager to generate an optimized system image. First, opt is invoked with the libjulia-codegen.so pass plugin and the julia meta-pass, followed by llc and the compiler. This workflow enables the use of julia-specific LLVM passes for further optimization and is compatible with custom and development builds.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./usr/tools/opt -load-pass-plugin=libjulia-codegen.so --passes='julia' -o opt.bc unopt.bc\n./usr/tools/llc -o sys.o opt.bc\n./usr/tools/cc -shared -o sys.so sys.o\n```\n\n----------------------------------------\n\nTITLE: Listing Recorded Processes with rr Debugger\nDESCRIPTION: Example command `rr ps` for the `rr` (record and replay) debugger. This command lists the processes captured during a recording session, useful for identifying a specific process (like the one failing during Julia precompilation) for debugging.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/aot.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nrr ps\n```\n\n----------------------------------------\n\nTITLE: Accessing Julia Array Data in C\nDESCRIPTION: This C snippet demonstrates how to get a direct pointer to the underlying data buffer of a Julia array (`jl_array_t* x`). The function `jl_array_data` is used, templated with the expected C data type (`double`). The returned pointer (`xData`) can then be used to read or modify the array elements directly.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_26\n\nLANGUAGE: c\nCODE:\n```\ndouble *xData = jl_array_data(x, double);\n```\n\n----------------------------------------\n\nTITLE: Importing Julia Module Names with Absolute Paths (REPL Error)\nDESCRIPTION: Shows an `ArgumentError` that occurs when attempting to import a name (`add_D`) from a submodule (`ParentModule.SubA`) using its absolute path directly in the REPL. This fails because `ParentModule`, defined interactively, isn't recognized as a package in the current load path, unlike modules loaded from files as part of a package.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_24\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> import ParentModule.SubA: add_D\nERROR: ArgumentError: Package ParentModule not found in current path.\n\n```\n\n----------------------------------------\n\nTITLE: Inspecting Thread Pool Configuration - Julia REPL\nDESCRIPTION: Provides a sequence of REPL commands to inspect thread pool assignments in Julia: using Base.Threads for thread pool functions, then calls to nthreadpools(), threadpool(), nthreads(:default), nthreads(:interactive), and nthreads(). Requires standard library. Shows how to determine thread pool allocations and counts.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_10\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Base.Threads\n\njulia> nthreadpools()\n2\n\njulia> threadpool() # the main thread is in the interactive thread pool\n:interactive\n\njulia> nthreads(:default)\n3\n\njulia> nthreads(:interactive)\n1\n\njulia> nthreads()\n3\n```\n\n----------------------------------------\n\nTITLE: Extending Methods After Specific `import` in Julia\nDESCRIPTION: Shows the alternative way to enable method extension: importing the specific function name using `import .NiceStuff: nice`. This allows adding methods (like `nice(::Mouse)`) without needing to qualify the function name.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_12\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> import .NiceStuff: nice\n\njulia> struct Mouse end\n\njulia> nice(::Mouse) = \"nice 🐭\"\nnice (generic function with 3 methods)\n```\n\n----------------------------------------\n\nTITLE: Opting into @main After Function Definition (Bash/Julia)\nDESCRIPTION: Shows that the `@main` macro can be invoked after the `main` function has already been defined within the same evaluation scope (like a script or a `-e` expression). This successfully opts into the automatic execution behavior, causing the defined `main` function to run and print \"Hello World!\".\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ julia -e 'main(args) = println(\"Hello World!\"); @main'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Tab Completion in Julia REPL - Julia-REPL\nDESCRIPTION: These snippets illustrate basic tab-completion usage in the Julia REPL, showing how partial function or type names are auto-completed or suggested. This feature is built into the Julia REPL (no additional dependencies), and lets users quickly complete identifiers, with the recognized scope and ambiguity built-in. Input is via the REPL, output is the suggested completions or the completed term itself.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_15\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> x[TAB]\njulia> xor\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> mapf[TAB]\njulia> mapfold\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> mapfold[TAB]\nmapfoldl mapfoldr\n```\n\n----------------------------------------\n\nTITLE: Replacing Environment Variables for Julia Cmd with setenv\nDESCRIPTION: Shows the use of the `setenv` function to define the execution environment for a Julia `Cmd` object. `setenv` takes a command and an environment mapping, running the command with only the specified variables set, effectively replacing the parent process's environment for the child process.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\n# jldoctest\njulia> run(setenv(`sh -c \"echo foo \\$HOWLONG\"`, (\"HOWLONG\" => \"ever!\",)));\nfoo ever!\n```\n\n----------------------------------------\n\nTITLE: Using promote for Numeric Type Conversion in Julia\nDESCRIPTION: Demonstrates how the `promote` function in Julia converts multiple numeric arguments (integers, floats, rationals, complex numbers) to a common, suitable type. Shows input arguments and the resulting tuple of promoted values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> promote(1, 2.5)\n(1.0, 2.5)\n\njulia> promote(1, 2.5, 3)\n(1.0, 2.5, 3.0)\n\njulia> promote(2, 3//4)\n(2//1, 3//4)\n\njulia> promote(1, 2.5, 3, 3//4)\n(1.0, 2.5, 3.0, 0.75)\n\njulia> promote(1.5, im)\n(1.5 + 0.0im, 0.0 + 1.0im)\n\njulia> promote(1 + 2im, 3//4)\n(1//1 + 2//1*im, 3//4 + 0//1*im)\n```\n\n----------------------------------------\n\nTITLE: Safe DTrace Probe Invocation Pattern - Semaphore Guarded - C\nDESCRIPTION: This C code snippet illustrates a performance-safe probe invocation pattern in Julia's runtime. The probe is called only if enabled via a semaphore macro, which checks if probe tracing should run to avoid expensive computation unless necessary. Typically found in C or C++ source integrating DTrace/USDT. Dependencies: Julia with probe header generated, only used when probes have expensive arguments. Outputs data to probe consumers when triggered.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n  if (JL_PROBE_{PROBE}_ENABLED())\n    auto expensive_arg = ...;\n    JL_PROBE_{PROBE}(expensive_arg);\n```\n\n----------------------------------------\n\nTITLE: Redirecting Standard Output to a File - Julia\nDESCRIPTION: Illustrates redirecting Julia's standard output to a file via `redirect_stdout`, enabling programmatic capture of all console outputs within a block. Example opens a file, routes output to it, then closes the file. This is useful for logging or capturing program output for post-processing. Dependencies: Julia base, file permissions for write access. Inputs: filename and content to print. Limitations: Must ensure file is closed after operation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n# Open file for writing\\nout_file = open(\"output.txt\", \"w\")\\n\\n# Redirect stdout to file\\nredirect_stdout(out_file) do\\n    # Your code here\\n    println(\"This output goes to `out_file` via the `stdout` variable.\")\\nend\\n\\n# Close file\\nclose(out_file)\\n\n```\n\n----------------------------------------\n\nTITLE: Confusing Type and Instance Method Patterns - Anti-pattern Example - Julia - julia\nDESCRIPTION: Includes method definitions that create ambiguity between instances and types by overloading functions for both the type and its instances. This can result in non-transparent or error-prone APIs. The surround context recommends choosing one paradigm for clarity. This example does not require any external dependencies and serves as a warning about overloading on Type{MyType} versus MyType.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nfoo(::Type{MyType}) = ...\nfoo(::MyType) = foo(MyType)\n\n```\n\n----------------------------------------\n\nTITLE: Generating a Minimal Working Example (MWE) Package in Julia Pkg REPL\nDESCRIPTION: Demonstrates using the `generate` command within the Julia Pkg REPL to create a new package named `MWE`. This is used to create a minimal environment for reproducing and diagnosing precompilation hangs suspected to be caused by a specific dependency.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/precompile_hang.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n(@v1.10) pkg> generate MWE\n  Generating  project MWE:\n    MWE\\Project.toml\n    MWE\\src\\MWE.jl\n```\n\n----------------------------------------\n\nTITLE: Comparing Field Type Stability in Parameterized vs. Abstract-Typed Structs\nDESCRIPTION: Instantiates `MyType` (parameterized) and `MyStillAmbiguousType` (abstract field type). For `MyType{Float64}`, the type of `m.a` is fixed as `Float64`, even when assigned a `Float32` (it gets converted). For `MyStillAmbiguousType`, the type of `t.a` can change at runtime (from `Float64` to `Float32`), demonstrating type instability which hurts performance.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_14\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> m = MyType(3.2)\nMyType{Float64}(3.2)\n\njulia> t = MyStillAmbiguousType(3.2)\nMyStillAmbiguousType(3.2)\n\njulia> typeof(m)\nMyType{Float64}\n\njulia> typeof(t)\nMyStillAmbiguousType\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> typeof(t.a)\nFloat64\n\njulia> t.a = 4.5f0\n4.5f0\n\njulia> typeof(t.a)\nFloat32\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> m.a = 4.5f0\n4.5f0\n\njulia> typeof(m.a)\nFloat64\n```\n\n----------------------------------------\n\nTITLE: Listing Low-Level Synchronization Primitive - Julia\nDESCRIPTION: This snippet documents the Base.Threads.SpinLock primitive, exposing details necessary for constructing higher-level synchronization objects. The SpinLock provides low-level locking mechanisms between threads, and the snippet ensures that API docs are generated for it. Intended for advanced users constructing custom concurrency controls.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/multi-threading.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nBase.Threads.SpinLock\\n```\n```\n\n----------------------------------------\n\nTITLE: Understanding MethodError due to Parametric Type Invariance (Julia)\nDESCRIPTION: Illustrates a common `MethodError` in Julia arising from parametric type invariance. Defining a function `foo(x::Vector{Real})` and calling it with `foo([1])` (which is a `Vector{Int64}`) fails because `Vector{Int64}` is not considered a subtype of `Vector{Real}`. This demonstrates that parametric types like `Vector` are invariant in their type parameters. The solution involves using type parameters like `foo(bar::Vector{T}) where {T<:Real}` or the shorthand `foo(bar::Vector{<:Real})`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_31\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> foo(x::Vector{Real}) = 42\nfoo (generic function with 1 method)\n\njulia> foo([1])\nERROR: MethodError: no method matching foo(::Vector{Int64})\nThe function `foo` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  foo(!Matched::Vector{Real})\n   @ Main none:1\n\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Broadcast Styles for Sparse Arrays - Julia\nDESCRIPTION: Illustrates a convention for creating and combining broadcast styles for sparse arrays in Julia (SparseVec, SparseMat). Subtypes of AbstractArrayStyle are defined for vectors and matrices, and broadcast style resolution is registered for their array types. Also defines logic for merging vector and matrix styles according to dimensionality, returning the appropriate custom style or defaulting to Julia's fallback dense style for higher dimensions. Dependencies: SparseVector, SparseMatrixCSC types from stdlib; intended for developers extending broadcast support for new container types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\nstruct SparseVecStyle <: Broadcast.AbstractArrayStyle{1} end\nstruct SparseMatStyle <: Broadcast.AbstractArrayStyle{2} end\nBase.BroadcastStyle(::Type{<:SparseVector}) = SparseVecStyle()\nBase.BroadcastStyle(::Type{<:SparseMatrixCSC}) = SparseMatStyle()\n```\n\nLANGUAGE: julia\nCODE:\n```\nSparseVecStyle(::Val{0}) = SparseVecStyle()\nSparseVecStyle(::Val{1}) = SparseVecStyle()\nSparseVecStyle(::Val{2}) = SparseMatStyle()\nSparseVecStyle(::Val{N}) where N = Broadcast.DefaultArrayStyle{N}()\n```\n\n----------------------------------------\n\nTITLE: Defining Opaque Pointer Type for Julia Values in C\nDESCRIPTION: Defines `jl_pvalue_t` as a C typedef for a pointer to an opaque `jl_value_t` struct. This represents a generic Julia object in memory without revealing its internal structure and serves as the fundamental pointer type for interacting with Julia objects from C.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct jl_value_t* jl_pvalue_t;\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation Header and Introduction in Julia\nDESCRIPTION: This Julia code snippet, executed within an `@eval` block, dynamically generates the header and introductory paragraph for the Julia documentation. It determines the current Julia version (major.minor or major.minor-prerelease) using the `VERSION` global constant and constructs the appropriate version string. If it's a pre-release version, a \"Work in progress\" warning is added. The generated Markdown content is written to an `IOBuffer` and then parsed using the `Markdown` module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@eval\nio = IOBuffer()\nrelease = isempty(VERSION.prerelease)\nv = \"$(VERSION.major).$(VERSION.minor)\"\n!release && (v = v*\"-$(first(VERSION.prerelease))\")\nprint(io, \"\"\"\n    # Julia $(v) Documentation\n\n    Welcome to the documentation for Julia $(v).\n\n    \"\"\")\nif !release\n    print(io,\"\"\"\n        !!! warning \"Work in progress!\"\n            This documentation is for an unreleased, in-development, version of Julia.\n        \"\"\")\nend\nimport Markdown\nMarkdown.parse(String(take!(io)))\n```\n```\n\n----------------------------------------\n\nTITLE: Default `convert` Implementation for Numeric Types in Julia\nDESCRIPTION: Shows the universal `convert` definition provided in Julia Base for converting between different `Number` subtypes. This method takes a target type `T` (where `T<:Number`) and a `Number` `x`, calling the constructor `T(x)` and ensuring the result is of type `T`. This simplifies defining new numeric types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nconvert(::Type{T}, x::Number) where {T<:Number} = T(x)::T\n```\n\n----------------------------------------\n\nTITLE: Accessing Julia Object Fields by Index or Name in C\nDESCRIPTION: Declares C functions for accessing fields within a Julia object. `jl_get_nth_field_checked` retrieves a field by its zero-based index (`i`), performing bounds checking. `jl_get_field` retrieves a field by its name (`fld`). Both take the object pointer (`v` or `o`) and return a pointer (`jl_value_t *`) to the field's value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *jl_get_nth_field_checked(jl_value_t *v, size_t i);\njl_value_t *jl_get_field(jl_value_t *o, char *fld);\n```\n\n----------------------------------------\n\nTITLE: Enabling HTML Rendering for Custom Types in Julia\nDESCRIPTION: Implements a show overload for Polar objects when output in HTML contexts, such as Jupyter Notebooks, using the MIME\"text/html\" type. Uses HTML formatting for mathematical expressions, including italics and superscripts, for clearer visual display. Allows seamless rendering in environments that support custom HTML output.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_71\n\nLANGUAGE: julia\nCODE:\n```\nBase.show(io::IO, ::MIME\"text/html\", z::Polar{T}) where {T} =\\n    println(io, \"<code>Polar{\\$T}</code> complex number: \",\\n            z.r, \" <i>e</i><sup>\", z.Θ, \" <i>i</i></sup>\")\n```\n\n----------------------------------------\n\nTITLE: Documenting Iterable Collection Functions in Julia\nDESCRIPTION: A documentation system directive (`@docs`) listing numerous functions that operate on general iterable collections in Julia. This includes membership tests (`in`), element type queries (`eltype`), reduction operations (`reduce`, `sum`, `prod`), searching (`findmax`, `findmin`), mapping (`map`), filtering (`filter`), and others.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.in\nBase.:∉\nBase.hasfastin\nBase.eltype\nBase.indexin\nBase.unique\nBase.unique!\nBase.allunique\nBase.allequal\nBase.reduce(::Any, ::Any)\nBase.reduce(::Any, ::AbstractArray)\nBase.foldl(::Any, ::Any)\nBase.foldr(::Any, ::Any)\nBase.maximum\nBase.maximum!\nBase.minimum\nBase.minimum!\nBase.extrema\nBase.extrema!\nBase.argmax\nBase.argmin\nBase.findmax\nBase.findmin\nBase.findmax!\nBase.findmin!\nBase.sum\nBase.sum!\nBase.prod\nBase.prod!\nBase.any(::Any)\nBase.any(::AbstractArray, ::Any)\nBase.any!\nBase.all(::Any)\nBase.all(::AbstractArray, ::Any)\nBase.all!\nBase.count\nBase.foreach\nBase.map\nBase.map!\nBase.mapreduce(::Any, ::Any, ::Any)\nBase.mapfoldl(::Any, ::Any, ::Any)\nBase.mapfoldr(::Any, ::Any, ::Any)\nBase.first\nBase.last\nBase.front\nBase.tail\nBase.step\nBase.collect(::Any)\nBase.collect(::Type, ::Any)\nBase.filter\nBase.filter!\nBase.replace(::Any, ::Pair...)\nBase.replace(::Base.Callable, ::Any)\nBase.replace!\nBase.rest\nBase.split_rest\n```\n\n----------------------------------------\n\nTITLE: Using else Clause in try/catch for Success Case Logic - Julia\nDESCRIPTION: This snippet introduces the use of the else clause in try/catch blocks (Julia 1.8+). It shows how to execute code only if no exception was thrown in the try block, as opposed to placing such code in try where it could be inadvertently caught. It leverages local scoping to enable variable access in else/finally blocks. Requires Julia 1.8 or newer.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\nlocal x\ntry\n    x = read(\"file\", String)\ncatch\n    # handle read errors\nelse\n    # do something with x\nend\n\n```\n\n----------------------------------------\n\nTITLE: Extracting Substrings via Range Indexing in Julia\nDESCRIPTION: Demonstrates extracting a substring from a string using an integer range and distinguishing between a `Char` and a `String` containing one character. Emphasizes the difference between `str[k]` and `str[k:k]`. Also shows range slicing returns string objects.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\njulia> str[4:9]\n\"lo, wo\"\n\njulia> str[6]\n',': ASCII/Unicode U+002C (category Po: Punctuation, other)\n\njulia> str[6:6]\n\",\"\n```\n\n----------------------------------------\n\nTITLE: Separating Julia Options from Script Arguments (Bash)\nDESCRIPTION: Illustrates the use of the `--` delimiter to separate options intended for the Julia executable (e.g., `--color=yes`, `-O` for optimization) from the arguments intended for the script (`script.jl`, `arg1`, `arg2..`). This ensures arguments are correctly passed to the script and not interpreted by Julia itself.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ julia --color=yes -O -- script.jl arg1 arg2..\n```\n\n----------------------------------------\n\nTITLE: Calling C Functions with Automatic Type Conversion in Julia (Julia)\nDESCRIPTION: This snippet exemplifies how Julia automatically applies type conversion when calling a C function using the @ccall macro. The macro ensures that provided arguments are converted to the required low-level types before the call, utilizing Base.cconvert for type adaptation. Both Int32 and Float64 are shown as example argument types, with the expected output being the correct call to a C function, ensuring proper value types and memory safety. Prerequisites include having Julia installed, defining or accessing the relevant C library (e.g., libfoo), and ensuring the argument types match between Julia and C to avoid undefined behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n@ccall \"libfoo\".foo(x::Int32, y::Float64)::Cvoid\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Linear Algebra Operations (Matrix Division and Multiplication) in Julia\nDESCRIPTION: This Julia snippet demonstrates how to benchmark basic linear algebra operations. It first creates two large random matrices (`A` and `B`) using `randn`. It then uses the `@btime` macro from the `BenchmarkTools` package to measure the performance of matrix division (`A \\ B`) and matrix multiplication (`A * B`). This code requires the `BenchmarkTools` package to be installed and imported.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\nusing BenchmarkTools\nA = randn(1000, 1000)\nB = randn(1000, 1000)\n@btime $A \\ $B\n@btime $A * $B\n```\n\n----------------------------------------\n\nTITLE: Variable Assignment Behavior in Nested For Loops in Julia\nDESCRIPTION: Illustrates variable assignment behavior within Julia's shorthand nested loop syntax. Even though the outer loop variable `i` is assigned the value `0` (`i = 0`) inside the loop body, this assignment does not affect subsequent iterations of the outer loop. The loop correctly proceeds to the `i = 2` iteration, showing that `i` is reset to its designated iteration value at the start of each outer loop cycle.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_25\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for i = 1:2, j = 3:4\n           println((i, j))\n           i = 0\n       end\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)\n```\n\n----------------------------------------\n\nTITLE: Starting Julia with Multiple Threads via Command Line - Bash\nDESCRIPTION: Shows how to start Julia with a specified number of threads using the --threads option in the CLI. No dependencies except for Julia installed in the expected environment. Input is the number of desired threads (here: 4). Output is Julia started with the requested number of threads.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ julia --threads 4\n```\n\n----------------------------------------\n\nTITLE: Errors When Redefining Imported Variables - Julia Doctest - Julia\nDESCRIPTION: This snippet explores Julia's error behavior when attempting to reassign names ('pi', 'sqrt') that have been explicitly imported from the Base module. It demonstrates correct access, followed by errors when reassignments are attempted. The test showcases interactive REPL behavior and typical error outputs with both constants and functions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> using Base: pi, sqrt\\n\\njulia> pi\\nπ = 3.1415926535897...\\n\\njulia> pi = 3\\nERROR: cannot assign a value to imported variable Base.pi from module Main\\n\\njulia> sqrt(100)\\n10.0\\n\\njulia> sqrt = 4\\nERROR: cannot assign a value to imported variable Base.sqrt from module Main\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Interleaved Output with Concurrent Asynchronous Writes in Julia\nDESCRIPTION: This Julia code snippet uses `@sync` and `Threads.@spawn` to launch three concurrent tasks, each attempting to `write` a sequence of strings (a number, \" Foo \", \" Bar \") to `stdout`. The output demonstrates that because `write` yields during I/O operations, the output from different tasks can become interleaved. It depends on the `Threads` module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\njulia> @sync for i in 1:3\n           Threads.@spawn write(stdout, string(i), \" Foo \", \" Bar \")\n       end\n123 Foo  Foo  Foo  Bar  Bar  Bar\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Scheduling with `Threads.@threads` in Julia\nDESCRIPTION: Explains that the `Threads.@threads` macro for parallel loops now defaults to a `:dynamic` schedule. In this mode, loop iterations are dynamically scheduled to available worker threads, which enhances composability with nested or concurrent parallel constructs like `@spawn` and other `@threads` loops.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\nThreads.@threads :dynamic ... end # Implicit default\n```\n\nLANGUAGE: julia\nCODE:\n```\n@spawn\n```\n\nLANGUAGE: julia\nCODE:\n```\n@threads\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Serial and Parallel Advection Implementations in Julia REPL\nDESCRIPTION: Executes and measures the performance of three advection implementations (`advection_serial!`, `advection_parallel!`, `advection_shared!`) using the `@time` macro. The example assumes the functions and the large `SharedArray`s `q` and `u` have been defined previously. The output shows the execution time and memory allocation for each version, demonstrating the typical performance advantage of the manually chunked shared-memory approach (`advection_shared!`) in this scenario.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_39\n\nLANGUAGE: julia\nCODE:\n```\njulia> @time advection_serial!(q, u);\n(irange,jrange,trange) = (1:500,1:500,1:499)\n 830.220 milliseconds (216 allocations: 13820 bytes)\n\njulia> @time advection_parallel!(q, u);\n   2.495 seconds      (3999 k allocations: 289 MB, 2.09% gc time)\n\njulia> @time advection_shared!(q,u);\n        From worker 2:       (irange,jrange,trange) = (1:500,1:125,1:499)\n        From worker 4:       (irange,jrange,trange) = (1:500,251:375,1:499)\n        From worker 3:       (irange,jrange,trange) = (1:500,126:250,1:499)\n        From worker 5:       (irange,jrange,trange) = (1:500,376:500,1:499)\n 238.119 milliseconds (2264 allocations: 169 KB)\n```\n\n----------------------------------------\n\nTITLE: Creating C-Compatible Julia Function Pointers Using @cfunction\nDESCRIPTION: This snippet demonstrates how to use @cfunction to obtain a C-compatible function pointer from a Julia function. The example shows binding mycompare to a Cint-returning function pointer compatible with qsort, specifying types as (Ref{Cdouble}, Ref{Cdouble}). Dependencies include type matching with the destination C API and correct annotation of argument and return types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> mycompare_c = @cfunction(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}));\n```\n\n----------------------------------------\n\nTITLE: Orthogonal Design using Promotion in Julia\nDESCRIPTION: Illustrates another orthogonal design strategy using Julia's `promote` function. A core method `f(x::T, y::T)` handles arguments of the same promoted type `T`. A generic `f(x, y)` method calls `promote(x, y)` and then dispatches to the core method using splatting (`...`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_46\n\nLANGUAGE: julia\nCODE:\n```\nf(x::T, y::T) where {T} = ...\nf(x, y) = f(promote(x, y)...)\n```\n\n----------------------------------------\n\nTITLE: Setting Working Directory for Julia Cmd Objects\nDESCRIPTION: Demonstrates how to specify the working directory for an external command executed via a Julia `Cmd` object. The `dir` keyword argument is passed to the `Cmd` constructor, setting the execution context for the command. In this case, `pwd` is run in the root directory (\"/\").\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\n# jldoctest\njulia> run(Cmd(`pwd`, dir=\"/\"));\n/\n```\n\n----------------------------------------\n\nTITLE: Illustrating Name Conflict Warning During Import in Julia\nDESCRIPTION: Demonstrates a common scenario leading to name conflicts. If `Base.read` is already accessible, attempting `import CSV: read` causes a warning because both modules export a function named `read`, creating ambiguity.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_13\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> read;\n\njulia> import CSV: read\nWARNING: ignoring conflicting import of CSV.read into Main\n```\n\n----------------------------------------\n\nTITLE: Managing Distributed Jobs Using RemoteChannel in Julia\nDESCRIPTION: This code demonstrates setting up a distributed workflow across multiple Julia worker processes using RemoteChannel and Channel for inter-process job distribution and result collection. Dependencies include the Distributed standard library, and the workflow initializes job and result RemoteChannels, defines worker functions, distributes jobs, launches parallel worker tasks, and retrieves and prints results. Key parameters include number of jobs, number of workers, and job identifiers; outputs are job execution details printed in parallel. Limitations include relying on available processes/workers and assumes thread/process-safe use of channels.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\njulia> addprocs(4); # add worker processes\n\njulia> const jobs = RemoteChannel(() -> Channel{Int}(32));\n\njulia> const results = RemoteChannel(() -> Channel{Tuple}(32));\n\njulia> @everywhere function do_work(jobs, results) # define work function everywhere\n           while true\n               job_id = take!(jobs)\n               exec_time = rand()\n               sleep(exec_time) # simulates elapsed time doing actual work\n               put!(results, (job_id, exec_time, myid()))\n           end\n       end\n\njulia> function make_jobs(n)\n           for i in 1:n\n               put!(jobs, i)\n           end\n       end;\n\njulia> n = 12;\n\njulia> errormonitor(Threads.@spawn make_jobs(n)); # feed the jobs channel with \"n\" jobs\n\njulia> for p in workers() # start tasks on the workers to process requests in parallel\n           remote_do(do_work, p, jobs, results)\n       end\n\njulia> @elapsed while n > 0 # print out results\n           job_id, exec_time, where = take!(results)\n           println(\"$job_id finished in $(round(exec_time; digits=2)) seconds on worker $where\")\n           global n = n - 1\n       end\n1 finished in 0.18 seconds on worker 4\n2 finished in 0.26 seconds on worker 5\n6 finished in 0.12 seconds on worker 4\n7 finished in 0.18 seconds on worker 4\n5 finished in 0.35 seconds on worker 5\n4 finished in 0.68 seconds on worker 2\n3 finished in 0.73 seconds on worker 3\n11 finished in 0.01 seconds on worker 3\n12 finished in 0.02 seconds on worker 3\n9 finished in 0.26 seconds on worker 5\n8 finished in 0.57 seconds on worker 4\n10 finished in 0.58 seconds on worker 2\n0.055971741\n```\n\n----------------------------------------\n\nTITLE: Viewing a Stack Trace Result in Julia REPL\nDESCRIPTION: Shows the typical output format when calling `stacktrace()` directly in the Julia REPL. It returns an array of `Base.StackTraces.StackFrame` objects, representing the current call stack at the point of invocation. The output details the function calls leading to the `stacktrace()` call, including REPL-specific frames.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_0\n\nLANGUAGE: julia-repl\nCODE:\n```\n6-element Array{Base.StackTraces.StackFrame,1}:\n top-level scope\n eval at boot.jl:317 [inlined]\n eval(::Module, ::Expr) at REPL.jl:5\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n macro expansion at REPL.jl:116 [inlined]\n (::getfield(REPL, Symbol(\"##28#29\")){REPL.REPLBackend})() at event.jl:92\n```\n\n----------------------------------------\n\nTITLE: Retrieving Date Parts Using Accessor Functions in Julia\nDESCRIPTION: Demonstrates creation of a Date object and extraction of its year, month, week, and day fields as integers using Dates accessor functions. No external dependencies required apart from Julia's Dates standard module. Inputs involve a Date instance, outputs are integer representations of date parts.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> t = Date(2014, 1, 31)\n2014-01-31\n\njulia> Dates.year(t)\n2014\n\njulia> Dates.month(t)\n1\n\njulia> Dates.week(t)\n5\n\njulia> Dates.day(t)\n31\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Valid String Indices Using eachindex in Julia\nDESCRIPTION: Shows how to use the `eachindex` function to obtain an iterator that yields only the valid starting byte indices for each character within a Julia string. `collect(eachindex(s))` demonstrates gathering these valid indices (1, 4, 5, 6, 7, 10, 11 for the example string) into a Vector.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_20\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> collect(eachindex(s))\n7-element Vector{Int64}:\n  1\n  4\n  5\n  6\n  7\n 10\n 11\n```\n\n----------------------------------------\n\nTITLE: Inputting Unicode Characters via Escape Sequences in Julia\nDESCRIPTION: Shows several methods for inputting Unicode and ASCII characters in Julia using `\\u`, `\\U`, and hex escapes, each producing a valid or unassigned `Char`. No external dependencies required. Inputs use explicit Unicode points; outputs display character and category details.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> '\\u0'\n'\\0': ASCII/Unicode U+0000 (category Cc: Other, control)\n\njulia> '\\u78'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> '\\u2200'\n'\\u2200': Unicode U+2200 (category Sm: Symbol, math)\n\njulia> '\\U10ffff'\n'\\U10ffff': Unicode U+10FFFF (category Cn: Other, not assigned)\n```\n\n----------------------------------------\n\nTITLE: Redefining a Function with Multiple Dispatch in Julia\nDESCRIPTION: Adds new methods to the function `f(x)` using multiple dispatch. One method handles `Int` arguments, and another handles `Type{Int}` arguments. This demonstrates method overriding.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_67\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(x::Int) = \"definition for Int\";\n\njulia> f(x::Type{Int}) = \"definition for Type{Int}\";\n```\n\n----------------------------------------\n\nTITLE: Behavior of Default Value Scope in Julia Function Arguments\nDESCRIPTION: Demonstrates that default values for arguments in Julia functions only have access to the scope of previous arguments and not future parameters. In the provided example, a references to 'b' in 'a=b' resolves to an outer scope, not to argument b. The function body is omitted, but this definition is valid Julia syntax. No dependencies required; users must be aware of variable scope when assigning default argument values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nfunction f(x, a=b, b=1)\n    ###\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Constrained Parametric Composite Type for Rationals in Julia\nDESCRIPTION: Presents a definition of Julia's built-in Rational immutable type, parameterized on T restricted to subtypes of Integer, as a subtype of Real. Fields num and den both must be of type T. This enforces correct modeling of rational numbers as ratios of integers and ensures a Rational{T} can only be built from integer-like types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\nstruct Rational{T<:Integer} <: Real\n    num::T\n    den::T\nend\n```\n\n----------------------------------------\n\nTITLE: Constructing Higher-Dimensional Arrays with Row-Major Layout in Julia\nDESCRIPTION: Shows how spaces/tabs (for horizontal concatenation) maintain higher precedence even with multi-dimensional concatenation using multiple semicolons. This allows writing higher-dimensional arrays by specifying rows first, arranging elements textually similar to their layout in the resulting array.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_7\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [1 3 5\n        2 4 6;;;\n        7 9 11\n        8 10 12]\n2×3×2 Array{Int64, 3}:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12\n\njulia> [1 2;;; 3 4;;;; 5 6;;; 7 8]\n1×2×2×2 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1  2\n\n[:, :, 2, 1] =\n 3  4\n\n[:, :, 1, 2] =\n 5  6\n\n[:, :, 2, 2] =\n 7  8\n\njulia> [[1 2;;; 3 4];;;; [5 6];;; [7 8]]\n1×2×2×2 Array{Int64, 4}:\n[:, :, 1, 1] =\n 1  2\n\n[:, :, 2, 1] =\n 3  4\n\n[:, :, 1, 2] =\n 5  6\n\n[:, :, 2, 2] =\n 7  8\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `Array(T, dims...)`: Use `Array{T,N}` or `Array{T}` Syntax in Julia\nDESCRIPTION: The `Array` constructor syntax `Array(T, dims...)` is deprecated in Julia. Use `Array{T,N}(dims...)` when the number of dimensions `N` is known (e.g., `Vector{T}(m)` for `N=1`, `Matrix{T}(m, n)` for `N=2`), or `Array{T}(dims...)` when `N` is determined by the length of `dims`. This also applies to `SharedArray`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_190\n\nLANGUAGE: julia\nCODE:\n```\nArray{T,N}(dims...)\n```\n\nLANGUAGE: julia\nCODE:\n```\nVector{T}(dims...)\n```\n\nLANGUAGE: julia\nCODE:\n```\nMatrix{T}(dims...)\n```\n\nLANGUAGE: julia\nCODE:\n```\nArray{T}(dims...)\n```\n\n----------------------------------------\n\nTITLE: Defining a Self-Referential Struct with an Inner Constructor in Julia\nDESCRIPTION: Redefines the `SelfReferential` struct with an inner constructor `SelfReferential()`. This constructor utilizes the special `new()` function to create an incompletely initialized instance `x`, assigns this instance `x` to its own `obj` field (`x.obj = x`), thereby completing the initialization, and then returns the fully initialized, self-referential object. This pattern solves the construction problem for recursive types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_9\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> mutable struct SelfReferential\n           obj::SelfReferential\n           SelfReferential() = (x = new(); x.obj = x)\n       end\n```\n\n----------------------------------------\n\nTITLE: Executing Basic Passing Unit Tests in Julia\nDESCRIPTION: Demonstrates basic unit testing in Julia using the `@test` macro. It shows two examples where the conditions `foo(\"bar\") == 9` and `foo(\"fizz\") >= 10` evaluate to true, resulting in `Test Passed` outputs.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> @test foo(\"bar\") == 9\nTest Passed\n\njulia> @test foo(\"fizz\") >= 10\nTest Passed\n```\n\n----------------------------------------\n\nTITLE: Analyzing Julia Package Loading Time with @time_imports - Julia\nDESCRIPTION: This code sample uses the @time_imports macro in conjunction with @time to examine the package loading process, reporting detailed timing and compilation statistics for each dependency. It serves to identify bottlenecks and recompilation causes when importing packages, useful for optimizing startup performance. The snippet requires Julia's REPL with the InteractiveUtils and Package loading macros available. Expected output includes a breakdown of compilation and allocation times for each package and indirect dependency.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_55\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @time @time_imports using Plots\n      0.5 ms  Printf\n     16.4 ms  Dates\n      0.7 ms  Statistics\n               ┌ 23.8 ms SuiteSparse_jll.__init__() 86.11% compilation time (100% recompilation)\n     90.1 ms  SuiteSparse_jll 91.57% compilation time (82% recompilation)\n      0.9 ms  Serialization\n               ┌ 39.8 ms SparseArrays.CHOLMOD.__init__() 99.47% compilation time (100% recompilation)\n    166.9 ms  SparseArrays 23.74% compilation time (100% recompilation)\n      0.4 ms  Statistics → SparseArraysExt\n      0.5 ms  TOML\n      8.0 ms  Preferences\n      0.3 ms  PrecompileTools\n      0.2 ms  Reexport\n... many deps omitted for example ...\n      1.4 ms  Tar\n               ┌ 73.8 ms p7zip_jll.__init__() 99.93% compilation time (100% recompilation)\n     79.4 ms  p7zip_jll 92.91% compilation time (100% recompilation)\n               ┌ 27.7 ms GR.GRPreferences.__init__() 99.77% compilation time (100% recompilation)\n     43.0 ms  GR 64.26% compilation time (100% recompilation)\n               ┌ 2.1 ms Plots.__init__() 91.80% compilation time (100% recompilation)\n    300.9 ms  Plots 0.65% compilation time (100% recompilation)\n  1.795602 seconds (3.33 M allocations: 190.153 MiB, 7.91% gc time, 39.45% compilation time: 97% of which was recompilation)\n\n```\n\n----------------------------------------\n\nTITLE: Defining Fixed-Length Varargs Functions in Julia\nDESCRIPTION: Illustrates how to define a Julia function `bar` that accepts a fixed number of variable arguments using the `Vararg{T,N}` syntax. In this case, `Vararg{Any, 2}` requires exactly two additional arguments of any type after the initial `a` and `b`. Calls with a different number of varargs result in a `MethodError`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\njulia> bar(a,b,x::Vararg{Any,2}) = (a,b,x)\nbar (generic function with 1 method)\n\njulia> bar(1,2,3)\nERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64)\nThe function `bar` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  bar(::Any, ::Any, ::Any, !Matched::Any)\n   @ Main none:1\n\nStacktrace:\n[...]\n\njulia> bar(1,2,3,4)\n(1, 2, (3, 4))\n\njulia> bar(1,2,3,4,5)\nERROR: MethodError: no method matching bar(::Int64, ::Int64, ::Int64, ::Int64, ::Int64)\nThe function `bar` exists, but no method is defined for this combination of argument types.\n\nClosest candidates are:\n  bar(::Any, ::Any, ::Any, ::Any)\n   @ Main none:1\n\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Applying a Function Elementwise Using Dot Syntax in Julia\nDESCRIPTION: Demonstrates applying the `sin` function to each element of a `Float64` vector `A` using the dot syntax (`.`). This is equivalent to `broadcast(sin, A)` and creates a new vector containing the results. This syntax works for any Julia function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_41\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> A = [1.0, 2.0, 3.0]\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> sin.(A)\n3-element Vector{Float64}:\n 0.8414709848078965\n 0.9092974268256817\n 0.1411200080598672\n```\n\n----------------------------------------\n\nTITLE: Breakpoint on Loading a Particular File (Conditional GDB Breakpoint)\nDESCRIPTION: Sets a conditional GDB breakpoint on jl_load that only triggers when the filename matches 'sysimg.jl'. Useful to intercept or debug loading of specific source files in Julia. Relies on 'fname' being in scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_7\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) break jl_load if strcmp(fname, \"sysimg.jl\")==0\n```\n\n----------------------------------------\n\nTITLE: Configuring Julia Threadpools via Environment Variable (Bash)\nDESCRIPTION: Demonstrates setting the `JULIA_NUM_THREADS` environment variable in Bash to configure the size of Julia's `:default` and `:interactive` threadpools using the `x,y` format (requires Julia 1.9+). The first example allocates 5 threads to `:default` and 2 to `:interactive`. The second uses `auto` (requires Julia 1.7+) for the `:default` pool size (matching CPU threads) and 1 thread for `:interactive`. This variable must be set before starting Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/environment-variables.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# 5 threads in the :default pool and 2 in the :interactive pool\nexport JULIA_NUM_THREADS=5,2\n\n# `auto` threads in the :default pool and 1 in the :interactive pool\nexport JULIA_NUM_THREADS=auto,1\n```\n\n----------------------------------------\n\nTITLE: Dumping LLVM IR for a Julia Function (Julia)\nDESCRIPTION: This Julia code snippet demonstrates how to extract and write the LLVM IR for a specific function and argument type into a file (plus.ll). It uses the code_llvm function with raw and dump_module options to produce the IR, which can then be inspected or processed by LLVM tools. This approach is useful for focused debugging and analysis of individual Julia function compilation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nfun, T = +, Tuple{Int,Int} # Substitute your function of interest here\noptimize = false\nopen(\"plus.ll\", \"w\") do file\n    code_llvm(file, fun, T; raw=true, dump_module=true, optimize)\nend\n```\n\n----------------------------------------\n\nTITLE: Demonstrating DomainError with `sqrt` on Negative Real Numbers in Julia\nDESCRIPTION: This snippet shows the standard Julia behavior when attempting to calculate the square root of a negative floating-point number (`-2.0`). It results in a `DomainError` because the `sqrt` function, for type stability, is defined to return a real number when given a real input. The error message explicitly guides the user to use `sqrt(Complex(x))` for complex results.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_14\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> sqrt(-2.0)\nERROR: DomainError with -2.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n```\n```\n\n----------------------------------------\n\nTITLE: Documenting General Number Functions and Constants - Julia - Julia\nDESCRIPTION: Aggregates various number-related functions and constants from Julia's Base and Core for documentation, covering special values, rounding, and type conversion features. This @docs block is structured to automate the rendering of docstrings for these symbols, facilitating user discovery in auto-generated documentation. Depends on a properly configured Julia documentation build environment and the presence of all referenced items.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/numbers.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nBase.one\\nBase.oneunit\\nBase.zero\\nBase.im\\nBase.MathConstants.pi\\nBase.MathConstants.ℯ\\nBase.MathConstants.catalan\\nBase.MathConstants.eulergamma\\nBase.MathConstants.golden\\nBase.Inf\\nBase.Inf64\\nBase.Inf32\\nBase.Inf16\\nBase.NaN\\nBase.NaN64\\nBase.NaN32\\nBase.NaN16\\nBase.issubnormal\\nBase.isfinite\\nBase.isinf\\nBase.isnan\\nBase.iszero\\nBase.isone\\nBase.nextfloat\\nBase.prevfloat\\nBase.isinteger\\nBase.isreal\\nCore.Float32(::Any)\\nCore.Float64(::Any)\\nBase.Rounding.rounding\\nBase.Rounding.setrounding(::Type, ::Any)\\nBase.Rounding.setrounding(::Function, ::Type, ::RoundingMode)\\nBase.Rounding.get_zero_subnormals\\nBase.Rounding.set_zero_subnormals\\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Block Quotes in Markdown\nDESCRIPTION: This snippet demonstrates how to create block quotes in Markdown by prepending each line of the quote with a greater-than symbol (`>`) followed by a space. Block quotes can contain other Markdown elements.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_14\n\nLANGUAGE: markdown\nCODE:\n```\nHere's a quote:\n\n> Julia is a high-level, high-performance dynamic programming language for\n> technical computing, with syntax that is familiar to users of other\n> technical computing environments.\n```\n\n----------------------------------------\n\nTITLE: Sampling Values from a Custom Object Instance (Die) in Julia\nDESCRIPTION: Demonstrates calling `rand` on an instance of the custom `Die` type (e.g., `Die(4)`). Based on the previously defined `rand(rng, ::Random.SamplerTrivial{Die})` method, this generates random integers representing the outcome of rolling the specific die (values between 1 and 4 in this case). It also shows generating an array of such random outcomes.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> rand(Die(4))\n1\n\njulia> rand(Die(4), 3)\n3-element Vector{Any}:\n 2\n 3\n 3\n```\n\n----------------------------------------\n\nTITLE: Tab Completion of Function Methods and Arguments - Julia-REPL\nDESCRIPTION: These examples demonstrate using tab completion to list available methods for a function based on supplied argument types or partial input, including listing all overloads and filtering by argument types, even for outputs of other functions. Useful for interactive exploration of APIs, especially with functions following Julia's multiple dispatch paradigm.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_22\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> max([TAB] # All methods are displayed, not shown here due to size of the list\n\njulia> max([1, 2], [TAB] # All methods where `Vector{Int}` matches as first argument\nmax(x, y) in Base at operators.jl:215\nmax(a, b, c, xs...) in Base at operators.jl:281\n\njulia> max([1, 2], max(1, 2), [TAB] # All methods matching the arguments.\nmax(x, y) in Base at operators.jl:215\nmax(a, b, c, xs...) in Base at operators.jl:281\n```\n\n----------------------------------------\n\nTITLE: Documenting vec Function Return Type - Julia - Julia\nDESCRIPTION: This docstring example demonstrates how to annotate the return type in a function signature using Julia docstring conventions. The vec function takes an AbstractArray input and specifies the output as AbstractVector via the :: annotation. This approach clarifies and enforces the expected output type for readers and tools.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\n   vec(x::AbstractArray)::AbstractVector\n\n...\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Scheduling Work with AsyncCondition and wait in Julia\nDESCRIPTION: This snippet shows the creation of an AsyncCondition object and the use of wait to block until it is notified. Used as part of a thread-safe callback mechanism when integrating with multi-threaded C libraries. Intended for use with Julia's event loop, often in FFI scenarios where C callbacks are scheduled onto Julia's runtime. No external dependencies, but proper event signaling from the C side is required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\ncond = Base.AsyncCondition()\nwait(cond)\n```\n\n----------------------------------------\n\nTITLE: Basic GC Rooting for a Single Julia Value in C\nDESCRIPTION: Demonstrates how to prevent a Julia object, obtained via `jl_eval_string`, from being garbage collected while it's needed in C code. The `JL_GC_PUSH1` macro roots the `jl_value_t*` variable `ret`, and `JL_GC_POP` releases the root when the variable is no longer needed within the current C stack frame.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_13\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *ret = jl_eval_string(\"sqrt(2.0)\");\nJL_GC_PUSH1(&ret);\n// Do something with ret\nJL_GC_POP();\n```\n\n----------------------------------------\n\nTITLE: Using SamplerSimple for Custom Sampler Implementation in Julia\nDESCRIPTION: Illustrates using the built-in `Random.SamplerSimple` helper type as a concise alternative to defining a completely custom sampler struct like `SamplerDie`. The `Sampler` constructor returns a `SamplerSimple` instance containing the original `Die` object and the underlying range sampler (`Sampler(RNG, 1:die.nsides, r)`). The corresponding `rand` method accesses this underlying sampler via `sp.data` for generation. Assumes the `Die` struct is defined elsewhere.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nSampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =\n    SamplerSimple(die, Sampler(RNG, 1:die.nsides, r))\n\nrand(rng::AbstractRNG, sp::SamplerSimple{Die}) = rand(rng, sp.data)\n```\n\n----------------------------------------\n\nTITLE: Using Functions within Test Sets in Julia\nDESCRIPTION: Demonstrates calling a function `f(x)` (which contains a `@test`) directly within a `@testset`. The test set automatically takes the name of the function `f`.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(x) = @test isone(x)\nf (generic function with 1 method)\n\njulia> @testset f(1);\nTest Summary: | Pass  Total  Time\nf             |    1      1  0.0s\n```\n\n----------------------------------------\n\nTITLE: Computing Generalized Dot Product `dot(x, A*y)` Efficiently in Julia\nDESCRIPTION: Demonstrates the 3-argument `dot` method in Julia's LinearAlgebra module. This computes the generalized dot product `dot(x, A*y)` without explicitly forming the intermediate matrix-vector product `A*y`, potentially saving memory and computation.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_94\n\nLANGUAGE: julia\nCODE:\n```\ndot(x, A, y)\n```\n\n----------------------------------------\n\nTITLE: Configuring Documenter.jl Doctest Setup\nDESCRIPTION: This `@meta` block is used by Julia's documentation generator, Documenter.jl. Setting `DocTestSetup = nothing` prevents the execution of any globally defined setup code before running doctests within the subsequent sections of the documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nDocTestSetup = nothing\n```\n```\n\n----------------------------------------\n\nTITLE: Read-Only Data in Distributed Parallel Loop in Julia\nDESCRIPTION: Illustrates using a read-only external array ('a') from the parent scope within a distributed (+) reduction loop. Each process applies function 'f' to a randomly chosen element from 'a'. Shows that broadcasting non-shared data is allowed as long as it is not mutated. Requires array 'a' and function 'f' to be defined beforehand.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_21\n\nLANGUAGE: julia\nCODE:\n```\na = randn(1000)\n@distributed (+) for i = 1:100000\n    f(a[rand(1:end)])\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Thread Pools via Command Line - Bash\nDESCRIPTION: Shows command line invocations to launch Julia with separate thread counts for default and interactive threadpools using the --threads option. Second pool count can be set to 0 or 1 for different configurations. No dependencies outside Julia installation. Inputs are comma-separated integers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ julia --threads 3,1\njulia> Threads.nthreads(:interactive)\n1\n\n$ julia --threads 3,0\njulia> Threads.nthreads(:interactive)\n0\n```\n\n----------------------------------------\n\nTITLE: GC Rooting Multiple Julia Values in C using JL_GC_PUSH*\nDESCRIPTION: Illustrates the pattern for rooting multiple `jl_value_t*` variables simultaneously using the `JL_GC_PUSH2` through `JL_GC_PUSH6` macros. This avoids nested `JL_GC_PUSH` blocks for a small, fixed number of variables within the same scope. Each push must be paired with a `JL_GC_POP`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_14\n\nLANGUAGE: c\nCODE:\n```\nJL_GC_PUSH2(&ret1, &ret2);\n```\n\nLANGUAGE: c\nCODE:\n```\n// ...\n```\n\nLANGUAGE: c\nCODE:\n```\nJL_GC_PUSH6(&ret1, &ret2, &ret3, &ret4, &ret5, &ret6);\n```\n\n----------------------------------------\n\nTITLE: Listing Special Julia Types for Documentation\nDESCRIPTION: This block utilizes the `@docs` directive to enumerate fundamental and special types within the Julia language, including the root type `Any`, `Union` types, tuples (`Tuple`, `NTuple`, `NamedTuple`), `Val` for type-based dispatch, `Vararg`, `Nothing`, `Some`, enums (`Enum`), `Expr` for code representation, `Symbol`, and `Module`. It instructs the documentation generator to include documentation for these types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCore.Any\nCore.Union\nUnion{}\nCore.UnionAll\nCore.Tuple\nCore.NTuple\nCore.NamedTuple\nBase.@NamedTuple\nBase.@Kwargs\nBase.Val\nCore.Vararg\nCore.Nothing\nBase.isnothing\nBase.notnothing\nBase.Some\nBase.something\nBase.@something\nBase.Enums.Enum\nBase.Enums.@enum\nCore.Expr\nCore.Symbol\nCore.Symbol(x...)\nCore.Module\n```\n```\n\n----------------------------------------\n\nTITLE: Closing a Socket Connection with Sockets in Julia\nDESCRIPTION: This snippet shows how to disconnect a client socket using the close function in the Julia Sockets API. It is used to terminate a TCP connection established earlier. There are no parameters apart from the socket object to be closed. Output: Closes the connection, releasing system resources. Only works on an open socket.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_14\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> close(clientside)\n```\n\n----------------------------------------\n\nTITLE: Running OProfile Profiler with Julia (Shell)\nDESCRIPTION: Shows how to record profiling data for a Julia script (`test/fastmath.jl`) using `operf` after setting the `ENABLE_JITPROFILING` environment variable. It also includes the command `opreport` to analyze the collected profiling data. Requires Julia compiled with `USE_OPROFILE_JITEVENTS=1` and OProfile installed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n>ENABLE_JITPROFILING=1 sudo operf -Vdebug ./julia test/fastmath.jl\\n>opreport -l `which ./julia`\n```\n\n----------------------------------------\n\nTITLE: Error on Attempting Reassignment of Julia `const` Variable\nDESCRIPTION: Illustrates that attempting to assign a new value to a variable (`x`) previously declared `const` without using the `const` keyword again results in an error in Julia. The error message indicates that the variable is constant and suggests using `const` again if redefinition is intended.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_28\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> const x = 1.0\n1.0\n\njulia> x = 1\nERROR: invalid assignment to constant x. This redefinition may be permitted using the `const` keyword.\n```\n```\n\n----------------------------------------\n\nTITLE: Scheduling a Julia Task for Execution\nDESCRIPTION: Schedules the previously created task `t` for execution using the `schedule` function. This adds the task to Julia's internal task queue, allowing it to run when the scheduler gets a chance (e.g., during I/O wait or when the REPL is idle). The `schedule` function returns immediately without waiting for the task to complete.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/asynchronous-programming.md#_snippet_1\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> schedule(t);\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Custom Unicode Binary Operators - Julia\nDESCRIPTION: This code snippet demonstrates the definition and usage of a custom binary operator in Julia by assigning a Unicode symbol (⊗) to the Kronecker product using infix and prefix notation. This pattern requires Julia's Unicode symbol support and definition of new operator methods. Inputs are function arguments representing arrays or matrices (e.g., A, B), and the output is a result of the defined operation (kron). The snippet highlights extensibility in operator syntax and shows how custom operations are invoked in both infix and prefix forms. Key limitation is that only certain Unicode characters are supported as operators by Julia's parser.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/math.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```julia\n⊗(x,y) = kron(x,y)\n```\n```\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nC = A ⊗ B\n```\n```\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nC = ⊗(A,B)\n```\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple and Nested Scoped Values in Julia\nDESCRIPTION: Illustrates defining multiple `ScopedValue`s (`a`, `b`) using `const` and managing their values in nested dynamic scopes using `with`. Each `with` block sets specific values, which are observed by functions `f` and `g`. Values revert to those of the outer scope upon exiting a `with` block.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.ScopedValues\n\nf() = @show a[]\ng() = @show b[]\n\nconst a = ScopedValue(1)\nconst b = ScopedValue(2)\n\nf() # a[] = 1\ng() # b[] = 2\n\n# Enter a new dynamic scope and set value.\nwith(a => 3) do\n    f() # a[] = 3\n    g() # b[] = 2\n    with(a => 4, b => 5) do\n        f() # a[] = 4\n        g() # b[] = 5\n    end\n    f() # a[] = 3\n    g() # b[] = 2\nend\n\nf() # a[] = 1\ng() # b[] = 2\n```\n\n----------------------------------------\n\nTITLE: Running Perf Profiler with JIT Support for Julia (Shell)\nDESCRIPTION: Demonstrates profiling a Julia script (`test/fastmath.jl`) using `perf`. It involves setting the `ENABLE_JITPROFILING` variable, recording data with call graph information (`perf record`), injecting JIT symbols (`perf inject --jit`), and finally generating a report (`perf report`). Requires Julia compiled with `USE_PERF_JITEVENTS=1` and perf tools installed. Note the potential size of `perf.data` files and debug objects in `~/.debug/jit`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n$ ENABLE_JITPROFILING=1 perf record -o /tmp/perf.data --call-graph dwarf -k 1 ./julia /test/fastmath.jl\\n$ perf inject --jit --input /tmp/perf.data --output /tmp/perf-jit.data\\n$ perf report --call-graph -G -i /tmp/perf-jit.data\n```\n\n----------------------------------------\n\nTITLE: Propagating Escape Information via Try/Catch - Julia\nDESCRIPTION: This snippet further illustrates exception-related escapes by performing analysis on multiple reference variables in a try/catch context. It shows how global assignment or field updates within the exception handler can cause references (such as r1) to fully escape, while others (such as r2) remain local. The main dependencies are Julia's exception system and EscapeAnalysis facilities. The code expects string inputs and reference assignments, with the outcome affecting global analysis results of which variables are safe to optimize or must be treated as escaping. This pattern is representative of the complexities that arise when exceptions are involved in control flow.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nresult = code_escapes((String,String)) do s1, s2\n    r1 = Ref(s1)\n    r2 = Ref(s2)\n    local ret\n    try\n        s1 = get′(r1)\n        ret = sizeof(s1)\n    catch err\n        global GV = err # will definitely escape `r1`\n    end\n    s2 = get′(r2)       # still `r2` doesn't escape fully\n    return s2\nend\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting Fortran Linker Errors in Julia Build (Shell)\nDESCRIPTION: Provides shell commands to diagnose and fix linker errors like `cannot find -lgfortran` during the Julia build process when linking OpenBLAS or other Fortran-dependent components. First, locate the gfortran library path using `gfortran -print-file-name=libgfortran.so`. Then, add its directory to the linker search path by exporting `LDFLAGS`, adjusting the path based on the output of the first command.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_10\n\nLANGUAGE: Shell\nCODE:\n```\ngfortran -print-file-name=libgfortran.so\n```\n\nLANGUAGE: Shell\nCODE:\n```\nexport LDFLAGS=-L/usr/lib/gcc/x86_64-linux-gnu/8/\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Base.Iterators Functions for Documentation\nDESCRIPTION: This snippet utilizes the Documenter.jl `@docs` directive to automatically generate documentation for a collection of functions within Julia's `Base.Iterators` module. It includes functions for stateful iteration (`Stateful`), combining iterators (`zip`, `product`), modifying iteration flow (`take`, `drop`, `cycle`), transforming elements (`enumerate`, `map`, `flatten`), and other common iteration patterns. This block is processed by Documenter.jl to embed the relevant docstrings into the generated documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/iterators.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.Iterators.Stateful\nBase.Iterators.zip\nBase.Iterators.enumerate\nBase.Iterators.rest\nBase.Iterators.countfrom\nBase.Iterators.take\nBase.Iterators.takewhile\nBase.Iterators.drop\nBase.Iterators.dropwhile\nBase.Iterators.cycle\nBase.Iterators.repeated\nBase.Iterators.product\nBase.Iterators.flatten\nBase.Iterators.flatmap\nBase.Iterators.partition\nBase.Iterators.map\nBase.Iterators.filter\nBase.Iterators.accumulate\nBase.Iterators.reverse\nBase.Iterators.only\nBase.Iterators.peel\n```\n```\n\n----------------------------------------\n\nTITLE: Documenting Logger Installation and Inspection Functions (Julia Docs)\nDESCRIPTION: A directive for Julia's documentation generator (Documenter.jl) to include documentation for functions related to setting and retrieving the current logger (global_logger, with_logger, current_logger).\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Logging/docs/src/index.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nLogging.global_logger\nLogging.with_logger\nLogging.current_logger\n```\n\n----------------------------------------\n\nTITLE: Listing Standard Julia Modules for Documentation\nDESCRIPTION: This block uses the `@docs` directive to list the core standard modules in Julia: `Main`, `Core`, and `Base`. The documentation generator will use this list to include descriptions of these fundamental modules.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nMain\nCore\nBase\n```\n```\n\n----------------------------------------\n\nTITLE: Computing Exact Matrix Condition Number (1-norm or Inf-norm) in Julia\nDESCRIPTION: Illustrates calling the `cond(A, p)` function from Julia's LinearAlgebra module with `p=1` or `p=Inf`. In Julia v1.4, this now computes the exact condition number for these norms, rather than an estimate.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_96\n\nLANGUAGE: julia\nCODE:\n```\ncond(A, p)\n```\n\n----------------------------------------\n\nTITLE: Using `else` Block with `try` in Julia\nDESCRIPTION: Illustrates the structure of a `try`-`else`-`end` block in Julia. The code within the `else` block is executed immediately after the main `try` block, but only if no errors were thrown during the execution of the `try` block.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\ntry\n  # ... code that might throw an error ...\nelse\n  # ... code executed only if no error occurred in the try block ...\nend\n```\n\n----------------------------------------\n\nTITLE: Path Tab Completion in Julia and Shell REPL Modes - Julia-REPL\nDESCRIPTION: These code examples show tab completion of filesystem paths in both Julia string contexts and shell mode. No dependencies are necessary; the REPL automatically lists directories and files in the prompted directory. Suitable for navigating or selecting file and directory names interactively.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_19\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> path=\"/[TAB]\"\n.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\n.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\nshell> /[TAB]\n.dockerenv  .juliabox/   boot/        etc/         lib/         media/       opt/         root/        sbin/        sys/         usr/\n.dockerinit bin/         dev/         home/        lib64/       mnt/         proc/        run/         srv/         tmp/         var/\n```\n\n----------------------------------------\n\nTITLE: Julia Code with Type Check Before PiNode Insertion (Julia)\nDESCRIPTION: This Julia code snippet shows a common pattern where a variable `x` has a Union type (`Union{Int, Float64}`), and its usage depends on a runtime type check using `isa`. This pattern represents a situation where compiler optimization can benefit from statically proven type information within conditional branches, which PiNodes help represent.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n%x::Union{Int, Float64} # %x is some Union{Int, Float64} typed ssa value\nif isa(x, Int)\n    # use x\nelse\n    # use x\nend\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inlining and Loop Optimization for Integer Functions - Julia\nDESCRIPTION: This Julia snippet shows how inlining and loop optimization lead to efficient machine code for a loop repeatedly calling f(k), thanks to associativity and distributivity of machine integer arithmetic. It provides both the Julia source and its generated assembly, showcasing how simple integer loops can be compiled to a single fast instruction per iteration. This relies on standard Julia features and the code_native function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\njulia> function g(k, n)\n           for i = 1:n\n               k = f(k)\n           end\n           return k\n       end\ng (generic function with 1 methods)\n\njulia> code_native(g, Tuple{Int,Int})\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 2\n  testq %rsi, %rsi\n  jle L26\n  nopl  (%rax)\nSource line: 3\nL16:\n  leaq  -1(%rdi,%rdi,4), %rdi\nSource line: 2\n  decq  %rsi\n  jne L16\nSource line: 5\nL26:\n  movq  %rdi, %rax\n  popq  %rbp\n  retq\n  nop\n```\n\n----------------------------------------\n\nTITLE: Boxing C Primitive Types into Julia Objects\nDESCRIPTION: Demonstrates how to convert native C data types (like `double`, `float`, `int32_t`) into their corresponding heap-allocated Julia object representations (`jl_value_t*`) using the `jl_box_float64`, `jl_box_float32`, and `jl_box_int32` functions. This process, known as boxing, is necessary for passing C values as arguments to Julia functions via the C API.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_9\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *a = jl_box_float64(3.0);\njl_value_t *b = jl_box_float32(3.0f);\njl_value_t *c = jl_box_int32(3);\n```\n\n----------------------------------------\n\nTITLE: Listing Julia C Interface Documentation Entries\nDESCRIPTION: This snippet uses Julia's `@docs` macro within its documentation system (likely Documenter.jl) to automatically generate documentation pages for a comprehensive list of built-in functions, macros, types, and constants related to C interoperability. It covers calling C functions (`ccall`, `@ccall`), creating C-callable Julia functions (`@cfunction`, `CFunction`), handling pointers (`Ptr`, `Ref`, `pointer`, `unsafe_load`, `unsafe_store!`), managing memory (`unsafe_wrap`, `unsafe_copyto!`), signal handling (`disable_sigint`), error handling (`systemerror`), and defining C-compatible types (`Cint`, `Cstring`, `Cdouble`, etc.). These are fundamental components of Julia's FFI.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/c.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\n@ccall\nccall\nCore.Intrinsics.cglobal\nBase.@cfunction\nBase.CFunction\nBase.unsafe_convert\nBase.cconvert\nBase.unsafe_load\nBase.unsafe_store!\nBase.unsafe_modify!\nBase.unsafe_replace!\nBase.unsafe_swap!\nBase.unsafe_copyto!{T}(::Ptr{T}, ::Ptr{T}, ::Any)\nBase.unsafe_copyto!(::Array, ::Any, ::Array, ::Any, ::Any)\nBase.copyto!\nBase.pointer\nBase.unsafe_wrap{T,N}(::Union{Type{Array},Type{Array{T}},Type{Array{T,N}}}, ::Ptr{T}, ::NTuple{N,Int})\nBase.pointer_from_objref\nBase.unsafe_pointer_to_objref\nBase.disable_sigint\nBase.reenable_sigint\nBase.exit_on_sigint\nBase.systemerror\nBase.windowserror\nCore.Ptr\nCore.Ref\nBase.isassigned(::Base.RefValue)\nBase.Cchar\nBase.Cuchar\nBase.Cshort\nBase.Cstring\nBase.Cushort\nBase.Cint\nBase.Cuint\nBase.Clong\nBase.Culong\nBase.Clonglong\nBase.Culonglong\nBase.Cintmax_t\nBase.Cuintmax_t\nBase.Csize_t\nBase.Cssize_t\nBase.Cptrdiff_t\nBase.Cwchar_t\nBase.Cwstring\nBase.Cfloat\nBase.Cdouble\n```\n```\n\n----------------------------------------\n\nTITLE: Determining the Type of a Named Function in Julia\nDESCRIPTION: Defines a simple function `foo41`. It then uses `typeof(foo41)` to show that the function has its own unique singleton type. This type is printed as `typeof(foo41)` by convention and is a subtype of the abstract type `Function`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_51\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> foo41(x) = x + 1\nfoo41 (generic function with 1 method)\n\njulia> typeof(foo41)\ntypeof(foo41) (singleton type of function foo41, subtype of Function)\n```\n\n----------------------------------------\n\nTITLE: Documenting General Collection Functions in Julia\nDESCRIPTION: A documentation system directive (`@docs`) to include documentation for fundamental functions applicable to most collections in Julia, like checking emptiness (`isempty`), emptying (`empty!`), and getting the size (`length`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.isempty\nBase.isdone\nBase.empty!\nBase.length\nBase.checked_length\n```\n\n----------------------------------------\n\nTITLE: Multiplying Input by Integer Literal in Julia Function - Julia\nDESCRIPTION: Defines a generic function g(x) that multiplies its argument by an Int literal (2). Shows that using an integer literal preserves the type of the input, with promotion only happening if required by the input's type. Inputs tested include Rational, float, and integer, demonstrating preservation or promotion accordingly. No special dependencies are necessary.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\njulia> g(x) = 2 * x\ng (generic function with 1 method)\n\njulia> g(1//2)\n1//1\n\njulia> g(1/2)\n1.0\n\njulia> g(1)\n2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Name Conflict Error in Julia\nDESCRIPTION: Illustrates the error that occurs when attempting to use an unqualified name (`f`) after importing multiple modules (`A`, `B`) that export different bindings for that name using `using .A, .B`. Julia cannot resolve the ambiguity.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_18\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using .A, .B\n\njulia> f\nERROR: UndefVarError: `f` not defined in `Main`\nHint: It looks like two or more modules export different bindings with this name, resulting in ambiguity. Try explicitly importing it from a particular module, or qualifying the name with the module it should come from.\n```\n\n----------------------------------------\n\nTITLE: Triggering Type Inference Manually in Julia\nDESCRIPTION: This snippet demonstrates how to programmatically invoke Julia's type inference mechanism (`Core.Compiler.typeinf_code`) for a specific method (`convert`) with given argument types (`Type{Int}, UInt`). It involves retrieving the method instance, setting up an interpreter (`NativeInterpreter`) and parameters (`sparams`), choosing whether to run optimizations, defining the full signature tuple (`types`), and finally calling the inference function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/inference.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n# Get the method\natypes = Tuple{Type{Int}, UInt}  # argument types\nmths = methods(convert, atypes)  # worth checking that there is only one\nm = first(mths)\n\n# Create variables needed to call `typeinf_code`\ninterp = Core.Compiler.NativeInterpreter()\nsparams = Core.svec()      # this particular method doesn't have type-parameters\nrun_optimizer = true       # run all inference optimizations\ntypes = Tuple{typeof(convert), atypes.parameters...} # Tuple{typeof(convert), Type{Int}, UInt}\nCore.Compiler.typeinf_code(interp, m, types, sparams, run_optimizer)\n```\n\n----------------------------------------\n\nTITLE: Using GC Write Barrier After Updating Object Fields in C\nDESCRIPTION: Illustrates the use of the garbage collector write barrier (`jl_gc_wb`). This function must be called after manually updating a field in an older Julia object (`parent`) to point to a younger Julia object (`child`) in C. This informs the GC about the potential violation of the generation hypothesis, ensuring GC correctness.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_22\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *parent = some_old_value, *child = some_young_value;\n((some_specific_type*)parent)->field = child;\njl_gc_wb(parent, child);\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Mutating the Custom SparseArray in Julia\nDESCRIPTION: Demonstrates creating and modifying the `SparseArray`. It shows initialization, filling with a value using the inherited `fill!` method, and assigning values using linear indexing (`A[:]`). Linear indexing works because `AbstractArray` provides fallback methods that convert linear indices to Cartesian indices based on the array's size and `IndexStyle`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_17\n\nLANGUAGE: jldoctest squarevectype\nCODE:\n```\njulia> A = SparseArray(Float64, 3, 3)\n3×3 SparseArray{Float64, 2}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\njulia> fill!(A, 2)\n3×3 SparseArray{Float64, 2}:\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n 2.0  2.0  2.0\n\njulia> A[:] = 1:length(A); A\n3×3 SparseArray{Float64, 2}:\n 1.0  4.0  7.0\n 2.0  5.0  8.0\n 3.0  6.0  9.0\n```\n\n----------------------------------------\n\nTITLE: Creating a Global Julia Variable from C for GC Protection\nDESCRIPTION: Presents an alternative, simpler method for protecting a Julia value (`val`) across C scopes by assigning it directly to a global variable (`var`) in a Julia module (`jl_main_module`). This uses `jl_symbol`, `jl_get_binding_wr` to get/create the binding, and `jl_checked_assignment` to assign the value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_21\n\nLANGUAGE: c\nCODE:\n```\njl_module_t *mod = jl_main_module;\njl_sym_t *var = jl_symbol(\"var\");\njl_binding_t *bp = jl_get_binding_wr(mod, var, 1);\njl_checked_assignment(bp, mod, var, val);\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Syntax and Metaprogramming Macros/Functions\nDESCRIPTION: This block uses the `@docs` directive to list core functions and macros related to Julia's syntax, evaluation, and metaprogramming. This includes evaluation functions (`eval`, `evalfile`), hygiene (`esc`), performance annotations (`@inbounds`, `@inline`, `@noinline`, etc.), symbol generation (`gensym`), control flow (`@goto`, `@label`), SIMD optimization (`@simd`), generated functions (`@generated`), and effect system annotations (`@assume_effects`). It directs the documentation system to include entries for these syntax-related elements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCore.eval\nMain.eval\nBase.@eval\nBase.evalfile\nBase.esc\nBase.@inbounds\nBase.@boundscheck\nBase.@propagate_inbounds\nBase.@inline\nBase.@noinline\nBase.@nospecialize\nBase.@specialize\nBase.@nospecializeinfer\nBase.@constprop\nBase.gensym\nBase.@gensym\nvar\"name\"\nBase.@goto\nBase.@label\nBase.@simd\nBase.@polly\nBase.@generated\nBase.@assume_effects\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scope Leaks in If Blocks - Julia\nDESCRIPTION: This snippet illustrates that variables declared inside an if block in Julia are accessible outside of it, provided all code paths initialize the variable. Function 'test' uses conditional assignment of 'relation' and then prints a concatenated message. It is essential to ensure all branches assign a value to prevent runtime errors.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> function test(x,y)\n           if x < y\n               relation = \"less than\"\n           elseif x == y\n               relation = \"equal to\"\n           else\n               relation = \"greater than\"\n           end\n           println(\"x is \", relation, \" y.\")\n       end\ntest (generic function with 1 method)\n\njulia> test(2, 1)\nx is greater than y.\n```\n\n----------------------------------------\n\nTITLE: Creating Julia Functions and Method Instances in C\nDESCRIPTION: Declares C functions for creating core Julia code-related objects. `jl_new_generic_function` creates a new generic function (a callable entity that can have multiple methods) associated with a given symbol (`name`). `jl_new_method_instance` creates a specific method instance, often representing specialized compiled code, linked to an abstract syntax tree (AST) or other code representation (`ast`) and potentially static parameters (`sparams`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_15\n\nLANGUAGE: c\nCODE:\n```\njl_function_t *jl_new_generic_function(jl_sym_t *name);\njl_method_instance_t *jl_new_method_instance(jl_value_t *ast, jl_tuple_t *sparams);\n```\n\n----------------------------------------\n\nTITLE: Syntax Considerations for Single-line try/catch Statements - Julia\nDESCRIPTION: This section shows that writing single-line try/catch expressions without a semicolon or line break after catch leads to parsing issues. Two correct alternatives are given: try bad() catch; x end and a multi-line variant. Ensures developers are aware of potential parsing ambiguities and how to resolve them.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\ntry bad() catch x end\n\n```\n\nLANGUAGE: julia\nCODE:\n```\ntry bad() catch; x end\n\ntry bad()\ncatch\n    x\nend\n\n```\n\n----------------------------------------\n\nTITLE: Listing Direct Subtypes using InteractiveUtils.subtypes in Julia\nDESCRIPTION: Demonstrates how to list the direct subtypes of a given `DataType` using `InteractiveUtils.subtypes`. This example shows the five direct subtypes of the abstract type `AbstractFloat`. It requires the `InteractiveUtils` module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/reflection.md#_snippet_3\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> InteractiveUtils.subtypes(AbstractFloat)\n5-element Vector{Any}:\n BigFloat\n Core.BFloat16\n Float16\n Float32\n Float64\n```\n\n----------------------------------------\n\nTITLE: Documenting Basic Atomic Operation Function - Julia\nDESCRIPTION: This snippet includes a documentation macro for the atomic function, facilitating access to details on basic atomic operations in Julia. The purpose is to expose this function in generated API documentation, assisting users with atomic value manipulations in concurrent programs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/multi-threading.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\natomic\\n```\n```\n\n----------------------------------------\n\nTITLE: Using Lazy Strings for Delayed Error Message Construction in Julia\nDESCRIPTION: Introduces the `LazyString` type and the corresponding `lazy\"str\"` string macro in Julia. These tools allow for the creation of strings whose content (potentially involving interpolation or formatting) is only computed when the string is actually used (e.g., printed). This is particularly useful for optimizing performance by avoiding expensive string construction in error paths that are not taken.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_42\n\nLANGUAGE: julia\nCODE:\n```\nLazyString\n```\n\nLANGUAGE: julia\nCODE:\n```\nlazy\"str\"\n```\n\n----------------------------------------\n\nTITLE: Querying Type Documentation in REPL Help Mode\nDESCRIPTION: This demonstrates using the REPL's Help mode (`help?>`) to retrieve documentation for a specific data type. Typing `Int32` displays the documentation for the `Int32` type, including its supertype (`Signed`) and a brief description.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nhelp?> Int32\nsearch: Int32 UInt32\n\n  Int32 <: Signed\n\n  32-bit signed integer type.\n```\n\n----------------------------------------\n\nTITLE: Translating Backtrace Pointers with StackTraces.lookup - Julia\nDESCRIPTION: Translates a single pointer from a backtrace into a StackFrame using StackTraces.lookup, enabling inspection of individual stack frames. Requires the StackTraces module or relevant functionality to be available. The key input is a pointer (from backtrace), and the outputs are an array of StackFrame objects, which can be further inspected for function name and location details. Useful for fine-grained diagnostics and programmatic stack analysis.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n```julia-repl\\njulia> pointer = backtrace()[1];\\n\\njulia> frame = StackTraces.lookup(pointer)\\n1-element Array{Base.StackTraces.StackFrame,1}:\\n jl_apply_generic at gf.c:2167\\n\\njulia> println(\\\"The top frame is from $(frame[1].func)!\\\")\\nThe top frame is from jl_apply_generic!\\n```\n```\n\n----------------------------------------\n\nTITLE: Building and Debugging Julia Scripts With GDB - Shell\nDESCRIPTION: This shell snippet provides steps for creating a Julia debug build and launching a custom script under gdb for step-by-step debugging and backtrace generation. It is intended for cases when a user wants to run and debug their own Julia script to diagnose segmentation faults. The commands must be run from the Julia root after building with 'make debug'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/backtraces.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n\"$ cd <julia_root>\\n$ make debug\\n$ gdb --args usr/bin/julia-debug <path_to_your_script>\\n\"\n```\n\n----------------------------------------\n\nTITLE: Basic Julia Embedding Code for Visual Studio C Projects\nDESCRIPTION: Shows the C `main` function code for a basic Julia embedding example specifically tailored for a Visual Studio Console Application project. It performs initialization (`jl_init`), evaluation of a Julia string (`jl_eval_string`), and cleanup (`jl_atexit_hook`). This code replaces the default `main` function in the Visual Studio template.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nint main(int argc, char *argv[])\n{\n    /* required: setup the Julia context */\n    jl_init();\n\n    /* run Julia commands */\n    jl_eval_string(\"print(sqrt(2.0))\");\n\n    /* strongly recommended: notify Julia that the\n         program is about to terminate. this allows\n         Julia time to cleanup pending write requests\n         and run all finalizers\n    */\n    jl_atexit_hook(0);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the VecElement Struct in Julia\nDESCRIPTION: Defines the `VecElement{T}` struct, a wrapper for a value of type `T`. This struct is fundamental for SIMD operations in Julia, as homogeneous tuples of `VecElement{T}` (where T is a primitive bits type) map directly to LLVM vector types, potentially enabling auto-vectorization.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/simd-types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nstruct VecElement{T}\n    value::T\nend\n```\n\n----------------------------------------\n\nTITLE: Specifying Size for `diagm` and `spdiagm` in Julia\nDESCRIPTION: The `diagm` (LinearAlgebra) and `spdiagm` (SparseArrays) functions now accept optional initial `m, n` arguments to specify the dimensions of the resulting matrix.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_132\n\nLANGUAGE: julia\nCODE:\n```\nusing LinearAlgebra, SparseArrays\n\ndiagm(3, 4, 0 => [1, 2, 3]) # Dense 3x4 matrix\nspdiagm(5, 6, 0 => [1, 1, 1]) # Sparse 5x6 matrix\n```\n\n----------------------------------------\n\nTITLE: Iterating over a Custom `Squares` Object in Julia\nDESCRIPTION: Demonstrates the use of a `for` loop to iterate over an instance of the custom `Squares` type. This works because the `iterate` method has been defined for `Squares`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for item in Squares(7)\n           println(item)\n       end\n1\n4\n9\n16\n25\n36\n49\n```\n\n----------------------------------------\n\nTITLE: Wrapper for circle with No Keyword Arguments - Julia\nDESCRIPTION: Provides the method invoked when circle is called without keyword arguments. The method passes default values and a default empty NamedTuple (paired) for options to the auto-generated keyword handler. Required for every function with keyword arguments to ensure correct fallback behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nfunction circle(center, radius)\n    #circle#1(black, true, pairs(NamedTuple()), circle, center, radius)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple C Function for Shared Library Export\nDESCRIPTION: This C code defines a function that prints a message with an integer argument. It is intended for compilation as a shared library, which can then be called from Julia using @ccall. The function requires <stdio.h> for printf, and the shared object must be correctly compiled with -shared and -fPIC flags for compatibility.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n\nvoid say_y(int y)\n{\n    printf(\"Hello from C: got y = %d.\\n\", y);\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Custom Julia Structs to TOML\nDESCRIPTION: Shows how to serialize custom Julia structs using `TOML.print` by providing a function as the first argument. This function takes the object to be serialized and should return a TOML-supported type (like an array or dictionary). The example converts a `MyStruct` instance into an array `[x.a, x.b]` for TOML serialization.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/TOML/docs/src/index.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> using TOML\n\njulia> struct MyStruct\n           a::Int\n           b::String\n       end\n\njulia> TOML.print(Dict(\"foo\" => MyStruct(5, \"bar\"))) do x\n           x isa MyStruct && return [x.a, x.b]\n           error(\"unhandled type $(typeof(x))\")\n       end\nfoo = [5, \"bar\"]\n```\n\n----------------------------------------\n\nTITLE: Querying the Type of a Julia Object in C\nDESCRIPTION: Declares the C function `jl_typeof`, which takes a pointer to a Julia object (`jl_value_t *v`) and returns a pointer to its corresponding type object (a `jl_datatype_t`, which itself is represented as a `jl_value_t*`). This is essential for reflection and type checking in C.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *jl_typeof(jl_value_t *v);\n```\n\n----------------------------------------\n\nTITLE: Initializing TerminalMenus Options in Julia\nDESCRIPTION: Shows the initial setup for using TerminalMenus. It imports the `REPL` module and the `TerminalMenus` submodule, then defines a list of string options that will be used in subsequent menu examples.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\nimport REPL\nusing REPL.TerminalMenus\n\noptions = [\"apple\", \"orange\", \"grape\", \"strawberry\",\n            \"blueberry\", \"peach\", \"lemon\", \"lime\"]\n\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Type Structure Inspection Functions\nDESCRIPTION: This block uses the `@docs` directive to list functions for inspecting the declared structure of Julia types, such as mutability, abstractness, primitive status, field names, field types, and field counts. It directs the documentation generator to include these under the 'Declared structure' subcategory within 'Properties of Types'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.ismutable\nBase.isimmutable\nBase.ismutabletype\nBase.isabstracttype\nBase.isprimitivetype\nBase.issingletontype\nBase.isstructtype\nBase.nameof(::DataType)\nBase.fieldnames\nBase.fieldname\nCore.fieldtype\nBase.fieldtypes\nBase.fieldcount\nBase.hasfield\nCore.nfields\nBase.isconst\nBase.isfieldatomic\n```\n```\n\n----------------------------------------\n\nTITLE: Methods Discovery by Argument Type or Interactive Lookup - Julia-REPL\nDESCRIPTION: Demonstrates using tab completion with the ? function or help mode to list callable methods for a particular argument type, e.g., all InteractiveUtils functions that accept a string. SHIFT-TAB expands completion to include methods with arguments typed as Any. Useful for API exploration and method lookup inside Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_24\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> InteractiveUtils.?(\"somefile\")[TAB]\nedit(path::AbstractString) in InteractiveUtils at InteractiveUtils/src/editless.jl:197\nless(file::AbstractString) in InteractiveUtils at InteractiveUtils/src/editless.jl:266\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> InteractiveUtils.?(\"somefile\")[SHIFT-TAB]\napropos(string) in REPL at REPL/src/docview.jl:796\nclipboard(x) in InteractiveUtils at InteractiveUtils/src/clipboard.jl:64\ncode_llvm(f) in InteractiveUtils at InteractiveUtils/src/codeview.jl:221\ncode_native(f) in InteractiveUtils at InteractiveUtils/src/codeview.jl:243\nedit(path::AbstractString) in InteractiveUtils at InteractiveUtils/src/editless.jl:197\nedit(f) in InteractiveUtils at InteractiveUtils/src/editless.jl:225\neval(x) in InteractiveUtils at InteractiveUtils/src/InteractiveUtils.jl:3\ninclude(x) in InteractiveUtils at InteractiveUtils/src/InteractiveUtils.jl:3\nless(file::AbstractString) in InteractiveUtils at InteractiveUtils/src/editless.jl:266\nless(f) in InteractiveUtils at InteractiveUtils/src/editless.jl:274\nreport_bug(kind) in InteractiveUtils at InteractiveUtils/src/InteractiveUtils.jl:391\nseparate_kwargs(args...; kwargs...) in InteractiveUtils at InteractiveUtils/src/macros.jl:7\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Julia Unicode Functions (Markdown/Julia)\nDESCRIPTION: This `@docs` block is a directive for Documenter.jl. It instructs the documentation generator to automatically fetch and insert the documentation (docstrings) for the specified Julia entities: the `Unicode` module itself, and several functions within it (`julia_chartransform`, `isassigned`, `isequal_normalized`, `normalize`, `graphemes`). This automates the inclusion of API documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Unicode/docs/src/index.md#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n```@docs\nUnicode\nUnicode.julia_chartransform\nUnicode.isassigned\nUnicode.isequal_normalized\nUnicode.normalize\nUnicode.graphemes\n```\n```\n\n----------------------------------------\n\nTITLE: Profiling Package Precompilation with Tracy in Julia\nDESCRIPTION: This Julia code demonstrates how to profile the precompilation process of a specific package (e.g., \"SparseArrays\") using Tracy. It uses `Base.identify_package` to get a package identifier and then calls `Base.compilecache` within a `withenv` block. The `withenv` block temporarily sets the `JULIA_WAIT_FOR_TRACY=1` environment variable (to ensure Julia waits for the profiler connection) and `TRACY_PORT=9001` (to use a non-default port, making it easier to connect the Tracy UI to the correct Julia instance).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/external_profilers.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\npkg = Base.identify_package(\"SparseArrays\")\nwithenv(\"JULIA_WAIT_FOR_TRACY\" => 1, \"TRACY_PORT\" => 9001) do\n    Base.compilecache(pkg)\nend\n\n```\n\n----------------------------------------\n\nTITLE: Running the Multithreaded C/Julia Example\nDESCRIPTION: This shell snippet shows how to compile and run the C code example (presumably named `thread_example.c` or similar) that demonstrates calling the Julia C API from Julia-managed threads. The `JULIA_NUM_THREADS=2` environment variable tells the Julia runtime to start with 2 threads. The example output shows the number of threads reported by Julia, and interleaved output from both C (`[C ...]`) and Julia (`[J ...]`), indicating calls originating from different Julia threads mapped to distinct C pthreads.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_39\n\nLANGUAGE: sh\nCODE:\n```\n$ JULIA_NUM_THREADS=2 ./thread_example\n2\n[C 3bfd9c00] i = 1\n[C 23938640] i = 4\n[J 1] i = 1 -> 1.0\n[C 3bfd9c00] i = 2\n[J 1] i = 2 -> 1.4142135623730951\n[C 3bfd9c00] i = 3\n[J 2] i = 4 -> 2.0\n[C 23938640] i = 5\n[J 1] i = 3 -> 1.7320508075688772\n[J 2] i = 5 -> 2.23606797749979\n```\n\n----------------------------------------\n\nTITLE: Implementing Loop Scope Using Inner Function (Closure) - Julia\nDESCRIPTION: The sum_to_def_closure function explores how creating an inner function (closure) affects variable scope: t inside loop_body is local to that function, while s is updated across scopes. No external dependencies are required. The n parameter determines the number of iterations; returns include the accumulated sum and a check on t's visibility in the outer function. This snippet demonstrates equivalence between inner loop scopes and the inner function's scope in closures.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> function sum_to_def_closure(n)\n           function loop_body(i)\n               t = s + i # new local `t`\n               s = t # assign same local `s` as below\n           end\n           s = 0 # new local\n           for i = 1:n\n               loop_body(i)\n           end\n           return s, @isdefined(t)\n       end\nsum_to_def_closure (generic function with 1 method)\n\njulia> sum_to_def_closure(10)\n(55, false)\n```\n\n----------------------------------------\n\nTITLE: Converting Between Linear and Cartesian Indices in Julia\nDESCRIPTION: This snippet demonstrates conversion from linear to cartesian indices and vice versa using CartesianIndices and LinearIndices utilities. No special packages are required. The code provides element-wise index transformations for advanced access patterns in multi-dimensional arrays. Inputs are the matrix and integer indices; outputs are index objects or integers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\njulia> CartesianIndices(A)[5]\nCartesianIndex(2, 2)\n\njulia> LinearIndices(A)[2, 2]\n5\n```\n\n----------------------------------------\n\nTITLE: Checking Thread Counts with Julia Threads API - Julia\nDESCRIPTION: Demonstrates how to determine the number of execution threads in Julia, using the Threads.nthreads function for both :default and :interactive thread pools. Requires Julia's standard Threads module; no external dependencies. Inputs are threadpool symbols (:default or :interactive), and outputs are integer counts of threads for each pool.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> Threads.nthreads(:default)\n1\njulia> Threads.nthreads(:interactive)\n1\n```\n\n----------------------------------------\n\nTITLE: Throwing an Exception with Arguments (UndefVarError) - Julia\nDESCRIPTION: Demonstrates throwing an exception with arguments for detailed error reporting. Here, throw(UndefVarError(:x)) raises an error regarding the undefined variable x. Base Julia is required; acceptable argument types are Symbol. No return value as it interrupts control flow.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\njulia> throw(UndefVarError(:x))\nERROR: UndefVarError: `x` not defined\n\n```\n\n----------------------------------------\n\nTITLE: Checking Subtype Relationships - Julia\nDESCRIPTION: This snippet uses the '<:' operator in an expression context to determine if one type is a subtype of another in Julia. The examples showcase interactive usage within the Julia REPL, returning boolean values based on the type relationship. This operation is core to Julia and does not require external dependencies. Inputs are two existing types; output is a boolean indicating the subtype relationship.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> Integer <: Number\ntrue\n\njulia> Integer <: AbstractFloat\nfalse\n```\n\n----------------------------------------\n\nTITLE: Comparing Local and Remote remotecall_fetch Data Passing Semantics in Julia\nDESCRIPTION: This snippet illustrates the different data semantics between remotecall_fetch to the local node and to a remote node. It uses Distributed and demonstrates that on the local node, remotecall_fetch modifies the same object reference, while on a remote node, a copy is sent and modifications are isolated. Key parameters include the value of the arguments and target worker. Inputs and results are printed to verify identity. Ensure that at least one worker is added before invoking remote calls.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\njulia> using Distributed; addprocs(1);\n\njulia> v = [0];\n\njulia> v2 = remotecall_fetch(x -> (x[1] = 1; x), myid(), v);     # Executed on local node\n\njulia> println(\"v=$v, v2=$v2, \", v === v2);\nv=[1], v2=[1], true\n\njulia> v = [0];\n\njulia> v2 = remotecall_fetch(x -> (x[1] = 1; x), workers()[1], v); # Executed on remote node\n\njulia> println(\"v=$v, v2=$v2, \", v === v2);\nv=[0], v2=[1], false\n```\n\n----------------------------------------\n\nTITLE: New `iszero(x)` Function in Julia\nDESCRIPTION: Adds a new function `iszero(x)` to Julia. It provides a quick way to check if a numeric value `x` is zero, or if all elements of an array `x` are zero.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_170\n\nLANGUAGE: julia\nCODE:\n```\niszero(x)\n```\n\n----------------------------------------\n\nTITLE: Creating and Collecting Date Ranges with Periods in Julia\nDESCRIPTION: Shows how to construct ranges of Date objects using a specified period increment, then collect their values into a vector. Two examples demonstrate day and month intervals. Useful for efficient generation and iteration of calendar ranges.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\njulia> dr = Date(2014,1,29):Day(1):Date(2014,2,3)\nDate(\"2014-01-29\"):Day(1):Date(\"2014-02-03\")\n\njulia> collect(dr)\n6-element Vector{Date}:\n 2014-01-29\n 2014-01-30\n 2014-01-31\n 2014-02-01\n 2014-02-02\n 2014-02-03\n\njulia> dr = Date(2014,1,29):Dates.Month(1):Date(2014,07,29)\nDate(\"2014-01-29\"):Month(1):Date(\"2014-07-29\")\n\njulia> collect(dr)\n7-element Vector{Date}:\n 2014-01-29\n 2014-02-28\n 2014-03-29\n 2014-04-29\n 2014-05-29\n 2014-06-29\n 2014-07-29\n```\n\n----------------------------------------\n\nTITLE: Deprecation of String-Accepting Character Predicates: Use `all` in Julia\nDESCRIPTION: Methods of character predicates (like `isalnum`, `isnumber`, `isspace`, etc.) that accept `AbstractString` arguments are deprecated in Julia. Apply the predicate to each character using `all`, for example, replace `isnumber(\"123\")` with `all(isnumber, \"123\")`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_198\n\nLANGUAGE: julia\nCODE:\n```\nall(isnumber, \"123\")\n```\n\n----------------------------------------\n\nTITLE: Copying Between AbstractVectors With Arbitrary Indices via LinearIndices - Julia\nDESCRIPTION: This function shows a safe copy operation for AbstractVectors that may use unconventional indices by comparing axes and iterating over 'LinearIndices(src)'. The indices are guaranteed to match both the index set and value origin of 'src', preventing errors when using custom-indexed arrays. Dependencies: Julia Base. Parameters: 'dest', 'src' as AbstractVectors with identical axes. Returns 'dest'. Inputs must have matching axes; otherwise, a DimensionMismatch is thrown.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/offset-arrays.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nfunction mycopy!(dest::AbstractVector, src::AbstractVector)\n    axes(dest) == axes(src) || throw(DimensionMismatch(\"vectors must match\"))\n    for i in LinearIndices(src)\n        @inbounds dest[i] = src[i]\n    end\n    dest\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Wrapper for Chunked Advection on SharedArray in Julia REPL\nDESCRIPTION: Defines a convenience wrapper function `advection_shared_chunk!` using `@everywhere`. This function calls the core `advection_chunk!` function, automatically determining the appropriate `irange` and `jrange` for the calling worker by invoking `myrange(q)`. The time range `trange` is set to `1:size(q,3)-1`. Requires `myrange` and `advection_chunk!` to be defined on the workers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\njulia> @everywhere advection_shared_chunk!(q, u) =\n           advection_chunk!(q, u, myrange(q)..., 1:size(q,3)-1)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom `similar` for `ArrayAndChar` Broadcasting in Julia\nDESCRIPTION: Provides the implementation of `Base.similar` specialized for the `ArrayAndChar` broadcast style (`Broadcast.ArrayStyle{ArrayAndChar}`). It uses a recursive helper function `find_aac` to locate an `ArrayAndChar` instance within the potentially nested broadcast arguments (`bc.args`). It then creates a new `ArrayAndChar` instance for the output, allocating the underlying data array using `similar(Array{ElType}, axes(bc))` and preserving the `char` metadata from the found input `ArrayAndChar`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest ArrayAndChar; output = false\nfunction Base.similar(bc::Broadcast.Broadcasted{Broadcast.ArrayStyle{ArrayAndChar}}, ::Type{ElType}) where ElType\n    # Scan the inputs for the ArrayAndChar:\n    A = find_aac(bc)\n    # Use the char field of A to create the output\n    ArrayAndChar(similar(Array{ElType}, axes(bc)), A.char)\nend\n\n\"`A = find_aac(As)` returns the first ArrayAndChar among the arguments.\"\nfind_aac(bc::Base.Broadcast.Broadcasted) = find_aac(bc.args)\nfind_aac(args::Tuple) = find_aac(find_aac(args[1]), Base.tail(args))\nfind_aac(x) = x\nfind_aac(::Tuple{}) = nothing\nfind_aac(a::ArrayAndChar, rest) = a\nfind_aac(::Any, rest) = find_aac(rest)\n```\n```\n\n----------------------------------------\n\nTITLE: Testing for Expected Exceptions in Julia\nDESCRIPTION: Demonstrates the use of the `@test_throws` macro in Julia to assert that a specific type of exception (`MethodError`) is thrown when evaluating an expression (`foo(:cat)`). This test passes because the expected error occurs.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> @test_throws MethodError foo(:cat)\nTest Passed\n      Thrown: MethodError\n```\n\n----------------------------------------\n\nTITLE: Lowered 'kwsorter' Method for Handling Keyword Argument Sorting - Julia\nDESCRIPTION: Implements the 'kwsorter' function, which takes a NamedTuple of keyword arguments and rearranges them, evaluates defaults, and invokes the keyword method. This function is auto-generated by the Julia compiler for any method with keyword arguments. It facilitates both default argument expansion and error handling for extraneous keywords.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nfunction (::Core.kwftype(typeof(circle)))(kws, circle, center, radius)\n    if haskey(kws, :color)\n        color = kws.color\n    else\n        color = black\n    end\n    # etc.\n\n    # put remaining kwargs in `options`\n    options = structdiff(kws, NamedTuple{(:color, :fill)})\n\n    # if the method doesn't accept rest keywords, throw an error\n    # unless `options` is empty\n\n    #circle#1(color, fill, pairs(options), circle, center, radius)\nend\n```\n\n----------------------------------------\n\nTITLE: Nested @static Conditionals for Symbol Selection - Julia\nDESCRIPTION: This snippet illustrates how to use nested @static macros to select symbols based on the detected operating system in Julia. It returns :a for Windows, :b for Apple, and :c for all other platforms, ensuring compile-time selection for nested OS branches. Requires only base Julia, with all symbols (a, b, c) defined elsewhere.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/handling-operating-system-variation.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n@static Sys.iswindows() ? :a : (@static Sys.isapple() ? :b : :c)\n```\n\n----------------------------------------\n\nTITLE: Attaching bpftrace to Julia Process for Probe Monitoring - Shell/BPFtrace\nDESCRIPTION: This snippet uses bpftrace to attach to a running Julia process via a USDT probe, specifically monitoring the julia:rt__sleep__check__wake hook for thread sleep/wake events. It requires superuser privileges and knowledge of the target PID, which can be obtained from the Julia process. Key parameters: -p (PID), -e (expression with inline probe definition). Dependencies: bpftrace installed, Julia built with USDT probes enabled, and access to libjulia-internal.so.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nsudo bpftrace -p 997825 -e 'usdt:usr/lib/libjulia-internal.so:julia:rt__sleep__check__wake { printf(\"Thread wake up! %x\\n\", arg0); }'\n```\n\n----------------------------------------\n\nTITLE: Using GC Write Barrier After Directly Updating Array Elements in C\nDESCRIPTION: Shows the necessity of using the GC write barrier (`jl_gc_wb`) when directly modifying the contents of a Julia array of pointers (e.g., `Vector{Any}`) from C. After getting the raw data pointer using `jl_array_data` and updating an element, `jl_gc_wb` must be called with the array's owner (`jl_array_owner`) and the new value to notify the GC.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_23\n\nLANGUAGE: c\nCODE:\n```\njl_array_t *some_array = ...; // e.g. a Vector{Any}\nvoid **data = jl_array_data(some_array, void*);\njl_value_t *some_value = ...;\ndata[0] = some_value;\njl_gc_wb(jl_array_owner(some_array), some_value);\n```\n\n----------------------------------------\n\nTITLE: Displaying Default REPL Module in Julia\nDESCRIPTION: Demonstrates how to check the current active module context within the Julia REPL using the `@__MODULE__` macro. By default, expressions are evaluated in the `Main` module.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_29\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @__MODULE__\nMain\n```\n\n----------------------------------------\n\nTITLE: Defining Parallel Advection using @distributed in Julia REPL\nDESCRIPTION: Defines the function `advection_parallel!`, which parallelizes the advection computation using Julia's `@distributed` macro. The outer loop iterates through time steps `t` sequentially. Within each time step, the `@distributed` macro distributes the iterations of the `j` loop (columns) across available workers. `@sync` ensures all parallel tasks for a given time step complete before proceeding to the next.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\njulia> function advection_parallel!(q, u)\n           for t = 1:size(q,3)-1\n               @sync @distributed for j = 1:size(q,2)\n                   for i = 1:size(q,1)\n                       q[i,j,t+1]= q[i,j,t] + u[i,j,t]\n                   end\n               end\n           end\n           q\n       end;\n```\n\n----------------------------------------\n\nTITLE: Documenting Module API with @docs Macro - Julia\nDESCRIPTION: The provided code snippet uses Julia's `@docs` macro to enumerate public types, structs, and functions exported by the LibGit2 module. This macro generates documentation index sections, linking to relevant docstrings and source code where available. Dependencies include the Julia Documenter package, and it is used in docstring or markdown files to construct organized API overviews. The macro expects names of types and methods; input consists of a sequence of qualified names with optional signatures, and the output is a documentation block rendered in the generated docs. Limitations: it does not include implementation examples or inline code, focusing strictly on API item listings.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/LibGit2/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nLibGit2.Buffer\nLibGit2.CheckoutOptions\nLibGit2.CloneOptions\nLibGit2.DescribeOptions\nLibGit2.DescribeFormatOptions\nLibGit2.DiffDelta\nLibGit2.DiffFile\nLibGit2.DiffOptionsStruct\nLibGit2.FetchHead\nLibGit2.FetchOptions\nLibGit2.GitAnnotated\nLibGit2.GitBlame\nLibGit2.GitBlob\nLibGit2.GitCommit\nLibGit2.GitConfig\nLibGit2.GitHash\nLibGit2.GitObject\nLibGit2.GitRemote\nLibGit2.GitRemoteAnon\nLibGit2.GitRepo\nLibGit2.GitRepoExt\nLibGit2.GitRevWalker\nLibGit2.GitShortHash\nLibGit2.GitSignature\nLibGit2.GitStatus\nLibGit2.GitTag\nLibGit2.GitTree\nLibGit2.IndexEntry\nLibGit2.IndexTime\nLibGit2.BlameOptions\nLibGit2.MergeOptions\nLibGit2.ProxyOptions\nLibGit2.PushOptions\nLibGit2.RebaseOperation\nLibGit2.RebaseOptions\nLibGit2.RemoteCallbacks\nLibGit2.SignatureStruct\nLibGit2.StatusEntry\nLibGit2.StatusOptions\nLibGit2.StrArrayStruct\nLibGit2.TimeStruct\nLibGit2.addfile\nLibGit2.add!\nLibGit2.add_fetch!\nLibGit2.add_push!\nLibGit2.addblob!\nLibGit2.author\nLibGit2.authors\nLibGit2.branch\nLibGit2.branch!\nLibGit2.checkout!\nLibGit2.clone\nLibGit2.commit\nLibGit2.committer\nLibGit2.count\nLibGit2.counthunks\nLibGit2.create_branch\nLibGit2.credentials_callback\nLibGit2.credentials_cb\nLibGit2.default_signature\nLibGit2.delete_branch\nLibGit2.diff_files\nLibGit2.entryid\nLibGit2.entrytype\nLibGit2.fetch\nLibGit2.fetchheads\nLibGit2.fetch_refspecs\nLibGit2.fetchhead_foreach_cb\nLibGit2.merge_base\nLibGit2.merge!(::LibGit2.GitRepo; ::Any...)\nLibGit2.merge!(::LibGit2.GitRepo, ::Vector{LibGit2.GitAnnotated}; ::LibGit2.MergeOptions, ::LibGit2.CheckoutOptions)\nLibGit2.merge!(::LibGit2.GitRepo, ::Vector{LibGit2.GitAnnotated}, ::Bool; ::LibGit2.MergeOptions, ::LibGit2.CheckoutOptions)\nLibGit2.ffmerge!\nLibGit2.fullname\nLibGit2.features\nLibGit2.filename\nLibGit2.filemode\nLibGit2.gitdir\nLibGit2.git_url\nLibGit2.@githash_str\nLibGit2.head\nLibGit2.head!\nLibGit2.head_oid\nLibGit2.headname\nLibGit2.init\nLibGit2.is_ancestor_of\nLibGit2.isbinary\nLibGit2.iscommit\nLibGit2.isdiff\nLibGit2.isdirty\nLibGit2.isorphan\nLibGit2.isset\nLibGit2.iszero\nLibGit2.lookup_branch\nLibGit2.map\nLibGit2.mirror_callback\nLibGit2.mirror_cb\nLibGit2.message\nLibGit2.merge_analysis\nLibGit2.name\nLibGit2.need_update\nLibGit2.objtype\nLibGit2.path\nLibGit2.peel\nLibGit2.posixpath\nLibGit2.push\nLibGit2.push!(::LibGit2.GitRevWalker, ::LibGit2.GitHash)\nLibGit2.push_head!\nLibGit2.push_refspecs\nLibGit2.raw\nLibGit2.read_tree!\nLibGit2.rebase!\nLibGit2.ref_list\nLibGit2.reftype\nLibGit2.remotes\nLibGit2.remove!\nLibGit2.reset\nLibGit2.reset!\nLibGit2.restore\nLibGit2.revcount\nLibGit2.set_remote_url\nLibGit2.shortname\nLibGit2.snapshot\nLibGit2.split_cfg_entry\nLibGit2.status\nLibGit2.stage\nLibGit2.tag_create\nLibGit2.tag_delete\nLibGit2.tag_list\nLibGit2.target\nLibGit2.toggle\nLibGit2.transact\nLibGit2.treewalk\nLibGit2.upstream\nLibGit2.update!\nLibGit2.url\nLibGit2.version\nLibGit2.with\nLibGit2.with_warn\nLibGit2.workdir\nLibGit2.GitObject(::LibGit2.GitTreeEntry)\nLibGit2.UserPasswordCredential\nLibGit2.SSHCredential\nLibGit2.isfilled\nLibGit2.CachedCredentials\nLibGit2.CredentialPayload\nLibGit2.approve\nLibGit2.reject\nLibGit2.Consts.GIT_CONFIG\n```\n```\n\n----------------------------------------\n\nTITLE: Disallowed Variable Names: Keywords - Julia REPL - Julia\nDESCRIPTION: This snippet shows failed attempts to use Julia language keywords ('else', 'try') as variable names, resulting in syntax errors. It clarifies which identifiers are forbidden by the parser. The REPL is used to interactively demonstrate error diagnostics. No dependencies outside Julia's parser are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> else = false\\nERROR: syntax: unexpected \\\"else\\\"\\n\\njulia> try = \\\"No\\\"\\nERROR: syntax: unexpected \\\"=\\\"\n```\n\n----------------------------------------\n\nTITLE: Imaginary Unit Representation\nDESCRIPTION: Julia represents the imaginary unit `sqrt(-1)` as `im`, whereas MATLAB uses `i` or `j`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nim\n```\n\n----------------------------------------\n\nTITLE: Configuring MultiSelectMenu with Unicode Characters in Julia REPL\nDESCRIPTION: Shows how to customize the appearance of a `MultiSelectMenu` by passing configuration options to its constructor (available from Julia 1.6). This example sets the `charset` to `:unicode` to use Unicode characters for selection indicators and navigation arrows.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_37\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> menu = MultiSelectMenu(options, pagesize=5, charset=:unicode);\n\njulia> request(menu)\n[press: Enter=toggle, a=all, n=none, d=done, q=abort]\n   ⬚ apple\n   ✓ orange\n   ⬚ grape\n → ✓ strawberry\n↓  ⬚ blueberry\n```\n\n----------------------------------------\n\nTITLE: Profiling Repeated Function Execution - Julia\nDESCRIPTION: Profiles the function myfunc over 100 iterations inside a for-loop to gather more samples, then interprets the profiling results to enable more conclusive performance analysis. The snippet uses Julia's built-in Profile macro and expects the function myfunc is in scope. Input is the profiled code; output is a more statistically significant sample in the Profile buffer, readable via Profile.print(). No external dependencies beyond Profile are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_2\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @profile (for i = 1:100; myfunc(); end)\n\njulia> Profile.print()\n[....]\n 3821 ./REPL[1]:2; myfunc()\n  3511 ./random.jl:431; rand!(::MersenneTwister, ::Array{Float64,3}, ::Int64, ::Type...\n   3511 ./dSFMT.jl:84; dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_state, ::Ptr...\n  310  ./random.jl:278; rand\n   [....]\n 2893 ./REPL[1]:3; myfunc()\n  2893 ./reduce.jl:270; _mapreduce(::Base.#identity, ::Base.#scalarmax, ::IndexLinea...\n   [....]\n```\n\n----------------------------------------\n\nTITLE: Querying Month Name and Days in Month in Julia\nDESCRIPTION: This snippet retrieves the month's name and the number of days in the month from a Date instance. The shown functions are part of the Dates module and accept a Date as input, returning a string or integer.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> Dates.monthname(t)\n\"January\"\n\njulia> Dates.daysinmonth(t)\n31\n```\n\n----------------------------------------\n\nTITLE: Obtaining CodeInfo for a Method Call in Julia\nDESCRIPTION: This snippet shows how to use the `@code_typed` macro to retrieve the `CodeInfo` object for a specific function call (`convert(Int, UInt(1))`). The `CodeInfo` object represents the typed Abstract Syntax Tree (AST) after type inference and optimization, containing detailed type information for variables and expressions. The `[1]` indexing extracts the `CodeInfo` object itself from the tuple returned by `@code_typed`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/inference.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n# Returns the CodeInfo object for `convert(Int, ::UInt)`:\nci = (@code_typed convert(Int, UInt(1)))[1]\n```\n\n----------------------------------------\n\nTITLE: Signature for Calling Julia Functions with Multiple Arguments in C\nDESCRIPTION: This shows the function signature for `jl_call`, which is used to invoke a Julia function (`f`) from C with an arbitrary number (`nargs`) of arguments passed as an array (`args`) of `jl_value_t*` pointers. This is more general than `jl_call0`, `jl_call1`, `jl_call2`, and `jl_call3`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_11\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs)\n```\n\n----------------------------------------\n\nTITLE: Handling Impossible Conversions with `convert` in Julia\nDESCRIPTION: Shows the result of attempting an invalid conversion using `convert`, specifically trying to convert a `String` to an `AbstractFloat`. This results in a `MethodError` because no applicable conversion method exists.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_1\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> convert(AbstractFloat, \"foo\")\nERROR: MethodError: Cannot `convert` an object of type String to an object of type AbstractFloat\n[...]\n```\n\n----------------------------------------\n\nTITLE: Creating an Optimized Sampler for DiscreteDistribution in Julia\nDESCRIPTION: Implements `Random.eltype` to specify the output type (`Int`) and `Random.Sampler` to construct an optimized sampler for `DiscreteDistribution`. This sampler uses `SamplerSimple` to store pre-computed data (an alias table generated by `make_alias_table`) for efficient random number generation. Requires `make_alias_table` to be defined elsewhere.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nRandom.eltype(::Type{<:DiscreteDistribution}) = Int\n\nfunction Random.Sampler(::Type{<:AbstractRNG}, distribution::DiscreteDistribution, ::Repetition)\n    SamplerSimple(distribution, make_alias_table(distribution.probabilities))\nend\n```\n\n----------------------------------------\n\nTITLE: Displaying Statement Costs for Inlining Analysis in Julia (jldoctest)\nDESCRIPTION: This snippet demonstrates using `Base.print_statement_costs` to inspect the compiler's estimated cost for each statement within a specific method instance (`map(sqrt, (2,))`). This is useful for understanding the inlining cost model (`inline_worthy`). The costs, shown in the left column of the output comment, are derived from intrinsic function costs and heuristics for control flow and calls, guiding the decision of whether to inline the function call.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/inference.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Base.print_statement_costs(stdout, map, (typeof(sqrt), Tuple{Int},)) # map(sqrt, (2,))\nmap(f, t::Tuple{Any}) @ Base tuple.jl:358\n  0 1 ─ %1  = $(Expr(:boundscheck, true))::Bool\n  0 │   %2  =   builtin Base.getfield(_3, 1, %1)::Int64\n  1 │   %3  = intrinsic Base.sitofp(Float64, %2)::Float64\n  0 │   %4  = intrinsic Base.lt_float(%3, 0.0)::Bool\n  0 └──       goto #3 if not %4\n  0 2 ─          invoke Base.Math.throw_complex_domainerror(:sqrt::Symbol, %3::Float64)::Union{}\n  0 └──       unreachable\n 20 3 ─ %8  = intrinsic Base.Math.sqrt_llvm(%3)::Float64\n  0 └──       goto #4\n  0 4 ─       goto #5\n  0 5 ─ %11 =   builtin Core.tuple(%8)::Tuple{Float64}\n  0 └──       return %11\n```\n\n----------------------------------------\n\nTITLE: Listing General I/O Functions/Types in Julia Base\nDESCRIPTION: This snippet uses the `@docs` macro to list various functions and types from Julia's Base module related to general input/output operations. It includes standard streams (stdout, stderr, stdin), file operations (open, read, write), stream types (IOStream, IOBuffer, Pipe), stream manipulation (seek, position, flush, close), and redirection utilities.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/io-network.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.stdout\nBase.stderr\nBase.stdin\nBase.read(::AbstractString)\nBase.write(::AbstractString, ::Any)\nBase.open\nBase.IOStream\nBase.IOBuffer\nBase.take!(::Base.GenericIOBuffer)\nBase.Pipe\nBase.link_pipe!\nBase.fdio\nBase.flush\nBase.close\nBase.closewrite\nBase.write\nBase.read\nBase.read!\nBase.readbytes!\nBase.unsafe_read\nBase.unsafe_write\nBase.readeach\nBase.peek\nBase.position\nBase.seek\nBase.seekstart\nBase.seekend\nBase.skip\nBase.mark\nBase.unmark\nBase.reset(::IO)\nBase.ismarked\nBase.eof\nBase.isreadonly\nBase.iswritable\nBase.isreadable\nBase.isexecutable\nBase.isopen\nBase.fd\nBase.redirect_stdio\nBase.redirect_stdout\nBase.redirect_stdout(::Function, ::Any)\nBase.redirect_stderr\nBase.redirect_stderr(::Function, ::Any)\nBase.redirect_stdin\nBase.redirect_stdin(::Function, ::Any)\nBase.readchomp\nBase.truncate\nBase.skipchars\nBase.countlines\nBase.PipeBuffer\nBase.readavailable\nBase.IOContext\nBase.IOContext(::IO, ::Pair)\nBase.IOContext(::IO, ::IOContext)\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Flags (i, m, s, x) to Regex Literals in Julia\nDESCRIPTION: Shows how to append flags (`i` for case-insensitive, `m` for multi-line, `s` for single-line/dotall, `x` for extended/comments) after the closing quote of a `r\"...\"` literal to modify the regex matching behavior, similar to Perl.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_54\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> r\"a+.*b+.*d$\"ism\nr\"a+.*b+.*d$\"ims\n\njulia> match(r\"a+.*b+.*d$\"ism, \"Goodbye,\\nOh, angry,\\nBad world\\n\")\nRegexMatch(\"angry,\\nBad world\")\n```\n\n----------------------------------------\n\nTITLE: Using External Tracing Tools for Startup Diagnostics - Shell\nDESCRIPTION: These shell snippets demonstrate how to invoke external system tracing tools (strace on Linux and dtruss on macOS) to monitor system calls and diagnose issues during the early startup phase of the Julia process. They require appropriate permissions and the presence of the tracing utilities, and their outputs can be shared with maintainers for further diagnostic analysis.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/backtraces.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n\"$ strace julia\\n\"\n```\n\nLANGUAGE: shell\nCODE:\n```\n\"$ dtruss -f julia\\n\"\n```\n\n----------------------------------------\n\nTITLE: Customizing REPL Output Display with IOContext in Julia\nDESCRIPTION: This code demonstrates how the Julia REPL uses `show` with an `IOContext` (specifically setting `:limit` to `true`) to display results. It then shows how to manually call `show` with a modified `IOContext` (setting `:compact` to `false`) for verbose output. Finally, it modifies the active REPL's options (`Base.active_repl.options.iocontext`) to persistently change the display format for subsequent evaluations, making `rand(2, 2)` output non-compactly.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> rand(2, 2)\n2×2 Matrix{Float64}:\n 0.8833    0.329197\n 0.719708  0.59114\n\njulia> show(IOContext(stdout, :compact => false), \"text/plain\", rand(2, 2))\n 0.43540323669187075  0.15759787870609387\n 0.2540832269192739   0.4597637838786053\njulia> Base.active_repl.options.iocontext[:compact] = false;\n\njulia> rand(2, 2)\n2×2 Matrix{Float64}:\n 0.2083967319174056  0.13330606013126012\n 0.6244375177790158  0.9777957560761545\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Metaprogramming Utilities (Meta Module)\nDESCRIPTION: This block uses the `@docs` directive to list utility functions from Julia's `Meta` module, primarily used for metaprogramming and working with code expressions (`Expr`). It includes functions for quoting (`Meta.quot`), checking expression types (`Meta.isexpr`), validating identifiers and operators (`Meta.isidentifier`, `Meta.isoperator`, etc.), and displaying expressions in S-expression format (`Meta.show_sexpr`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nMeta.quot\nMeta.isexpr\nMeta.isidentifier\nMeta.isoperator\nMeta.isunaryoperator\nMeta.isbinaryoperator\nMeta.show_sexpr\n```\n```\n\n----------------------------------------\n\nTITLE: Assembling a Streamed Heap Snapshot Offline in Julia\nDESCRIPTION: Shows how to use `Profile.HeapSnapshot.assemble_snapshot` to combine the multiple files generated by a streaming heap snapshot (using the prefix \"snapshot\") into a single, viewable `.heapsnapshot` file (\"snapshot.heapsnapshot\"). This is done offline after the snapshot parts have been generated. Requires the `Profile` module.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Profile/docs/src/index.md#_snippet_4\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Profile\n\njulia> Profile.HeapSnapshot.assemble_snapshot(\"snapshot\", \"snapshot.heapsnapshot\")\n```\n\n----------------------------------------\n\nTITLE: Calling an In-Place Julia Function from C\nDESCRIPTION: This C code demonstrates calling a Julia function that modifies its argument in place. It retrieves the `reverse!` function from Julia's `Base` module using `jl_get_function` and then calls this function with the Julia array `x` as an argument using `jl_call1`. Assumes `jl_base_module` is initialized and `x` is a valid `jl_array_t*`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_28\n\nLANGUAGE: c\nCODE:\n```\njl_function_t *func = jl_get_function(jl_base_module, \"reverse!\");\njl_call1(func, (jl_value_t*)x);\n```\n\n----------------------------------------\n\nTITLE: Calling Fortran Functions for Dot Product Using @ccall - Julia\nDESCRIPTION: This example shows how to call a Fortran (BLAS) function from Julia using the @ccall macro, with careful mapping of reference and pointer types for arguments. It wraps the ddot function from libLAPACK to compute the dot product of two equal-length Float64 vectors, managing Fortran conventions for argument passing. Requires the \"libLAPACK\" library and vector inputs. Outputs the computed dot product as a Float64 scalar.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\nfunction compute_dot(DX::Vector{Float64}, DY::Vector{Float64})\n    @assert length(DX) == length(DY)\n    n = length(DX)\n    incx = incy = 1\n    product = @ccall \"libLAPACK\".ddot(\n        n::Ref{Int32}, DX::Ptr{Float64}, incx::Ref{Int32}, DY::Ptr{Float64}, incy::Ref{Int32})::Float64\n    return product\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Julia Profiler Buffer Size and Delay\nDESCRIPTION: Shows how to interact with the profiler's configuration. Calling `Profile.init()` without arguments returns the current settings. Calling it with keyword arguments like `n` (total number of instruction pointers to store, default `10^6`) and `delay` (sampling interval in seconds, default `0.001`) allows customization of the profiler's behavior and resource usage.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nProfile.init() # returns the current settings\nProfile.init(n = 10^7, delay = 0.01)\n```\n\n----------------------------------------\n\nTITLE: Disabling GC with JL_GC_DISABLED Annotation - Julia GC Static Analyzer - C\nDESCRIPTION: This example shows a function annotated with JL_GC_DISABLED indicating it should only be called when the GC is disabled, typically during startup or GC code. The runtime GC enable and disable calls bracket this function's use. Annotations are statically checked. Requires correct use with the Julia runtime.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-sa.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nvoid jl_do_magic() JL_GC_DISABLED {\n  // Wildly allocate here with no regard for roots\n}\n\nvoid example() {\n  int en = jl_gc_enable(0);\n  jl_do_magic();\n  jl_gc_enable(en);\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Dequeue Manipulation Functions in Julia\nDESCRIPTION: A documentation system directive (`@docs`) for functions commonly used with dequeue-like structures (like Julia's `Vector`) or mutable sequences. Covers adding/removing elements from both ends (`push!`, `pop!`, `pushfirst!`, `popfirst!`), insertion/deletion by index (`insert!`, `deleteat!`), filtering (`keepat!`), replacing sections (`splice!`), resizing (`resize!`), and appending/prepending collections (`append!`, `prepend!`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.push!\nBase.pop!\nBase.popat!\nBase.pushfirst!\nBase.popfirst!\nBase.insert!\nBase.deleteat!\nBase.keepat!\nBase.splice!\nBase.resize!\nBase.append!\nBase.prepend!\n```\n\n----------------------------------------\n\nTITLE: Serializing Julia Data to TOML Format\nDESCRIPTION: Demonstrates using `TOML.print` to serialize a Julia `Dict` into TOML format. The first example prints to standard output. The second example writes the TOML data to a temporary file using an IO stream and then verifies the content by parsing the file back with `TOML.parsefile`.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/TOML/docs/src/index.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> using TOML\n\njulia> data = Dict(\n          \"names\" => [\"Julia\", \"Julio\"],\n          \"age\" => [10, 20],\n       );\n\njulia> TOML.print(data)\nnames = [\"Julia\", \"Julio\"]\nage = [10, 20]\n\njulia> fname = tempname();\n\njulia> open(fname, \"w\") do io\n           TOML.print(io, data)\n       end\n\njulia> TOML.parsefile(fname)\nDict{String, Any} with 2 entries:\n  \"names\" => [\"Julia\", \"Julio\"]\n  \"age\"   => [10, 20]\n```\n\n----------------------------------------\n\nTITLE: Creating or Retrieving Julia Symbols in C\nDESCRIPTION: Declares the C function `jl_symbol`. It takes a null-terminated C string (`str`) and returns a pointer (`jl_sym_t*`, which is also a `jl_value_t*`) to the corresponding unique, interned Julia symbol object. If a symbol with the given name already exists, the existing object is returned; otherwise, a new symbol object is created and added to the internal symbol table.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_14\n\nLANGUAGE: c\nCODE:\n```\njl_sym_t *jl_symbol(const char *str);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Shell Mode Limitations on Windows in Julia\nDESCRIPTION: This snippet highlights a limitation of the Julia REPL's Shell mode on Windows. Standard Windows shell commands like `dir` are not directly available and attempting to run them results in an `IOError`, as Julia's shell mode doesn't automatically invoke `cmd.exe` or PowerShell.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> ; # upon typing ;, the prompt changes (in place) to: shell>\n\nshell> dir\nERROR: IOError: could not spawn `dir`: no such file or directory (ENOENT)\nStacktrace!\n.......\n```\n\n----------------------------------------\n\nTITLE: Regenerating Rust FFI Bindings for mmtk-julia - shell\nDESCRIPTION: Explains how to update the Rust FFI bindings when Julia's memory layout changes. Set the JULIA_PATH environment variable to the path of the Julia version being built and run 'make regen-bindgen-ffi' from the binding directory. This will delete and regenerate the FFI bindings using rust-bindgen. The Rust toolchain and rust-bindgen crate are prerequisites for this operation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-mmtk.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nJULIA_PATH=/path/to/julia\nmake regen-bindgen-ffi\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Sampler Type (SamplerDie) in Julia\nDESCRIPTION: Demonstrates defining a custom sampler type `SamplerDie` for a hypothetical `Die` object. This struct subtypes `Sampler{Int}` and holds both the original `Die` object and an underlying sampler (`sp`) created for the range of the die's sides. The `Sampler` constructor initializes `SamplerDie`, and the `rand` method delegates the random number generation to the underlying sampler (`sp.sp`). Assumes the `Die` struct is defined elsewhere.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nimport Random: Sampler, rand\n\nstruct SamplerDie <: Sampler{Int} # generates values of type Int\n    die::Die\n    sp::Sampler{Int} # this is an abstract type, so this could be improved\nend\n\nSampler(RNG::Type{<:AbstractRNG}, die::Die, r::Random.Repetition) =\n    SamplerDie(die, Sampler(RNG, 1:die.nsides, r))\n# the `r` parameter will be explained later on\n\nrand(rng::AbstractRNG, sp::SamplerDie) = rand(rng, sp.sp)\n```\n\n----------------------------------------\n\nTITLE: Comparing `adjoint` Function Behavior\nDESCRIPTION: In Julia, the `adjoint` function (or `'` operator) computes the conjugate transpose. In MATLAB, the `adjoint` function computes the classical adjoint (adjugate matrix).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nadjoint(A) # Julia: Conjugate transpose\n```\n\nLANGUAGE: matlab\nCODE:\n```\nadjoint(A) % MATLAB: Classical adjoint (adjugate)\n```\n\n----------------------------------------\n\nTITLE: Configuring Numbered Prompts on Julia REPL Startup\nDESCRIPTION: Provides the Julia code to be added to the `startup.jl` file to automatically enable numbered input/output prompts (like IPython) every time the REPL starts. It uses `atreplinit` to hook into the REPL initialization process and calls `REPL.numbered_prompt!`.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\natreplinit() do repl\n    @eval import REPL\n    if !isdefined(repl, :interface)\n        repl.interface = REPL.setup_interface(repl)\n    end\n    REPL.numbered_prompt!(repl)\nend\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `@test_approx_eq`: Use `@test isapprox` or `@test x ≈ y` in Julia\nDESCRIPTION: The macro `@test_approx_eq x y` for approximate equality testing is deprecated in Julia. Use `@test isapprox(x, y)` or the convenient infix operator `@test x ≈ y` (where `≈` is typed `\\approx<tab>`) instead.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_195\n\nLANGUAGE: julia\nCODE:\n```\n@test isapprox(x,y)\n```\n\nLANGUAGE: julia\nCODE:\n```\n@test x ≈ y\n```\n\n----------------------------------------\n\nTITLE: Declaring a Safe Printf Function for Signal Handlers in C\nDESCRIPTION: Declares the `jl_safe_printf` C function, designed for printing messages in special contexts like signal handlers where using the full libuv infrastructure might be problematic or too heavy. It writes directly to the standard error file descriptor (`STDERR_FILENO`) using the `write(2)` system call.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/stdio.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nvoid jl_safe_printf(const char *str, ...);\n```\n\n----------------------------------------\n\nTITLE: Searching Documentation with Regex Literal in REPL Help Mode\nDESCRIPTION: Demonstrates using a regular expression literal in Help mode (`help?>`) for documentation searching via `apropos`. Typing `r\"ap..p\"` searches docstrings for patterns matching the regex and lists the results.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nhelp?> r\"ap..p\"\nBase.:∘\nBase.shell_escape_posixly\nDistributed.CachingPool\nREPL.stripmd\nBase.Docs.apropos\n```\n\n----------------------------------------\n\nTITLE: Specifying Start Index for Regex Match in Julia\nDESCRIPTION: Illustrates how to provide an optional third argument to the `match` function to specify the starting index (1-based) for the regular expression search within the target string.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_47\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",1)\nRegexMatch(\"1\")\n\njulia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",6)\nRegexMatch(\"2\")\n\njulia> m = match(r\"[0-9]\",\"aaaa1aaaa2aaaa3\",11)\nRegexMatch(\"3\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Potential Race Condition with SharedArray in Julia\nDESCRIPTION: Illustrates code that can lead to undefined behavior due to a race condition. It uses `@sync` and `Threads.@spawn` to start tasks on all participating workers (`procs(S)`). Each worker attempts to fill the *entire* `SharedArray` `S` with its own process ID (`p`) using `remotecall_wait`. The final value of any element depends on which worker finishes writing last.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\n@sync begin\n    for p in procs(S)\n        Threads.@spawn begin\n            remotecall_wait(fill!, p, S, p)\n        end\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing sub2ind via Recursion (Julia)\nDESCRIPTION: Shows a set of recursive function definitions (sub2ind_rec) for calculating linear indices from n-dimensional indices. These handle the base case, bounds checking, and recursion across the tuple dimensions, matching on types and tuple decomposition. Inputs: dims::Tuple, indices...; Outputs: linear index or BoundsError; Limitations: partial indexing throws an error if out of bounds. No external dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_73\n\nLANGUAGE: julia\nCODE:\n```\nsub2ind_rec(dims::Tuple{}) = 1;\n\nsub2ind_rec(dims::Tuple{}, i1::Integer, I::Integer...) =\n    i1 == 1 ? sub2ind_rec(dims, I...) : throw(BoundsError());\n\nsub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer) = i1;\n\nsub2ind_rec(dims::Tuple{Integer, Vararg{Integer}}, i1::Integer, I::Integer...) =\n    i1 + dims[1] * (sub2ind_rec(Base.tail(dims), I...) - 1);\n\nsub2ind_rec((3, 5), 1, 2)\n4\n```\n\n----------------------------------------\n\nTITLE: Fallback Definition for Wrapper Function in Julia\nDESCRIPTION: Shows the necessary fallback definition for the helper function `g` used in the wrapper pattern. This method `g(x::A) = x` handles cases where the argument is already of the target type `A`, preventing unnecessary work or errors.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_45\n\nLANGUAGE: julia\nCODE:\n```\ng(x::A) = x\n```\n\n----------------------------------------\n\nTITLE: Successful Remote Access to Main Module Globals (Julia)\nDESCRIPTION: Demonstrates that global variables defined directly within the `Main` module (e.g., `gvar_self`) are successfully serialized and accessible on remote workers via `remotecall_fetch`. Unlike globals defined within other modules, `Main` globals are copied to the remote worker's `Main` module, preventing `UndefVarError`. The `varinfo` call confirms the existence of `gvar_self` on worker 2.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_29\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> gvar_self = \"Node1\"\n\"Node1\"\n\njulia> remotecall_fetch(()->gvar_self, 2)\n\"Node1\"\n\njulia> remotecall_fetch(varinfo, 2)\nname          size summary\n––––––––– –––––––– –––––––\nBase               Module\nCore               Module\nMain               Module\ngvar_self 13 bytes String\n```\n\n----------------------------------------\n\nTITLE: Using Qualified Names after `import` in Julia Functions\nDESCRIPTION: Illustrates using `import Foo` outside a function to load a module. This approach makes the module itself available via the variable `Foo`, allowing access to its members within the function `bar` using qualified names (e.g., `Foo.baz`), without importing the member names directly into the function's local scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nimport Foo\nfunction bar(...)\n    # ... refer to Foo bindings via Foo.baz ...\nend\n```\n\n----------------------------------------\n\nTITLE: Machine Code Optimization for Integer Arithmetic in Julia - Julia\nDESCRIPTION: This snippet uses Julia's code_native to reveal the optimized x86_64 machine code produced for a simple arithmetic function f(k) = 5k-1. It demonstrates compiler optimization, yielding a single leaq instruction for the arithmetic operation, contingent on machine integer behavior and associativity. Inputs and outputs are shown at both Julia and assembly levels, requiring only Julia's built-in code_native facility.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\njulia> code_native(f, Tuple{Int})\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 1\n  leaq  -1(%rdi,%rdi,4), %rax\n  popq  %rbp\n  retq\n  nopl  (%rax,%rax)\n```\n\n----------------------------------------\n\nTITLE: Creating Indented Code Blocks in Markdown\nDESCRIPTION: This snippet shows how to create a literal code block in Markdown by indenting the code with four spaces or one tab. This method does not allow specifying the language for syntax highlighting.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nThis is a paragraph.\n\n    function func(x)\n        # ...\n    end\n\nAnother paragraph.\n```\n\n----------------------------------------\n\nTITLE: Generating Julia REPL Banner Programmatically\nDESCRIPTION: This snippet uses Julia's `@eval` macro within the documentation system to programmatically generate and display the standard Julia REPL startup banner. It imports the `REPL` module, captures the banner output into an `IOBuffer`, converts it to a string, and then uses `Markdown.parse` to format it as a code block simulating the REPL startup sequence.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing REPL\nio = IOBuffer()\nREPL.banner(io)\nbanner = String(take!(io))\nimport Markdown\nMarkdown.parse(\"```\\n\\$ julia\\n\\n$(banner)\\njulia>\\n```\")\n```\n\n----------------------------------------\n\nTITLE: Using Parenthesized Julia Generator in Function Argument\nDESCRIPTION: Corrects the previous syntax error by enclosing the multi-dimensional generator expression `(1/(i+j) for i=1:2, j=1:2)` in parentheses. This correctly separates the generator from the subsequent matrix argument `[1 3; 2 4]`, allowing the `map` function to apply the `tuple` function to elements generated by the generator and corresponding elements from the matrix.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_15\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> map(tuple, (1/(i+j) for i=1:2, j=1:2), [1 3; 2 4])\n2×2 Matrix{Tuple{Float64, Int64}}:\n (0.5, 1)       (0.333333, 3)\n (0.333333, 2)  (0.25, 4)\n```\n\n----------------------------------------\n\nTITLE: Allocating New Julia Struct Instances in C\nDESCRIPTION: Declares C functions for allocating new instances of Julia structs. `jl_new_struct` takes the struct type (`jl_datatype_t*`) and a variable number of arguments representing the field values. `jl_new_structv` is similar but takes an array of field values (`args`) and the number of arguments (`na`). Both return a pointer (`jl_value_t*`) to the newly allocated and initialized struct object.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_9\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *jl_new_struct(jl_datatype_t *type, ...);\njl_value_t *jl_new_structv(jl_datatype_t *type, jl_value_t **args, uint32_t na);\n```\n\n----------------------------------------\n\nTITLE: Handling Large Unsigned Literals as `BigInt` in Julia\nDESCRIPTION: Unsigned hexadecimal literals (starting with `0x`) that exceed the maximum value representable by `UInt128` are now automatically interpreted as `BigInt` objects. This avoids overflow errors for very large unsigned constants.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_54\n\nLANGUAGE: julia\nCODE:\n```\nlarge_hex = 0x100000000000000000000000000000000 # This will be a BigInt\ntypeof(large_hex) == BigInt\n```\n\n----------------------------------------\n\nTITLE: Defining Documented Functions and Types for the Julia Mmap Module - Julia\nDESCRIPTION: This snippet uses the Julia documentation macro @docs to reference and generate documentation entries for the Mmap module, specifically targeting 'Mmap.Anonymous', 'Mmap.mmap', and 'Mmap.sync!'. The snippet instructs Julia's documentation system to publish API docs for these items, which are fundamental for file mapping operations. No explicit code implementation is shown; rather, it relies on upstream definitions elsewhere in the source code and is intended for use when building Julia's standard library documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Mmap/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nMmap.Anonymous\nMmap.mmap\nMmap.sync!\n```\n```\n\n----------------------------------------\n\nTITLE: Attaching Debugger to Precompilation Worker (GDB and LLDB Commands)\nDESCRIPTION: Shows how to instruct the debugger to wait for and attach to a worker process named 'julia-debug' for precompilation debugging. This is needed because precompilation runs in separate processes. These commands should be run in the debugger before starting the parent Julia process that spawns workers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_15\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) attach -w -n julia-debug\n```\n\n----------------------------------------\n\nTITLE: Complex Subtype Debugging Example with Parameterized Tuples - Julia\nDESCRIPTION: Uses the mysubtype function to examine a more complex subtype relationship with parameterized tuples. Inputs: Tuple types (including Array and type variable); Outputs: subtype boolean. Helps illustrate the behavior of Julia's subtype algorithm with generic tuple and array types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nmysubtype(Tuple{Array{Int,2}, Int8}, Tuple{Array{T}, T} where T)\n```\n\n----------------------------------------\n\nTITLE: Creating Unordered Lists in Markdown\nDESCRIPTION: This snippet demonstrates creating unordered lists using asterisks (`*`), plus signs (`+`), or hyphens (`-`) as markers. Each item must be preceded by the marker and a space, typically with indentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_16\n\nLANGUAGE: markdown\nCODE:\n```\nA list of items:\n\n  * item one\n  * item two\n  * item three\n```\n\n----------------------------------------\n\nTITLE: Separating Kernel Function for Efficient Array Filling - Julia\nDESCRIPTION: Illustrates separating the setup and computation (function barrier pattern) for type inference and reuse. Defines fill_twos! to fill a supplied array a with 2, then strange_twos constructs a randomly typed array and fills it. Dependencies: Random for randomness. Advantage: Compiler can specialize fill_twos! for the concrete array type, improving efficiency.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nfunction fill_twos!(a)\n    for i = eachindex(a)\n        a[i] = 2\n    end\nend;\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction strange_twos(n)\n    a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n    fill_twos!(a)\n    return a\nend;\n```\n\n----------------------------------------\n\nTITLE: Retrieving Git Commit SHA for a Remote Branch\nDESCRIPTION: This shell command uses Git to retrieve the full commit SHA (hash) of the HEAD of the specified remote branch (`origin/release-x.y`). This SHA is required as the 'Revision' when submitting jobs to the Julia buildbot UI, particularly for building test binaries.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\ngit rev-parse origin/release-x.y\n```\n\n----------------------------------------\n\nTITLE: Using @spawnat with :any for Flexible Task Scheduling - Julia (REPL)\nDESCRIPTION: This snippet illustrates creating and using Futures by scheduling tasks on any available worker process with @spawnat :any. This enables Julia to choose an appropriate worker, demonstrating that the fetch operation is a no-op if the owning process is selected. Inputs involve expressions using random matrix creation and basic arithmetic, and outputs are Futures and resulting matrices. The code relies on the Distributed module and helps demonstrate Julia's automatic task placement.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_3\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> r = @spawnat :any rand(2,2)\nFuture(2, 1, 4, nothing)\n\njulia> s = @spawnat :any 1 .+ fetch(r)\nFuture(3, 1, 5, nothing)\n\njulia> fetch(s)\n2×2 Matrix{Float64}:\n 1.38854  1.9098\n 1.20939  1.57158\n```\n\n----------------------------------------\n\nTITLE: Listing Julia LLVM Interface Documentation Entry\nDESCRIPTION: This snippet employs the `@docs` macro to include the documentation for `Core.Intrinsics.llvmcall` in the generated output. The `llvmcall` intrinsic provides a low-level mechanism to directly invoke LLVM instructions or functions from within Julia code. This is typically used for performance-critical sections or to access specific hardware features not exposed through higher-level Julia abstractions. Using `llvmcall` requires knowledge of LLVM Intermediate Representation (IR).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/c.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCore.Intrinsics.llvmcall\n```\n```\n\n----------------------------------------\n\nTITLE: Computing Integer Midpoints Safely Using Bitwise Shift in Julia - Julia\nDESCRIPTION: This Julia snippet demonstrates computing the midpoint between large integer values using machine arithmetic and bitwise operations, specifically avoiding problems caused by saturation or wrapping in other languages. The calculation handles large integers, such as 2^62 and 2^63, showing Julia's ability to yield correct results in these edge cases. No special libraries besides Julia are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\njulia> n = 2^62\n4611686018427387904\n\njulia> (n + 2n) >>> 1\n6917529027641081856\n```\n\n----------------------------------------\n\nTITLE: Configuring LLVM Version in Julia Build (Bash)\nDESCRIPTION: This snippet demonstrates how to override the default LLVM version used in Julia by editing the Make.user file. By setting the LLVM_VER variable, developers can specify a custom LLVM release when building Julia. This requires access to the top-level Julia source directory and familiarity with make build configuration.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nLLVM_VER = 13.0.0\n```\n\n----------------------------------------\n\nTITLE: Defining Modules with Conflicting Exported Names in Julia\nDESCRIPTION: Sets up a name conflict scenario by defining two distinct modules, `A` and `B`, both of which export a function named `f` but with different implementations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_17\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> module A\n       export f\n       f() = 1\n       end\nA\njulia> module B\n       export f\n       f() = 2\n       end\nB\n```\n\n----------------------------------------\n\nTITLE: Inspecting Nested Exceptions with current_exceptions in Julia\nDESCRIPTION: Shows how to use `current_exceptions()` (available in Julia 1.1+) within nested `try...catch` blocks to access the runtime's exception stack. This allows inspection of multiple exceptions that might occur during error handling. The example demonstrates catching an initial error (A), then triggering another error (B) while handling A, and finally iterating through the exception stack using `current_exceptions()` to display both exceptions and their associated backtraces.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_7\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> try\n           error(\"(A) The root cause\")\n       catch\n           try\n               error(\"(B) An exception while handling the exception\")\n           catch\n               for (exc, bt) in current_exceptions()\n                   showerror(stdout, exc, bt)\n                   println(stdout)\n               end\n           end\n       end\n(A) The root cause\nStacktrace:\n [1] error(::String) at error.jl:33\n [2] top-level scope at REPL[7]:2\n [3] eval(::Module, ::Any) at boot.jl:319\n [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n [5] macro expansion at REPL.jl:117 [inlined]\n [6] (::getfield(REPL, Symbol(\"##26#27\")){REPL.REPLBackend})() at task.jl:259\n(B) An exception while handling the exception\nStacktrace:\n [1] error(::String) at error.jl:33\n [2] top-level scope at REPL[7]:5\n [3] eval(::Module, ::Any) at boot.jl:319\n [4] eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\n [5] macro expansion at REPL.jl:117 [inlined]\n [6] (::getfield(REPL, Symbol(\"##26#27\")){REPL.REPLBackend})() at task.jl:259\n```\n\n----------------------------------------\n\nTITLE: Flat Profile Output of Julia Profiler - Julia\nDESCRIPTION: Demonstrates how to print the profiler's flat-format output, summarizing sample counts irrespective of call nesting. Requires prior profiling runs and that the Profile buffer contains meaningful data. The Profile.print(format=:flat) call outputs a table correlating sample counts, file locations, and function names, aiding in holistic performance assessment. All dependencies are standard Julia library components, with key parameters being the format argument.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_3\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> Profile.print(format=:flat)\n Count File          Line Function\n  6714 ./<missing>     -1 anonymous\n  6714 ./REPL.jl       66 eval_user_input(::Any, ::Base.REPL.REPLBackend)\n  6714 ./REPL.jl       97 macro expansion\n  3821 ./REPL[1]        2 myfunc()\n  2893 ./REPL[1]        3 myfunc()\n  6714 ./REPL[7]        1 macro expansion\n  6714 ./boot.jl      235 eval(::Module, ::Any)\n  3511 ./dSFMT.jl      84 dsfmt_fill_array_close_open!(::Base.dSFMT.DSFMT_s...\n  6714 ./event.jl      73 (::Base.REPL.##1#2{Base.REPL.REPLBackend})()\n  6714 ./profile.jl    23 macro expansion\n  3511 ./random.jl    431 rand!(::MersenneTwister, ::Array{Float64,3}, ::In...\n   310 ./random.jl    277 rand\n   310 ./random.jl    278 rand\n   310 ./random.jl    366 rand\n   310 ./random.jl    369 rand\n  2893 ./reduce.jl    270 _mapreduce(::Base.#identity, ::Base.#scalarmax, :...\n     5 ./reduce.jl    420 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n   253 ./reduce.jl    426 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n  2592 ./reduce.jl    428 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n    43 ./reduce.jl    429 mapreduce_impl(::Base.#identity, ::Base.#scalarma...\n```\n\n----------------------------------------\n\nTITLE: Running Escape Analysis with EAUtils.jl in Julia\nDESCRIPTION: This snippet demonstrates how to set up and use the `EAUtils.jl` utility script to perform escape analysis on a sample Julia function. It defines a mutable struct `SafeRef` and related methods, then defines an anonymous function that uses `Ref`, `SafeRef`, and a `try-catch` block. The `code_escapes` function is called to analyze potential escapes, including escapes via exceptions assigned to global variables.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@repl EAUtils\n# InteractiveUtils.@activate Compiler # to use the stdlib version of the Compiler\n\nlet JULIA_DIR = normpath(Sys.BINDIR, \"..\", \"share\", \"julia\")\n    include(normpath(JULIA_DIR, \"Compiler\", \"test\", \"EAUtils.jl\"))\n    using .EAUtils\nend\n\nmutable struct SafeRef{T}\n    x::T\nend\nBase.getindex(x::SafeRef) = x.x;\nBase.setindex!(x::SafeRef, v) = x.x = v;\nBase.isassigned(x::SafeRef) = true;\nget′(x) = isassigned(x) ? x[] : throw(x);\n\nresult = code_escapes((Base.RefValue{String},String,String,)) do r1, s2, s3\n    r2 = Ref(s2)\n    r3 = SafeRef(s3)\n    try\n        s1 = get′(r1)\n        ret = sizeof(s1)\n    catch err\n        global GV = err # `r1` may escape\n    end\n    s2 = get′(r2)       # `r2` doesn't escape\n    s3 = get′(r3)       # `r3` doesn't escape\n    return s2, s3, s4\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Mounting and Verifying macOS .dmg Code Signature - Shell\nDESCRIPTION: This shell snippet mounts a Julia .dmg file read-only, verifies the code signature of the Julia app bundle within, and then ejects the disk image and cleans up. It requires the macOS utilities hdiutil and codesign, and assumes the .dmg and related files are present in the working directory. The main parameters are the .dmg file name (mount source) and the mount point directory. Successful verification returns no output; failure requires further action.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\nmkdir ./jlmnt\\nhdiutil mount -readonly -mountpoint ./jlmnt julia-x.y.z-osx.dmg\\ncodesign -v jlmnt/Julia-x.y.app\n```\n\n----------------------------------------\n\nTITLE: Standard Unicode Codepoint Representation in Julia `display`\nDESCRIPTION: Shows the standard-conforming `\"U+XXXX\"` format used for displaying the codepoint value of a `Char` type during verbose `display` (e.g., `text/plain` output) in Julia v1.4.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_93\n\nLANGUAGE: text\nCODE:\n```\n\"U+XXXX\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating Problematic Conditional Local Method Definitions in Julia\nDESCRIPTION: This Julia code snippet highlights incorrect ways to define methods within a local scope. Function `f2` attempts to define method `g` conditionally using `if/else`, and `f3` defines `g` after a `return` statement. Both practices are discouraged as the behavior is ill-defined and may become an error in future Julia versions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_54\n\nLANGUAGE: julia\nCODE:\n```\nfunction f2(inc)\n    if inc\n        g(x) = x + 1\n    else\n        g(x) = x - 1\n    end\nend\n\nfunction f3()\n    function g end\n    return g\n    g() = 0\nend\n```\n\n----------------------------------------\n\nTITLE: Comparing Implicit Return vs. Explicit 'return' in Julia REPL\nDESCRIPTION: This REPL session compares two functions defined earlier: `f` uses implicit return (returning the value of the last expression, `x + y`), while `g` uses an explicit `return x * y`. Calling both with `(2, 3)` shows the different outcomes: `f` returns `5`, and `g` returns `6`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_9\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> f(x, y) = x + y\nf (generic function with 1 method)\n\njulia> function g(x, y)\n           return x * y\n           x + y\n       end\ng (generic function with 1 method)\n\njulia> f(2, 3)\n5\n\njulia> g(2, 3)\n6\n```\n\n----------------------------------------\n\nTITLE: Testing Approximate Equality (Failing) in Julia\nDESCRIPTION: Shows a failing test using the `≈` operator (`isapprox`) in Julia. The value 0.999999 is outside the default tolerance for being approximately equal to 1, causing the test to fail.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> @test 1 ≈ 0.999999\nTest Failed at none:1\n  Expression: 1 ≈ 0.999999\n\nERROR: There was an error during testing\n```\n\n----------------------------------------\n\nTITLE: Handling `missing` with Logical AND (`&`) - Propagation Case in Julia\nDESCRIPTION: Illustrates the propagation of `missing` with the logical AND operator (`&`) when one operand is `true`. The result depends on the unknown value represented by `missing`, so the overall result is `missing`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/missing.md#_snippet_7\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> true & true\ntrue\n\njulia> true & false\nfalse\n\njulia> true & missing\nmissing\n```\n\n----------------------------------------\n\nTITLE: Loading Code on All Julia Processes using @everywhere include\nDESCRIPTION: Demonstrates using the `@everywhere` macro combined with `include(\"DummyModule.jl\")` to ensure the module definition from the specified file is loaded on the master process and all worker processes. The output confirms loading on workers 2 and 3. Requires Julia to be started with multiple processes (e.g., `julia -p 2`) and the file `DummyModule.jl` to exist.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_6\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @everywhere include(\"DummyModule.jl\")\nloaded\n      From worker 3:    loaded\n      From worker 2:    loaded\n```\n\n----------------------------------------\n\nTITLE: Safely Parsing TOML with Error Details in Julia\nDESCRIPTION: Shows how to use `TOML.tryparse` to attempt parsing TOML data without throwing an exception on syntax errors. If parsing fails, it returns a `TOML.ParserError` object containing details like the error type, line number, and column number.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/TOML/docs/src/index.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> using TOML\n\njulia> err = TOML.tryparse(\"\"\"\n           value = 0.0.0\n       \"\"\"\n);\n\njulia> err.type\nErrGenericValueError::ErrorType = 14\n\njulia> err.line\n1\n\njulia> err.column\n16\n```\n\n----------------------------------------\n\nTITLE: Result after Parallel @threads Write - Julia\nDESCRIPTION: Displays the output of the array after a parallel @threads execution, illustrating which thread wrote to which locations. Makes evident how workload is partitioned among threads. No inputs required; output is the current state of 'a'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_13\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> a\n10-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 2.0\n 2.0\n 2.0\n 3.0\n 3.0\n 4.0\n 4.0\n```\n\n----------------------------------------\n\nTITLE: Constructing Literal Zero and One for Arbitrary Types in Julia\nDESCRIPTION: Shows the use of zero(x) and one(x) functions to obtain values of literal 0 and 1 matching either a specified type or the type of a value, important for type-generic numeric programming. No dependencies beyond Julia Base. Inputs can be either types or example values; outputs are literal zero and one of the same type. This avoids explicit casting and preserves type correctness, vital in mathematical code that supports multiple numeric types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\njulia> zero(Float32)\n0.0f0\n\njulia> zero(1.0)\n0.0\n\njulia> one(Int32)\n1\n\njulia> one(BigFloat)\n1.0\n```\n\n----------------------------------------\n\nTITLE: Structuring the Main Test Runner runtests.jl in Julia\nDESCRIPTION: Presents the content of the main test runner script `test/runtests.jl`. It imports the package being tested (`Example`) and the `Test` library. It defines a top-level testset (`Example tests`) and uses nested `@testset` blocks to group tests logically (`Math tests`, `Greeting tests`), including separate files (`math_tests.jl`, `greeting_tests.jl`) for better organization.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nusing Example\nusing Test\n\n@testset \"Example tests\" begin\n\n    @testset \"Math tests\" begin\n        include(\"math_tests.jl\")\n    end\n\n    @testset \"Greeting tests\" begin\n        include(\"greeting_tests.jl\")\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Methods for a Generic Function with Union Types - Julia\nDESCRIPTION: Illustrates how Julia allows method definitions for union types, enabling a single anonymous function to handle multiple specific concrete parametric types. This method allows calls like f(::Foo{Int}, x) and f(::Foo{Int8}, x) to dispatch to the same body, as both types are associated with the same method table due to sharing the same TypeName. No explicit dependencies beyond Julia's standard type system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n(::Union{Foo{Int},Foo{Int8}})(x) = 0\n```\n\n----------------------------------------\n\nTITLE: Executing a Function within a Dynamic Scope using `with` in Julia\nDESCRIPTION: Demonstrates using the `with` function to execute a call `f(10)` within a dynamic scope where the `ScopedValue` `a` is set to `2`. This requires wrapping the function call in a zero-argument anonymous function `() -> f(10)`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nwith(() -> f(10), a=>2)\n```\n\n----------------------------------------\n\nTITLE: Lack of Automatic Synchronization for Global Variables Across Julia Workers\nDESCRIPTION: This code demonstrates that global variables in `Main` are not automatically synchronized across workers. First, `A`'s value is sent to worker 2. Then `A` is reassigned locally to a new random matrix. Subsequently, `A`'s *new* value is sent to worker 3. Finally, `A` is set to `nothing` locally. This results in `Main.A` having different values on process 1 (`nothing`), worker 2 (the first matrix), and worker 3 (the second matrix).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nA = rand(10,10)\nremotecall_fetch(()->sum(A), 2) # worker 2\nA = rand(10,10)\nremotecall_fetch(()->sum(A), 3) # worker 3\nA = nothing\n```\n\n----------------------------------------\n\nTITLE: Running a Julia Script from the Shell\nDESCRIPTION: This shell command shows how to execute a Julia script (e.g., script.jl) non-interactively by invoking the julia executable from the command line. The user supplies the script file as an argument to julia, and can pass additional arguments as needed. This run mode is useful for automating Julia computations and integrating with other shell-based workflows.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/getting-started.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ julia script.jl\n```\n\n----------------------------------------\n\nTITLE: Entering and Using REPL Help Mode in Julia\nDESCRIPTION: This example demonstrates how to enter the REPL's Help mode by typing `?` at the beginning of an empty line in the Julian prompt. Once in Help mode (`help?>`), typing a function name like `string` provides documentation and related search results.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> ? # upon typing ?, the prompt changes (in place) to: help?>\n\nhelp?> string\nsearch: string String Cstring Cwstring RevString randstring bytestring SubString\n\n  string(xs...)\n\n  Create a string from any values using the print function.\n```\n\n----------------------------------------\n\nTITLE: Passing Julia Arrays to C Functions via @ccall - Julia\nDESCRIPTION: This code wraps a C function (gsl_sf_bessel_Jn_array) that takes a Julia array as an output parameter. It sets up size and input arguments, allocates a result array, invokes the C wrapper with appropriate type translations, checks for C-level errors, and returns the populated Julia array. Requires the \"libgsl\" library and expects nmin, nmax, and x as integer and real inputs. Outputs a Vector{Cdouble} with Bessel function results or throws on error.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\n# The corresponding C signature is\n#    int gsl_sf_bessel_Jn_array (int nmin, int nmax, double x,\n#                                double result_array[])\nfunction sf_bessel_Jn_array(nmin::Integer, nmax::Integer, x::Real)\n    if nmax < nmin\n        throw(DomainError())\n    end\n    result_array = Vector{Cdouble}(undef, nmax - nmin + 1)\n    errorcode = @ccall \"libgsl\".gsl_sf_bessel_Jn_array(\n                    nmin::Cint, nmax::Cint, x::Cdouble, result_array::Ref{Cdouble})::Cint\n    if errorcode != 0\n        error(\"GSL error code $errorcode\")\n    end\n    return result_array\nend\n```\n\n----------------------------------------\n\nTITLE: Protecting Containers from Broadcasting in Julia\nDESCRIPTION: Demonstrates how to prevent a container (like an array) from being iterated over during a broadcasting operation by wrapping it in another container, such as a single-element `Tuple`. This causes the broadcast mechanism to treat the wrapped container as a single scalar value. Both literal tuple syntax `(...,)` and the `tuple()` function achieve this.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_41\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> ([1, 2, 3], [4, 5, 6]) .+ ([1, 2, 3],)\n([2, 4, 6], [5, 7, 9])\n\njulia> ([1, 2, 3], [4, 5, 6]) .+ tuple([1, 2, 3])\n([2, 4, 6], [5, 7, 9])\n```\n\n----------------------------------------\n\nTITLE: Creating and Instantiating Custom Parametric Types in Julia - Julia\nDESCRIPTION: This snippet defines a custom parametric type `MyType{T,N}` and demonstrates concrete instantiations using different type parameters. It shows how Julia caches and displays parametric type instances. Inputs are type and value parameters; the output is the instantiated parametric type objects. Only Julia base is required for this functionality.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> struct MyType{T,N} end\n\njulia> MyType{Int,2}\nMyType{Int64, 2}\n\njulia> MyType{Float32, 5}\nMyType{Float32, 5}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Linear Indexing Mechanics in Julia Arrays\nDESCRIPTION: This snippet shows that providing a single integer index to a matrix accesses the element in column-major order. It creates a 2D matrix, accesses via linear index, and compares with a vectorized view. Built into Julia Base with no external dependencies. Inputs are the matrix and linear index; outputs are scalars. Only works for arrays with column-major storage.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\njulia> A = [2 6; 4 7; 3 1]\n3×2 Matrix{Int64}:\n 2  6\n 4  7\n 3  1\n\njulia> A[5]\n7\n\njulia> vec(A)[5]\n7\n```\n\n----------------------------------------\n\nTITLE: Randomly Choosing Array Element Type and Filling - Julia\nDESCRIPTION: Shows how constructing arrays with randomly chosen element types (Int64 or Float64) and filling them in a single function can hinder performance due to lack of type inference. Defines strange_twos which picks the array type randomly and fills all entries with 2. Uses Random module and randomness in type selection.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nfunction strange_twos(n)\n    a = Vector{rand(Bool) ? Int64 : Float64}(undef, n)\n    for i = 1:n\n        a[i] = 2\n    end\n    return a\nend;\n```\n\n----------------------------------------\n\nTITLE: Finding the First Regex Match with match in Julia\nDESCRIPTION: Explains how to use the `match` function to find the first occurrence of a regular expression pattern within a string. It returns a `RegexMatch` object if a match is found, containing details about the match, or `nothing` if no match is found.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_44\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> match(r\"^\\s*(?:#|$)\", \"not a comment\")\n\njulia> match(r\"^\\s*(?:#|$)\", \"# a comment\")\nRegexMatch(\"#\")\n```\n\n----------------------------------------\n\nTITLE: `InetAddr` Constructor from String and Integer in Julia\nDESCRIPTION: A new constructor for `InetAddr` allows creating an instance directly from an IP address string (e.g., \"127.0.0.1\") and an integer port number.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_143\n\nLANGUAGE: julia\nCODE:\n```\nusing Sockets\naddr = Sockets.InetAddr(\"192.168.1.100\", 8080)\n```\n\n----------------------------------------\n\nTITLE: Updating Package Lists Inside Docker Container - Shell - Shell\nDESCRIPTION: Runs 'apt update' as root to refresh package lists inside the previously launched Ubuntu container. This prepares the environment to install build tools and dependencies for compiling Julia. The command assumes the user is root (no sudo needed) and there are no additional parameters; it must be executed at the command prompt inside the container.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_23\n\nLANGUAGE: sh\nCODE:\n```\n# apt update\n```\n\n----------------------------------------\n\nTITLE: Defining an Adder with Closures - Julia\nDESCRIPTION: This high-level Julia function demonstrates closure creation, returning a new function that captures its surrounding variable 'x'. The returned anonymous function adds its input 'y' to the captured 'x'. The code shows idiomatic functional programming in Julia. There are no external dependencies except Julia's core language features.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nfunction adder(x)\n    return y->x+y\nend\n```\n\n----------------------------------------\n\nTITLE: Requesting Documentation for FileWatching Functions (Julia)\nDESCRIPTION: Uses the Documenter.jl `@docs` macro to request the inclusion of documentation for specific file event monitoring functions (`poll_fd`, `poll_file`, `watch_file`, `watch_folder`, `unwatch_folder`) from the Julia standard library.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/FileWatching/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n@docs\npoll_fd\npoll_file\nwatch_file\nwatch_folder\nunwatch_folder\n```\n\n----------------------------------------\n\nTITLE: Defining Footnote Content in Markdown\nDESCRIPTION: This snippet shows the syntax for defining the content of footnotes previously referenced using `[^name]` or `[^N]`. The definition starts with the reference label followed by a colon (`:`), and the content follows. Multi-paragraph or complex content requires indentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_20\n\nLANGUAGE: markdown\nCODE:\n```\n[^1]: Numbered footnote text.\n\n[^note]:\n\n    Named footnote text containing several toplevel elements\n    indented by 4 spaces or one tab.\n\n      * item one\n      * item two\n      * item three\n\n    ```julia\n    function func(x)\n        # ...\n    end\n    ```\n```\n\n----------------------------------------\n\nTITLE: Destructuring RegexMatch Captures in Julia\nDESCRIPTION: Demonstrates that `RegexMatch` objects are iterable (iterating over captures) and can be used directly in destructuring assignments to bind captured substrings to local variables. Depends on the `m` variable assigned in the previous snippet.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_49\n\nLANGUAGE: jldoctest acdmatch\nCODE:\n```\njulia> first, second, third = m; first\n\"a\"\n```\n\n----------------------------------------\n\nTITLE: Finding First and Last Character Occurrences using findfirst/findlast in Julia\nDESCRIPTION: Shows how to use the `findfirst(char, string)` and `findlast(char, string)` functions to get the byte index of the first or last occurrence of a specific character within a string. Returns `nothing` if the character is not found.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_38\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> findfirst('o', \"xylophone\")\n4\n\njulia> findlast('o', \"xylophone\")\n7\n\njulia> findfirst('z', \"xylophone\")\n```\n\n----------------------------------------\n\nTITLE: Deprecated Empty Block Syntax in Julia\nDESCRIPTION: Illustrates the deprecated syntax `(;)`, which previously parsed as an empty block expression. This syntax is planned to represent an empty named tuple in future Julia versions.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_85\n\nLANGUAGE: julia\nCODE:\n```\n(;)\n```\n\n----------------------------------------\n\nTITLE: Listing Network I/O Functions in Julia Base\nDESCRIPTION: This snippet lists functions from Julia's Base module relevant to network input/output operations using the `@docs` macro. It primarily focuses on checking available bytes (`bytesavailable`) and handling byte order conversions (endianness) between network and host representations (`ntoh`, `hton`, `ltoh`, `htol`), along with the `ENDIAN_BOM` constant.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/io-network.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.bytesavailable\nBase.ntoh\nBase.hton\nBase.ltoh\nBase.htol\nBase.ENDIAN_BOM\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a Delayed Finalizer with Locking in Julia\nDESCRIPTION: This Julia function `finalize_ref` demonstrates a strategy for safely handling finalization for `AbstractRemoteRef` objects. It attempts to acquire the `client_refs` lock using `trylock`. If the lock is already held or cannot be acquired immediately (to prevent potential recursion or blocking within the finalizer), it reschedules the same finalizer function to run again later. If the lock is acquired successfully, it re-checks the finalization condition (`r.where > 0`) inside a `try...finally` block to ensure the lock is always released, performs the necessary cleanup (setting `r.where = 0`), and then releases the lock.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nfunction finalize_ref(r::AbstractRemoteRef)\n    if r.where > 0 # Check if the finalizer is already run\n        if islocked(client_refs) || !trylock(client_refs)\n            # delay finalizer for later if we aren't free to acquire the lock\n            finalizer(finalize_ref, r)\n            return nothing\n        end\n        try # `lock` should always be followed by `try`\n            if r.where > 0 # Must check again here\n                # Do actual cleanup here\n                r.where = 0\n            end\n        finally\n            unlock(client_refs)\n        end\n    end\n    nothing\nend\n```\n\n----------------------------------------\n\nTITLE: Defining an Outer Constructor for a Julia Struct (Single Argument)\nDESCRIPTION: Defines an outer constructor method for the `Foo` struct that takes a single argument `x` and calls the default two-argument constructor, setting both `bar` and `baz` fields to `x`. Includes an example call demonstrating its usage.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_1\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Foo(x) = Foo(x,x)\nFoo\n\njulia> Foo(1)\nFoo(1, 1)\n```\n\n----------------------------------------\n\nTITLE: Deprecating Direct Boolean Indexing - Julia\nDESCRIPTION: Deprecated using Boolean values as indices; now, explicit conversion to Int is required, e.g., accessing index 1 for true and 0 for false. While no code is included, recommended practice is int(bool_value).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_162\n\n\n\n----------------------------------------\n\nTITLE: Propagating GC Rooting with JL_PROPAGATES_ROOT - Julia GC Static Analyzer - C\nDESCRIPTION: This code snippet illustrates the JL_PROPAGATES_ROOT annotation, which signals that a function propagates GC rooting from an argument to its return value. In this example, the safepoint after obtaining the value is safe due to rooting propagation. Dependencies include Julia value types and proper analyzer annotation macros.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-sa.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *jl_svecref(jl_svec_t *t JL_PROPAGATES_ROOT, size_t i) JL_NOTSAFEPOINT;\n\nsize_t example(jl_svec_t *svec) {\n  jl_value_t *val = jl_svecref(svec, 1)\n  // This is valid, because, as annotated by the PROPAGATES_ROOT annotation,\n  // jl_svecref propagates the rooted-ness from `svec` to `val`\n  jl_gc_safepoint();\n  return jl_unbox_long(val);\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Reflection and Introspection Tools\nDESCRIPTION: This block uses the `@docs` directive to list functions and macros for reflection and introspection in Julia code. This covers querying module information (`nameof`, `parentmodule`, `pathof`), source location (`__module__`, `__source__`, `@__FILE__`, `@__LINE__`), function properties (`nameof`, `functionloc`), listing names (`names`, `isexported`), accessing local variables (`@locals`), and manipulating global variables (`getglobal`, `setglobal!`, etc.).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.nameof(::Module)\nBase.parentmodule\nBase.pathof(::Module)\nBase.pkgdir(::Module)\nBase.pkgversion(::Module)\nBase.moduleroot\n__module__\n__source__\nBase.@__MODULE__\nBase.@__FILE__\nBase.@__DIR__\nBase.@__LINE__\nBase.fullname\nBase.names\nBase.isexported\nBase.ispublic\nBase.nameof(::Function)\nBase.functionloc(::Any, ::Any)\nBase.functionloc(::Method)\nBase.@locals\nCore.getglobal\nCore.setglobal!\nCore.modifyglobal!\nCore.swapglobal!\nCore.setglobalonce!\nCore.replaceglobal!\n```\n```\n\n----------------------------------------\n\nTITLE: Default axes(A, d) Implementation for AbstractArrays - Julia\nDESCRIPTION: This code provides a default method for retrieving the valid index range for a given dimension 'd' of an AbstractArray by accessing the corresponding element from the 'axes' tuple. If 'd' exceeds the array's dimensions, it returns 'OneTo(1)', signaling a degenerate (singleton) dimension. Use when writing AbstractArray subtypes not needing specialized behavior for axes fallback. Parameters: 'A', any AbstractArray; 'd', integer dimension index. Returns an AbstractUnitRange. Required: correct 'axes(A)' method, relies on standard tuple access.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/offset-arrays.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\naxes(A::AbstractArray{T,N}, d) where {T,N} = d <= N ? axes(A)[d] : OneTo(1)\n```\n\n----------------------------------------\n\nTITLE: Handling Escapes in Raw String Literals in Julia\nDESCRIPTION: Illustrates the behavior of raw string literals (`raw\"...\"`) in Julia, where most characters, including backslashes, are interpreted literally. The exception is that a backslash immediately preceding a double quote (`\\\"`) escapes the quote, and a backslash preceding another backslash that is itself before a quote (`\\\\\"`) escapes the second backslash.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_62\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> println(raw\"\\\\ \\\\\"\" )\n\\\\ \\\"\n```\n\n----------------------------------------\n\nTITLE: Destructuring Collections with `...` Spread on LHS in Julia\nDESCRIPTION: The splat operator `...` can now be used on the left-hand side (LHS) of an assignment to capture the remaining elements of an iterable collection after assigning initial elements. This functionality relies on the `Base.rest` function, which can be overloaded for custom collection types.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_55\n\nLANGUAGE: julia\nCODE:\n```\na, b... = [1, 2, 3] # a gets 1, b gets [2, 3]\nfirst, second, rest... = (10, 20, 30, 40) # first=10, second=20, rest=(30, 40)\n```\n\n----------------------------------------\n\nTITLE: Documenting sum Function with Default Arguments - Julia - Julia\nDESCRIPTION: This snippet provides a Julia docstring template for the sum function, demonstrating the documentation of a function signature with an optional init parameter. It presents the recommended four-space indentation, a minimal example of a function header for documentation, and uses Julia markdown syntax. The input is the docstring definition; no actual function logic is provided.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\n   sum(itr; [init])\n\n...\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating Memory Layout of a Boxed uint16_t in C\nDESCRIPTION: Provides a C struct representation illustrating the memory layout of a boxed `uint16_t` Julia value. It shows the `opaque metadata` followed by the `jl_value_t` struct which, in this specific case, directly contains the `uint16_t data`. This demonstrates how primitive types are wrapped with metadata when represented as heap-allocated Julia objects.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nstruct {\n    opaque metadata;\n    struct {\n        uint16_t data;        // -- 2 bytes\n    } jl_value_t;\n};\n```\n\n----------------------------------------\n\nTITLE: Resolving Name Conflicts Using `using` and `as` in Julia\nDESCRIPTION: Shows a method for resolving name conflicts by selectively importing identifiers with renaming. `using .A: f as f` imports `A.f` as `f`, while `using .B: f as g` imports `B.f` as `g`, allowing both functions to be used unambiguously.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_19\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using .A: f as f\n\njulia> using .B: f as g\n\n```\n\n----------------------------------------\n\nTITLE: Embedding Images in Markdown\nDESCRIPTION: This snippet shows the Markdown syntax for embedding images. It's similar to the link syntax but prepended with an exclamation mark (`!`). The text in square brackets is the alternative text.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_15\n\nLANGUAGE: markdown\nCODE:\n```\n![alternative text](link/to/image.png)\n```\n\n----------------------------------------\n\nTITLE: Using `end` Keyword for Indexing a Custom Type in Julia\nDESCRIPTION: Shows an example of using the `end` keyword to access the last element of a `Squares` object, leveraging the previously defined `lastindex` method.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_11\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Squares(23)[end]\n529\n```\n\n----------------------------------------\n\nTITLE: Setting Specific CPU Microarchitecture in Julia Build (Makefile)\nDESCRIPTION: Specifies the target CPU microarchitecture for optimization during the Julia build by setting the `MARCH` variable in `Make.user`. Examples include `pentium4` for older CPUs (requiring specific 32-bit libraries) or `native` for maximum optimization tailored to the build host's CPU.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_4\n\nLANGUAGE: Makefile\nCODE:\n```\nMARCH=pentium4\n```\n\nLANGUAGE: Makefile\nCODE:\n```\nMARCH=native\n```\n\n----------------------------------------\n\nTITLE: New `raw\"...\"` Nonstandard String Literal in Julia\nDESCRIPTION: Introduces a new nonstandard string literal syntax `raw\"...\"` in Julia. This literal creates strings without performing any interpolation or unescaping of characters within the quotes.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_171\n\nLANGUAGE: julia\nCODE:\n```\nraw\"...\"\n```\n\n----------------------------------------\n\nTITLE: Restarting Swapfile Service using Shell Commands\nDESCRIPTION: Provides the shell commands to stop and then start the `dphys-swapfile` service. This is necessary to apply the changes made to the swap file size configuration (e.g., in `/etc/dphys-swapfile`). Requires `sudo` privileges.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/arm.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nsudo /etc/init.d/dphys-swapfile stop\nsudo /etc/init.d/dphys-swapfile start\n```\n\n----------------------------------------\n\nTITLE: Defining Docstring Links for Printf Module in Julia\nDESCRIPTION: This snippet uses the Julia documentation system to register four core functions and macros from the Printf module (@printf, @sprintf, Format, and format) for docstring indexing. It enables these items to be cross-referenced and displayed in generated documentation, aiding users in locating relevant API information. There are no direct dependencies, but it presumes the file is processed in a Julia documentation build context, and that the Printf module is available.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Printf/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nPrintf.@printf\nPrintf.@sprintf\nPrintf.Format\nPrintf.format\n```\n```\n\n----------------------------------------\n\nTITLE: New `UpperHessenberg` Matrix Type in Julia\nDESCRIPTION: A new matrix type `UpperHessenberg` has been added to the `LinearAlgebra` module for representing upper Hessenberg matrices.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_134\n\nLANGUAGE: julia\nCODE:\n```\nusing LinearAlgebra\n# U = UpperHessenberg(matrix_data)\n```\n\n----------------------------------------\n\nTITLE: Documenting Functions with Docstrings – Julia\nDESCRIPTION: This snippet shows Julia's docstring syntax, where a string literal placed immediately before a function definition \"attaches\" documentation to the function. When parsed, this code transforms into a macro call that associates the string as documentation with the function definition for tooling and introspection. Useful for module and library authors providing inline documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ast.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n\"some docs\"\nf(x) = x\n```\n\n----------------------------------------\n\nTITLE: Switching Threads in GDB for Julia Debugging\nDESCRIPTION: Switches the GDB debugging context to a specific thread identified by its thread number (`<threadno>`). Use this command after `info threads` to select the correct thread if GDB is not showing the desired backtrace, allowing focused debugging on the relevant Julia execution.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/windows.md#_snippet_1\n\nLANGUAGE: gdb\nCODE:\n```\nthread <threadno>\n```\n\n----------------------------------------\n\nTITLE: Programmatically Adding Worker Processes in Julia\nDESCRIPTION: Shows how to add two new worker processes to the current Julia session programmatically. It requires explicitly loading the `Distributed` module first using `using Distributed`. The `addprocs(2)` function call initiates the workers, and it returns a vector containing the process IDs (pids) of the newly added workers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_10\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Distributed\n\njulia> addprocs(2)\n2-element Vector{Int64}:\n 2\n 3\n```\n\n----------------------------------------\n\nTITLE: Inverting with Integer Literal Exponents - Julia\nDESCRIPTION: Demonstrates the new behavior in Julia where integer literal negative powers, such as 'x^-1', are type-stable and equivalent to 'inv(x)'. This applies only when 'n' is an integer literal; for symbolic values, the interpretation may differ. Inputs are any types that implement 'inv', outputs depend on the type of 'x'.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_148\n\nLANGUAGE: julia\nCODE:\n```\nx^-1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Finite Floating-Point Arithmetic and NaN Behavior (Julia)\nDESCRIPTION: Illustrates the creation and propagation of special values such as positive and negative infinity (Inf, -Inf) and Not a Number (NaN), and shows the results of arithmetic with these values. It also exemplifies how comparisons involving NaN yield counter-intuitive Boolean results in compliance with IEEE 754. No external packages needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1/Inf\n0.0\n\njulia> 1/0\nInf\n\njulia> -5/0\n-Inf\n\njulia> 0.000001/0\nInf\n\njulia> 0/0\nNaN\n\njulia> 500 + Inf\nInf\n\njulia> 500 - Inf\n-Inf\n\njulia> Inf + Inf\nInf\n\njulia> Inf - Inf\nNaN\n\njulia> Inf * Inf\nInf\n\njulia> Inf / Inf\nNaN\n\njulia> 0 * Inf\nNaN\n\njulia> NaN == NaN\nfalse\n\njulia> NaN != NaN\ntrue\n\njulia> NaN < NaN\nfalse\n\njulia> NaN > NaN\nfalse\n```\n\n----------------------------------------\n\nTITLE: Documenting the Logging Module (Julia Docs)\nDESCRIPTION: A directive for Julia's documentation generator (Documenter.jl) to include the documentation for the `Logging.Logging` module itself at this location in the generated output.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Logging/docs/src/index.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nLogging.Logging\n```\n\n----------------------------------------\n\nTITLE: Result of Exponentiating UniformScaling Objects in Julia\nDESCRIPTION: Represents the result of exponentiating a `UniformScaling` object `(a*I)^x` in Julia's LinearAlgebra module, which simplifies to `a^x * I`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_98\n\nLANGUAGE: julia\nCODE:\n```\na^x * I\n```\n\n----------------------------------------\n\nTITLE: Restoring Old Regular Expression Behavior - Julia\nDESCRIPTION: This snippet illustrates using the 'a' modifier in a regular expression to revert to non-Unicode (ASCII-based) matching in Julia. This is relevant after the default was changed to UCP (Unicode Character Properties) mode. Input is a string to be matched; output is a match object or array of matches. Limitations: older 'r\"\\w+\"' now matches more Unicode characters; to only match ASCII word characters, use 'a' as in this example.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_147\n\nLANGUAGE: julia\nCODE:\n```\nr\"\\w+\"a\n```\n\n----------------------------------------\n\nTITLE: Configuring Thread Pools via Environment Variable - Bash\nDESCRIPTION: Shows how to use the JULIA_NUM_THREADS environment variable to set the number of threads for the default and interactive threadpools before Julia starts. Uses a comma-separated format for multiple pools. No dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nexport JULIA_NUM_THREADS=3,1\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple Functions and Mapping in Julia\nDESCRIPTION: Illustrates composing three functions (`first`, `reverse`, `uppercase`) using the `∘` operator and applying the composed function to each element of a string array using `map`. The expression processes each word by converting it to uppercase, reversing it, and taking the first character.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_35\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> map(first ∘ reverse ∘ uppercase, split(\"you can compose functions like this\"))\n6-element Vector{Char}:\n 'U': ASCII/Unicode U+0055 (category Lu: Letter, uppercase)\n 'N': ASCII/Unicode U+004E (category Lu: Letter, uppercase)\n 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n 'E': ASCII/Unicode U+0045 (category Lu: Letter, uppercase)\n 'S': ASCII/Unicode U+0053 (category Lu: Letter, uppercase)\n```\n\n----------------------------------------\n\nTITLE: Installing Build Dependencies on Debian/Ubuntu using apt-get\nDESCRIPTION: This command uses `apt-get` on Debian-based Linux distributions like Ubuntu to install the essential build tools and libraries required to compile Julia from source. It requires root privileges (`sudo`) to execute.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install build-essential libatomic1 python gfortran perl wget m4 cmake pkg-config curl\n```\n\n----------------------------------------\n\nTITLE: Temporarily Extending PATH Environment Variable (csh/tcsh)\nDESCRIPTION: Shows how to add the current working directory of Julia to the shell executable path in csh or tcsh shells. This allows the user to invoke 'julia' from anywhere for the current session.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_6\n\nLANGUAGE: csh\nCODE:\n```\nset path= ( $path $cwd )\n\n```\n\n----------------------------------------\n\nTITLE: Deprecation of Vectorized Functions: Use Dot Syntax in Julia\nDESCRIPTION: Pre-defined vectorized functions (often ending in `!` or operating element-wise by convention without explicit syntax) are deprecated in Julia. Use the dot syntax (`.`) for element-wise operations (broadcasting) instead, e.g., `x .+ y` instead of a hypothetical `add_vectors(x, y)`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_197\n\nLANGUAGE: julia\nCODE:\n```\nf.(args...)\n```\n\n----------------------------------------\n\nTITLE: Creating and Updating Local Variables in a For Loop Within a Function - Julia\nDESCRIPTION: The sum_to function defines a new local variable s and updates it within a for loop, showing that variable assignment in an inner local scope always refers to the existing local unless explicitly shadowed. Standard Julia base functions are used. Parameter n controls the upper bound of summation, and the function accumulates values in s as a running total, then returns the result. Global s is shown to be undefined after function execution, highlighting function-local scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nfunction sum_to(n)\n    s = 0 # new local\n    for i = 1:n\n        s = s + i # assign existing local\n    end\n    return s # same local\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> function sum_to(n)\n           s = 0 # new local\n           for i = 1:n\n               s = s + i # assign existing local\n           end\n           return s # same local\n       end\nsum_to (generic function with 1 method)\n\njulia> sum_to(10)\n55\n\njulia> s # global\nERROR: UndefVarError: `s` not defined in `Main`\n```\n\n----------------------------------------\n\nTITLE: Illustrating 'Spooky Action at a Distance' with Soft Scope (Julia)\nDESCRIPTION: Presents a Julia code example demonstrating how older soft scope rules (Julia <= 0.6) or current REPL behavior could lead to unintended side effects ('spooky action at a distance'). The assignment `x = \"hello\"` inside the `for` loop might modify a global variable `x` defined far away (potentially in another file), changing its type and value unexpectedly, which could cause errors later, such as in the `y = x + 234` expression.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nx = 123\n\n# much later\n# maybe in a different file\n\nfor i = 1:10\n    x = \"hello\"\n    println(x)\nend\n\n# much later\n# maybe in yet another file\n# or maybe back in the first one where `x = 123`\n\ny = x + 234\n```\n\n----------------------------------------\n\nTITLE: Editing GPG Key Trust Level for Julia Key\nDESCRIPTION: This shell command launches an interactive GnuPG session specifically for editing the properties of the key identified by 'julia' (presumably the key imported in the previous step). Within this session, the user needs to set the trust level for the key to 'maximum' (often level 5), which is a prerequisite for using the key to sign files.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_17\n\nLANGUAGE: gpg\nCODE:\n```\ngpg --edit-key julia\n```\n\n----------------------------------------\n\nTITLE: MPI-Based Summation of Process Ranks with MPI.jl (Julia)\nDESCRIPTION: This Julia script uses MPI.jl to initialize an MPI communicator, synchronize processes, fetch each process's rank, perform a reduction to sum all ranks at the designated root, and print the result. It demonstrates initialization, communication, and finalization workflows typical to MPI programming. This pattern is commonly used in distributed-memory high-performance computing. Dependencies: MPI.jl package and an MPI runtime (e.g., OpenMPI). Inputs: none required; Output: printed sum of ranks when run via mpirun. Must be run in multiple processes, e.g., 'mpirun -np 4 ./julia example.jl'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_47\n\nLANGUAGE: julia\nCODE:\n```\nimport MPI\n\nMPI.Init()\n\ncomm = MPI.COMM_WORLD\nMPI.Barrier(comm)\n\nroot = 0\nr = MPI.Comm_rank(comm)\n\nsr = MPI.Reduce(r, MPI.SUM, root, comm)\n\nif(MPI.Comm_rank(comm) == root)\n   @printf(\"sum of ranks: %s\\n\", sr)\nend\n\nMPI.Finalize()\n```\n\n----------------------------------------\n\nTITLE: Capturing and Translating Backtraces with Julia Stacktrace - Julia\nDESCRIPTION: Captures the backtrace using Julia's backtrace() and translates it to a stacktrace for readability. The first snippet demonstrates that backtrace returns an array of pointers and interpreter frames, and stacktrace converts this into StackFrame objects. Prerequisites include having the Julia REPL environment and the standard library loaded. The key parameters are the call to backtrace (which captures the recent call stack), and stacktrace (which converts this structure). The typical input is no parameter, and the output is a simplified, filtered stacktrace omitting lower-level C frames by default.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n```julia-repl\\njulia> trace = backtrace()\\n18-element Array{Union{Ptr{Nothing}, Base.InterpreterIP},1}:\\n Ptr{Nothing} @0x00007fd8734c6209\\n Ptr{Nothing} @0x00007fd87362b342\\n Ptr{Nothing} @0x00007fd87362c136\\n Ptr{Nothing} @0x00007fd87362c986\\n Ptr{Nothing} @0x00007fd87362d089\\n Base.InterpreterIP(CodeInfo(: (begin\\n      Core.SSAValue(0) = backtrace()\\n      trace = Core.SSAValue(0)\\n      return Core.SSAValue(0)\\n  end)), 0x0000000000000000)\\n Ptr{Nothing} @0x00007fd87362e4cf\\n[...]\\n\\njulia> stacktrace(trace)\\n6-element Array{Base.StackTraces.StackFrame,1}:\\n top-level scope\\n eval at boot.jl:317 [inlined]\\n eval(::Module, ::Expr) at REPL.jl:5\\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\\n macro expansion at REPL.jl:116 [inlined]\\n (::getfield(REPL, Symbol(\\\"##28#29\\\")){REPL.REPLBackend})() at event.jl:92\\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Julia Modules with Relative Imports\nDESCRIPTION: Demonstrates the definition of nested Julia modules (`ParentModule`, `SubA`, `SubB`). It shows how to export (`export`) functions like `add_D` from a submodule, use relative paths (`using .SubA`) to bring names into the parent module's namespace, and import specific names from sibling modules using relative parent paths (`import ..SubA: add_D`). The example also includes extending a function (`add_D`) defined in a sibling submodule.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_23\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> module ParentModule\n       module SubA\n       export add_D  # exported interface\n       const D = 3\n       add_D(x) = x + D\n       end\n       using .SubA  # brings `add_D` into the namespace\n       export add_D # export it from ParentModule too\n       module SubB\n       import ..SubA: add_D # relative path for a “sibling” module\n       # import ParentModule.SubA: add_D # when in a package, such as when this is loaded by using or import, this would be equivalent to the previous import, but not at the REPL\n       struct Infinity end\n       add_D(x::Infinity) = x\n       end\n       end;\n\n```\n\n----------------------------------------\n\nTITLE: Renaming an Identifier During Import with `as` in Julia\nDESCRIPTION: Shows how to resolve name conflicts or shorten names using the `as` keyword during import. `import CSV: read as rd` imports `CSV.read` but makes it available under the name `rd` in the current namespace.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_14\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> import CSV: read as rd\n```\n\n----------------------------------------\n\nTITLE: Enhancing Custom Iterables with `eltype` and `length` in Julia\nDESCRIPTION: Extends the `Squares` type by defining the `eltype` (element type) and `length` methods. Providing this information allows Julia to optimize operations involving the iterable, such as preallocating correctly sized arrays.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Base.eltype(::Type{Squares}) = Int # Note that this is defined for the type\n\njulia> Base.length(S::Squares) = S.count\n```\n\n----------------------------------------\n\nTITLE: Listing Methods for the '+' Operator in Julia REPL\nDESCRIPTION: This REPL session demonstrates using `methods(+)` to list the numerous methods defined for the addition operator (`+`) in Julia's Base library. It highlights the extensive use of multiple dispatch for core operations, showing specialized methods for various numeric and other types (Bool, Float, Complex, BigInt, Char, etc.) and their locations in the source code.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_10\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> methods(+)\n# 180 methods for generic function \"+\":\n[1] +(x::Bool, z::Complex{Bool}) in Base at complex.jl:227\n[2] +(x::Bool, y::Bool) in Base at bool.jl:89\n[3] +(x::Bool) in Base at bool.jl:86\n[4] +(x::Bool, y::T) where T<:AbstractFloat in Base at bool.jl:96\n[5] +(x::Bool, z::Complex) in Base at complex.jl:234\n[6] +(a::Float16, b::Float16) in Base at float.jl:373\n[7] +(x::Float32, y::Float32) in Base at float.jl:375\n[8] +(x::Float64, y::Float64) in Base at float.jl:376\n[9] +(z::Complex{Bool}, x::Bool) in Base at complex.jl:228\n[10] +(z::Complex{Bool}, x::Real) in Base at complex.jl:242\n[11] +(x::Char, y::Integer) in Base at char.jl:40\n[12] +(c::BigInt, x::BigFloat) in Base.MPFR at mpfr.jl:307\n[13] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt, e::BigInt) in Base.GMP at gmp.jl:392\n[14] +(a::BigInt, b::BigInt, c::BigInt, d::BigInt) in Base.GMP at gmp.jl:391\n[15] +(a::BigInt, b::BigInt, c::BigInt) in Base.GMP at gmp.jl:390\n[16] +(x::BigInt, y::BigInt) in Base.GMP at gmp.jl:361\n[17] +(x::BigInt, c::Union{UInt16, UInt32, UInt64, UInt8}) in Base.GMP at gmp.jl:398\n...\n[180] +(a, b, c, xs...) in Base at operators.jl:424\n```\n\n----------------------------------------\n\nTITLE: CSV Writing/Reading Replacement - Julia\nDESCRIPTION: Demonstrates migration from deprecated 'writecsv' and 'readcsv' functions to their new equivalents 'writedlm' and 'readdlm', which provide similar functionality in terms of table input/output with CSV format. Base Julia is the dependency; typical parameters include IO streams, arrays, optional element types, and options.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_154\n\nLANGUAGE: julia\nCODE:\n```\nwritedlm(io, a, ','; opts...)\nreaddlm(io, ','[, T]; opts...)\n```\n\n----------------------------------------\n\nTITLE: Interacting Custom AbstractArrays and Using Base Functions in Julia\nDESCRIPTION: Demonstrates using one custom array (`SquaresVector`) to index another (`SparseArray`), and applying a standard Julia Base function (`sum`) to the `SparseArray`. This highlights the seamless integration of custom array types into the broader Julia ecosystem, allowing them to interact with each other and leverage existing functions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_20\n\nLANGUAGE: jldoctest squarevectype\nCODE:\n```\njulia> A[SquaresVector(3)]\n3-element SparseArray{Float64, 1}:\n 1.0\n 4.0\n 9.0\n\njulia> sum(A)\n45.0\n```\n\n----------------------------------------\n\nTITLE: Debugging UndefVarError for Module References in Remote Closures (Julia)\nDESCRIPTION: Demonstrates an `UndefVarError` when a closure (`x->x`) created within a module (`Foo`) is executed on a remote worker using `remotecall_fetch`. The error occurs because the closure captures a reference to `Foo`, but the `Foo` module itself is not defined in the `Main` scope on the remote worker (worker 2). This highlights that globals under modules other than `Main` are referenced, not serialized by value, in remote calls.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_27\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> module Foo\n           foo() = remotecall_fetch(x->x, 2, \"Hello\")\n       end\n\njulia> Foo.foo()\nERROR: On worker 2:\nUndefVarError: `Foo` not defined in `Main`\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Defining a Workspace in Julia Project.toml\nDESCRIPTION: This TOML snippet shows how to define a workspace in a Julia `Project.toml` file using the `[workspace]` section. The `projects` key lists the subdirectories (e.g., \"test\", \"benchmarks\", \"docs\", \"SomePackage\") that contain their own `Project.toml` files and are part of this workspace. The package manager uses this information to generate a single `Manifest.toml` for the entire workspace.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_17\n\nLANGUAGE: toml\nCODE:\n```\n[workspace]\nprojects = [\"test\", \"benchmarks\", \"docs\", \"SomePackage\"]\n```\n\n----------------------------------------\n\nTITLE: Iterators and Specialized Objects in Julia\nDESCRIPTION: Julia frequently uses iterators and specialized objects (like `AbstractRange`, `enumerate`, `zip`) that behave like arrays in many contexts but are more memory-efficient as they compute values lazily.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nrange(...)\n```\n\nLANGUAGE: julia\nCODE:\n```\nenumerate(...)\n```\n\nLANGUAGE: julia\nCODE:\n```\nzip(...)\n```\n\n----------------------------------------\n\nTITLE: Setting REPL Input and Output Styles to Bold - ENV Variable Usage - Julia\nDESCRIPTION: These statements customize REPL input and answer text styles in Julia to be bold. By assigning the symbols :bold to the JULIA_INPUT_COLOR and JULIA_ANSWER_COLOR environment variables, the user can change the default display attributes for REPL prompts and answers. These assignments are typically added to a startup file such as .juliarc.jl and work across Julia sessions; they presume color-capable terminals.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_166\n\nLANGUAGE: julia\nCODE:\n```\nENV[\"JULIA_INPUT_COLOR\"] = :bold\n```\n\nLANGUAGE: julia\nCODE:\n```\nENV[\"JULIA_ANSWER_COLOR\"] = :bold\n```\n\n----------------------------------------\n\nTITLE: Requesting Documentation for Pidfile Helper Functions (Julia)\nDESCRIPTION: Uses the Documenter.jl `@docs` macro to request the inclusion of documentation for helper functions (`Pidfile.open_exclusive`, `Pidfile.tryopen_exclusive`, etc.) related to PID file management within the `FileWatching.Pidfile` module, including a method extension for `Base.touch`.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/FileWatching/docs/src/index.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nPidfile.open_exclusive\nPidfile.tryopen_exclusive\nPidfile.write_pidfile\nPidfile.parse_pidfile\nPidfile.stale_pidfile\nPidfile.isvalidpid\nBase.touch(::Pidfile.LockMonitor)\n```\n\n----------------------------------------\n\nTITLE: Printing and String Interpolation of `nothing` in Julia\nDESCRIPTION: The `nothing` value can now be printed or interpolated into strings, resulting in the string `\"nothing\"`. Interpolation into `Cmd` objects remains disallowed.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_126\n\nLANGUAGE: julia\nCODE:\n```\nprint(nothing)    # Prints \"nothing\"\n\"Value is $(nothing)\" # Results in \"Value is nothing\"\n# ``echo `$(nothing)` `` # Still causes an error\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for Julia Built-in Constants\nDESCRIPTION: Uses the Julia `@docs` directive within the documentation system (like Documenter.jl) to automatically generate documentation entries for various built-in constants from the `Core` and `Base` modules. Constants referenced include `Core.nothing`, `Base.PROGRAM_FILE`, `Base.ARGS`, `Base.C_NULL`, `Base.VERSION`, `Base.DEPOT_PATH`, `Base.LOAD_PATH`, `Base.Sys.BINDIR`, `Base.Sys.CPU_THREADS`, `Base.Sys.WORD_SIZE`, `Base.Sys.KERNEL`, `Base.Sys.ARCH`, and `Base.Sys.MACHINE`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/constants.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCore.nothing\nBase.PROGRAM_FILE\nBase.ARGS\nBase.C_NULL\nBase.VERSION\nBase.DEPOT_PATH\nBase.LOAD_PATH\nBase.Sys.BINDIR\nBase.Sys.CPU_THREADS\nBase.Sys.WORD_SIZE\nBase.Sys.KERNEL\nBase.Sys.ARCH\nBase.Sys.MACHINE\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating julia-config.jl into a Makefile\nDESCRIPTION: Provides a Makefile snippet demonstrating how to automate the inclusion of Julia build flags using `julia-config.jl`. It dynamically determines the Julia shared data directory (`JL_SHARE`) using `julia -e` and then uses `make`'s `shell` function to execute `julia-config.jl` with appropriate flags to set `CFLAGS`, `CXXFLAGS`, `LDFLAGS`, and `LDLIBS` variables.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_5\n\nLANGUAGE: makefile\nCODE:\n```\nJL_SHARE = $(shell julia -e 'print(joinpath(Sys.BINDIR, Base.DATAROOTDIR, \"julia\"))')\nCFLAGS   += $(shell $(JL_SHARE)/julia-config.jl --cflags)\nCXXFLAGS += $(shell $(JL_SHARE)/julia-config.jl --cflags)\nLDFLAGS  += $(shell $(JL_SHARE)/julia-config.jl --ldflags)\nLDLIBS   += $(shell $(JL_SHARE)/julia-config.jl --ldlibs)\n\nall: embed_example\n```\n\n----------------------------------------\n\nTITLE: Disabling BinaryBuilder for Source Dependency Builds (Makefile)\nDESCRIPTION: Shows how to disable pre-built external dependencies so that all required libraries are built from source. This is especially recommended for environments that do not allow access to external networks during build. The option is set in the Make.user configuration file, and is automatically picked up during the build process.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_1\n\nLANGUAGE: make\nCODE:\n```\nUSE_BINARYBUILDER=0\n\n```\n\n----------------------------------------\n\nTITLE: Calculating Durations and Comparisons with Date and DateTime - Julia Dates Module - Julia\nDESCRIPTION: This block demonstrates how to subtract, compare, and inspect Date and DateTime objects in Julia. It shows that Date and DateTime support direct subtraction which yields Day or Millisecond period values, respectively, but do not support addition or multiplication with each other. Comparisons like greater-than and not-equal are supported. Calling dump reveals the internal structure which uses UTInstant periods. Main dependency is the Dates module, and input values must be valid Date or DateTime objects. Attempts at unsupported operations return MethodError.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> dt = Date(2012,2,29)\n2012-02-29\n\njulia> dt2 = Date(2000,2,1)\n2000-02-01\n\njulia> dump(dt)\nDate\n  instant: Dates.UTInstant{Day}\n    periods: Day\n      value: Int64 734562\n\njulia> dump(dt2)\nDate\n  instant: Dates.UTInstant{Day}\n    periods: Day\n      value: Int64 730151\n\njulia> dt > dt2\ntrue\n\njulia> dt != dt2\ntrue\n\njulia> dt + dt2\nERROR: MethodError: no method matching +(::Date, ::Date)\n[...]\n\njulia> dt * dt2\nERROR: MethodError: no method matching *(::Date, ::Date)\n[...]\n\njulia> dt / dt2\nERROR: MethodError: no method matching /(::Date, ::Date)\n\njulia> dt - dt2\n4411 days\n\njulia> dt2 - dt\n-4411 days\n\njulia> dt = DateTime(2012,2,29)\n2012-02-29T00:00:00\n\njulia> dt2 = DateTime(2000,2,1)\n2000-02-01T00:00:00\n\njulia> dt - dt2\n381110400000 milliseconds\n```\n\n----------------------------------------\n\nTITLE: Interacting With GDB for Julia Backtraces - Shell\nDESCRIPTION: This shell snippet shows interaction with a gdb debugging session, specifically entering commands to start execution and to generate a stack backtrace when Julia segfaults. The sample output includes prompts and illustrative paths, and it assumes gdb is currently running with a compiled Julia debug build.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/backtraces.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n\"(gdb) r\\nStarting program: /home/sabae/src/julia/usr/bin/julia-debug ./test.jl\\n...\\n(gdb) bt\\n\"\n```\n\n----------------------------------------\n\nTITLE: Evaluating Library Names Dynamically in `ccall` in Julia\nDESCRIPTION: The library name argument provided to `ccall` or the `@ccall` macro can now be an arbitrary Julia expression involving global variables and function calls. This expression is evaluated the first time the `ccall` is executed, allowing for dynamic library path resolution.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_50\n\nLANGUAGE: julia\nCODE:\n```\nlibname = determine_library_path()\nccall((:my_c_function, libname), ...)\n\n@ccall determine_library_path().my_c_function(...)\n```\n\n----------------------------------------\n\nTITLE: Listing Command Line Parameters for Julia Windows Installer (Inno Setup)\nDESCRIPTION: Provides the command to list available command-line parameters for the new Julia Windows installer based on Inno Setup. This is useful for automating or customizing installations.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_86\n\nLANGUAGE: shell\nCODE:\n```\njulia-installer.exe /?\n```\n\n----------------------------------------\n\nTITLE: Building Advanced Pipelines and Parallel Processes - Julia\nDESCRIPTION: Shows how to chain multiple processes together using pipeline and run, including examples that mimic classic Unix pipeline idioms. Demonstrates how to execute processes concurrently with &, and how to combine their outputs or chain them to further commands. Useful for advanced process orchestration without an intermediate shell. All involved commands must be present on the platform.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_7\n\nLANGUAGE: julia-repl\nCODE:\n```\n```julia-repl\njulia> run(pipeline(`cut -d: -f3 /etc/passwd`, `sort -n`, `tail -n5`))\n210\n211\n212\n213\n214\n```\n```\n\nLANGUAGE: jldoctest; filter = r\"(world\\nhello|hello\\nworld)\"\nCODE:\n```\n```jldoctest; filter = r\"(world\\nhello|hello\\nworld)\"\njulia> run(`echo hello` & `echo world`);\nworld\nhello\n```\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> run(pipeline(`echo world` & `echo hello`, `sort`));\nhello\nworld\n```\n```\n\nLANGUAGE: julia\nCODE:\n```\n```julia\npipeline(`do_work`, stdout=pipeline(`sort`, \"out.txt\"), stderr=\"errs.txt\")\n```\n```\n\n----------------------------------------\n\nTITLE: New Testing Macros `@test_warn` and `@test_nowarn` in Julia\nDESCRIPTION: Adds two new macros, `@test_warn` and `@test_nowarn`, to the `Base.Test` module in Julia. These macros facilitate testing for the presence or absence of warning messages during code execution.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_168\n\nLANGUAGE: julia\nCODE:\n```\n@test_warn\n```\n\nLANGUAGE: julia\nCODE:\n```\n@test_nowarn\n```\n\n----------------------------------------\n\nTITLE: Printing Build Variable Value using Julia Makefile (Console)\nDESCRIPTION: Demonstrates the use of Julia Makefile's print rules to display the value of a build variable for debugging purposes. Replace 'JULIA_PRECOMPILE' with any desired variable name. Run directly from the console in the Julia source directory.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ make print-JULIA_PRECOMPILE\nJULIA_PRECOMPILE=1\n\n```\n\n----------------------------------------\n\nTITLE: Race-Free Parallel Summation by Chunking and Spawning Tasks - Julia\nDESCRIPTION: Defines sum_multi_good to perform parallel summation safely by partitioning the input, spawning a concurrent sum_single task for each chunk, fetching partial sums, and combining them. Demonstrates use of Iterators.partition, Threads.nthreads, Threads.@spawn, and fetch. Inputs: array to sum. Output: correct total, safe from data races. Requires Julia's standard library and multi-threaded setup.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_16\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> function sum_multi_good(a)\n           chunks = Iterators.partition(a, cld(length(a), Threads.nthreads()))\n           tasks = map(chunks) do chunk\n               Threads.@spawn sum_single(chunk)\n           end\n           chunk_sums = fetch.(tasks)\n           return sum_single(chunk_sums)\n       end\nsum_multi_good (generic function with 1 method)\n\njulia> sum_multi_good(1:1_000_000)\n500000500000\n```\n\n----------------------------------------\n\nTITLE: Updating GTK Icon Cache Post-Installation in Shell\nDESCRIPTION: This shell script updates the GTK icon cache located at `/usr/share/icons/hicolor`. It first checks if the cache file (`icon-theme.cache`) and the update utility (`/usr/bin/gtk-update-icon-cache`) exist and are executable, respectively. If both conditions are met, it runs the update command silently. This is typically executed by package managers after installing an application like Julia to ensure its icons are correctly displayed in desktop environments.\nSOURCE: https://github.com/julialang/julia/blob/master/contrib/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nif [ -e /usr/share/icons/hicolor/icon-theme.cache ]; then\n  if [ -x /usr/bin/gtk-update-icon-cache ]; then\n    /usr/bin/gtk-update-icon-cache -f /usr/share/icons/hicolor >/dev/null 2>&1\n  fi\nfi\n```\n\n----------------------------------------\n\nTITLE: Defining C Function Using AVX SIMD Types\nDESCRIPTION: Example C function `dist` that takes two `__m256` (AVX SIMD type) arguments and returns a `__m256` result. It uses AVX intrinsics (`_mm256_*`) for calculations. This demonstrates a C routine intended to be called from Julia with SIMD vector types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_20\n\nLANGUAGE: c\nCODE:\n```\n#include <immintrin.h>\n\n__m256 dist( __m256 a, __m256 b ) {\n    return _mm256_sqrt_ps(_mm256_add_ps(_mm256_mul_ps(a, a),\n                                        _mm256_mul_ps(b, b)));\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Strides with @nexprs Using Index Arithmetic - Julia\nDESCRIPTION: This example uses @nexprs to generate a series of stride calculations for an array, incrementally updating stride variables using arithmetic on the loop index. The code includes an initial stride assignment and then applies @nexprs 3 j->(s_{j+1} = s_j * size(A, j)) to expand into sequenced stride computations. Inputs are the number of repetitions and a stride formula; output is a sequence of assignments that compute strides s_2 to s_4 based on the size of A and prior stride values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/cartesian.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\ns_1 = 1\\n@nexprs 3 j->(s_{j+1} = s_j * size(A, j))\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Function Selection via Reflection - Julia\nDESCRIPTION: This example, used to illustrate limitations of system image trimming, demonstrates a reflective technique to call arbitrary functions read from standard input. The snippet reads a function name at runtime, looks it up in Base, and immediately invokes it with argument 1. Due to its highly dynamic and unpredictable nature, such code precludes effective dead code elimination in system-image builds, as any Base function could potentially be needed at runtime. Requires only Base module functions; expected input is a function name from stdin, and output depends on the called function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/sysimg.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\ngetglobal(Base, Symbol(readchomp(stdin)))(1)\n```\n\n----------------------------------------\n\nTITLE: New `@macroexpand` Macro in Julia\nDESCRIPTION: Adds the `@macroexpand` macro as a convenient alternative to the `macroexpand` function in Julia for inspecting macro expansions.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_172\n\nLANGUAGE: julia\nCODE:\n```\n@macroexpand\n```\n\n----------------------------------------\n\nTITLE: Examining the Generated Expression for sub2ind (Julia)\nDESCRIPTION: Shows how to inspect the Expr returned by sub2ind_gen_impl directly by passing type arguments, revealing the fully unrolled calculation expression (no runtime loop). Used for understanding the code generation output. Inputs: Tuple type information, Int signature; Output: Expr representing the calculation. Limitations: Only reveals generated code structure, not for direct linear index computation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_76\n\nLANGUAGE: julia\nCODE:\n```\nsub2ind_gen_impl(Tuple{Int,Int}, Int, Int)\n:(((I[1] - 1) + dims[1] * (I[2] - 1)) + 1)\n```\n\n----------------------------------------\n\nTITLE: Generating Repeated Expressions with @nexprs Macro - Julia\nDESCRIPTION: This snippet demonstrates the use of the @nexprs macro to generate repeated assignment statements for a series of variables indexed by j. In this example, @nexprs 2 j->(i_j = 1) creates two assignments: i_1 = 1 and i_2 = 1. It is useful for initializing variables in a systematic fashion. Inputs are the number of repetitions and an anonymous function specifying the assignment pattern; the output is a block of assignment statements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/cartesian.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n@nexprs 2 j->(i_j = 1)\n```\n\n----------------------------------------\n\nTITLE: Multiplying Input by Float Literal in Julia Function - Julia\nDESCRIPTION: Defines a generic function f(x) that multiplies its argument by a Float64 literal (2.0). Demonstrates how using a float in the operation leads to type promotion of inputs to Float64, regardless of their original numeric type. No external dependencies are required; illustrates implications when passing Rational, float, or integer values.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(x) = 2.0 * x\nf (generic function with 1 method)\n\njulia> f(1//2)\n1.0\n\njulia> f(1/2)\n1.0\n\njulia> f(1)\n2.0\n```\n\n----------------------------------------\n\nTITLE: Defining a Function Using a Scoped Value in Julia\nDESCRIPTION: Defines a function `f` that takes an argument `x` and adds it to the current value of a globally defined `ScopedValue` named `a`. This function is used in subsequent examples to show interaction with dynamic scopes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.ScopedValues\nconst a = ScopedValue(1)\nf(x) = a[] + x\n```\n\n----------------------------------------\n\nTITLE: Introducing a New Local Variable in a For Loop Body and Testing Scope - Julia\nDESCRIPTION: The sum_to_def function creates a new local variable t inside a for loop, then uses @isdefined to show that t is not visible outside the loop body. Dependencies include standard Julia constructs and the @isdefined macro. Parameter n selects the loop bounds; the function returns both the final sum and a boolean indicating t's outer-scope existence. This example highlights hard scope separation and temporary local variable visibility constraints within loops.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> function sum_to_def(n)\n           s = 0 # new local\n           for i = 1:n\n               t = s + i # new local `t`\n               s = t # assign existing local `s`\n           end\n           return s, @isdefined(t)\n       end\nsum_to_def (generic function with 1 method)\n\njulia> sum_to_def(10)\n(55, false)\n```\n\n----------------------------------------\n\nTITLE: Notifying GC of Pointer Updates within Julia Objects in C\nDESCRIPTION: Declares the C function `jl_gc_wb` (write barrier). This function must be called after modifying a field of a mutable Julia object (`parent`) to store a pointer to another heap-allocated Julia object (`ptr`). It informs the garbage collector about the potential new reference, ensuring the referenced object (`ptr`) is not prematurely collected.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nvoid jl_gc_wb(jl_value_t *parent, jl_value_t *ptr);\n```\n\n----------------------------------------\n\nTITLE: Printing Flisp value_t in Julia's Flisp Interpreter (C/C++ call)\nDESCRIPTION: This demonstrates using the flisp interpreter's facilities to print a value_t object to the standard output stream. It shows calling fl_print inside the native context, displaying the object passed as 'obj'. Dependencies include flisp context setup and access to ios_stdout.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\ncall fl_print(fl_ctx, ios_stdout, obj)\n```\n\n----------------------------------------\n\nTITLE: Building Julia Documentation Locally using Make (Shell)\nDESCRIPTION: This command, executed from the Julia project's root directory, initiates the documentation build process using Make and Documenter.jl. It first rebuilds the Julia system image, installs or updates necessary package dependencies, and finally compiles the Markdown source files (`doc/src/`) and docstrings (`base/`) into HTML format, placing the output in the `doc/_build/html/` directory. It's recommended to run this command to validate documentation changes before submitting a pull request.\nSOURCE: https://github.com/julialang/julia/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n```shell\nmake docs\n```\n```\n\n----------------------------------------\n\nTITLE: Getting Remaining Elements of a Collection with `Base.rest` in Julia\nDESCRIPTION: `Base.rest(collection, state)` returns an object representing the rest of the `collection` starting from the iteration `state`. This function is used internally to implement the `...` destructuring syntax on the LHS of assignments and can be overloaded for custom collection types.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_70\n\nLANGUAGE: julia\nCODE:\n```\nitr = [1, 2, 3, 4]\nval, state = iterate(itr)       # val=1, state=2\nrest_collection = Base.rest(itr, state) # Represents [2, 3, 4]\ncollect(rest_collection)        # Returns [2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Setting Documentation Metadata (Julia Documenter.jl)\nDESCRIPTION: This `@meta` block provides metadata for the documentation generation system (likely Documenter.jl). The `EditURL` key specifies the URL where the source markdown file for this documentation page can be found and edited on GitHub.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/CRC32c/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nEditURL = \"https://github.com/JuliaLang/julia/blob/master/stdlib/CRC32c/docs/src/index.md\"\n```\n```\n\n----------------------------------------\n\nTITLE: Using a Promotion-Based Outer Constructor in Julia\nDESCRIPTION: Demonstrates the power of the `promote`-based outer constructor for `Point`. It successfully creates `Point` instances with various combinations of numeric arguments: `Point(1.5, 2)` (Float64, Int -> Float64), `Point(1, 1//2)` (Int, Rational -> Rational), and `Point(1.0, 1//2)` (Float64, Rational -> Float64). The arguments are automatically promoted to a suitable common type before the corresponding `Point{T}` instance is created.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_21\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Point(1.5,2)\nPoint{Float64}(1.5, 2.0)\n\njulia> Point(1,1//2)\nPoint{Rational{Int64}}(1//1, 1//2)\n\njulia> Point(1.0,1//2)\nPoint{Float64}(1.0, 0.5)\n```\n\n----------------------------------------\n\nTITLE: Comparing Strings Lexicographically in Julia\nDESCRIPTION: Demonstrates using the standard comparison operators (`<`, `==`, `!=`) for lexicographical (alphabetical order based on character codes) comparison of strings in Julia. The last example shows that comparison works correctly even when one string involves interpolation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_37\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> \"abracadabra\" < \"xylophone\"\ntrue\n\njulia> \"abracadabra\" == \"xylophone\"\nfalse\n\njulia> \"Hello, world.\" != \"Goodbye, world.\"\ntrue\n\njulia> \"1 + 2 = 3\" == \"1 + 2 = $(1 + 2)\"\ntrue\n```\n\n----------------------------------------\n\nTITLE: Comparing Immutability and Structural Identity in Julia Composite Types\nDESCRIPTION: Shows that two distinct instances of an immutable struct with identical field values are indistinguishable (===). Defines a simple struct X and constructs two logically identical instances, demonstrating that their logical identity holds. Assumes no dependencies beyond struct definition.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nstruct X\n    a::Int\n    b::Float64\nend\n\nX(1, 2) === X(1, 2)\ntrue\n```\n\n----------------------------------------\n\nTITLE: Counting String/Regex Matches in Julia\nDESCRIPTION: The `count(pattern, string)` function returns the number of matches that `findall` would find for the given string or regular expression pattern within the string.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_111\n\nLANGUAGE: julia\nCODE:\n```\ncount(pattern::Union{String, Regex}, string::String)\n```\n\n----------------------------------------\n\nTITLE: Calling a Type-Specific Function Method (Julia)\nDESCRIPTION: This snippet shows usage of a function 'f' in Julia, where both arguments are Float64, satisfying the type constraints of a previously defined method. The function computes '2x + y' and returns a Float64 value. No dependencies are needed beyond the function's definition.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(2.0, 3.0)\n7.0\n```\n\n----------------------------------------\n\nTITLE: Method Expansion for Optional Arguments in Julia\nDESCRIPTION: Shows the three separate method definitions that Julia automatically generates for the function `f(a=1,b=2) = a+2b`. This illustrates that optional arguments are syntactic sugar for defining multiple methods with different numbers of arguments.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\nf(a,b) = a+2b\nf(a) = f(a,2)\nf() = f(1,2)\n```\n\n----------------------------------------\n\nTITLE: Method Ambiguity with NTuple Arguments in Julia\nDESCRIPTION: Demonstrates how using `NTuple{N, Type}` in method signatures can lead to ambiguity. The two methods for `f` differ only in the element type (`Int` vs `Float64`) but share the length parameter `N`. If `N == 0` (an empty tuple), it's ambiguous which method to call.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_40\n\nLANGUAGE: julia\nCODE:\n```\nf(x::NTuple{N,Int}) where {N} = 1\nf(x::NTuple{N,Float64}) where {N} = 2\n```\n\n----------------------------------------\n\nTITLE: Defining and Constructing a Parametric Rational Type in Julia\nDESCRIPTION: This snippet defines a parametric struct `OurRational{T<:Integer}` extending `Real`. It includes an inner constructor that normalizes the rational number (handling 0//0, signs, and using `gcd` for lowest terms) and ensures a non-negative denominator. Several outer constructors are provided for easier instantiation: inferring `T`, promoting differing integer types, and converting integers to rationals. Additionally, it defines multiple methods for the `⊘` operator to handle creation and operations involving `OurRational`, integers, and complex numbers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_22\n\nLANGUAGE: jldoctest rational\nCODE:\n```\njulia> struct OurRational{T<:Integer} <: Real\n           num::T\n           den::T\n           function OurRational{T}(num::T, den::T) where T<:Integer\n               if num == 0 && den == 0\n                    error(\"invalid rational: 0//0\")\n               end\n               num = flipsign(num, den)\n               den = flipsign(den, den)\n               g = gcd(num, den)\n               num = div(num, g)\n               den = div(den, g)\n               new(num, den)\n           end\n       end\n\njulia> OurRational(n::T, d::T) where {T<:Integer} = OurRational{T}(n,d)\nOurRational\n\njulia> OurRational(n::Integer, d::Integer) = OurRational(promote(n,d)...)\nOurRational\n\njulia> OurRational(n::Integer) = OurRational(n,one(n))\nOurRational\n\njulia> ⊘(n::Integer, d::Integer) = OurRational(n,d)\n⊘ (generic function with 1 method)\n\njulia> ⊘(x::OurRational, y::Integer) = x.num ⊘ (x.den*y)\n⊘ (generic function with 2 methods)\n\njulia> ⊘(x::Integer, y::OurRational) = (x*y.den) ⊘ y.num\n⊘ (generic function with 3 methods)\n\njulia> ⊘(x::Complex, y::Real) = complex(real(x) ⊘ y, imag(x) ⊘ y)\n⊘ (generic function with 4 methods)\n\njulia> ⊘(x::Real, y::Complex) = (x*y') ⊘ real(y*y')\n⊘ (generic function with 5 methods)\n\njulia> function ⊘(x::Complex, y::Complex)\n           xy = x*y'\n           yy = real(y*y')\n           complex(real(xy) ⊘ yy, imag(xy) ⊘ yy)\n       end\n⊘ (generic function with 6 methods)\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Querying a Composite Type in Julia\nDESCRIPTION: Demonstrates the creation of a Foo object, initializing all its fields, and then retrieving its type using typeof. This shows the default constructor's acceptance of any arguments (with conversion for typed fields). Inputs are compatible values for each field; outputs include a printed Foo object and its type. No dependencies beyond prior struct definition.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nfoo = Foo(\"Hello, world.\", 23, 1.5)\nFoo(\"Hello, world.\", 23, 1.5)\n\ntypeof(foo)\nFoo\n```\n\n----------------------------------------\n\nTITLE: Attempting Method Extension After Specific `using` Import in Julia\nDESCRIPTION: Illustrates that importing a function (`nice`) using `using .NiceStuff: nice` does *not* allow adding new methods to it without qualification. Attempting to define `nice(::Cat)` results in an error because the function must be explicitly imported via `import` or qualified with the module name for extension.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_10\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using .NiceStuff: nice\n\njulia> struct Cat end\n\njulia> nice(::Cat) = \"nice 😸\"\nERROR: invalid method definition in Main: function NiceStuff.nice must be explicitly imported to be extended\nStacktrace:\n [1] top-level scope\n   @ none:1\n```\n\n----------------------------------------\n\nTITLE: Bitwise Operators in Julia\nDESCRIPTION: Julia uses `&`, `|`, and `⊻` (or `xor`) for bitwise AND, OR, and XOR operations, respectively. These operators have precedence similar to Python's and can operate element-wise on arrays. Parentheses are often needed when combining with element-wise comparisons due to precedence.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\n&\n```\n\nLANGUAGE: julia\nCODE:\n```\n|\n```\n\nLANGUAGE: julia\nCODE:\n```\n⊻\n```\n\nLANGUAGE: julia\nCODE:\n```\nxor\n```\n\nLANGUAGE: julia\nCODE:\n```\n(A .== 1) .| (A .== 2) # Parentheses needed due to precedence\n```\n\n----------------------------------------\n\nTITLE: Building mmtk-julia Binding from Source - shell\nDESCRIPTION: Describes setting environment variables to bypass the precompiled BinaryBuilder and build the mmtk-julia Rust binding manually. Set USE_BINARYBUILDER_MMTK_JULIA=0 to force a source build, which requires a working Rust toolchain. Optionally, set MMTK_JULIA_DIR to specify a custom binding path. These variables affect the Julia build system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-mmtk.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nUSE_BINARYBUILDER_MMTK_JULIA=0\n```\n\n----------------------------------------\n\nTITLE: Starting Julia with Tracy Connection Wait Enabled (Bash/Shell)\nDESCRIPTION: This shell command starts the Julia executable (`./julia`) while setting the `JULIA_WAIT_FOR_TRACY` environment variable to `1`. This variable instructs the Julia runtime, if built with Tracy support, to pause execution upon startup until it successfully connects to a running Tracy profiler instance. The `-e '...'` part indicates where the Julia code to be executed and profiled would be placed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/external_profilers.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nJULIA_WAIT_FOR_TRACY=1 ./julia -e '...'\n\n```\n\n----------------------------------------\n\nTITLE: Checking Documentation Presence - Julia\nDESCRIPTION: Demonstrates built-in functions for programmatically checking for and listing documentation in Julia modules. 'Docs.hasdoc(module, name)' returns a boolean indicating whether a specific object has a docstring. 'Docs.undocumented_names(module; all)' returns all object names without docs. Useful for documentation coverage tests or analyzers; requires the 'Docs' standard module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nDocs.hasdoc(module, name)::Bool\nDocs.undocumented_names(module; all)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Julia Standard Stream Types with Shell Commands\nDESCRIPTION: Provides shell examples showing how the runtime types of Julia's `Base.stdin`, `Base.stdout`, and `Base.stderr` objects change based on I/O redirection. It illustrates the dynamic creation of `Base.TTY`, `Base.IOStream`, or `Base.PipeEndpoint` objects by `reinit_stdio()` to represent the underlying libuv stream types (retrieved via `ccall` to `JL_STD*` pointers and `jl_uv_handle_type`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/stdio.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ julia -e 'println(typeof((stdin, stdout, stderr)))'\nTuple{Base.TTY,Base.TTY,Base.TTY}\n\n$ julia -e 'println(typeof((stdin, stdout, stderr)))' < /dev/null 2>/dev/null\nTuple{IOStream,Base.TTY,IOStream}\n\n$ echo hello | julia -e 'println(typeof((stdin, stdout, stderr)))' | cat\nTuple{Base.PipeEndpoint,Base.PipeEndpoint,Base.TTY}\n```\n\n----------------------------------------\n\nTITLE: Parallel Map for Large Matrix Computations with pmap in Julia REPL\nDESCRIPTION: This snippet uses 'pmap' to compute the singular values of several large, randomly generated matrices in parallel. The matrices are assembled in a vector comprehension, and 'svdvals' is applied to each via distributed workers. Best for scenarios where each function call is compute-intensive. Relies on Julia's Distributed and LinearAlgebra libraries.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_22\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> M = Matrix{Float64}[rand(1000,1000) for i = 1:10];\n\njulia> pmap(svdvals, M);\n```\n\n----------------------------------------\n\nTITLE: Defining a Parametric Struct with Type Parameters as Values - Base Julia - Julia\nDESCRIPTION: Illustrates the definition of a Julia parametric struct with type value parameters (e.g., Make and Model for a Car). This pattern can provide optimization for certain workloads but risks a combinatorial explosion of compiled types if overused. There are no external dependencies, and the fields and usage must avoid excessive specialization for scalability.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_41\n\nLANGUAGE: julia\nCODE:\n```\nstruct Car{Make, Model}\n    year::Int\n    ...more fields...\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Parametric Type Aliases in Julia\nDESCRIPTION: Defines a parametric type alias Family{T} as an alias of Set{T}. Demonstrates that the construction of Family{Char} is equivalent to Set{Char}. This allows for flexible, parameterizable type aliasing for code readability and abstraction. No external dependencies are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_62\n\nLANGUAGE: julia\nCODE:\n```\nconst Family{T} = Set{T}\n```\n\n----------------------------------------\n\nTITLE: Launching Julia with Multiple Threads - Julia/Shell\nDESCRIPTION: This snippet demonstrates how to start Julia with 6 threads using the -t option, allowing concurrent task execution. It includes the initial Julia REPL banner and shows how to obtain the process ID (PID) within the REPL by calling getpid(). Dependencies: Julia 1.6.2 or compatible, a multiprocessor system. The output includes the PID, which is necessary for targeted tracing in follow-up steps.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n> julia -t 6\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.6.2 (2021-07-14)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org release\n|__/                   |\n```\n\nLANGUAGE: julia\nCODE:\n```\n1> getpid()\n997825\n```\n\n----------------------------------------\n\nTITLE: Creating SubArray Views with Dimension Dropping in Julia\nDESCRIPTION: Creates a 3D `Array` `A` with random Float64 values. It then creates two 2D `SubArray` views: `S1` by slicing the first dimension and fixing the second, and `S2` by fixing the first dimension and slicing the second. The output shows the resulting views and their types, illustrating how `view` drops dimensions specified by integers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest subarray\njulia> A = rand(2,3,4);\n\njulia> S1 = view(A, :, 1, 2:3)\n2×2 view(::Array{Float64, 3}, :, 1, 2:3) with eltype Float64:\n 0.839622  0.711389\n 0.967143  0.103929\n\njulia> S2 = view(A, 1, :, 2:3)\n3×2 view(::Array{Float64, 3}, 1, :, 2:3) with eltype Float64:\n 0.839622  0.711389\n 0.789764  0.806704\n 0.566704  0.962715\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Custom Install Folder using Make.user (Makefile)\nDESCRIPTION: Illustrates specifying a custom installation prefix for Julia in Make.user by setting the 'prefix' variable, causing 'make install' to place Julia in the user-specified directory. Requires running 'make install' after editing. Ensure that any existing Julia installation in this folder is deleted for a clean install.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_7\n\nLANGUAGE: make\nCODE:\n```\nprefix=/path/to/install/folder\n\n```\n\n----------------------------------------\n\nTITLE: Temporarily Extending PATH Environment Variable (bash)\nDESCRIPTION: Demonstrates how to temporarily add the current working directory to the PATH environment variable for the shell session, allowing instant access to the local Julia executable. This is a standard shell operation requiring no extra dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nexport PATH=\"$(pwd):$PATH\"\n\n```\n\n----------------------------------------\n\nTITLE: Forcing Julia Function Recompilation for Debugging (GDB Commands)\nDESCRIPTION: Demonstrates clearing the compiled functionObject field on a Julia function's linfo struct, causing codegen to be re-invoked on next run. A breakpoint can then be set in emit_function or related functions for step-debugging through Julia's JIT process. Intended for advanced debugging use inside a native debugger session.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_14\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) p f->linfo->functionObject\n(gdb) set f->linfo->functionObject = NULL\n(gdb) p jl_compile(f)\n... # your breakpoint here\n```\n\n----------------------------------------\n\nTITLE: Enabling AOT Multiversioning via Environment Variable\nDESCRIPTION: References the `JULIA_CPU_TARGET` environment variable. Setting this variable triggers the generation of native code optimized for multiple CPU architectures (multiversioning) during AOT compilation, allowing the loader to select the best version at runtime based on available CPU features.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/aot.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nJULIA_CPU_TARGET\n```\n\n----------------------------------------\n\nTITLE: Discouraged Static Parameter Usage in Function Signatures - Julia - julia\nDESCRIPTION: Displays a function definition pattern that unnecessarily uses a static type parameter in method signatures. The function foo uses a parametric type constraint (T<:Real) even though the type T is not used in the function body. No extra dependencies are required. This practice should be avoided as it does not offer any performance benefit and reduces code clarity; the preferred style is to use concrete types directly in the signature.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nfoo(x::T) where {T<:Real} = ...\n\n```\n\n----------------------------------------\n\nTITLE: Returning Parameter Types from Functions Using Parametric Methods in Julia\nDESCRIPTION: Implements 'mytypeof', a function that returns the type parameter of its argument, serving as a custom type introspection utility. This uses method type parameters to deterministically infer and output the type of the input argument, showing the power of 'where' in function signatures. Requires Julia's generic function system and return type inference.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nmytypeof(x::T) where {T} = T\n\nmytypeof(1)\nmytypeof(1.0)\n```\n\n----------------------------------------\n\nTITLE: Creating Constant-Filled Arrays - Base Julia - Julia\nDESCRIPTION: Demonstrates basic construction of a 2D matrix filled with a constant value using Julia's built-in `fill` function. No external dependencies are required. The method takes a value and a tuple of dimensions, returning a new dense matrix with all elements initialized to the fill value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\njulia> A = fill(5.0, (3, 3))\n3×3 Matrix{Float64}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n```\n\n----------------------------------------\n\nTITLE: Evaluating Basic Expressions with `eval` in Julia\nDESCRIPTION: Demonstrates using the `eval` function to execute Julia expressions stored in variables. It shows a successful evaluation of `:(1 + 2)` and an evaluation of `:(a + b)` that initially fails due to undefined variables, then succeeds after defining `a` and `b`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_14\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> ex1 = :(1 + 2)\n:(1 + 2)\n\njulia> eval(ex1)\n3\n\njulia> ex = :(a + b)\n:(a + b)\n\njulia> eval(ex)\nERROR: UndefVarError: `b` not defined in `Main`\n[...]\n\njulia> a = 1; b = 2;\n\njulia> eval(ex)\n3\n```\n\n----------------------------------------\n\nTITLE: Defining the Generic jlcall C Function Signature (C)\nDESCRIPTION: Shows the C function signature representing Julia's generic calling convention (`jlcall`) for unoptimized functions. The function takes a pointer to a boxed Julia function object (`jl_value_t *`), a pointer to an array of argument pointers (`jl_value_t **`), and the integer count of arguments, returning a pointer to a Julia value (`jl_value_t *`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *any_unoptimized_call(jl_value_t *, jl_value_t **, int);\n```\n\n----------------------------------------\n\nTITLE: Building Julia with Multiple Git Stdlib Checkouts using Make\nDESCRIPTION: This command allows the Julia build system to use local Git checkouts for multiple standard libraries simultaneously. The names of the desired stdlibs (e.g., Pkg, Tar, Downloads), corresponding to directories in `stdlib/`, are provided as a space-separated string to the `DEPS_GIT` variable via the `make` command. The respective repositories must be cloned into their corresponding `stdlib/` directories.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\nmake DEPS_GIT='Pkg Tar Downloads'\n```\n\n----------------------------------------\n\nTITLE: Starting Julia with Distributed Processes and Performing Remote Calls - Julia (REPL)\nDESCRIPTION: This snippet shows how to start Julia with multiple worker processes using the -p flag and how to use remotecall and @spawnat to execute functions on remote workers. The example creates a 2x2 random matrix on a specific worker, adds 1 to all its values, and fetches the result. Required dependency is the Distributed standard module (loaded automatically by -p). The code demonstrates asynchronous execution and result retrieval via Futures; input parameters include function, process ID, and function arguments. Output consists of Futures and the resulting matrix.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_0\n\nLANGUAGE: julia-repl\nCODE:\n```\n$ julia -p 2\n\njulia> r = remotecall(rand, 2, 2, 2)\nFuture(2, 1, 4, nothing)\n\njulia> s = @spawnat 2 1 .+ fetch(r)\nFuture(2, 1, 5, nothing)\n\njulia> fetch(s)\n2×2 Matrix{Float64}:\n 1.18526  1.50912\n 1.16296  1.60607\n```\n\n----------------------------------------\n\nTITLE: Installing GCC via Homebrew on macOS\nDESCRIPTION: This command uses the Homebrew package manager (`brew`) to install the GNU Compiler Collection (GCC) on macOS. This step is necessary if you intend to build Julia's dependencies locally, as it provides the required 64-bit gfortran compiler. This is an alternative to the default method which uses BinaryBuilder to automatically download pre-built dependencies. Requires Homebrew to be installed first.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/macos.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install gcc\n```\n\n----------------------------------------\n\nTITLE: Connecting to Remote Host by Hostname with Sockets in Julia\nDESCRIPTION: This snippet establishes a TCP connection to a remote host using a hostname and port (here, google.com:80). It demonstrates the string-based connect API for hostname resolution. Dependencies: Sockets and DNS resolution working in the environment. Input: Hostname string and TCP port. Output: A TCPSocket connected to the specified server if the connection succeeds.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_15\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> connect(\"google.com\", 80)\nTCPSocket(RawFD(30) open, 0 bytes waiting)\n```\n\n----------------------------------------\n\nTITLE: Illustrating CPU Profiler Limitations with Channel Contention in Julia\nDESCRIPTION: Presents a Julia example using `Base.Threads` and `Profile` to simulate tasks waiting on a channel (`ch`). It defines functions `spawn_a_bunch_of_tasks_waiting_on_channel`, `busywait`, and `main`. The standard `@profile` macro is used on `main()`, demonstrating that the default CPU sampling profiler struggles to capture time spent by tasks blocked on synchronization primitives like channels, as they are not actively running on a CPU thread when sampled.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.Threads\nusing Profile\nusing PProf\n\nch = Channel(1)\n\nconst N_SPAWNED_TASKS = (1 << 10)\nconst WAIT_TIME_NS = 10_000_000\n\nfunction spawn_a_bunch_of_tasks_waiting_on_channel()\n    for i in 1:N_SPAWNED_TASKS\n        Threads.@spawn begin\n            take!(ch)\n        end\n    end\nend\n\nfunction busywait()\n    t0 = time_ns()\n    while true\n        if time_ns() - t0 > WAIT_TIME_NS\n            break\n        end\n    end\nend\n\nfunction main()\n    spawn_a_bunch_of_tasks_waiting_on_channel()\n    for i in 1:N_SPAWNED_TASKS\n        put!(ch, i)\n        busywait()\n    end\nend\n\nProfile.@profile main()\n```\n\n----------------------------------------\n\nTITLE: Defining RISC-V Architecture and CPU for Julia Build - make\nDESCRIPTION: Sets the specific RISC-V architecture (MARCH) and target CPU (MCPU) for optimized builds of Julia in Make.user, ensuring correct configuration for devices like the SiFive U74. These variables guide the Julia and system compilers regarding instruction sets and CPU extensions. Key parameters: MARCH defines instruction set (e.g., 'rv64gc_zba_zbb' for extended feature support), MCPU optionally further optimizes for a specific CPU ('sifive-u74'). Supported values can be found via 'gcc -march=help' and 'gcc --target-help'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/riscv.md#_snippet_1\n\nLANGUAGE: make\nCODE:\n```\nMARCH := rv64gc_zba_zbb\nMCPU := sifive-u74\n```\n\n----------------------------------------\n\nTITLE: Creating Built-in Julia Type Objects in C\nDESCRIPTION: This C code snippet, part of `jl_init_types()` in `src/jltypes.c`, demonstrates how fundamental Julia types (`Any`, `Type`, `Int32`) are instantiated as `jl_datatype_t` objects during runtime initialization using internal C API functions like `jl_new_abstracttype` and `jl_new_primitivetype`. This process establishes the core type hierarchy and requires definitions from `julia.h`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/init.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\njl_any_type = jl_new_abstracttype(jl_symbol(\"Any\"), core, NULL, jl_emptysvec);\njl_any_type->super = jl_any_type;\n\njl_type_type = jl_new_abstracttype(jl_symbol(\"Type\"), core, jl_any_type, jl_emptysvec);\n\njl_int32_type = jl_new_primitivetype(jl_symbol(\"Int32\"), core,\n                                     jl_any_type, jl_emptysvec, 32);\n```\n\n----------------------------------------\n\nTITLE: Enabling DTrace Probes - Makefile Configuration - Bash\nDESCRIPTION: This snippet shows how to enable DTrace (USDT probes) support in Julia by specifying a build configuration in a Makefile. The presence of WITH_DTRACE=1 in Make.user enables probe generation. No prerequisites required apart from access to the Julia build system. Used at build time for instrumentation support.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nWITH_DTRACE=1\n```\n\n----------------------------------------\n\nTITLE: Controlling libstdc++ Loading Behavior in Julia via Environment Variable (Bash)\nDESCRIPTION: Sets the `JULIA_PROBE_LIBSTDCXX` environment variable to `0`. This forces Julia on Linux to load its bundled libstdc++ library, disabling the default behavior of auto-detecting and potentially using a newer system library. This restores the behavior prior to issue #46976.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nJULIA_PROBE_LIBSTDCXX=0\n```\n\n----------------------------------------\n\nTITLE: Configuring Julia Build with Tracy and Callstack Sampling (Make)\nDESCRIPTION: These lines are configuration options intended for the `Make.user` file when building Julia from source. Setting `WITH_TRACY := 1` enables the integration with the Tracy profiler. Setting `WITH_TRACY_CALLSTACKS := 1` additionally enables call stack sampling during profiling, which provides more detailed traces but significantly increases trace file size and profiling overhead. `USE_BINARYBUILDER_LIBTRACYCLIENT := 0` forces the build system to compile the `libTracyClient` library locally instead of using a pre-built binary, which might be necessary for the callstack feature to work correctly.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/external_profilers.md#_snippet_4\n\nLANGUAGE: make\nCODE:\n```\nWITH_TRACY := 1\nWITH_TRACY_CALLSTACKS := 1\nUSE_BINARYBUILDER_LIBTRACYCLIENT := 0\n\n```\n\n----------------------------------------\n\nTITLE: Defining a promote_rule for Float Types in Julia\nDESCRIPTION: Provides an example of defining a specific promotion rule using `promote_rule`. This rule specifies that when `Float64` and `Float32` types are promoted together, the result should be `Float64`. Requires importing `promote_rule` from `Base`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nimport Base: promote_rule\npromote_rule(::Type{Float64}, ::Type{Float32}) = Float64\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables via Julia REPL and Configuration File - Julia\nDESCRIPTION: This snippet demonstrates how to set the JULIA_EDITOR environment variable to 'vim' in a Julia session using the ENV dictionary, either for a single session or by adding it to the user's startup.jl configuration file for persistence. No external dependencies are required. The code expects the user to provide the desired environment variable and value as shown; it will apply immediately within the current Julia process, or persist across sessions if placed in the startup.jl file.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/environment-variables.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nENV[\"JULIA_EDITOR\"] = \"vim\"\n```\n\n----------------------------------------\n\nTITLE: Timing Array Computations with and without Preallocation - Base Julia - Julia\nDESCRIPTION: Presents timing outputs to compare the performance and memory allocation of the preallocated versus non-preallocated versions of the preceding array processing functions. Utilizes the `@time` macro to gather timing and allocation statistics, revealing substantial memory and time savings due to preallocation. The output demonstrates real-world impact in Julia's REPL.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_44\n\nLANGUAGE: julia\nCODE:\n```\njulia> @time loopinc()\n  0.297454 seconds (200.00 k allocations: 2.239 GiB, 39.80% gc time)\n5000250000\n\njulia> @time loopinc_prealloc()\n  0.009410 seconds (2 allocations: 23.477 KiB)\n5000250000\n```\n\n----------------------------------------\n\nTITLE: Debugging the Subtype Algorithm via Custom Breakpoint - Julia REPL - Julia\nDESCRIPTION: Defines a temporary function mysubtype which triggers a native C breakpoint before performing a subtype check. This is useful for stepping into Julia's subtype machinery using a C debugger. Dependencies: Julia build with debug symbols; Inputs: types a, b; Outputs: Boolean subtype result. Aids in in-depth debugging of Julia type internals.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_17\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> function mysubtype(a,b)\n           ccall(:jl_breakpoint, Cvoid, (Any,), nothing)\n           a <: b\n       end\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Covariance in Julia Tuple Types\nDESCRIPTION: Checks subtype relationships between different tuple types, emphasizing the covariance of tuple types in Julia. Tuple{Int,AbstractString} is a subtype of Tuple{Real,Any}, but not Tuple{Real,Real} or Tuple{Real,}, since tuple subtyping is positional and covariant only on element types. No external dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_40\n\nLANGUAGE: julia\nCODE:\n```\njulia> Tuple{Int,AbstractString} <: Tuple{Real,Any}\ntrue\n\njulia> Tuple{Int,AbstractString} <: Tuple{Real,Real}\nfalse\n\njulia> Tuple{Int,AbstractString} <: Tuple{Real,}\nfalse\n```\n\n----------------------------------------\n\nTITLE: Documenting Arguments in Function Docstring - Julia - Julia\nDESCRIPTION: This code block shows how to list function arguments, types, and default values in a Julia docstring section under # Arguments. The snippet catalogs required and optional parameters for clarity, optionally mentioning default values. This format helps users quickly understand usage requirements and defaults for a complex function interface.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\n...\n# Arguments\n- `n::Integer`: the number of elements to compute.\n- `dim::Integer=1`: the dimensions along which to perform the computation.\n...\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Fetching Data from a Remote Future Using remotecall_fetch - Julia (REPL)\nDESCRIPTION: This snippet demonstrates the use of remotecall_fetch to directly retrieve the (1,1) element from a remote random matrix previously computed and stored in a Future. remotecall_fetch efficiently executes the fetch operation on the remote worker and returns the value without transferring unnecessary data. It requires the Distributed module. Inputs include a lambda function, target worker ID, and the remote Future. Outputs are scalar values from the original data structure.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_1\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> remotecall_fetch(r-> fetch(r)[1, 1], 2, r)\n0.18526337335308085\n```\n\n----------------------------------------\n\nTITLE: Defining a Parametric Struct with Default Constructor in Julia\nDESCRIPTION: This snippet defines a parametric struct `SummedArray{T<:Number, S<:Number}` which stores a `Vector{T}` and its sum of type `S`. It demonstrates the default constructor automatically generated by Julia when no inner constructors are explicitly defined. The example shows constructing an instance with `Int32` for both `T` and `S`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_24\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct SummedArray{T<:Number,S<:Number}\n           data::Vector{T}\n           sum::S\n       end\n\njulia> SummedArray(Int32[1; 2; 3], Int32(6))\nSummedArray{Int32, Int32}(Int32[1, 2, 3], 6)\n```\n\n----------------------------------------\n\nTITLE: Creating Arrays of Heterogeneous Types - julia\nDESCRIPTION: Contrasts non-idiomatic and idiomatic ways of creating a heterogeneous array. Shows that using Vector{Union{...}} is unnecessarily complex and recommends using Vector{Any} for such cases, which is clearer and gives better guidance to the compiler. Inputs: n (array length); outputs: array a capable of holding elements of any type. Depends on Julia's Vector type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\na = Vector{Union{Int,AbstractString,Tuple,Array}}(undef, n)\n```\n\n----------------------------------------\n\nTITLE: Specializing Sampler Creation for Scalar vs. Array Generation in Julia\nDESCRIPTION: Shows how to define multiple methods for the `Sampler` constructor to provide different sampler implementations based on the expected usage (generating a single value vs. many values). It uses dispatch on the third parameter, `Val{1}` for single values (returning `SamplerDie1`) and `Val{Inf}` for multiple values (returning `SamplerDieMany`), allowing algorithm optimization based on the number of samples requested. Assumes `Die`, `SamplerDie1`, `SamplerDieMany` types and their corresponding `rand` methods are defined.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nSampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{1}) = SamplerDie1(...)\nSampler(RNG::Type{<:AbstractRNG}, die::Die, ::Val{Inf}) = SamplerDieMany(...)\n```\n\n----------------------------------------\n\nTITLE: Extending Methods Using Qualified Names in Julia\nDESCRIPTION: Demonstrates one way to add a method to a function from another module: by qualifying the function name with the module name (`NiceStuff.nice`). This works even if the module was brought into scope with `using .NiceStuff`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_11\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using .NiceStuff\n\njulia> struct Cat end\n\njulia> NiceStuff.nice(::Cat) = \"nice 😸\"\n```\n\n----------------------------------------\n\nTITLE: Loading a Local Julia Module with `using`\nDESCRIPTION: Shows how to load a locally defined module (indicated by the leading dot `.`) named `NiceStuff` using the `using` keyword in a `jldoctest` context. This action loads the module's code, brings the module name `NiceStuff` itself into the current scope, and imports all names listed in the module's `export` list (`nice` and `DOG` from the previous example).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using .NiceStuff\n```\n\n----------------------------------------\n\nTITLE: Initializing and Parsing Expressions with Meta.parse in Julia\nDESCRIPTION: Demonstrates how to initialize a program as a string and parse it into an Expr object using Meta.parse. The parsed expression can then be inspected and manipulated, which is foundational for metaprogramming in Julia. Requires the Julia language’s base modules; inputs are code strings, and outputs are Expr objects representing code structure.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> prog = \"1 + 1\"\n\"1 + 1\"\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> ex1 = Meta.parse(prog)\n:(1 + 1)\n\njulia> typeof(ex1)\nExpr\n```\n\n----------------------------------------\n\nTITLE: Adding Weak/Extra Dependencies via Pkg REPL\nDESCRIPTION: Shows the command-line syntax within the Julia Pkg REPL mode (`pkg>`) to add a package (`Foo`) as either a weak dependency (`--weak`) or an extra dependency (`--extra`). This allows specifying dependency types directly during addition. Requires the Pkg manager.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npkg> add --weak/extra Foo\n```\n\n----------------------------------------\n\nTITLE: Using a Callable Polynomial Object in Julia\nDESCRIPTION: Shows how to instantiate and use the `Polynomial` functor defined previously. An instance `poly` is created, and then called with an argument `poly(3)` to evaluate the polynomial at x=3, and without arguments `poly()` to use the defined zero-argument method (evaluating at x=5).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\njulia> poly = Polynomial([1,10,100])\nPolynomial{Int64}([1, 10, 100])\n\njulia> poly(3)\n931\n\njulia> poly()\n2551\n```\n\n----------------------------------------\n\nTITLE: Idiom: Grouping Multiple Scoped Values in a Struct in Julia\nDESCRIPTION: Presents an idiom for managing multiple related configuration settings. Instead of creating many individual `ScopedValue`s, a struct (`Configuration`) holds the settings, and a single `ScopedValue` (`CONFIG`) holds an instance of this struct. Modifications within a dynamic scope involve creating a new `Configuration` instance.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.ScopedValues\n\nBase.@kwdef struct Configuration\n    color::Bool = false\n    verbose::Bool = false\nend\n\nconst CONFIG = ScopedValue(Configuration(color=true))\n\n@with CONFIG => Configuration(color=CONFIG[].color, verbose=true) begin\n    @show CONFIG[].color # true\n    @show CONFIG[].verbose # true\nend\n```\n\n----------------------------------------\n\nTITLE: Concatenating Strings Using the string() Function in Julia\nDESCRIPTION: Demonstrates basic string concatenation in Julia using the `string()` function. It takes multiple arguments (variables `greet`, `whom`, and string literals \", \", \".\\n\") and combines them into a single output string.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_22\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> greet = \"Hello\"\n\"Hello\"\n\njulia> whom = \"world\"\n\"world\"\n\njulia> string(greet, \", \", whom, \".\\n\")\n\"Hello, world.\\n\"\n```\n\n----------------------------------------\n\nTITLE: Calling a C Shared Library Function by Path from Julia\nDESCRIPTION: This Julia REPL snippet shows how to use @ccall to invoke a specific function from a shared library by path. The example assumes the shared object (e.g., mylib.so) has been built from a compatible C source. Users must provide an absolute or relative library path and ensure the function signature matches the library's API.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> @ccall \"./mylib.so\".say_y(5::Cint)::Cvoid\nHello from C: got y = 5.\n```\n\n----------------------------------------\n\nTITLE: Splatting Interpolation with $(...) in Julia\nDESCRIPTION: Illustrates how to use the splatting interpolation syntax $(xs...) to inject multiple expressions as arguments into a quoted expression, a technique essential for programmatically constructing function calls with dynamic arity. Requires an array of expressions; output is an Expr that includes all splatted symbols.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> args = [:x, :y, :z];\n\njulia> :(f(1, $(args...)))\n:(f(1, x, y, z))\n```\n\n----------------------------------------\n\nTITLE: Defining a Monte Carlo Simulation Function in Julia\nDESCRIPTION: This function, 'count_heads', simulates flipping a coin 'n' times and counts the number of heads (true random bits). It accumulates the result in an integer counter. Requires Julia's base 'rand' function and expects an integer input. Returns the total number of heads as an integer. No dependencies other than Julia standard library.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nfunction count_heads(n)\n    c::Int = 0\n    for i = 1:n\n        c += rand(Bool)\n    end\n    c\nend\n```\n\n----------------------------------------\n\nTITLE: Comparing `exp` and `expm` in Julia and MATLAB\nDESCRIPTION: In MATLAB, `exp(A)` is element-wise and `expm(A)` is the matrix exponential. In Julia, `exp.(A)` (with a dot) is element-wise, and `exp(A)` (without a dot) is the matrix exponential.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_17\n\nLANGUAGE: matlab\nCODE:\n```\nexp(A)  % MATLAB: Element-wise\n```\n\nLANGUAGE: matlab\nCODE:\n```\nexpm(A) % MATLAB: Matrix exponential\n```\n\nLANGUAGE: julia\nCODE:\n```\nexp.(A) # Julia: Element-wise (note the dot)\n```\n\nLANGUAGE: julia\nCODE:\n```\nexp(A)  # Julia: Matrix exponential\n```\n\n----------------------------------------\n\nTITLE: Listing Threads in GDB for Julia Debugging\nDESCRIPTION: Displays all active threads within the Julia process currently being debugged using GDB. This command is essential when GDB might be attached to an incorrect thread, helping to identify the correct thread for examining the backtrace.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/windows.md#_snippet_0\n\nLANGUAGE: gdb\nCODE:\n```\ninfo threads\n```\n\n----------------------------------------\n\nTITLE: Performing System-Wide Julia Install via MSI on Windows\nDESCRIPTION: Executes the Windows Installer (msiexec) to perform a system-wide installation of Julia using an MSI package file. The '/i' flag specifies installation, '<PATH_TO_JULIA_MSI>' should be replaced with the actual path to the downloaded MSI file, and 'ALLUSERS=1' triggers a per-machine (system-wide) installation requiring administrator privileges. This method is generally not recommended due to limitations like lack of auto-updates.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/installation.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nmsiexec /i <PATH_TO_JULIA_MSI> ALLUSERS=1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Local vs Remote Channel Object Semantics in Julia\nDESCRIPTION: Demonstrates the difference in behavior between storing and retrieving objects in a locally-owned RemoteChannel versus a remotely-owned one. Using Distributed, it shows how repeated 'put!' of a modified array object to a local RemoteChannel always returns the same object by reference, whereas with a remote RemoteChannel, copies are made for each put. Outputs include object instance identity checks using objectid. Key parameters are the channel's location and the data object; ensure the correct number of processes (local and remote) is available for tests.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\njulia> using Distributed\n\njulia> rc = RemoteChannel(() -> Channel(3));   # RemoteChannel created on local node\n\njulia> v = [0];\n\njulia> for i in 1:3\n           v[1] = i                          # Reusing `v`\n           put!(rc, v)\n       end;\n\njulia> result = [take!(rc) for _ in 1:3];\n\njulia> println(result);\n[[3], [3], [3]]\n\njulia> println(\"Num Unique objects : \", length(unique(map(objectid, result))));\nNum Unique objects : 1\n\njulia> addprocs(1);\n\njulia> rc = RemoteChannel(() -> Channel(3), workers()[1]);   # RemoteChannel created on remote node\n\njulia> v = [0];\n\njulia> for i in 1:3\n           v[1] = i\n           put!(rc, v)\n       end;\n\njulia> result = [take!(rc) for _ in 1:3];\n\njulia> println(result);\n[[1], [2], [3]]\n\njulia> println(\"Num Unique objects : \", length(unique(map(objectid, result))));\nNum Unique objects : 3\n```\n\n----------------------------------------\n\nTITLE: Function Return Values in Julia\nDESCRIPTION: Functions in Julia implicitly return the value of the last expression evaluated, or explicitly using the `return` keyword. This differs from MATLAB's approach of listing return variables in the function signature.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nreturn value\n```\n\n----------------------------------------\n\nTITLE: Using Println for Atomic Output in Concurrent Asynchronous Operations in Julia\nDESCRIPTION: Similar to the previous `write` example, this Julia snippet spawns three concurrent tasks using `@sync` and `Threads.@spawn`. However, it uses `println` instead of `write`. The output shows that each line is printed atomically without interleaving, demonstrating that `println` locks the output stream (`stdout`) for the duration of its call. It depends on the `Threads` module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_34\n\nLANGUAGE: julia\nCODE:\n```\njulia> @sync for i in 1:3\n           Threads.@spawn println(stdout, string(i), \" Foo \", \" Bar \")\n       end\n1 Foo  Bar\n2 Foo  Bar\n3 Foo  Bar\n```\n\n----------------------------------------\n\nTITLE: Checking Linear Indexing Support for SubArrays in Julia\nDESCRIPTION: Uses the internal function `Base.viewindexing` to determine the indexing capabilities based on the types of indices stored in `S1` and `S2`. The output shows `IndexCartesian()` for `S1` and `IndexLinear()` for `S2`, indicating that `S2` supports fast linear indexing while `S1` does not, based solely on the index types. This result is stored in the `L` type parameter of the `SubArray`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest subarray\njulia> Base.viewindexing(S1.indices)\nIndexCartesian()\n\njulia> Base.viewindexing(S2.indices)\nIndexLinear()\n```\n```\n\n----------------------------------------\n\nTITLE: Evaluating Broadcasted Operations - Julia\nDESCRIPTION: This snippet demonstrates how to explicitly realize a broadcasted (fused) operation in Julia using the copy function. Instead of relying on implicit parser fusion, the 'Broadcasted' object is made explicit and evaluated with 'copy' or 'copyto!'. This change allows for greater control when customizing broadcasted operations in Julia packages. The input is an existing 'Broadcasted' object; outputs are the result of evaluated broadcast.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_145\n\nLANGUAGE: julia\nCODE:\n```\ncopy(bc::Broadcasted)\n```\n\n----------------------------------------\n\nTITLE: Improper Constructor and Method Definitions - Type Consistency Pitfalls - Julia - julia\nDESCRIPTION: Illustrates coding anti-patterns related to Julia constructor and conversion method definitions which violate the expectation that T(x) returns an instance of type T. This code demonstrates how improper definition of constructors and conversions can return unexpected types, leading to type confusion. The provided examples require only the Base module and are intended as warnings of what not to implement.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nstruct Foo{T}\n    x::T\nend\n\nBase.Float64(foo::Foo) = Foo(Float64(foo.x))  # Do not define methods like this\n\nFloat64(Foo(3))  # Should return `Float64`\nFoo{Float64}(3.0)\n\nFoo{Int}(x) = Foo{Float64}(x)  # Do not define methods like this\n\nFoo{Int}(3)  # Should return `Foo{Int}`\nFoo{Float64}(3.0)\n\n```\n\n----------------------------------------\n\nTITLE: Calculating `cis(pi * x)` Accurately with `cispi` in Julia\nDESCRIPTION: The `cispi(x)` function computes `cis(pi * x)`, which is equivalent to `exp(im * pi * x)` or `cospi(x) + im*sinpi(x)`. It aims for higher accuracy than computing the expression manually, especially for arguments where range reduction is critical.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_67\n\nLANGUAGE: julia\nCODE:\n```\nval = cispi(0.5) # Computes cis(pi * 0.5) = exp(i*pi*0.5) = cos(pi*0.5) + i*sin(pi*0.5)\n```\n\n----------------------------------------\n\nTITLE: Configuring Table of Contents Generation\nDESCRIPTION: This snippet uses the `@contents` directive within Julia's documentation system (Documenter.jl) to automatically generate a table of contents for the 'performance-tips.md' page. It specifies that the table should include headings up to a depth of 3.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n```@contents\nPages = [\"performance-tips.md\"]\nDepth = 3\n```\n```\n\n----------------------------------------\n\nTITLE: Linker Error Example Emitted by ld (ld)\nDESCRIPTION: Shows a sample linker error where a required library file is missing. This is output from the linker and not a code command. Indicates the need for updated build tools or headers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_14\n\nLANGUAGE: ld\nCODE:\n```\nld: library not found for -lcrt1.10.6.o\n\n```\n\n----------------------------------------\n\nTITLE: Thread-Safe System I/O Operations in Julia\nDESCRIPTION: All system-level I/O operations (like files and sockets) are now thread-safe in Julia v1.3. This excludes purely in-memory IO types like `IOBuffer` but includes `BufferStream`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_105\n\n\n\n----------------------------------------\n\nTITLE: Calculating `sinpi` and `cospi` Efficiently with `sincospi` in Julia\nDESCRIPTION: The new function `sincospi(x)` computes both `sinpi(x)` (sin(πx)) and `cospi(x)` (cos(πx)) simultaneously. This can be more efficient than calling `sinpi` and `cospi` separately, especially when both values are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_66\n\nLANGUAGE: julia\nCODE:\n```\ns, c = sincospi(0.25) # s = sin(pi*0.25), c = cos(pi*0.25)\n```\n\n----------------------------------------\n\nTITLE: Defining a Julia Module with Included Files\nDESCRIPTION: Demonstrates the standard syntax for defining a Julia module (`module ... end`) and a common pattern of using `include(\"file.jl\")` within the module block to incorporate code from external files. This organizes larger packages by separating code into manageable units while keeping them within the same module namespace.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nmodule SomeModule\n\n# export, public, using, import statements are usually here; we discuss these below\n\ninclude(\"file1.jl\")\ninclude(\"file2.jl\")\n\nend\n```\n\n----------------------------------------\n\nTITLE: Analyzing Exception-Induced Escapes in Julia - Julia\nDESCRIPTION: This code demonstrates escape scenarios where the rethrowing or assignment of exception objects causes referenced values to escape their lexical scope. The example uses references (Refs), try/catch blocks, and global assignment in a function context to illustrate how EscapeAnalysis must propagate escape information by reasoning about exception paths. Dependencies include Julia Base and an assumed utility environment (EAUtils). Key parameters are the reference objects and the values thrown or caught in try/catch. Inputs are typically string or reference types, and outputs indicate which objects have potentially escaped. Limitations arise from the conservative approach required to handle all indirect exception escape routes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nconst GR = Ref{Any}();\n@noinline function rethrow_escape!()\n    try\n        rethrow()\n    catch err\n        GR[] = err\n    end\nend;\nget′(x) = isassigned(x) ? x[] : throw(x);\n\ncode_escapes() do\n    r = Ref{String}()\n    local t\n    try\n        t = get′(r)\n    catch err\n        t = typeof(err)   # `err` (which `r` aliases to) doesn't escape here\n        rethrow_escape!() # but `r` escapes here\n    end\n    return t\nend\n```\n\n----------------------------------------\n\nTITLE: Simplified Channel Constructor in Julia\nDESCRIPTION: The `Channel` constructor has been simplified. Using the `csize` and `ctype` keyword arguments is now discouraged in favor of more idiomatic Julia usage.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_108\n\nLANGUAGE: julia\nCODE:\n```\nChannel(f::Function)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Whitespace Stripping in Julia Triple-Quoted Strings\nDESCRIPTION: Illustrates the behavior of whitespace stripping in Julia triple-quoted string literals as of v1.5. Whitespace stripping now occurs *before* escape sequence processing. This example, which previously yielded \" a\\nb\", now correctly results in \"a\\n b\" because the space before 'b' is no longer considered indentation.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_81\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\n  a\\n b\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Overwriting Constructor Methods in Julia\nDESCRIPTION: This snippet defines a simple struct `S` and then defines two zero-argument constructor methods. The first uses the standard `S() = S(7)` syntax. The second uses the function-like object syntax `(::Type{S})() = S(8)`. It demonstrates that these syntaxes define methods for the same callable object (the type `S`) and that the second definition overwrites the first, resulting in `S()` calling the second definition and returning `S(8)`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_27\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct S\n           f::Int\n       end\n\njulia> S() = S(7)\nS\n\njulia> (::Type{S})() = S(8)  # overwrites the previous constructor method\n\njulia> S()\nS(8)\n```\n\n----------------------------------------\n\nTITLE: Adding Unicode Suffixes to Postfix Transpose Operator in Julia\nDESCRIPTION: The postfix conjugate transpose operator `'` now permits Unicode modifiers as suffixes (e.g., `a'ᵀ`). This syntax parses as a function call like `var\"'ᵀ\"(a)`, allowing user definition. This is a minor breaking change, as `a'ᵀ` previously parsed as `a' * ᵀ`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_56\n\nLANGUAGE: julia\nCODE:\n```\na = [1 2; 3 4]\nx = a'ᵀ # Parses as var\"'ᵀ\"(a)\n```\n\n----------------------------------------\n\nTITLE: Applying `@inline`/`@noinline` at Julia Callsites or Blocks\nDESCRIPTION: Explains that `@inline` and `@noinline` can be applied to a function call or a block of code at the callsite in Julia v1.8. This enforces that function calls within that specific scope should be (or should not be) inlined by the compiler.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\n@inline call()\n```\n\nLANGUAGE: julia\nCODE:\n```\n@noinline begin ... end\n```\n\n----------------------------------------\n\nTITLE: Function Scope GC Root Promises for Julia C Extensions (C)\nDESCRIPTION: Shows usage of JL_GC_PROMISE_ROOTED as an escape hatch within a C function body to inform the analyzer that a value is rooted for the function's duration. In this illustrative function, jl_value_t *val is conditionally promised as rooted—useful for advanced users handling external GC guarantees. Dependencies: Julia's header files and macros. Key parameter: val, the pointer being promised as rooted for GC analysis. Output: none, but informs static analysis. Caution: should be reserved for advanced or exceptional cases, as misuse could result in GC safety issues.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-sa.md#_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nvoid example() {\n  jl_value_t *val = jl_alloc_something();\n  if (some_condition) {\n    // We happen to know for complicated external reasons\n    // that val is rooted under these conditions\n    JL_GC_PROMISE_ROOTED(val);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Short-Circuit Evaluation with && and || in Julia\nDESCRIPTION: Defines two functions, `t(x)` (prints x, returns true) and `f(x)` (prints x, returns false), and uses them to illustrate how `&&` only evaluates the second operand if the first is true, and `||` only evaluates the second operand if the first is false. The output shows which function calls are executed based on this short-circuit behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_12\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> t(x) = (println(x); true)\nt (generic function with 1 method)\n\njulia> f(x) = (println(x); false)\nf (generic function with 1 method)\n\njulia> t(1) && t(2)\n1\n2\ntrue\n\njulia> t(1) && f(2)\n1\n2\nfalse\n\njulia> f(1) && t(2)\n1\nfalse\n\njulia> f(1) && f(2)\n1\nfalse\n\njulia> t(1) || t(2)\n1\ntrue\n\njulia> t(1) || f(2)\n1\ntrue\n\njulia> f(1) || t(2)\n1\n2\ntrue\n\njulia> f(1) || f(2)\n1\n2\nfalse\n```\n\n----------------------------------------\n\nTITLE: Equivalent Expanded Nested Loops for Array Summation - Julia\nDESCRIPTION: This snippet shows the explicit form of the three nested for-loops generated by the @nloops macro. It illustrates the complete structure where each loop iterates over a single axis of array A, summing elements using the generated indices i_1, i_2, and i_3. This pattern is useful for understanding what the macro-generated code looks like, especially for debugging or performance analysis.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/cartesian.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nfor i_3 = axes(A, 3)\\n    for i_2 = axes(A, 2)\\n        for i_1 = axes(A, 1)\\n            s += A[i_1, i_2, i_3]\\n        end\\n    end\\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a LocalManager ClusterManager with Launch and Manage (Julia)\nDESCRIPTION: Shows the structure and methods required to implement a LocalManager, a subtype of ClusterManager for launching workers on the local host. The LocalManager stores the number of requested processes and supplies custom launch and manage implementations tailored to local worker instantiation and control. This pattern is used internally by Julia for multi-core or multi-processor circumstance. Dependencies include the ClusterManager abstract type and WorkerConfig structure. The struct expects an integer for process count, and the methods take Julia standard distributed arguments, with outputs communicated through arrays and condition synchronization.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_41\n\nLANGUAGE: julia\nCODE:\n```\nstruct LocalManager <: ClusterManager\n    np::Integer\nend\n\nfunction launch(manager::LocalManager, params::Dict, launched::Array, c::Condition)\n    [...]\nend\n\nfunction manage(manager::LocalManager, id::Integer, config::WorkerConfig, op::Symbol)\n    [...]\nend\n```\n\n----------------------------------------\n\nTITLE: Taking a Basic Heap Snapshot in Julia\nDESCRIPTION: This snippet shows how to use `Profile.take_heap_snapshot` to capture the state of Julia objects on the heap and save it to a specified file (`snapshot.heapsnapshot`). This file can then be analyzed using tools like Chrome DevTools. Requires the `Profile` module to be loaded.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Profile/docs/src/index.md#_snippet_2\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Profile\n\njulia> Profile.take_heap_snapshot(\"snapshot.heapsnapshot\")\n```\n\n----------------------------------------\n\nTITLE: Building Julia with a Single Git Stdlib Checkout using Make\nDESCRIPTION: This command instructs the Julia build system (using `make`) to use a local Git checkout of a specific standard library (e.g., Pkg) instead of the default version included in the source tree. The `NAME_OF_STDLIB` should correspond to the directory name within the `stdlib/` folder, and the respective repository should be cloned there.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\nmake DEPS_GIT=NAME_OF_STDLIB\n```\n\n----------------------------------------\n\nTITLE: Defining a Tuple-Like Composite Type in Julia\nDESCRIPTION: Defines Tuple2{A,B}, a composite type with two fields (a and b) parameterized by types A and B. Demonstrates the structural similarity between tuples and composite types, which is foundational to Julia's tuple type system. No dependencies are required outside Julia base types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\nstruct Tuple2{A,B}\n    a::A\n    b::B\nend\n```\n\n----------------------------------------\n\nTITLE: Extracting Collection Elements in Julia\nDESCRIPTION: Julia uses the splat operator `...` to unpack elements from any collection (like a Vector or Tuple) to be passed as individual arguments to a function like `vcat`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nvcat(A...)\n```\n\n----------------------------------------\n\nTITLE: Composing Functions from an Iterable using Splatting in Julia\nDESCRIPTION: Illustrates composing a sequence of functions contained within an iterable collection `fs` by using the splatting operator `...` with the composition operator `∘`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_92\n\nLANGUAGE: julia\nCODE:\n```\n∘(fs...)\n```\n\n----------------------------------------\n\nTITLE: Debugging UndefVarError for Remote Global Variable Access within Modules (Julia)\nDESCRIPTION: Illustrates an `UndefVarError` when attempting to access a global variable (`gvar`) defined within a module function (`Foo.foo`) during a remote call. Although the module `Foo` is defined on all workers using `@everywhere`, the `global gvar = \"Hello\"` assignment only occurs on the local node where `Foo.foo()` is initially called. The subsequent `remotecall_fetch(()->gvar, 2)` fails because `gvar` is not defined within `Main.Foo` on worker 2.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_28\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @everywhere module Foo\n           function foo()\n               global gvar = \"Hello\"\n               remotecall_fetch(()->gvar, 2)\n           end\n       end\n\njulia> Foo.foo()\nERROR: On worker 2:\nUndefVarError: `gvar` not defined in `Main.Foo`\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Defining promote_rule for BigInt and Other Types in Julia\nDESCRIPTION: Shows two examples of `promote_rule` definitions from Julia Base. The first rule promotes `BigInt` and `Float64` to `BigFloat`. The second rule promotes `BigInt` and `Int8` to `BigInt`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\npromote_rule(::Type{BigInt}, ::Type{Float64}) = BigFloat\npromote_rule(::Type{BigInt}, ::Type{Int8}) = BigInt\n```\n\n----------------------------------------\n\nTITLE: Defining Same-Type Boolean Functions Using Parametric Methods in Julia\nDESCRIPTION: Defines two methods for the 'same_type' function: one parametric, requiring its arguments to share a concrete type, and a second catch-all fallback. Demonstrates idiomatic function dispatch using type parameters and method overloading in Julia. Inputs are two values, output is a boolean indicating whether their types match; depends on Julia's method dispatch and generic function system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nsame_type(x::T, y::T) where {T} = true\nsame_type(x,y) = false\n```\n\nLANGUAGE: julia\nCODE:\n```\nsame_type(1, 2)\nsame_type(1, 2.0)\nsame_type(1.0, 2.0)\nsame_type(\"foo\", 2.0)\nsame_type(\"foo\", \"bar\")\nsame_type(Int32(1), Int64(2))\n```\n\n----------------------------------------\n\nTITLE: Creating and Running a Julia Argument-Printing Script (Bash)\nDESCRIPTION: This two-line snippet first creates a Julia script file (`script.jl`) containing code to print the script's filename (`PROGRAM_FILE`) and its command-line arguments (`ARGS`). The second line then executes this script using `julia`, passing `foo` and `bar` as arguments, demonstrating how `PROGRAM_FILE` and `ARGS` are populated when running a script file.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ echo 'println(PROGRAM_FILE); for x in ARGS; println(x); end' > script.jl\n$ julia script.jl foo bar\n```\n\n----------------------------------------\n\nTITLE: Changing Precision and Rounding for BigFloat Arithmetic in Julia\nDESCRIPTION: Illustrates how to control the default rounding mode and precision for BigFloat calculations using setprecision and setrounding, either globally or scoped to a block using do. These functions require Julia Base and affect all BigFloat calculations within their scope. Inputs are precision or rounding mode values along with BigFloat computations; outputs reflect the changed calculation results. Limitations include macro scoping effects that may be non-intuitive with @big_str. Precision is measured in bits, and rounding modes such as RoundUp and RoundDown are supported.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\njulia> setrounding(BigFloat, RoundUp) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.100000000000000000000000000000000000000000000000000000000000000000000000000003\n\njulia> setrounding(BigFloat, RoundDown) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.099999999999999999999999999999999999999999999999999999999999999999999999999986\n\njulia> setprecision(40) do\n           BigFloat(1) + parse(BigFloat, \"0.1\")\n       end\n1.1000000000004\n```\n\n----------------------------------------\n\nTITLE: Creating Recursive Additive Identity with zero() in Julia\nDESCRIPTION: Demonstrates the recursive behavior of `zero(::AbstractArray)` introduced in Julia. When applied to a nested array (like `[[1,2],[3,4,5]]`), it now recursively creates the additive identity element (zero) for each element, resulting in `[[0,0],[0,0,0]]` rather than erroring. This change applies to abstract arrays containing numbers.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nzero([[1,2],[3,4,5]])\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Infinite Recursion with Default Argument Cascade in Julia\nDESCRIPTION: This Julia snippet illustrates a problematic pattern where two method definitions for `myfilter` create an infinite recursion. The first method handles edge replication and calls `myfilter` again, while the second method provides a default `Replicate` argument, causing the first method to repeatedly call itself with ever-larger padded arrays.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_51\n\nLANGUAGE: julia\nCODE:\n```\nfunction myfilter(A, kernel, ::Replicate)\n    Apadded = replicate_edges(A, size(kernel))\n    myfilter(Apadded, kernel)  # now perform the \"real\" computation\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nmyfilter(A, kernel) = myfilter(A, kernel, Replicate()) # replicate the edge by default\n```\n\n----------------------------------------\n\nTITLE: Macro Expansion of Array Reference with @nref - Julia\nDESCRIPTION: This example uses Julia's @macroexpand tool to analyze how the @nref macro expands when used with two dimensions. It shows that @nref 2 A i expands to a standard array reference A[i_1, i_2]. Useful for debugging macro behavior and validating code generation, it requires importing Base.Cartesian: @nref. The input is typically an integer (number of dimensions), an array symbol, and an index variable prefix.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/cartesian.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> @macroexpand @nref 2 A i\\n:(A[i_1, i_2])\n```\n\n----------------------------------------\n\nTITLE: Example Lowered Keyword Call with Splatting via kwcall - Julia\nDESCRIPTION: Shows the lowered representation of a Julia function call with keyword arguments and splatting using kwcall. merge is used to combine named tuples for individual and splatted keyword pairs, enabling flexible and dynamic function invocation. This reflects how Julia desugars high-level keyword use at the compiler level.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nkwcall(merge((color = red,), other), circle, (0, 0), 1.0)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Loaded Packages Using the Callback - Julia REPL\nDESCRIPTION: Shows how to use a registered callback to track package loads interactively in Julia REPL. The snippet demonstrates loading a package (Example) and then querying the loaded_packages array to display which packages have been loaded. No external dependencies are needed beyond the prior callback registration; outputs include a vector of Base.PkgId objects.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/require.md#_snippet_1\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Example\n\njulia> loaded_packages\n1-element Vector{Base.PkgId}:\n Example [7876af07-990d-54b4-ab0e-23690620f79a]\n```\n\n----------------------------------------\n\nTITLE: Initializing C Library Pointers in Julia Module `__init__`\nDESCRIPTION: Illustrates defining an `__init__` function within a Julia module to handle runtime initialization required by external C libraries. It calls a C initialization function (`foo_init` from `libfoo`) using `ccall` and sets a global `Ref` constant (`foo_data_ptr`) with a pointer returned by another C function (`foo_data` from `libfoo`). This pattern is necessary because pointer values obtained from external libraries are determined at runtime and cannot be captured during module precompilation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\nconst foo_data_ptr = Ref{Ptr{Cvoid}}(0)\nfunction __init__()\n    ccall((:foo_init, :libfoo), Cvoid, ())\n    foo_data_ptr[] = ccall((:foo_data, :libfoo), Ptr{Cvoid}, ())\n    nothing\nend\n```\n\n----------------------------------------\n\nTITLE: Illustrating Julia `write` to Libuv Call Chain\nDESCRIPTION: Shows the conceptual call path when writing to a Julia standard stream object (like `Base.stdout`). Julia's `Base.write` method (defined in `stream.jl`) uses `ccall` to invoke the C wrapper function `jl_uv_write` (in `jl_uv.c`), which in turn calls the libuv library function `uv_write` to perform the actual asynchronous write operation on the underlying `uv_stream_t`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/stdio.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nstream.jl: function write(s::IO, p::Ptr, nb::Integer)\n               -> ccall(:jl_uv_write, ...)\n  jl_uv.c:          -> int jl_uv_write(uv_stream_t *stream, ...)\n                        -> uv_write(uvw, stream, buf, ...)\n```\n\n----------------------------------------\n\nTITLE: Defining @inline Macro for Compiler Hints - Julia\nDESCRIPTION: This snippet defines the @inline macro, which annotates Julia functions or expressions with an inline directive to the compiler by adding :inline to a :meta block. It uses esc() to ensure correct macro hygiene, and pushmeta! (from Base) to manage the metadata attachment. The macro expects an expression and handles insertion of :inline appropriately, requiring the Base.pushmeta! dependency. Main parameters: ex (Julia expression to annotate). Input is a function or expression; output is the same with an attached inline hint.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/meta.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nmacro inline(ex)\n    esc(isa(ex, Expr) ? pushmeta!(ex, :inline) : ex)\nend\n\n```\n\n----------------------------------------\n\nTITLE: Setting Generic RISC-V Target in Julia Makefile - make\nDESCRIPTION: Configures Julia to build for the generic rv64gc RISC-V architecture and specifies an expanded JULIA_CPU_TARGET for maximum portability. The MARCH variable sets the base RISC-V instruction set, while JULIA_CPU_TARGET explicitly lists supported extensions for use by the Julia build system. No prerequisites beyond a Make.user file. Users may leave MCPU unset for general compatibility.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/riscv.md#_snippet_2\n\nLANGUAGE: make\nCODE:\n```\nMARCH := rv64gc\n\n# also set JULIA_CPU_TARGET to the expanded form of rv64gc\n# (it normally copies the value of MCPU, which we don't set)\nJULIA_CPU_TARGET := generic-rv64,i,m,a,f,d,zicsr,zifencei,c\n```\n\n----------------------------------------\n\nTITLE: Expanded Representation of an @inline-Annotated Function - Julia\nDESCRIPTION: This snippet shows the macroexpanded form of a function decorated with @inline. The resulting code includes a function definition whose body starts with a :meta expression containing :inline, explicitly instructing the Julia compiler to apply the inlining optimization. The snippet illustrates how macros transform code structure. Input: macro-decorated function; Output: quoted function with embedded metadata.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/meta.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nquote\n    function myfunction(x)\n        Expr(:meta, :inline)\n        x*(x+3)\n    end\nend\n\n```\n\n----------------------------------------\n\nTITLE: Protecting Immutable Julia Objects Across C Scopes using Global IdDict and RefValue\nDESCRIPTION: Shows how to protect an *immutable* Julia object (`var`, e.g., a `Float64`) across C scopes using the global `IdDict` technique. Since the object is immutable, it's first wrapped in a mutable container (`Base.RefValue{Any}`) created using `jl_new_struct`. This wrapper (`rvar`) is then added to the global `IdDict` (`refs`) via `jl_call3` and `setindex!`. Temporary GC rooting (`JL_GC_PUSH1`) is used while creating the wrapper.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_19\n\nLANGUAGE: c\nCODE:\n```\n// This functions shall be executed only once, during the initialization.\njl_value_t* refs = jl_eval_string(\"refs = IdDict()\");\njl_function_t* setindex = jl_get_function(jl_base_module, \"setindex!\");\njl_datatype_t* reft = (jl_datatype_t*)jl_eval_string(\"Base.RefValue{Any}\");\n\n...\n\n// `var` is the variable we want to protect between function calls.\njl_value_t* var = 0;\n\n...\n\n// `var` is a `Float64`, which is immutable.\nvar = jl_eval_string(\"sqrt(2.0)\");\n\n// Protect `var` until we add its reference to `refs`.\nJL_GC_PUSH1(&var);\n\n// Wrap `var` in `RefValue{Any}` and push to `refs` to protect it.\njl_value_t* rvar = jl_new_struct(reft, var);\nJL_GC_POP();\n\njl_call3(setindex, refs, rvar, rvar);\n```\n\n----------------------------------------\n\nTITLE: Executing Summation Loop in REPL Showing Global Update (Julia)\nDESCRIPTION: Shows the execution of the summation loop within the Julia REPL (`jldoctest`). Because a global variable `s` is initialized before the loop, the assignment `s = t` inside the loop modifies the existing global `s`. The variable `t`, however, is created as local to the loop because no global `t` exists beforehand. Thus, the global `s` reflects the sum (55), while `t` remains undefined globally.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_12\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> s = 0 # global\n0\n\njulia> for i = 1:10\n           t = s + i # new local `t`\n           s = t # assign global `s`\n       end\n\njulia> s # global\n55\n\njulia> @isdefined(t) # global\nfalse\n```\n\n----------------------------------------\n\nTITLE: Deprecation of Infix Operator `$`: Use `⊻` or `xor` in Julia\nDESCRIPTION: The infix operator `$` for bitwise XOR is deprecated in Julia. Use the infix operator `⊻` (typed as `\\xor<tab>` or `\\veebar<tab>`) or the function form `xor(a, b)` instead.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_185\n\nLANGUAGE: julia\nCODE:\n```\n⊻\n```\n\nLANGUAGE: julia\nCODE:\n```\nxor\n```\n\n----------------------------------------\n\nTITLE: Scalar Broadcasting Behavior for IPAddr Subtypes in Julia\nDESCRIPTION: `IPAddr` subtypes (like `IPv4`, `IPv6`) now behave as scalars during broadcasting operations.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_121\n\nLANGUAGE: julia\nCODE:\n```\nip = IPv4(\"192.168.1.1\")\nips = [ip, ip]\nips .== ip # Broadcasts comparison\n```\n\n----------------------------------------\n\nTITLE: Using the Custom SquaresVector AbstractArray in Julia\nDESCRIPTION: Illustrates the usage of the previously defined `SquaresVector`. It shows instantiation, indexing (`s[s .> 8]`), and broadcasting operations (`+`, `sin.`), demonstrating that the custom type automatically inherits standard array functionalities like iteration and vectorized operations through the `AbstractArray` interface.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_15\n\nLANGUAGE: jldoctest squarevectype\nCODE:\n```\njulia> s = SquaresVector(4)\n4-element SquaresVector:\n  1\n  4\n  9\n 16\n\njulia> s[s .> 8]\n2-element Vector{Int64}:\n  9\n 16\n\njulia> s + s\n4-element Vector{Int64}:\n  2\n  8\n 18\n 32\n\njulia> sin.(s)\n4-element Vector{Float64}:\n  0.8414709848078965\n -0.7568024953079282\n  0.4121184852417566\n -0.2879033166650653\n```\n\n----------------------------------------\n\nTITLE: Using System-Dependent Integer Type Aliases in Julia\nDESCRIPTION: Demonstrates the `Int` and `UInt` type aliases in Julia. These aliases map to the system's native signed and unsigned integer types, respectively (`Int32`/`UInt32` on 32-bit systems, `Int64`/`UInt64` on 64-bit systems).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```julia-repl\n# 32-bit system:\njulia> Int\nInt32\njulia> UInt\nUInt32\n\n# 64-bit system:\njulia> Int\nInt64\njulia> UInt\nUInt64\n```\n```\n\n----------------------------------------\n\nTITLE: Inheritance of Dynamic Scopes by Tasks in Julia\nDESCRIPTION: Illustrates that dynamic scopes created with `with` are inherited by `Task`s spawned using `@spawn` at the moment of task creation. The example shows three concurrent tasks (the parent and two spawned children) observing different values (1, 2, and 3) for the same `ScopedValue` `scoped_val` based on the dynamic scope active when each task started or was spawned.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.ScopedValues\nimport Base.Threads: @spawn\n\nconst scoped_val = ScopedValue(1)\n@sync begin\n    with(scoped_val => 2)\n        @spawn @show scoped_val[] # 2\n    end\n    with(scoped_val => 3)\n        @spawn @show scoped_val[] # 3\n    end\n    @show scoped_val[] # 1\nend\n```\n\n----------------------------------------\n\nTITLE: Overloading Base.show for Custom Pretty-printing in Julia\nDESCRIPTION: Implements a custom Base.show method for the Polar type, rendering it in the format 'r * exp(Θim)' for enhanced readability. The method takes an IO stream and a Polar instance for flexible output to different destinations. This approach enables tailored string representations of user-defined types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_69\n\nLANGUAGE: julia\nCODE:\n```\nBase.show(io::IO, z::Polar) = print(io, z.r, \" * exp(\", z.Θ, \"im)\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function Unavailability on Remote Julia Workers\nDESCRIPTION: Shows defining a function `rand2` locally and successfully calling it. Then, attempts to execute `rand2` on any available worker using `@spawnat :any` and retrieve the result with `fetch`. This fails with an `UndefVarError` because `rand2` is not defined on the worker process by default.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_4\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> function rand2(dims...)\n           return 2*rand(dims...)\n       end\n\njulia> rand2(2,2)\n2×2 Matrix{Float64}:\n 0.153756  0.368514\n 1.15119   0.918912\n\njulia> fetch(@spawnat :any rand2(2,2))\nERROR: RemoteException(2, CapturedException(UndefVarError(Symbol(\"#rand2\"))))\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Recursive Function for Profiling and Example Profile Backtrace - Julia\nDESCRIPTION: Defines a simple recursive summation function (dumbsum) and a wrapper (dumbsum3), demonstrating how recursive calls appear in profile backtraces. No external packages are required, as the snippet focuses on illustrating recursion in profiling, with n as the recursion depth. Input is an integer (3), and outputs are stack traces when the function is profiled, clarifying the accumulation behavior in recursive code. The code requires the definitions to be in scope before profiling.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\ndumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)\ndumbsum3() = dumbsum(3)\n```\n\nLANGUAGE: julia\nCODE:\n```\ndumbsum3\n    dumbsum(3)\n        dumbsum(2)\n            dumbsum(1)\n```\n\n----------------------------------------\n\nTITLE: Defining Functions to Capture Stack Traces in Julia\nDESCRIPTION: Demonstrates defining simple functions (`example`, `child`, `parent`, `grandparent`) that call `stacktrace()` internally. It shows how the resulting stack trace reflects the call hierarchy, including the defined functions. The `@noinline` macro is used to prevent function inlining, ensuring distinct frames appear in the trace for `child` and `parent`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_1\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> example() = stacktrace()\nexample (generic function with 1 method)\n\njulia> example()\n7-element Array{Base.StackTraces.StackFrame,1}:\n example() at REPL[1]:1\n top-level scope\n eval at boot.jl:317 [inlined]\n[...]\n\njulia> @noinline child() = stacktrace()\nchild (generic function with 1 method)\n\njulia> @noinline parent() = child()\nparent (generic function with 1 method)\n\njulia> grandparent() = parent()\ngrandparent (generic function with 1 method)\n\njulia> grandparent()\n9-element Array{Base.StackTraces.StackFrame,1}:\n child() at REPL[3]:1\n parent() at REPL[4]:1\n grandparent() at REPL[5]:1\n[...]\n```\n\n----------------------------------------\n\nTITLE: Configuring Julia Bounds Checking via Command-Line Option (Bash)\nDESCRIPTION: Describes the `--check-bounds=yes|no|auto` command-line option for the Julia executable. This option controls whether array bounds checking is enforced (`yes`), disabled (`no`, respecting `@inbounds`), or follows the default behavior (`auto`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\n--check-bounds=yes|no|auto\n```\n\n----------------------------------------\n\nTITLE: Wrapping C Library Calls with Error Handling in Julia\nDESCRIPTION: This snippet illustrates how to encapsulate a @ccall invocation within a Julia function that validates results and raises exceptions on error, following best practices for robust handling of external C functions. The example wraps getenv to throw an exception if the environment variable is undefined. Users should ensure the required C library function is available and handle all error conditions as defined by the C API.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nfunction getenv(var::AbstractString)\n    val = @ccall getenv(var::Cstring)::Cstring\n    if val == C_NULL\n        error(\"getenv: undefined variable: \", var)\n    end\n    return unsafe_string(val)\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Legacy ios_t Streams in jl_uv_puts() in C\nDESCRIPTION: This C code snippet is part of the `jl_uv_puts()` function within `jl_uv.c`. It demonstrates a compatibility check for handling legacy `ios_t` streams originating from femtolisp's `ios.c` library. It checks if the stream's type field (`stream->type`) has a value outside the valid range for libuv handle types (`UV_HANDLE_TYPE_MAX`). If so, it casts the stream pointer to `ios_t*` and calls the legacy `ios_write` function, ensuring that calls like `jl_printf` can work even when passed an `ios_t` stream via `jl_static_show` from femtolisp.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/stdio.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nif (stream->type > UV_HANDLE_TYPE_MAX) {\n    return ios_write((ios_t*)stream, str, n);\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing First Element with `begin` Keyword in Julia\nDESCRIPTION: Shows the use of the `begin` keyword within square brackets `[]` to access the first element of an integer-indexed collection `a`. This syntax relies on the `firstindex(a)` function to determine the actual index.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_84\n\nLANGUAGE: julia\nCODE:\n```\na[begin]\n```\n\n----------------------------------------\n\nTITLE: Declaring Libuv Standard I/O Stream Pointers in C\nDESCRIPTION: Defines global C pointers (`JL_STDIN`, `JL_STDOUT`, `JL_STDERR`) in `julia.h` that wrap libuv streams (`uv_stream_t`) for standard input, output, and error. These serve as the runtime's C-level interface to stdio via the libuv library.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/stdio.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nuv_stream_t *JL_STDIN;\nuv_stream_t *JL_STDOUT;\nuv_stream_t *JL_STDERR;\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Event and Timer Types\nDESCRIPTION: This block uses the `@docs` directive to list types related to asynchronous events and timers in Julia. It includes the `Timer` type for scheduling delayed execution and the `AsyncCondition` type for asynchronous notifications.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.Timer(::Function, ::Real)\nBase.Timer\nBase.AsyncCondition\nBase.AsyncCondition(::Function)\n```\n```\n\n----------------------------------------\n\nTITLE: Assigning to All-Underscore Identifiers - Julia REPL - Julia\nDESCRIPTION: This snippet demonstrates the special write-only behavior of all-underscore variable names in Julia. Assignments are permitted, but any attempt to read back or use the value will result in a syntax error. This illustrates an important constraint for Julia variables and is suitable for documentation and error scenario demonstrations. No extra dependencies are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> x, ___ = size([2 2; 1 1])\\n(2, 2)\\n\\njulia> y = ___\\nERROR: syntax: all-underscore identifiers are write-only and their values cannot be used in expressions\\n\\njulia> println(___)\\nERROR: syntax: all-underscore identifiers are write-only and their values cannot be used in expressions\n```\n\n----------------------------------------\n\nTITLE: Creating a System Image with the Old LLVM Pass Manager (Bash)\nDESCRIPTION: This sequence compiles an optimized system image from unoptimized LLVM IR using the llc code generator and the system compiler. It expects opt.bc as optimized bytecode and outputs a shared object sys.so usable by Julia. The commands should be run in the correct order, with intermediate files managed appropriately.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nllc -o sys.o opt.bc\ncc -shared -o sys.so sys.o\n```\n\n----------------------------------------\n\nTITLE: Executing Code in the Latest World Age in Julia\nDESCRIPTION: Highlights the use of `Base.invokelatest`. This function is necessary when code (especially within new Tasks created by `@spawn`, `@async`, etc.) needs to execute using methods defined in the global latest world age, rather than the world age inherited from the parent task (the default behavior from v1.8 onwards).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\nBase.invokelatest\n```\n\n----------------------------------------\n\nTITLE: Accessing C Flexible Array Member Data in Julia\nDESCRIPTION: Demonstrates how to access data within a C struct that uses a flexible array member (like `struct String`) from Julia. It involves obtaining a pointer to the struct, loading the length field (`strlen`) using `unsafe_load` with the correct pointer type and offset, and then creating a Julia string from the data part using `unsafe_string` by calculating the starting address of the data (`str + Core.sizeof(Cint)`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nstr = from_c::Ptr{Cvoid}\nlen = unsafe_load(Ptr{Cint}(str))\nunsafe_string(str + Core.sizeof(Cint), len)\n```\n\n----------------------------------------\n\nTITLE: Setting Max Precompile Files Limit (Julia Env Var)\nDESCRIPTION: This environment variable controls the maximum number of precompiled cache file variants that Julia will store per package. It influences how many different versions (e.g., for different configurations) are kept.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nJULIA_MAX_NUM_PRECOMPILE_FILES\n```\n\n----------------------------------------\n\nTITLE: Iterating Over String Splits in Julia\nDESCRIPTION: Introduces the `eachsplit(str)` function in Julia. It returns an iterator that yields substrings of `str` based on delimiters, performing the split operation lazily as the iterator is consumed. This contrasts with `split(str)`, which returns a fully allocated array of substrings.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\neachsplit(str)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsplit(str)\n```\n\n----------------------------------------\n\nTITLE: Correctly Piping Broadcasted Anonymous Function Results in Julia\nDESCRIPTION: Shows the correct syntax for piping the result of a broadcasted anonymous function application. Parentheses `(x -> x^2)` ensure the anonymous function is fully applied via broadcasting `.|>` before its results (a vector `[1, 4, 9]`) are passed to `sum` and then `sqrt`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_39\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> 1:3 .|> (x -> x^2) |> sum |> sqrt\n3.7416573867739413\n```\n\n----------------------------------------\n\nTITLE: Documenting Unexported StackTraces Methods in Julia\nDESCRIPTION: This snippet employs the Julia `@docs` macro to include documentation for the *unexported* `lookup` and `remove_frames!` functions from the `Base.StackTraces` module. The surrounding text indicates these methods are not part of the public exported API and need to be accessed with qualification (e.g., `StackTraces.lookup`). The `@docs` directive relies on the Julia documentation system (like Documenter.jl) to process it.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/stacktraces.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.StackTraces.lookup\nBase.StackTraces.remove_frames!\n```\n\n----------------------------------------\n\nTITLE: Replacing expand with Meta.lower - Julia\nDESCRIPTION: Illustrates replacement of deprecated 'expand' calls with 'Meta.lower', which provides access to lower-level representations of Julia code in macros or reflection utilities. Requires Base Julia, Meta module. Inputs are expressions or modules and expressions; output is the lowered expression.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_152\n\nLANGUAGE: julia\nCODE:\n```\nMeta.lower(module, ex)\n```\n\n----------------------------------------\n\nTITLE: Implementing a One-Way Event Synchronization Primitive using Atomics in Julia\nDESCRIPTION: This code defines a custom synchronization primitive, OneWayEvent, to coordinate between two Julia tasks using atomics and the low-level functions schedule and wait. It demonstrates the correct usage of atomics (@atomic, @atomicreplace) to manage the event's state, and shows how only a single notifer and waiter task is supported due to non-atomic assignment. Dependencies include Julia's atomics, task scheduling, and threading support; no external dependencies are needed. The example showcases key parameters such as event state (OWEState), task assignment, and atomic transitions, with expected outputs being ordered notification and synchronization between spawned tasks.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/parallel.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n@enum OWEState begin\n    OWE_EMPTY\n    OWE_WAITING\n    OWE_NOTIFYING\nend\n\nmutable struct OneWayEvent\n    @atomic state::OWEState\n    task::Task\n    OneWayEvent() = new(OWE_EMPTY)\nend\n\nfunction Base.notify(ev::OneWayEvent)\n    state = @atomic ev.state\n    while state !== OWE_NOTIFYING\n        # Spin until we successfully update the state to OWE_NOTIFYING:\n        state, ok = @atomicreplace(ev.state, state => OWE_NOTIFYING)\n        if ok\n            if state == OWE_WAITING\n                # OWE_WAITING -> OWE_NOTIFYING transition means that the waiter task is\n                # already waiting or about to call `wait`. The notifier task must wake up\n                # the waiter task.\n                schedule(ev.task)\n            else\n                @assert state == OWE_EMPTY\n                # Since we are assuming that there is only one notifier task (for\n                # simplicity), we know that the other possible case here is OWE_EMPTY.\n                # We do not need to do anything because we know that the waiter task has\n                # not called `wait(ev::OneWayEvent)` yet.\n            end\n            break\n        end\n    end\n    return\nend\n\nfunction Base.wait(ev::OneWayEvent)\n    ev.task = current_task()\n    state, ok = @atomicreplace(ev.state, OWE_EMPTY => OWE_WAITING)\n    if ok\n        # OWE_EMPTY -> OWE_WAITING transition means that the notifier task is guaranteed to\n        # invoke OWE_WAITING -> OWE_NOTIFYING transition. The waiter task must call\n        # `wait()` immediately. In particular, it MUST NOT invoke any function that may\n        # yield to the scheduler at this point in code.\n        wait()\n    else\n        @assert state == OWE_NOTIFYING\n        # Otherwise, the `state` must have already been moved to OWE_NOTIFYING by the\n        # notifier task.\n    end\n    return\nend\n\nev = OneWayEvent()\n@sync begin\n    Threads.@spawn begin\n        wait(ev)\n        println(\"done\")\n    end\n    println(\"notifying...\")\n    notify(ev)\nend\n\n# output\nnotifying...\ndone\n```\n\n----------------------------------------\n\nTITLE: Constructing Julia Cmd Objects Directly\nDESCRIPTION: Shows two ways to construct Julia `Cmd` objects directly instead of only using backticks. The first example modifies a `Cmd` created with backticks by passing a keyword argument (`dir`). The second example creates a `Cmd` from an array of strings (command and arguments) and passes keyword arguments (`detach`, `ignorestatus`) for further configuration.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nrun(Cmd(`pwd`, dir=\"..\"))\nrun(Cmd([\"pwd\"], detach=true, ignorestatus=true))\n```\n\n----------------------------------------\n\nTITLE: Writing to a Subprocess via open and Custom Streams - Julia\nDESCRIPTION: Illustrates writing to the stdin of an external command using open and a do-block, sending multiple lines from Julia to the external process for further handling. It also shows redirecting output using custom IO streams such as PipeBuffer, and reading the resulting output as needed. Essential for advanced IO functor usage, with required dependencies matching the subprocess being invoked (like less).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> open(`less`, \"w\", stdout) do io\n           for i = 1:3\n               println(io, i)\n           end\n       end\n1\n2\n3\n```\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> io = PipeBuffer(); # PipeBuffer is a type of IOBuffer\n\njulia> run(`echo world`, devnull, io, stderr);\n\njulia> readlines(io)\n1-element Vector{String}:\n \"world\"\n```\n```\n\n----------------------------------------\n\nTITLE: Type Sets with Parametric Abstract Types in Julia\nDESCRIPTION: Demonstrates expressing sets of types using bounded parametric forms (covariant: Pointy{<:Real}, contravariant: Pointy{>:Int}) and checking subtype relationships across these sets. Highlights Julia's support for using parametric types to model flexible interfaces. No external dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\njulia> Pointy{Float64} <: Pointy{<:Real}\ntrue\n\njulia> Pointy{Real} <: Pointy{>:Int}\ntrue\n```\n\n----------------------------------------\n\nTITLE: Comparing Remote Calls with Named vs. Anonymous Functions (Julia)\nDESCRIPTION: Contrasts the behavior of `remotecall_fetch` with standard named functions versus anonymous functions assigned to variables. Calling a named function (`bar`) remotely results in an `UndefVarError` because the function definition itself is not automatically serialized. However, an anonymous function assigned to a global variable (`anon_bar`) is serialized along with its closure environment, allowing it to be executed successfully on the remote worker.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_30\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> bar() = 1\nbar (generic function with 1 method)\n\njulia> remotecall_fetch(bar, 2)\nERROR: On worker 2:\nUndefVarError: `#bar` not defined in `Main`\n[...]\n\njulia> anon_bar  = ()->1\n(::#21) (generic function with 1 method)\n\njulia> remotecall_fetch(anon_bar, 2)\n1\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `isdefined(a::Array, i::Int)`: Use `isassigned` in Julia\nDESCRIPTION: Checking if an array element is defined using `isdefined(a::Array, i::Int)` is deprecated in Julia. The function `isassigned(a, i...)` should be used instead to check if a specific index (or indices) in an array has been assigned a value.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_180\n\nLANGUAGE: julia\nCODE:\n```\nisassigned\n```\n\n----------------------------------------\n\nTITLE: Querying Hostname via C Function from Julia\nDESCRIPTION: This Julia function queries the local machine's hostname by allocating a byte array, calling the C gethostname function, and converting the C string to a Julia string. It shows memory management with GC.@preserve and error checking. Dependencies include the C gethostname function, proper type annotations, and a correctly sized output buffer. The function ensures null-termination to meet expected C string requirements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nfunction gethostname()\n    hostname = Vector{UInt8}(undef, 256) # MAXHOSTNAMELEN\n    err = @ccall gethostname(hostname::Ptr{UInt8}, sizeof(hostname)::Csize_t)::Int32\n    Base.systemerror(\"gethostname\", err != 0)\n    hostname[end] = 0 # ensure null-termination\n    return GC.@preserve hostname unsafe_string(pointer(hostname))\nend\n```\n\n----------------------------------------\n\nTITLE: Setting Module Optimization Level using @optlevel Macro in Julia\nDESCRIPTION: Demonstrates using the experimental `Base.Experimental.@optlevel n` macro to set the compiler optimization level per-module in Julia. Setting `n` to 0 or 1 can provide significant latency improvements for non-performance-critical code.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_79\n\nLANGUAGE: julia\nCODE:\n```\nBase.Experimental.@optlevel n\n```\n\n----------------------------------------\n\nTITLE: Treating Custom Types as Scalars in Julia Broadcasting\nDESCRIPTION: Shows how to implement `Base.broadcastable` for a custom type (`MyType`) to make it behave like a scalar (0-dimensional object) during broadcasting operations. Wrapping the object instance `o` in `Ref(o)` ensures it's treated as a single element rather than a container, preventing iteration over its potential contents.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nBase.broadcastable(o::MyType) = Ref(o)\n```\n```\n\n----------------------------------------\n\nTITLE: Specialization Behavior on Vararg Arguments - Julia\nDESCRIPTION: Compares Vararg handling in Julia specialization: passing Int... as a catch-all does not cause specialization, while using Vararg{Int, N} where {N} does. Accepts variable-length integer arguments. No extra dependencies are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\nf_vararg(x::Int...) = tuple(x...)\n```\n\nLANGUAGE: julia\nCODE:\n```\ng_vararg(x::Vararg{Int, N}) where {N} = tuple(x...)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Covariance in Tuple Types with typeintersect - Julia REPL - Julia\nDESCRIPTION: These examples illustrate Julia's type covariance for tuples by intersecting the base Tuple and Tuple{Vararg{Any}} types with Tuple{Int,Float64}. It reveals that Tuple matches any tuple structure, and that both forms result in Tuple{Int64, Float64} when intersected. Dependencies: Julia base. Inputs: Tuple types; Output: Intersected type. This is key for understanding method dispatch.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_7\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> typeintersect(Tuple, Tuple{Int,Float64})\nTuple{Int64, Float64}\n\njulia> typeintersect(Tuple{Vararg{Any}}, Tuple{Int,Float64})\nTuple{Int64, Float64}\n```\n\n----------------------------------------\n\nTITLE: Understanding Return Value of Assignment in Julia Functions\nDESCRIPTION: Demonstrates that an assignment expression (`x::Int = 3.0`) in Julia evaluates to the value on the right-hand side (`3.0`) *before* it's assigned to the variable `x`. The type assertion `::Int` applies to the variable `x`, causing the value `3.0` to be converted to `3` when stored in `x`. The examples contrast returning the variable `x` itself (value `3`) versus implicitly returning the result of the assignment statement (value `3.0`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_11\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function threeint()\n           x::Int = 3.0\n           x # returns variable x\n       end\nthreeint (generic function with 1 method)\n\njulia> function threefloat()\n           x::Int = 3.0 # returns 3.0\n       end\nthreefloat (generic function with 1 method)\n\njulia> threeint()\n3\n\njulia> threefloat()\n3.0\n```\n\n----------------------------------------\n\nTITLE: Tracing Julia Precompilation with PRECOMPILE_TRACE_COMPILE - Julia\nDESCRIPTION: This snippet shows how to set the internal Base.PRECOMPILE_TRACE_COMPILE global to output method precompilation timing information to stderr. It is useful for profiling package precompilation bottlenecks when running 'pkg> precompile', allowing developers to identify slow methods. There are no external dependencies; requirements include access to the Julia REPL and an environment with package manager enabled. The key output is a detailed trace of precompiled methods and their timing, but the trace may be verbose, and timing could be affected by system conditions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_57\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> Base.PRECOMPILE_TRACE_COMPILE[] = \"stderr\"\n\npkg> precompile\n\n```\n\n----------------------------------------\n\nTITLE: Package Image Usage Control Flag (Julia Flag)\nDESCRIPTION: The `--pkgimages` flag setting (implicitly, whether it's enabled or disabled via `--pkgimages=no`) impacts whether Julia attempts to load or create package image caches. Mismatches in this setting relative to cache creation flags can lead to rejection.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n--pkgimages\n```\n\n----------------------------------------\n\nTITLE: Enumerating Builtin Functions with `methods` in Julia\nDESCRIPTION: Mentions that Julia's builtin functions can now be enumerated using the `methods` function, similar to how generic functions are inspected. This provides more introspection capabilities for builtins.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nmethods\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running PackageEvaluator via Shell\nDESCRIPTION: These shell commands clone the PackageEvaluator repository, navigate into its scripts directory, check out a specific branch prepared for backport testing (e.g., `backport-x.y.z`), and then execute the `runvagrant.sh` script. This script initiates the package evaluation process, typically using Vagrant and VirtualBox to test package compatibility against the Julia version being prepared.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/JuliaCI/PackageEvaluator.jl.git\ncd PackageEvaluator.jl/scripts\ngit checkout backport-x.y.z\n./runvagrant.sh\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `cummin` and `cummax`: Use `accumulate` in Julia\nDESCRIPTION: The functions `cummin` and `cummax` for computing cumulative minimum and maximum are deprecated in Julia. Use the `accumulate` function with `min` or `max` as the binary operator instead, e.g., `accumulate(min, A)`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_189\n\nLANGUAGE: julia\nCODE:\n```\naccumulate\n```\n\n----------------------------------------\n\nTITLE: Incorrect Element Type Extraction via Introspection - Julia\nDESCRIPTION: This snippet shows a common anti-pattern for extracting the element type by accessing internal type parameters via the .parameters field. It tries to retrieve the first parameter of A, but this fails for arrays without explicit type parameters (e.g., custom array types with fixed element types). The method may result in runtime errors or incorrect results for special cases. No external dependencies are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\neltype_wrong(::Type{A}) where {A<:AbstractArray} = A.parameters[1]\n```\n\n----------------------------------------\n\nTITLE: Illustrating Potential Pointer Array Representation of Tuples in C\nDESCRIPTION: Provides a C struct definition (`jl_tuple_t`) illustrating one possible internal memory representation for Julia tuples. This layout includes a `length` field and a flexible array member `data` holding pointers (`jl_value_t*`) to the tuple's elements. It's important to note that this is not the only representation; tuples containing only `isbits` elements might be stored unboxed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_13\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct {\n    size_t length;\n    jl_value_t *data[length];\n} jl_tuple_t;\n```\n\n----------------------------------------\n\nTITLE: Annotating API Compatibility in Julia Documentation\nDESCRIPTION: Provides the standard Markdown admonition format (`!!! compat \"Julia 1.X\"`) used within Julia documentation or docstrings to indicate when a feature was added or its behavior changed, specifying the relevant Julia version (e.g., 1.X). This helps users track API evolution and ensure compatibility across Julia versions.\nSOURCE: https://github.com/julialang/julia/blob/master/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n!!! compat \"Julia 1.X\"\n    This method was added in Julia 1.X.\n```\n\n----------------------------------------\n\nTITLE: Demo: For-Loop Spawning of Tasks - Multi-Task Creation - Julia\nDESCRIPTION: This Julia code demonstrates spawning multiple tasks within a loop, highlighting how parent-child task relationships affect probe monitoring. By nesting @spawn within a for loop inside another task, it allows users to observe which tasks are parents during probe tracing. Designed for use in bpftrace or DTrace probe experiments, this pattern helps in debugging and tracing spawned task hierarchies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nThreads.@spawn for i in 1:10\n   Threads.@spawn 1+1\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Large SharedArrays for Benchmarking in Julia REPL\nDESCRIPTION: Creates two large 3D `SharedArray`s, `q` and `u`, both of type `Float64` and dimensions (500, 500, 500). These arrays are intended for use in benchmarking the performance of different serial and parallel advection algorithm implementations. Requires the `SharedArrays` module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\njulia> q = SharedArray{Float64,3}((500,500,500));\n\njulia> u = SharedArray{Float64,3}((500,500,500));\n```\n\n----------------------------------------\n\nTITLE: Defining Unsigned Hexadecimal Literals in Julia\nDESCRIPTION: Demonstrates the syntax for unsigned integer literals using the `0x` prefix and hexadecimal digits. The resulting unsigned integer type (`UInt8`, `UInt16`, `UInt32`, `UInt64`, `UInt128`) is determined by the number of hex digits used.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> x = 0x1\n0x01\n\njulia> typeof(x)\nUInt8\n\njulia> x = 0x123\n0x0123\n\njulia> typeof(x)\nUInt16\n\njulia> x = 0x1234567\n0x01234567\n\njulia> typeof(x)\nUInt32\n\njulia> x = 0x123456789abcdef\n0x0123456789abcdef\n\njulia> typeof(x)\nUInt64\n\njulia> x = 0x11112222333344445555666677778888\n0x11112222333344445555666677778888\n\njulia> typeof(x)\nUInt128\n```\n```\n\n----------------------------------------\n\nTITLE: Error on Attempting to Change Type Annotation of Assigned Global in Julia\nDESCRIPTION: Shows that once a global variable (`x`) in Julia (version 1.8+) has been assigned a value, its effective type is fixed. Attempting to subsequently add or change its type annotation using syntax like `global x::Int` is not allowed and results in an error, as the variable already has a value or potentially a conflicting type annotation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_32\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> x = 1\n1\n\njulia> global x::Int\nERROR: cannot set type for global x. It already has a value or is already set to a different type.\nStacktrace:\n[...]\n```\n```\n\n----------------------------------------\n\nTITLE: Throwing a DomainError in a Function - Julia\nDESCRIPTION: This code defines a function f that computes exp(-x) if x is non-negative, otherwise throws a DomainError with a descriptive message. It demonstrates explicit error-throwing using the throw function based on input validation. Dependencies are base Julia; the function takes one argument, expects a real or numeric input, and signals errors for invalid cases.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(x) = x>=0 ? exp(-x) : throw(DomainError(x, \"argument must be non-negative\"))\nf (generic function with 1 method)\n\njulia> f(1)\n0.36787944117144233\n\njulia> f(-1)\nERROR: DomainError with -1:\nargument must be non-negative\nStacktrace:\n [1] f(::Int64) at ./none:1\n\n```\n\n----------------------------------------\n\nTITLE: Seeding a Julia Test Set with a Specific RNG State\nDESCRIPTION: This Julia code demonstrates how to use the `@testset` macro with the optional `rng` keyword argument to seed the random number generator for a specific test set. This example uses a `Xoshiro` RNG initialized with a particular state, ensuring reproducible results for tests involving random numbers within that set, as shown by the `@test rand() == ...` line.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nusing Test, Random\n@testset rng=Xoshiro(0x2e026445595ed28e, 0x07bb81ac4c54926d, 0x83d7d70843e8bad6, 0xdbef927d150af80b, 0xdbf91ddf2534f850) begin\n    @test rand() == 0.559472630416976\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Closure Behavior with Shared Variable in Julia Loop\nDESCRIPTION: Demonstrates a potential issue with closures in Julia loops without proper scoping. Two closures are created within a `while` loop, both capturing the loop variable `i`. Because they capture the *same* mutable variable instance, which is incremented globally in each iteration, both closures return the final value of the global `i` (3) when called later.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_19\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> Fs = Vector{Any}(undef, 2); i = 1;\n\njulia> while i <= 2\n           Fs[i] = ()->i\n           global i += 1\n       end\n\njulia> Fs[1]()\n3\n\njulia> Fs[2]()\n3\n```\n```\n\n----------------------------------------\n\nTITLE: Unsafe Thread Communication through Shared Variables - Julia\nDESCRIPTION: Shows examples of unsafe communication between threads using global variables without synchronization, leading to possible segmentation faults and undefined behavior. Illustrates typical anti-patterns for multi-threaded code with shared state. Inputs are sequences of global assignments and busy-wait loops; outputs are likely crashes or undefined results.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nThread 1:\nglobal b = false\nglobal a = rand()\nglobal b = true\n\nThread 2:\nwhile !b; end\nbad_read1(a) # it is NOT safe to access `a` here!\n\nThread 3:\nwhile !@isdefined(a); end\nbad_read2(a) # it is NOT safe to access `a` here\n```\n\n----------------------------------------\n\nTITLE: Deprecation of Whitespace-Insensitive Syntax in Julia - Julia\nDESCRIPTION: This snippet illustrates several deprecated Julia syntactic forms where whitespace was previously tolerated around parentheses for function calls, getindex operations, and definitions. These deprecations enforce clearer, more explicit syntax and prevent ambiguity. The code is intended to warn users of breaking changes and guides them to update their code. There are no external dependencies, and its function is purely illustrative; inputs and outputs depend on the function signatures shown. Limitations: The snippet is for informational purposes and may not run as-is due to new parser restrictions in updated Julia versions.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_203\n\nLANGUAGE: julia\nCODE:\n```\n    # function call\n    f (x)\n\n    # getindex\n    x [17]\n    rand(2) [1]\n\n    # function definition\n    f (x) = x^2\n    function foo (x)\n        x^2\n    end\n```\n\n----------------------------------------\n\nTITLE: Cloning Julia Source Code from GitHub - Shell\nDESCRIPTION: This shell command clones the official Julia source code repository from GitHub, providing the user a local copy for building or development. Users must have Git installed and an active internet connection. The created 'julia' directory will contain all source files required for building Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/JuliaLang/julia.git\n```\n\n----------------------------------------\n\nTITLE: Identifying Indirect Julia Package Dependencies with pkg> why - Julia REPL\nDESCRIPTION: This snippet uses the Julia package manager's 'why' command in the REPL to trace the dependency chain for a given package. This helps developers understand why an indirect dependency was included in their environment, which can be crucial for optimizing load times and dependency bloat. No external dependencies are needed apart from an active Julia package environment. Inputs are the package to query (e.g., FFMPEG_jll); outputs are the dependency chains leading to that package. The output format is REPL-specific and intended for interactive analysis.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_56\n\nLANGUAGE: repl\nCODE:\n```\n(CustomPackage) pkg> why FFMPEG_jll\n  Plots → FFMPEG → FFMPEG_jll\n  Plots → GR → GR_jll → FFMPEG_jll\n\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Directory Trees Using walkdir in Julia\nDESCRIPTION: This Julia code snippet demonstrates the use of the walkdir function to recursively traverse a directory tree, returning a tuple of the current root, its subdirectories, and files. The example iterates over each directory within ~/.julia/v0.5/Plots/src, printing the number of files present in each directory using println. Dependencies include Julia's Base I/O and filesystem libraries. Input is the target directory path, and output consists of formatted messages counting files per directory. The snippet illustrates handling directory trees in Julia post v0.5, and assumes the given directory structure exists.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_202\n\nLANGUAGE: julia\nCODE:\n```\nfor (root, dirs, files) in walkdir(expanduser(\"~/.julia/v0.5/Plots/src\"))\n    println(\"$(length(files)) \\t files in $root\")\nend\n19    files in /Users/me/.julia/v0.5/Plots/src\n15    files in /Users/me/.julia/v0.5/Plots/src/backends\n4     files in /Users/me/.julia/v0.5/Plots/src/deprecated\n```\n\n----------------------------------------\n\nTITLE: Deprecation of Array-Reducing `isinteger`: Use `all(isinteger, x)` in Julia\nDESCRIPTION: The array-reducing form `isinteger(x::AbstractArray)`, which checks if all elements of an array are integers, is deprecated in Julia. Use the explicit form `all(isinteger, x)` instead.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_192\n\nLANGUAGE: julia\nCODE:\n```\nall(isinteger, x)\n```\n\n----------------------------------------\n\nTITLE: Adding Weak/Extra Dependencies Programmatically with Pkg.add in Julia\nDESCRIPTION: Illustrates how to programmatically add a package named \"Foo\" as either a weak dependency (`target=:weakdeps`) or an extra dependency (`target=:extras`) using the `Pkg.add` function in Julia. This provides API access to manage dependency types. Depends on the `Pkg` standard library.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nPkg.add(\"Foo\", target=:weakdeps/:extras)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage: Calling Julia API from User-Created Threads\nDESCRIPTION: This C code demonstrates an *incorrect* and unsupported pattern for using the Julia C API with threads. It attempts to call `jl_eval_string` from a new thread created using `pthread_create`. This is not thread-safe because Julia API functions (except `jl_init`/`jl_atexit_hook`) should generally only be called from the thread that called `jl_init` or from threads started by the Julia runtime itself. This usage can lead to undefined behavior or crashes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_36\n\nLANGUAGE: c\nCODE:\n```\nvoid *func(void*)\n{\n    // Wrong, jl_eval_string() called from thread that was not started by Julia\n    jl_eval_string(\"println(Threads.threadid())\");\n    return NULL;\n}\n\nint main()\n{\n    pthread_t t;\n\n    jl_init();\n\n    // Start a new thread\n    pthread_create(&t, NULL, func, NULL);\n    pthread_join(t, NULL);\n\n    jl_atexit_hook(0);\n}\n```\n\n----------------------------------------\n\nTITLE: Updating a Julia Source Tree and Rebuilding (Shell)\nDESCRIPTION: Shows the recommended workflow for updating an existing Julia Git repository and rebuilding the project using 'git pull' and 'make'. Assumes no local conflicting changes. Requires Git and Make tools installed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ncd julia\ngit pull && make\n\n```\n\n----------------------------------------\n\nTITLE: Sample Julia Startup Error Message - Julia\nDESCRIPTION: This Julia snippet displays an example of a startup error encountered when launching Julia, specifically an 'exec: error -5' message. This output is useful for diagnosing early boot failures using system tracing tools and should be shared with the Julia maintainers for analysis. No execution is required, as it demonstrates a possible failure output.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/backtraces.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n\"$ julia\\nexec: error -5\\n\"\n```\n\n----------------------------------------\n\nTITLE: Idiom: Defining Scoped Values as Const Globals in Julia\nDESCRIPTION: Illustrates the common practice of defining `ScopedValue`s as constant global variables (`const sval = ScopedValue(1)`). This ensures the `ScopedValue` object itself is readily accessible within the lexical scope where its value needs to be read or dynamically modified using `with` or `@with`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.ScopedValues\nconst sval = ScopedValue(1)\n```\n\n----------------------------------------\n\nTITLE: Batch Generating and Packing Icon Files - Shell\nDESCRIPTION: This shell script automates the conversion of the generated 'julia-dots.svg' into a set of PNG images at various standard icon sizes using 'rsvg-convert', then combines them into a single .ico file using ImageMagick's 'convert' tool. It removes the intermediate PNG files after the .ico is created for cleanup. Dependencies include rsvg-convert and ImageMagick. Inputs are the existing 'julia-dots.svg' file; outputs are several PNG files and a compiled 'julia.ico' icon. All command-line tools must be installed and available in the PATH. The script covers common icon sizes for cross-platform compatibility.\nSOURCE: https://github.com/julialang/julia/blob/master/contrib/windows/icon-readme.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n#!/bin/bash\\n\\nfor size in 16 20 24 32 40 48 64 128 256; do\\n    rsvg-convert -w $size -h $size julia-dots.svg -o $size.png\\ndone\\n\\nconvert 256.png 128.png 64.png 48.png 40.png 32.png 24.png 20.png 16.png julia.ico\\n\\nrm 256.png 128.png 64.png 48.png 40.png 32.png 24.png 20.png 16.png\\n\n```\n\n----------------------------------------\n\nTITLE: Exporting and Modifying JULIA_LOAD_PATH in Unix Shell - Shell\nDESCRIPTION: This snippet illustrates how to prepend a directory to the JULIA_LOAD_PATH shell environment variable using bash syntax. The export command sets or updates the environment variable for the running shell and any child processes, allowing the user to influence Julia's package path resolution for the subsequent Julia process. Command must be run before Julia is started or added to shell initialization files (e.g., .bashrc). On Windows, ';' should be used instead of ':'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/environment-variables.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nexport JULIA_LOAD_PATH=\"/foo/bar:$JULIA_LOAD_PATH\"\n```\n\n----------------------------------------\n\nTITLE: Generic Conversion and Output Array Creation with AbstractArray - Julia\nDESCRIPTION: This example shows how to generically convert an input to a specific AbstractArray{Eltype} and then create an output of the same type with a desired element type. It uses Julia's convert and similar functions, which operate generically for AbstractArray subtypes that implement the expected interface. This pattern ensures type consistency between input and output arrays. No extra dependencies, but AbstractArray subtypes must support convert and similar.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\ninput = convert(AbstractArray{Eltype}, input)\noutput = similar(input, Eltype)\n```\n\n----------------------------------------\n\nTITLE: Running a Multi-Stage Parallel Pipeline in Julia\nDESCRIPTION: Demonstrates an even more complex multi-stage pipeline in Julia using the previously defined `prefixer` function. A Perl producer's output is first piped concurrently to three `prefixer` instances (X, Y, Z). The combined output of this first stage is then piped concurrently to two more `prefixer` instances (A, B) in the second stage. This showcases chaining parallel processing stages with different numbers of workers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\n# jldoctest prefixer; filter = r\"[A-B] [X-Z] [0-5]\"\njulia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`,\n           prefixer(\"X\",3) & prefixer(\"Y\",3) & prefixer(\"Z\",3),\n           prefixer(\"A\",2) & prefixer(\"B\",2)));\nA X 0\nB Y 1\nA Z 2\nB X 3\nA Y 4\nB Z 5\n```\n\n----------------------------------------\n\nTITLE: Executing Code within a Dynamic Scope using `@with` Macro in Julia\nDESCRIPTION: Shows the usage of the `@with` macro as an alternative to the `with` function. `@with a=>2 f(10)` executes `f(10)` in a dynamic scope where `a` is `2`, avoiding the need for a zero-argument closure and potentially reducing overhead.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n@with a=>2 f(10)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Period Types from Date Parts in Julia\nDESCRIPTION: Shows usage of propercase Dates accessor functions to retrieve year and day as Period objects from a Date. These return values in the corresponding Period type rather than as plain integers. Only the Dates module is required; supply a Date to receive a typed Period result.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> Dates.Year(t)\n2014 years\n\njulia> Dates.Day(t)\n31 days\n```\n\n----------------------------------------\n\nTITLE: Defining a Function to Manipulate and Construct Expressions in Julia\nDESCRIPTION: Shows a function `make_expr2` that processes its arguments before constructing an expression. It doubles any numeric arguments using `map` and `isa` check, leaving other types (like nested `Expr` objects) unchanged, then builds and returns the final expression.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_18\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> function make_expr2(op, opr1, opr2)\n           opr1f, opr2f = map(x -> isa(x, Number) ? 2*x : x, (opr1, opr2))\n           retexpr = Expr(:call, op, opr1f, opr2f)\n           return retexpr\n       end\nmake_expr2 (generic function with 1 method)\n\njulia> make_expr2(:+, 1, 2)\n:(2 + 4)\n\njulia> ex = make_expr2(:+, 1, Expr(:call, :*, 5, 8))\n:(2 + 5 * 8)\n\njulia> eval(ex)\n42\n```\n\n----------------------------------------\n\nTITLE: Performing Horizontal Array Concatenation in Julia\nDESCRIPTION: Demonstrates horizontal concatenation in Julia using spaces, tabs, or double semicolons (`;;`) between arguments within square brackets. Shows how ranges, existing vectors, or individual numbers can be concatenated horizontally to form a Matrix. This syntax is shorthand for `hcat`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_3\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [1:2  4:5  7:8]\n2×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n\njulia> [[1,2]  [4,5]  [7,8]]\n2×3 Matrix{Int64}:\n 1  4  7\n 2  5  8\n\njulia> [1 2 3] # Numbers can also be horizontally concatenated\n1×3 Matrix{Int64}:\n 1  2  3\n\njulia> [1;; 2;; 3;; 4]\n1×4 Matrix{Int64}:\n 1  2  3  4\n```\n\n----------------------------------------\n\nTITLE: Differentiating Index Types in Subarray Iteration with Julia\nDESCRIPTION: This code block demonstrates iterating over a subarray (view) with eachindex, showing that indices returned are CartesianIndex objects instead of Ints. It creates random and view arrays, then loops through eachindex to display the type and value of the indices. No dependencies required. Illustrates index-type adaptation depending on array storage.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\njulia> A = rand(4, 3);\n\njulia> B = view(A, 1:3, 2:3);\n\njulia> for i in eachindex(B)\n           @show i\n       end\ni = CartesianIndex(1, 1)\ni = CartesianIndex(2, 1)\ni = CartesianIndex(3, 1)\ni = CartesianIndex(1, 2)\ni = CartesianIndex(2, 2)\ni = CartesianIndex(3, 2)\n```\n\n----------------------------------------\n\nTITLE: Broadcasted Construction of CartesianIndex for Diagonal Extraction in Julia Arrays\nDESCRIPTION: This snippet demonstrates the use of dot-broadcasting and axes to construct arrays of CartesianIndex, which are then used for indexing to extract one or both diagonals from a multi-page 3D array. No dependencies are needed. The code uses CartesianIndex.(axes(A, 1), axes(A, 2)) to generate indices for diagonals and accesses corresponding elements from one or both pages, returning a vector or matrix. Cannot use 'end' with CartesianIndex indices.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\njulia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), 1]\n4-element Vector{Int64}:\n  1\n  6\n 11\n 16\n\njulia> A[CartesianIndex.(axes(A, 1), axes(A, 2)), :]\n4×2 Matrix{Int64}:\n  1  17\n  6  22\n 11  27\n 16  32\n```\n\n----------------------------------------\n\nTITLE: Idiom: Unsharing Mutable State in Scoped Values in Julia\nDESCRIPTION: Demonstrates an idiom for safely modifying mutable state stored in a `ScopedValue` within a new dynamic scope, especially in concurrent scenarios. Instead of directly modifying the shared mutable object, a new version is created (e.g., using `merge` for a dictionary) which incorporates changes while leaving the original object in the parent scope untouched. This prevents race conditions when modifying the state concurrently.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.ScopedValues\nimport Base.Threads: @spawn\n\nconst sval_dict = ScopedValue(Dict())\n\n# If you want to add new values to the dict, instead of replacing\n# it, unshare the values explicitly. In this example we use `merge`\n# to unshare the state of the dictionary in parent scope.\n@sync begin\n    with(sval_dict => merge(sval_dict[], Dict(:a => 10))) do\n        @spawn @show sval_dict[][:a]\n    end\n    @spawn sval_dict[][:a] = 3 # Not a race since they are unshared.\nend\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Local Variable Shadowing Global in Function Scope - Julia\nDESCRIPTION: This snippet illustrates that a variable assigned inside a Julia function shadows any global variable of the same name; the function uses a new local x while the global x remains unchanged. It depends only on Julia base functions. The key parameter is x, demonstrating that its value inside the function is distinct from any global definition. The sample includes both initial global assignment and subsequent function calls to validate the independent scope of each variable.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = 123 # global\n123\n\njulia> function greet()\n           x = \"hello\" # new local\n           println(x)\n       end\ngreet (generic function with 1 method)\n\njulia> greet()\nhello\n\njulia> x # global\n123\n```\n\n----------------------------------------\n\nTITLE: Spawning a Single Task in Julia with Threads.@spawn - Julia\nDESCRIPTION: This snippet executes a single lightweight thread (task) in Julia using Threads.@spawn, triggering the task scheduler. This is used in conjunction with tracing (as previously described) to observe thread wakeup behavior when a single task is dispatched. No additional dependencies are required beyond a multithreaded Julia setup. The result indicates that all worker threads may awaken even for a single task.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nThreads.@spawn 1+1\n```\n\n----------------------------------------\n\nTITLE: Using Standalone Dotted Operators for Broadcasting in Julia\nDESCRIPTION: Standalone dotted operators (e.g., `.*`, `.+,` `.*`) are now parsed as `Expr(:., :op)`, which lowers to `Base.BroadcastFunction(op)`. This syntax provides a convenient way to pass the broadcasted version of an operator to higher-order functions like `map`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_52\n\nLANGUAGE: julia\nCODE:\n```\n# Example: Elementwise product of arrays of arrays\nmap(.*, A, B)\n```\n\nLANGUAGE: julia\nCODE:\n```\n# Equivalent to:\nmap((x...) -> (.*)(x...), A, B)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Array Type `ArrayAndChar` in Julia\nDESCRIPTION: Defines a struct `ArrayAndChar` that subtypes `AbstractArray`. It wraps a standard `Array` (`data`) and includes an additional character field (`char`) as metadata. It implements essential array interface methods like `size`, `getindex`, and `setindex!` by forwarding them to the internal `data` array, and provides a custom display method `showarg`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest ArrayAndChar; output = false\nstruct ArrayAndChar{T,N} <: AbstractArray{T,N}\n    data::Array{T,N}\n    char::Char\nend\nBase.size(A::ArrayAndChar) = size(A.data)\nBase.getindex(A::ArrayAndChar{T,N}, inds::Vararg{Int,N}) where {T,N} = A.data[inds...]\nBase.setindex!(A::ArrayAndChar{T,N}, val, inds::Vararg{Int,N}) where {T,N} = A.data[inds...] = val\nBase.showarg(io::IO, A::ArrayAndChar, toplevel) = print(io, typeof(A), \" with char '\", A.char, \"'\")\n# output\n\n```\n```\n\n----------------------------------------\n\nTITLE: Array Reductions in Julia\nDESCRIPTION: Reduction functions like `sum`, `prod`, and `maximum` in Julia operate over all elements of an array by default, even for multi-dimensional arrays, when called with a single array argument.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nsum(A)\n```\n\nLANGUAGE: julia\nCODE:\n```\nprod(A)\n```\n\nLANGUAGE: julia\nCODE:\n```\nmaximum(A)\n```\n\n----------------------------------------\n\nTITLE: Type Identity and DataType in Julia\nDESCRIPTION: Demonstrates that both abstract and primitive/concrete types (such as Real and Int) are themselves instances of DataType. This highlights the unification of type representations in Julia's type system. Inputs are types themselves; outputs confirm their type is DataType.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\ntypeof(Real)\nDataType\n\ntypeof(Int)\nDataType\n```\n\n----------------------------------------\n\nTITLE: Building an Asynchronous TCP Echo Server in Julia\nDESCRIPTION: This snippet implements a TCP echo server using Sockets, multithreading, and coroutines. The server listens on port 2001, accepts connections, and for each connection, spawns a separate thread to echo received messages back to the sender. It also includes a client that connects to this server and a coroutine that prints any received lines to STDOUT. Inputs: Data from client sockets. Outputs: Echoed data sent back to the client via the socket. Threads and asynchronous design allow handling multiple clients.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_13\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> errormonitor(Threads.@spawn begin\n           server = listen(2001)\n           while true\n               sock = accept(server)\n               Threads.@spawn while isopen(sock)\n                   write(sock, readline(sock, keep=true))\n               end\n           end\n       end)\nTask (runnable) @0x00007fd31dc12e60\n\njulia> clientside = connect(2001)\nTCPSocket(RawFD(28) open, 0 bytes waiting)\n\njulia> errormonitor(Threads.@spawn while isopen(clientside)\n           write(stdout, readline(clientside, keep=true))\n       end)\nTask (runnable) @0x00007fd31dc11870\n\njulia> println(clientside,\"Hello World from the Echo Server\")\nHello World from the Echo Server\n```\n\n----------------------------------------\n\nTITLE: Applying Global GC Root Annotations in Julia C API (C)\nDESCRIPTION: Declares and annotates global variables and function returns to signal that their values are always globally rooted for Julia's GC. The usage of JL_GLOBALLY_ROOTED ensures the referenced jl_any_type and every return value of jl_ast_ctx will not be collected. Dependencies include the Julia C header files defining types and macros. Inputs may include none (for variable declaration) or functions as specified; outputs are rooted values for use within the Julia runtime context. Limitations: only variables and function returns can be annotated;\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-sa.md#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nextern JL_DLLEXPORT jl_datatype_t *jl_any_type JL_GLOBALLY_ROOTED;\njl_ast_context_t *jl_ast_ctx(fl_context_t *fl) JL_GLOBALLY_ROOTED;\n```\n\n----------------------------------------\n\nTITLE: Representing Julia Value Roots with Operand Bundle in LLVM IR\nDESCRIPTION: Illustrates a call instruction in LLVM IR using an operand bundle named `jl_roots` to ensure a Julia value is considered live for the duration of a foreign function call. This ensures the GC does not collect the value. The bundle attaches `%A` as a root, and this mechanism is handled transparently in the GC root placement pass.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_13\n\nLANGUAGE: llvm\nCODE:\n```\ncall void inttoptr (i64 ... to void (double*)*)(double* %5) [ \"jl_roots\"(%jl_value_t addrspace(10)* %A) ]\n```\n\n----------------------------------------\n\nTITLE: Changing REPL Colors for Warnings - ENV Variable Usage - Julia\nDESCRIPTION: This snippet sets the JULIA_WARN_COLOR environment variable to an integer value to customize the REPL warning message color (e.g., 208 for orange) in Julia. By assigning ENV[\"JULIA_WARN_COLOR\"] to a numerical color code, users can influence the color of warning messages shown in the Julia REPL, provided the terminal supports 256 colors. This approach requires no dependencies but may have limited effect in terminals not supporting extended color palettes.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_165\n\nLANGUAGE: julia\nCODE:\n```\nENV[\"JULIA_WARN_COLOR\"] = 208\n```\n\n----------------------------------------\n\nTITLE: Protecting Mutable Julia Objects Across C Scopes using Global IdDict\nDESCRIPTION: Demonstrates a technique to prevent GC collection of a *mutable* Julia object (`var`) across different C function calls or scopes. It involves creating a global `IdDict` in Julia (`refs`) during initialization and adding a reference to the object using `setindex!` called via `jl_call3`. This keeps the object alive as long as it's in the dictionary.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_18\n\nLANGUAGE: c\nCODE:\n```\n// This functions shall be executed only once, during the initialization.\njl_value_t* refs = jl_eval_string(\"refs = IdDict()\");\njl_function_t* setindex = jl_get_function(jl_base_module, \"setindex!\");\n\n...\n\n// `var` is the variable we want to protect between function calls.\njl_value_t* var = 0;\n\n...\n\n// `var` is a `Vector{Float64}`, which is mutable.\nvar = jl_eval_string(\"[sqrt(2.0); sqrt(4.0); sqrt(6.0)]\");\n\n// To protect `var`, add its reference to `refs`.\njl_call3(setindex, refs, var, var);\n```\n\n----------------------------------------\n\nTITLE: Inspecting Macro Expansion using `@macroexpand` in Julia\nDESCRIPTION: Demonstrates the use of the built-in `@macroexpand` macro to view the code generated by the advanced `@assert` macro. Shows the expansion results for calls both with (`@assert a==b \"a should equal b!\"`) and without (`@assert a == b`) the optional custom error message, revealing the underlying `if/else` structure and how the message is incorporated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_39\n\nLANGUAGE: julia\nCODE:\n```\njulia> @macroexpand @assert a == b\n:(if Main.a == Main.b\n        Main.nothing\n    else\n        Main.throw(Main.AssertionError(\"a == b\"))\n    end)\n\njulia> @macroexpand @assert a==b \"a should equal b!\"\n:(if Main.a == Main.b\n        Main.nothing\n    else\n        Main.throw(Main.AssertionError(\"a should equal b!\"))\n    end)\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple `@assert` Macro in Julia\nDESCRIPTION: Presents a simplified definition of the `@assert` macro. It takes an expression `ex`, and returns a quoted expression `:($ex ? nothing : throw(AssertionError($(string(ex)))))` which checks the condition `ex` at runtime and throws an `AssertionError` with the string representation of `ex` if it's false.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\njulia> macro assert(ex)\n           return :( $ex ? nothing : throw(AssertionError($(string(ex)))) )\n       end\n@assert (macro with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Promotion and Interaction of Rational Numbers with Other Numeric Types in Julia\nDESCRIPTION: Illustrates how rationals interact with integers, floating-point numbers, and complex numbers via Julia's promotion system. Only Julia Base is required. Inputs are various numeric type combinations; the system returns promoted results or performs appropriate arithmetic, with outputs possibly being rationals, floats, or complex numbers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\njulia> 3//5 + 1\n8//5\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 3//5 - 0.5\n0.09999999999999998\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 2//7 * (1 + 2im)\n2//7 + 4//7*im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 2//7 * (1.5 + 2im)\n0.42857142857142855 + 0.5714285714285714im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 3//2 / (1 + 2im)\n3//10 - 3//5*im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1//2 + 2im\n1//2 + 2//1*im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1 + 2//3im\n1//1 - 2//3*im\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 0.5 == 1//2\ntrue\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 0.33 == 1//3\nfalse\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 0.33 < 1//3\ntrue\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1//3 - 0.33\n0.0033333333333332993\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lexical Scoping in Julia\nDESCRIPTION: This snippet illustrates Julia's default lexical scoping using a `let` block. The variable `x` defined inside the `let` block shadows the outer `x` only within that block's scope. The outer `x` retains its original value after the `let` block finishes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nx = 1\nlet x = 5\n    @show x # 5\nend\n@show x # 1\n```\n\n----------------------------------------\n\nTITLE: Defining Functions and Generated Functions Calling Another Function in Julia\nDESCRIPTION: Defines three functions: `g(x)` (a regular function calling `f(x)`), `gen1(x)` (a generated function *returning* the result of `f(x)` called with the type), and `gen2(x)` (a generated function returning a *quoted expression* `:(f(x))` to be evaluated later). This sets up a comparison of how method redefinition affects regular vs. generated functions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_66\n\nLANGUAGE: julia\nCODE:\n```\njulia> g(x) = f(x);\n\njulia> @generated gen1(x) = f(x);\n\njulia> @generated gen2(x) = :(f(x));\n```\n\n----------------------------------------\n\nTITLE: Illustrating Compile-Time Index Translation with reindex in Julia\nDESCRIPTION: Demonstrates the core `reindex` mechanism for efficient index translation. It shows how calling `Base.reindex` with the `SubArray` (`S1`), its indices (`S1.indices`), and the input indices `(i, j)` translates the view indices `(i, j)` into the corresponding parent array indices `(i, S1.indices[2], S1.indices[3][j])` without runtime overhead. This relies on dispatching based on the *types* of the indices stored in `S1.indices`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nBase.reindex(S1, S1.indices, (i, j)) == (i, S1.indices[2], S1.indices[3][j])\n```\n```\n\n----------------------------------------\n\nTITLE: Resolving NTuple Ambiguity by Requiring Minimum Length in Julia\nDESCRIPTION: Presents an alternative strategy to resolve `NTuple` ambiguity. Instead of a dedicated empty tuple method, one of the methods (`Float64` variant here) is redefined using `Tuple{Float64, Vararg{Float64}}` which requires the tuple to contain at least one element, thus avoiding the `N=0` conflict with the `Int` fallback.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_42\n\nLANGUAGE: julia\nCODE:\n```\nf(x::NTuple{N,Int}) where {N} = 1           # this is the fallback\nf(x::Tuple{Float64, Vararg{Float64}}) = 2   # this requires at least one Float64\n```\n\n----------------------------------------\n\nTITLE: Calling Variadic C Functions with @ccall in Julia\nDESCRIPTION: Shows the syntax for calling variadic C functions, such as `printf`, using Julia's `@ccall` macro. A semicolon (`;`) is used within the argument list to separate the required arguments (like the format string) from the variable arguments that follow. The example demonstrates passing a format string, a C string literal, and a Julia integer variable `foo` to `printf`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_31\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @ccall printf(\"%s = %d\\n\"::Cstring ; \"foo\"::Cstring, foo::Cint)::Cint\nfoo = 3\n8\n```\n\n----------------------------------------\n\nTITLE: Handling Aliasing and Mutation Across Control Flow (PhiNodes) - Julia\nDESCRIPTION: This snippet illustrates how EscapeAnalysis can track aliasing of mutable objects (SafeRef) assigned along divergent control flows and how escape propagation operates via getfield/setfield! operations connected through IR-level phi nodes. The function takes a tuple (Bool, String), wraps a value in control-dependent SafeRef assignments, mutates a field, retrieves it, and returns it. Requires the availability of code_escapes and SafeRef. It highlights limitations and subtleties in propagating escape information within PHI nodes and SSA statements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\ncode_escapes((Bool, String,)) do cond, x\n    if cond\n        ϕ2 = ϕ1 = SafeRef(\"foo\")\n    else\n        ϕ2 = ϕ1 = SafeRef(\"bar\")\n    end\n    ϕ2[] = x\n    y = ϕ1[]\n    return y\nend\n```\n\n----------------------------------------\n\nTITLE: Constraining Parametric Functions to Subtypes Using 'where' Clause in Julia\nDESCRIPTION: Defines 'same_type_numeric' with parameter constraints (T<:Number), allowing it to apply only to pairs of values that are subtypes of Number. Provides fallback and error-handling behavior with MethodError when called on non-numeric arguments, illustrating advanced method signature constraints. Inputs must be subtypes of Number to return boolean answers; relies on Julia's type system and constrained generic function dispatch.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\nsame_type_numeric(x::T, y::T) where {T<:Number} = true\nsame_type_numeric(x::Number, y::Number) = false\n```\n\nLANGUAGE: julia\nCODE:\n```\nsame_type_numeric(1, 2)\nsame_type_numeric(1, 2.0)\nsame_type_numeric(1.0, 2.0)\nsame_type_numeric(\"foo\", 2.0)\nsame_type_numeric(\"foo\", \"bar\")\nsame_type_numeric(Int32(1), Int64(2))\n```\n\n----------------------------------------\n\nTITLE: Using Constrained Parametric Abstract Types in Julia\nDESCRIPTION: Demonstrates instantiating Pointy{T} with types allowed by constraint (Float64, Real) and shows errors encountered when using invalid types (AbstractString, integer values) based on the earlier defined type constraint (T<:Real). Provides feedback for correct and incorrect parameter choices within the type system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\njulia> Pointy{Float64}\nPointy{Float64}\n\njulia> Pointy{Real}\nPointy{Real}\n\njulia> Pointy{AbstractString}\nERROR: TypeError: in Pointy, in T, expected T<:Real, got Type{AbstractString}\n\njulia> Pointy{1}\nERROR: TypeError: in Pointy, in T, expected T<:Real, got a value of type Int64\n```\n\n----------------------------------------\n\nTITLE: Running a Single-Producer, Dual-Consumer Pipeline in Julia\nDESCRIPTION: Illustrates a complex pipeline setup in Julia. A helper function `prefixer` is defined, which creates a Perl command to prefix input lines and add a delay. The main `run` command executes a pipeline where one Perl process generates numbers (0-5), and its output is concurrently consumed by two instances of the `prefixer` command (one adding 'A', the other 'B'). The `&` operator creates the parallel consumers. The `$|=1` in Perl ensures immediate flushing of output.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n# jldoctest prefixer; filter = r\"([A-B] [0-5])\"\njulia> prefixer(prefix, sleep) = `perl -nle '$|=1; print \"'$prefix' \", $_; sleep '$sleep';'`;\n\njulia> run(pipeline(`perl -le '$|=1; for(0..5){ print; sleep 1 }'`, prefixer(\"A\",2) & prefixer(\"B\",2)));\nB 0\nA 1\nB 2\nA 3\nB 4\nA 5\n```\n\n----------------------------------------\n\nTITLE: Inspecting Expr Structure with head and args in Julia\nDESCRIPTION: Shows how to analyze the structure of an Expr object by accessing its .head and .args properties. This enables deeper introspection into the kind of operation and its arguments, facilitating complex code analysis and transformations. Dependencies: Expr object from Meta.parse or constructed directly; outputs are Symbol and argument list respectively.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> ex1.head\n:call\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> ex1.args\n3-element Vector{Any}:\n :+\n 1\n 1\n```\n\n----------------------------------------\n\nTITLE: Inspecting DataType Fields using fieldnames in Julia\nDESCRIPTION: Defines a simple struct `Point` with two fields, `x` (typed as `Int`) and `y` (untyped). It then demonstrates using the `fieldnames` function to retrieve a tuple of symbols representing the names of the fields within the `Point` struct.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/reflection.md#_snippet_0\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct Point\n           x::Int\n           y\n       end\n\njulia> fieldnames(Point)\n(:x, :y)\n```\n\n----------------------------------------\n\nTITLE: Defining Julia Modules with Cyclic Dependency Error\nDESCRIPTION: Demonstrates an `UndefVarError` that arises from cyclic dependencies between submodules. Module `B` attempts `using ..C`, and module `C` attempts `using ..B`. Because each module requires the other to be defined first, a circular dependency is created, leading to an error when `B` tries to load `C` which has not yet been fully defined.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\nmodule A\n\nmodule B\nusing ..C # ERROR: UndefVarError: `C` not defined in `Main.A`\nend\n\nmodule C\nusing ..B\nend\n\nend\n\n```\n\n----------------------------------------\n\nTITLE: Expanded Stride Calculations from @nexprs Macro - Julia\nDESCRIPTION: Shows the explicit assignments generated by expanding @nexprs 3 j->(s_{j+1} = s_j * size(A, j)), which calculates consecutive stride values for a 3-dimensional array. Each statement updates a stride variable based on its predecessor and the size of array A along one dimension. The example highlights the macro's ability to automate such repetitive computations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/cartesian.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\ns_1 = 1\\ns_2 = s_1 * size(A, 1)\\ns_3 = s_2 * size(A, 2)\\ns_4 = s_3 * size(A, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining Platform-Dependent Type Aliases in Julia (Example: UInt)\nDESCRIPTION: Demonstrates a type alias where `UInt` is assigned to `UInt32` on a hypothetical 32-bit system. This illustrates how type aliases provide convenient, platform-aware names for underlying types. On a 64-bit system, `UInt` would typically alias `UInt64`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_60\n\nLANGUAGE: julia-repl\nCODE:\n```\n# 32-bit system:\njulia> UInt\nUInt32\n```\n\n----------------------------------------\n\nTITLE: Verbose Output for Nested Test Sets in Julia\nDESCRIPTION: Shows the effect of the `verbose=true` option on `@testset`. When enabled, the summary includes details for all nested test sets, even if they all pass, unlike the default behavior which hides passing nested sets.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> @testset verbose = true \"Foo Tests\" begin\n           @testset \"Animals\" begin\n               @test foo(\"cat\") == 9\n               @test foo(\"dog\") == foo(\"cat\")\n           end\n           @testset \"Arrays $i\" for i in 1:3\n               @test foo(zeros(i)) == i^2\n               @test foo(fill(1.0, i)) == i^2\n           end\n       end;\nTest Summary: | Pass  Total  Time\nFoo Tests     |    8      8  0.0s\n  Animals     |    2      2  0.0s\n  Arrays 1    |    2      2  0.0s\n  Arrays 2    |    2      2  0.0s\n  Arrays 3    |    2      2  0.0s\n```\n\n----------------------------------------\n\nTITLE: Strict Boolean Requirement in Conditional Expressions - Julia\nDESCRIPTION: Highlights an error condition in Julia where a non-boolean value is used in an if condition, resulting in a TypeError. Reinforces Julia's enforcement of boolean types for conditional evaluation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> if 1\n           println(\"true\")\n       end\nERROR: TypeError: non-boolean (Int64) used in boolean context\n```\n\n----------------------------------------\n\nTITLE: Initializing SharedArray using indexpids in Julia REPL\nDESCRIPTION: Shows an alternative parallel initialization method for a 3x4 `SharedArray`. It uses `indexpids(S)` to get a worker-specific index and assigns the worker's ID (`myid()`) to elements distributed cyclically across workers based on the total number of participating processes (`length(procs(S))`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\njulia> S = SharedArray{Int,2}((3,4), init = S -> S[indexpids(S):length(procs(S)):length(S)] = repeat([myid()], length( indexpids(S):length(procs(S)):length(S))))\n3×4 SharedMatrix{Int64}:\n 2  2  2  2\n 3  3  3  3\n 4  4  4  4\n```\n\n----------------------------------------\n\nTITLE: Defining a Mutable Struct with a const Field in Julia\nDESCRIPTION: Shows how to declare a field as const in a mutable struct (Baz) and demonstrates the effect, including an error raised when attempting to modify a const field. Also highlights version dependency: const field annotation requires Julia 1.8 or above. Includes both successful and failed field assignments.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nmutable struct Baz\n    a::Int\n    const b::Float64\nend\n\nbaz = Baz(1, 1.5);\n\nbaz.a = 2\n2\n\nbaz.b = 2.0\nERROR: setfield!: const field .b of type Baz cannot be changed\n[...]\n```\n\n----------------------------------------\n\nTITLE: Using findall for Cartesian Indices - Julia\nDESCRIPTION: This snippet shows how to replace the deprecated 'findn' function with 'findall(!iszero, x)' for querying nonzero entries in an array. 'findall' now returns Cartesian indices for multidimensional arrays. No third-party dependencies are required, and it is compatible with Julia 1.0 or later. The function accepts an AbstractArray; output is a list of indices, and unlike 'findn', these may be CartesianIndex objects for higher dimensions.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_144\n\nLANGUAGE: julia\nCODE:\n```\nfindall(!iszero, x)\n```\n\n----------------------------------------\n\nTITLE: Comparing Unescaping in Regex vs Standard String Literals in Julia\nDESCRIPTION: Contrasts the behavior of `r\"...\"` regex literals with standard `\"...\"` string literals regarding interpolation (`$`) and escape sequences (`\\`). Regex literals generally treat characters literally, except for escaping the closing quote (`\"`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_55\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> x = 10\n10\n\njulia> r\"$x\"\nr\"$x\"\n\njulia> \"$x\"\n\"10\"\n\njulia> r\"\\x\"\nr\"\\x\"\n\njulia> \"\\x\"\nERROR: syntax: invalid escape sequence\n```\n\n----------------------------------------\n\nTITLE: Using the Simple `@assert` Macro in Julia\nDESCRIPTION: Demonstrates the usage of the previously defined simple `@assert` macro. Shows a successful assertion (`@assert 1 == 1.0`) and a failing assertion (`@assert 1 == 0`) which throws an `AssertionError` indicating the failed expression.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_36\n\nLANGUAGE: julia\nCODE:\n```\njulia> @assert 1 == 1.0\n\njulia> @assert 1 == 0\nERROR: AssertionError: 1 == 0\n```\n\n----------------------------------------\n\nTITLE: Manual Code Signing and Attribute Cleanup on macOS - Shell\nDESCRIPTION: Used for manual code signing of a writable .dmg image on macOS. This snippet demonstrates converting the original read-only .dmg into a writable format, mounting it for editing, applying a deep code signature with a specified certificate, and (if required) removing unwanted Finder attributes with xattr. Dependencies include hdiutil, codesign, and xattr, plus access to signing certificates in .p12 format. The 'disk3' device name and certificate string must match the environment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\nhdiutil convert julia-x.y.z-osx.dmg -format UDRW -o julia-x.y.z-osx_writable.dmg\\nmkdir ./jlmnt\\nhdiutil mount -mountpoint julia-x.y.z-osx_writable.dmg\\ncodesign -s \\\"AFB379C0B4CBD9DB9A762797FC2AB5460A2B0DBE\\\" --deep jlmnt/Julia-x.y.app\n```\n\nLANGUAGE: shell\nCODE:\n```\nxattr -cr jlmnt/Julia-x.y.app\n```\n\n----------------------------------------\n\nTITLE: Verifying and Printing Single-Function LLVM IR with Julia Codegen Plugin (Bash)\nDESCRIPTION: This command runs the Julia codegen pass pipeline over an extracted LLVM IR module for a specific function, prints the result in textual form with the -S flag, and verifies each pass. Requires that libjulia-codegen.so is available (with appropriate extension for the OS) and that the plus.ll file was previously generated from Julia. Provides detailed IR validation and is suitable for debugging transformation issues.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./usr/tools/opt -load-pass-plugin=libjulia-codegen.so --passes='julia' -S -verify-each plus.ll\n```\n\n----------------------------------------\n\nTITLE: Simulating Inefficient Runtime Index Translation Logic in Julia\nDESCRIPTION: Outlines a conceptual, but inefficient, way to perform index translation at runtime. It involves iterating through the stored indices (`S.indices`), checking their types (`Int`, `AbstractVector`, `AbstractMatrix`), dynamically building a `parentindices` vector, and finally indexing the parent array (`S.parent`). This approach is contrasted with the efficient `reindex` method used in Julia, highlighting the performance pitfalls of runtime type analysis for indexing.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nparentindices = Vector{Any}()\nfor thisindex in S.indices\n    ...\n    if isa(thisindex, Int)\n        # Don't consume one of the input indices\n        push!(parentindices, thisindex)\n    elseif isa(thisindex, AbstractVector)\n        # Consume an input index\n        push!(parentindices, thisindex[inputindex[j]])\n        j += 1\n    elseif isa(thisindex, AbstractMatrix)\n        # Consume two input indices\n        push!(parentindices, thisindex[inputindex[j], inputindex[j+1]])\n        j += 2\n    elseif ...\nend\nS.parent[parentindices...]\n```\n```\n\n----------------------------------------\n\nTITLE: Interpolating Characters and Strings Directly in Julia\nDESCRIPTION: Demonstrates that for `AbstractString` and `AbstractChar` types, interpolation inserts the value directly without adding quotes or performing escaping, as `string()` acts as the identity function for these types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_28\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> c = 'x'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> \"hi, $c\"\n\"hi, x\"\n```\n\n----------------------------------------\n\nTITLE: Assigning Operators to Variables for Functional Use - Julia\nDESCRIPTION: Illustrates the assignment of the '+' operator to a variable, using it as a regular function. The function assigned to 'f' computes the sum of its arguments when called. Demonstrates Julia's support for higher-order programming, where operators are function objects. No additional dependencies are needed. Input parameters are numeric, output is their sum.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_14\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> f = +;\n\njulia> f(1, 2, 3)\n6\n```\n\n----------------------------------------\n\nTITLE: Handling TOML Parsing Errors in Julia\nDESCRIPTION: Illustrates how the `TOML.parse` function throws an error when encountering syntactically incorrect TOML data. This example attempts to parse an invalid floating-point representation, resulting in a `TOML Parser error`.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/TOML/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> using TOML\n\njulia> TOML.parse(\"\"\"\n           value = 0.0.0\n       \"\"\"\n)\nERROR: TOML Parser error:\nnone:1:16 error: failed to parse value\n      value = 0.0.0\n                 ^\n[...]\n```\n\n----------------------------------------\n\nTITLE: Calling Wrapped C Functions for Environment Variables in Julia REPL\nDESCRIPTION: These Julia REPL examples show the use of the robust getenv wrapper function for both existent and non-existent environment variables. The snippets demonstrate correct function usage, result inspection, and the expected exception when a variable does not exist. Ensure safe string conversions and proper error checking when adapting for other C APIs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> getenv(\"SHELL\")\n\"/bin/bash\"\n\njulia> getenv(\"FOOBAR\")\nERROR: getenv: undefined variable: FOOBAR\n```\n\n----------------------------------------\n\nTITLE: Creating Dedented Multi-line Strings with Triple Quotes in Julia\nDESCRIPTION: Introduces triple-quoted string literals (`\"\"\"...\"\"\"`) which support multi-line content and automatic dedentation. Leading whitespace is removed from each line up to the level of the least-indented line (determined by the final line in this example).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_30\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> str = \"\"\"\n           Hello,\n           world.\n         \"\"\"\n\"  Hello,\\n  world.\\n\"\n```\n\n----------------------------------------\n\nTITLE: Type Inference for Large Integer Literals in Julia\nDESCRIPTION: Shows that integer literals too large to fit in 32 bits (like 3,000,000,000) are automatically inferred as `Int64`, regardless of whether the system is 32-bit or 64-bit.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\n# 32-bit or 64-bit system:\njulia> typeof(3000000000)\nInt64\n```\n```\n\n----------------------------------------\n\nTITLE: Annotating `@time`/`@timev` Reports in Julia\nDESCRIPTION: Explains that the `@time` and `@timev` macros in Julia can now accept an optional string description as their first argument. This description is included in the timing report output, providing context for what code block was being timed (e.g., `@time \"Evaluating foo\" foo()`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_43\n\nLANGUAGE: julia\nCODE:\n```\n@time \"Evaluating foo\" foo()\n```\n\nLANGUAGE: julia\nCODE:\n```\n@timev\n```\n\n----------------------------------------\n\nTITLE: Using Adjuster Functions for First and Last Days in Julia Dates Module\nDESCRIPTION: Illustrates adjuster methods for shifting a Date to the first day of its week, the last day of its month, or the last day of its quarter. These make temporal calculations such as finding boundaries straightforward. Dependencies include only Dates and a Date input.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\njulia> Dates.firstdayofweek(Date(2014,7,16)) # Adjusts the input to the Monday of the input's week\n2014-07-14\n\njulia> Dates.lastdayofmonth(Date(2014,7,16)) # Adjusts to the last day of the input's month\n2014-07-31\n\njulia> Dates.lastdayofquarter(Date(2014,7,16)) # Adjusts to the last day of the input's quarter\n2014-09-30\n```\n\n----------------------------------------\n\nTITLE: Examples of Bitwise Operators in Julia - Julia\nDESCRIPTION: This snippet showcases the use of bitwise operators (~, &, |, ⊻, nand, nor) on both signed and unsigned integer types in Julia. Pre-requisites include familiarity with Julia's integer types and bitwise operation functions. The output displays results as integers or hexadecimal representations for UInt types, highlighting behavior with both normal and specialized bitwise functions. Limitations include the need for Julia's Unicode symbols or `using Base: ⊻, ⊼, ⊽` for non-ASCII operators.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> ~123\n-124\n\njulia> 123 & 234\n106\n\njulia> 123 | 234\n251\n\njulia> 123 ⊻ 234\n145\n\njulia> xor(123, 234)\n145\n\njulia> nand(123, 123)\n-124\n\njulia> 123 ⊼ 123\n-124\n\njulia> nor(123, 124)\n-128\n\njulia> 123 ⊽ 124\n-128\n\njulia> ~UInt32(123)\n0xffffff84\n\njulia> ~UInt8(123)\n0x84\n```\n\n----------------------------------------\n\nTITLE: Setting up DocTest Environment in Julia\nDESCRIPTION: Configures the doctest environment by importing the `Random` module and setting a fixed seed (1234) using `Random.seed!`. This ensures that examples involving random numbers produce consistent results across test runs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nDocTestSetup = :(import Random; Random.seed!(1234))\n```\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `negate` Keyword in `Dates`: Use `!` Operator in Julia\nDESCRIPTION: The `negate` keyword argument is deprecated in all functions within the `Dates` adjuster API (`adjust`, `tonext`, `toprev`, `Date`, `Time`, `DateTime`). Use the predicate function negation operator `!` instead (e.g., `tonext(dt, !isweekend)`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_194\n\nLANGUAGE: julia\nCODE:\n```\n!\n```\n\n----------------------------------------\n\nTITLE: Calling a Julia Function from C via @cfunction Pointer\nDESCRIPTION: This snippet illustrates an alternative way to call Julia functions from C using `@cfunction`. It evaluates a Julia string that uses `@cfunction` to create a C-callable function pointer for `sqrt`, unboxes this pointer using `jl_unbox_voidpointer`, and then calls it like a native C function. This method handles type conversions on the Julia side and avoids dynamic dispatch overhead.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\ndouble (*sqrt_jl)(double) = jl_unbox_voidpointer(jl_eval_string(\"@cfunction(sqrt, Float64, (Float64,))\"));\ndouble ret = sqrt_jl(2.0);\n```\n\n----------------------------------------\n\nTITLE: Running Headless Tracy Capture to Save Trace File in Julia\nDESCRIPTION: This Julia snippet executes the Tracy capture tool in headless mode, saving the profiling trace directly to a file without opening the GUI. It uses command interpolation with `TracyProfiler_jll.capture()` to get the path to the capture executable and passes the `-o mytracefile.tracy` argument to specify the output filename. This is useful for automated trace collection.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/external_profilers.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nrun(`$(TracyProfiler_jll.capture()) -o mytracefile.tracy`)\n\n```\n\n----------------------------------------\n\nTITLE: Inspecting Methods of a Type Constructor in Julia\nDESCRIPTION: This snippet demonstrates that type objects themselves (like `Bool`) are callable in Julia and can have multiple methods defined, effectively acting as constructors. It uses the `methods()` function to list the various constructor methods available for the `Bool` type, showing different ways to convert other types (like `BigFloat`, `Float16`, `Rational`, `Real`, `Complex`, etc.) to `Bool`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_26\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> methods(Bool)\n# 10 methods for type constructor:\n  [1] Bool(x::BigFloat)\n     @ Base.MPFR mpfr.jl:393\n  [2] Bool(x::Float16)\n     @ Base float.jl:338\n  [3] Bool(x::Rational)\n     @ Base rational.jl:138\n  [4] Bool(x::Real)\n     @ Base float.jl:233\n  [5] (dt::Type{<:Integer})(ip::Sockets.IPAddr)\n     @ Sockets ~/tmp/jl/jl/julia-nightly-assert/share/julia/stdlib/v1.11/Sockets/src/IPAddr.jl:11\n  [6] (::Type{T})(x::Enum{T2}) where {T<:Integer, T2<:Integer}\n     @ Base.Enums Enums.jl:19\n  [7] (::Type{T})(z::Complex) where T<:Real\n     @ Base complex.jl:44\n  [8] (::Type{T})(x::Base.TwicePrecision) where T<:Number\n     @ Base twiceprecision.jl:265\n  [9] (::Type{T})(x::T) where T<:Number\n     @ boot.jl:894\n [10] (::Type{T})(x::AbstractChar) where T<:Union{AbstractChar, Number}\n     @ char.jl:50\n```\n\n----------------------------------------\n\nTITLE: Applying Explicit Types to Array Concatenation Syntax in Julia\nDESCRIPTION: Demonstrates that concatenation syntax (here, horizontal concatenation using spaces) can be prefixed with a type (`Int8`) to explicitly specify the element type of the resulting concatenated array, similar to typed array literals.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_10\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [[1 2] [3 4]]\n1×4 Matrix{Int64}:\n 1  2  3  4\n\njulia> Int8[[1 2] [3 4]]\n1×4 Matrix{Int8}:\n 1  2  3  4\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Deprecation Management Tools\nDESCRIPTION: This block uses the `@docs` directive to list tools for managing code deprecations in Julia. It includes the `@deprecate` macro for marking functions or methods as deprecated and the `depwarn` function for issuing deprecation warnings at runtime. The documentation generator will include details on how to use these tools.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.@deprecate\nBase.depwarn\n```\n```\n\n----------------------------------------\n\nTITLE: Displaying Code and Execution Time in Julia with `@showtime`\nDESCRIPTION: Introduces the `@showtime` macro in Julia. When applied to an expression, it first prints the expression itself (similar to `@show`) and then prints a timing report for the execution of that expression (similar to `@time`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_41\n\nLANGUAGE: julia\nCODE:\n```\n@showtime\n```\n\nLANGUAGE: julia\nCODE:\n```\n@time\n```\n\n----------------------------------------\n\nTITLE: Extracting Substring Based on Grapheme Indices in Julia\nDESCRIPTION: Returns a substring of string `s` containing the graphemes from the `m`-th index to the `n`-th index, inclusive. This respects Unicode grapheme boundaries.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\ngraphemes(s, m:n)\n```\n\n----------------------------------------\n\nTITLE: Skipping Iterations Using the continue Keyword in Julia\nDESCRIPTION: Shows how the `continue` keyword is used within a `for` loop to skip the remainder of the current iteration and proceed directly to the next one. In this example, the loop iterates from 1 to 10. If the current number `i` is not divisible by 3 (`i % 3 != 0`), `continue` is executed, skipping the `println(i)` call. As a result, only multiples of 3 (3, 6, 9) are printed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_23\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> for i = 1:10\n           if i % 3 != 0\n               continue\n           end\n           println(i)\n       end\n3\n6\n9\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `delete!(ENV, k, def)`: Use `pop!(ENV, k, def)` in Julia\nDESCRIPTION: The three-argument method `delete!(ENV::EnvDict, k::AbstractString, def)` is deprecated in Julia. Use `pop!(ENV, k, def)` instead. Note the difference in return value: `pop!` returns the value associated with key `k` (or the default `def`), whereas `delete!` returned the `ENV` dictionary (or `def`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_184\n\nLANGUAGE: julia\nCODE:\n```\npop!(ENV, k, def)\n```\n\n----------------------------------------\n\nTITLE: Subtyping of Parametric Primitive Types in Julia\nDESCRIPTION: Performs subtype checks between pointers of different parameterizations (Ptr{Float64}, Ptr{Int64}) and the umbrella Ptr type. This illustrates that all specific pointer types are subtypes of Ptr, despite equivalent memory representation, and demonstrates the flexibility of tag-based parametric primitives.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_46\n\nLANGUAGE: julia\nCODE:\n```\njulia> Ptr{Float64} <: Ptr\ntrue\n\njulia> Ptr{Int64} <: Ptr\ntrue\n```\n\n----------------------------------------\n\nTITLE: Executing Julia Code Inline with Arguments (Bash)\nDESCRIPTION: Shows how to execute a short Julia expression directly from the command line using the `-e` flag. It prints the `PROGRAM_FILE` (which will be empty in this case) and then iterates through and prints the command-line arguments (`foo`, `bar`) provided after the expression, which are stored in `ARGS`. `PROGRAM_FILE` is empty because no script file is being executed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/command-line-interface.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ julia -e 'println(PROGRAM_FILE); for x in ARGS; println(x); end' foo bar\n```\n\n----------------------------------------\n\nTITLE: Customizing Julia REPL Keybindings for History Navigation\nDESCRIPTION: This Julia code snippet demonstrates how to customize the REPL keybindings. It defines a custom keymap `mykeys` to override the default behavior of the up and down arrow keys, making them navigate history directly without prefix search. The `customize_keys` function applies this custom map using `REPL.setup_interface`, and `atreplinit` registers this function to be executed when the REPL starts. This code should be placed in the `~/.julia/config/startup.jl` file.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nimport REPL\nimport REPL.LineEdit\n\nconst mykeys = Dict{Any,Any}(\n    # Up Arrow\n    \"\\e[A\" => (s,o...)->(LineEdit.edit_move_up(s) || LineEdit.history_prev(s, LineEdit.mode(s).hist)),\n    # Down Arrow\n    \"\\e[B\" => (s,o...)->(LineEdit.edit_move_down(s) || LineEdit.history_next(s, LineEdit.mode(s).hist))\n)\n\nfunction customize_keys(repl)\n    repl.interface = REPL.setup_interface(repl; extra_repl_keymap = mykeys)\nend\n\natreplinit(customize_keys)\n```\n\n----------------------------------------\n\nTITLE: Declaring a USDT Probe in bpftrace Syntax - BPFtrace\nDESCRIPTION: This code illustrates the syntax for declaring a USDT probe in a bpftrace script to instrument specific events such as gc__begin in libjulia-internal.so. It captures the process start time at the beginning of GC using the nsecs built-in variable and stores it in a map keyed by PID. Dependencies: bpftrace, access to correct probe path, knowledge of relevant Julia USDT events.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_11\n\nLANGUAGE: bpftrace\nCODE:\n```\nusdt:usr/lib/libjulia-internal.so:julia:gc__begin\n{\n  @start[pid] = nsecs;\n}\n```\n\n----------------------------------------\n\nTITLE: Type{T} Behavior with Parametric Types in Julia\nDESCRIPTION: Defines a parametric struct `TypeParamExample{T}` and illustrates the invariant nature of `Type{T}` checks. `TypeParamExample isa Type{TypeParamExample}` is true because `TypeParamExample` is the type object itself. However, `TypeParamExample{Int} isa Type{TypeParamExample}` is false because `TypeParamExample{Int}` is a different type object. `TypeParamExample{Int} isa Type{TypeParamExample{Int}}` is true.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_56\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct TypeParamExample{T}\n           x::T\n       end\n\njulia> TypeParamExample isa Type{TypeParamExample}\ntrue\n\njulia> TypeParamExample{Int} isa Type{TypeParamExample}\nfalse\n\njulia> TypeParamExample{Int} isa Type{TypeParamExample{Int}}\ntrue\n```\n\n----------------------------------------\n\nTITLE: Infix Notation for Multiple Function Composition in Julia\nDESCRIPTION: Shows the infix notation for composing multiple functions (`f`, `g`, `h`) using the `∘` operator (typed as `\\circ<tab>`). This is equivalent to `∘(f, g, h)`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_91\n\nLANGUAGE: julia\nCODE:\n```\nf ∘ g ∘ h\n```\n\n----------------------------------------\n\nTITLE: Defining a Parametric Composite Type with a Single Field in Julia\nDESCRIPTION: Defines DiagPoint{T} as a subtype of Pointy{T} with a single field x of type T, representing points on the diagonal x=y. This demonstrates how different concrete and parametric types can implement a shared abstract interface, enabling polymorphic behaviors. No dependencies are required, but interfaces are generalized by parametric abstractions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\nstruct DiagPoint{T} <: Pointy{T}\n    x::T\nend\n```\n\n----------------------------------------\n\nTITLE: Dynamic Library Operations with Libdl API in Julia\nDESCRIPTION: This snippet enumerates all core Libdl functions and constants relevant for interacting with dynamic libraries: opening libraries (dlopen, dlopen_e), resolving symbols (dlsym, dlsym_e), handling library references (dlclose, dllist, dlpath, dlext), and searching for libraries (find_library, DL_LOAD_PATH, RTLD_NOW). All functions require the Libdl module and provide low-level access to operating system linking facilities, with parameters such as library filename, symbol name, and loading flags. These APIs are essential for advanced users interacting with native code from Julia, and users must handle OS-specific constraints or failure cases.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Libdl/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nLibdl.dlopen\nLibdl.dlopen_e\nLibdl.RTLD_NOW\nLibdl.dlsym\nLibdl.dlsym_e\nLibdl.dlclose\nLibdl.dlext\nLibdl.dllist\nLibdl.dlpath\nLibdl.find_library\nLibdl.DL_LOAD_PATH\n```\n\n----------------------------------------\n\nTITLE: Combining Newline Stripping and Dedentation in Julia Triple Quotes\nDESCRIPTION: Demonstrates how the leading newline stripping occurs *after* dedentation is calculated. Here, the initial newline is stripped, and then the remaining lines are dedented based on the indentation of `world.`. \nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_35\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> \"\"\"\n         Hello,\n         world.\"\"\"\n\"Hello,\\nworld.\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic @time Macro in Julia\nDESCRIPTION: Defines a simple `@time` macro that measures the execution time of a given expression `ex`. It stores start and end times using `time_ns()`, evaluates the expression, prints the elapsed time, and returns the expression's value. This initial version highlights potential hygiene issues as its internal variables (`t0`, `t1`, `val`) could clash with variables in the code where the macro is used.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_42\n\nLANGUAGE: julia\nCODE:\n```\nmacro time(ex)\n    return quote\n        local t0 = time_ns()\n        local val = $ex\n        local t1 = time_ns()\n        println(\"elapsed time: \", (t1-t0)/1e9, \" seconds\")\n        val\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `zeros`/`ones` with Array Argument: Use Size Argument in Julia\nDESCRIPTION: Methods for `zeros` and `ones` that accept an element type and an example array (e.g., `zeros(Float64, [1, 2, 3])`) are deprecated in Julia. Instead, provide the element type and the desired size, typically derived from the example array's size (e.g., `zeros(Float64, size([1, 2, 3]))`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_201\n\nLANGUAGE: julia\nCODE:\n```\nzeros(Float64, size([1, 2, 3]))\n```\n\n----------------------------------------\n\nTITLE: Viewing and Querying Strides of a Noncontiguous Array Slice (Julia)\nDESCRIPTION: Illustrates creation of a noncontiguous view (SubArray) of a parent Array using @view and range slicing, and shows how to compute its stride along the first dimension. 'V' is a view into A using non-unit steps, causing strides to differ from standard arrays. Input: an array A; Output: stride value for first dimension. The negative/positive stride indicates the direction and offset in memory due to slicing.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_44\n\nLANGUAGE: julia\nCODE:\n```\njulia> V = @view A[1:3:4, 2:2:6, 2:-1:1];\n\njulia> stride(V, 1)\n3\n```\n\n----------------------------------------\n\nTITLE: Symbol Initialization and Construction in Julia\nDESCRIPTION: Demonstrates creating symbols via literal and constructor syntax, and discusses symbol identity and construction with various argument types. These operations are core to dynamic variable referencing and metaprogramming. Inputs: identifiers or string/char arguments; output: Symbol objects.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> s = :foo\n:foo\n\njulia> typeof(s)\nSymbol\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> :foo === Symbol(\"foo\")\ntrue\n\njulia> Symbol(\"1foo\") # `:1foo` would not work, as `1foo` is not a valid identifier\nSymbol(\"1foo\")\n\njulia> Symbol(\"func\",10)\n:func10\n\njulia> Symbol(:var,'_','sym')\n:var_sym\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> :(:)\n:(:)\n\njulia> :(::)\n:(::)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom AbstractChannel (DictChannel) in Julia\nDESCRIPTION: Defines a custom channel type 'DictChannel' using a dictionary as its internal store and a threading condition for synchronization. Implements standard channel API functions such as put!, take!, fetch, isready, and wait for keyed access. Enables safe, keyed communication in concurrent or distributed contexts. Requires Threads.Condition, Dict, and proper understanding of thread safety issues.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_23\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct DictChannel{T} <: AbstractChannel{T}\n           d::Dict\n           cond_take::Threads.Condition    # waiting for data to become available\n           DictChannel{T}() where {T} = new(Dict(), Threads.Condition())\n           DictChannel() = DictChannel{Any}()\n       end\n\njulia> begin\n       function Base.put!(D::DictChannel, k, v)\n           @lock D.cond_take begin\n               D.d[k] = v\n               notify(D.cond_take)\n           end\n           return D\n       end\n       function Base.take!(D::DictChannel, k)\n           @lock D.cond_take begin\n               v = fetch(D, k)\n               delete!(D.d, k)\n               return v\n           end\n       end\n       Base.isready(D::DictChannel) = @lock D.cond_take !isempty(D.d)\n       Base.isready(D::DictChannel, k) = @lock D.cond_take haskey(D.d, k)\n       function Base.fetch(D::DictChannel, k)\n           @lock D.cond_take begin\n               wait(D, k)\n               return D.d[k]\n           end\n       end\n       function Base.wait(D::DictChannel, k)\n           @lock D.cond_take begin\n               while !isready(D, k)\n                   wait(D.cond_take)\n               end\n           end\n       end\n       end;\n\njulia> d = DictChannel();\n\njulia> isready(d)\nfalse\n\njulia> put!(d, :k, :v);\n\njulia> isready(d, :k)\ntrue\n\njulia> fetch(d, :k)\n:v\n\njulia> wait(d, :k)\n\njulia> take!(d, :k)\n:v\n\njulia> isready(d, :k)\nfalse\n```\n\n----------------------------------------\n\nTITLE: Conditional Use of `public` Keyword for Julia Version Compatibility\nDESCRIPTION: Provides a code pattern to conditionally use the `public` keyword, introduced in Julia 1.11, while maintaining compatibility with older versions (1.10 and below). It checks the `VERSION` constant and uses `eval(Meta.parse(...))` to execute the `public a, b, c` statement only if the Julia version is 1.11.0-DEV.469 or newer.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nVERSION >= v\"1.11.0-DEV.469\" && eval(Meta.parse(\"public a, b, c\"))\n```\n\n----------------------------------------\n\nTITLE: Receiving IP Multicast Packets with UDP in Julia\nDESCRIPTION: This snippet illustrates receiving UDP multicast packets using Julia's Sockets. It binds a UDPSocket to port 6789 on all interfaces, joins a multicast group, and prints the first received message from the socket. After receiving, it leaves the group and closes the socket. Inputs: UDP packets sent to the multicast address. Output: Message contents printed as a string. Requires Sockets standard library, multicasting enabled on the network, and port 6789 open.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\nusing Sockets\ngroup = ip\"228.5.6.7\"\nsocket = Sockets.UDPSocket()\nbind(socket, ip\"0.0.0.0\", 6789)\njoin_multicast_group(socket, group)\nprintln(String(recv(socket)))\nleave_multicast_group(socket, group)\nclose(socket)\n```\n\n----------------------------------------\n\nTITLE: `do`-Block Syntax for `dlopen` in Julia\nDESCRIPTION: The `dlopen()` function in `Libdl` now supports `do`-block syntax (`dlopen(...) do handle ... end`), providing a convenient way to manage the lifecycle of loaded dynamic libraries, similar to `open()`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_130\n\nLANGUAGE: julia\nCODE:\n```\nusing Libdl\n\ndlopen(\"mylib\") do handle\n    # Use handle for dlsym, etc.\nend # Library is automatically dlclose'd\n```\n\n----------------------------------------\n\nTITLE: Inspecting AST of a Quoted Expression in Julia\nDESCRIPTION: Demonstrates how to parse a quoted Julia expression `:(1+2)` into its Abstract Syntax Tree (AST) representation using `Meta.parse` and then displays its structure using `dump`. The output shows an `Expr` object with head `:quote` containing the actual expression `:call` for `+`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_11\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> dump(Meta.parse(\":(1+2)\"))\nExpr\n  head: Symbol quote\n  args: Array{Any}((1,))\n    1: Expr\n      head: Symbol call\n      args: Array{Any}((3,))\n        1: Symbol +\n        2: Int64 1\n        3: Int64 2\n```\n\n----------------------------------------\n\nTITLE: One-Dimensional Arrays in Julia\nDESCRIPTION: Julia supports true one-dimensional arrays (Vectors) of size `N`. This contrasts with MATLAB where column vectors are represented as size `Nx1`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nrand(N) # Creates a 1-dimensional array of size N\n```\n\n----------------------------------------\n\nTITLE: Creating a Doctest in Julia Documentation\nDESCRIPTION: Demonstrates a simple doctest using the `jldoctest` block within a docstring. It shows a REPL interaction (`julia> uppercase(\"Docstring test\")`) and its expected output (`\"DOCSTRING TEST\"`), which will be automatically verified when running `make -C doc doctest=true`. This ensures documentation examples remain correct.\nSOURCE: https://github.com/julialang/julia/blob/master/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> uppercase(\"Docstring test\")\n\"DOCSTRING TEST\"\n```\n```\n\n----------------------------------------\n\nTITLE: Index Style Specification for `enumerate` in Julia\nDESCRIPTION: The `enumerate` function in Julia now supports a two-argument form `enumerate(::IndexStyle, iterable)` which allows specifying the style of indices returned. `enumerate(IndexLinear, iterable)` yields linear indices, while `enumerate(IndexCartesian, iterable)` yields cartesian indices.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_177\n\nLANGUAGE: julia\nCODE:\n```\nenumerate(::IndexStyle, iterable)\n```\n\nLANGUAGE: julia\nCODE:\n```\nenumerate(IndexLinear, iterable)\n```\n\nLANGUAGE: julia\nCODE:\n```\nenumerate(IndexCartesian, iterable)\n```\n\n----------------------------------------\n\nTITLE: Starting Julia with Local Worker Processes via Command Line\nDESCRIPTION: Launches Julia with `N` local worker processes specified by the `--procs` command line flag. The package environment is automatically propagated to these workers.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\n--procs=N\n```\n\n----------------------------------------\n\nTITLE: Handling Failures in Nested Test Sets in Julia\nDESCRIPTION: Illustrates the output when a test fails within a nested `@testset`. The summary only shows details for the test sets containing failures (here, \"Arrays\" and the top-level \"Foo Tests\"), along with the specific failure information and a final error indicating not all tests passed.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> @testset \"Foo Tests\" begin\n           @testset \"Animals\" begin\n               @testset \"Felines\" begin\n                   @test foo(\"cat\") == 9\n               end\n               @testset \"Canines\" begin\n                   @test foo(\"dog\") == 9\n               end\n           end\n           @testset \"Arrays\" begin\n               @test foo(zeros(2)) == 4\n               @test foo(fill(1.0, 4)) == 15\n           end\n       end\n\nArrays: Test Failed\n  Expression: foo(fill(1.0, 4)) == 15\n   Evaluated: 16 == 15\n[...]\nTest Summary: | Pass  Fail  Total  Time\nFoo Tests     |    3     1      4  0.0s\n  Animals     |    2            2  0.0s\n  Arrays      |    1     1      2  0.0s\nERROR: Some tests did not pass: 3 passed, 1 failed, 0 errored, 0 broken.\n```\n\n----------------------------------------\n\nTITLE: 12-Hour Clock and AM/PM Formatting/Parsing for Dates/Times in Julia\nDESCRIPTION: `DateTime` and `Time` formatting/parsing now supports 12-hour clock formats with AM/PM indicators using the `I` (hour) and `p` (AM/PM) format codes, similar to `strftime`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_139\n\nLANGUAGE: julia\nCODE:\n```\nusing Dates\ndt = DateTime(2023, 10, 27, 15, 30)\nDates.format(dt, \"I:M p\") # Output: \"3:30 PM\"\n```\n\n----------------------------------------\n\nTITLE: Writing Unit Tests for Math Functions in Julia\nDESCRIPTION: Contains example unit tests for the `simple_add` and `type_multiply` functions from the `Example` package, intended to be placed in `math_tests.jl`. It uses `@testset` to group related tests (`Testset 1`, `Testset 2`) and employs `@test` for asserting correct return values and types (`isa`), and `@test_throws MethodError` to assert that specific incorrect inputs raise the expected error.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\n@testset \"Testset 1\" begin\n    @test 2 == simple_add(1, 1)\n    @test 3.5 == simple_add(1, 2.5)\n    @test_throws MethodError simple_add(1, \"A\")\n    @test_throws MethodError simple_add(1, 2, 3)\nend\n\n@testset \"Testset 2\" begin\n    @test 1.0 == type_multiply(1.0, 1.0)\n    @test isa(type_multiply(2.0, 2.0), Float64)\n    @test_throws MethodError type_multiply(1, 2.5)\nend\n```\n\n----------------------------------------\n\nTITLE: Dependency Version and Patch Update Checklist - Markdown - Markdown\nDESCRIPTION: A structured Markdown checklist detailing all files and values to verify or update when incrementing the version of a Julia dependency. Used to systematically track changes like version fields, checksums, and patch files during maintenance. Relies on consistent naming for dependencies, and applies to Julia's custom build system; items may not exist for every dependency.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_24\n\nLANGUAGE: md\nCODE:\n```\n### Check list\n\nVersion numbers:\n- [ ] `deps/$(libname).version`: `LIBNAME_VER`, `LIBNAME_BRANCH`, `LIBNAME_SHA1` and `LIBNAME_JLL_VER`\n- [ ] `stdlib/$(LIBNAME_JLL_NAME)_jll/Project.toml`: `version`\n\nChecksum:\n- [ ] `deps/checksums/$(libname)`\n- [ ] `deps/checksums/$(LIBNAME_JLL_NAME)-*/`: `md5` and `sha512`\n\nPatches:\n- [ ] `deps/$(libname).mk`\n- [ ] `deps/patches/$(libname)-*.patch`\n```\n\n----------------------------------------\n\nTITLE: Actual (Incorrect) Reindexing Output with CartesianIndex in Julia\nDESCRIPTION: This Julia snippet shows the incorrect tuple structure that `Base.reindex` actually generates when processing `CartesianIndex` arguments based solely on its standard type dispatch mechanism. It contrasts with the desired output, demonstrating how the reindexing mechanism fails because it doesn't skip the empty `CartesianIndex()` and incorrectly applies the second `CartesianIndex` to the third stored index. This limitation necessitates special handling for `CartesianIndex` within the `view` function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\n(CartesianIndex(), S1.indices[2], S1.indices[3][CartesianIndex(2,1)])\n```\n\n----------------------------------------\n\nTITLE: Building Optimized Julia with Make and BOLT - Bash\nDESCRIPTION: This Bash code snippet provides the sequential 'make' commands necessary to build a PGO, LTO, and BOLT optimized version of Julia. It requires a compatible Linux system on x86_64 or aarch64 and an appropriate build environment for Julia. The commands, when executed in the correct directory, produce an optimized Julia build in the 'optimized.build' folder. Dependencies include working Makefile targets and required build tools, and outputs are not aligned for huge pages, resulting in .so files that are 2-4MB smaller.\nSOURCE: https://github.com/julialang/julia/blob/master/contrib/pgo-lto-bolt/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake stage1\nmake stage2\nmake copy_originals\nmake bolt_instrument\nmake finish_stage2\nmake merge_data\nmake bolt\n```\n\n----------------------------------------\n\nTITLE: Using Bitwise Operators & and | for Non-Short-Circuiting Boolean Logic in Julia\nDESCRIPTION: Demonstrates the behavior of bitwise operators `&` (and) and `|` (or) using the previously defined functions `f` and `t`. Unlike their logical counterparts `&&` and `||`, these bitwise operators always evaluate both operands, irrespective of the value of the first operand. This non-short-circuiting behavior is confirmed by the output, which shows both `println` calls executing in both cases.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_14\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> f(1) & t(2)\n1\n2\nfalse\n\njulia> t(1) | t(2)\n1\n2\ntrue\n```\n\n----------------------------------------\n\nTITLE: Custom BroadcastStyle Rules for AbstractArray Types - Julia\nDESCRIPTION: Overrides default broadcast style resolution between different AbstractArrayStyle types in Julia. These three methods determine which array style should be used as the result type for broadcasting, with dimensionality-aware logic for selecting the most specific or highest dimensional style. Inputs include AbstractArrayStyle instances and their dimensionality parameters. Outputs are the dominant style or a type constructed with Val(max(M,N)). Prerequisites: custom or built-in AbstractArray types; used primarily by package authors.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\nBroadcastStyle(a::AbstractArrayStyle{Any}, ::DefaultArrayStyle) = a\nBroadcastStyle(a::AbstractArrayStyle{N}, ::DefaultArrayStyle{N}) where N = a\nBroadcastStyle(a::AbstractArrayStyle{M}, ::DefaultArrayStyle{N}) where {M,N} =\n    typeof(a)(Val(max(M, N)))\n```\n\n----------------------------------------\n\nTITLE: Inspecting Methods of a Generic Function in Julia\nDESCRIPTION: This output shows the result of inspecting the methods of a generic function `f` (likely using `methods(f)`). It reveals two defined methods: one specifically for `Float64` arguments and another for any `Number` arguments, along with their definition locations (REPL in this case, indicated by `none:1`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n# 2 methods for generic function \"f\" from Main:\n [1] f(x::Float64, y::Float64)\n     @ none:1\n [2] f(x::Number, y::Number)\n     @ none:1\n```\n\n----------------------------------------\n\nTITLE: Observing Parse-Time Execution During Macro Expansion in Julia\nDESCRIPTION: Shows the output produced when calling `macroexpand` on the `@twostep` macro. The first `println` statement from the macro definition is executed immediately, demonstrating the parse-time action. The variable `ex` captures the expression returned by the macro.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_27\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> ex = macroexpand(Main, :(@twostep :(1, 2, 3)) );\nI execute at parse time. The argument is: :((1, 2, 3))\n```\n\n----------------------------------------\n\nTITLE: Using Regex String Literals for Efficiency in Julia Loops\nDESCRIPTION: This Julia code demonstrates using the `r\"\"` non-standard string literal within a `for` loop. The regex `r\"^\\s*(?:#|$)\"` is compiled only once before the loop starts, making it more efficient than creating a `Regex` object inside the loop.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_57\n\nLANGUAGE: julia\nCODE:\n```\nfor line = lines\n    m = match(r\"^\\s*(?:#|$)\", line)\n    if m === nothing\n        # non-comment\n    else\n        # comment\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Applying `@inline`/`@noinline` within Julia Function Bodies\nDESCRIPTION: Mentions the capability introduced in Julia v1.8 to place the `@inline` and `@noinline` macros directly within a function body. This allows annotating specific parts of the function, including anonymous functions, to suggest inlining or prevent it.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\n@inline\n```\n\nLANGUAGE: julia\nCODE:\n```\n@noinline\n```\n\n----------------------------------------\n\nTITLE: Performing Generic Function Call via jl_call - C\nDESCRIPTION: Shows the variant of the Julia C API for function calls, where the function and its arguments are passed separately. jl_call is used when the function pointer (jl_function_t *f) and arguments (jl_value_t **args) are provided, with nargs specifying argument count. This entry point is suitable for use where the function is already separated from its arguments, obeying Julia's calling conventions. Prerequisites: an initialized Julia environment and properly typed pointers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *jl_call(jl_function_t *f, jl_value_t **args, int32_t nargs);\n```\n\n----------------------------------------\n\nTITLE: Building RISC-V GNU Toolchain - sh\nDESCRIPTION: Defines the shell commands to configure and build the riscv-gnu-toolchain with C, C++, and Fortran support, targeting installation under /opt/riscv. The commands set up permissions, run configure with a custom prefix, then build using all available CPU cores via 'make -j$(nproc)'. Prerequisites: user must have sudo access and sufficient disk space. Outputs are the cross-compiler binaries and libraries installed in /opt/riscv.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/riscv.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nsudo mkdir /opt/riscv && sudo chown $USER /opt/riscv\n./configure --prefix=/opt/riscv --with-languages=c,c++,fortran\nmake linux -j$(nproc)\n```\n\n----------------------------------------\n\nTITLE: Generating and Filtering Checksums for Build Artifacts - Shell\nDESCRIPTION: Calculates SHA-256 and MD5 checksums for all Julia build artifacts matching a pattern, filters out any extraneous files (e.g., existing checksum or signature records), and outputs to .sha256 and .md5 files. Dependencies include shasum, md5sum (or md5 -r on macOS), and grep. The main parameter is the file pattern (julia-x.y.z*) and the resulting checksum files are used for upload and verification.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_24\n\nLANGUAGE: shell\nCODE:\n```\nshasum -a 256 julia-x.y.z* | grep -v -e sha256 -e md5 -e asc > julia-x.y.z.sha256\\nmd5sum julia-x.y.z* | grep -v -e sha256 -e md5 -e asc > julia-x.y.z.md5\n```\n\n----------------------------------------\n\nTITLE: Using Let Block for Local Scope in Julia\nDESCRIPTION: Illustrates the recommended method to create a local variable scope for counting and printing numbers from 1 through 5 by wrapping the logic inside a let block. This avoids errors related to global/local scope and ensures consistent variable visibility within the loop. No external dependencies are needed. The key parameter 'i' is initialized in the let block, and the code prints integers 1 to 5. This approach is suitable for scripts where code is not wrapped in a function.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables-and-scoping.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n# Print the numbers 1 through 5\\nlet i = 0\\n    while i < 5\\n        i += 1     # Now outer `i` is defined in the inner scope of the while loop\\n        println(i)\\n    end\\nend\n```\n\n----------------------------------------\n\nTITLE: Declaring Libuv-based Formatted Output Functions in C\nDESCRIPTION: Declares C functions `jl_printf` and `jl_vprintf` which provide formatted output capabilities similar to standard `printf` and `vprintf`. These functions operate on libuv streams (`uv_stream_t*`) and are used throughout the Julia runtime's C code (`src/`, `cli/`) to ensure unified output buffering.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/stdio.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint jl_printf(uv_stream_t *s, const char *format, ...);\nint jl_vprintf(uv_stream_t *s, const char *format, va_list args);\n```\n\n----------------------------------------\n\nTITLE: Custom Admonition Block in Markdown - Markdown\nDESCRIPTION: This snippet demonstrates how to define a custom admonition block type in Markdown. The block is created by specifying a custom type, such as 'terminology', after the triple exclamation marks, accompanied by an optional custom title. The indented content provides the explanatory text. Custom admonition types allow for semantic expansion, but may receive default styling unless specially handled by the document renderer. This approach is suited for documentation authors who require more nuanced information highlighting.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_24\n\nLANGUAGE: markdown\nCODE:\n```\n!!! terminology \"julia vs Julia\"\n\n    Strictly speaking, \"Julia\" refers to the language,\n    and \"julia\" to the standard implementation.\n```\n\n----------------------------------------\n\nTITLE: Illustrating TypeError for Non-Boolean in && Context in Julia\nDESCRIPTION: Shows that using a non-boolean value (specifically, the integer `1`) as an operand within a boolean context controlled by the `&&` operator results in a `TypeError`. Julia requires operands in logical operations (except potentially the very last one in a chain) to be strictly boolean (`true` or `false`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_15\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> 1 && true\nERROR: TypeError: non-boolean (Int64) used in boolean context\n```\n\n----------------------------------------\n\nTITLE: Getting Lowered Code Form using Meta.lower in Julia\nDESCRIPTION: Demonstrates using `Meta.lower` to obtain the lowered form (a simplified intermediate representation closer to primitive operations) of a given Julia expression. The example lowers the expression `[1+2, sin(0.5)]`. Requires `Base: +` and `sin` to be available in the context.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/reflection.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Meta.lower(@__MODULE__, :( [1+2, sin(0.5)] ))\n:($(Expr(:thunk, CodeInfo(\n1 ─ %1 = :+\n│   %2 =   dynamic (%1)(1, 2)\n│   %3 = sin\n│   %4 =   dynamic (%3)(0.5)\n│   %5 =   dynamic Base.vect(%2, %4)\n└──      return %5\n))))\n```\n\n----------------------------------------\n\nTITLE: Setting CPU Affinity for Sub-processes in Julia\nDESCRIPTION: Introduces the `setcpuaffinity(cmd, cpus)` function in Julia. It allows specifying the CPU affinity for a sub-process launched via a `Cmd` object (`cmd`), restricting its execution to the set of CPUs specified by `cpus`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_39\n\nLANGUAGE: julia\nCODE:\n```\nsetcpuaffinity(cmd, cpus)\n```\n\n----------------------------------------\n\nTITLE: Controlling Concatenation Order with Double Semicolons in Julia\nDESCRIPTION: Illustrates how using double semicolons (`;;`) for horizontal concatenation changes the order of operations compared to spaces. Double semicolons perform vertical concatenations (separated by `;`) *before* performing the horizontal concatenation, contrasting with the space/tab behavior where horizontal concatenation happens first.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [zeros(Int, 2, 2) ; [3 4] ;; [1; 2] ; 5]\n3×3 Matrix{Int64}:\n 0  0  1\n 0  0  2\n 3  4  5\n\njulia> [1:2; 4;; 1; 3:4]\n3×2 Matrix{Int64}:\n 1  1\n 2  3\n 4  4\n```\n\n----------------------------------------\n\nTITLE: Comparing Byte Escapes and Unicode Escapes in Julia Byte Array Literals\nDESCRIPTION: Highlights the distinction between hexadecimal byte escapes (`\\x`) and Unicode escapes (`\\u`) within byte array literals. `b\"\\xff\"` produces a single byte `0xff`. In contrast, `b\"\\uff\"` represents the Unicode code point U+00FF, which gets encoded into its two-byte UTF-8 representation (`0xc3`, `0xbf`) within the byte array.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_60\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> b\"\\xff\"\n1-element Base.CodeUnits{UInt8, String}:\n 0xff\n\njulia> b\"\\uff\"\n2-element Base.CodeUnits{UInt8, String}:\n 0xc3\n 0xbf\n```\n\n----------------------------------------\n\nTITLE: Cross-architecture building with MARCH variable - Makefile - Shell\nDESCRIPTION: Specifies the target architecture/cpu for Julia's system image and runtime libraries by passing the 'MARCH' variable when invoking 'make'. Ensures portability across older or baseline CPUs by tuning generated binaries accordingly. Prerequisite: Knowledge of supported architectures and desired baseline. Input: 'MARCH' variable (e.g., x86-64, core2, pentium4) set in the make command. Output: A Julia build targeting the specified architecture.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nmake MARCH=core2\n```\n\n----------------------------------------\n\nTITLE: Representing jlcall in LLVM IR for Optimization (LLVM IR)\nDESCRIPTION: Demonstrates the LLVM IR `call` instruction used to represent the `jlcall` calling convention instead of a direct C ABI lowering. This representation, using an intrinsic-like pattern (`julia.call`), passes arguments directly as SSA values (`%arg1`, `%arg2`), preserving their SSA nature for LLVM optimizers before GC root placement lowers the call to the actual C ABI.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_9\n\nLANGUAGE: llvm\nCODE:\n```\ncall %jl_value_t *@julia.call(jl_value_t *(*)(...) @any_unoptimized_call, %jl_value_t *%arg1, %jl_value_t *%arg2)\n```\n\n----------------------------------------\n\nTITLE: Applying the Power Method to Dense, GPU, and Distributed Arrays (Julia REPL)\nDESCRIPTION: This Julia REPL example demonstrates the usage of the previously defined power_method function on regular, GPU, and distributed arrays. It shows instantiation of matrices and vectors, converting them with CuArray and distribute, and then applying the power method to check for compatibility. This snippet highlights the function's polymorphism and ability to work with different array implementations, as well as returning outputs with types respective to each backend. Dependencies: CUDA.jl, DistributedArrays.jl. Inputs: 2x2 matrices and 2-element vectors of Float64; Outputs: eigenvector/eigenvalue pairs as tuples, with types matching the input backend.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_46\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> M = [2. 1; 1 1];\n\njulia> v = rand(2)\n2-element Vector{Float64}:\n0.40395\n0.445877\n\njulia> power_method(M,v)\n([0.850651, 0.525731], 2.618033988749895)\n\njulia> cuM = CuArray(M);\n\njulia> cuv = CuArray(v);\n\njulia> curesult = power_method(cuM, cuv);\n\njulia> typeof(curesult)\nCuArray{Float64,1}\n\njulia> dM = distribute(M);\n\njulia> dv = distribute(v);\n\njulia> dC = power_method(dM, dv);\n\njulia> typeof(dC)\nTuple{DistributedArrays.DArray{Float64,1,Vector{Float64}},Float64}\n```\n\n----------------------------------------\n\nTITLE: Querying Macro Documentation in REPL Help Mode\nDESCRIPTION: This shows using the REPL's Help mode (`help?>`) to get documentation for a macro. Typing `@time` fetches and displays the docstring associated with the `@time` macro.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nhelp?> @time\n  @time\n\n  A macro to execute an expression, printing the time it took to execute, the number of allocations,\n  and the total number of bytes its execution caused to be allocated, before returning the value of the\n  expression.\n\n  See also @timev, @timed, @elapsed, and @allocated.\n```\n\n----------------------------------------\n\nTITLE: Nested GC Rooting in C using Inner Blocks\nDESCRIPTION: This snippet demonstrates how to correctly root Julia values (`ret1`, `ret2`) that have different lifetimes within a C function using nested blocks. Each `JL_GC_PUSH*` call is paired with a `JL_GC_POP` in its corresponding block, ensuring proper management of GC roots on the C stack.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_16\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *ret1 = jl_eval_string(\"sqrt(2.0)\");\nJL_GC_PUSH1(&ret1);\njl_value_t *ret2 = 0;\n{\n    jl_function_t *func = jl_get_function(jl_base_module, \"exp\");\n    ret2 = jl_call1(func, ret1);\n    JL_GC_PUSH1(&ret2);\n    // Do something with ret2.\n    JL_GC_POP();    // This pops ret2.\n}\nJL_GC_POP();    // This pops ret1.\n```\n\n----------------------------------------\n\nTITLE: Explicitly Defining the Default Inner Constructor Behavior in Julia\nDESCRIPTION: Defines a `struct` `Foo` with an explicit inner constructor that takes all fields (`bar`, `baz`) as arguments and calls `new(bar, baz)`. This explicitly shows the behavior that Julia provides by default when no inner constructor is specified.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct Foo\n           bar\n           baz\n           Foo(bar,baz) = new(bar,baz)\n       end\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Minimal Module in Julia\nDESCRIPTION: Demonstrates how to create a truly minimal module named `:arithmetic` using `Module(:name, false, false)`, which does not import `Core` or `Base` by default. Code (like the `add` function) is then evaluated into this module's scope using `@eval`, and the function is subsequently called via qualification (`arithmetic.add`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_21\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> arithmetic = Module(:arithmetic, false, false)\nMain.arithmetic\n\njulia> @eval arithmetic add(x, y) = $(+)(x, y)\nadd (generic function with 1 method)\n\njulia> arithmetic.add(12, 13)\n25\n```\n\n----------------------------------------\n\nTITLE: Replacing indices with axes - Julia\nDESCRIPTION: Shows updated indexing API by substituting the 'indices' method with 'axes', supporting more flexible and accurate dimension introspection in Julia arrays. Inputs include arrays and an optional dimension; the output is a tuple or object representing array axes.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_153\n\nLANGUAGE: julia\nCODE:\n```\naxes(a)\naxes(a, d)\n```\n\n----------------------------------------\n\nTITLE: Creating N-Dimensional Constant Arrays with Tuple Generation - Base Julia - Julia\nDESCRIPTION: Shows how to use a function to produce N-dimensional constant-filled arrays by generating a size tuple using `ntuple`. This approach takes in the fill value and the number of dimensions `N`, but the output type is not type-stable for arbitrary `N`. Requires only Julia Base. Useful for dynamically specifying array dimensions but suffers performance loss due to type instability.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\njulia> function array3(fillval, N)\n           fill(fillval, ntuple(d->3, N))\n       end\narray3 (generic function with 1 method)\n\njulia> array3(5.0, 2)\n3×3 Matrix{Float64}:\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n 5.0  5.0  5.0\n```\n\n----------------------------------------\n\nTITLE: Delegating Struct Initialization in Julia\nDESCRIPTION: Defines a `mutable struct` `Lazy` with an inner constructor `Lazy(v)`. This constructor creates an incomplete object using `new()` (leaving the `data` field uninitialized) and immediately passes this incomplete object along with a value `v` to an external function `complete_me`. This pattern allows the responsibility of completing the object's initialization to be delegated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/constructors.md#_snippet_14\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> mutable struct Lazy\n           data\n           Lazy(v) = complete_me(new(), v)\n       end\n```\n\n----------------------------------------\n\nTITLE: Working with Nested Expressions Using Meta.parse in Julia\nDESCRIPTION: Shows parsing of an expression with nested operations, demonstrating the ability to handle and operate on complex code trees. Such capability is fundamental when programs need to analyze or generate expressions involving a hierarchy of sub-expressions. Input: code string with sub-expressions; output: nested Expr.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> ex3 = Meta.parse(\"(4 + 4) / 2\")\n:((4 + 4) / 2)\n```\n\n----------------------------------------\n\nTITLE: Using Underscore Digit Separators in Numeric Literals (Julia)\nDESCRIPTION: Demonstrates the use of underscores as digit separators in integer, floating-point, hexadecimal, and binary literals for increased readability. Evaluates multiple types in a tuple, showing proper parsing by Julia. No special dependencies or constraints.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\njulia> 10_000, 0.000_000_005, 0xdead_beef, 0b1011_0010\n(10000, 5.0e-9, 0xdeadbeef, 0xb2)\n```\n\n----------------------------------------\n\nTITLE: Performing In-Place Kronecker Product with `Base.kron!` in Julia\nDESCRIPTION: The new function `Base.kron!` allows computing the Kronecker product of matrices and storing the result in a pre-allocated output matrix. Overloads are provided for various matrix types to optimize performance.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_63\n\nLANGUAGE: julia\nCODE:\n```\nA = [1 2; 3 4]\nB = [0 1; 1 0]\nC = zeros(4, 4)\nBase.kron!(C, A, B)\n```\n\n----------------------------------------\n\nTITLE: Adding a Docstring to a Julia Function\nDESCRIPTION: Illustrates how to add a docstring (represented by `\"...\"`) directly above a function definition (`function bar(...)`) in Julia's `base/` directory as part of the documentation contribution process. This docstring provides documentation for the function `bar`.\nSOURCE: https://github.com/julialang/julia/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n\"...\"\nfunction bar(args...)\n    # ...\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Julia Module for Distributed Examples\nDESCRIPTION: Creates the content for a file named `DummyModule.jl` containing a simple module `DummyModule`. This module exports `MyType` and `f`, defines a mutable struct `MyType`, a function `f`, and includes a `println(\"loaded\")` statement which executes upon module loading, useful for confirming when and where the module is loaded.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nmodule DummyModule\n\nexport MyType, f\n\nmutable struct MyType\n    a::Int\nend\n\nf(x) = x^2+1\n\nprintln(\"loaded\")\n\nend\n```\n\n----------------------------------------\n\nTITLE: Illustrating LLVM's Exception Handling Control Flow (LLVM IR)\nDESCRIPTION: This snippet illustrates the typical LLVM IR approach for handling potential exceptions using the `invoke` instruction. `invoke` specifies both a normal continuation label (`%regular`) and an exception unwinding label (`%catch`). This makes potentially throwing calls explicit basic block terminators. Julia avoids this approach because it's often difficult to determine which calls might throw early in the optimization pipeline.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_8\n\nLANGUAGE: llvm\nCODE:\n```\ninvoke @function_that_may_throw() to label %regular unwind to %catch\n\nregular:\n# Control flow continues here\n\ncatch:\n# Exceptions go here\n```\n\n----------------------------------------\n\nTITLE: Invoking Windows Distributed Workers via SSH - Julia Distributed\nDESCRIPTION: This snippet shows the addition of support for invoking Windows worker processes via SSH with the shell=:wincmd keyword in addprocs (Julia's Distributed standard library). This enhancement allows launching worker nodes on Windows using native SSH commands with configurable environment variables and SSH client options. Requires Distributed module and working SSH setup; key parameters include shell= and env= for command customization.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_76\n\nLANGUAGE: julia\nCODE:\n```\nusing Distributed\naddprocs([\"winhost\"], shell=:wincmd, ssh=\"C:/Windows/System32/OpenSSH/ssh.exe\", env=[\"MYVAR\"=>\"VALUE\"])\n```\n\n----------------------------------------\n\nTITLE: Calling Julia Object Display Internally (Julia ccall)\nDESCRIPTION: This Julia code uses ccall to invoke the C function 'jl_' with the given Julia object. The call prints the representation in the Julia session, which is particularly useful when debugger-based calls are not practical. Requires Julia running with access to the internal C APIs. The single parameter 'obj' can be any Julia object you want to display. No value is returned (Cvoid).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nccall(:jl_, Cvoid, (Any,), obj)\n```\n\n----------------------------------------\n\nTITLE: Installing Julia via winget on Windows\nDESCRIPTION: Uses the Windows Package Manager (winget) command-line tool to install Julia from the Microsoft Store. The command specifies the application name ('Julia'), its store ID ('9NJNWW8PVKMN'), requests an exact match ('-e'), and targets the Microsoft Store source ('-s msstore').\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/installation.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nwinget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\n```\n\n----------------------------------------\n\nTITLE: Evaluating Polynomials with `evalpoly` Function in Julia\nDESCRIPTION: Illustrates the preferred method for polynomial evaluation using the `evalpoly` function. It takes the variable `x` and a tuple of coefficients `(p1, p2, p3)`, offering efficiency comparable to the older `@evalpoly` macro.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_89\n\nLANGUAGE: julia\nCODE:\n```\nevalpoly(x, (p1, p2, p3))\n```\n\n----------------------------------------\n\nTITLE: DTrace GC Probe Semaphore Macro and Declaration - C\nDESCRIPTION: Demonstrates how a specific USDT probe for GC begin is declared and guarded by a memory-mapped semaphore in C. The macro defines the enabled check, and the semaphore declaration ensures compatibility with expected linker sections for probes. Dependencies: GCC-compatible compiler to handle attributes and extensions, and the build scripts that generate probe macros. Called from the Julia runtime when instrumenting GC phases; no arguments in this sample.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#define JL_PROBE_GC_BEGIN_ENABLED() __builtin_expect (julia_gc__begin_semaphore, 0)\n__extension__ extern unsigned short julia_gc__begin_semaphore __attribute__ ((unused)) __attribute__ ((section (\".probes\")));\n```\n\n----------------------------------------\n\nTITLE: Sample Builtin Function Interface in Julia's Runtime - C\nDESCRIPTION: Shows the C calling convention used by Julia's core built-in functions. This function pointer signature accepts a Julia value (possibly the 'this' context), an array of argument pointers, and an argument count. Builtins are defined in this manner for efficiency and dynamic dispatch from the Julia interpreter, and have associated method tables and singleton types. Requires internals of the Julia runtime.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *(jl_value_t*, jl_value_t**, uint32_t)\n```\n\n----------------------------------------\n\nTITLE: Auto-documenting Concrete Number Types - Julia - Julia\nDESCRIPTION: Provides an @docs documentation block listing all primary concrete number types available in Julia's Core and Base modules. It's intended for automatic generation of documentation pages that detail each listed type. It relies on Julia's documentation infrastructure to render details for each type; no input or output in the conventional sense, but each type must be defined in the module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/numbers.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nCore.Float16\\nCore.Float32\\nCore.Float64\\nBase.BigFloat\\nCore.Bool\\nCore.Int8\\nCore.UInt8\\nCore.Int16\\nCore.UInt16\\nCore.Int32\\nCore.UInt32\\nCore.Int64\\nCore.UInt64\\nCore.Int128\\nCore.UInt128\\nBase.Int\\nBase.UInt\\nBase.BigInt\\nBase.Complex\\nBase.Rational\\nBase.Irrational\\n```\n```\n\n----------------------------------------\n\nTITLE: Overriding configuration directories during installation - Makefile - Shell\nDESCRIPTION: Customizes system configuration paths for Julia at build time, specifically changing where Julia looks for the installation-wide startup.jl file. Passing 'sysconfdir=/etc' to 'make' causes Julia to check '/etc/julia/startup.jl' before falling back to the default. This is often required when the installation prefix is '/usr'. Input: Extra variable passed to make. Output: Julia build using custom system directory.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\nmake sysconfdir=/etc\n```\n\n----------------------------------------\n\nTITLE: Tagging a Julia Release and Pushing via Git\nDESCRIPTION: These shell commands are used to finalize a Julia release. The first command creates a Git tag locally; the tag name is generated by prefixing 'v' to the content of the `VERSION` file (which should contain the release version number like `x.y.z`). The second command pushes all local tags, including the newly created release tag, to the configured remote Git repository (e.g., GitHub).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\ngit tag v$(cat VERSION)\ngit push --tags\n```\n\n----------------------------------------\n\nTITLE: Monitoring Thread Wakeup Events Output - BPFtrace Output\nDESCRIPTION: This example shows sample output from the earlier bpftrace invocation when a single Julia task is spawned. Each line corresponds to a thread that was awoken, supporting the discussion about the thundering herd problem. While not an executable code snippet, it reflects bpftrace's real-time event reporting for each relevant probe trigger.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_9\n\nLANGUAGE: bpftrace\nCODE:\n```\nThread wake up! 3f926100\nThread wake up! 3ebd5140\nThread wake up! 3f876130\nThread wake up! 3e2711a0\nThread wake up! 3e312190\n```\n\n----------------------------------------\n\nTITLE: Defining Conditional Bounds Checking for Custom Array Type in Julia\nDESCRIPTION: Defines an inline `getindex` method for a hypothetical custom `MyArray` type. It uses the `@boundscheck` macro to mark the `checkbounds(A, i)` call. This check will be elided by the compiler only if this `getindex` method is inlined into a calling function marked with `@inbounds`. If not within an `@inbounds` context, the `checkbounds` function will execute normally, ensuring safety.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/boundscheck.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n@inline getindex(A::MyArray, i::Real) = (@boundscheck checkbounds(A, i); A.data[to_index(i)])\n```\n\n----------------------------------------\n\nTITLE: Invoking Foreign Functions with ccall in Julia\nDESCRIPTION: Demonstrates using the Julia `ccall` function to invoke a C function, ensuring that a Julia array is passed as a pointer. Requires the external C function `foo` to exist and expects the array `A` to be alive during the call. `A` is a random Float64 vector of length 1024. No output is captured, and proper GC rooting is implied by Julia's lowering of the call.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nA = randn(1024)\nccall(:foo, Cvoid, (Ptr{Float64},), A)\n```\n\n----------------------------------------\n\nTITLE: Optionally-Generated sub2ind Function with Fallback (Julia)\nDESCRIPTION: Defines sub2ind_gen with both generated and fallback runtime implementations. Chooses at compile time whether to use the generated code or fall back to normal Julia code (sub2ind_gen_fallback), based on the @generated context. Includes error checking for partial indexing. Inputs: dims::NTuple{N}, I; Outputs: linear index; Limitation: identical logic must be maintained between generated and fallback implementations; requires Julia 1.10+ for @generated in ordinary methods.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_77\n\nLANGUAGE: julia\nCODE:\n```\nfunction sub2ind_gen_impl(dims::Type{T}, I...) where T <: NTuple{N,Any} where N\n    ex = :(I[$N] - 1)\n    for i = (N - 1):-1:1\n        ex = :(I[$i] - 1 + dims[$i] * $ex)\n    end\n    return :($ex + 1)\nend;\n\nfunction sub2ind_gen_fallback(dims::NTuple{N}, I) where N\n    ind = I[N] - 1\n    for i = (N - 1):-1:1\n        ind = I[i] - 1 + dims[i]*ind\n    end\n    return ind + 1\nend;\n\nfunction sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n    length(I) == N || error(\"partial indexing is unsupported\")\n    if @generated\n        return sub2ind_gen_impl(dims, I...)\n    else\n        return sub2ind_gen_fallback(dims, I)\n    end\nend;\n\nsub2ind_gen((3, 5), 1, 2)\n4\n```\n\n----------------------------------------\n\nTITLE: Convenient spdiagm Construction - Julia\nDESCRIPTION: This snippet shows the new convenient way to construct sparse diagonal matrices using the spdiagm([m, n,] v::AbstractVector) method. It defaults to placing 'v' on the main diagonal (0 offset), matching the signature of the dense 'diagm' constructor. No external dependencies are required beyond Julia's SparseArrays. Input is an AbstractVector (optionally with dimensions), and output is a sparse diagonal matrix.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_72\n\nLANGUAGE: julia\nCODE:\n```\nusing SparseArrays\nv = [10, 20, 30]\nS = spdiagm(v)           # 3x3 sparse diagonal matrix\nT = spdiagm(4, 5, v)     # 4x5 sparse matrix with 'v' on main diagonal\n\n```\n\n----------------------------------------\n\nTITLE: Auto-Generated Implementation for Keyword Argument Dispatch - Julia\nDESCRIPTION: Julia internally generates a method with a name like #circle#1, where all keyword arguments are converted to positional form before invoking the actual function body. This lowered version serves as the main entry point for keyword calls, resolving default values. Required for methods with keyword arguments; inherently depends on Julia's method lowering.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nfunction #circle#1(color, fill::Bool, options, circle, center, radius)\n    # draw\nend\n```\n\n----------------------------------------\n\nTITLE: Conditionally Marking Tests with `broken` Keyword in Julia Test\nDESCRIPTION: Demonstrates the new, concise way to conditionally mark a test as broken in Julia's Test framework using the `broken` boolean keyword argument directly within the `@test` macro. This approach allows specifying the condition (`T == Float64`) under which the test should be treated as broken, eliminating the need for an explicit `if/else` block.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_45\n\nLANGUAGE: julia\nCODE:\n```\n```julia\n@test isequal(complex(one(T)) / complex(T(Inf), T(-Inf)), complex(zero(T), zero(T))) broken=(T == Float64)\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Assertion Builds in Julia Make.user - Makefile - Makefile\nDESCRIPTION: Defines Makefile variables to force the use of internal Julia and LLVM assertions for a debug-friendly build. Requires editing Make.user and setting FORCE_ASSERTIONS and LLVM_ASSERTIONS to 1. Use this only when debugging, as it can significantly reduce performance; there are no code parameters except these variable assignments. No external dependencies are required besides the Julia source and make.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_21\n\nLANGUAGE: Makefile\nCODE:\n```\nFORCE_ASSERTIONS=1\nLLVM_ASSERTIONS=1\n```\n\n----------------------------------------\n\nTITLE: Extracting Cell Array Elements in MATLAB\nDESCRIPTION: MATLAB uses curly braces `{}` with a colon `:` (e.g., `A{:}`) to extract or dereference all elements from a cell array, often used as arguments to functions like `vertcat`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_28\n\nLANGUAGE: matlab\nCODE:\n```\nvertcat(A{:})\n```\n\n----------------------------------------\n\nTITLE: Determining the Primary Tuple Type in Julia - Julia REPL - Julia\nDESCRIPTION: Uses pointer_from_objref to compare Tuple and Tuple{} at an implementation level, revealing that Tuple and Tuple{}.name.wrapper share the same primary type. Dependencies: Standard Julia and a system capable of object pointers. Inputs: Tuple types; Outputs: C pointers. The addresses confirm the identity of the primary Tuple type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_10\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> pointer_from_objref(Tuple)\nPtr{Cvoid} @0x00007f5998a04370\n\njulia> pointer_from_objref(Tuple{})\nPtr{Cvoid} @0x00007f5998a570d0\n\njulia> pointer_from_objref(Tuple.name.wrapper)\nPtr{Cvoid} @0x00007f5998a04370\n\njulia> pointer_from_objref(Tuple{}.name.wrapper)\nPtr{Cvoid} @0x00007f5998a04370\n```\n\n----------------------------------------\n\nTITLE: Comparisons Involving NaN and Special Cases - Julia\nDESCRIPTION: This snippet demonstrates the peculiar behavior of NaN in Julia numeric comparisons, highlighting that NaN is not equal, less than, or greater than any value, including itself. Julia base language is required. Inputs are NaN expressions, and outputs are boolean values showing the unique results when using standard comparison operators on NaN.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> NaN == NaN\nfalse\n\njulia> NaN != NaN\ntrue\n\njulia> NaN < NaN\nfalse\n\njulia> NaN > NaN\nfalse\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `Dates.recur`: Use `filter` in Julia\nDESCRIPTION: The `Dates.recur` function for generating recurring dates is deprecated in Julia. The recommended alternative is to use the `filter` function with an appropriate predicate over a date range.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_187\n\nLANGUAGE: julia\nCODE:\n```\nfilter\n```\n\n----------------------------------------\n\nTITLE: Choosing a Sorting Algorithm Explicitly - Julia\nDESCRIPTION: Illustrates selection of a particular sorting algorithm using the alg keyword. Here, InsertionSort is specified, which is a stable and simple algorithm best suited for small arrays. Requires the algorithm type (e.g., InsertionSort) to be available in scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/sort.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia-repl\\njulia> sort(v, alg=InsertionSort)\\n5-element Vector{Float64}:\\n -0.839027\\n -0.597634\\n -0.0104452\\n  0.297288\\n  0.382396\n```\n\n----------------------------------------\n\nTITLE: Using Dynamically Generated Methods for a Custom Type in Julia\nDESCRIPTION: Shows the application of the methods that were dynamically generated in the previous step. An instance `x` of `MyNumber` is created, and the generated `sin(a::MyNumber)` and `cos(a::MyNumber)` methods are successfully called on `x`, demonstrating the result of the code generation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_51\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> x = MyNumber(π)\nMyNumber(3.141592653589793)\n\njulia> sin(x)\nMyNumber(1.2246467991473532e-16)\n\njulia> cos(x)\nMyNumber(-1.0)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating DomainError Exception Throwing - Julia\nDESCRIPTION: This snippet illustrates Julia's built-in error handling when evaluating inappropriate mathematical operations (such as applying sqrt to a negative number). No specific dependencies are required. The code shows the usage of sqrt, which throws a DomainError for negative reals, resulting in a displayed error message and stacktrace. Input is -1, output is a printed error indicating improper usage.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\njulia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Logging via Environment Variable (Linux)\nDESCRIPTION: Demonstrates how to enable debug messages specifically for the 'loading.jl' module in Julia by setting the JULIA_DEBUG environment variable before launching Julia in a Linux shell. This causes @debug messages within that module (and potentially related recompilation messages) to be displayed.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Logging/docs/src/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ JULIA_DEBUG=loading julia -e 'using OhMyREPL'\n┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji due to it containing an incompatible cache header\n└ @ Base loading.jl:1328\n[ Info: Recompiling stale cache file /home/user/.julia/compiled/v0.7/OhMyREPL.ji for module OhMyREPL\n┌ Debug: Rejecting cache file /home/user/.julia/compiled/v0.7/Tokenize.ji due to it containing an incompatible cache header\n└ @ Base loading.jl:1328\n...\n```\n\n----------------------------------------\n\nTITLE: Generating HTML Output by Calling Custom show Method in Julia\nDESCRIPTION: Demonstrates invoking the show function directly with 'text/html' MIME type to emit HTML-formatted output of a Polar object. Uses stdout as the target IO, producing HTML suitable for display in browser-based or notebook environments. Relies on previously defined show overload for HTML.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_72\n\nLANGUAGE: julia\nCODE:\n```\nshow(stdout, \"text/html\", Polar(3.0,4.0))\n```\n\n----------------------------------------\n\nTITLE: Multiline Pretty-printing with MIME Types in Julia\nDESCRIPTION: Defines an additional 3-argument show overload for Polar with MIME type MIME\"text/plain\", providing a more verbose, multi-line rendering intended for the REPL or interactive environments. Inputs include the IO stream, MIME type specifier, and the Polar instance with type parameter T. Ensures attractive and informational presentation for single objects.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_70\n\nLANGUAGE: julia\nCODE:\n```\nBase.show(io::IO, ::MIME\"text/plain\", z::Polar{T}) where{T} =\\n    print(io, \"Polar{\\$T} complex number:\\\\n   \", z)\n```\n\n----------------------------------------\n\nTITLE: Writing to Files with Manual Stream Management - Julia\nDESCRIPTION: Opens a file for writing using `open(filename, \"w\")` to obtain an IOStream and writes content using `write(f, data)`. Shows that content is buffered until `close(f)` is called, which then flushes data to disk. Inputs are the file stream and string to write. Constraints: File is not updated until stream is closed. Use for controlled writes when explicit stream management is needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_7\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> f = open(\"hello.txt\",\"w\")\\nIOStream(<file hello.txt>)\\n\\njulia> write(f,\"Hello again.\")\\n12\n```\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> close(f)\n```\n\n----------------------------------------\n\nTITLE: Chaining Ternary Operators for Multiway Conditionals - Julia\nDESCRIPTION: Showcases re-writing multiway if-else logic using chained ternary operators for concise in-line selection among multiple outcomes. The test function prints which of three relational statements about its arguments is true. This pattern requires right-to-left association for correct evaluation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\njldoctest\njulia> test(x, y) = println(x < y ? \"x is less than y\"    :\n                            x > y ? \"x is greater than y\" : \"x is equal to y\")\ntest (generic function with 1 method)\n\njulia> test(1, 2)\nx is less than y\n\njulia> test(2, 1)\nx is greater than y\n\njulia> test(1, 1)\nx is equal to y\n```\n\n----------------------------------------\n\nTITLE: Downloading Binary Artifacts with Pkg in Julia\nDESCRIPTION: Julia's package manager `Pkg` now supports downloading and installing binary artifacts using the `Pkg.Artifacts` submodule and related functions.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_116\n\nLANGUAGE: julia\nCODE:\n```\n# Usage typically involves Artifacts.toml files and Pkg operations\nusing Pkg.Artifacts\n```\n\n----------------------------------------\n\nTITLE: Defining an Empty Generic Function in Julia\nDESCRIPTION: Illustrates the syntax for defining a generic function `emptyfunc` in Julia without initially providing any methods. This can be useful for defining an interface separately from its implementation or for documentation purposes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\nfunction emptyfunc end\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method-Specific Views in Generated Functions (Julia)\nDESCRIPTION: Adds a new method to the generated function `gen1` specifically for `Real` types. When `gen1(1)` is called again, this new generated method is invoked. Inside this specific method's generation, `f(x)` (where `x` is `Int`) resolves to `f(::Type{Int})`, demonstrating that each generated method captures the state of the world at the time of its own definition.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_69\n\nLANGUAGE: julia\nCODE:\n```\njulia> @generated gen1(x::Real) = f(x);\n\njulia> gen1(1)\n\"definition for Type{Int}\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Numeric Comparison Operators - Julia\nDESCRIPTION: These examples showcase basic comparison operators in Julia, such as equality (==), inequality (!=), less/greater than (<, >), and their behavior with different numeric types including integers and floats. Required dependency is the Julia base language. Inputs are literal numeric values; outputs are boolean results of the comparisons. These snippets highlight standard and cross-type comparison results.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/mathematical-operations.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1 == 1\ntrue\n\njulia> 1 == 2\nfalse\n\njulia> 1 != 2\ntrue\n\njulia> 1 == 1.0\ntrue\n\njulia> 1 < 2\ntrue\n\njulia> 1.0 > 3\nfalse\n\njulia> 1 >= 1.0\ntrue\n\njulia> -1 <= 1\ntrue\n\njulia> -1 <= -1\ntrue\n\njulia> -1 <= -2\nfalse\n\njulia> 3 < -0.5\nfalse\n```\n\n----------------------------------------\n\nTITLE: Mapping a Multi-Line Anonymous Function in Julia (Standard Syntax)\nDESCRIPTION: Demonstrates passing a multi-line anonymous function as an argument to the `map` function using standard Julia syntax. This highlights the potential awkwardness that the `do` block syntax aims to solve.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\nmap(x->begin\n           if x < 0 && iseven(x)\n               return 0\n           elseif x == 0\n               return 1\n           else\n               return x\n           end\n       end,\n    [A, B, C])\n```\n\n----------------------------------------\n\nTITLE: Querying Julia Master Thread ID - Julia\nDESCRIPTION: Illustrates how to retrieve the current thread's ID using Threads.threadid() in Julia. No dependencies required beyond standard library. Input is implicit (current execution thread), output is the integer thread ID (typically 1 for the master thread).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> Threads.threadid()\n1\n```\n\n----------------------------------------\n\nTITLE: General Syntax for Julia Indexed Array Assignment\nDESCRIPTION: Presents the general syntax for assigning a value `X` to elements or subarrays of an n-dimensional array `A` in Julia. `I_1` through `I_n` specify the target locations using supported index types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_23\n\nLANGUAGE: plaintext\nCODE:\n```\nA[I_1, I_2, ..., I_n] = X\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Task Sampling Issues with Short-Lived Tasks in Julia\nDESCRIPTION: This Julia code demonstrates a scenario where numerous short-lived tasks are spawned, potentially leading to `failed_to_stop_thread_fun` samples in wall-time profiling. It uses `Threads.@spawn` within a loop, simulates work with `busywait`, and profiles the execution using `Profile.@profile_walltime`. Dependencies include `Base.Threads`, `Profile`, and potentially `PProf` for later analysis.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_12\n\nLANGUAGE: Julia\nCODE:\n```\n```Julia\nusing Base.Threads\nusing Profile\nusing PProf\n\nconst N_SPAWNED_TASKS = (1 << 16)\nconst WAIT_TIME_NS = 100_000\n\nfunction spawn_a_bunch_of_short_lived_tasks()\n    for i in 1:N_SPAWNED_TASKS\n        Threads.@spawn begin\n            # Do nothing\n        end\n    end\nend\n\nfunction busywait()\n    t0 = time_ns()\n    while true\n        if time_ns() - t0 > WAIT_TIME_NS\n            break\n        end\n    end\nend\n\nfunction main()\n    GC.enable(false)\n    spawn_a_bunch_of_short_lived_tasks()\n    for i in 1:N_SPAWNED_TASKS\n        busywait()\n    end\n    GC.enable(true)\nend\n\nProfile.@profile_walltime main()\n```\n```\n\n----------------------------------------\n\nTITLE: Parsing UUID from String - Julia UUIDs\nDESCRIPTION: This snippet shows the new parse(::Type{UUID}, ::AbstractString) method in Julia's UUIDs module, which parses a UUID from its string representation. The function takes a string like '123e4567-e89b-12d3-a456-426614174000' and converts it to a UUID object. No external dependencies are required beyond UUIDs, and output is a UUID.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_78\n\nLANGUAGE: julia\nCODE:\n```\nusing UUIDs\nstr = \"123e4567-e89b-12d3-a456-426614174000\"\nu = parse(UUID, str)\n```\n\n----------------------------------------\n\nTITLE: Using Double Semicolons for Line Continuation in Horizontal Concatenation\nDESCRIPTION: Illustrates a specific use case for double semicolons (`;;`) where they act as a line continuation character within a horizontal concatenation defined by spaces. This prevents the line break from being interpreted as a vertical concatenation separator (`;`), allowing a single horizontal row to be written across multiple lines.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_8\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> [1 2 ;;\n       3 4]\n1×4 Matrix{Int64}:\n 1  2  3  4\n```\n\n----------------------------------------\n\nTITLE: Parsing Julia 'do' Block Syntax – Julia\nDESCRIPTION: This snippet demonstrates the use of Julia's 'do' syntax, which allows passing an anonymous function as the last argument to another function, commonly for control flow or resource handling. The block with parameters a and b and body executes within the scope of the 'do' clause when f(x) is called. When parsed, this code is transformed into a specific AST representation for further macro or compiler processing.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ast.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nf(x) do a,b\n    body\nend\n```\n\n----------------------------------------\n\nTITLE: Data Structures: Julia `struct` vs. MATLAB `class`\nDESCRIPTION: Julia `struct`s have fixed fields defined at creation and do not allow dynamic addition of fields at runtime. For dynamic fields similar to MATLAB `class` objects, use a Julia `Dict` (Dictionary), which is unordered.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_23\n\nLANGUAGE: julia\nCODE:\n```\nstruct\n```\n\nLANGUAGE: julia\nCODE:\n```\nDict\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unsafe Memory Access with OffsetArrays and @inbounds in Julia REPL\nDESCRIPTION: Shows the consequence of using the potentially unsafe `sum` function (which assumes 1-based indexing and uses `@inbounds`) with an `OffsetArray` whose indices start at -10. Because the loop attempts to access indices like `A[1]` which are out of bounds for this specific array, and `@inbounds` disables the checks, this leads to reading invalid memory, resulting in incorrect results or a program crash (segmentation fault).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/boundscheck.md#_snippet_3\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using OffsetArrays\n\njulia> sum(OffsetArray([1, 2, 3], -10))\n9164911648 # inconsistent results or segfault\n```\n\n----------------------------------------\n\nTITLE: Problematic Top-Level Call Creating a Global Timer in Julia\nDESCRIPTION: Demonstrates calling the previously defined `maketimer` function at the top level of a Julia module to initialize a global constant `GLOBAL_TIMER`. This pattern is problematic because it executes the function and creates the `Timer` during the module definition phase, which can lead to precompilation hangs if the timer is not properly managed before precompilation finishes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/precompile_hang.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nconst GLOBAL_TIMER = maketimer()\n```\n\n----------------------------------------\n\nTITLE: Example of Throwing a Formatted Julia Exception from C\nDESCRIPTION: This C code provides a specific example of using `jl_errorf` to throw a Julia exception from C. It formats an error message including an integer variable `x`, similar to how `printf` works.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_35\n\nLANGUAGE: c\nCODE:\n```\njl_errorf(\"argument x = %d is too large\", x);\n```\n\n----------------------------------------\n\nTITLE: Executing a Simple Macro in Julia REPL\nDESCRIPTION: Demonstrates calling the simple `@sayhello` macro in the Julia REPL. The macro expands and executes immediately, printing the string to the console.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_21\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> @sayhello()\nHello, world!\n```\n\n----------------------------------------\n\nTITLE: Running Julia Bootstrap Within GDB - Shell\nDESCRIPTION: This shell snippet illustrates the steps to run Julia's bootstrap process inside the GNU Debugger (gdb), allowing the user to obtain backtraces during segmentation faults encountered in the build phase. It assumes Julia has been built in debug mode and should be executed from the 'base/' directory. The code uses a helper GDB script provided in Julia's 'contrib' folder.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/backtraces.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n\"$ cd base/\\n$ gdb -x ../contrib/debug_bootstrap.gdb\\n\"\n```\n\n----------------------------------------\n\nTITLE: Querying Julia Version and Environment Information - Julia\nDESCRIPTION: This snippet shows how to use the InteractiveUtils standard library in Julia to display comprehensive version and environment information about the Julia installation, which is essential for debugging and reporting issues. It requires no additional dependencies beyond Julia's standard library. The function versioninfo() outputs details like version, build info, platform, and system settings. The primary input is a running Julia REPL, and the output is printed to the console.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/backtraces.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n\"using InteractiveUtils\\nversioninfo()\\n\"\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Special Type Value Functions/Constants\nDESCRIPTION: This block uses the `@docs` directive to list functions and constants providing special values associated with types, such as minimum/maximum representable values, machine epsilon for floating-point types, and retrieving all instances of an enum type. It directs the documentation generator to include these under the 'Special values' subcategory within 'Properties of Types'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.typemin\nBase.typemax\nBase.floatmin\nBase.floatmax\nBase.maxintfloat\nBase.eps(::Type{<:AbstractFloat})\nBase.eps(::AbstractFloat)\nBase.instances\n```\n```\n\n----------------------------------------\n\nTITLE: Requiring One-Based Indexing in Julia Arrays - Julia\nDESCRIPTION: This code uses Julia's built-in function 'Base.require_one_based_indexing' to enforce that specified arrays use conventional 1-based indexing. By passing array objects as arguments, this function will check and throw an error if any array uses non-1-based indices. No additional dependencies are required beyond Julia Base. The function is useful for ensuring compatibility of legacy code or enforcing strict indexing conventions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/offset-arrays.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nBase.require_one_based_indexing(arrays...)\n```\n\n----------------------------------------\n\nTITLE: Generating Methods Dynamically using eval and Prefix Quoting in Julia\nDESCRIPTION: Presents a more concise syntax for the dynamic method generation loop shown earlier. Instead of `eval(quote(...))`, this version uses the prefix quoting form `:(...)` combined with `eval`. The expression `:(Base.$op(a::MyNumber) = MyNumber($op(a.x)))` creates the code AST, which is then evaluated by `eval` within the loop, achieving the same result of defining methods for `MyNumber`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_52\n\nLANGUAGE: julia\nCODE:\n```\nfor op = (:sin, :cos, :tan, :log, :exp)\n    eval(:(Base.$op(a::MyNumber) = MyNumber($op(a.x))))\nend\n```\n\n----------------------------------------\n\nTITLE: Function Composition Operator `∘` (`\\circ`) in Julia\nDESCRIPTION: The `∘` operator (typed as `\\circ<tab>`) now performs function composition in Julia. For example, `uppercase ∘ hex` creates a new function that first applies `hex` and then `uppercase` to its argument. This can be used in functions like `map`, e.g., `map(uppercase ∘ hex, 250:255)` is equivalent to `map(x -> uppercase(hex(x)), 250:255)`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_176\n\nLANGUAGE: julia\nCODE:\n```\n∘\n```\n\nLANGUAGE: julia\nCODE:\n```\nmap(uppercase ∘ hex, 250:255)\n```\n\nLANGUAGE: julia\nCODE:\n```\nmap(x -> uppercase(hex(x)), 250:255)\n```\n\n----------------------------------------\n\nTITLE: Setting a release banner in Make.user - Makefile - Shell\nDESCRIPTION: Allows customization of the Julia release banner (visible in splash screen/output) by specifying the 'TAGGED_RELEASE_BANNER' variable within a local Make.user file. This is useful for marking custom builds or downstream distributions. Requires the build process to load and apply variables from Make.user. Input: Edit Make.user. Output: Customized banner within Julia's version/splash screens.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\noverride TAGGED_RELEASE_BANNER = \"my-package-repository build\"\n```\n\n----------------------------------------\n\nTITLE: Ejecting and Cleaning Up Mounted .dmg - Shell\nDESCRIPTION: This shell snippet unmounts ('ejects') the mounted disk image and removes the temporary mount point directory used during code signature verification or manipulation. It is used after code signing or verification steps to clean up. Parameter /dev/disk3 is the device name given when hdiutil originally mounted the image. There are no outputs if successful.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\nhdiutil eject /dev/disk3\\nrm -rf ./jlmnt\n```\n\n----------------------------------------\n\nTITLE: Disabling BinaryBuilder in Julia Makefile - make\nDESCRIPTION: Disables the use of Julia's BinaryBuilder by setting the USE_BINARYBUILDER variable to 0 in Make.user. This instructs Julia's build system to compile all dependencies from source rather than downloading prebuilt binaries. No external dependencies are needed for this change; the effect is local to the Julia build process. There are no required parameters; simply setting this variable applies to the current build.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/riscv.md#_snippet_0\n\nLANGUAGE: make\nCODE:\n```\nUSE_BINARYBUILDER := 0\n```\n\n----------------------------------------\n\nTITLE: Using RandomDevice with uuid1 and uuid4 - Julia UUIDs\nDESCRIPTION: This snippet demonstrates the change where uuid1 and uuid4 now use Random.RandomDevice() as the default random number generator. This enhances randomness and security when generating UUIDs. Dependencies include Julia's UUIDs and Random standard libraries; usage is unchanged, but now relies on a system entropy source by default.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_77\n\nLANGUAGE: julia\nCODE:\n```\nusing UUIDs\nusing Random\nu1 = uuid1() # Uses RandomDevice for randomness\nu4 = uuid4()\n```\n\n----------------------------------------\n\nTITLE: Highlighting Associativity Failure of Saturating Arithmetic in Matlab - Matlab\nDESCRIPTION: This snippet highlights the non-associative nature of Matlab's saturating arithmetic with int64 types, showing how computations like n + (n - 1) and (n + n) - 1 yield different answers. It focuses on the subtle consequences for algorithm correctness in numerical code and does not require additional dependencies beyond Matlab itself.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_21\n\nLANGUAGE: matlab\nCODE:\n```\n>> n = int64(2)^62\n4611686018427387904\n\n>> n + (n - 1)\n9223372036854775807\n\n>> (n + n) - 1\n9223372036854775806\n```\n\n----------------------------------------\n\nTITLE: Unsafe getindex Overloading using unsafe_load - Anti-pattern - Julia - julia\nDESCRIPTION: Defines getindex for a custom type by directly calling unsafe_load on the internal pointer, making the getindex operation unsafe by default. This is discouraged as it allows users to call x[i] with hidden risks of memory errors. No dependencies are required, but the correct approach is to either validate memory access or clearly mark such methods as unsafe.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\ngetindex(x::NativeType, i) = unsafe_load(x.p, i)\n\n```\n\n----------------------------------------\n\nTITLE: Using Generated Functions to Unroll sub2ind Loop (Julia)\nDESCRIPTION: Defines a @generated function sub2ind_gen that constructs an expression to calculate the linear index at compile time, removing the runtime loop. The generated function iterates over dimension types to build the calculation as an expression. Inputs: dims::NTuple{N}, I::Integer...; Outputs: linear index; Limitations: fully type-based, code is generated for each type combination; requires no additional dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_74\n\nLANGUAGE: julia\nCODE:\n```\n@generated function sub2ind_gen(dims::NTuple{N}, I::Integer...) where N\n    ex = :(I[$N] - 1)\n    for i = (N - 1):-1:1\n        ex = :(I[$i] - 1 + dims[$i] * $ex)\n    end\n    return :($ex + 1)\nend;\n\nsub2ind_gen((3, 5), 1, 2)\n4\n```\n\n----------------------------------------\n\nTITLE: Comparing Types and Instances of Closures in Julia\nDESCRIPTION: Defines a function `addy(y)` that returns a closure capturing `y`. It demonstrates that the types of two closures created with different captured values (`addy(1)` and `addy(2)`) are the same (`===`), but the closure instances themselves are distinct objects (`!==`). Finally, it confirms that the type of such closures is not necessarily a singleton type using `Base.issingletontype`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_54\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> addy(y) = x -> x + y\naddy (generic function with 1 method)\n\njulia> typeof(addy(1)) === typeof(addy(2))\ntrue\n\njulia> addy(1) === addy(2)\nfalse\n\njulia> Base.issingletontype(typeof(addy(1)))\nfalse\n```\n\n----------------------------------------\n\nTITLE: Querying Second-Dimension Stride in an Array View (Julia)\nDESCRIPTION: Demonstrates how to obtain the stride along the second dimension for a noncontiguous SubArray created from an original Array using range slicing. Input: view V constructed via @view; Output: stride(V, 2) returns the step size in memory for the second dimension, affected by non-unit step intervals. This can expose gaps in memory layout compared to the parent array.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_45\n\nLANGUAGE: julia\nCODE:\n```\njulia> stride(V, 2)\n10\n```\n\n----------------------------------------\n\nTITLE: Rounding Mode Argument for `rem` Function in Julia\nDESCRIPTION: The `rem` function in Julia now accepts an optional `RoundingMode` argument `r`. The call `rem(x, y, r::RoundingMode)` computes `x - y*round(x/y, r)` without intermediate rounding. `rem(x, y, RoundNearest)` corresponds to the IEEE 754 `remainder` function, yielding a result in `[-abs(y)/2, abs(y)/2]`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_173\n\nLANGUAGE: julia\nCODE:\n```\nrem(x, y, r::RoundingMode)\n```\n\nLANGUAGE: julia\nCODE:\n```\nrem(x, y, RoundNearest)\n```\n\n----------------------------------------\n\nTITLE: Referencing Experimental Task Metrics API - Julia\nDESCRIPTION: This documentation macro block lists experimental APIs related to task metrics, including time measurements for tasks in nanoseconds. The snippet prepares Base.Experimental.task_metrics, task_running_time_ns, and task_wall_time_ns for documentation rendering, enabling users to monitor and analyze the performance of concurrent Julia tasks.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/multi-threading.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nBase.Experimental.task_metrics\\nBase.Experimental.task_running_time_ns\\nBase.Experimental.task_wall_time_ns\\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing Julia REPL Prompt and Text Colors via Startup File - Julia\nDESCRIPTION: This Julia code snippet shows how to define a function to configure REPL prompt color in the Julia startup configuration file, using the Base.text_colors dictionary. The function is registered to run on REPL startup. Dependencies: Julia must be able to run code at REPL init, and Base.text_colors should be available (standard Julia installation). Key parameter is `repl`, which refers to the REPL object modified.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\nfunction customize_colors(repl)\n    repl.prompt_color = Base.text_colors[:cyan]\nend\n\natreplinit(customize_colors)\n```\n\n----------------------------------------\n\nTITLE: Quarter Period Type Definition - Julia\nDESCRIPTION: This snippet highlights the introduction of the Quarter period type in Julia's Dates module. The Quarter type provides support for quarter-based date periods, enabling easier manipulation and representation of quarterly intervals. It requires only the standard Dates module as a dependency. Typical usage involves constructing periods like Quarter(1) to represent the first quarter.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_73\n\nLANGUAGE: julia\nCODE:\n```\nusing Dates\nq = Quarter(2)  # Represents the second quarter period\n```\n\n----------------------------------------\n\nTITLE: Using Unicode Suffixes with Operators in Julia\nDESCRIPTION: The Unicode characters `ꜛ` (U+A71B), `ꜜ` (U+A71C), and `ꜝ` (U+A71D) can now be used as operator suffixes in Julia. They can be entered in the REPL using tab completion for `\\^uparrow`, `\\^downarrow`, and `\\^!` respectively.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_51\n\nLANGUAGE: julia\nCODE:\n```\n# Hypothetical usage where 'op' is some operator\nx = y opꜛ z  # Entered as y op\\^uparrow<tab> z\na = b opꜜ c  # Entered as b op\\^downarrow<tab> c\np = q opꜝ r  # Entered as q op\\^!<tab> r\n```\n\n----------------------------------------\n\nTITLE: Running Julia With RR Integration for Crash Reporting - Julia\nDESCRIPTION: This Julia code snippet demonstrates usage of Julia's '--bug-report=rr' and '--bug-report=rr-local' flags for running Julia under the rr recorder on Linux. This integration assists in producing detailed trace dumps when an unexpected crash occurs, enabling time-travel debugging by maintainers. The feature is only available on Linux, and the output is a recorded rr trace for either sharing with maintainers or local analysis.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/backtraces.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n\"julia --bug-report=rr\\n\"\n```\n\nLANGUAGE: julia\nCODE:\n```\n\"julia --bug-report=rr-local\\n\"\n```\n\n----------------------------------------\n\nTITLE: Changing and Verifying Active REPL Module in Julia\nDESCRIPTION: Illustrates how to change the active module context in the Julia REPL. It shows using `REPL.activate(module)` function and the Alt-m (Esc-m on MacOS) keybinding to switch between modules like `Base`, `Main`, and `Core`. The active module is displayed in the prompt.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_30\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using REPL\n\njulia> REPL.activate(Base)\n\n(Base) julia> @__MODULE__\nBase\n\n(Base) julia> using REPL # Need to load REPL into Base module to use it\n\n(Base) julia> REPL.activate(Main)\n\njulia>\n\njulia> Core<Alt-m> # using the keybinding to change module\n\n(Core) julia>\n\n(Core) julia> <Alt-m> # going back to Main via keybinding\n\njulia>\n\njulia> <Alt-m> # going back to previously-active Core via keybinding\n\n(Core) julia>\n```\n\n----------------------------------------\n\nTITLE: Building Julia Executable from Source - Shell\nDESCRIPTION: This shell command invokes GNU Make to build the Julia executable from the source code in the current directory. Prerequisites include having all build dependencies installed and being in the root of the previously cloned (and optionally checked-out) Julia repository. The process requires sufficient disk space and virtual memory, and will output the compiled binary on success.\nSOURCE: https://github.com/julialang/julia/blob/master/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple IndexLinear AbstractArray (SquaresVector) in Julia\nDESCRIPTION: Defines a custom `AbstractArray` subtype `SquaresVector` representing the squares of integers up to `count`. It implements the minimal required methods for an `IndexLinear` array: `size`, `IndexStyle`, and `getindex`. This demonstrates the basic requirements for creating a functional, read-only array type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/interfaces.md#_snippet_14\n\nLANGUAGE: jldoctest squarevectype\nCODE:\n```\njulia> struct SquaresVector <: AbstractArray{Int, 1}\n           count::Int\n       end\n\njulia> Base.size(S::SquaresVector) = (S.count,)\n\njulia> Base.IndexStyle(::Type{<:SquaresVector}) = IndexLinear()\n\njulia> Base.getindex(S::SquaresVector, i::Int) = i*i\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Type Memory Layout Functions\nDESCRIPTION: This block employs the `@docs` directive to list functions related to the memory layout of Julia types, including size calculation, concrete type checks, bitstype checks, field offsets, alignment, padding, and pointer-free status. It guides the documentation generator to include these under the 'Memory layout' subcategory within 'Properties of Types'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.sizeof(::Type)\nBase.isconcretetype\nBase.isbits\nBase.isbitstype\nBase.fieldoffset\nBase.datatype_alignment\nBase.datatype_haspadding\nBase.datatype_pointerfree\n```\n```\n\n----------------------------------------\n\nTITLE: Suppressing Output and Using `ans` Variable in Julia REPL\nDESCRIPTION: This example illustrates two features of the Julia REPL's Julian mode. First, appending a semicolon (`;`) to an expression (`string(3 * 4);`) suppresses the automatic display of the result. Second, the result of the last evaluated expression (even if suppressed) is automatically bound to the variable `ans`, which can then be used in subsequent expressions.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> string(3 * 4);\n\njulia> ans\n\"12\"\n```\n\n----------------------------------------\n\nTITLE: Directly Accessing Pointer Fields in Julia Objects in C\nDESCRIPTION: Shows an example C code snippet demonstrating direct array-like access to fields of a Julia object (`value`) using the `fieldptr` member. This method assumes the object's fields are known *a priori* to be all pointers and requires careful indexing (`n`). It bypasses type checks and is generally less safe than using the provided getter functions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *v = value->fieldptr[n];\n```\n\n----------------------------------------\n\nTITLE: Multiline NamedTuple Type Declaration in Julia\nDESCRIPTION: Uses the @NamedTuple macro's begin ... end block syntax to spread out field declarations. This enhances readability for larger types but results in the same type as the one-line version. Field names and types are specified as key::Type pairs, omitted types default to Any.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_43\n\nLANGUAGE: julia\nCODE:\n```\njulia> @NamedTuple begin\n           a::Int\n           b::String\n       end\n@NamedTuple{a::Int64, b::String}\n```\n\n----------------------------------------\n\nTITLE: Expanded Code Generated by the Simple `@assert` Macro\nDESCRIPTION: Shows the equivalent Julia code that results from the expansion of the simple `@assert` macro calls at parse time. This clarifies how the original expression (`1 == 1.0` or `1 == 0`) is used as the condition and its string representation is embedded in the `AssertionError`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\n1 == 1.0 ? nothing : throw(AssertionError(\"1 == 1.0\"))\n1 == 0 ? nothing : throw(AssertionError(\"1 == 0\"))\n```\n\n----------------------------------------\n\nTITLE: Defining C Struct with Flexible Array Member\nDESCRIPTION: Defines a C struct `String` using a C99 flexible array member (`char data[]`). This pattern, where a struct contains metadata followed by variable-length data, requires manual pointer arithmetic to access in Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_18\n\nLANGUAGE: c\nCODE:\n```\nstruct String {\n    int strlen;\n    char data[];\n};\n```\n\n----------------------------------------\n\nTITLE: Evaluating the Value of try/finally Expressions in Julia\nDESCRIPTION: This snippet illustrates that a try/finally expression in Julia evaluates to the value of the last statement in the try block, while the finally block executes cleanup code but does not affect the result. It provides an example where the try block returns 1 and the finally block executes 2; the evaluated value is 1. No external dependencies exist, and it requires basic exception handling knowledge.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_41\n\nLANGUAGE: julia\nCODE:\n```\njulia> try\n           1\n       finally\n           2\n       end\n1\n```\n\n----------------------------------------\n\nTITLE: Identity `convert` Implementation for Numeric Types in Julia\nDESCRIPTION: Presents the identity conversion method for `Number` types in Julia Base. If the input value `x` is already of the target type `T` (where `T<:Number`), `convert(T, x)` simply returns `x` itself without performing any operation or allocation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/conversion-and-promotion.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nconvert(::Type{T}, x::T) where {T<:Number} = x\n```\n\n----------------------------------------\n\nTITLE: Displaying Sparse Matrices with spy plot or 2D Layout - Julia\nDESCRIPTION: This snippet demonstrates the display of large sparse matrices using a Unicode 'spy' plot to visualize the nonzero pattern, and the display of small sparse matrices formatted in a Matrix-like 2D layout to show their content directly. The display method adapts based on matrix size, ensuring more readable representations. This functionality is provided natively in Julia's SparseArrays module, with no additional dependencies except standard Julia, and leverages built-in display mechanisms.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_71\n\nLANGUAGE: julia\nCODE:\n```\n## Example (conceptual):\nusing SparseArrays\nA = sprand(100, 100, 0.01) # Large sparse matrix\nprintln(A) # Displays with a spy plot to show nonzero pattern\n\nB = sparse([1 2; 3 0])      # Small sparse matrix\nprintln(B) # Displays as a 2D Matrix-like table\n\n```\n\n----------------------------------------\n\nTITLE: Compact Display via IOContext for Arrays in Julia\nDESCRIPTION: Demonstrates using IOContext with the :compact property set to true to obtain short, space-saving displays of Polar objects when printing or displaying arrays with multiple columns. Automatically selects the compact printing logic defined in the specialized Base.show method. Makes array visualization more readable in tight horizontal layouts.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_75\n\nLANGUAGE: julia\nCODE:\n```\nshow(IOContext(stdout, :compact=>true), Polar(3, 4.0))\\n\\n[Polar(3, 4.0) Polar(4.0,5.3)]\n```\n\n----------------------------------------\n\nTITLE: Working with Half-Precision Float16 Numbers (Julia)\nDESCRIPTION: Illustrates the use of Float16 (half-precision floats) in Julia, including memory size and arithmetic. Also explains that hardware support or software fallback may apply. Inputs and outputs show numeric operations and constructor usage. No external dependencies are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\njulia> sizeof(Float16(4.))\n2\n\njulia> 2*Float16(4.)\nFloat16(8.0)\n```\n\n----------------------------------------\n\nTITLE: Associative Period Arithmetic Chaining in Julia Dates Module\nDESCRIPTION: Demonstrates that, when chaining multiple Periods together in an expression, Dates guarantees associativity by ordering periods by type rather than their position. This ensures results are as expected regardless of addition order.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\njulia> Date(2014,1,29) + Dates.Day(1) + Dates.Month(1)\n2014-03-01\n\njulia> Date(2014,1,29) + Dates.Month(1) + Dates.Day(1)\n2014-03-01\n```\n\n----------------------------------------\n\nTITLE: Illustrating Dedentation Logic in Triple-Quoted Julia Strings\nDESCRIPTION: Provides another example of dedentation in triple-quoted strings. The dedentation level is the longest common starting sequence of spaces/tabs across all relevant lines (excluding the first line and lines with only whitespace).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_31\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> \"\"\"    This\n         is\n           a test\"\"\"\n\"    This\\nis\\n  a test\"\n```\n\n----------------------------------------\n\nTITLE: Defining Signed Hexadecimal Literals in Julia\nDESCRIPTION: Demonstrates how to create signed integers from hexadecimal literals by prefixing them with a minus sign (`-`). The resulting type is an unsigned integer of the same size as the corresponding unsigned literal, representing the two's complement of the value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n```jldoctest\njulia> -0x2\n0xfe\n\njulia> -0x0002\n0xfffe\n```\n```\n\n----------------------------------------\n\nTITLE: Manually Constructing TypeVars and UnionAll Types - Julia\nDESCRIPTION: This snippet demonstrates manual construction of a `TypeVar` and a `UnionAll` type in Julia, showing how abstract parameter bounds and parametric types can be programmatically assembled. It reveals how Julia's type system handles bounded parameters and how type-lowering from high-level syntax to internal representations works. Inputs are symbols and types for `TypeVar` construction; outputs are symbolic type objects. Only Julia base is required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> TypeVar(:V, Signed, Real)\nSigned<:V<:Real\n```\n\nLANGUAGE: julia\nCODE:\n```\nlet T = TypeVar(:T,Integer)\n    UnionAll(T, Array{T})\nend\n```\n\n----------------------------------------\n\nTITLE: Using Non-Global Scoped Values in Julia\nDESCRIPTION: Shows that `ScopedValue`s can be defined locally within a function's scope (`role = ScopedValue(:client)` inside `main`). While possible, the example suggests that for such localized dynamic scoping needs, passing values as explicit function arguments might be a simpler approach.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.ScopedValues\nimport Base.Threads: @spawn\n\nfunction main()\n    role = ScopedValue(:client)\n\n    function launch()\n        #...\n        role[]\n    end\n\n    @with role => :server @spawn launch()\n    launch()\nend\n```\n\n----------------------------------------\n\nTITLE: Purging Fastly CDN Cache for Updated Artifacts - Shell\nDESCRIPTION: Uses curl to send an HTTP PURGE request to the Fastly CDN, forcing them to invalidate the cached copy of an updated checksum file. Only requires curl and correct file paths/URLs; an example is shown for a .sha256 file. There is generally no output unless an error occurs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_25\n\nLANGUAGE: shell\nCODE:\n```\ncurl -X PURGE https://julialang-s3.julialang.org/bin/checksums/julia-x.y.z.sha256\n```\n\n----------------------------------------\n\nTITLE: Parsing If-Else AST Representation – S-Expression\nDESCRIPTION: This snippet shows the s-expression form of a Julia if-elseif-else statement as produced by the parser: the 'if' node takes the condition and a 'block' for each branch, including explicit line number annotations. Used for tooling and macro authors to understand the intermediate representation of source code structures.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ast.md#_snippet_3\n\nLANGUAGE: s-expression\nCODE:\n```\n(if a (block (line 2) b)\n    (elseif (block (line 3) c) (block (line 4) d)\n            (block (line 6 e))))\n```\n\n----------------------------------------\n\nTITLE: Tab Completion of Dictionary Keys - Julia-REPL\nDESCRIPTION: Illustrates tab completion for the keys of a Julia dictionary object by constructing a Dict and attempting index completion with a partial key string. Works directly within the REPL using Julia's standard dictionary type and indexing syntax; facilitates easy exploration of available dictionary keys.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_20\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> foo = Dict(\"qwer1\"=>1, \"qwer2\"=>2, \"asdf\"=>3)\nDict{String,Int64} with 3 entries:\n  \"qwer2\" => 2\n  \"asdf\"  => 3\n  \"qwer1\" => 1\n\njulia> foo[\"q[TAB]\n\n\"qwer1\" \"qwer2\"\njulia> foo[\"qwer\n```\n\n----------------------------------------\n\nTITLE: New `Base.invokelatest` Function in Julia\nDESCRIPTION: Introduces the `Base.invokelatest(f, args...)` function in Julia. This function is designed to call the most recent version of a function `f` with arguments `args...`, particularly useful in scenarios like function calls within `eval` where an older version might otherwise be invoked due to world age issues.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_169\n\nLANGUAGE: julia\nCODE:\n```\nBase.invokelatest(f, args...)\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `sumabs`/`sumabs2`/`maxabs`/`minabs`: Use Higher-Order Functions in Julia\nDESCRIPTION: Functions like `sumabs`, `sumabs2`, `maxabs`, and `minabs` (and their in-place versions) are deprecated in Julia. Use higher-order functions instead: `sum(abs, x)`, `sum(abs2, x)`, `maximum(abs, x)`, `minimum(abs, x)`. Apply the same pattern for in-place operations (e.g., using `map!`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_191\n\nLANGUAGE: julia\nCODE:\n```\nsum(abs, x)\n```\n\nLANGUAGE: julia\nCODE:\n```\nsum(abs2, x)\n```\n\nLANGUAGE: julia\nCODE:\n```\nmaximum(abs, x)\n```\n\nLANGUAGE: julia\nCODE:\n```\nminimum(abs, x)\n```\n\n----------------------------------------\n\nTITLE: Defining Documentation Metadata for the Julia InteractiveUtils Docs - Julia\nDESCRIPTION: Specifies metadata at the top of the documentation page, such as the canonical edit URL for the InteractiveUtils docs index. This metadata is used by Julia's documentation system to link to the source on GitHub and is not directly part of the functional code. No external dependencies are required; it sets the EditURL property for contributors and tooling.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/InteractiveUtils/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nEditURL = \"https://github.com/JuliaLang/julia/blob/master/stdlib/InteractiveUtils/docs/src/index.md\"\n```\n```\n\n----------------------------------------\n\nTITLE: Using Nested Test Sets and Loops in Julia\nDESCRIPTION: Shows how `@testset` macros can be nested and combined with loops for more complex test organization. It includes a nested \"Animals\" test set and another test set iterating from 1 to 3 to test `foo` with arrays of different sizes.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> @testset \"Foo Tests\" begin\n           @testset \"Animals\" begin\n               @test foo(\"cat\") == 9\n               @test foo(\"dog\") == foo(\"cat\")\n           end\n           @testset \"Arrays $i\" for i in 1:3\n               @test foo(zeros(i)) == i^2\n               @test foo(fill(1.0, i)) == i^2\n           end\n       end;\nTest Summary: | Pass  Total  Time\nFoo Tests     |    8      8  0.0s\n```\n\n----------------------------------------\n\nTITLE: Implementing rand for the Optimized DiscreteDistribution Sampler in Julia\nDESCRIPTION: Defines the `rand` method specialized for the `SamplerSimple{<:DiscreteDistribution}` type created previously. It utilizes a hypothetical `draw_number` function, passing the RNG and the pre-computed alias table (stored in `sp.data`), to efficiently draw a random integer according to the specified discrete distribution. Requires `draw_number` to be defined elsewhere.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Random/docs/src/index.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nfunction rand(rng::AbstractRNG, sp::SamplerSimple{<:DiscreteDistribution})\n    draw_number(rng, sp.data)\nend\n```\n\n----------------------------------------\n\nTITLE: Indexing with `begin` using `firstindex` in Julia\nDESCRIPTION: The syntax `a[begin, k]` (and similar uses of `begin`) now calls `firstindex(a, d)` for dimension `d`, rather than `first(axes(a, d))`. However, `firstindex(a, d)` now defaults to calling `first(axes(a, d))` for backward compatibility.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_59\n\nLANGUAGE: julia\nCODE:\n```\nA = rand(3, 4)\nval = A[begin, 2] # Calls firstindex(A, 1) which defaults to first(axes(A, 1))\n```\n\n----------------------------------------\n\nTITLE: Predicate Function Negation Operator `!` in Julia\nDESCRIPTION: The `!` operator in Julia can now be used for predicate function negation. For example, `!iszero` creates a new function that returns the logical opposite of `iszero`. This is useful in functions like `map`, e.g., `map(!iszero, (0, 1))` is equivalent to `map(x -> !iszero(x), (0, 1))`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_175\n\nLANGUAGE: julia\nCODE:\n```\n!\n```\n\nLANGUAGE: julia\nCODE:\n```\nmap(!iszero, (0, 1))\n```\n\nLANGUAGE: julia\nCODE:\n```\nmap(x -> !iszero(x), (0, 1))\n```\n\n----------------------------------------\n\nTITLE: Manually Pre-compiling Regex for Loops in Julia\nDESCRIPTION: This Julia snippet shows the more verbose way to achieve efficient regex matching in a loop without using the `r\"\"` literal. A `Regex` object `re` is explicitly created before the loop and then used within it. This serves as a comparison to the more concise macro literal form.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_58\n\nLANGUAGE: julia\nCODE:\n```\nre = Regex(\"^\\\\s*(?:#|\\$)\")\nfor line = lines\n    m = match(re, line)\n    if m === nothing\n        # non-comment\n    else\n        # comment\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Implementing Power by Squaring to Illustrate Mutation Issues in Julia\nDESCRIPTION: Defines a Julia function `power_by_squaring` that calculates `x` raised to the power of `n` (where `n` must be a power of 2) using repeated squaring. This function is used in the surrounding text to illustrate why operators like `*=` rebind rather than mutate, highlighting potential inconsistencies if mutation were the default for both mutable and immutable types. It depends only on base Julia functions like `ispow2` and `error`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\nfunction power_by_squaring(x, n::Int)\n    ispow2(n) || error(\"This implementation only works for powers of 2\")\n    while n >= 2\n        x *= x\n        n >>= 1\n    end\n    x\nend\n```\n\n----------------------------------------\n\nTITLE: Using replace Function with Optional IO Argument in Julia\nDESCRIPTION: References the `replace` function in Julia, noting a new feature in v1.10. It now accepts an optional `IO` argument (typically as the first argument), allowing the output of the replacement operation to be written directly to a stream instead of creating and returning a new string.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nreplace(string, pattern...)\n```\n\n----------------------------------------\n\nTITLE: Constructing Complex Numbers with Literal Coefficients in Julia\nDESCRIPTION: Demonstrates Julia's syntax for creating complex numbers by juxtaposing numeric literals with the 'im' identifier. This example requires Julia's standard library and does not need any external dependencies. The input is a single expression using a literal coefficient, and the output is a complex number in canonical form.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1+2im\n1 + 2im\n```\n\n----------------------------------------\n\nTITLE: Manually Quoting Shell Metacharacters and Constructing Pipelines - Julia\nDESCRIPTION: Demonstrates the need to quote shell metacharacters like | when using Julia's backtick syntax and explains how to construct actual pipelines using Julia's pipeline method instead. Important for replicating shell pipelines or command chains in Julia. Requires the presence of all involved commands in the host system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/running-external-programs.md#_snippet_6\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> run(`echo hello '|' sort`);\nhello | sort\n\njulia> run(`echo hello \\| sort`);\nhello | sort\n```\n```\n\nLANGUAGE: jldoctest\nCODE:\n```\n```jldoctest\njulia> run(pipeline(`echo hello`, `sort`));\nhello\n```\n```\n\n----------------------------------------\n\nTITLE: Seeding Random Number Generators with Strings in Julia\nDESCRIPTION: Demonstrates the ability to seed seedable random number generators (RNGs) from Julia's `Random` standard library using a string. The `seed!` function takes the RNG object (`rng`) and a string (e.g., `\"a random seed\"`) as input. Depends on the `Random` standard library.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nseed!(rng, \"a random seed\")\n```\n\n----------------------------------------\n\nTITLE: Accessing Underlying Integer and Instant Value of Date in Julia\nDESCRIPTION: Illustrates how to inspect the internal representation of a Date object using dump and retrieve the underlying UTInstant and Int64 value. These approaches reveal implementation details, useful for debugging or interop, and require only the Dates module.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> dump(t)\nDate\n  instant: Dates.UTInstant{Day}\n    periods: Day\n      value: Int64 735264\n\njulia> t.instant\nDates.UTInstant{Day}(Day(735264))\n\njulia> Dates.value(t)\n735264\n```\n\n----------------------------------------\n\nTITLE: Resolving Hostnames to IP Addresses Using getaddrinfo in Julia\nDESCRIPTION: This snippet demonstrates how to resolve a hostname (such as 'google.com') into its corresponding IP address using getaddrinfo. Input is a single hostname as a string. Output is an IpAddress object. Only standard libraries are required. The result depends on DNS resolution being available.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/networking-and-streams.md#_snippet_16\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> getaddrinfo(\"google.com\")\nip\"74.125.226.225\"\n```\n\n----------------------------------------\n\nTITLE: Lowering `-->` Operator to `:call` Expression in Julia\nDESCRIPTION: The `-->` operator now lowers to a `:call` expression, enabling it to be defined and used like a standard function or operator. The dotted version `.-->` is also now parsed. For backward compatibility, `-->` retains its unique expression head during parsing.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_58\n\nLANGUAGE: julia\nCODE:\n```\n# Define --> as a function\nfunction -->(a, b)\n    # function body\nend\n\n# Use the operator\nx --> y\n\n# Dotted version\nA .--> B\n```\n\n----------------------------------------\n\nTITLE: Signal Handling in GDB (GDB Command)\nDESCRIPTION: Configures GDB to ignore certain signals (e.g., SIGSEGV), preventing print, stop, or intercept by the debugger. This reduces noise while debugging multithreaded or profiled Julia code. 'SIGSEGV' can be substituted by any other relevant signal.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_9\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) handle SIGSEGV noprint nostop pass\n```\n\n----------------------------------------\n\nTITLE: Global Variable Assignment Conversion in Julia\nDESCRIPTION: Explains that assignment to a global variable `g` (e.g., `g = x`) now implicitly involves a conversion step: `convert(Any, x)` or `convert(T, x)` if the global `g` has a declared type `T`. This change underscores the importance of ensuring the `convert(Any, x) === x` invariant holds for types.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_29\n\nLANGUAGE: julia\nCODE:\n```\nconvert(Any, x)\n```\n\nLANGUAGE: julia\nCODE:\n```\nconvert(T, x)\n```\n\n----------------------------------------\n\nTITLE: Signal Handling in LLDB (LLDB Command)\nDESCRIPTION: Configures LLDB to ignore SIGSEGV by setting process handling options. Used to reduce unwanted breaks in the debugger due to signals thrown for normal interpreter operation (e.g., threads, profiling). Should be run after the process is started.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_10\n\nLANGUAGE: lldb\nCODE:\n```\n(lldb) pro hand -p true -s false -n false SIGSEGV\n```\n\n----------------------------------------\n\nTITLE: Setting Edit URL Metadata in Julia Docs\nDESCRIPTION: This snippet uses the `@meta` block, specific to Julia's documentation system (Documenter.jl), to define metadata. It sets the `EditURL` variable to the GitHub URL of the source Markdown file, typically used to enable features like an \"Edit on GitHub\" link in the generated documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/UUIDs/docs/src/index.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```@meta\nEditURL = \"https://github.com/JuliaLang/julia/blob/master/stdlib/UUIDs/docs/src/index.md\"\n```\n```\n\n----------------------------------------\n\nTITLE: Using `@executable_path` for Relative Paths on All Platforms in Julia\nDESCRIPTION: The `@executable_path` identifier can now be used within `jl_load_dynamic_library()` calls on all supported platforms, not just macOS. This enables embedding executable-relative paths for loading dynamic libraries within compiled Julia applications, enhancing portability.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_61\n\nLANGUAGE: c\nCODE:\n```\n// Conceptual C API usage within Julia runtime or embedding\njl_load_dynamic_library(\"@executable_path/../lib/mylib.so\", JL_RTLD_DEFAULT, 0);\n```\n\n----------------------------------------\n\nTITLE: Setting Runtime Library Path (rpath) in Julia Build (Makefile)\nDESCRIPTION: Sets the `LDFLAGS` variable in `Make.user` to embed a runtime library search path (rpath) into the compiled Julia executables using the linker flag `-Wl,-rpath`. This helps Julia find required shared libraries located in non-standard directories at runtime when using system libraries (`USE_SYSTEM_XXX=1`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\nLDFLAGS=-Wl,-rpath,/path/to/dir/contains/libXXX.so\n```\n\n----------------------------------------\n\nTITLE: Example Ctrl-C Output for Precompilation Hang Diagnosis\nDESCRIPTION: Shows the output received after interrupting a hanging Julia precompilation process with Ctrl-C. It identifies the package (`Test1`) being precompiled and the type of open handle (`timer`) causing the hang. This information is crucial for pinpointing the source of the precompilation issue.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/precompile_hang.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n^C Interrupted: Exiting precompilation...\n\n  1 dependency had warnings during precompilation:\n┌ Test1 [ac89d554-e2ba-40bc-bc5c-de68b658c982]\n│  [pid 2745] waiting for IO to finish:\n│   Handle type        uv_handle_t->data\n│   timer              0x55580decd1e0->0x7f94c3a4c340\n```\n\n----------------------------------------\n\nTITLE: Calling jl_ on an Argument from GDB (GDB Command)\nDESCRIPTION: Displays the first argument in the current Julia function invocation by calling 'jl_' on 'args[0]'. Useful for inspecting the function argument state at a breakpoint, requiring access to the Julia debugger context. 'args' should be an array or pointer to jl_value_t* objects.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_5\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) call jl_(args[0])\n```\n\n----------------------------------------\n\nTITLE: Disabling Tab Completion Hints in Julia REPL - Julia\nDESCRIPTION: Shows how to temporarily or permanently disable the visual hint for tab completions in the Julia REPL by toggling the relevant option or editing the user's startup.jl. Requires Julia 1.11 or newer for some functionality. The code can be placed in the REPL or the Julia startup configuration, affecting the hint behavior globally for the user.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\nBase.active_repl.options.hint_tab_completes = false\n```\n\nLANGUAGE: julia\nCODE:\n```\natreplinit() do repl\n    if VERSION >= v\"1.11.0-0\"\n        repl.options.hint_tab_completes = false\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Replacing whos with varinfo - Julia\nDESCRIPTION: Presents the migration from 'whos' to 'varinfo', which now returns variable information as a markdown table instead of direct output. No additional dependencies are needed aside from Julia Base. Inputs can vary depending on which module or workspace is inspected.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_156\n\nLANGUAGE: julia\nCODE:\n```\nvarinfo\n```\n\n----------------------------------------\n\nTITLE: Deprecation of Ambiguous `UniformScaling` +/- `Number`: Use Explicit Addition in Julia\nDESCRIPTION: Ambiguous methods for addition and subtraction between `UniformScaling` (`J`) and `Number` (`x`), such as `(+)(J::UniformScaling, x::Number)`, are deprecated in Julia. Use the explicit form `J.λ + x` instead, adding the number directly to the scaling factor `λ`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_182\n\nLANGUAGE: julia\nCODE:\n```\nJ.λ + x\n```\n\n----------------------------------------\n\nTITLE: Creating a full source distribution archive - Makefile - Shell\nDESCRIPTION: Builds a source tarball archive containing Julia and all its required dependencies for use in offline or airgapped build environments. The make target 'full-source-dist' packages the full source, producing an archive named 'julia-version-commit.tar.gz'. Dependencies are the Makefile rules, and all sources will be fetched and packaged automatically. Input: N/A. Output: A compressed tarball with comprehensive sources and dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nmake full-source-dist\n```\n\n----------------------------------------\n\nTITLE: Including C Stack Frames using Stacktrace Options - Julia\nDESCRIPTION: Demonstrates modification of stacktrace behavior to include C stack frames by passing an additional boolean flag (true). Requires the use of stacktrace(trace, true), which outputs all Julia and native C function frames in the call stack. Used for deep debugging or performance analysis. Input is the trace object and true; output is a longer array of StackFrame objects including functions from both Julia and C layers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/stacktraces.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\n```julia-repl\\njulia> stacktrace(trace, true)\\n21-element Array{Base.StackTraces.StackFrame,1}:\\n jl_apply_generic at gf.c:2167\\n do_call at interpreter.c:324\\n eval_value at interpreter.c:416\\n eval_body at interpreter.c:559\\n jl_interpret_toplevel_thunk_callback at interpreter.c:798\\n top-level scope\\n jl_interpret_toplevel_thunk at interpreter.c:807\\n jl_toplevel_eval_flex at toplevel.c:856\\n jl_toplevel_eval_in at builtins.c:624\\n eval at boot.jl:317 [inlined]\\n eval(::Module, ::Expr) at REPL.jl:5\\n jl_apply_generic at gf.c:2167\\n eval_user_input(::Any, ::REPL.REPLBackend) at REPL.jl:85\\n jl_apply_generic at gf.c:2167\\n macro expansion at REPL.jl:116 [inlined]\\n (::getfield(REPL, Symbol(\\\"##28#29\\\")){REPL.REPLBackend})() at event.jl:92\\n jl_fptr_trampoline at gf.c:1838\\n jl_apply_generic at gf.c:2167\\n jl_apply at julia.h:1540 [inlined]\\n start_task at task.c:268\\n ip:0xffffffffffffffff\\n```\n```\n\n----------------------------------------\n\nTITLE: Passing Environment Variables When Adding Local Julia Workers\nDESCRIPTION: Uses the `env` keyword argument with `addprocs` to pass specific environment variables to newly created local worker processes.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\naddprocs(..., env=...)\n```\n\n----------------------------------------\n\nTITLE: Filling a Julia Array from C\nDESCRIPTION: This C code shows how to populate a Julia array with values from C code. It iterates from 0 up to the number of rows (obtained using `jl_array_nrows(x)`) and assigns values directly to the memory locations accessed via the `xData` pointer, which was previously obtained using `jl_array_data`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_27\n\nLANGUAGE: c\nCODE:\n```\nfor (size_t i = 0; i < jl_array_nrows(x); i++)\n    xData[i] = i;\n```\n\n----------------------------------------\n\nTITLE: Extracting Numerator and Denominator from Rationals in Julia\nDESCRIPTION: Shows the use of numerator() and denominator() functions to extract the components of a rational number in Julia. No external dependencies are required. Input is a rational; outputs are its numerator and denominator as integers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> numerator(2//3)\n2\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> denominator(2//3)\n3\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Heat Diffusion with Subnormal Handling in Julia\nDESCRIPTION: Provides routines to simulate heat diffusion in a vector using iterative stencil updates, benchmarking their performance under toggling of subnormal handling via set_zero_subnormals. The snippet includes boundary conditions, alternating stencil updates, and time measurements to showcase performance differences when treating subnormals as zeros. Dependencies: Julia and access to set_zero_subnormals. Inputs: array size, number of time steps; outputs: execution times per trial. Caveats: Changing subnormal handling may alter numerical results or break logical identities.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_61\n\nLANGUAGE: julia\nCODE:\n```\nfunction timestep(b::Vector{T}, a::Vector{T}, \\u0394t::T) where T\n    @assert length(a)==length(b)\n    n = length(b)\n    b[1] = 1                            # Boundary condition\n    for i=2:n-1\n        b[i] = a[i] + (a[i-1] - T(2)*a[i] + a[i+1]) * \\u0394t\n    end\n    b[n] = 0                            # Boundary condition\nend\n\nfunction heatflow(a::Vector{T}, nstep::Integer) where T\n    b = similar(a)\n    for t=1:div(nstep,2)                # Assume nstep is even\n        timestep(b,a,T(0.1))\n        timestep(a,b,T(0.1))\n    end\nend\n\nheatflow(zeros(Float32,10),2)           # Force compilation\nfor trial=1:6\n    a = zeros(Float32,1000)\n    set_zero_subnormals(iseven(trial))  # Odd trials use strict IEEE arithmetic\n    @time heatflow(a,1000)\nend\n\n```\n\n----------------------------------------\n\nTITLE: Single-Line Compound Expression with Semicolon Chains - Julia\nDESCRIPTION: Illustrates the use of a semicolon-separated single-line expression as a compact alternative to a begin block for sequential evaluation. Variables x and y are defined and summed with the result assigned to z. No dependencies required; the syntax is useful for inline or quick operations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> z = (x = 1; y = 2; x + y)\n3\n```\n\n----------------------------------------\n\nTITLE: Illustrating Recursive Structure of checkbounds_indices in Julia\nDESCRIPTION: Shows the typical recursive definition pattern for `checkbounds_indices(Bool, axes, indices)`. It checks the first index `I1` against the first axis `IA1` using `checkindex(Bool, ...)` and then recursively calls itself for the remaining axes `IA` and indices `I`. This function forms a core part of Julia's bounds checking hierarchy, allowing efficient checking by comparing permitted index ranges (`axes`) with requested indices (`I`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/boundscheck.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\ncheckbounds_indices(Bool, (IA1, IA...), (I1, I...)) = checkindex(Bool, IA1, I1) &\n                                                      checkbounds_indices(Bool, IA, I)\n```\n\n----------------------------------------\n\nTITLE: Output and Statement Termination in Julia\nDESCRIPTION: Julia does not require semicolons to terminate statements and does not automatically print statement results (except in the REPL). Explicit printing functions like `println` or macros like `@printf` are used for output.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nprintln(x)\n```\n\nLANGUAGE: julia\nCODE:\n```\n@printf(\"Value: %f\\n\", x)\n```\n\n----------------------------------------\n\nTITLE: Evaluating Basic Expression in Julia REPL\nDESCRIPTION: This snippet demonstrates a basic interaction in the Julian mode of the REPL. It shows entering a simple addition expression `1 + 2`, wrapping it in the `string` function, and the REPL evaluating it and displaying the string result \"3\". This example uses the `jldoctest` block format, indicating it's a testable example within documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> string(1 + 2)\n\"3\"\n```\n\n----------------------------------------\n\nTITLE: Setting Boldface Answer Output in Julia REPL via Startup File - Julia\nDESCRIPTION: Shows how to use boldface for REPL answers by customizing environment and output color fields in a Julia startup configuration. The customize_colors function disables REPL's own color environment handling and sets answer_color to bold. Put into ~/.julia/config/startup.jl for persistent settings.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_27\n\nLANGUAGE: julia\nCODE:\n```\nfunction customize_colors(repl)\n    repl.envcolors = false\n    repl.answer_color = Base.text_colors[:bold]\nend\n\natreplinit(customize_colors)\n```\n\n----------------------------------------\n\nTITLE: Documenting splitdir Return Value Structure - Julia - Julia\nDESCRIPTION: This snippet provides a Julia docstring for the splitdir function, using the -> notation to describe the structured return value. The returned tuple includes named elements for directory and filename, enhancing clarity about output structure. This form is important for communicating multiple return values in Julia functions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/documentation.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\n   splitdir(path::AbstractString) -> (dir::AbstractString, file::AbstractString)\n...\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Attempting to Query a Non-Loaded Locale Field in Julia\nDESCRIPTION: Demonstrates the error produced when attempting to access day abbreviations for a locale that was not configured with such values. This highlights a limitation when locale data is incomplete. Inputs are the Date object and the locale name.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\njulia> Dates.dayabbr(t;locale=\"french\")\nERROR: BoundsError: attempt to access 1-element Vector{String} at index [5]\nStacktrace:\n[...]\n```\n\n----------------------------------------\n\nTITLE: Removing Metadata During Julia System Image Build (Bash)\nDESCRIPTION: Explains the `--strip-metadata` command-line option used when building a Julia system image. This option removes potentially bulky metadata like docstrings, source location information, and local variable names from the resulting image file.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\n--strip-metadata\n```\n\n----------------------------------------\n\nTITLE: Keyword-based Dimension Arguments for Array Operations - Julia\nDESCRIPTION: Explains the shift from positional to 'dims' keyword argument for functions like sum, prod, maximum, and others, enhancing clarity and extensibility. No actual code is provided, but usage is implied, e.g., sum(A; dims=2).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_161\n\n\n\n----------------------------------------\n\nTITLE: Specializing axes1 for Zero- and Higher-Dimensional Arrays - Julia\nDESCRIPTION: These two methods define 'axes1', a utility for quickly pulling the primary axis of an AbstractArray; for 0-dimensional arrays, it returns 'OneTo(1)', and for higher dimensions, it returns the first range from 'axes(A)'. Often used for optimization and dispatch correctness. Parameters: AbstractArray. Returns an AbstractUnitRange. Extend or override when handling custom AbstractArrays with non-standard zero-dimensional behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/offset-arrays.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\naxes1(A::AbstractArray{T,0}) where {T} = OneTo(1)\naxes1(A::AbstractArray) = axes(A)[1]\n```\n\n----------------------------------------\n\nTITLE: Specifying Worker Process Thread Count using addprocs in Julia\nDESCRIPTION: Shows how to set the number of threads for worker processes spawned using `addprocs` in Julia. The `exeflags` keyword argument is used to pass command-line options, such as `--threads 4`, to the new Julia worker processes.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_82\n\nLANGUAGE: julia\nCODE:\n```\naddprocs(...; exeflags=`--threads 4`)\n```\n\n----------------------------------------\n\nTITLE: Searching for Characters in Strings using `find*` functions in Julia\nDESCRIPTION: The functions `findfirst`, `findlast`, `findnext`, and `findprev` now accept a `Char` as the first argument to search for that character within a `String` provided as the second argument.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_109\n\nLANGUAGE: julia\nCODE:\n```\nfindfirst(char::Char, string::String)\nfindlast(char::Char, string::String)\nfindnext(char::Char, string::String, start_index::Integer)\nfindprev(char::Char, string::String, start_index::Integer)\n```\n\n----------------------------------------\n\nTITLE: Offset Modular Arithmetic with `mod` and Unit Range in Julia\nDESCRIPTION: The `mod` function now accepts a unit range as the second argument (e.g., `mod(x, 1:n)`). This performs modular arithmetic such that the result is guaranteed to be within the specified range (inclusive).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_125\n\nLANGUAGE: julia\nCODE:\n```\nmod(13, 1:10) # Returns 3\nmod(10, 1:10) # Returns 10\nmod(0, 1:10)  # Returns 10\n```\n\n----------------------------------------\n\nTITLE: Inspecting LLVM IR using @code_llvm Macro in Julia\nDESCRIPTION: Shows how to use the `@code_llvm` macro to inspect the generated LLVM Intermediate Representation for a specific function call. The example displays the LLVM IR for the addition operation `+(1, 1)`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/reflection.md#_snippet_6\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> @code_llvm +(1,1)\n;  @ int.jl:87 within `+`\n; Function Attrs: sspstrong uwtable\ndefine i64 @\"julia_+_476\"(i64 signext %0, i64 signext %1) #0 {\ntop:\n  %2 = add i64 %1, %0\n  ret i64 %2\n}\n```\n\n----------------------------------------\n\nTITLE: Updating `readdlm` Default Behavior in Julia\nDESCRIPTION: The `readdlm` function in the DelimitedFiles standard library now defaults the `use_mmap` argument to `false` across all operating systems. This change aims to provide consistent reliability, especially in unusual filesystem scenarios.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_46\n\nLANGUAGE: julia\nCODE:\n```\nreaddlm(..., use_mmap=false) # New default behavior\n```\n\n----------------------------------------\n\nTITLE: Setting Julia Thread Count Environment Variable (Shell)\nDESCRIPTION: This shell command sets the `JULIA_NUM_THREADS` environment variable to 8. This instructs the Julia runtime environment to utilize up to eight threads for parallel execution. Setting this is recommended when using `rr --chaos` for debugging concurrency, as `rr` can simulate up to eight cores in that mode.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\nJULIA_NUM_THREADS=8\n```\n\n----------------------------------------\n\nTITLE: Embedding Markdown String Literals Using md Macro - Julia\nDESCRIPTION: This Julia code snippet demonstrates embedding a markdown-formatted string directly into Julia code using the md macro. The macro, invoked as md\"...\", accepts standard Markdown including formatting and links, and produces a Markdown object suitable for further rendering or API processing. The feature depends on Julia's standard Markdown module; the key parameter is the markdown text within the macro. Input is a Markdown-formatted string, and output is a Markdown object. It is limited to Julia environments where the Markdown module and md macro are available.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_25\n\nLANGUAGE: julia\nCODE:\n```\nresult = md\"This is a **custom** Markdown string with [a link](http://example.com).\"\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Code Loading Functions\nDESCRIPTION: This block uses the `@docs` directive to list functions related to Julia's code loading mechanism. This includes functions for identifying and locating packages (`identify_package`, `locate_package`), loading modules (`require`), managing precompilation caches (`compilecache`, `isprecompiled`), and accessing package extensions (`get_extension`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.identify_package\nBase.locate_package\nBase.require\nBase.compilecache\nBase.isprecompiled\nBase.get_extension\n```\n```\n\n----------------------------------------\n\nTITLE: Invoking Julia Macros on Array Literals via Juxtaposition\nDESCRIPTION: Shows an alternative syntax for invoking a macro on an array literal or comprehension by juxtaposing `@name` and `[...]` without parentheses. This passes the array as the single argument to the macro and is equivalent to `@name([...]) * v`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\n@name[a b] * v\n@name([a b]) * v\n```\n\n----------------------------------------\n\nTITLE: Checking Exception Object Types - Julia\nDESCRIPTION: These snippets clarify the distinction between DomainError as a type and an instantiated exception object as used in throw. typeof(DomainError(nothing)) returns a subtype of Exception, while typeof(DomainError) is just the exception type itself. Useful for avoiding errors when programmatically manipulating exceptions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\njulia> typeof(DomainError(nothing)) <: Exception\ntrue\n\njulia> typeof(DomainError) <: Exception\nfalse\n\n```\n\n----------------------------------------\n\nTITLE: Loading Multiple Julia Modules with a Single `using` Statement\nDESCRIPTION: Demonstrates the concise syntax in Julia for loading multiple modules (`LinearAlgebra` and `Random` in this case) simultaneously using a single `using` statement within a `jldoctest` block, separating the module names with commas. This imports the module names and their respective exported members into the current namespace.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_7\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using LinearAlgebra, Random\n```\n\n----------------------------------------\n\nTITLE: Comparing Real and Complex Results with sqrt in Julia\nDESCRIPTION: Demonstrates how the sqrt() function behaves differently for negative real versus negative complex input. Attempts to compute sqrt(-1) raise a domain error, while sqrt(-1 + 0im) returns a complex result. Only Julia Base is needed and the distinction helps avoid unexpected errors in mathematical computation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> sqrt(-1)\nERROR: DomainError with -1.0:\nsqrt was called with a negative real argument but will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\nStacktrace:\n[...]\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> sqrt(-1 + 0im)\n0.0 + 1.0im\n```\n\n----------------------------------------\n\nTITLE: Defining Julia Modules with Order-Dependent Variable Access Error\nDESCRIPTION: Highlights an `UndefVarError` caused by accessing a variable before its definition across modules. The submodule `Sub` tries to use `TestPackage.y` (accessed via `using ..TestPackage`), but `y` is defined in `TestPackage` *after* the `Sub` module block. Consequently, `y` doesn't exist when `Sub` is evaluated.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\nmodule TestPackage\n\nexport x, y\n\nx = 0\n\nmodule Sub\nusing ..TestPackage\nz = y # ERROR: UndefVarError: `y` not defined in `Main`\nend\n\ny = 1\n\nend\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Function with Conditional Type Dispatching (Less Idiomatic)\nDESCRIPTION: Presents a function `mynorm` that uses `if/elseif` with `isa` checks to handle different input types (`Vector`, `Matrix`). While functional, this approach is generally less performant and less idiomatic in Julia compared to using multiple dispatch, as the type checks happen at runtime.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/performance-tips.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nusing LinearAlgebra\n\nfunction mynorm(A)\n    if isa(A, Vector)\n        return sqrt(real(dot(A,A)))\n    elseif isa(A, Matrix)\n        return maximum(svdvals(A))\n    else\n        error(\"mynorm: invalid argument\")\n    end\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Calling C Function with char** Argument from Julia\nDESCRIPTION: Demonstrates calling a C function (like `main`) that accepts `char**` arguments using Julia's `@ccall`. It shows how to prepare a Julia array of strings and pass it as a `Ptr{Ptr{UInt8}}`, along with the argument count explicitly cast to `Int32`. The expected return type (`Int32`) is also specified.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/calling-c-and-fortran-code.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nargv = [ \"a.out\", \"arg1\", \"arg2\" ]\n@ccall main(length(argv)::Int32, argv::Ptr{Ptr{UInt8}})::Int32\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom AbstractTestSet Subtype in Julia\nDESCRIPTION: Demonstrates the definition of a `CustomTestSet` struct inheriting from `Test.AbstractTestSet`. It includes a constructor taking a description and options, storage for results (`results::Vector`), and implementations for the required `record` and `finish` methods from the `Test` package. The `finish` method handles result recording for nested testsets and printing results via `Test.print_test_results` for the top-level testset.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nimport Test: Test, record, finish\nusing Test: AbstractTestSet, Result, Pass, Fail, Error\nusing Test: get_testset_depth, get_testset\nstruct CustomTestSet <: Test.AbstractTestSet\n    description::AbstractString\n    foo::Int\n    results::Vector\n    # constructor takes a description string and options keyword arguments\n    CustomTestSet(desc; foo=1) = new(desc, foo, [])\nend\n\nrecord(ts::CustomTestSet, child::AbstractTestSet) = push!(ts.results, child)\nrecord(ts::CustomTestSet, res::Result) = push!(ts.results, res)\nfunction finish(ts::CustomTestSet)\n    # just record if we're not the top-level parent\n    if get_testset_depth() > 0\n        record(get_testset(), ts)\n        return ts\n    end\n\n    # so the results are printed if we are at the top level\n    Test.print_test_results(ts)\n    return ts\nend\n```\n\n----------------------------------------\n\nTITLE: Single-Threaded Summation Function - Julia\nDESCRIPTION: Defines a function sum_single that computes the sum of elements in an array with a single-threaded for loop. No dependencies outside Julia core language. Accepts a sequence as input, returns the total as output. Safe from data races by design.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_14\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> function sum_single(a)\n           s = 0\n           for i in a\n               s += i\n           end\n           s\n       end\nsum_single (generic function with 1 method)\n\njulia> sum_single(1:1_000_000)\n500000500000\n```\n\n----------------------------------------\n\nTITLE: Returning Nothing in Julia Functions - Julia\nDESCRIPTION: Demonstrates the Julia convention for functions that perform side effects without returning meaningful values. The example function prints a value and explicitly returns 'nothing', which is a singleton object of type Nothing. No external dependencies are required. The sole parameter 'x' is printed; no output is returned by the function. Notably, 'return nothing' is a style preference rather than a necessity, since printing already returns 'nothing'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nfunction printx(x)\n    println(\"x = $x\")\n    return nothing\nend\n```\n\n----------------------------------------\n\nTITLE: Compiler Optimization of Fixed-size Integer Arithmetic Loops in Julia - Julia\nDESCRIPTION: This Julia code demonstrates further optimization by making the loop count fixed, allowing the compiler to reduce a sequence of repeated integer arithmetic operations into a single multiply and add in the machine code. It shows how knowledge of associativity and distributivity enables the compiler to generate minimal, highly efficient assembly for integer-heavy routines. The code relies on defining a function and calling code_native to inspect the output.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\njulia> function g(k)\n           for i = 1:10\n               k = f(k)\n           end\n           return k\n       end\ng (generic function with 2 methods)\n\njulia> code_native(g,(Int,))\n  .text\nFilename: none\n  pushq %rbp\n  movq  %rsp, %rbp\nSource line: 3\n  imulq $9765625, %rdi, %rax    # imm = 0x9502F9\n  addq  $-2441406, %rax         # imm = 0xFFDABF42\nSource line: 5\n  popq  %rbp\n  retq\n  nopw  %cs:(%rax,%rax)\n```\n\n----------------------------------------\n\nTITLE: Defining Constructors with `where` Syntax in Julia\nDESCRIPTION: Julia v1.6 allows using the `where` syntax directly in constructor definitions. This enables defining constructors for parameterized types more expressively.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_47\n\nLANGUAGE: julia\nCODE:\n```\n(Foo{T} where T)(x) = ...\n```\n\n----------------------------------------\n\nTITLE: Generating Typed SSA IR for a Julia Function (Julia)\nDESCRIPTION: This Julia snippet uses the `InteractiveUtils.@code_typed` macro to inspect the typed SSA IR generated by the Julia compiler. It specifically requests the IR for the `foo` function (defined previously) when called with a `Float64` argument (1.0). This is a common way to view the compiler's intermediate steps.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nusing InteractiveUtils\n@code_typed foo(1.0)\n```\n\n----------------------------------------\n\nTITLE: Investigating the Empty Tuple and its Type Parameters - Julia REPL - Julia\nDESCRIPTION: Shows that Tuple{} is a distinct type from Tuple, with no parameters and a trivial intersection with non-empty tuples (resulting in Union{}). Dependencies: None beyond Julia. Inputs: Empty tuple types; Outputs: Parameters and intersection results. Highlights the emptiness of Tuple{} for dispatch and type relations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_9\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> Tuple{}\nTuple{}\n\njulia> Tuple{}.parameters\nsvec()\n\njulia> typeintersect(Tuple{}, Tuple{Int})\nUnion{}\n```\n\n----------------------------------------\n\nTITLE: Checking System Word Size in Julia\nDESCRIPTION: Shows how to use the `Sys.WORD_SIZE` internal variable to determine if the Julia instance is running on a 32-bit or 64-bit system. The output will be `32` or `64`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```julia-repl\n# 32-bit system:\njulia> Sys.WORD_SIZE\n32\n\n# 64-bit system:\njulia> Sys.WORD_SIZE\n64\n```\n```\n\n----------------------------------------\n\nTITLE: Splitting Long String Literals Across Lines in Julia\nDESCRIPTION: Illustrates multi-line string literals by joining lines with a backslash. This allows for long logical lines in code to remain readable. Inputs are a continued string literal; output is the logically joined string.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> \"This is a long \\\n       line\"\n\"This is a long line\"\n```\n\n----------------------------------------\n\nTITLE: `Sockets.recvfrom` Returning `InetAddr` in Julia\nDESCRIPTION: The `Sockets.recvfrom` function now returns the sender's address as a single `InetAddr` object, which contains both the host IP address and the port number.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_142\n\nLANGUAGE: julia\nCODE:\n```\nusing Sockets\n# data, addr = recvfrom(socket)\n# addr is now an InetAddr containing host and port\n```\n\n----------------------------------------\n\nTITLE: Declaring the Profile.print Function in Julia\nDESCRIPTION: Shows the function signature for `Profile.print`. This function is used to display collected profiling data. It takes an optional `io` argument (defaulting to `stdout`) for specifying the output stream and an optional `data` argument (defaulting to `Profile.fetch()`) containing the profile data. Keyword arguments (`kwargs...`) allow for further customization of the output.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nfunction print(io::IO = stdout, data = fetch(); kwargs...)\n```\n\n----------------------------------------\n\nTITLE: Iteratively Reading Typed Data with `Base.readeach` in Julia\nDESCRIPTION: The function `Base.readeach(io, T)` returns an iterator that repeatedly calls `read(io, T)` until the end of the stream `io` is reached. This provides a convenient way to process streams of fixed-size binary data.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_64\n\nLANGUAGE: julia\nCODE:\n```\n# Example: Read a sequence of Int32 values from a file\nopen(\"data.bin\") do io\n    for value in Base.readeach(io, Int32)\n        println(value)\n    end\nend\n```\n\n----------------------------------------\n\nTITLE: Timing Package Precompilation using Pkg.precompile in Julia\nDESCRIPTION: Demonstrates how to use the `Pkg.precompile` function in Julia's package manager with the `timing=true` keyword argument. Invoking precompilation this way will output timing information for each package being precompiled, aiding in performance analysis.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nPkg.precompile(timing=true)\n```\n\n----------------------------------------\n\nTITLE: Combining Begin and Semicolon Chains, Multiline and Single-Line - Julia\nDESCRIPTION: Shows variations in compound expression syntax using both multiline begin blocks and single/multiline semicolon chains. Useful to demonstrate that begin and semicolon chains are interchangeable in many contexts, allowing for flexibility in code formatting. Variable assignments and summation are performed as in prior examples.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> begin x = 1; y = 2; x + y end\n3\n\njulia> (x = 1;\n        y = 2;\n        x + y)\n3\n```\n\n----------------------------------------\n\nTITLE: Consuming Channels Concurrently with `Threads.foreach` in Julia\nDESCRIPTION: A new function `Base.Threads.foreach(f, channel::Channel)` provides a mechanism for consuming items from a `Channel` using multiple threads. The function `f` is applied to each item retrieved from the channel in parallel.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_62\n\nLANGUAGE: julia\nCODE:\n```\nc = Channel{Int}(32)\n# ... populate channel c ...\n\nfunction process_item(item)\n    # Process item\nend\n\nBase.Threads.foreach(process_item, c)\n```\n\n----------------------------------------\n\nTITLE: Deprecation of Ambiguous `<:Period` Range Construction: Specify Step in Julia\nDESCRIPTION: Constructing ranges of `Dates.Period` subtypes without specifying a step, like `Dates.Hour(1):Dates.Hour(2)`, is deprecated due to ambiguity in Julia. Always specify the step explicitly, for example, `Dates.Hour(1):Dates.Hour(1):Dates.Hour(2)`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_188\n\nLANGUAGE: julia\nCODE:\n```\nDates.Hour(1):Dates.Hour(1):Dates.Hour(2)\n```\n\n----------------------------------------\n\nTITLE: Converting Values to Float32 Using Constructor in Julia (Julia)\nDESCRIPTION: Explains how to convert a numeric value of any compatible type to Float32 using the Float32 constructor. Accepts a numeric value as input and outputs its Float32 representation. Useful for explicit type conversions in computational workflows. No external dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\njulia> x = Float32(-1.5)\n-1.5f0\n\njulia> typeof(x)\nFloat32\n```\n\n----------------------------------------\n\nTITLE: Testing the Julia Build - Shell\nDESCRIPTION: This shell command runs all tests for the freshly built Julia installation by invoking 'make testall'. Dependencies include a successful prior build. Outputs include detailed test progress and results; all tests should complete without error for a correct build.\nSOURCE: https://github.com/julialang/julia/blob/master/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nmake testall\n```\n\n----------------------------------------\n\nTITLE: Replaying a Specific Process with rr Debugger\nDESCRIPTION: Example command `rr replay -p PID` for the `rr` debugger. This command replays the execution of a specific process identified by its `PID` (Process ID), allowing for deterministic debugging of complex scenarios like Julia precompilation failures.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/aot.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nrr replay -p PID\n```\n\n----------------------------------------\n\nTITLE: `empty` Function Support for NamedTuple in Julia\nDESCRIPTION: The `empty` function can now be used with `NamedTuple` types to create an empty named tuple with the same field names but empty collections (if applicable) or default values.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_124\n\nLANGUAGE: julia\nCODE:\n```\nnt = (a=1, b=\"hi\")\nempty(nt) # Might return (a=(), b=()) depending on interpretation, or an empty NT of same structure\n```\n\n----------------------------------------\n\nTITLE: Referencing Julia CPU Target Variable (Makefile)\nDESCRIPTION: References the `JULIA_CPU_TARGET` variable, configurable in `Make.user` or `Make.inc`, which allows fine-grained control over CPU features and instruction sets used during the Julia build for performance tuning beyond the general `MARCH` setting.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_5\n\nLANGUAGE: Makefile\nCODE:\n```\nJULIA_CPU_TARGET\n```\n\n----------------------------------------\n\nTITLE: Using the Wall-Time Profiler for Channel Contention Analysis in Julia\nDESCRIPTION: Revises the previous channel contention example to use the wall-time profiler via `Profile.@profile_walltime main()`. Unlike the standard CPU profiler, the wall-time profiler samples tasks based on their existence over time, regardless of their running state. This allows it to effectively capture time spent waiting on the channel (`take!(ch)`), making it suitable for diagnosing contention and I/O-related performance issues.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/profile.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.Threads\nusing Profile\nusing PProf\n\nch = Channel(1)\n\nconst N_SPAWNED_TASKS = (1 << 10)\nconst WAIT_TIME_NS = 10_000_000\n\nfunction spawn_a_bunch_of_tasks_waiting_on_channel()\n    for i in 1:N_SPAWNED_TASKS\n        Threads.@spawn begin\n            take!(ch)\n        end\n    end\nend\n\nfunction busywait()\n    t0 = time_ns()\n    while true\n        if time_ns() - t0 > WAIT_TIME_NS\n            break\n        end\n    end\nend\n\nfunction main()\n    spawn_a_bunch_of_tasks_waiting_on_channel()\n    for i in 1:N_SPAWNED_TASKS\n        put!(ch, i)\n        busywait()\n    end\nend\n\nProfile.@profile_walltime main()\n```\n\n----------------------------------------\n\nTITLE: Example of Complex Multi-Argument Dispatch in Julia\nDESCRIPTION: Illustrates a scenario where a function `f` has multiple methods dispatching on different combinations of two types, `A` and `B`. This complexity motivates exploring alternative designs like orthogonalization.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_43\n\nLANGUAGE: julia\nCODE:\n```\nf(x::A, y::A) = ...\nf(x::A, y::B) = ...\nf(x::B, y::A) = ...\nf(x::B, y::B) = ...\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `produce`/`consume`: Use Channels in Julia\nDESCRIPTION: The `produce` and `consume` functions, along with direct iteration over Task objects for inter-task communication, are deprecated in Julia. The recommended approach is to use Channels (`Channel`) for communication between concurrent tasks.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_193\n\n\n\n----------------------------------------\n\nTITLE: Examining the Expression Returned by Macro Expansion in Julia\nDESCRIPTION: Displays the type (`Expr`) and content of the expression `ex` generated by expanding the `@twostep` macro. It shows the code that will be executed at runtime, including the interpolated argument.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_28\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> typeof(ex)\nExpr\n\njulia> ex\n:(println(\"I execute at runtime. The argument is: \", $(Expr(:copyast, :($(QuoteNode(:((1, 2, 3)))))))))\n\n```\n\n----------------------------------------\n\nTITLE: Defining Serial Advection Computation Function in Julia REPL\nDESCRIPTION: Defines the function `advection_serial!`, which serves as a baseline serial implementation for the advection problem. It calls `advection_chunk!` with the full index ranges of the input arrays `q` and `u` (`1:size(q,1)`, `1:size(q,2)`, `1:size(q,3)-1`), performing the entire computation within a single process.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_35\n\nLANGUAGE: julia\nCODE:\n```\njulia> advection_serial!(q, u) = advection_chunk!(q, u, 1:size(q,1), 1:size(q,2), 1:size(q,3)-1);\n```\n\n----------------------------------------\n\nTITLE: Defining and Checking Singleton Types in Julia\nDESCRIPTION: Defines an immutable struct `NoFields` with no fields. It demonstrates that instances created via `NoFields()` are identical using the identity operator `===` and confirms `NoFields` is a singleton type using `Base.issingletontype`. Singleton types have only one possible instance.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_49\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> struct NoFields\n       end\n\njulia> NoFields() === NoFields()\ntrue\n\njulia> Base.issingletontype(NoFields)\ntrue\n```\n\n----------------------------------------\n\nTITLE: Using the Generic `Base.ifelse` Function in Julia\nDESCRIPTION: Notes that `Base.ifelse(condition, x, y)` is now defined as a generic function in Julia, rather than a builtin. This allows packages to extend its definition for custom types or behaviors. It returns `x` if `condition` is true, otherwise `y`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\nBase.ifelse\n```\n\n----------------------------------------\n\nTITLE: Improved `repr` for `Time` Objects in Julia\nDESCRIPTION: The `repr` function for `Time` objects has been fixed to display the time in a format that represents how it would be entered as Julia code (e.g., `Time(hour, minute, second)`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_140\n\nLANGUAGE: julia\nCODE:\n```\nusing Dates\nt = Time(10, 30, 5)\nrepr(t) # Output resembles `Time(10, 30, 5)`\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `LinearIndexing`, `LinearFast`, `LinearSlow`: Use `IndexStyle`, `IndexLinear`, `IndexCartesian` in Julia\nDESCRIPTION: Names related to indexing traits in Julia have been changed. `LinearIndexing` and `linearindexing` are deprecated in favor of `IndexStyle`. `LinearFast` is deprecated in favor of `IndexLinear`. `LinearSlow` is deprecated in favor of `IndexCartesian`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_199\n\nLANGUAGE: julia\nCODE:\n```\nIndexStyle\n```\n\nLANGUAGE: julia\nCODE:\n```\nIndexLinear\n```\n\nLANGUAGE: julia\nCODE:\n```\nIndexCartesian\n```\n\n----------------------------------------\n\nTITLE: Creating Fenced Code Blocks in Markdown\nDESCRIPTION: These snippets demonstrate creating code blocks using triple backticks (``` ```). An optional language identifier can be added after the opening backticks (e.g., ```julia) for syntax highlighting. Fenced code blocks are preferred over indented ones.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_13\n\nLANGUAGE: markdown\nCODE:\n```\nA code block without a \"language\":\n\n```\nfunction func(x)\n    # ...\nend\n```\n```\n\nLANGUAGE: markdown\nCODE:\n```\nand another one with the \"language\" specified as `julia`:\n\n```julia\nfunction func(x)\n    # ...\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `Matrix()`/`Matrix{T}()`: Use Explicit Zero Dimensions in Julia\nDESCRIPTION: The zero-argument constructors `Matrix()` and `Matrix{T}()` are deprecated in Julia. To create an empty 0x0 matrix, use the explicit forms `Matrix(0, 0)` or `Matrix{T}(0, 0)`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_196\n\nLANGUAGE: julia\nCODE:\n```\nMatrix(0, 0)\n```\n\nLANGUAGE: julia\nCODE:\n```\nMatrix{T}(0, 0)\n```\n\n----------------------------------------\n\nTITLE: Representing Keyword Argument Types in Julia Stack Traces\nDESCRIPTION: Shows the `@Kwargs{...}` syntax introduced in Julia v1.10. This syntax is used internally to simplify the display of keyword argument types within stack traces, making them more readable.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n@Kwargs{key1::Type1, ...}\n```\n\n----------------------------------------\n\nTITLE: Querying Date Fields Using a Custom Locale in Julia\nDESCRIPTION: Illustrates locale-aware querying functions, retrieving day name, month name, and month abbreviation in French by specifying the locale keyword argument. Requires a previously registered locale and a Date input.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> Dates.dayname(t;locale=\"french\")\n\"vendredi\"\n\njulia> Dates.monthname(t;locale=\"french\")\n\"janvier\"\n\njulia> Dates.monthabbr(t;locale=\"french\")\n\"janv\"\n```\n\n----------------------------------------\n\nTITLE: Expression Returned by Simple Macro in Julia\nDESCRIPTION: Shows the literal Julia expression that the simple `@sayhello` macro returns. This expression object represents the code that will be executed when the macro is used.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\n:( println(\"Hello, world!\") )\n```\n\n----------------------------------------\n\nTITLE: Obtaining Tuple Types from Tuple Values in Julia\nDESCRIPTION: Demonstrates Julia's ability to infer and construct the tuple type from the structure and types of runtime tuple values. Shows how tuples of different element types get corresponding Tuple type objects, which are covariant over elements, serving in multiple dispatch and method signatures.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/types.md#_snippet_39\n\nLANGUAGE: julia\nCODE:\n```\njulia> typeof((1,\"foo\",2.5))\nTuple{Int64, String, Float64}\n```\n\n----------------------------------------\n\nTITLE: Algorithm Selection for SVD in Julia\nDESCRIPTION: The `svd` and `svd!` functions in `LinearAlgebra` now accept a keyword argument `alg` to allow selection between different SVD algorithms (e.g., `DivideAndConquer`, `QRIteration`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_135\n\nLANGUAGE: julia\nCODE:\n```\nusing LinearAlgebra\nA = randn(5, 4)\nsvd(A, alg=LinearAlgebra.DivideAndConquer())\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with Optional Arguments in Julia\nDESCRIPTION: Demonstrates the syntax for defining a Julia function `f` with optional positional arguments `a` and `b`, which have default values `1` and `2` respectively. If arguments are omitted in a call, the default values are used.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_32\n\nLANGUAGE: julia\nCODE:\n```\nf(a=1,b=2) = a+2b\n```\n\n----------------------------------------\n\nTITLE: Setting Optimization Level (Julia Flag)\nDESCRIPTION: The `-O` or `--optimize` command-line flags set the compiler optimization level (0, 1, 2, or 3). Package images created with a lower optimization level will be rejected if a higher level is requested, but caches from higher levels are acceptable.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n-O, --optimize\n```\n\n----------------------------------------\n\nTITLE: `unescape_string` with `keep` Argument in Julia\nDESCRIPTION: The `unescape_string` function now includes a `keep` keyword argument, allowing more control over which escape sequences are processed or kept literally.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_129\n\nLANGUAGE: julia\nCODE:\n```\nunescape_string(\"\\\\n\", keep = r\"\\\\n\") # Example usage, specific behavior depends on `keep` pattern\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `Multimedia.@textmime`: Use `Multimedia.istextmime` in Julia\nDESCRIPTION: The macro `Multimedia.@textmime \"mime\"` is deprecated in Julia. To indicate that a MIME type is text-based, define a method `Multimedia.istextmime(::MIME\"mime\") = true` instead.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_179\n\nLANGUAGE: julia\nCODE:\n```\nMultimedia.istextmime(::MIME\"mime\") = true\n```\n\n----------------------------------------\n\nTITLE: Checking Julia GC Version from REPL - text\nDESCRIPTION: Illustrates the use of 'versioninfo()' in the Julia REPL to display current Julia version details, including the GC type in use. This is a runtime command intended for verification after building Julia with a specific GC configuration.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-mmtk.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nversioninfo()\n```\n\n----------------------------------------\n\nTITLE: Enabling Fail-Fast Mode for a Julia Testset\nDESCRIPTION: Configures a specific `@testset` block to operate in fail-fast mode. If any test within this set fails or errors, the entire test run terminates immediately.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\n@testset failfast=true\n```\n\n----------------------------------------\n\nTITLE: Period Arithmetic and Associativity in Julia Dates Module\nDESCRIPTION: Compares different associativity orders when adding Day and Month Periods to a Date, showing that order affects results unless Periods are chained, in which case the module ensures consistent semantics. Only standard Dates objects are needed.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\njulia> (Date(2014,1,29)+Dates.Day(1)) + Dates.Month(1)\n2014-02-28\n\njulia> (Date(2014,1,29)+Dates.Month(1)) + Dates.Day(1)\n2014-03-01\n```\n\n----------------------------------------\n\nTITLE: Enabling Detection of Offset Axes on Non-AbstractArray Types - Julia\nDESCRIPTION: For types that act like AbstractArrays but don't subtype it, this method lets code using 'has_offset_axes' correctly recognize the custom-offset property by simply returning true. Useful in user-defined wrapper types or array-like structs that don't inherit from AbstractArray. Parameters: an object of the user type. Returns: true (Boolean). This pattern helps with robust error reporting and compatibility with code expecting 1-based indexing.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/offset-arrays.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nBase.has_offset_axes(obj::MyNon1IndexedArraylikeObject) = true\n```\n\n----------------------------------------\n\nTITLE: Finding the Parent Module of an Identifier in Julia\nDESCRIPTION: Demonstrates the use of the `parentmodule` function in Julia to determine the originating module of a given identifier (like a type or function). In this example, it shows that `UnitRange` belongs to the `Base` module. This is useful for understanding where names come from and for using qualified names.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/modules.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> parentmodule(UnitRange)\nBase\n```\n\n----------------------------------------\n\nTITLE: Using env -S Shebang for Julia Scripts (Julia)\nDESCRIPTION: Illustrates how to create a Julia script with a shebang that supports command-line options using '/usr/bin/env -S' for compatibility across BSD, macOS, and Linux. The code demonstrates printing command-line arguments via ARGS in Julia, with '--color=yes' and '--startup-file=no' options passed to the Julia executable. Required dependencies are system support for 'env -S' (FreeBSD 6.0+, macOS Sierra+, GNU coreutils 8.30+). The primary input comes from the arguments provided when the script is run, and the output is a display of ARGS; limitations exist on platforms lacking 'env -S' support.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n#!/usr/bin/env -S julia --color=yes --startup-file=no\n@show ARGS  # put any Julia code here\n```\n\n----------------------------------------\n\nTITLE: Consistent Handling of Zero-Dimensional Arrays in Mathematical Functions in Julia\nDESCRIPTION: Mathematical functions (`+`, `-`, `*`, `/`, `conj`, `real`, `imag`) operating on zero-dimensional arrays now consistently return zero-dimensional arrays, rather than unwrapping the element.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_120\n\nLANGUAGE: julia\nCODE:\n```\na = fill(1.0)\nb = fill(2.0)\na + b # Returns a 0-dimensional array containing 3.0\n```\n\n----------------------------------------\n\nTITLE: Using tonext Adjuster to Find Next Matching Day in Julia\nDESCRIPTION: Demonstrates two uses of the tonext adjuster: first using a custom lambda DateFunction for a specific condition (next Tuesday), and second using the convenience method with a constant for weekday adjustments. Inputs include a function or Date plus day constant; output is the next matching Date.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\njulia> istuesday = x->Dates.dayofweek(x) == Dates.Tuesday; # Returns true if the day of the week of x is Tuesday\n\njulia> Dates.tonext(istuesday, Date(2014,7,13)) # 2014-07-13 is a Sunday\n2014-07-15\n\njulia> Dates.tonext(Date(2014,7,13), Dates.Tuesday) # Convenience method provided for day of the week adjustments\n2014-07-15\n```\n\n----------------------------------------\n\nTITLE: Setting JULIA_NUM_THREADS Environment Variable - PowerShell\nDESCRIPTION: Demonstrates configuration of Julia thread count in PowerShell by setting $env:JULIA_NUM_THREADS prior to starting Julia. No dependencies beyond PowerShell and installed Julia. The variable must be set in the session before launching Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\n$env:JULIA_NUM_THREADS=4\n```\n\n----------------------------------------\n\nTITLE: Argument Completion with Unclosed Parentheses During Help Lookup - Julia-REPL\nDESCRIPTION: Shows that omitting the closing parenthesis during a lookup extends the tab completion results to all matching functions that may accept additional arguments, across modules. Illustrates completion of various function signatures within the `Mmap` module when querying signatures involving a file argument.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_25\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> using Mmap\n\nhelp?> Mmap.?(\"file\",[TAB]\nMmap.Anonymous(name::String, readonly::Bool, create::Bool) in Mmap at Mmap/src/Mmap.jl:16\nmmap(file::AbstractString) in Mmap at Mmap/src/Mmap.jl:245\nmmap(file::AbstractString, ::Type{T}) where T<:Array in Mmap at Mmap/src/Mmap.jl:245\nmmap(file::AbstractString, ::Type{T}, dims::Tuple{Vararg{Integer, N}}) where {T<:Array, N} in Mmap at Mmap/src/Mmap.jl:245\nmmap(file::AbstractString, ::Type{T}, dims::Tuple{Vararg{Integer, N}}, offset::Integer; grow, shared) where {T<:Array, N} in Mmap at Mmap/src/Mmap.jl:245\nmmap(file::AbstractString, ::Type{T}, len::Integer) where T<:Array in Mmap at Mmap/src/Mmap.jl:251\nmmap(file::AbstractString, ::Type{T}, len::Integer, offset::Integer; grow, shared) where T<:Array in Mmap at Mmap/src/Mmap.jl:251\nmmap(file::AbstractString, ::Type{T}, dims::Tuple{Vararg{Integer, N}}) where {T<:BitArray, N} in Mmap at Mmap/src/Mmap.jl:316\nmmap(file::AbstractString, ::Type{T}, dims::Tuple{Vararg{Integer, N}}, offset::Integer; grow, shared) where {T<:BitArray, N} in Mmap at Mmap/src/Mmap.jl:316\nmmap(file::AbstractString, ::Type{T}, len::Integer) where T<:BitArray in Mmap at Mmap/src/Mmap.jl:322\nmmap(file::AbstractString, ::Type{T}, len::Integer, offset::Integer; grow, shared) where T<:BitArray in Mmap at Mmap/src/Mmap.jl:322\n```\n\n----------------------------------------\n\nTITLE: Creating Hard Links in Julia\nDESCRIPTION: Introduces the `hardlink(src, dst)` function in Julia. This function creates a new directory entry (hard link) named `dst` that points to the same file inode as the existing file specified by `src`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_38\n\nLANGUAGE: julia\nCODE:\n```\nhardlink(src, dst)\n```\n\n----------------------------------------\n\nTITLE: Manually Overriding Compiler Effect Analysis in Julia\nDESCRIPTION: Introduces the `Base.@assume_effects` macro. This macro allows developers to manually inform the Julia compiler about the side-effect properties (e.g., side-effect-free, nothrow) of a code block or function call, potentially overriding the compiler's own inference and influencing optimizations.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\nBase.@assume_effects\n```\n\n----------------------------------------\n\nTITLE: Checking if All Iterator Elements Are Equal in Julia\nDESCRIPTION: Introduces the `allequal(itr)` function in Julia. It takes an iterator `itr` and returns `true` if all elements produced by the iterator are equal to each other (using `isequal`), and `false` otherwise. It may short-circuit evaluation.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_37\n\nLANGUAGE: julia\nCODE:\n```\nallequal(itr)\n```\n\n----------------------------------------\n\nTITLE: `clamp` Function Handling Missing Values in Julia\nDESCRIPTION: The `clamp(x, lo, hi)` function can now handle `missing` values gracefully, typically propagating the `missing`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_123\n\nLANGUAGE: julia\nCODE:\n```\nclamp(missing, 0, 1) # Returns missing\nclamp([1, missing, 3], 0, 2) # Returns [1, missing, 2]\n```\n\n----------------------------------------\n\nTITLE: Attaching Debugger to Precompilation Worker (LLDB Command)\nDESCRIPTION: Same as the GDB version but for LLDB, attaches to any new process named 'julia-debug' spawned for Julia module precompilation. Required to catch errors or breakpoints during precompilation in subprocesses.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_16\n\nLANGUAGE: lldb\nCODE:\n```\n(lldb) process attach -w -n julia-debug\n```\n\n----------------------------------------\n\nTITLE: Controlling Function Inlining (Julia Flag)\nDESCRIPTION: The `--inline` command-line flag influences the compiler's function inlining decisions. Package image caches require an exact match for this flag setting to be considered valid due to its impact on code generation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n--inline\n```\n\n----------------------------------------\n\nTITLE: Exported `nonmissingtype` function in Julia\nDESCRIPTION: The `nonmissingtype(T)` function, which returns a type `T` without `Missing` if `T` is a `Union` containing `Missing`, is now exported for easier use.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_115\n\nLANGUAGE: julia\nCODE:\n```\nnonmissingtype(Union{Int, Missing}) # Returns Int\n```\n\n----------------------------------------\n\nTITLE: Enabling Numbered Prompt Mode in Julia REPL\nDESCRIPTION: Activates a REPL mode where input and output prompts are numbered sequentially. Evaluated results are stored in the `Out` variable for later reference.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nREPL.numbered_prompt!()\n```\n\n----------------------------------------\n\nTITLE: Throwing General Julia Exceptions from C\nDESCRIPTION: This snippet shows the C function signatures for raising general Julia exceptions from C code. `jl_error` takes a constant C string message, while `jl_errorf` allows for `printf`-style formatted error messages.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_34\n\nLANGUAGE: c\nCODE:\n```\nvoid jl_error(const char *str);\nvoid jl_errorf(const char *fmt, ...);\n```\n\n----------------------------------------\n\nTITLE: Controlling Scalar Indexing in Julia SparseArrays\nDESCRIPTION: Allows enabling or disabling scalar indexing for sparse arrays (like `SparseMatrixCSC`). Disabling it helps identify potential performance bottlenecks caused by accidental scalar access.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nSparseArrays.allowscalar(::Bool)\n```\n\n----------------------------------------\n\nTITLE: New `count(itr)` Method in Julia\nDESCRIPTION: Introduces a new single-argument method for the `count` function in Julia. `count(itr)` is now equivalent to calling `count(identity, itr)`, simplifying the counting of elements in an iterable.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_167\n\nLANGUAGE: julia\nCODE:\n```\ncount(itr)\n```\n\nLANGUAGE: julia\nCODE:\n```\ncount(identity, itr)\n```\n\n----------------------------------------\n\nTITLE: Deprecation of Single-Argument `write(x)`: Use `write(STDOUT, x)` in Julia\nDESCRIPTION: The single-argument form `write(x)`, which implicitly writes to `STDOUT`, is deprecated in Julia. Use the explicit two-argument form `write(STDOUT, x)` instead.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_186\n\nLANGUAGE: julia\nCODE:\n```\nwrite(STDOUT, x)\n```\n\n----------------------------------------\n\nTITLE: Setting Julia CPU Target for Raspberry Pi 2 in Makefile\nDESCRIPTION: Specifies the CPU target `cortex-a7` in the `Make.user` file for building Julia on a Raspberry Pi 2. This is needed because the LLVM build system may not automatically detect this specific ARM CPU type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/arm.md#_snippet_3\n\nLANGUAGE: Makefile\nCODE:\n```\nJULIA_CPU_TARGET=cortex-a7\n```\n\n----------------------------------------\n\nTITLE: Copying Between AbstractVectors Without Indexing Assumptions - Julia\nDESCRIPTION: This function, 'mycopy!', copies elements from 'src' to 'dest', both of which are AbstractVectors, while assuming conventional 1-based indexing. It uses a for-loop from 1 to length(src) and @inbounds for performance, but can cause errors or segfaults if either vector uses non-1-based indices. Dependencies: Julia Base. Parameters: 'dest' and 'src' must be AbstractVectors. Returns 'dest'. Strictly requires both vectors to use identical lengths and 1-based indices; input arrays with unconventional indexing can cause undefined behavior.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/offset-arrays.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nfunction mycopy!(dest::AbstractVector, src::AbstractVector)\n    length(dest) == length(src) || throw(DimensionMismatch(\"vectors must match\"))\n    # OK, now we're safe to use @inbounds, right? (not anymore!)\n    for i = 1:length(src)\n        @inbounds dest[i] = src[i]\n    end\n    dest\nend\n```\n\n----------------------------------------\n\nTITLE: Documenting Built-in Logger Types (Julia Docs)\nDESCRIPTION: A directive for Julia's documentation generator (Documenter.jl) to include documentation for the standard logger types provided with Julia's Logging system (NullLogger, ConsoleLogger, SimpleLogger).\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Logging/docs/src/index.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nLogging.NullLogger\nLogging.ConsoleLogger\nLogging.SimpleLogger\n```\n\n----------------------------------------\n\nTITLE: Redefining Methods and Observing Task/World Age Effects in Julia\nDESCRIPTION: Shows stepwise redefinition of the function 'f', including both general and type-specific methods, and examines how method visibility and dispatch vary across the main session, helper functions, and async tasks due to world age. Demonstrates effects of adding methods and differences between direct invocation, function wrappers, and scheduled asynchronous computation. Relies on Julia's Tasks, scheduling, and method redefinition mechanisms; input is typically an integer, output is a string indicating which method is active in the given world age.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nf(x) = \"original definition\"\n```\n\nLANGUAGE: julia\nCODE:\n```\ng(x) = f(x)\nt = @async f(wait()); yield();\n```\n\nLANGUAGE: julia\nCODE:\n```\nf(x::Int) = \"definition for Int\"\nf(x::Type{Int}) = \"definition for Type{Int}\"\n```\n\nLANGUAGE: julia\nCODE:\n```\nf(1)\ng(1)\nfetch(schedule(t, 1))\nt = @async f(wait()); yield();\nfetch(schedule(t, 1))\n```\n\n----------------------------------------\n\nTITLE: Correct Exception Handling for `open` with Command in Julia\nDESCRIPTION: When `open` is called with a function, a command (`Cmd`), and keyword arguments (e.g., ```open(`ls`, read=true) do f ...```), it now correctly throws a `ProcessFailedException` if the command fails, consistent with other similar calls.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_127\n\nLANGUAGE: julia\nCODE:\n```\ntry\n    open(`command_that_fails`, read=true) do io\n        # ...\n    end\ncatch e\n    # e is now ProcessFailedException\nend\n```\n\n----------------------------------------\n\nTITLE: Linking System Library on macOS (Linker Flag)\nDESCRIPTION: The `-lSystem` flag is typically required when linking dynamic libraries on macOS to link against the core system library. Availability might depend on Xcode installation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n-lSystem\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `unsafe_wrap(String, ...)`: Use `unsafe_string` in Julia\nDESCRIPTION: Using `unsafe_wrap` to create a `String` from a pointer is deprecated in Julia. Use the `unsafe_string` function instead.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_200\n\nLANGUAGE: julia\nCODE:\n```\nunsafe_string\n```\n\n----------------------------------------\n\nTITLE: Building Julia Documentation with Make (Shell)\nDESCRIPTION: Demonstrates how to build the Julia documentation from the root directory using the \\\"make docs\\\" command. This command leverages the Makefile included with the repository to generate HTML documentation, which is output to the \\\"doc/_build/\\\" folder. Requires GNU Make and all Julia documentation dependencies installed; dependencies are managed in a sandboxed \\\"doc/deps/\\\" directory. No parameters beyond the \\\"docs\\\" target are required.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ make docs\n```\n\n----------------------------------------\n\nTITLE: Getting Disk Statistics in Julia\nDESCRIPTION: Introduces the `diskstat(path=pwd())` function in Julia. It queries the operating system for statistics about the disk that contains the file or directory specified by `path`. If no path is provided, it defaults to the current working directory (`pwd()`).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_40\n\nLANGUAGE: julia\nCODE:\n```\ndiskstat(path=pwd())\n```\n\n----------------------------------------\n\nTITLE: Performing Type Set Operations with Julia's Type System - Julia\nDESCRIPTION: This snippet demonstrates Julia's set-theoretic type operations, such as intersection, union, and join, using built-in functions and type constructors. It shows how to use `typeintersect`, `Union`, and `typejoin` with both simple and compound types, enabling developers to understand relations between types and their use in method dispatch. Input consists of type objects, and the output is the resulting type after the operation. Requires Julia's base language and REPL; no additional dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> typeintersect(Int, Float64)\nUnion{}\n\njulia> Union{Int, Float64}\nUnion{Float64, Int64}\n\njulia> typejoin(Int, Float64)\nReal\n\njulia> typeintersect(Signed, Union{UInt8, Int8})\nInt8\n\njulia> Union{Signed, Union{UInt8, Int8}}\nUnion{UInt8, Signed}\n\njulia> typejoin(Signed, Union{UInt8, Int8})\nInteger\n\njulia> typeintersect(Tuple{Integer, Float64}, Tuple{Int, Real})\nTuple{Int64, Float64}\n\njulia> Union{Tuple{Integer, Float64}, Tuple{Int, Real}}\nUnion{Tuple{Int64, Real}, Tuple{Integer, Float64}}\n\njulia> typejoin(Tuple{Integer, Float64}, Tuple{Int, Real})\nTuple{Integer, Real}\n```\n\n----------------------------------------\n\nTITLE: Indexing Arrays in Julia\nDESCRIPTION: Julia uses square brackets `[]` for array indexing, similar to many programming languages, but different from MATLAB's parentheses.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nA[i,j]\n```\n\n----------------------------------------\n\nTITLE: Resolving NTuple Ambiguity using Empty Tuple Method in Julia\nDESCRIPTION: Provides one strategy to resolve the `NTuple` ambiguity caused by the `N == 0` case. A specific method `f(x::Tuple{})` is defined to handle the empty tuple explicitly, removing the ambiguity for that case.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_41\n\nLANGUAGE: julia\nCODE:\n```\nf(x::Tuple{}) = 3\n```\n\n----------------------------------------\n\nTITLE: Invoking Julia Macros with Different Syntaxes\nDESCRIPTION: Shows the two primary syntax forms for invoking Julia macros. The first uses space-separated expressions after the macro name prefixed with '@'. The second uses comma-separated expressions within parentheses immediately following the macro name.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_30\n\nLANGUAGE: julia\nCODE:\n```\n@name expr1 expr2 ...\n@name(expr1, expr2, ...)\n```\n\n----------------------------------------\n\nTITLE: Standard Generalized Dot Product Calculation in Julia\nDESCRIPTION: Shows the standard way to compute a generalized dot product `dot(x, A*y)` in Julia, which involves explicitly calculating the intermediate product `A*y` before computing the dot product with `x`. The 3-argument `dot(x, A, y)` method avoids this intermediate step.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_95\n\nLANGUAGE: julia\nCODE:\n```\ndot(x, A*y)\n```\n\n----------------------------------------\n\nTITLE: Using `using` within a Dedicated Module Scope in Julia\nDESCRIPTION: Shows an alternative method for using module members within a function: define a new module (`Bar`), use `using Foo` inside `Bar` to bring `Foo`'s names into `Bar`'s scope, and define the function (`bar`) within `Bar`. This allows `bar` to access `Foo`'s members without qualification (e.g., `baz`). The function `bar` is then accessed via its parent module (`using Bar`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nmodule Bar\nexport bar\nusing Foo\nfunction bar(...)\n    # ... refer to Foo.baz as simply baz ....\nend\nend\nusing Bar\n```\n\n----------------------------------------\n\nTITLE: Compiling C Embedding Code using julia-config.jl\nDESCRIPTION: Demonstrates using the `julia-config.jl` script (assumed to be in `/usr/local/julia/share/julia`) to automatically obtain the necessary compiler and linker flags (`--cflags`, `--ldflags`, `--ldlibs`) for building a C application (`embed_example.c`) that embeds Julia. The output flags are passed to the compiler (`gcc`) using `xargs`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n/usr/local/julia/share/julia/julia-config.jl --cflags --ldflags --ldlibs | xargs gcc embed_example.c\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Struct MyNumber in Julia\nDESCRIPTION: Defines a simple struct named `MyNumber` which encapsulates a single `Float64` field called `x`. This struct serves as a target type for demonstrating dynamic code generation techniques in subsequent examples.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_49\n\nLANGUAGE: jldoctest\nCODE:\n```\nstruct MyNumber\n    x::Float64\nend\n# output\n```\n\n----------------------------------------\n\nTITLE: Initializing and Inspecting Characters in Julia\nDESCRIPTION: Demonstrates defining a character value, displaying its Unicode properties, and querying its type in Julia. No external dependencies required beyond Julia's base language. Inputs include a direct character assignment; outputs show both the value and type information.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> c = 'x'\n'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)\n\njulia> typeof(c)\nChar\n```\n\n----------------------------------------\n\nTITLE: Consistency Checks for `sparse` Constructor in Julia\nDESCRIPTION: The `sparse(I, J, V, m, n)` function now verifies that the lengths of index arrays `I`, `J`, and value array `V` are equal and that these lengths are compatible with the specified dimensions `m`, `n` and the element type of `I`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_138\n\nLANGUAGE: julia\nCODE:\n```\nusing SparseArrays\n# Example: Constructor now validates inputs\n# sparse(I, J, V, m, n)\n```\n\n----------------------------------------\n\nTITLE: Defining Types with Unsafe Pointers - Unsafe API Exposure - Julia - julia\nDESCRIPTION: Shows how to define a mutable Julia struct with a raw pointer field (Ptr{UInt8}), exemplifying a situation where exposing unsafe operations is discouraged. This pattern can lead to accidental misuse if not protected or clearly named, and does not check memory safety. No extra dependencies are needed, but such APIs should be carefully designed to avoid introducing security or stability hazards.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/style-guide.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nmutable struct NativeType\n    p::Ptr{UInt8}\n    ...\nend\n\n```\n\n----------------------------------------\n\nTITLE: Efficient Shifted Solves and Determinants for Hessenberg Factorizations in Julia\nDESCRIPTION: `Hessenberg` factorizations (`H`) now support efficient computation of shifted solves `(H + µI) \\ b` and determinants. Hermitian matrices use a specialized tridiagonal factorization.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_133\n\nLANGUAGE: julia\nCODE:\n```\nusing LinearAlgebra\nA = randn(5,5)\nH = hessenberg(A)\nmu = 0.5\nb = randn(5)\nx = (H + mu*I) \\ b # Efficient shifted solve\n```\n\n----------------------------------------\n\nTITLE: Configuring REPL IOContext Options at Startup in Julia\nDESCRIPTION: This snippet shows how to customize the REPL's display behavior automatically upon startup. By adding this code to the `~/.julia/config/startup.jl` file, the `atreplinit` function registers a callback that modifies the active REPL's `iocontext` options (here, setting `:compact` to `false`) every time a REPL session starts.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\natreplinit() do repl\n    repl.options.iocontext[:compact] = false\nend\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Error and Exception Handling Mechanisms\nDESCRIPTION: This block employs the `@docs` directive to list functions, types, and macros related to error handling and exceptions in Julia. This includes functions for throwing errors (`error`, `throw`, `rethrow`), obtaining backtraces (`backtrace`, `catch_backtrace`), inspecting current exceptions, asserting conditions (`@assert`), registering error hints, various standard exception types (e.g., `ArgumentError`, `BoundsError`, `MethodError`, `TypeError`), and retry logic (`retry`, `ExponentialBackOff`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.error\nCore.throw\nBase.rethrow\nBase.backtrace\nBase.catch_backtrace\nBase.current_exceptions\nBase.@assert\nBase.Experimental.register_error_hint\nBase.Experimental.show_error_hints\nBase.ArgumentError\nBase.AssertionError\nCore.BoundsError\nBase.CompositeException\nBase.DimensionMismatch\nCore.DivideError\nCore.DomainError\nBase.EOFError\nCore.ErrorException\nCore.FieldError\nCore.InexactError\nCore.InterruptException\nBase.KeyError\nBase.LoadError\nBase.MethodError\nBase.MissingException\nCore.OutOfMemoryError\nCore.ReadOnlyMemoryError\nCore.OverflowError\nBase.ProcessFailedException\nBase.TaskFailedException\nCore.StackOverflowError\nBase.SystemError\nCore.TypeError\nCore.UndefKeywordError\nCore.UndefRefError\nCore.UndefVarError\nBase.StringIndexError\nBase.InitError\nBase.retry\nBase.ExponentialBackOff\n```\n```\n\n----------------------------------------\n\nTITLE: Defining the Dependency Graph for a Julia Package Directory\nDESCRIPTION: Julia code defining a `Dict` named `graph` representing the dependency relationships between packages in the example directory. Keys are the UUIDs of packages that have a Project.toml file (Bobcat, Cobra, Dingo). Values are dictionaries mapping dependency names (Symbols) to their respective UUIDs, as specified in the `[deps]` section of each package's Project.toml file. Packages without a Project.toml (Aardvark) are omitted.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\ngraph = Dict(\\n    # Bobcat:\\n    UUID(\\\"85ad11c7-31f6-5d08-84db-0a4914d4cadf\\\") => Dict(\\n        :Cobra => UUID(\\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\"),\\n        :Dingo => UUID(\\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"),\\n    ),\\n    # Cobra:\\n    UUID(\\\"4725e24d-f727-424b-bca0-c4307a3456fa\\\") => Dict(\\n        :Dingo => UUID(\\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\"),\\n    ),\\n    # Dingo:\\n    UUID(\\\"7a7925be-828c-4418-bbeb-bac8dfc843bc\\\") => Dict(),\\n)\n```\n\n----------------------------------------\n\nTITLE: Validating Unicode Code Points in Julia\nDESCRIPTION: Demonstrates how to manually construct a `Char` value from an integer beyond the valid Unicode range and how to use `isvalid(Char, x)` to check validity. Output includes representation of invalid character and boolean validity check. This does not throw on invalid code points except when explicitly checked.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> Char(0x110000)\n'\\U110000': Unicode U+110000 (category In: Invalid, too high)\n\njulia> isvalid(Char, 0x110000)\nfalse\n```\n\n----------------------------------------\n\nTITLE: Documenting Dictionary Types and Functions in Julia\nDESCRIPTION: A documentation system directive (`@docs`) specifying various dictionary (associative map) types and related functions in Julia's Base library. Includes standard `Dict`, specialized dictionaries like `IdDict` and `WeakKeyDict`, immutable versions, and functions for key checking (`haskey`), value retrieval (`get`), deletion (`delete!`, `pop!`), merging (`merge`), and introspection (`keys`, `values`, `pairs`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.AbstractDict\nBase.Dict\nBase.IdDict\nBase.WeakKeyDict\nBase.ImmutableDict\nBase.PersistentDict\nBase.haskey\nBase.get\nBase.get!\nBase.getkey\nBase.delete!\nBase.pop!(::Any, ::Any, ::Any)\nBase.keys\nBase.values\nBase.pairs\nBase.merge\nBase.mergewith\nBase.merge!\nBase.mergewith!\nBase.sizehint!\nBase.keytype\nBase.valtype\n```\n\n----------------------------------------\n\nTITLE: Listing Text I/O Functions/Types in Julia Base\nDESCRIPTION: This snippet utilizes the `@docs` macro to enumerate functions from Julia's Base module specifically designed for text input/output. This includes functions for displaying objects (`show`, `summary`, `print`, `println`, `printstyled`), capturing output (`sprint`), error display (`showerror`, `dump`), and reading textual data (`readline`, `readuntil`, `readlines`, `eachline`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/io-network.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.show(::IO, ::Any)\nBase.summary\nBase.print\nBase.println\nBase.printstyled\nBase.sprint\nBase.showerror\nBase.dump\nMeta.@dump\nBase.readline\nBase.readuntil\nBase.readlines\nBase.eachline\nBase.copyline\nBase.copyuntil\nBase.displaysize\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Environment Variables to `Cmd` Objects with `addenv` in Julia\nDESCRIPTION: The `addenv` function takes a `Cmd` object and a dictionary or pairs of environment variable mappings. It returns a new `Cmd` object with the specified environment variables added to its execution environment.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_68\n\nLANGUAGE: julia\nCODE:\n```\nbase_cmd = `my_program`\nenv_mapping = Dict(\"MY_VAR\" => \"value\", \"ANOTHER_VAR\" => \"data\")\ncmd_with_env = addenv(base_cmd, env_mapping)\n# Or using pairs:\ncmd_with_env2 = addenv(base_cmd, \"MY_VAR\" => \"value\", \"ANOTHER_VAR\" => \"data\")\n\nrun(cmd_with_env)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Disallowed Conversion of Heterogeneous Tuple to NTuple in Julia\nDESCRIPTION: Shows an example of converting an arbitrary, heterogeneous tuple `(1, \"\")` to `NTuple` in Julia. This conversion is now disallowed and results in an error because `NTuple` strictly refers to homogeneous tuples (tuples where all elements have the same type).\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_80\n\nLANGUAGE: julia\nCODE:\n```\nconvert(NTuple, (1, \"\"))\n```\n\n----------------------------------------\n\nTITLE: Entering and Using REPL Shell Mode in Julia\nDESCRIPTION: This example shows how to enter the REPL's Shell mode by typing a semicolon `;` at the beginning of an empty line in the Julian prompt. In Shell mode (`shell>`), system commands like `echo hello` can be executed directly.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\njulia> ; # upon typing ;, the prompt changes (in place) to: shell>\n\nshell> echo hello\nhello\n```\n\n----------------------------------------\n\nTITLE: Adding Methods to Abstract Types in Julia\nDESCRIPTION: Julia v1.3 allows adding methods directly to abstract types, providing more flexibility in defining behavior for type hierarchies.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_102\n\n\n\n----------------------------------------\n\nTITLE: Thread-Safe Global Random Number Generator in Julia\nDESCRIPTION: The global random number generator (`GLOBAL_RNG`) is now thread-safe and thread-local, ensuring safe random number generation in multi-threaded contexts.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_106\n\nLANGUAGE: julia\nCODE:\n```\nGLOBAL_RNG\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Bold Syntax in Markdown\nDESCRIPTION: This snippet shows how to render text in boldface using Markdown by enclosing it with double asterisks (`**`). It is typically used within a paragraph.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nA paragraph containing a **bold** word.\n```\n\n----------------------------------------\n\nTITLE: Scalar Broadcasting Behavior for Pair in Julia\nDESCRIPTION: The `Pair` type is now treated as a scalar in broadcasting operations.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_122\n\nLANGUAGE: julia\nCODE:\n```\np = 1 => \"a\"\ndata = [10, 20]\n(x -> x + p.first).(data) # Broadcasts using p as a scalar\n```\n\n----------------------------------------\n\nTITLE: Documenting Basic Array Functions via JuliaDoc Macros - Julia\nDESCRIPTION: Uses the JuliaDoc `@docs` macro to generate documentation for fundamental array interface methods and utility functions. Functions covered include array dimension queries (`ndims`, `size`, `axes`), various index handlers, and miscellaneous array operations. Input and output are not applicable (doc build only), and the block presumes the presence of Julia's documentation tooling and relevant base/core modules.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/arrays.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.ndims\nBase.size\nBase.axes(::Any)\nBase.axes(::AbstractArray, ::Any)\nBase.length(::AbstractArray)\nBase.keys(::AbstractArray)\nBase.eachindex\nBase.IndexStyle\nBase.IndexLinear\nBase.IndexCartesian\nBase.conj!\nBase.stride\nBase.strides\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Literal Syntax in Markdown\nDESCRIPTION: This snippet demonstrates using single backticks (``` ` ```) in Markdown to display text exactly as written, often used for variable names or code snippets inline.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nA paragraph containing a `literal` word.\n```\n\n----------------------------------------\n\nTITLE: Using Triple Backticks for Literals Containing Backticks in Markdown\nDESCRIPTION: This snippet shows how to include literal backtick characters within a literal block by using triple backticks (```` ``` ````) as delimiters. Any odd number of backticks can enclose a lesser number.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\nA paragraph containing ``` `backtick` characters ```.\n```\n\n----------------------------------------\n\nTITLE: Observing Runtime Execution After Macro Expansion in Julia\nDESCRIPTION: Evaluates the expression `ex` (generated by expanding the `@twostep` macro) using `eval`. This triggers the execution of the `println` statement contained within the generated expression, demonstrating the runtime action.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_29\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> eval(ex)\nI execute at runtime. The argument is: (1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Using Unicode Variable Names - Julia Doctest - Julia\nDESCRIPTION: This snippet demonstrates variable assignment using Unicode characters, including Latin and Hangul characters as variable names. It emphasizes Julia's ability to use Unicode for greater expressiveness. No special dependencies are needed. Inputs are numeric and string literals; outputs show the values bound to these Unicode-named variables.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/variables.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> δ = 0.00001\\n1.0e-5\\n\\njulia> 안녕하세요 = \\\"Hello\\\"\\n\\\"Hello\\\"\n```\n\n----------------------------------------\n\nTITLE: Documenting Integer Utility Functions and Macros - Julia - Julia\nDESCRIPTION: Documents integer-specific utility functions and macros using a Julia @docs block, such as those for inspecting and manipulating bit patterns, parity checking, and large integer literals. Intended for consolidated display in Julia's autogenerated documentation, each referenced function or macro must be present in Base or Core. Not intended for direct execution but to structure reference documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/numbers.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nBase.count_ones\\nBase.count_zeros\\nBase.leading_zeros\\nBase.leading_ones\\nBase.trailing_zeros\\nBase.trailing_ones\\nBase.isodd\\nBase.iseven\\nBase.@int128_str\\nBase.@uint128_str\\n```\n```\n\n----------------------------------------\n\nTITLE: Clarifying Signature Disambiguation with Multiple Type Variables - Julia\nDESCRIPTION: Presents an alternative method definition with independent type variables for additional arguments, allowing explicit control over whether x and y must match types. Dependencies: Julia language. Inputs: a::Array{T}, x::S, y::S; Outputs: customizable depending on body. Useful for complex dispatch involving both element and argument type relationships.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\nf(a::Array{T}, x::S, y::S) where {T, S<:T} = ...\n```\n\n----------------------------------------\n\nTITLE: Documenting Core Date Conversion Functions in Julia (Julia)\nDESCRIPTION: This @docs section covers key conversion functions for moving between various time representations, such as Dates.today (current date), unix2datetime, datetime2unix, julian2datetime, datetime2julian, rata2datetime, and datetime2rata. Dependencies: Dates module. Most functions accept integers or date/time types as input, returning the appropriate converted date/time or numeric representation. Useful for interoperability and data exchange. Inputs and outputs are strongly typed and constrained to handled formats.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\nDates.today\nDates.unix2datetime\nDates.datetime2unix\nDates.julian2datetime\nDates.datetime2julian\nDates.rata2datetime\nDates.datetime2rata\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Multi-Dimensional Arrays in Julia\nDESCRIPTION: Shows the syntax `[;;;]` for creating an empty 3-dimensional `Array{Any, 3}` (specifically, a 0x0x0 array) in Julia. This syntax uses multiple semicolons inside square brackets to define the dimensionality of the empty array.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_22\n\nLANGUAGE: julia\nCODE:\n```\n[;;;]\n```\n\n----------------------------------------\n\nTITLE: Documenting Exported StackTraces Items in Julia\nDESCRIPTION: This snippet uses the Julia `@docs` macro within a documentation file (like Markdown processed by Documenter.jl) to automatically generate documentation for the exported `StackFrame` type, `StackTrace` type, and `stacktrace` function from the `Base.StackTraces` module. It relies on the Julia documentation system to find and insert the docstrings associated with these items.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/stacktraces.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.StackTraces.StackFrame\nBase.StackTraces.StackTrace\nBase.StackTraces.stacktrace\n```\n\n----------------------------------------\n\nTITLE: Specializing 'axes' for a Custom Array Type with Zero-Based Indices - Julia\nDESCRIPTION: This code specialization makes the 'axes' method return a sequence of ZeroRange objects for each dimension of a custom ZeroArray, enabling zero-based indexing. It assumes the existence of a ZeroRange type (a custom AbstractUnitRange) and a 'size' field in ZeroArray, mapping each dimension's size to a corresponding ZeroRange. Dependencies: a proper definition of ZeroRange and a ZeroArray type with a size field. Returns a tuple of ZeroRanges indicating valid indices for each dimension. Use this in custom AbstractArray subtype implementations needing non-standard (e.g., zero-based) indices.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/offset-arrays.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nBase.axes(A::ZeroArray) = map(n->ZeroRange(n), A.size)\n```\n\n----------------------------------------\n\nTITLE: Representing the Roots Map of a Julia Project in Julia Code\nDESCRIPTION: This Julia code snippet converts the contents of a Project.toml file into a roots map as a Julia dictionary, mapping package names (symbols) to their UUIDs. This is used by the Julia package loader to resolve which package implementation each name refers to in the context of the current environment. The expected input is the set of name-UUID pairs, with output being a dictionary for subsequent dependency lookup. Requires the 'UUID' struct from Julia's standard library.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/code-loading.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nroots = Dict(\n    :App  => UUID(\"8f986787-14fe-4607-ba5d-fbff2944afa9\"),\n    :Priv => UUID(\"ba13f791-ae1d-465a-978b-69c3ad90f72b\"),\n    :Pub  => UUID(\"c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1\"),\n)\n```\n\n----------------------------------------\n\nTITLE: Listing Multimedia Display Stack Functions in Julia Base\nDESCRIPTION: This snippet uses the `@docs` macro to list functions from Julia's Base.Multimedia module related to managing the stack of display backends. It includes functions for adding (`pushdisplay`) and removing (`popdisplay`) displays from the stack, the default `TextDisplay`, and a utility to check if a MIME type is text-based (`istextmime`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/io-network.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.Multimedia.pushdisplay\nBase.Multimedia.popdisplay\nBase.Multimedia.TextDisplay\nBase.Multimedia.istextmime\n```\n```\n\n----------------------------------------\n\nTITLE: Listing Advanced Atomic Operation Macros and Types - Julia\nDESCRIPTION: This code snippet references advanced macros and types related to atomic operations, preparing them for documentation generation. It includes documentation blocks for Base.@atomic, Base.@atomicswap, Base.@atomicreplace, Base.@atomiconce, and the Base.AtomicMemory type. These enable safe, low-level thread synchronization primitives, and this listing allows users to access generated documentation for each.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/multi-threading.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nBase.@atomic\\nBase.@atomicswap\\nBase.@atomicreplace\\nBase.@atomiconce\\nBase.AtomicMemory\\n```\n```\n\n----------------------------------------\n\nTITLE: Printing TOML with Custom Key Sorting in Julia\nDESCRIPTION: Illustrates how to use the `sorted=true` and `by` keyword arguments with `TOML.print` to control the order of keys in the output. This example sorts the keys of a dictionary based on their string length before printing.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/TOML/docs/src/index.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> using TOML\n\njulia> TOML.print(Dict(\n       \"abc\"  => 1,\n       \"ab\"   => 2,\n       \"abcd\" => 3,\n       ); sorted=true, by=length)\nab = 2\nabc = 1\nabcd = 3\n```\n\n----------------------------------------\n\nTITLE: Violating Hygiene with esc() to Modify Caller Variables in Julia\nDESCRIPTION: Demonstrates how `esc()` can be used to intentionally bypass hygiene rules and manipulate variables in the macro caller's environment. The `@zerox` macro returns `esc(:(x = 0))`, causing the assignment `x = 0` to occur in the scope where `@zerox` is called, as shown by its effect within the `foo` function. This technique should be used cautiously.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_45\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> macro zerox()\n           return esc(:(x = 0))\n       end\n@zerox (macro with 1 method)\n\njulia> function foo()\n           x = 1\n           @zerox\n           return x # is zero\n       end\nfoo (generic function with 1 method)\n\njulia> foo()\n0\n```\n\n----------------------------------------\n\nTITLE: Evaluating Julia Code that Throws an Exception in C\nDESCRIPTION: This C code snippet shows an example of executing Julia code from C using `jl_eval_string` that is expected to fail because the specified Julia function does not exist. This call itself doesn't handle the exception but demonstrates a scenario where an exception would occur, requiring subsequent checks.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_31\n\nLANGUAGE: c\nCODE:\n```\njl_eval_string(\"this_function_does_not_exist()\");\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Operations on Regex Objects in Julia\nDESCRIPTION: `Regex` objects can now be multiplied (`*`) and exponentiated (`^`), similar to strings, allowing for pattern repetition.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_118\n\nLANGUAGE: julia\nCODE:\n```\nr = r\"ab\"\nr * 3 # Equivalent to r\"ababab\"\nr^3   # Equivalent to r\"(ab){3}\"\n```\n\n----------------------------------------\n\nTITLE: Initializing RowVectors with Undef Argument - Julia\nDESCRIPTION: Shows the modern syntax for constructing uninitialized RowVectors in Julia, which now require 'undef' as the first argument. Requires Julia Base and the appropriate type. Shape and type are essential parameters; output is an uninitialized RowVector.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_150\n\nLANGUAGE: julia\nCODE:\n```\nRowVector{Int}(undef, 3)\nRowVector{Float32}(undef, (1, 4))\n```\n\n----------------------------------------\n\nTITLE: Documenting Set Types and Functions in Julia\nDESCRIPTION: A documentation system directive (`@docs`) listing set types (`Set`, `BitSet`, `IdSet`) and standard set operations available in Julia. Includes functions for union, intersection, difference, symmetric difference, subset checks, and membership testing.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.AbstractSet\nBase.Set\nBase.BitSet\nBase.IdSet\nBase.union\nBase.union!\nBase.intersect\nBase.setdiff\nBase.setdiff!\nBase.symdiff\nBase.symdiff!\nBase.intersect!\nBase.issubset\nBase.in!\nBase.:⊈\nBase.:⊊\nBase.issetequal\nBase.isdisjoint\n```\n\n----------------------------------------\n\nTITLE: Specializations of 'similar' for Custom Zero-Indexed Arrays - Julia\nDESCRIPTION: These function specializations for 'Base.similar' are templates intended for custom AbstractArray subtypes using ZeroRange axes (for zero-based indexing). The first is for creating an array like 'A' with element type 'T'; the second for creation via a storage type or function. Both must allocate a proper custom array type with ZeroRange-derived indices. The method body should construct and return the correct custom array instance matching the provided shape. Override as needed in custom array packages to ensure correct storage and shape allocation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/offset-arrays.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nfunction Base.similar(A::AbstractArray, T::Type, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\n    # body\nend\n\nfunction Base.similar(f::Union{Function,DataType}, shape::Tuple{ZeroRange,Vararg{ZeroRange}})\n    # body\nend\n```\n\n----------------------------------------\n\nTITLE: Documenting Iteration Interface Functions in Julia\nDESCRIPTION: A documentation system directive (`@docs`) used to automatically include the documentation strings for key functions defining Julia's iteration interface: `Base.iterate`, `Base.IteratorSize`, and `Base.IteratorEltype`. This is specific to Julia's documentation generator.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/collections.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nBase.iterate\nBase.IteratorSize\nBase.IteratorEltype\n```\n\n----------------------------------------\n\nTITLE: Showing Saturating Integer Arithmetic in Matlab - Matlab\nDESCRIPTION: This snippet illustrates Matlab's saturating arithmetic for int64 types, where results exceeding the max or min value are clamped rather than wrapped. It demonstrates both upward and downward saturation on edge values, providing a comparative baseline with Julia's machine-int behavior. No special dependencies are required; input and output are shown for each operation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_20\n\nLANGUAGE: matlab\nCODE:\n```\n>> int64(9223372036854775807)\n\nans =\n\n  9223372036854775807\n\n>> int64(9223372036854775807) + 1\n\nans =\n\n  9223372036854775807\n\n>> int64(-9223372036854775808)\n\nans =\n\n -9223372036854775808\n\n>> int64(-9223372036854775808) - 1\n\nans =\n\n -9223372036854775808\n```\n\n----------------------------------------\n\nTITLE: Using the `only` Function to Extract Single Element in Julia\nDESCRIPTION: Demonstrates the usage of the new `only(x)` function, which returns the sole element from a collection `x`. It throws an `ArgumentError` if the collection does not contain exactly one element.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_87\n\nLANGUAGE: julia\nCODE:\n```\nonly(x)\n```\n\n----------------------------------------\n\nTITLE: Specializing 'reshape' for Arrays with Zero-Based Indices - Julia\nDESCRIPTION: This shows the method signature for overloading 'Base.reshape' to support reshaping AbstractArrays to have custom ZeroRange-based indices (enabling, for example, zero-based multidimensional reshaping). This extension lets users convert an existing AbstractArray to a new shape where each dimension uses a ZeroRange. The implementation (ellipsis) should return a new array instance with the provided custom-shaped axes. Ensure shape is a tuple of ZeroRange objects. Used in packages extending the AbstractArray interface.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/offset-arrays.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nBase.reshape(A::AbstractArray, shape::Tuple{ZeroRange,Vararg{ZeroRange}}) = ...\n```\n\n----------------------------------------\n\nTITLE: Disabling REPL Tab Completion Hints in Julia Startup\nDESCRIPTION: Provides a code snippet intended for `startup.jl` to disable the REPL's tab completion hints introduced in Julia v1.11.0. It uses `atreplinit` to modify the active REPL's options, setting `hint_tab_completes` to `false`. This ensures the setting persists across REPL sessions. Requires Julia v1.11.0 or later.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nif VERSION >= v\"1.11.0-0\"\n  atreplinit() do repl\n      repl.options.hint_tab_completes = false\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Setting OpenBLAS Target Architecture (Makefile)\nDESCRIPTION: Sets the target CPU architecture for the OpenBLAS library build within Julia's build process, using the `OPENBLAS_TARGET_ARCH` variable in `Make.user`. Used as a possible solution to resolve OpenBLAS build failures on specific AMD (`BARCELONA`) or Intel (`NEHALEM`) CPUs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_6\n\nLANGUAGE: Makefile\nCODE:\n```\nOPENBLAS_TARGET_ARCH=BARCELONA\n```\n\nLANGUAGE: Makefile\nCODE:\n```\nOPENBLAS_TARGET_ARCH=NEHALEM\n```\n\n----------------------------------------\n\nTITLE: Customizing Default Algorithm Selection by Type - Julia\nDESCRIPTION: Shows how to override the default sorting algorithm for arrays of particular types by defining a method for Base.Sort.defalg. This method links arrays containing SmallInlineStrings or Missing values to a specialized InlineStringSort algorithm. Appropriate for package authors or advanced users; assumes the referenced types and InlineStringSort are defined.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/sort.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia\\nBase.Sort.defalg(::AbstractArray{<:Union{SmallInlineStrings, Missing}}) = InlineStringSort\n```\n\n----------------------------------------\n\nTITLE: Building Julia with BLAS and LAPACK configuration - Makefile - Shell\nDESCRIPTION: Allows selecting or overriding BLAS/LAPACK library behavior by toggling the 'USE_BLAS64', 'USE_SYSTEM_BLAS', and 'USE_SYSTEM_LAPACK' options and changing 'LIBBLAS', 'LIBBLASNAME', 'LIBLAPACK', and 'LIBLAPACKNAME' variables as needed. This is crucial for ensuring ABI compatibility and optimal performance on various distributions. Prerequisites: Availability of chosen libraries, correct library names, and matching integer sizes. Input: Appropriate variable assignment in make command. Output: Julia linked to the specified BLAS/LAPACK implementation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\nmake USE_BLAS64=0\n```\n\nLANGUAGE: Shell\nCODE:\n```\nmake LIBBLAS=-l$(YOURBLAS) LIBBLASNAME=lib$(YOURBLAS)\n```\n\nLANGUAGE: Shell\nCODE:\n```\nmake USE_SYSTEM_BLAS=1 USE_SYSTEM_LAPACK=1 LIBLAPACK=-l$(YOURBLAS) LIBLAPACKNAME=lib$(YOURBLAS)\n```\n\n----------------------------------------\n\nTITLE: Parsing Non-Standard Variable Names in Julia\nDESCRIPTION: Introduced the `var\"#str#\"` syntax for printing and parsing variable names that do not follow standard Julia identifier rules.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_103\n\nLANGUAGE: julia\nCODE:\n```\nvar\"#str#\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing Multidimensional Julia Arrays in C\nDESCRIPTION: This C code demonstrates creating and manipulating a 2D Julia array. It defines the array type for 2 dimensions (`jl_apply_array_type`), specifies dimensions, allocates the array (`jl_alloc_array_nd`), gets a pointer to the data (`jl_array_data`), retrieves the number of dimensions (`jl_array_ndims`) and size of each dimension (`jl_array_dim`). Finally, it fills the array, taking into account Julia's column-major memory layout. Note that C API functions like `jl_array_dim` use 0-based indexing.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_30\n\nLANGUAGE: c\nCODE:\n```\n// Create 2D array of float64 type\njl_value_t *array_type = jl_apply_array_type((jl_value_t*)jl_float64_type, 2);\nint dims[] = {10,5};\njl_array_t *x  = jl_alloc_array_nd(array_type, dims, 2);\n\n// Get array pointer\ndouble *p = jl_array_data(x, double);\n// Get number of dimensions\nint ndims = jl_array_ndims(x);\n// Get the size of the i-th dim\nsize_t size0 = jl_array_dim(x,0);\nsize_t size1 = jl_array_dim(x,1);\n\n// Fill array with data\nfor(size_t i=0; i<size1; i++)\n    for(size_t j=0; j<size0; j++)\n        p[j + size0*i] = i + j;\n```\n\n----------------------------------------\n\nTITLE: Generating Random Values from Tuple Elements in Julia\nDESCRIPTION: Represents the method signature for generating random values by sampling from the elements of a `Tuple` using the `rand` function in Julia's Random module. Performance for this was improved in v1.4, changing the output stream for a given seed.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_99\n\nLANGUAGE: julia\nCODE:\n```\nrand(::Tuple)\n```\n\n----------------------------------------\n\nTITLE: Including CRC32c Function Documentation (Julia Documenter.jl)\nDESCRIPTION: This `@docs` block instructs Julia's documentation generator (likely Documenter.jl) to automatically insert the documentation strings (docstrings) for the specified `CRC32c` functions. It includes the main `crc32c` function and its specific method signature taking an IO stream, an integer byte count, and an initial UInt32 value.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/CRC32c/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCRC32c.crc32c\nCRC32c.crc32c(::IO, ::Integer, ::UInt32)\n```\n```\n\n----------------------------------------\n\nTITLE: Exponentiating UniformScaling Objects in Julia\nDESCRIPTION: Shows the exponentiation operation `(a*I)^x` applied to a `UniformScaling` object (`a*I`) in Julia's LinearAlgebra module. This operation is now supported and results in `a^x * I`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_97\n\nLANGUAGE: julia\nCODE:\n```\n(a*I)^x\n```\n\n----------------------------------------\n\nTITLE: Removing Whitespace with Git Rebase in Bash\nDESCRIPTION: These bash commands demonstrate how to use git rebase with the --whitespace=fix option to automatically remove whitespace from previous or diverging commits. No additional dependencies beyond git are required. KEY PARAMETERS: 'HEAD~1' targets only the previous commit; 'master' targets all commits relative to the master branch. Inputs are invoked from the terminal, and outputs adjust commit history and fix whitespace issues in affected commits. Proper use ensures a cleaner commit history, but rewriting history can complicate collaborative workflows if not coordinated.\nSOURCE: https://github.com/julialang/julia/blob/master/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit rebase --whitespace=fix HEAD~1\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit rebase --whitespace=fix master\n```\n\n----------------------------------------\n\nTITLE: Defining Example Functions for Testing in a Julia Module\nDESCRIPTION: Defines a simple Julia module named `Example` within the `src/Example.jl` file. It exports three functions (`greet`, `simple_add`, `type_multiply`) intended for demonstration purposes within a package testing workflow. These functions provide basic functionality (greeting, addition, type-specific multiplication) to be targeted by test cases.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_17\n\nLANGUAGE: julia\nCODE:\n```\nmodule Example\n\nexport greet, simple_add, type_multiply\n\nfunction greet()\n    \"Hello world!\"\nend\n\nfunction simple_add(a, b)\n    a + b\nend\n\nfunction type_multiply(a::Float64, b::Float64)\n    a * b\nend\n\nend\n```\n\n----------------------------------------\n\nTITLE: Searching Documentation with String Literal in REPL Help Mode\nDESCRIPTION: Illustrates using a string literal in Help mode (`help?>`) to perform an `apropos` search through all documentation. Typing `\"aprop\"` searches for docstrings containing \"aprop\" and lists the relevant functions/modules.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nhelp?> \"aprop\"\nREPL.stripmd\nBase.Docs.apropos\n```\n\n----------------------------------------\n\nTITLE: Customizing REPL Error, Warning, and Info Colors via Environment Variables - Julia\nDESCRIPTION: These assignments set environment variables to control the REPL's error, warning, and info message colors. Can be added to the startup.jl file. Takes a Symbol corresponding to a supported color. No dependencies beyond Julia's environment variable handling and recognition of the color symbols.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_28\n\nLANGUAGE: julia\nCODE:\n```\nENV[\"JULIA_ERROR_COLOR\"] = :magenta\nENV[\"JULIA_WARN_COLOR\"] = :yellow\nENV[\"JULIA_INFO_COLOR\"] = :cyan\n```\n\n----------------------------------------\n\nTITLE: Initializing an Array of Zeros - Julia\nDESCRIPTION: Shows how to create a zero-initialized array of Float64 elements in Julia. Dependencies: Julia standard library. Input is the length of the vector; output is a vector of zeros of specified length.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/multi-threading.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> a = zeros(10)\n10-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n```\n\n----------------------------------------\n\nTITLE: Spawning and Monitoring Tasks - Stress GC and SAFETY with Threads - Julia\nDESCRIPTION: This Julia example stresses the garbage collector and demonstrates safe-point yielding in a multithreaded environment. It defines recursive and allocation-heavy tasks, spawning them onto multiple Julia threads and manually inserts calls to GC.safepoint() to ensure GC intervention. Intended for instrumentation analysis, this code can be used alongside external probe monitors such as bpftrace. Requires Julia with threading enabled.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nusing Base.Threads\n\nfib(x) = x <= 1 ? 1 : fib(x-1) + fib(x-2)\n\nbeaver = @spawn begin\n    while true\n        fib(30)\n        # A manual safepoint is necessary since otherwise this loop\n        # may never yield to GC.\n        GC.safepoint()\n    end\nend\n\nallocator = @spawn begin\n    while true\n        zeros(1024)\n    end\nend\n\nwait(allocator)\n```\n\n----------------------------------------\n\nTITLE: Equality and Arithmetic Operations on Rational Numbers in Julia\nDESCRIPTION: Illustrates equality checks, arithmetic operations, and comparison operators for rationals using Julia's built-in types and operators. No external dependencies are required. Takes rational numbers as input and returns logical (bool) results or rational results for arithmetic.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/complex-and-rational-numbers.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\njulia> 2//3 == 6//9\ntrue\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 2//3 == 9//27\nfalse\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 3//7 < 1//2\ntrue\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 3//4 > 2//3\ntrue\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 2//4 + 1//6\n2//3\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 5//12 - 1//4\n1//6\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 5//8 * 3//12\n5//32\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> 6//5 / 10//7\n21//25\n```\n\n----------------------------------------\n\nTITLE: Defining the WorkerConfig Structure for Cluster Managers (Julia)\nDESCRIPTION: Defines the mutable struct WorkerConfig, used to communicate launch parameters and state for worker processes in distributed Julia environments. The fields cover essential I/O and network information (such as host, port, io stream), worker launch details (count, executable name and flags), per-worker user data, and SSH/tunnel-specific options for non-local clusters. This struct is central to both in-built and custom cluster manager workflows. Users must initialize appropriate fields for their manager logic, and only io, host, or port are mandatory for basic connectivity. Constraints may apply depending on the transport or cluster type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_42\n\nLANGUAGE: julia\nCODE:\n```\nmutable struct WorkerConfig\n    # Common fields relevant to all cluster managers\n    io::Union{IO, Nothing}\n    host::Union{AbstractString, Nothing}\n    port::Union{Integer, Nothing}\n\n    # Used when launching additional workers at a host\n    count::Union{Int, Symbol, Nothing}\n    exename::Union{AbstractString, Cmd, Nothing}\n    exeflags::Union{Cmd, Nothing}\n\n    # External cluster managers can use this to store information at a per-worker level\n    # Can be a dict if multiple fields need to be stored.\n    userdata::Any\n\n    # SSHManager / SSH tunnel connections to workers\n    tunnel::Union{Bool, Nothing}\n    bind_addr::Union{AbstractString, Nothing}\n    sshflags::Union{Cmd, Nothing}\n    max_parallel::Union{Integer, Nothing}\n\n    # Used by Local/SSH managers\n    connect_at::Any\n\n    [...]\nend\n```\n\n----------------------------------------\n\nTITLE: Skipping Julia Package Initialization During Precompilation\nDESCRIPTION: Shows a Julia `ccall` expression that checks if the code is running during the precompilation output generation phase (`jl_generating_output`). Placing this check at the beginning of a package's `__init__` function prevents the initialization logic (which might create persistent handles like Timers) from running during any precompilation process, thereby resolving related hangs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/precompile_hang.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nccall(:jl_generating_output, Cint, ()) == 1 && return nothing\n```\n\n----------------------------------------\n\nTITLE: Compiling a C Embedding Example with GCC\nDESCRIPTION: Provides a GCC command line example to compile a C program (`test.c`) that embeds Julia. It specifies include paths (`-I`), library paths (`-L`), the library to link (`-ljulia`), and the runtime library path (`-Wl,-rpath`) for the Julia shared library. Assumes Julia is installed in the location specified by the `$JULIA_DIR` environment variable.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngcc -o test -fPIC -I$JULIA_DIR/include/julia -L$JULIA_DIR/lib -Wl,-rpath,$JULIA_DIR/lib test.c -ljulia\n```\n\n----------------------------------------\n\nTITLE: Activating a Module Context in Julia REPL\nDESCRIPTION: Changes the active module context within the Julia REPL. By default, the context is `Main`. This function allows switching to a different module for evaluation.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\nREPL.activate(::Module)\n```\n\n----------------------------------------\n\nTITLE: Parsing Function Definition AST with Where Clause – S-Expression\nDESCRIPTION: This snippet provides the s-expression AST form for a Julia function with typed arguments, keyword defaults, and a 'where' type parameter, as parsed by Julia. This aids macro developers in programmatically generating function signatures and bodies with type constraints.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ast.md#_snippet_5\n\nLANGUAGE: s-expression\nCODE:\n```\n(function (where (call f (parameters (kw k 1))\n                       (:: x T))\n                 T)\n          (block (line 2) (return (call + x 1))))\n```\n\n----------------------------------------\n\nTITLE: Installing Juliaup via Cargo (Cross-Platform)\nDESCRIPTION: Installs Juliaup using Rust's package manager, Cargo. This method works on Windows, macOS, and Linux, provided the Rust toolchain (including Cargo) is already installed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/installation.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ncargo install juliaup\n```\n\n----------------------------------------\n\nTITLE: Special Matrix Constructor Parameter Update - Julia\nDESCRIPTION: Shows that Bidiagonal, Tridiagonal, and SymTridiagonal constructors require explicit type conversions for input vectors and that Bidiagonal now requires a Symbol to specify upper/lower property, rather than a Bool or Char. Inputs: vectors and symbol; output: constructed special matrix.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_160\n\n\n\n----------------------------------------\n\nTITLE: Performing Generic Function Call via jl_apply - C\nDESCRIPTION: Demonstrates the low-level C API used by Julia to invoke a function by supplying all arguments in a contiguous array. jl_apply receives a pointer to an array of jl_value_t pointers (where the first element is the function to call) and the argument count. This function facilitates dynamic dispatch at the runtime level. Dependencies: Julia runtime C API, proper jl_value_t allocation, and knowledge of valid arguments.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *jl_apply(jl_value_t **args, uint32_t nargs)\n```\n\n----------------------------------------\n\nTITLE: Enabling Multi-Versioning for Package Images (Julia Env Var)\nDESCRIPTION: Setting the `JULIA_CPU_TARGET` environment variable to `generic` enables multi-versioning for package images. This creates caches optimized for multiple microarchitectures, useful in heterogeneous environments sharing a cache.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nJULIA_CPU_TARGET=generic\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Missing Value Handling Utilities\nDESCRIPTION: This block uses the `@docs` directive to list types and functions for handling missing data in Julia. It includes the `Missing` type, the `missing` singleton instance, functions for providing defaults (`coalesce`), checking for missingness (`ismissing`), iterating while skipping missing values (`skipmissing`), and determining the non-missing type (`nonmissingtype`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.Missing\nBase.missing\nBase.coalesce\nBase.@coalesce\nBase.ismissing\nBase.skipmissing\nBase.nonmissingtype\n```\n```\n\n----------------------------------------\n\nTITLE: Resulting Variable Assignment from @nexprs Expansion - Julia\nDESCRIPTION: Displays the explicit result of expanding @nexprs 2 j->(i_j = 1), which assigns 1 to each of i_1 and i_2. Serves to illuminate how the macro translates into Julia assignment statements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/cartesian.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\ni_1 = 1\\ni_2 = 1\n```\n\n----------------------------------------\n\nTITLE: Enabling Global Fail-Fast Mode for Julia Tests via Environment Variable\nDESCRIPTION: Sets the environment variable `JULIA_TEST_FAILFAST` to `\"true\"` to enable fail-fast mode globally for all test runs. This is useful in CI environments to report failures quickly.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\nJULIA_TEST_FAILFAST=\"true\"\n```\n\n----------------------------------------\n\nTITLE: Canonicalizing Periods with canonicalize - Julia\nDESCRIPTION: This snippet demonstrates the use of the canonicalize function, now extended to accept any Period input from the Dates module. The function normalizes period representations into canonical forms, facilitating easier comparison and manipulation. It only relies on Julia's Dates module, and accepts inputs like Month(15), converting them to a normalized Year/Month representation.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_74\n\nLANGUAGE: julia\nCODE:\n```\nusing Dates\nperiod = Month(15)\ncan_period = canonicalize(period) # Returns Year(1) + Month(3)\n```\n\n----------------------------------------\n\nTITLE: Command Interpolation Flag Propagation in Julia\nDESCRIPTION: When interpolating a `Cmd` object into another command string (e.g., ``` `$(x::Cmd) a b c` ```), the process flags (environment, working directory, etc.) from `x` are propagated if `x` is the first interpolant. Interpolating `x` elsewhere raises an error.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_119\n\nLANGUAGE: julia\nCODE:\n```\nx = setenv(`echo hello`, \"VAR\"=>\"value\")\n`$x world` # Propagates environment from x\n`echo $(x)` # Error\n```\n\n----------------------------------------\n\nTITLE: Disabling OpenBLAS Dynamic Architecture (Makefile)\nDESCRIPTION: Sets `OPENBLAS_DYNAMIC_ARCH = 0` in `Make.user` to disable compiling multiple architecture kernels within the OpenBLAS library. This can resolve build failures related to specific instructions (like `vpermpd`) or when using older versions of binutils (pre-2.18).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_7\n\nLANGUAGE: Makefile\nCODE:\n```\nOPENBLAS_DYNAMIC_ARCH = 0\n```\n\n----------------------------------------\n\nTITLE: Passing a Tuple as a Single Argument to a Julia Macro\nDESCRIPTION: Illustrates the syntax `@name (expr1, expr2, ...)` which passes the tuple `(expr1, expr2, ...)` as a single argument to the macro `@name`. This is distinct from passing multiple arguments using the standard invocation syntaxes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_31\n\nLANGUAGE: julia\nCODE:\n```\n@name (expr1, expr2, ...)\n```\n\n----------------------------------------\n\nTITLE: Importing Operators with Quoted Symbols in Julia\nDESCRIPTION: Demonstrates the new syntax in Julia v1.4 allowing the import of specific operators or functions using quoted symbols, particularly useful for names containing special characters. This example imports the addition operator `+` from the `Base` module.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_83\n\nLANGUAGE: julia\nCODE:\n```\nimport Base.:+\n```\n\n----------------------------------------\n\nTITLE: Referencing Experimental Threaded ccall API - Julia\nDESCRIPTION: This snippet documents the Base.@threadcall macro, which enables executing ccall operations using Julia's libuv-based thread pool. The macro is still experimental, and the snippet ensures that its usage and parameters will be accessible through auto-generated API documentation. Dependencies include experimental threading support with ccall integration.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/multi-threading.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nBase.@threadcall\\n```\n```\n\n----------------------------------------\n\nTITLE: Defining and Calling a Julia Function with a Unicode Name\nDESCRIPTION: Illustrates that Julia allows the use of Unicode characters for function names. A function named `∑` (summation symbol) is defined using the compact assignment form and then called with arguments `2` and `3`, returning `5`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/functions.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> ∑(x, y) = x + y\n∑ (generic function with 1 method)\n\njulia> ∑(2, 3)\n5\n```\n\n----------------------------------------\n\nTITLE: Defining and Using a Test Function with Conditionals - Julia\nDESCRIPTION: Defines a function 'test' that takes two arguments and prints their relation using an if-elseif-else conditional. Demonstrates function definition, execution, and output for different argument pairs. Highlights generic function creation in Julia and conditional message output based on input comparison.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/control-flow.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> function test(x, y)\n           if x < y\n               println(\"x is less than y\")\n           elseif x > y\n               println(\"x is greater than y\")\n           else\n               println(\"x is equal to y\")\n           end\n       end\ntest (generic function with 1 method)\n\njulia> test(1, 2)\nx is less than y\n\njulia> test(2, 1)\nx is greater than y\n\njulia> test(1, 1)\nx is equal to y\n```\n\n----------------------------------------\n\nTITLE: Performing Type Checks and Throwing Type Errors in C\nDESCRIPTION: This C code illustrates how to validate the type of a Julia value (`jl_value_t* val`) within C code intended to be callable from Julia. It uses `jl_typeis` to check if `val` matches the expected type (`jl_float64_type`). If the check fails, it raises a standard Julia `TypeError` using `jl_type_error`, providing the function name, expected type, and the received value.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_33\n\nLANGUAGE: c\nCODE:\n```\nif (!jl_typeis(val, jl_float64_type)) {\n    jl_type_error(function_name, (jl_value_t*)jl_float64_type, val);\n}\n```\n\n----------------------------------------\n\nTITLE: Breakpoint on Calling a Particular Method (Conditional GDB Breakpoint)\nDESCRIPTION: Sets a conditional breakpoint in GDB that triggers when the global function name matches a specified string ('method_to_break'). This is particularly useful when investigating performance or behavior of specific methods, but can slow down execution due to frequency of triggering. Requires that jl_symbol_name and jl_gf_mtable are available and called in context.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_8\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) break jl_apply_generic if strcmp((char*)(jl_symbol_name)(jl_gf_mtable(F)->name), \"method_to_break\")==0\n```\n\n----------------------------------------\n\nTITLE: Registering Package Load Callback - Julia\nDESCRIPTION: Registers a callback function with Julia's Base.package_callbacks, so that every time a package is loaded via Base.require, its Base.PkgId is pushed onto the loaded_packages array. This snippet relies on Julia's internal APIs (Base.PkgId, Base.package_callbacks) and demonstrates experimental usage that could change. It requires Julia's Base module and should be executed in a Julia script or session; loaded_packages will contain a list of all loaded package IDs.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/require.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nloaded_packages = Base.PkgId[]\ncallback = (pkg::Base.PkgId) -> push!(loaded_packages, pkg)\npush!(Base.package_callbacks, callback)\n```\n\n----------------------------------------\n\nTITLE: Accessing cmd.exe from Julia REPL Shell Mode on Windows\nDESCRIPTION: This snippet demonstrates another workaround for Windows Shell mode limitations by explicitly starting the Command Prompt (`cmd.exe`). Typing `cmd` in the Julia REPL's Shell mode (`shell>`) initiates a `cmd.exe` session, allowing standard commands like `dir` to be executed.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/REPL/docs/src/index.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\njulia> ; # upon typing ;, the prompt changes (in place) to: shell>\n\nshell> cmd\nMicrosoft Windows [version 10.0.17763.973]\n(c) 2018 Microsoft Corporation. All rights reserved.\nC:\\Users\\elm>dir\n Volume in drive C has no label\n Volume Serial Number is 1643-0CD7\n  Directory of C:\\Users\\elm\n\n29/01/2020  22:15    <DIR>          .\n29/01/2020  22:15    <DIR>          ..\n02/02/2020  08:06    <DIR>          .atom\n```\n\n----------------------------------------\n\nTITLE: Executing the Julia Test Suite under Valgrind\nDESCRIPTION: This command shows how to run the complete Julia test suite (`runtests.jl all`) under Valgrind from the `julia/test/` directory. It includes flags for self-modifying code (`--smc-check=all-non-file`), tracing child processes (`--trace-children=yes`), and using the standard Julia suppression file (`$PWD/../contrib/valgrind-julia.supp`). This is useful for comprehensive memory checking but can be time-consuming.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/valgrind.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvalgrind --smc-check=all-non-file --trace-children=yes --suppressions=$PWD/../contrib/valgrind-julia.supp ../julia runtests.jl all\n```\n\n----------------------------------------\n\nTITLE: Examining Julia Exception in GDB (Breakpoint and Inspection Sequence)\nDESCRIPTION: Sequence of GDB commands to catch a thrown Julia exception (jl_throw), examine the error object using jl_ and output valuable context. Useful to walk up the stack to the relevant jl_apply frame and inspect method signatures and ASTs. This relies on Julia symbols being available in the debug session.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_13\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) p jl_(e)\n(gdb) bt 10\n(gdb) f 3\n(gdb) p f->linfo->specTypes\n(gdb) p jl_( f->linfo->specTypes )\n(gdb) p jl_( jl_uncompress_ast(f->linfo, f->linfo->ast) )\n```\n\n----------------------------------------\n\nTITLE: Parsing If-Else Statements – Julia\nDESCRIPTION: This snippet illustrates the standard if-elseif-else conditional control structure in Julia. It contains nested branches and executes different blocks depending on the truth value of variable a, with fallbacks for elseif and else. When parsed, the corresponding AST explicitly represents each branch with 'block' nodes to capture source location and scope.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ast.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nif a\n    b\nelseif c\n    d\nelse\n    e\nend\n```\n\n----------------------------------------\n\nTITLE: Evaluating Field Escape Through SafeRef - Julia\nDESCRIPTION: This Julia code demonstrates how the EscapeAnalysis tool evaluates the escape behavior of values stored and retrieved via fields by utilizing a SafeRef. The function receives a tuple of types (here, String), wraps and updates a value within a SafeRef, fetches the value, and returns it. It relies on the presence of the EscapeAnalysis utility code_escapes, and requires SafeRef to be available in the environment. Inputs are passed as a tuple, and the returned value is analyzed for escape. This pattern helps visualize aliasing between IR elements in setfield! and getfield operations.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\ncode_escapes((String,)) do s\n    obj = SafeRef(\"init\")\n    obj[] = s\n    v = obj[]\n    return v\nend\n```\n\n----------------------------------------\n\nTITLE: Optimized `zero` for AbstractSparseArray in Julia\nDESCRIPTION: The `zero(x::AbstractSparseArray)` function no longer stores explicit zeros based on the input `x`. This change makes the operation constant time, improving performance compared to the previous O(number of stored values) complexity.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_100\n\nLANGUAGE: julia\nCODE:\n```\nzero(x::AbstractSparseArray)\n```\n\n----------------------------------------\n\nTITLE: Launching Tracy Profile Viewer using TracyProfiler_jll in Julia\nDESCRIPTION: This Julia code snippet demonstrates how to launch the Tracy profile viewer application. It requires the `TracyProfiler_jll` package to be installed in the Julia environment. Executing `run(TracyProfiler_jll.tracy())` starts the graphical user interface for viewing Tracy profiling data collected from a Julia session.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/external_profilers.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nrun(TracyProfiler_jll.tracy())\n\n```\n\n----------------------------------------\n\nTITLE: Controlling Compilation with `@compiler_options` Macro in Julia\nDESCRIPTION: The experimental macro `Base.Experimental.@compiler_options` allows enabling or disabling compilation and type inference on a per-module basis. This provides finer control over the compilation process.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_49\n\nLANGUAGE: julia\nCODE:\n```\nmodule MyModule\n  using Base.Experimental\n  @compiler_options compile=false infer=false\n  # Module content...\nend\n```\n\n----------------------------------------\n\nTITLE: Conditionally Marking Tests as Broken (Old Method) in Julia Test\nDESCRIPTION: Illustrates the previous method for conditionally marking a test as broken within the Julia Test framework. An `if/else` statement checks a condition (e.g., `T == Float64`) and uses `@test_broken` for the specific case where the test is expected to fail, while `@test` is used for other cases where the test should pass.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_44\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nif T == Float64\n    @test_broken isequal(complex(one(T)) / complex(T(Inf), T(-Inf)), complex(zero(T), zero(T)))\nelse\n    @test isequal(complex(one(T)) / complex(T(Inf), T(-Inf)), complex(zero(T), zero(T)))\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Passing LLVM Options via Environment Variables (Bash)\nDESCRIPTION: This collection of bash export commands shows how to pass various options and flags to LLVM through the JULIA_LLVM_ARGS environment variable before launching Julia. Options include enabling IR dumps after passes, restricting debug output, listing available options, and passing multiple flags at once. These commands must be executed in a shell prior to running Julia, and require LLVM and Julia built with compatible options.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport JULIA_LLVM_ARGS=-print-after-all\n```\n\nLANGUAGE: bash\nCODE:\n```\nexport JULIA_LLVM_ARGS=-debug-only=loop-vectorize\n```\n\nLANGUAGE: bash\nCODE:\n```\nexport JULIA_LLVM_ARGS=-help\n```\n\nLANGUAGE: bash\nCODE:\n```\nexport JULIA_LLVM_ARGS=-help-hidden\n```\n\nLANGUAGE: bash\nCODE:\n```\nexport JULIA_LLVM_ARGS=\"-fatal-warnings -print-options\"\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation Links for SharedArrays Components in Julia\nDESCRIPTION: This snippet utilizes the Julia documentation system's `@docs` macro. It automatically generates links or embeds documentation for the specified items from the `SharedArrays` module: the types `SharedArray`, `SharedVector`, `SharedMatrix`, and the functions `procs` (specifically its method for `SharedArray`), `sdata`, `indexpids`, and `localindices`. This directive is typically processed by documentation generators like Documenter.jl to build comprehensive API documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/SharedArrays/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSharedArrays.SharedArray\nSharedArrays.SharedVector\nSharedArrays.SharedMatrix\nSharedArrays.procs(::SharedArray)\nSharedArrays.sdata\nSharedArrays.indexpids\nSharedArrays.localindices\n```\n```\n\n----------------------------------------\n\nTITLE: Exported `istaskfailed` function in Julia\nDESCRIPTION: The function `istaskfailed`, used to check if a task has failed, is now documented and exported, joining `istaskdone` and `istaskstarted`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_112\n\nLANGUAGE: julia\nCODE:\n```\nistaskfailed(task::Task)\n```\n\n----------------------------------------\n\nTITLE: Enforcing `esc` Usage for Macros Returning `:quote` in Julia\nDESCRIPTION: Macros that return quoted expressions using `Expr(:quote, ...)` must now correctly use `esc(...)` to escape the contents where necessary. Previously, escaping might have been implicitly handled, but this behavior has been corrected for consistency.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_57\n\nLANGUAGE: julia\nCODE:\n```\n# Macro definition requiring esc for quoted output\nmacro my_quote_macro(expr)\n    return Expr(:quote, esc(expr))\nend\n```\n\n----------------------------------------\n\nTITLE: Tracking Base Module Changes with Revise.jl in Julia\nDESCRIPTION: Shows the necessary Julia commands to start using Revise.jl for efficient Base development. `using Revise` loads the package (if not already loaded via startup configuration), and `Revise.track(Base)` instructs Revise to monitor the source files of the Base module for changes and apply them automatically to the running session, avoiding the need for frequent Julia rebuilds during development.\nSOURCE: https://github.com/julialang/julia/blob/master/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nusing Revise    # if you aren't launching it in your `.julia/config/startup.jl`\nRevise.track(Base)\n```\n\n----------------------------------------\n\nTITLE: Minimal Julia Module Importing a Suspected Problematic Dependency\nDESCRIPTION: Defines a simple Julia module `MWE` that imports `ThePackageYouThinkIsCausingTheProblem`. This code is placed in `MWE/src/MWE.jl` as part of creating a Minimal Working Example (MWE) to test if the dependency's `__init__` function causes a precompilation hang when the MWE package itself is precompiled.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/precompile_hang.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nmodule MWE\nusing ThePackageYouThinkIsCausingTheProblem\nend\n```\n\n----------------------------------------\n\nTITLE: Working with Floating-Point Literals in Julia (Julia)\nDESCRIPTION: Demonstrates basic usage and parsing of floating-point literals in Julia, including standard and scientific E-notation, decimal values, and negative values. No dependencies required; expected input is literal values, output is their parsed Float64 values as displayed in the REPL. Highlights Julia's recognition of these values as Float64 by default.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/integers-and-floating-point-numbers.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\njulia> 1.0\n1.0\n\njulia> 1.\n1.0\n\njulia> 0.5\n0.5\n\njulia> .5\n0.5\n\njulia> -1.23\n-1.23\n\njulia> 1e10\n1.0e10\n\njulia> 2.5e-4\n0.00025\n```\n\n----------------------------------------\n\nTITLE: Configuring AOT Compilation Threads via Environment Variable\nDESCRIPTION: References the `JULIA_IMAGE_THREADS` environment variable, which allows overriding the default multithreading behavior for the LLVM optimization and machine code emission steps within `jl_dump_native`. Setting this variable can influence performance and memory usage during AOT image compilation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/aot.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nJULIA_IMAGE_THREADS\n```\n\n----------------------------------------\n\nTITLE: Comparing PackageEvaluator Results using Julia and DataFrames\nDESCRIPTION: This Julia script leverages the DataFrames package to analyze PackageEvaluator results stored in CSV files. It reads the summary data for both the release and backport versions, joins them based on package name, and then iterates through the combined results. It prints a color-coded comparison to standard output, highlighting packages with changed statuses: red for potential regressions (pass to fail), green for fixes (fail to pass), and yellow for packages that only ran successfully on one of the versions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nusing DataFrames\n\nrelease = readtable(\"summary_release.csv\", header=false, names=[:package, :release])\nbackport = readtable(\"summary_backport.csv\", header=false, names=[:package, :backport])\n\nresults = join(release, backport, on=:package, kind=:outer)\n\nfor result in eachrow(results)\n    a = result[:release]\n    b = result[:backport]\n    if (isna(a) && !isna(b)) || (isna(b) && !isna(a))\n        color = :yellow\n    elseif a != b && occursin(\"pass\", b)\n        color = :green\n    elseif a != b\n        color = :red\n    else\n        continue\n    end\n    printstyled(result[:package], \": Release \", a, \" -> Backport \", b, \"\\n\", color=color)\nend\n```\n\n----------------------------------------\n\nTITLE: Documenting AnnotatedString Experimental API in Julia\nDESCRIPTION: This documentation block lists the experimental AnnotatedString API elements, consisting of types and functions such as AnnotatedString, AnnotatedChar, annotatedstring, annotations, and annotate!. The API is dynamic and may change between Julia versions, as highlighted in the accompanying note. Inputs involve strings or characters with optional annotations, and outputs are enhanced string types carrying extra metadata. Usage is subject to change and is presently part of Julia's experimental suite. No external packages are required, although users should monitor Julia's changelogs when relying on these features.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/strings.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.AnnotatedString\nBase.AnnotatedChar\nBase.annotatedstring\nBase.annotations\nBase.annotate!\n```\n```\n\n----------------------------------------\n\nTITLE: Subtyping Example with Custom Debugger Function - Julia\nDESCRIPTION: Calls the mysubtype function on simple tuple types, allowing breakpoints to be hit if debugging infrastructure is set up. Inputs: Tuple types; Outputs: subtype boolean. Used for debugging and stepping through subtype relationships in practice.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/types.md#_snippet_18\n\nLANGUAGE: julia\nCODE:\n```\nmysubtype(Tuple{Int, Float64}, Tuple{Integer, Real})\n```\n\n----------------------------------------\n\nTITLE: Escape Analysis with Array Resizing - Julia\nDESCRIPTION: This code demonstrates how dynamic array resizing limits the precision of EscapeAnalysis, switching it to a coarser aliasing mode. The function accepts two Strings, initializes an empty array, pushes two SafeRef-wrapped values (thus resizing the array), and returns the first element and the length. Since array mutation makes dimensions non-constant, the analysis cannot propagate escape with per-element granularity. Relies on SafeRef and code_escapes; the output is a tuple of an array element and its length.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\ncode_escapes((String,String)) do s, t\n    ary = Any[]\n    push!(ary, SafeRef(s))\n    push!(ary, SafeRef(t))\n    ary[1], length(ary)\nend\n```\n\n----------------------------------------\n\nTITLE: Documenting Indexing and Assignment Methods via JuliaDoc Macros - Julia\nDESCRIPTION: Enumerates key functions in Julia's array indexing and assignment API for documentation through the `@docs` macro. Includes indexing accessors (`getindex`, `setindex!`), index calculation utilities, bounds checking, and machinery for working with Cartesian and linear indices. Relies on Julia Base and Core. Meant for auto-generating documentation, not for direct execution.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/arrays.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.getindex(::AbstractArray, ::Any...)\nBase.setindex!(::AbstractArray, ::Any, ::Any...)\nBase.nextind\nBase.prevind\nBase.copyto!(::AbstractArray, ::CartesianIndices, ::AbstractArray, ::CartesianIndices)\nBase.copy!\nBase.isassigned\nBase.Colon\nBase.CartesianIndex\nBase.CartesianIndices\nBase.Dims\nBase.LinearIndices\nBase.to_indices\nBase.checkbounds\nBase.checkindex\nBase.elsize\n```\n```\n\n----------------------------------------\n\nTITLE: Running a Julia Program with Valgrind and Suppressions\nDESCRIPTION: This command demonstrates how to execute a Julia script (`progname.jl`) using Valgrind. It includes the crucial `--smc-check=all-non-file` flag for JIT compilers and specifies a suppression file (`contrib/valgrind-julia.supp`) to reduce spurious warnings. This command should be run from the Julia source directory.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/valgrind.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ valgrind --smc-check=all-non-file --suppressions=contrib/valgrind-julia.supp ./julia progname.jl\n```\n\n----------------------------------------\n\nTITLE: Enabling Julia JIT Compile Tracing via CLI Flag\nDESCRIPTION: Shows the Julia command-line flag `--trace-compile=filename` used to activate the recording of methods compiled by the JIT. This generates a precompile script in the specified file, which can be used later in the AOT compilation process to guide which methods need to be compiled.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/aot.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n--trace-compile=filename\n```\n\n----------------------------------------\n\nTITLE: Inspecting Escape Analysis Results in Julia\nDESCRIPTION: This snippet shows how to programmatically access the detailed escape information computed by `code_escapes`. It retrieves the `EscapeInfo` object for a specific function argument (`s2`, represented by `Core.Argument(3)`) and an SSA value (`r3`, represented by `Core.SSAValue(3)`) from the analysis result state.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@repl EAUtils\nresult.state[Core.Argument(3)] # get EscapeInfo of `s2`\n\nresult.state[Core.SSAValue(3)] # get EscapeInfo of `r3`\n```\n```\n\n----------------------------------------\n\nTITLE: Generating version file with Make - Makefile - Shell\nDESCRIPTION: Generates the 'base/version_git.jl' file using the Makefile and information from the Git repository. This file is used to populate version information in the Julia splash screen and output of versioninfo(). The command leverages the '-C' flag to run make in the 'base' subdirectory and triggers the 'version_git.jl.phony' target. Dependencies include GNU Make, version control via git, and access to the 'base' directory. Input: N/A. Output: A version information file placed at 'base/version_git.jl'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nmake -C base version_git.jl.phony\n```\n\n----------------------------------------\n\nTITLE: Configuring Julia Cross-Compilation Environment - make\nDESCRIPTION: Sets essential environment and make variables for cross-compiling Julia for RISC-V. XC_HOST defines the cross-compiler target triple, OS specifies the build target system, and QEMU_LD_PREFIX is set to a sysroot for QEMU. These variables are normally placed in Make.user; QEMU_LD_PREFIX ensures runtime libraries are found when running RISC-V binaries. Dependencies: a proper sysroot and QEMU emulator are required for correct execution.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/riscv.md#_snippet_4\n\nLANGUAGE: make\nCODE:\n```\nXC_HOST=riscv64-unknown-linux-gnu\nOS=Linux\nexport QEMU_LD_PREFIX=/opt/riscv/sysroot\n```\n\n----------------------------------------\n\nTITLE: Documenting Period Rounding Operations in Julia Dates (Julia)\nDESCRIPTION: This @docs snippet lists method signatures for rounding ConvertiblePeriod values to specified period resolutions in Julia. It includes Base.floor, Base.ceil, and Base.round methods where ConvertiblePeriods are manipulated. Dependencies involve the Dates module, and input parameters are ConvertiblePeriod or compatible subtypes. Outputs a period rounded per the requested mode. Limitations: Only works with ConvertiblePeriod inputs recognized by Julia's Dates.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Dates/docs/src/index.md#_snippet_20\n\nLANGUAGE: julia\nCODE:\n```\nBase.floor(::Dates.ConvertiblePeriod, ::T) where T <: Dates.ConvertiblePeriod\nBase.ceil(::Dates.ConvertiblePeriod, ::Dates.ConvertiblePeriod)\nBase.round(::Dates.ConvertiblePeriod, ::Dates.ConvertiblePeriod, ::RoundingMode{:NearestTiesUp})\n```\n\n----------------------------------------\n\nTITLE: Defining the Julia SubArray Struct\nDESCRIPTION: Presents the struct definition for `SubArray`. It details the five type parameters: element type (`T`), dimensionality (`N`), parent array type (`P`), a tuple of index types (`I`), and a boolean indicating fast linear indexing support (`L`). Key fields include the parent array, the tuple of indices used for the view, and fields related to linear indexing (`offset1`, `stride1`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nstruct SubArray{T,N,P,I,L} <: AbstractArray{T,N}\n    parent::P\n    indices::I\n    offset1::Int       # for linear indexing and pointer, only valid when L==true\n    stride1::Int       # used only for linear indexing\n    ...\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Calling Julia Object Display in GDB (GDB Command)\nDESCRIPTION: This GDB command calls a Julia helper to display a jl_value_t* object from the debugger, directing the output into the Julia session. Requires a debug build of Julia and a running gdb session with access to Julia's C APIs. The parameter 'obj' is any pointer to a Julia value, and the command outputs its type and value inside the running Julia process.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_0\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) call jl_(obj)\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `ipermutedims`: Use `permutedims` with `invperm` in Julia\nDESCRIPTION: The function `ipermutedims(A::AbstractArray, p)` has been deprecated in Julia. The recommended alternative is to use `permutedims(A, invperm(p))` to achieve the inverse permutation of dimensions.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_178\n\nLANGUAGE: julia\nCODE:\n```\npermutedims(A, invperm(p))\n```\n\n----------------------------------------\n\nTITLE: Syntax Error in Julia Multi-Dimensional Generator Argument\nDESCRIPTION: Demonstrates a common syntax error in Julia. When a multi-dimensional generator expression (`1/(i+j) for i=1:2, j=1:2`) is used directly as an argument followed by another argument (`[1:4;]`), the comma separation causes a syntax error because the subsequent argument is misinterpreted as part of the generator's iteration specification.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/arrays.md#_snippet_14\n\nLANGUAGE: julia-repl\nCODE:\n```\njulia> map(tuple, 1/(i+j) for i=1:2, j=1:2, [1:4;])\nERROR: syntax: invalid iteration specification\n```\n\n----------------------------------------\n\nTITLE: Illustrating Backward Escape Propagation in Julia\nDESCRIPTION: This example demonstrates the backward nature of Julia's escape analysis. It shows how the `ReturnEscape` status applied to the return value (`obj`) propagates backward through the use-def chain to the `Ref(s)` call and ultimately marks the input argument `s` as potentially escaping.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@repl EAUtils\ncode_escapes((Base.RefValue{String},)) do s\n    obj = Ref(s)\n    return obj\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Parsing Type Definitions with Type Parameters – Julia\nDESCRIPTION: This snippet defines a mutable Julia struct with a parametric type constraint. The type variable T is restricted with <: to S, and a field x carries this type. When parsed, this construct is mapped to an AST suitable for generating Julia type objects and for macro manipulations involving types.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ast.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nmutable struct Foo{T<:S}\n    x::T\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Git to Use HTTPS Instead of Git Protocol (Shell)\nDESCRIPTION: Demonstrates how to configure Git globally to rewrite all Git protocol URLs to HTTPS, which is useful for users behind firewalls that block the standard git protocol. No additional dependencies are needed beyond Git itself. The command modifies the global Git configuration for all clones and pulls on the system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit config --global url.\"https://\".insteadOf git://\n\n```\n\n----------------------------------------\n\nTITLE: Implementing ClusterManager Launch and Manage Methods (Julia)\nDESCRIPTION: Defines template method signatures for the launch and manage methods required by a custom ClusterManager (e.g., FooManager) in Julia. The launch method is responsible for launching new worker processes based on the provided parameters and reporting them using the launched array and condition variable, while the manage method handles events such as worker registration, interruption, and cleanup. No external dependencies are required beyond Julia's distributed infrastructure. The parameters include the cluster manager instance, various configuration dicts, arrays, and condition/event signals. Both functions are invoked by Julia's distributed system and must be implemented to support custom cluster managers.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/distributed-computing.md#_snippet_40\n\nLANGUAGE: julia\nCODE:\n```\nfunction launch(manager::FooManager, params::Dict, launched::Array, c::Condition)\n    [...]\nend\n\nfunction manage(manager::FooManager, id::Integer, config::WorkerConfig, op::Symbol)\n    [...]\nend\n```\n\n----------------------------------------\n\nTITLE: Line Continuation in Julia vs. MATLAB\nDESCRIPTION: Julia automatically continues incomplete expressions onto the next line. MATLAB uses `...` for explicit line continuation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_21\n\nLANGUAGE: matlab\nCODE:\n```\n... % MATLAB line continuation\n```\n\n----------------------------------------\n\nTITLE: Disabling Package Images via Command Line (Julia)\nDESCRIPTION: This command-line option, when passed to Julia, disables the use and creation of package images (native object caches) for the current session. Disabling caching may require regeneration of `.ji` cache files.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n--pkgimages=no\n```\n\n----------------------------------------\n\nTITLE: Saturating Arithmetic Prevents Correct Midpoint Calculation in Matlab - Matlab\nDESCRIPTION: This Matlab snippet illustrates that due to its saturating arithmetic, computing the midpoint as (n + 2*n)/2 can produce incorrect results when overflow or saturation occurs, in contrast to Julia's approach. It's designed to show the limitations of saturating arithmetic for certain algorithms and does not require extra dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/faq.md#_snippet_23\n\nLANGUAGE: matlab\nCODE:\n```\n>> (n + 2*n)/2\n\nans =\n\n  4611686018427387904\n```\n\n----------------------------------------\n\nTITLE: Calling Julia C API from Julia-Managed Threads\nDESCRIPTION: This C code provides a complete example demonstrating thread-safe usage of the Julia C API from threads managed by the Julia runtime. It defines a C function `c_func` which calls back into the Julia API (`jl_get_function`, `jl_box_int32`, `jl_call1`, `jl_unbox_float64`). This C function is then made available to Julia using `ccall` via `jl_eval_string`. Finally, Julia code executed via `jl_eval_string` uses `Threads.@threads` to call the wrapper function (`func`) from multiple Julia threads, which in turn safely call the C function `c_func` and the Julia C API from those threads. Requires `julia.h`, `JULIA_DEFINE_FAST_TLS`, `jl_init`, and `jl_atexit_hook`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_38\n\nLANGUAGE: c\nCODE:\n```\n#include <julia/julia.h>\nJULIA_DEFINE_FAST_TLS\n\ndouble c_func(int i)\n{\n    printf(\"[C %08x] i = %d\\n\", pthread_self(), i);\n\n    // Call the Julia sqrt() function to compute the square root of i, and return it\n    jl_function_t *sqrt = jl_get_function(jl_base_module, \"sqrt\");\n    jl_value_t* arg = jl_box_int32(i);\n    double ret = jl_unbox_float64(jl_call1(sqrt, arg));\n\n    return ret;\n}\n\nint main()\n{\n    jl_init();\n\n    // Define a Julia function func() that calls our c_func() defined in C above\n    jl_eval_string(\"func(i) = ccall(:c_func, Float64, (Int32,), i)\");\n\n    // Call func() multiple times, using multiple threads to do so\n    jl_eval_string(\"println(Threads.threadpoolsize())\");\n    jl_eval_string(\"use(i) = println(\\\"[J $(Threads.threadid())] i = $(i) -> $(func(i))\\\")\");\n    jl_eval_string(\"Threads.@threads for i in 1:5 use(i) end\");\n\n    jl_atexit_hook(0);\n}\n```\n\n----------------------------------------\n\nTITLE: Recording Program Execution with rr Chaos Mode (Shell)\nDESCRIPTION: This shell command uses the `rr` tool to record a program's execution. The `--chaos` flag causes `rr` to simulate a random number of cores (between one and eight), introducing non-deterministic scheduling to help expose concurrency bugs. It is often used iteratively until a bug is captured.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\nrr record --chaos\n```\n\n----------------------------------------\n\nTITLE: Deprecation of `num` and `den`: Use `numerator` and `denominator` in Julia\nDESCRIPTION: The functions `num(x)` and `den(x)` for accessing the numerator and denominator of a rational number `x` are deprecated in Julia. Use `numerator(x)` and `denominator(x)` respectively instead.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_183\n\nLANGUAGE: julia\nCODE:\n```\nnumerator\n```\n\nLANGUAGE: julia\nCODE:\n```\ndenominator\n```\n\n----------------------------------------\n\nTITLE: Requesting Documentation for FileWatching Types (Julia)\nDESCRIPTION: Uses the Documenter.jl `@docs` macro to request the inclusion of documentation for specific file event monitoring types (`FileMonitor`, `FolderMonitor`, `PollingFileWatcher`, `FDWatcher`) from the Julia standard library.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/FileWatching/docs/src/index.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nFileMonitor\nFolderMonitor\nPollingFileWatcher\nFDWatcher\n```\n\n----------------------------------------\n\nTITLE: Operators Module Removal - Julia\nDESCRIPTION: Documents the deprecation of the Operators module. Instead, users should explicitly import specific operators from Base. Only imports are required; no extra dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_159\n\nLANGUAGE: julia\nCODE:\n```\nimport Base: +, -, *, /\n```\n\n----------------------------------------\n\nTITLE: Defining a Julia Function to Create a Timer\nDESCRIPTION: Defines a simple Julia function `maketimer` that creates and returns a `Timer` object which prints \"hi\" after a 0-second delay, repeating every 1 second. This example highlights that function *definitions* involving potentially problematic objects like `Timer` are safe unless the function is actually *called* during the module loading or precompilation process.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/precompile_hang.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nmaketimer() = Timer(timer -> println(\"hi\"), 0; interval=1)\n```\n\n----------------------------------------\n\nTITLE: Checking Package Precompilation Status Function Signature in Julia\nDESCRIPTION: Defines the signature for the new `Base.isprecompiled` function in Julia. This function accepts a `PkgId` object (identifying a package) and returns a boolean value indicating if a precompiled cache file exists for that package.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nBase.isprecompiled(pkg::PkgId)\n```\n\n----------------------------------------\n\nTITLE: Defining a Regular Function in Julia\nDESCRIPTION: Defines a simple, regular Julia function `f(x)` that returns the string \"original definition\". This serves as the initial definition before demonstrating interactions with generated functions and method redefinition.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/metaprogramming.md#_snippet_65\n\nLANGUAGE: julia\nCODE:\n```\njulia> f(x) = \"original definition\";\n```\n\n----------------------------------------\n\nTITLE: Including Julia Header in Visual Studio Precompiled Header\nDESCRIPTION: Instructs how to include the main Julia C API header (`julia.h`) within a Visual Studio project, specifically by adding the `#include <julia.h>` directive to the precompiled header file (`stdafx.h`). This ensures the Julia API is available throughout the project.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/embedding.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\n#include <julia.h>\n```\n\n----------------------------------------\n\nTITLE: Creating Minimal Modules in Julia\nDESCRIPTION: Shows how to use the `Module` constructor `Module(:name, false, false)` to create a Julia module named `:name`. This specific constructor creates a module that contains no initial names – it does not import `Base` or `Core`, nor does it contain a reference to itself.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_26\n\nLANGUAGE: julia\nCODE:\n```\nModule(:name, false, false)\n```\n\n----------------------------------------\n\nTITLE: Describing Number Type Hierarchy - Julia - Plaintext\nDESCRIPTION: Presents a visual tree structure outlining the full hierarchy of Julia's Number types, including differentiation between abstract and concrete types. This visualization is intended for documentation to help users understand the inheritance structure and relationships among built-in number types. There are no code dependencies, and inputs/outputs are not applicable as this is not executable code but a diagram.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/numbers.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nNumber  (Abstract Type)\\n├─ Complex\\n└─ Real  (Abstract Type)\\n   ├─ AbstractFloat  (Abstract Type)\\n   │  ├─ Float16\\n   │  ├─ Float32\\n   │  ├─ Float64\\n   │  └─ BigFloat\\n   ├─ Integer  (Abstract Type)\\n   │  ├─ Bool\\n   │  ├─ Signed  (Abstract Type)\\n   │  │  ├─ Int8\\n   │  │  ├─ Int16\\n   │  │  ├─ Int32\\n   │  │  ├─ Int64\\n   │  │  ├─ Int128\\n   │  │  └─ BigInt\\n   │  └─ Unsigned  (Abstract Type)\\n   │     ├─ UInt8\\n   │     ├─ UInt16\\n   │     ├─ UInt32\\n   │     ├─ UInt64\\n   │     └─ UInt128\\n   ├─ Rational\\n   └─ AbstractIrrational  (Abstract Type)\\n      └─ Irrational\n```\n\n----------------------------------------\n\nTITLE: Triggering AOT Compilation in Julia\nDESCRIPTION: Demonstrates a typical Julia command (`using Foo`) that initiates the internal AOT compilation pipeline for a package named 'Foo'. This command loads the package, potentially triggering precompilation if needed, which involves the AOT process described.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/aot.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing Foo\n```\n\n----------------------------------------\n\nTITLE: Checking Out Specific Julia Release Version - Shell\nDESCRIPTION: This shell command checks out the specified stable Julia version (v1.11.5) using Git. The command must be run inside the cloned 'julia' directory. It ensures users are working with a well-tested stable release instead of the latest development version.\nSOURCE: https://github.com/julialang/julia/blob/master/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout v1.11.5\n```\n\n----------------------------------------\n\nTITLE: Running Julia Documentation Doctests with Make (Shell)\nDESCRIPTION: Shows how to execute doctests for the Julia documentation via the \\\"make -C doc doctest=true\\\" command. This runs the doctest target in the documentation build Makefile, ensuring all examples and code in the manual are tested for correctness. Usage requires GNU Make; doctests use the sandboxed package environment in \\\"doc/deps/\\\". The \\\"-C doc\\\" flag changes into the \\\"doc\\\" directory before running Make, and \\\"doctest=true\\\" is passed as a variable to enable doctesting.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ make -C doc doctest=true\n```\n\n----------------------------------------\n\nTITLE: Signing Windows Executables with signtool - Batch\nDESCRIPTION: Signs the Julia Windows executable using Microsoft's SignTool, with certificate and password arguments, as well as online timestamping. Requires the Windows SDK (with SignTool) and the signing certificate (.p12) file with password accessible; parameters include the path to SignTool, location of the .p12 file, the actual .exe to sign, and a contactable certificate password holder. Output includes standard signtool feedback and errors if signing fails.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_23\n\nLANGUAGE: batch\nCODE:\n```\nset PATH=%PATH%;C:\\\\Program Files (x86)\\\\Windows Kits\\\\10\\\\App Certification Kit;\\nsigntool sign /f julia-windows-code-sign_2017.p12 /p \\\"PASSWORD\\\" ^\\n   /t http://timestamp.verisign.com/scripts/timstamp.dll ^\\n   /v julia-x.y.z-win32.exe\n```\n\n----------------------------------------\n\nTITLE: Setting Compilation Flags for Valgrind Memory Debugging in Julia\nDESCRIPTION: This Make snippet shows how to add `MEMDEBUG` and `MEMDEBUG2` flags to `CFLAGS` in the `Make.user` file. These flags disable memory pools in Julia and FemtoLisp, respectively, which can improve Valgrind's ability to detect memory errors. This requires recompiling Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/valgrind.md#_snippet_0\n\nLANGUAGE: make\nCODE:\n```\nCFLAGS = -DMEMDEBUG -DMEMDEBUG2\n```\n\n----------------------------------------\n\nTITLE: Creating Cross-References in Julia Docstrings\nDESCRIPTION: This Julia docstring example shows how to create cross-references to other documented items (like `parse` and `nothing`) using the `[`name`](@ref)` syntax. This feature relies on Documenter.jl, not standard Markdown.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\n    tryparse(type, str; base)\n\nLike [`parse`](@ref), but returns either a value of the requested type,\nor [`nothing`](@ref) if the string does not contain a valid number.\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Verbose Linking Output (Julia Env Var)\nDESCRIPTION: Setting the `JULIA_VERBOSE_LINKING` environment variable to `true` makes the package image linking process output detailed information. This is useful for debugging issues related to the linking stage where native code is combined.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nJULIA_VERBOSE_LINKING=true\n```\n\n----------------------------------------\n\nTITLE: Introducing `⌿` and `¦` as Infix Operators in Julia\nDESCRIPTION: The Unicode characters `⌿` (U+233F) and `¦` (U+00A6) are now recognized as infix operators in Julia. `⌿` has precedence similar to multiplication (`*`), and `¦` has precedence similar to addition (`+`). Previously, these characters were treated as parts of identifiers.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_60\n\nLANGUAGE: julia\nCODE:\n```\n# Hypothetical usage:\nx = a ⌿ b  # U+233F\ny = c ¦ d  # U+00A6\n```\n\n----------------------------------------\n\nTITLE: Including a Function in `@docs` Block for Documentation Generation\nDESCRIPTION: Shows how to include a function name (`bar`) within a `@docs` block in the documentation source files (`doc/src/stdlib/`). This directive tells the documentation generator (Documenter.jl) to pull the docstring associated with `bar` and render it at this location in the final HTML documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n@docs\nfoo\nbar # <-- Added this one.\nbaz\n```\n\n----------------------------------------\n\nTITLE: Lowered Representation of a Closure as a Struct and Function - Julia\nDESCRIPTION: Presents how Julia internally lowers closures to a struct capturing tangent variables and a corresponding method for the call interface. The struct holds the captured environment (field x), and the method enables function-like invocation. This pattern enables closures to retain references to external variables. Intended for internal compiler use; depends on Julia's metaprogramming system.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/functions.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nstruct ##1{T}\n    x::T\nend\n\n(_::##1)(y) = _.x + y\n\nfunction adder(x)\n    return ##1(x)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining a Sample Function for Testing in Julia\nDESCRIPTION: Defines a simple Julia function `foo(x)` that calculates the square of the length of its input `x`. This function is used as the subject for subsequent testing examples within the documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Test/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> using Test\n\njulia> foo(x) = length(x)^2\nfoo (generic function with 1 method)\n```\n\n----------------------------------------\n\nTITLE: Defining Admonitions in Markdown - Markdown\nDESCRIPTION: This snippet showcases the use of the admonition block syntax in Markdown documentation. Using triple exclamation marks (!!!) followed by a type and optional title, various highlighted blocks such as notes, warnings, and custom types can be created. No dependencies are required; key parameters include the admonition type and optional title, while the indented content forms the body. Inputs are the block type, title, and the content; outputs are specially styled documentation blocks. This technique is limited to documentation generators or renderers that support the admonition extension.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_23\n\nLANGUAGE: markdown\nCODE:\n```\n!!! note\n\n    This is the content of the note.\n    It is indented by 4 spaces. A tab would work as well.\n\n!!! warning \"Beware!\"\n\n    And this is another one.\n\n    This warning admonition has a custom title: `\"Beware!\"`.\n```\n\n----------------------------------------\n\nTITLE: Configuring MMTk GC Options for Julia Build Process - shell\nDESCRIPTION: Shows how to configure build variables in a Make.user file or as environment variables to select the GC plan, movement, and build type for Julia's garbage collector integration with MMTk. The supported variables are MMTK_PLAN (e.g., 'Immix' or 'StickyImmix'), MMTK_MOVING (1 or 0), and MMTK_BUILD ('release' or 'debug'). Setting these options tailors the GC configuration at build time. These settings must be defined before invoking Julia's build process and cannot be changed at runtime.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-mmtk.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nMMTK_PLAN=Immix\nMMTK_MOVING=0\nMMTK_BUILD=release\n```\n\nLANGUAGE: shell\nCODE:\n```\nMMTK_PLAN=StickyImmix\nMMTK_MOVING=1\nMMTK_BUILD=debug\n```\n\n----------------------------------------\n\nTITLE: Julia Make.user Configuration for Building with ASAN - Makefile\nDESCRIPTION: This Make.user configuration fragment lists all necessary Makefile variables and environment exports for building Julia with Address Sanitizer. It sets up the custom LLVM/Clang toolchain, compiler environment overrides, debug mode, GC debugging, sanitizer flags, ASAN-specific options, and disables problematic RTLD_DEEPBIND in dependent libraries. Each key allows for advanced customization, memory reduction, debug improvements, and instrumentation required for sanitizer workflows.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/sanitizers.md#_snippet_3\n\nLANGUAGE: make\nCODE:\n```\nTOOLCHAIN=$(TOOLCHAIN_WORKTREE)/usr/tools\\n\\n# use our new toolchain\\nUSECLANG=1\\noverride CC=$(TOOLCHAIN)/clang\\noverride CXX=$(TOOLCHAIN)/clang++\\nexport ASAN_SYMBOLIZER_PATH=$(TOOLCHAIN)/llvm-symbolizer\\n\\nUSE_BINARYBUILDER_LLVM=1\\n\\noverride SANITIZE=1\\noverride SANITIZE_ADDRESS=1\\n\\n# make the GC use regular malloc/frees, which are hooked by ASAN\\noverride WITH_GC_DEBUG_ENV=1\\n\\n# default to a debug build for better line number reporting\\noverride JULIA_BUILD_MODE=debug\\n\\n# make ASAN consume less memory\\nexport ASAN_OPTIONS=detect_leaks=0:fast_unwind_on_malloc=0:allow_user_segv_handler=1:malloc_context_size=2\\n\\nJULIA_PRECOMPILE=1\\n\\n# tell libblastrampoline to not use RTLD_DEEPBIND\\nexport LBT_USE_RTLD_DEEPBIND=0\n```\n\n----------------------------------------\n\nTITLE: Meta-programming: current_module replaced with @__MODULE__ - Julia\nDESCRIPTION: Outlines the deprecation of 'current_module' in favor of the macro '@__MODULE__' for meta-programming and reflection. Code is not included but macros and module inspection patterns are affected.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_163\n\n\n\n----------------------------------------\n\nTITLE: Building and Installing zlib for RISC-V Sysroot - sh\nDESCRIPTION: Details the process of building and manually copying the zlib dependency into the RISC-V sysroot if missing. The commands invoke the makefile target for zlib, then use 'cp' to move the library files (libz.*) and headers (z*.h) to appropriate locations in the sysroot. Prerequisites: successful build of zlib in Julia's 'deps' directory and write access to /opt/riscv/sysroot. This step may be repeated for additional missing system libraries.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/riscv.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nmake -C deps install-zlib\ncp -v usr/lib/libz.*   /opt/riscv/sysroot/usr/lib\ncp -v usr/include/z*.h /opt/riscv/sysroot/usr/include\n```\n\n----------------------------------------\n\nTITLE: Embedding LaTeX in Julia String Literals\nDESCRIPTION: This snippet demonstrates how LaTeX syntax within double backticks needs to be handled when embedded inside a Julia string literal. The backslash character (`\\`) must be escaped as `\\\\`.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n\"``\\\\LaTeX`` syntax in a docstring.\"\n```\n\n----------------------------------------\n\nTITLE: Invoking jl_breakpoint from Julia (Julia ccall)\nDESCRIPTION: This Julia code uses ccall to invoke the C function 'jl_breakpoint', which is typically triggered to allow the debugger to pause. 'obj' is passed along, allowing access to context or variables at the breakpoint. The function is void and takes a single Any parameter.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\nccall(:jl_breakpoint, Cvoid, (Any,), obj)\n```\n\n----------------------------------------\n\nTITLE: Generic Julia Command-line Launch (Console)\nDESCRIPTION: Shows the basic command to launch Julia using the executable from the system's PATH or directly if in the current directory. This starts the interactive Julia REPL.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_9\n\nLANGUAGE: console\nCODE:\n```\njulia\n\n```\n\n----------------------------------------\n\nTITLE: Using System BLAS Library for Julia Build (Makefile)\nDESCRIPTION: Configures the Julia build to use the system-installed BLAS library instead of bundling OpenBLAS, as a workaround for OpenBLAS build issues. Set `USE_SYSTEM_BLAS=1` in `Make.user`. Optionally, specify the exact library with `LIBBLAS` (e.g., `-lopenblas`) and `LIBBLASNAME` (e.g., `libopenblas`) if multiple BLAS implementations are present.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_9\n\nLANGUAGE: Makefile\nCODE:\n```\nUSE_SYSTEM_BLAS=1\n```\n\nLANGUAGE: Makefile\nCODE:\n```\nLIBBLAS=-lopenblas\n```\n\nLANGUAGE: Makefile\nCODE:\n```\nLIBBLASNAME=libopenblas\n```\n\n----------------------------------------\n\nTITLE: Stripping Leading Newline in Triple-Quoted Strings in Julia\nDESCRIPTION: Illustrates a feature of triple-quoted strings: if the opening `\"\"\"` is immediately followed by a newline character, that newline is automatically removed from the final string value. This makes formatting embedded code blocks cleaner.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/strings.md#_snippet_33\n\nLANGUAGE: julia\nCODE:\n```\n\"\"\"\nhello\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Listing Deprecated Thread Atomic Operations - Julia\nDESCRIPTION: This snippet marks and lists deprecated atomic operations within the Threads module using the documentation macro, preparing these APIs for documented reference. Includes atomic_cas!, atomic_xchg!, and arithmetic/logical atomic mutation functions. It serves to inform users about legacy APIs that remain available for compatibility, noting their deprecated status without removing their documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/multi-threading.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nBase.Threads.Atomic\\nBase.Threads.atomic_cas!\\nBase.Threads.atomic_xchg!\\nBase.Threads.atomic_add!\\nBase.Threads.atomic_sub!\\nBase.Threads.atomic_and!\\nBase.Threads.atomic_nand!\\nBase.Threads.atomic_or!\\nBase.Threads.atomic_xor!\\nBase.Threads.atomic_max!\\nBase.Threads.atomic_min!\\nBase.Threads.atomic_fence\\n```\n```\n\n----------------------------------------\n\nTITLE: Parsing Type Definition AST with Type Parameters – S-Expression\nDESCRIPTION: This snippet is the s-expression AST for a mutable Julia struct with type parameters. It encodes mutability, parameterized type variable constraint with <: (subtype), and field type associations, which are essential for construction of new types by code generation tools or for introspection.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ast.md#_snippet_7\n\nLANGUAGE: s-expression\nCODE:\n```\n(struct true (curly Foo (<: T S))\n        (block (line 2) (:: x T)))\n```\n\n----------------------------------------\n\nTITLE: Creating Display Equations with LaTeX in Markdown\nDESCRIPTION: This snippet demonstrates how to render large LaTeX equations as display blocks. This is achieved using a fenced code block with the language identifier set to `math`.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_19\n\nLANGUAGE: latex\nCODE:\n```\n```math\nf(a) = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} (\\alpha+R\\cos(\\theta))d\\theta\n```\n```\n\n----------------------------------------\n\nTITLE: Using LLD GNU Flavor on Windows (LLD)\nDESCRIPTION: On Windows, Julia instructs LLD to use `-flavor gnu` to emulate a MinGW32 linking environment. This avoids dependencies on `link.exe` and requires Julia to inject necessary stubs like `_DllMainCRTStartup`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n-flavor gnu\n```\n\n----------------------------------------\n\nTITLE: Listing Sockets API Elements for Documentation Generation in Julia\nDESCRIPTION: This `@docs` block lists various functions, types, and macros from the Julia `Sockets` standard library module. It directs the Julia documentation generator (like Documenter.jl) to automatically pull in and render the docstrings associated with each listed item, creating a comprehensive API reference page. It covers core socket operations (connect, listen, accept, send, recv), address information retrieval (getaddrinfo, getipaddr), socket types (TCPSocket, UDPSocket), IP address types (IPv4, IPv6), and configuration options (setopt, nagle, quickack).\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Sockets/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nSockets.Sockets\nSockets.connect(::TCPSocket, ::Integer)\nSockets.connect(::AbstractString)\nSockets.listen(::Any)\nSockets.listen(::AbstractString)\nSockets.getaddrinfo\nSockets.getipaddr\nSockets.getipaddrs\nSockets.islinklocaladdr\nSockets.getalladdrinfo\nSockets.DNSError\nSockets.getnameinfo\nSockets.getsockname\nSockets.getpeername\nSockets.IPAddr\nSockets.IPv4\nSockets.IPv6\nSockets.@ip_str\nSockets.TCPSocket\nSockets.UDPSocket\nSockets.accept\nSockets.listenany\nSockets.bind\nSockets.send\nSockets.recv\nSockets.recvfrom\nSockets.setopt\nSockets.nagle\nSockets.quickack\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying Multiple System Image Targets with JULIA_CPU_TARGET - Julia\nDESCRIPTION: This snippet demonstrates how to specify multiple compilation targets when building a Julia system image. Each target, separated by a semicolon, configures the build for different CPU microarchitectures and features using LLVM-style options, with special syntax for function cloning and base images. This approach is critical when distributing binaries optimized for a range of x86_64 processors, ensuring the system image selects the best available code paths at runtime. No additional dependencies are required beyond a Julia build environment; the example string is intended for use with system-image build commands.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/sysimg.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\ngeneric;sandybridge,-xsaveopt,clone_all;haswell,-rdrnd,base(1)\n```\n\n----------------------------------------\n\nTITLE: Cherry-picking commits for backporting - Git - Shell\nDESCRIPTION: Uses git cherry-pick to add specific commits (identified by SHA) to the prepared backporting branch, with '-x' to record the origin and '-e' to edit the commit message. Conflicts may occur and must be resolved manually. Prerequisites: Knowledge of target commit SHA and branch already created. Input: <sha> is the commit identifier to cherry-pick. Output: Selected commits replayed onto the current branch for release preparation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_9\n\nLANGUAGE: Shell\nCODE:\n```\ngit cherry-pick -x -e <sha>\n```\n\n----------------------------------------\n\nTITLE: Building LLVM/Clang and Julia with Sanitizer Flags - Makefile\nDESCRIPTION: This Makefile sequence illustrates how to orchestrate building both LLVM and Julia with sanitizer support, including disabling binary builder LLVM, setting the LLVM version, running the build for LLVM in deps, and configuring the core Julia build in src with necessary flags and environment variables. It shows how to override compiler paths and configure macOS-specific flags, as well as document how these can be persisted in Make.user for convenience. Prerequisite: matching Clang/LLVM sources and toolchain configuration.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/sanitizers.md#_snippet_1\n\nLANGUAGE: make\nCODE:\n```\nmake -C deps USE_BINARYBUILDER_LLVM=0 LLVM_VER=svn stage-llvm\\n\\nmake -C src SANITIZE=1 USECLANG=1 \\\\\\n    CC=~+/deps/scratch/llvm-svn/build_Release/bin/clang \\\\\\n    CXX=~+/deps/scratch/llvm-svn/build_Release/bin/clang++ \\\\\\n    CPPFLAGS=\"-isysroot $(xcode-select -p)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk\" \\\\\\n    CXXFLAGS=\"-isystem $(xcode-select -p)/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1\"\n```\n\n----------------------------------------\n\nTITLE: BPFnative.jl Example for Task Runtime Monitoring - Julia\nDESCRIPTION: This snippet refers to using BPFnative.jl, a Julia package capable of attaching to USDT probe points in a similar manner to bpftrace. The referenced example demonstrates monitoring task runtime, garbage collection, and thread state transitions directly from Julia scripts. Dependencies: BPFnative.jl, appropriate permissions, and system support for eBPF/USDT. Limitations: Actual code is not shown here, only its repository reference.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nhttps://github.com/jpsamaroo/BPFnative.jl/blob/master/examples/task-runtime.jl\n```\n\n----------------------------------------\n\nTITLE: Comparing Julia Objects for Equivalence (egal) in C\nDESCRIPTION: Declares the C function `jl_egal`, which implements the logic corresponding to Julia's `===` operator. It compares two Julia objects (`a` and `b`) for identity equivalence, correctly handling potential unboxed representations where object addresses might not be unique. Returns a non-zero integer if the objects are egal, and zero otherwise.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nint jl_egal(jl_value_t *a, jl_value_t *b);\n```\n\n----------------------------------------\n\nTITLE: Listing Array Constructors and Types via JuliaDoc Macros - Julia\nDESCRIPTION: Aggregates the major array types and constructors in Julia using the JuliaDoc `@docs` macro. This block includes core array types (such as `AbstractArray`, `Array`, `UndefInitializer`), subtype definitions (e.g., `DenseArray`, `StridedArray`), and functions for array creation and initialization. Intended for building documentation, it presumes the use of Julia's documentation system with dependencies on the core and base Julia libraries. Expected input is none (for documentation use), and output is auto-generated API documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/arrays.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCore.AbstractArray\nBase.AbstractVector\nBase.AbstractMatrix\nBase.AbstractVecOrMat\nCore.Array\nCore.Array(::UndefInitializer, ::Any)\nCore.Array(::Nothing, ::Any)\nCore.Array(::Missing, ::Any)\nCore.UndefInitializer\nCore.undef\nBase.Vector\nBase.Vector(::UndefInitializer, ::Any)\nBase.Vector(::Nothing, ::Any)\nBase.Vector(::Missing, ::Any)\nBase.Matrix\nBase.Matrix(::UndefInitializer, ::Any, ::Any)\nBase.Matrix(::Nothing, ::Any, ::Any)\nBase.Matrix(::Missing, ::Any, ::Any)\nBase.VecOrMat\nCore.DenseArray\nBase.DenseVector\nBase.DenseMatrix\nBase.DenseVecOrMat\nBase.StridedArray\nBase.StridedVector\nBase.StridedMatrix\nBase.StridedVecOrMat\nBase.GenericMemory\nBase.Memory\nBase.memoryref\nBase.Slices\nBase.RowSlices\nBase.ColumnSlices\nBase.getindex(::Type, ::Any...)\nBase.zeros\nBase.ones\nBase.BitArray\nBase.BitArray(::UndefInitializer, ::Integer...)\nBase.BitArray(::Any)\nBase.trues\nBase.falses\nBase.fill\nBase.fill!\nBase.empty\nBase.similar\n```\n```\n\n----------------------------------------\n\nTITLE: Documenting BigFloat and BigInt Utilities - Julia - Julia\nDESCRIPTION: References construction, configuration, and macro helpers for arbitrary-precision floating point and integer types (BigFloat and BigInt) via a Julia @docs block. Functions relate to precision settings and conversion from other types, often relying on GNU MPFR and GMP libraries under the hood. This is for documentation purposes to aid users working with high precision arithmetic; intended solely for display, not for code execution.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/numbers.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nBase.MPFR.BigFloat(::Any, rounding::RoundingMode)\\nBase.precision\\nBase.MPFR.setprecision\\nBase.GMP.BigInt(::Any)\\nBase.@big_str\\n```\n```\n\n----------------------------------------\n\nTITLE: Output from Interpreted println via libuv\nDESCRIPTION: This represents the standard output generated by executing `println(\"Hello World!\")` when run through Julia's interpreter. The output is written to `JL_STDOUT` using the `uv_write` function from libuv, called via `jl_uv_write` as part of the execution path initiated by `Core.eval`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/init.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nHello World!\n```\n\n----------------------------------------\n\nTITLE: Documenting Markdown API Reference - Markdown\nDESCRIPTION: This snippet specifies a list of Julia Markdown API components using documentation macro syntax. It uses the @docs macro inside a markdown code block to enumerate relevant functions and types from the Markdown module, such as Markdown.MD, Markdown.@md_str, and Markdown.parse. Dependencies include the Julia Documentation system and the Markdown stdlib. Inputs are the function/type identifiers; output is rendered API documentation in the generated docs. This is intended for use in Julia's documentation pipeline.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_26\n\nLANGUAGE: markdown\nCODE:\n```\n```@docs\nMarkdown.MD\nMarkdown.@md_str\nMarkdown.@doc_str\nMarkdown.parse\nMarkdown.html\nMarkdown.latex\n```\n```\n\n----------------------------------------\n\nTITLE: Enhanced Sparse Array Products with General Element Types in Julia\nDESCRIPTION: Products involving sparse arrays in Julia now support more general element types (`eltype`), including types like `StaticArrays`, increasing flexibility.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_101\n\n\n\n----------------------------------------\n\nTITLE: Building Julia with Address Sanitizer Support - Shell\nDESCRIPTION: This shell script demonstrates how to configure and build Julia with Address Sanitizer by invoking a custom build script and specifying a build output directory. The script creates a directory and then runs the build.sh script found in contrib/asan to configure Julia with ASAN. The built Julia binary can then be tested from the output directory to detect memory errors, as the sanitizer will report any issues during workload execution.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/sanitizers.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ mkdir /tmp/julia\\n$ contrib/asan/build.sh /tmp/julia/\n```\n\n----------------------------------------\n\nTITLE: Installing Julia via curl script on Mac/Linux\nDESCRIPTION: Downloads and executes the official Julia installation script using curl. This script handles the installation of Juliaup, which then manages Julia versions. The '-fsSL' flags ensure curl fails silently on server errors, doesn't show progress, and follows redirects.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/installation.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl -fsSL https://install.julialang.org | sh\n```\n\n----------------------------------------\n\nTITLE: Cartesian to Linear Index Mapping - Julia\nDESCRIPTION: This snippet provides a method to convert Cartesian indices returned by 'findall' into linear indices using 'LinearIndices'. This is crucial when porting code that assumes linear indexing (as prior versions of Julia did). Requires input of an AbstractArray; output will be a list of linear indices corresponding to the 'findall' results.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_146\n\nLANGUAGE: julia\nCODE:\n```\nLinearIndices(a)[findall(f, a)]\n```\n\n----------------------------------------\n\nTITLE: Defining DebugInfo Structs for Julia IR and Compiler (Julia)\nDESCRIPTION: These code snippets define two structures, Core.DebugInfo (immutable, used internally) and Core.Compiler.DebugInfoStream (mutable, used in the compiler), for tracking source line numbers and inlining relationships within Julia\\'s code intermediate representation. The DebugInfo struct holds compressed codeloc data as a string, while DebugInfoStream expands this into accessible vectors, including explicit tracking of the starting line, all inlined edge blocks, and stacktrace indices. Both depend on core Julia types such as Method, MethodInstance, SimpleVector, and Vector; code consumers may need to reference internal Julia modules for types and functions like Base.IRShow.buildLineInfoNode. Inputs are typically constructed at runtime by the compiler; fields reference methods, encoded code-locations, or subgraphs of inlining. Outputs are indirection-rich tree structures efficiently capturing execution provenance, designed for compiler passes and tools to reconstruct source-level information from IR. Limitations include a non-public internal API and dependencies on the internal code representation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ast.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\nstruct Core.DebugInfo\n    @noinline\n    def::Union{Method,MethodInstance,Symbol}\n    linetable::Union{Nothing,DebugInfo}\n    edges::SimpleVector{DebugInfo}\n    codelocs::String # compressed data\nend\nmutable struct Core.Compiler.DebugInfoStream\n    def::Union{Method,MethodInstance,Symbol}\n    linetable::Union{Nothing,DebugInfo}\n    edges::Vector{DebugInfo}\n    firstline::Int32 # the starting line for this block (specified by an index of 0)\n    codelocs::Vector{Int32} # for each statement:\n        # index into linetable (if defined), else a line number (in the file represented by def)\n        # then index into edges\n        # then index into edges[linetable]\nend\n```\n\n----------------------------------------\n\nTITLE: Creating Hyperlinks in Markdown\nDESCRIPTION: This snippet demonstrates the Markdown syntax for creating hyperlinks. The link text is enclosed in square brackets (`[]`) and the target URL is enclosed in parentheses (`()`).\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\nA paragraph containing a link to [Julia](https://www.julialang.org).\n```\n\n----------------------------------------\n\nTITLE: Creating Ordered Lists in Markdown\nDESCRIPTION: These snippets illustrate creating ordered lists using numbers followed by a period (`.`) or a closing parenthesis (`)`). Lists can start from any number. Nested elements are allowed as with unordered lists.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_18\n\nLANGUAGE: markdown\nCODE:\n```\nTwo ordered lists:\n\n 1. item one\n 2. item two\n 3. item three\n\n 5) item five\n 6) item six\n 7) item seven\n```\n\n----------------------------------------\n\nTITLE: Verifying DTrace Probe Presence - ELF Note Inspection - Bash\nDESCRIPTION: This bash example demonstrates using the readelf utility to examine probe metadata within the compiled Julia library. It extracts ELF notes related to SystemTap probe descriptors to confirm probe availability. Requires the ELF binary of Julia and readelf installed. Outputs probe information for analysis.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/probes.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n> readelf -n usr/lib/libjulia-internal.so.1\n\nDisplaying notes found in: .note.gnu.build-id\n  Owner                Data size  Description\n  GNU                  0x00000014 NT_GNU_BUILD_ID (unique build ID bitstring)\n    Build ID: 57161002f35548772a87418d2385c284ceb3ead8\n\nDisplaying notes found in: .note.stapsdt\n  Owner                Data size  Description\n  stapsdt              0x00000029 NT_STAPSDT (SystemTap probe descriptors)\n    Provider: julia\n    Name: gc__begin\n    Location: 0x000000000013213e, Base: 0x00000000002bb4da, Semaphore: 0x0000000000346cac\n    Arguments:\n  stapsdt              0x00000032 NT_STAPSDT (SystemTap probe descriptors)\n    Provider: julia\n    Name: gc__stop_the_world\n    Location: 0x0000000000132144, Base: 0x00000000002bb4da, Semaphore: 0x0000000000346cae\n    Arguments:\n  stapsdt              0x00000027 NT_STAPSDT (SystemTap probe descriptors)\n    Provider: julia\n    Name: gc__end\n    Location: 0x000000000013214a, Base: 0x00000000002bb4da, Semaphore: 0x0000000000346cb0\n    Arguments:\n  stapsdt              0x0000002d NT_STAPSDT (SystemTap probe descriptors)\n    Provider: julia\n    Name: gc__finalizer\n    Location: 0x0000000000132150, Base: 0x00000000002bb4da, Semaphore: 0x0000000000346cb2\n    Arguments:\n\n```\n\n----------------------------------------\n\nTITLE: Installing Xcode Command Line Tools on macOS (Shell)\nDESCRIPTION: Recommends the command for macOS users to update/install Xcode command line tools using 'xcode-select'. This step is essential after OS upgrades to avoid linker problems or missing headers during build.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nxcode-select --install\n\n```\n\n----------------------------------------\n\nTITLE: Cleaning/Rebuilding a Dependency from Make (Makefile)\nDESCRIPTION: Provides make targets for cleaning existing builds of a dependency (e.g., llvm) from the 'deps' directory. 'clean-llvm' wipes build artifacts for the dependency; 'distclean-llvm' additionally removes source distributions for full reset. Essential for troubleshooting dependency-related build issues.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_11\n\nLANGUAGE: make\nCODE:\n```\nmake -C deps clean-llvm\nmake -C deps distclean-llvm\n\n```\n\n----------------------------------------\n\nTITLE: Removing Compiler IR During Julia System Image Build (Bash)\nDESCRIPTION: Describes the `--strip-ir` command-line option for Julia system image building. It removes the compiler's Intermediate Representation (IR) of source code. A system image built with this option requires either using `--compile=all` at runtime or ensuring all necessary code was precompiled into the image.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\n--strip-ir\n```\n\nLANGUAGE: bash\nCODE:\n```\n--compile=all\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Documentation System Components\nDESCRIPTION: This block uses the `@docs` directive to list core components of Julia's built-in documentation system. It includes the `@doc` macro for attaching documentation strings, types for representing documentation formats (`Docs.HTML`, `Docs.Text`), and utilities for checking documentation existence (`Docs.hasdoc`) and finding undocumented names (`Docs.undocumented_names`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_19\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.@doc\nDocs.HTML\nDocs.Text\nDocs.hasdoc\nDocs.undocumented_names\n```\n```\n\n----------------------------------------\n\nTITLE: Lowering a ccall Expression to Julia IR\nDESCRIPTION: Shows a hypothetical Julia IR lowering for a `ccall`, using `Expr(:foreigncall, ...)` constructs to represent a foreign function invocation. Dependencies include Julia's compiler, and the IR requires explicit handling of GC rooting by passing relevant values (such as `A`) as an extra argument. The top-level expression encodes the call to the foreign function with explicit conversion and lifetime handling for GC.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\nreturn $(Expr(:foreigncall, :(:foo), Cvoid, svec(Ptr{Float64}), 0, :(:ccall), Expr(:foreigncall, :(:jl_array_ptr), Ptr{Float64}, svec(Any), 0, :(:ccall), :(A)), :(A)))\n```\n\n----------------------------------------\n\nTITLE: Listing Multimedia I/O Functions/Types in Julia Base\nDESCRIPTION: This snippet employs the `@docs` macro to list functions and types from Julia's Base and Base.Multimedia modules relevant to handling rich multimedia output. It includes the core `display` function, types like `AbstractDisplay` and `MIME`, utilities for checking displayability (`displayable`, `showable`), and functions for getting representations (`show`, `repr`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/io-network.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.AbstractDisplay\nBase.Multimedia.display\nBase.Multimedia.redisplay\nBase.Multimedia.displayable\nBase.show(::IO, ::Any, ::Any)\nBase.Multimedia.showable\nBase.repr(::MIME, ::Any)\nBase.MIME\nBase.@MIME_str\n```\n```\n\n----------------------------------------\n\nTITLE: Constructing Parametric and Array Types in C\nDESCRIPTION: Declares C functions for creating specific Julia type objects. `jl_apply_type` constructs a parametric type (e.g., `Vector{Int}`) by applying type parameters (`params`, a Julia Tuple) to a type constructor (`tc`, e.g., `Vector`). `jl_apply_array_type` constructs an array type (e.g., `Array{Float64, 2}`) given the element type (`type`) and dimensionality (`dim`). Both return a `jl_datatype_t*`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_11\n\nLANGUAGE: c\nCODE:\n```\njl_datatype_t *jl_apply_type(jl_datatype_t *tc, jl_tuple_t *params);\njl_datatype_t *jl_apply_array_type(jl_datatype_t *type, size_t dim);\n```\n\n----------------------------------------\n\nTITLE: Generating Function Reference Documentation with Future Module - Julia\nDESCRIPTION: This snippet invokes Julia's documentation macro to auto-generate reference pages for the Future module's functions, copy! and randjump. It requires the documented functions to be available in the module search path at documentation build time. Outputs are formatted according to the Julia Documenter.jl standard, and only valid with compatible documentation toolchains.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Future/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nFuture.copy!\nFuture.randjump\n```\n```\n\n----------------------------------------\n\nTITLE: Listing Serialization APIs in Julia - Julia\nDESCRIPTION: This code block enumerates key serialization-related functions in Julia: Serialization.serialize, Serialization.deserialize, and Serialization.writeheader. It is used in Julia documentation to automatically generate reference sections for each function, helping users discover and understand their interfaces and usage. The block assumes the Julia documentation system (DocStringExtensions or Documenter.jl) which parses the function signatures and docstrings, and does not execute code directly; rather, it enables dynamic documentation rendering.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Serialization/docs/src/index.md#_snippet_0\n\nLANGUAGE: Julia\nCODE:\n```\n```@docs\nSerialization.serialize\nSerialization.deserialize\nSerialization.writeheader\n```\n```\n\n----------------------------------------\n\nTITLE: Evaluating Polynomials with `@evalpoly` Macro (Legacy) in Julia\nDESCRIPTION: Shows the usage of the `@evalpoly` macro for evaluating a polynomial at `x` with coefficients `p1, p2, p3`. This macro is now recommended to be replaced by the more flexible `evalpoly` function.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_88\n\nLANGUAGE: julia\nCODE:\n```\n@evalpoly(x, p1, p2, p3)\n```\n\n----------------------------------------\n\nTITLE: Installing Custom LLVM/Clang Toolchain for Julia Sanitizers - Shell\nDESCRIPTION: This shell script sets up a custom LLVM/Clang toolchain for use with Julia sanitizers by configuring Make.user with required build flags and running make to install LLVM, Clang, and related tools in a dedicated worktree directory. This ensures toolchain compatibility and allows Julia builds to use a known-good compiler set. The script must be run in the toolchain worktree directory, and the installed tools appear in a specified subdirectory.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/sanitizers.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncd $TOOLCHAIN_WORKTREE\\nmake -C deps install-llvm install-clang install-llvm-tools\n```\n\n----------------------------------------\n\nTITLE: Installing LLVM Developer Tools for Julia (Bash)\nDESCRIPTION: This make command installs LLVM developer utilities required for advanced debugging and manipulation of LLVM IR in relation to Julia. It must be run within the Julia project directory, assuming Makefile and dependency targets are properly set up. The target installs tools such as opt and llc for further use.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake -C deps install-llvm-tools\n```\n\n----------------------------------------\n\nTITLE: Using LLD Flavor Option for Cross-Platform Linking (LLD)\nDESCRIPTION: The LLD linker's `-flavor` option is used by Julia to set the linker's behavior according to the target platform (e.g., Windows, macOS), ensuring correct linking despite LLD's non-uniform cross-platform interface.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nlld -flavor\n```\n\n----------------------------------------\n\nTITLE: Allowing Undefined Symbols on macOS (Linker Flag)\nDESCRIPTION: The `-undefined dynamic_lookup` linker flag is used on macOS, particularly when `-lSystem` might not be directly available. It instructs the linker to allow unresolved symbols at link time, resolving them dynamically at runtime.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n-undefined dynamic_lookup\n```\n\n----------------------------------------\n\nTITLE: Building Julia macOS framework - Makefile - Shell\nDESCRIPTION: Enables macOS Julia builds as a framework by invoking 'make' with 'darwinframework' target and 'DARWIN_FRAMEWORK=1'. This alters build output and packaging for special integration with macOS features. Prerequisites: macOS development tools and a Julia source checkout. Input: 'DARWIN_FRAMEWORK=1 darwinframework' as arguments to make. Output: Julia built as a macOS framework.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nmake DARWIN_FRAMEWORK=1 darwinframework\n```\n\n----------------------------------------\n\nTITLE: Creating Detached GPG Signature for Linux Tarball\nDESCRIPTION: This shell command uses `gpg` to generate a detached digital signature for a specified Julia Linux release tarball (e.g., `julia-x.y.z-linux-<arch>.tar.gz`). The `-u julia` option specifies the signing key to use, `--armor` ensures the output signature is in ASCII-armored format, and `--detach-sig` creates the signature in a separate file with a `.asc` extension, rather than embedding it.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_18\n\nLANGUAGE: gpg\nCODE:\n```\ngpg -u julia --armor --detach-sig julia-x.y.z-linux-<arch>.tar.gz\n```\n\n----------------------------------------\n\nTITLE: Resetting Julia Source Tree with Git (Shell)\nDESCRIPTION: Shows commands to forcibly reset any changes in the Julia Git source tree and remove untracked files or directories. Warning: these commands are destructive and cannot be undone by Git. Used as a last resort to return to a pristine source state.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\ngit reset --hard #Forcibly remove any changes to any files under version control\ngit clean -x -f -d #Forcibly remove any file or directory not under version control\n\n```\n\n----------------------------------------\n\nTITLE: Building Julia and Running LLVM Pass Tests (Shell)\nDESCRIPTION: Provides the sequence of `make` commands required to prepare the environment and execute the LLVM pass tests for Julia. It includes installing necessary LLVM tools from the Julia repository's dependencies, building the Julia release version, and running the specific LLVM pass tests located in `test/llvmpasses`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nmake -C deps install-llvm-tools\nmake -j julia-src-release\nmake -C test/llvmpasses\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Type Relation Functions for Documentation\nDESCRIPTION: This block uses the `@docs` directive to list functions and types related to Julia's type system hierarchy and relationships, including subtyping checks (`<:`), supertype retrieval, type joining/intersection, and type promotion rules. It guides the documentation generator to include these under the 'Type relations' subcategory within 'Properties of Types'.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.supertype\nCore.Type\nCore.DataType\nCore.:(<:)\nBase.:(>:)\nBase.typejoin\nBase.typeintersect\nBase.promote_type\nBase.promote_rule\nBase.promote_typejoin\nBase.isdispatchtuple\n```\n```\n\n----------------------------------------\n\nTITLE: Executing BOLT Optimization Build Steps for Julia using Make (Bash)\nDESCRIPTION: This sequence of Bash commands executes the necessary `make` targets to build a BOLT-optimized version of Julia. It assumes the user has changed directory (`cd`) into the correct location as mentioned in the surrounding text. The process involves staging, copying originals, instrumenting, finishing the stage, merging profile data, and finally running BOLT. The optimized build result will be located in the `optimized.build` directory.\nSOURCE: https://github.com/julialang/julia/blob/master/contrib/bolt/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake stage1\nmake copy_originals\nmake bolt_instrument\nmake finish_stage1\nmake merge_data\nmake bolt\n```\n\n----------------------------------------\n\nTITLE: Running Built Julia Executable from Build Directory (Shell)\nDESCRIPTION: Illustrates how to execute the Julia binary directly from the build directory after compilation using a relative path. No dependencies needed beyond a successful build. This launches an interactive Julia REPL if run successfully.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n./julia\n\n```\n\n----------------------------------------\n\nTITLE: Illustrating Conditional Error Path for GC Root Placement (Julia)\nDESCRIPTION: Presents a Julia code snippet containing a conditional block that calls the `error` function. This example serves to illustrate the benefits of late GC root placement; if LLVM determines `some_condition()` is always false, it can eliminate this block entirely, which might be hindered if GC roots for variables used within the block were placed earlier in the compilation pipeline.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nif some_condition()\n    #= Use some variables maybe =#\n    error(\"An error occurred\")\nend\n```\n\n----------------------------------------\n\nTITLE: Installing Static Analyzer Dependencies - Make/Unix Shell - sh\nDESCRIPTION: This shell command, intended to be run from Julia's toplevel directory, installs all dependencies required for the static analyzer plugin by invoking a target in the Makefile under the src directory. Requires GNU make and write permissions for dependencies installation directories.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-sa.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nmake -C src install-analysis-deps\n```\n\n----------------------------------------\n\nTITLE: Enabling System Library Usage in Julia Build (Makefile)\nDESCRIPTION: A Makefile variable set in `Make.user` to indicate that Julia should link against a system-provided version of an external library (e.g., `USE_SYSTEM_LLVM=1`) instead of the bundled one. This flag should be used with caution and is primarily for troubleshooting or packaging. Requires the corresponding library development package to be installed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\nUSE_SYSTEM_XXX=1\n```\n\n----------------------------------------\n\nTITLE: Invoking Julia Build with Customized Cross-Compiler PATH - sh\nDESCRIPTION: Demonstrates how to run Julia's make with the RISC-V cross-compiler toolchain in PATH to ensure the correct compilers are found. PATH is prepended with /opt/riscv/bin so 'make' uses the cross tools, and '-j$(nproc)' parallelizes the build. No special parameters beyond correct installation of the cross-compiler toolchain in /opt/riscv/bin.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/riscv.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nPATH=/opt/riscv/bin:$PATH make -j$(nproc)\n```\n\n----------------------------------------\n\nTITLE: Creating a backport branch for point releases - Git - Shell\nDESCRIPTION: This command sequence fetches the latest upstream branches, rebases the local 'release-x.y' branch, and creates a new backport branch (following the 'initials/backport-x.y' naming convention). Essential for patch/point release workflows in Julia development. Dependencies: Git client configured with access to repository. Input: Substitute 'x.y' with appropriate Julia minor version. Output: New branch ready for cherry-picking backported commits.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\ngit fetch origin\ngit checkout release-x.y\ngit rebase origin/release-x.y\ngit checkout -b js/backport-x.y\n```\n\n----------------------------------------\n\nTITLE: `mean` Function with Function Argument and `dims` Keyword in Julia\nDESCRIPTION: The `mean` function in `Statistics` now accepts both a function argument (to apply before averaging) and a `dims` keyword argument simultaneously.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_141\n\nLANGUAGE: julia\nCODE:\n```\nusing Statistics\nA = [1 2; 3 4]\nmean(abs2, A, dims=1) # Calculate mean of squares along dimension 1\n```\n\n----------------------------------------\n\nTITLE: Setting MCPU for ARMv7-A Compatibility in Makefile\nDESCRIPTION: Adds `MCPU=armv7-a` to the `Make.user` file. This setting might be necessary on Raspberry Pi 2 builds if failures occur due to unsupported inline assembly, potentially related to the specific compiler and distribution being used.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/arm.md#_snippet_4\n\nLANGUAGE: Makefile\nCODE:\n```\nMCPU=armv7-a\n```\n\n----------------------------------------\n\nTITLE: Removed `dot` Export from BLAS Submodule in Julia\nDESCRIPTION: The `LinearAlgebra.BLAS` submodule no longer exports the `dot` function to avoid conflicts with the `dot` function exported directly from `LinearAlgebra`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_131\n\n\n\n----------------------------------------\n\nTITLE: Printing Uncompressed AST in to_function Frame (GDB Command)\nDESCRIPTION: This GDB sequence demonstrates extracting the AST for a Julia method instance by first calling jl_uncompress_ast and then displaying the result with jl_. Requires function and AST pointers as arguments. Useful for internal debugging of Julia's JIT compilation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_6\n\nLANGUAGE: gdb\nCODE:\n```\n(gdb) p jl_(jl_uncompress_ast(li, li->ast))\n```\n\n----------------------------------------\n\nTITLE: Building Julia Debug Version with ASAN - Shell\nDESCRIPTION: This shell snippet demonstrates how to invoke make to build the debug version of Julia (julia-debug) inside a configured worktree where Make.user is already set up for Address Sanitizer. The target assumes that all required environment variables and toolchain paths are prepopulated. This build produces a Julia binary with full sanitizer instrumentation for advanced memory diagnostics.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/sanitizers.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ncd $BUILD_WORKTREE\\nmake debug\n```\n\n----------------------------------------\n\nTITLE: Consistency Checks for `SparseMatrixCSC` Constructor in Julia\nDESCRIPTION: The `SparseMatrixCSC(m, n, colptr, rowval, nzval)` constructor now performs consistency checks on its arguments, ensuring `colptr` is valid and array lengths (`colptr`, `rowval`, `nzval`) are compatible with dimensions `m`, `n` and the element type of `colptr`.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_137\n\nLANGUAGE: julia\nCODE:\n```\nusing SparseArrays\n# Example: Constructor now validates inputs\n# SparseMatrixCSC(m, n, colptr, rowval, nzval)\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Lists and Blocks within Lists in Markdown\nDESCRIPTION: This snippet shows how to nest lists and include other toplevel elements like code blocks within list items in Markdown. Blank lines are required between list items containing toplevel elements, and indentation must be consistent.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_17\n\nLANGUAGE: markdown\nCODE:\n```\nAnother list:\n\n  * item one\n\n  * item two\n\n    ```\n    f(x) = x\n    ```\n\n  * And a sublist:\n\n      + sub-item one\n      + sub-item two\n```\n\n----------------------------------------\n\nTITLE: Assigning Rooting with JL_ROOTING_ARGUMENT and JL_ROOTED_ARGUMENT - Julia GC Static Analyzer - C\nDESCRIPTION: The code demonstrates the assignment-side rooting macros JL_ROOTING_ARGUMENT and JL_ROOTED_ARGUMENT, which declare that assigning a value into a rooted structure will propagate rooting, so GC safety is preserved across safepoints. Used for writing safer setter functions with the Julia GC. Requires analyzer_annotations.h and proper macro markup.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-sa.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nvoid jl_svecset(void *t JL_ROOTING_ARGUMENT, size_t i, void *x JL_ROOTED_ARGUMENT) JL_NOTSAFEPOINT\n\n\nsize_t example(jl_svec_t *svec) {\n  jl_value_t *val = jl_box_long(10000);\n  jl_svecset(svec, val);\n  // This is valid, because the annotations imply that the\n  // jl_svecset propagates the rooted-ness from `svec` to `val`\n  jl_gc_safepoint();\n  return jl_unbox_long(val);\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting AbstractLogger Interface Methods (Julia Docs)\nDESCRIPTION: A directive for Julia's documentation generator (Documenter.jl) to include documentation for the core functions that define the `AbstractLogger` interface, used for processing log events (handle_message, shouldlog, min_enabled_level, catch_exceptions, disable_logging).\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Logging/docs/src/index.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nLogging.AbstractLogger\nLogging.handle_message\nLogging.shouldlog\nLogging.min_enabled_level\nLogging.catch_exceptions\nLogging.disable_logging\n```\n\n----------------------------------------\n\nTITLE: Debugging sys0 Build Phase (Shell Command with GDB)\nDESCRIPTION: Invokes gdb with arguments set to run Julia in build mode for the sys0 build phase. Allows debugging low-level system image generation errors. Should be run from the 'base' directory; adjusts to your local path structure and build setup.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\njulia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys0 sysimg.jl\n```\n\n----------------------------------------\n\nTITLE: Declaring Leaftype-rooted Functions in Julia's C Backend (C)\nDESCRIPTION: Demonstrates annotating a function return as always rooted through leaftype guarantees, using JL_ALWAYS_LEAFTYPE. This example declares jl_apply_array_type as returning a rooted type based on Julia type system invariants. This relies on implementation details where leaftypes are cached and module-rooted. Requires inclusion of Julia's API and proper macro definitions. Expects type and dimension parameters; returns a boxed array type that should be memory-safe under GC analysis. Limitation: only appropriate for functions returning leaftypes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-sa.md#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nJL_DLLEXPORT jl_value_t *jl_apply_array_type(jl_value_t *type, size_t dim) JL_ALWAYS_LEAFTYPE;\n```\n\n----------------------------------------\n\nTITLE: Filtering Arrays in MATLAB using Logical Indexing\nDESCRIPTION: MATLAB commonly uses logical indexing to filter arrays (`x(x>3)`) or remove elements in-place (`x(x>3) = []`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/noteworthy-differences.md#_snippet_24\n\nLANGUAGE: matlab\nCODE:\n```\nx(x>3)\n```\n\nLANGUAGE: matlab\nCODE:\n```\nx(x>3) = []\n```\n\n----------------------------------------\n\nTITLE: Incorrect Element Type Extraction via supertype Traversal - Julia\nDESCRIPTION: These methods attempt to extract the element type by recursively traversing the supertype chain of AbstractArray subtypes. They define methods for AbstractArray with one or two type parameters and use eltype_wrong(supertype(A)) for generic subtypes. This approach fails for types without proper supertypes or where the hierarchy does not match expectations. The example does not require external dependencies.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/methods.md#_snippet_24\n\nLANGUAGE: julia\nCODE:\n```\neltype_wrong(::Type{AbstractArray{T}}) where {T} = T\neltype_wrong(::Type{AbstractArray{T, N}}) where {T, N} = T\neltype_wrong(::Type{A}) where {A<:AbstractArray} = eltype_wrong(supertype(A))\n```\n\n----------------------------------------\n\nTITLE: Triggering Nanosoldier Benchmarks via GitHub Comment\nDESCRIPTION: This markdown comment is used on a GitHub pull request to instruct the Nanosoldier bot to run all registered benchmarks. It compares the current branch against the specified base branch (e.g., `:release-x.y`) to detect performance regressions or improvements introduced by the pull request.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n@nanosoldier `runbenchmarks(ALL, vs=\":release-x.y\")`\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom LLVM Build in Julia Makefile (Make.user)\nDESCRIPTION: These Makefile variables, typically placed in `Make.user`, allow customization of the LLVM build process when compiling Julia. They enable forcing a source build (`USE_BINARYBUILDER_LLVM=0`), specifying a Git repository (`DEPS_GIT`, `LLVM_GIT_URL`), branch (`LLVM_BRANCH`), commit (`LLVM_SHA1`), target architectures (`LLVM_TARGETS`), and enabling build optimizations or debugging (`USECCACHE`, `CMAKE_GENERATOR`, `LLVM_ASSERTIONS`, `LLVM_DEBUG`). Using an unpatched or different version of LLVM than the one specified by Julia maintainers is not officially supported and may lead to errors or poor performance.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_18\n\nLANGUAGE: make\nCODE:\n```\n# Force source build of LLVM\nUSE_BINARYBUILDER_LLVM = 0\n# Use Git for fetching LLVM source code\n# this is either `1` to get all of them\nDEPS_GIT = 1\n# or a space-separated list of specific dependencies to download with git\nDEPS_GIT = llvm\n\n# Other useful options:\n#URL of the Git repository you want to obtain LLVM from:\n#  LLVM_GIT_URL = ...\n#Name of the alternate branch to clone from git\n#  LLVM_BRANCH = julia-16.0.6-0\n#SHA hash of the alternate commit to check out automatically\n#  LLVM_SHA1 = $(LLVM_BRANCH)\n#List of LLVM targets to build. It is strongly recommended to keep at least all the\n#default targets listed in `deps/llvm.mk`, even if you don't necessarily need all of them.\n#  LLVM_TARGETS = ...\n#Use ccache for faster recompilation in case you need to restart a build.\n#  USECCACHE = 1\n#  CMAKE_GENERATOR=Ninja\n#  LLVM_ASSERTIONS=1\n#  LLVM_DEBUG=Symbols\n```\n\n----------------------------------------\n\nTITLE: Intrinsic Declaration for pointer_from_objref in LLVM IR\nDESCRIPTION: Declares a custom LLVM intrinsic used by Julia to handle address space casting from managed to unmanaged pointers. The caller is responsible for ensuring that the returned pointer is still GC-rooted. Only to be used when explicit control of object lifetime is handled by the programmer. Not GC-safe by default.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_14\n\nLANGUAGE: llvm\nCODE:\n```\ndeclared %jl_value_t *julia.pointer_from_objref(%jl_value_t addrspace(10)*)\n```\n\n----------------------------------------\n\nTITLE: Internal Low-Level Julia Object Allocation Functions in C\nDESCRIPTION: Declares internal C functions used within the Julia runtime for object allocation, typically called by higher-level functions. `newstruct` allocates memory for a struct instance based on its type definition (`type`). `newobj` allocates memory for specific object types that might require special handling or layout, taking the type (`type`) and the number of fields (`nfields`) if applicable. These are generally not intended for direct use when embedding Julia.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_17\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *newstruct(jl_value_t *type);\njl_value_t *newobj(jl_value_t *type, size_t nfields);\n```\n\n----------------------------------------\n\nTITLE: Configuring Edit URL for Julia Documentation\nDESCRIPTION: This `@meta` block sets the `EditURL` variable for the Julia documentation generator. This URL points to the source file on GitHub, allowing readers to easily suggest edits or view the original Markdown file.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Sockets/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nEditURL = \"https://github.com/JuliaLang/julia/blob/master/stdlib/Sockets/docs/src/index.md\"\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Simultaneous Execution of Phi Nodes (Julia IR)\nDESCRIPTION: This Julia IR snippet shows two Phi nodes (`%45`, `%46`) at the beginning of a basic block. It illustrates that Phi nodes execute conceptually simultaneously based on the state *before* entering the block. If control flow comes from block `#23`, the value assigned to `%46` uses the value `%45` held *prior* to entering this block, not the new value assigned to `%45` by the first Phi node (`#23 => %50`) within this block.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\n%45 = φ (#18 => %23, #23 => %50)\n%46 = φ (#18 => 1.0, #23 => %45)\n```\n\n----------------------------------------\n\nTITLE: Desired Reindexing Output with CartesianIndex in Julia\nDESCRIPTION: This Julia code snippet represents the conceptually correct tuple structure that `Base.reindex` *should* produce for a specific hypothetical scenario involving a view `S1` and `CartesianIndex` arguments. It shows how the individual components of the `CartesianIndex(2,1)` are intended to be distributed and used to index into the appropriate stored indices (`S1.indices`), skipping the empty `CartesianIndex()`. This illustrates the ideal, albeit computationally complex, reindexing logic.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\n(CartesianIndex(2,1)[1], S1.indices[2], S1.indices[3][CartesianIndex(2,1)[2]])\n```\n\n----------------------------------------\n\nTITLE: Example JITLink Memory Allocation Error Message\nDESCRIPTION: Shows an example error message `JIT session error: Cannot allocate memory` that can occur on Linux when running Julia v1.10+ on AArch64 with LLVM 15+ and JITLink enabled. This error typically indicates that the process has exceeded the system's maximum allowed memory mappings (`vm.max_map_count`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/arm.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nJIT session error: Cannot allocate memory\n```\n\n----------------------------------------\n\nTITLE: Referencing the Library Search Path Environment Variable (Shell)\nDESCRIPTION: Mentions the `LD_LIBRARY_PATH` environment variable as an alternative to using `rpath` via `LDFLAGS` for specifying non-standard library locations. The dynamic linker will search directories listed in `LD_LIBRARY_PATH` at both compile and run time when looking for shared libraries.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\nLD_LIBRARY_PATH\n```\n\n----------------------------------------\n\nTITLE: Requesting Documentation for Pidfile Primary Functions (Julia)\nDESCRIPTION: Uses the Documenter.jl `@docs` macro to request the inclusion of documentation for primary functions (`mkpidlock`, `trymkpidlock`, `close`) related to PID file locking within the `FileWatching.Pidfile` module.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/FileWatching/docs/src/index.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\n@docs\nmkpidlock\ntrymkpidlock\nclose(lock::LockMonitor)\n```\n\n----------------------------------------\n\nTITLE: Generating Julia Logo with Luxor - Julia\nDESCRIPTION: This Julia snippet uses the Luxor package to programmatically draw and export the Julia logo to an SVG file named 'julia-dots.svg'. It creates a drawing canvas with specific dimensions, sets the origin, performs a translation transformation, and draws the Julia circles using a custom function. Dependencies include the Luxor Julia package and the availability of the 'juliacircles' function. Inputs are drawing dimensions and the output path; output is an SVG file ready for further rasterization or use. The code assumes 'juliacircles' is defined elsewhere, and the output filename is dynamically constructed from the current working directory.\nSOURCE: https://github.com/julialang/julia/blob/master/contrib/windows/icon-readme.md#_snippet_0\n\nLANGUAGE: Julia\nCODE:\n```\nusing Luxor\\nDrawing(325, 325, joinpath(pwd(), \\\"julia-dots.svg\\\"))\\norigin()\\ntranslate(0, 25)\\njuliacircles(100)\\nfinish()\\n\n```\n\n----------------------------------------\n\nTITLE: Boxing Small Unsigned Integers Using a Cache in C\nDESCRIPTION: This C function, `jl_box_uint8`, shows an optimization for boxing small unsigned 8-bit integers within the Julia runtime. It retrieves a pre-allocated `jl_value_t` object from `boxed_uint8_cache` instead of allocating a new one, improving performance. This cache is set up by `jl_init_box_caches()` in `src/datatype.c`.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/init.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *jl_box_uint8(uint32_t x)\n{\n    return boxed_uint8_cache[(uint8_t)x];\n}\n```\n\n----------------------------------------\n\nTITLE: Julia SSA IR with PhiC and Upsilon Nodes for Exception Handling (Julia IR/LLVM-like)\nDESCRIPTION: This block shows the Julia SSA IR generated for the function with the `try-catch` block. It demonstrates key components for exception handling: `Expr(:enter)`/`Expr(:leave)` delimit the `try` region. Upsilon nodes (`ϒ` or `Upsilon`) record the state of variables (`false`, `#undef`, `1` initially; `true`, `2` after assignment; `true`, `3` after second assignment) at points within the `try` block. PhiC nodes (`φᶜ` or `PhiC`) in the catch handler (`4 ┄`) merge these potentially multiple states for each variable (`%13`, `%14`, `%15`) originating from different points where an exception could have occurred. Note the handling of potentially undefined `y` (`Core.Compiler.MaybeUndef(Int64)`) and the explicit check `Expr(:throw_undef_if_not)` before its use.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/ssair.md#_snippet_10\n\nLANGUAGE: llvm\nCODE:\n```\n1 ─       nothing::Nothing\n2 ─ %2  = $(Expr(:enter, #4))\n3 ─ %3  = ϒ (false)\n│   %4  = ϒ (#undef)\n│   %5  = ϒ (1)\n│   %6  = ϒ (true)\n│   %7  = ϒ (2)\n│         invoke Main.opaque()::Any\n│   %9  = ϒ (true)\n│   %10 = ϒ (3)\n│         invoke Main.error()::Union{}\n└──       $(Expr(:unreachable))::Union{}\n4 ┄ %13 = φᶜ (%3, %6, %9)::Bool\n│   %14 = φᶜ (%4, %7, %10)::Core.Compiler.MaybeUndef(Int64)\n│   %15 = φᶜ (%5)::Core.Const(1)\n└──       $(Expr(:leave, Core.SSAValue(2)))\n5 ─       $(Expr(:pop_exception, :(%2)))::Any\n│         $(Expr(:throw_undef_if_not, :y, :(%13)))::Any\n│   %19 = Core.tuple(%15, %14)\n└──       return %19\n```\n\n----------------------------------------\n\nTITLE: Example Valgrind Warning for Unhandled rr Syscall\nDESCRIPTION: This text block shows an example warning output from Valgrind when it encounters an unhandled system call (syscall 1008) specific to the rr Record and Replay Framework. This warning typically occurs when Julia detects if it's running under rr and is generally safe to ignore, as noted in the surrounding documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/valgrind.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n--xxxxxx-- WARNING: unhandled amd64-linux syscall: 1008\n--xxxxxx-- You may be able to write your own handler.\n--xxxxxx-- Read the file README_MISSING_SYSCALL_OR_IOCTL.\n--xxxxxx-- Nevertheless we consider this a bug.  Please report\n--xxxxxx-- it at http://valgrind.org/support/bug_reports.html.\n```\n\n----------------------------------------\n\nTITLE: Configuring Edit URL for Julia Documentation (Markdown)\nDESCRIPTION: This `@meta` block is a directive used by Documenter.jl, Julia's documentation generator. It sets the `EditURL` metadata variable, providing a link to the source file on GitHub for the current documentation page, facilitating contributions and edits.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Unicode/docs/src/index.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n```@meta\nEditURL = \"https://github.com/JuliaLang/julia/blob/master/stdlib/Unicode/docs/src/index.md\"\n```\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Base Functions for 'Getting Around'\nDESCRIPTION: This block uses the `@docs` directive, specific to Julia's documentation system (likely Documenter.jl), to list essential Julia Base functions and constants related to environment interaction, module loading, introspection, and basic utilities under the 'Getting Around' category. It instructs the documentation generator to insert the documentation for each listed item.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.exit\nBase.atexit\nBase.isinteractive\nBase.summarysize\nBase.__precompile__\nBase.include\nMain.include\nBase.include_string\nBase.include_dependency\n__init__\nBase.OncePerProcess\nBase.OncePerTask\nBase.OncePerThread\nBase.which(::Any, ::Any)\nBase.methods\nBase.@show\nans\nerr\nBase.active_project\nBase.set_active_project\n```\n```\n\n----------------------------------------\n\nTITLE: Building Julia binary distribution on macOS - Makefile - Shell\nDESCRIPTION: After building Julia, this command sequence creates a macOS DMG containing a standalone Julia.app. The user enters the 'contrib/mac/app' directory and executes 'make', passing the same make variables as used during the original build. Dependencies: Completed Julia build and access to make. Input: Execution in 'contrib/mac/app'. Output: A DMG file ready for macOS installation.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\ncd contrib/mac/app\nmake [makevars...]\n```\n\n----------------------------------------\n\nTITLE: Automatic Cleanup for `mktemp` and `mktempdir` in Julia\nDESCRIPTION: By default, the `mktemp` and `mktempdir` functions now attempt to remove the temporary files or directories they create when the Julia process exits.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_128\n\nLANGUAGE: julia\nCODE:\n```\ntemp_path = mktemp()      # File path\ntemp_dir_path = mktempdir() # Directory path\n# Paths are scheduled for cleanup on process exit by default\n```\n\n----------------------------------------\n\nTITLE: Using JL_MAYBE_UNROOTED for Unrooted GC Values - Julia GC Static Analyzer - C\nDESCRIPTION: This snippet shows how to define a function that can accept unrooted values by annotating its argument with JL_MAYBE_UNROOTED, with an example of calling such a function safely. It demonstrates both definition and practical invocation, needing the Julia runtime and proper inclusion of analyzer annotations. Arguments and return values are C pointers to Julia values, and the code assumes static analyzer context.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-sa.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nJL_DLLEXPORT void JL_NORETURN jl_throw(jl_value_t *e JL_MAYBE_UNROOTED);\njl_value_t *jl_alloc_error();\n\nvoid example() {\n  // The return value of the allocation is unrooted. This would normally\n  // be an error, but is allowed because of the above annotation.\n  jl_throw(jl_alloc_error());\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Julia Parser Frontend Directly (Femtolisp)\nDESCRIPTION: This sequence of shell commands demonstrates how to manually invoke the Julia parser, which is implemented in femtolisp. It involves navigating to the `src` directory within the Julia source code, starting the `flisp` interpreter, loading the Julia frontend script (`jlfrontend.scm`), and then using the `jl-parse-file` function to parse a specified Julia file (`<filename>`). This method allows testing the parser component without needing to build the entire Julia project.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/eval.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cd src\n$ flisp/flisp\n> (load \"jlfrontend.scm\")\n> (jl-parse-file \"<filename>\")\n```\n\n----------------------------------------\n\nTITLE: Documenting Builtin and Intrinsics APIs in Julia\nDESCRIPTION: This snippet is a Julia documentation macro that enumerates internal Core APIs related to memory and atomic operations. It lists function signatures for memory reference (e.g., memoryrefnew, memoryrefget, memoryrefset!) and intrinsic atomic pointer operations (e.g., atomic_pointerref, atomic_pointerset), as well as Core type introspection functions. Required dependencies include Julia's Core module and built-in documentation system. This macro produces API documentation but does not implement functionality directly; it is intended for use in building Julia's internal or advanced API reference and assumes a supporting documentation toolchain.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/builtins.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nCore.memoryrefnew\nCore.memoryrefoffset\nCore.memoryrefget\nCore.memoryrefset!\nCore.memoryref_isassigned\nCore.memoryrefswap!\nCore.memoryrefmodify!\nCore.memoryrefreplace!\nCore.memoryrefsetonce!\nCore.Intrinsics.atomic_pointerref\nCore.Intrinsics.atomic_pointerset\nCore.Intrinsics.atomic_pointerswap\nCore.Intrinsics.atomic_pointermodify\nCore.Intrinsics.atomic_pointerreplace\nCore.get_binding_type\nCore.IntrinsicFunction\nCore.Intrinsics\nCore.IR\n```\n```\n\n----------------------------------------\n\nTITLE: Renamed fftw-related Base Bindings - Julia\nDESCRIPTION: Informs that FFT (Fast Fourier Transform) bindings have moved from Julia Base to the AbstractFFTs.jl and FFTW.jl external packages, and related signal processing to DSP.jl. The code itself is not shown, but consumers should now use these packages for FFT functionality.\nSOURCE: https://github.com/julialang/julia/blob/master/HISTORY.md#_snippet_158\n\n\n\n----------------------------------------\n\nTITLE: Evaluating and Displaying the Julia REPL Banner in Julia\nDESCRIPTION: This Julia snippet demonstrates how to use the REPL module to capture the standard Julia REPL welcome banner to a buffer, convert it to a string, and parse it as Markdown for display purposes. It depends on the REPL and Markdown standard libraries, and works by redirecting the banner output to an IOBuffer, extracting the string, then feeding the formatted text to Markdown.parse. This snippet is typically used for documentation or automated rendering of Julia's interactive environment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/manual/getting-started.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nusing REPL\\nio = IOBuffer()\\nREPL.banner(io)\\nbanner = String(take!(io))\\nimport Markdown\\nMarkdown.parse(\"```\\n$ julia\\n\\n$(banner)\\njulia> 1 + 2\\n3\\n\\njulia> ans\\n3\\n```\")\n```\n\n----------------------------------------\n\nTITLE: Handling PhiNodes in Julia Escape Analysis\nDESCRIPTION: This snippet illustrates how escape analysis handles control flow merges represented by `PhiNode`s in Julia's IR. It defines a function with conditional assignment. The analysis propagates the escape information from the returned `obj` (which corresponds to a `PhiNode` after the `if/else`) back to the values defined in both branches (`Ref(s)` and `Ref(t)`).\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/EscapeAnalysis.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```@repl EAUtils\ncode_escapes((Bool, Base.RefValue{String}, Base.RefValue{String})) do cnd, s, t\n    if cnd\n        obj = Ref(s)\n    else\n        obj = Ref(t)\n    end\n    return obj\nend\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Italic Syntax in Markdown\nDESCRIPTION: This snippet illustrates how to render text in italics using Markdown by enclosing it with single asterisks (`*`). This formatting is applied inline within text blocks.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nA paragraph containing an *italicized* word.\n```\n\n----------------------------------------\n\nTITLE: Marking Metadata in Julia Documentation Files - Julia\nDESCRIPTION: The snippet sets a metadata URL for edit tracking in the documentation source. It assigns the EditURL variable to help contributors locate the source in GitHub. This metadata directive depends on Julia's documentation tooling, and it must be placed at the top of the file.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Future/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nEditURL = \"https://github.com/JuliaLang/julia/blob/master/stdlib/Future/docs/src/index.md\"\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Julia `isbits` Objects from Raw Data in C\nDESCRIPTION: Declares the C function `jl_new_bits`, used to construct Julia `isbits` objects (immutable types like primitive numbers or structs containing only other `isbits` types). It takes the `isbits` type object (`bt`, which is a `jl_value_t*`) and a pointer (`void *data`) to the raw binary data representing the value. It returns a `jl_value_t*` pointing to the Julia object, potentially allocating a new box if necessary.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_10\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *jl_new_bits(jl_value_t *bt, void *data)\n```\n\n----------------------------------------\n\nTITLE: Referencing Multi-Threading API Documentation - Julia\nDESCRIPTION: This snippet references Julia's main thread management APIs using a documentation macro, intended to generate API docs for thread-related macros, functions, and variables. No direct executable code is included; instead, it collects documentation targets for tools like Documenter.jl. The referenced names include thread launching, joining, thread info, and threadpool management.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/multi-threading.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nBase.Threads.@threads\\nBase.Threads.foreach\\nBase.Threads.@spawn\\nBase.Threads.threadid\\nBase.Threads.maxthreadid\\nBase.Threads.nthreads\\nBase.Threads.threadpool\\nBase.Threads.nthreadpools\\nBase.Threads.threadpoolsize\\nBase.Threads.ngcthreads\\n```\n```\n\n----------------------------------------\n\nTITLE: Debugging sys.ji Build Phase (Shell Command with GDB)\nDESCRIPTION: Launches gdb with Julia arguments for debugging during the sys.ji build image creation, specifying both sys and sys0.ji. Used to capture detailed state at points of failure during precompilation. Run from the 'base' directory corresponding to your build environment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/debuggingtips.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\njulia/base$ gdb --args ../usr/bin/julia-debug -C native --build ../usr/lib/julia/sys -J ../usr/lib/julia/sys0.ji sysimg.jl\n```\n\n----------------------------------------\n\nTITLE: Defining Julia Object Metadata and Value Struct in C\nDESCRIPTION: Defines the `jl_typetag_t` struct in C, which encapsulates a Julia object's memory block. It contains opaque metadata (used for type information and garbage collection) and the actual `jl_value_t` representing the object's data.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct {\n    opaque metadata;\n    jl_value_t value;\n} jl_typetag_t;\n```\n\n----------------------------------------\n\nTITLE: Checking Mutability of a Julia Object in C\nDESCRIPTION: Declares the C function `jl_is_mutable`. It takes a pointer to a Julia object (`v`) and returns a non-zero integer if the object's type is defined as mutable (meaning its fields can be modified after creation), and zero otherwise.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nint jl_is_mutable(jl_value_t *v);\n```\n\n----------------------------------------\n\nTITLE: Generating API Documentation for ScopedValues in Julia\nDESCRIPTION: This snippet shows the standard Julia documentation syntax (`@docs`) used to automatically include API documentation for specific functions and types related to Scoped Values, such as `ScopedValue`, `with`, `@with`, `isassigned`, and `get` from the `Base.ScopedValues` module.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/scopedvalues.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.ScopedValues.ScopedValue\nBase.ScopedValues.with\nBase.ScopedValues.@with\nBase.isassigned(::Base.ScopedValues.ScopedValue)\nBase.ScopedValues.get\n```\n```\n\n----------------------------------------\n\nTITLE: Unmount and Convert Writable .dmg Back to Read-only - Shell\nDESCRIPTION: Ejects/unmounts a disk image used for manual code signing and removes the temporary mount point, then converts the mutable .dmg back to a compressed read-only format for distribution. Requires correct device name (/dev/disk3) and the file paths matching the earlier conversion. There is no direct output if the commands succeed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\nhdiutil eject /dev/disk3\\nrm -rf ./jlmnt\\nhdiutil convert julia-x.y.z-osx_writable.dmg -format UDZO -o julia-x.y.z-osx_fixed.dmg\n```\n\n----------------------------------------\n\nTITLE: Lowest-Level GC Allocation and Type Tagging in C\nDESCRIPTION: Declares the most fundamental C functions for memory allocation and type assignment within the Julia runtime. `jl_gc_allocobj` requests a raw block of memory of `nbytes` size directly from the garbage collector's allocator. `jl_set_typeof` takes a raw memory pointer (`v`) obtained from the allocator and assigns a Julia type (`type`, a `jl_datatype_t*`) to it by setting the object's metadata header, making it a valid, typed Julia object. A note indicates that documentation for `jl_gc_allocobj` may be out of date.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_18\n\nLANGUAGE: c\nCODE:\n```\njl_value_t *jl_gc_allocobj(size_t nbytes);\nvoid jl_set_typeof(jl_value_t *v, jl_datatype_t *type);\n```\n\n----------------------------------------\n\nTITLE: Allocating and Constructing Julia Tuples in C\nDESCRIPTION: Declares C functions for creating Julia tuple objects (`jl_tuple_t*`). `jl_tuple` takes the tuple size (`n`) and a variable number of `jl_value_t*` arguments for the elements. `jl_tuplev` takes the size (`n`) and an array (`v`) of `jl_value_t*` element pointers. `jl_alloc_tuple` allocates memory for an uninitialized tuple of size `n`, requiring subsequent field initialization.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/object.md#_snippet_12\n\nLANGUAGE: c\nCODE:\n```\njl_tuple_t *jl_tuple(size_t n, ...);\njl_tuple_t *jl_tuplev(size_t n, jl_value_t **v);\njl_tuple_t *jl_alloc_tuple(size_t n);\n```\n\n----------------------------------------\n\nTITLE: Listing Julia Base Submodules for Documentation\nDESCRIPTION: This block employs the `@docs` directive to specify several important submodules within Julia's `Base` module, such as `Broadcast`, `Docs`, `Iterators`, `Libc`, `Meta`, `StackTraces`, `Sys`, `Threads`, and `GC`. It directs the documentation generator to include documentation for these specific submodules.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/base.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nBase.Broadcast\nBase.Docs\nBase.Iterators\nBase.Libc\nBase.Meta\nBase.StackTraces\nBase.Sys\nBase.Threads\nBase.GC\n```\n```\n\n----------------------------------------\n\nTITLE: LLVMLifetime Preservation Intrinsics in Julia Backend\nDESCRIPTION: Lists LLVM intrinsics (`@llvm.julia.gc_preserve_begin` and `@llvm.julia.gc_preserve_end`) used to extend the lifetime of objects as required for bridging low-level and high-level code. These functions are employed to ensure objects remain live between explicit regions, delimited by these calls. Callers use the returned token to properly manage object lifetimes.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/llvm.md#_snippet_15\n\nLANGUAGE: llvm\nCODE:\n```\ntoken @llvm.julia.gc_preserve_begin(...)\nvoid @llvm.julia.gc_preserve_end(token)\n```\n\n----------------------------------------\n\nTITLE: Setting an Alias for Julia in Bash Shell (bash)\nDESCRIPTION: Provides the command to add a persistent alias for the Julia executable in the bash shell, updating the user's .bashrc profile. This facilitates convenient invocation of Julia from any directory. The code echoes a new alias definition and sources .bashrc to update the current shell session.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\necho \"alias julia='<build-directory>/usr/bin/julia'\" >> ~/.bashrc && source ~/.bashrc\n\n```\n\n----------------------------------------\n\nTITLE: CMake Cache Error Example After Directory Move (cmake)\nDESCRIPTION: Provides a typical error message emitted by CMake if the build directory for a dependency is moved. Resolution usually involves deleting and rebuilding the affected dependency under the 'deps' directory.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_15\n\nLANGUAGE: cmake\nCODE:\n```\nCMake Error: The current CMakeCache.txt directory ... is different than the directory ... where     CMakeCache.txt was created.\n\n```\n\n----------------------------------------\n\nTITLE: Ensuring a Rooted Slot with JL_REQUIRE_ROOTED_SLOT - Julia GC Static Analyzer - C\nDESCRIPTION: This snippet details how to enforce that a function argument must be a rooted slot using JL_REQUIRE_ROOTED_SLOT, with allocation and safepoint following correct rooting protocol. Typically, JL_GC_PUSH is used by the caller before passing the slot, and JL_GC_POP after the operation. This ensures safety through the static analyzer and Julia's GC.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/gc-sa.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nvoid jl_do_processing(jl_value_t **slot JL_REQUIRE_ROOTED_SLOT) {\n  *slot = jl_box_long(1);\n  // Ok, only, because the slot was annotated as rooting\n  jl_gc_safepoint();\n}\n\nvoid example() {\n  jl_value_t *slot = NULL;\n  JL_GC_PUSH1(&slot);\n  jl_do_processing(&slot);\n  JL_GC_POP();\n}\n```\n\n----------------------------------------\n\nTITLE: Aggregating PackageEvaluator Results via Shell\nDESCRIPTION: These shell commands utilize the `summary.sh` script within the PackageEvaluator/scripts directory to consolidate test results from individual JSON files generated during the PkgEval runs. Results corresponding to the baseline release version (identified by 'AK' folders) and the backport version (identified by 'LZ' folders) are aggregated into separate text files (`summary_release.txt` and `summary_backport.txt`) for comparison.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n./summary.sh 0.4AK/*.json > summary_release.txt\n./summary.sh 0.5AK/*.json >> summary_release.txt\n./summary.sh 0.6AK/*.json >> summary_release.txt\n./summary.sh 0.4LZ/*.json > summary_backport.txt\n./summary.sh 0.5LZ/*.json >> summary_backport.txt\n./summary.sh 0.6LZ/*.json >> summary_backport.txt\n```\n\n----------------------------------------\n\nTITLE: Creating Horizontal Rules in Markdown\nDESCRIPTION: This snippet demonstrates how to create a horizontal rule (equivalent to HTML `<hr>`) in Markdown using three or more hyphens (`---`) on a line by themselves, usually separated by blank lines.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_21\n\nLANGUAGE: markdown\nCODE:\n```\nText above the line.\n\n---\n\nAnd text below the line.\n```\n\n----------------------------------------\n\nTITLE: Setting Julia CPU Target for Raspberry Pi 1/Zero in Makefile\nDESCRIPTION: Specifies the CPU target `arm1176jzf-s` in the `Make.user` file. This is necessary when building Julia on Raspberry Pi 1 or Raspberry Pi Zero if the LLVM build system fails to automatically detect the CPU type.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/arm.md#_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\nJULIA_CPU_TARGET=arm1176jzf-s\n```\n\n----------------------------------------\n\nTITLE: Auto-documenting Abstract Number Types - Julia - Julia\nDESCRIPTION: Utilizes Julia's documentation tools with @docs blocks to reference and generate documentation for key abstract number types in Core and Base modules. This snippet is for literate programming and organizes abstract number types for inclusion in Julia's documentation build process. It depends on Julia's documentation system and is not meant for execution; the referenced symbols must exist in the current environment.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/base/numbers.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\\nCore.Number\\nCore.Real\\nCore.AbstractFloat\\nCore.Integer\\nCore.Signed\\nCore.Unsigned\\nBase.AbstractIrrational\\n```\n```\n\n----------------------------------------\n\nTITLE: Increasing Swap File Size Configuration\nDESCRIPTION: Illustrates modifying the `/etc/dphys-swapfile` configuration file to increase the swap size from 100MB to 512MB. This adjustment might be required during the Julia build process on resource-constrained devices like the Raspberry Pi 1/Zero to prevent out-of-memory errors.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/arm.md#_snippet_1\n\nLANGUAGE: conf\nCODE:\n```\nCONF_SWAPSIZE=100\n```\n\nLANGUAGE: conf\nCODE:\n```\nCONF_SWAPSIZE=512\n```\n\n----------------------------------------\n\nTITLE: Make Clean Error Remediation (Shell Make Output)\nDESCRIPTION: Displays a typical error message from the build process suggesting to run 'make clean' or 'make cleanall'. Indicates possible issues with the base library requiring bootstrapping. The error message is intended for users to follow troubleshooting instructions.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n*** This error is usually fixed by running 'make clean'. If the error persists, try 'make cleanall' ***\n\n```\n\n----------------------------------------\n\nTITLE: Setting Documentation Edit URL Metadata in Julia\nDESCRIPTION: This snippet uses Julia's documentation meta macro to assign the canonical edit URL for this documentation file, aiding contributors in tracing source files for edits on GitHub. The macro takes a key 'EditURL' and sets it to a direct GitHub URL pointing to the Printf documentation markdown file. It requires processing by Julia's docsystem and does not affect runtime code.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Printf/docs/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nEditURL = \"https://github.com/JuliaLang/julia/blob/master/stdlib/Printf/docs/src/index.md\"\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Documenter.jl Edit URL\nDESCRIPTION: Sets the 'EditURL' metadata for Documenter.jl, specifying the source file location on GitHub for the 'Edit on GitHub' link within the generated documentation.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/FileWatching/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n@meta\nEditURL = \"https://github.com/JuliaLang/julia/blob/master/stdlib/FileWatching/docs/src/index.md\"\n```\n\n----------------------------------------\n\nTITLE: Setting Documenter.jl Current Module Context (Julia)\nDESCRIPTION: Uses the Documenter.jl `@meta` block to set the `CurrentModule` context to `FileWatching.Pidfile` for subsequent `@docs` blocks, ensuring symbols are resolved correctly within that specific module.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/FileWatching/docs/src/index.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\n@meta\nCurrentModule = FileWatching.Pidfile\n```\n\n----------------------------------------\n\nTITLE: Setting Generic Build Architecture in Julia (Makefile)\nDESCRIPTION: Configures the general target architecture (e.g., `x86_64`, `i686`) for the Julia build by setting the `ARCH` variable in the `Make.user` file. See `Make.inc` for further customization options.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/linux.md#_snippet_3\n\nLANGUAGE: Makefile\nCODE:\n```\nARCH\n```\n\n----------------------------------------\n\nTITLE: Required Windows DLL Entry Point (Windows/C)\nDESCRIPTION: This identifier represents the standard entry point function required for Windows DLLs. When using LLD with `-flavor gnu`, Julia injects a stub definition for this function to satisfy linker requirements.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/pkgimg.md#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n_DllMainCRTStartup\n```\n\n----------------------------------------\n\nTITLE: Generating PDF Download Link for Documentation in Julia\nDESCRIPTION: This Julia code snippet, executed within an `@eval` block, generates a Markdown \"note\" directive containing a link to the PDF version of the documentation. It dynamically constructs the filename and URL based on the current Julia `VERSION` global, differentiating between release and pre-release versions. The resulting Markdown string is then parsed using the `Markdown` module to render the note block.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/index.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@eval\nrelease = isempty(VERSION.prerelease)\nfile = release ? \"julia-$(VERSION).pdf\" :\n       \"julia-$(VERSION.major).$(VERSION.minor).$(VERSION.patch)-$(first(VERSION.prerelease)).pdf\"\nurl = \"https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/$(file)\"\nimport Markdown\nMarkdown.parse(\"\"\"\n!!! note\n    The documentation is also available in PDF format: [$file]($url).\n\"\"\")\n```\n```\n\n----------------------------------------\n\nTITLE: Resetting DocTest Environment in Julia\nDESCRIPTION: Resets the doctest setup configuration. This typically signifies the end of the block where the previous setup (`DocTestSetup = :(...)`) was needed.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/subarrays.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```@meta\nDocTestSetup = nothing\n```\n```\n\n----------------------------------------\n\nTITLE: Increasing Linux Memory Mapping Limit using Shell Command\nDESCRIPTION: Demonstrates using the `sysctl` command with root privileges to increase the Linux kernel's maximum memory map count (`vm.max_map_count`) to 262144. This is a workaround for the `Cannot allocate memory` error encountered with JITLink on AArch64 systems.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/arm.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nsysctl -w vm.max_map_count=262144\n```\n\n----------------------------------------\n\nTITLE: Importing GPG Key for Julia Code Signing\nDESCRIPTION: This shell command uses the `gpg` (GnuPG) utility to import a private key from the specified file (`julia.key`) into the user's GPG keyring. This key is essential for digitally signing Julia release binaries for Linux. Executing this command requires access to the `julia.key` file and the corresponding passphrase.\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/distributing.md#_snippet_16\n\nLANGUAGE: gpg\nCODE:\n```\ngpg --import julia.key\n```\n\n----------------------------------------\n\nTITLE: Defining Paragraphs in Markdown\nDESCRIPTION: This snippet shows how paragraphs are defined in Markdown as blocks of plain text separated by one or more blank lines. Paragraphs can contain inline formatting.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\nThis is a paragraph.\n\nAnd this is *another* paragraph containing some emphasized text.\nA new line, but still part of the same paragraph.\n```\n\n----------------------------------------\n\nTITLE: Deleting Built Binaries and Dependencies (Shell)\nDESCRIPTION: Indicates the procedure for deleting all Julia binaries and dependencies by removing the './usr' directory from the source tree. No scripts shown; the operation can be performed with a standard file removal command (e.g., 'rm -rf ./usr').\nSOURCE: https://github.com/julialang/julia/blob/master/doc/src/devdocs/build/build.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\ndelete the ./usr directory _in the source tree_\n\n```\n\n----------------------------------------\n\nTITLE: Defining Headers in Markdown\nDESCRIPTION: This snippet demonstrates the syntax for creating headers of different levels (1 to 6) in Markdown using the hash symbol (`#`). More hashes indicate a lower level header.\nSOURCE: https://github.com/julialang/julia/blob/master/stdlib/Markdown/docs/src/index.md#_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n# Level One\n## Level Two\n### Level Three\n#### Level Four\n##### Level Five\n###### Level Six\n```"
  }
]