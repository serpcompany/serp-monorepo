[
  {
    "owner": "hhenson",
    "repo": "hgraph",
    "content": "TITLE: Declaring a Component with Type Annotations and Decorator in Python\nDESCRIPTION: This snippet demonstrates the canonical way to define a component in the hgraph project using a Python decorator, type annotations, and a docstring. The @decorator placeholder indicates a component type (such as @graph or @compute_node). All parameters must have type annotations distinguishing time-series inputs and scalar configuration. The function returns a typed output reflecting the expected time-series output. Dependencies include the appropriate component decorator, Python 3 type annotations, and relevant time-series type objects. Inputs can be a mix of time-series and scalar values; outputs must align with the return type annotation.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/component_signature.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@decorator\ndef component_name(ts1: TIME_SERIES_TYPE, ..., s1: str, ...) -> TIME_SERIES_TYPE_2:\n    \"\"\"\n    Documentation\n    \"\"\"\n    ... # component behavior\n```\n\n----------------------------------------\n\nTITLE: Constructing an HGraph Graph Definition (Python)\nDESCRIPTION: Defines a graph using the `@graph` decorator. The `main` function wires together the previously defined nodes: `counter` (source), `sum_time_series` (compute), and `print_time_series` (sink). The output of `counter` is fed into `sum_time_series`, and its output is fed into `print_time_series`. This graph has no explicit inputs or outputs, making it suitable as a top-level graph for execution. Unconnected nodes are automatically removed during graph building.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/graphs_and_nodes.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph\n\n@graph\ndef main():\n    c = counter(10)\n    s = sum_time_series(c)\n    print_time_series(s)\n```\n\n----------------------------------------\n\nTITLE: Defining and Running an HGraph Graph in Python\nDESCRIPTION: This Python snippet defines a simple HGraph graph named `what_is_one_plus_one` using the `@graph` decorator. It demonstrates wiring nodes: `const(1)` creates a time-series source, `one + one` implicitly calls an addition node, and `debug_print` displays the result. The `run_graph` function executes this graph definition. It depends on `hgraph`, `run_graph`, `const`, and `debug_print` from the `hgraph` library.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/program_anatomy.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, run_graph\nfrom hgraph.nodes import const, debug_print\n\n@graph\ndef what_is_one_plus_one():\n    one = const(1)\n    one_plus_one = one + one  # NOTE: This is equivalent to add_(one, one), lots of syntactic sugar\n    debug_print(\"1 + 1\", one_plus_one)\n\nrun_graph(what_is_one_plus_one)\n```\n\n----------------------------------------\n\nTITLE: Defining and Running a Simple hgraph Graph in Python\nDESCRIPTION: Demonstrates a basic hgraph program. It defines a graph function `main` using the `@graph` decorator, creates a constant time-series node `a` with value 1 using `const`, adds 2 to it, prints the result `c` using `debug_print`, and finally executes the graph using `run_graph`. Requires the `hgraph` library and its associated modules (`graph`, `run_graph`, `const`, `debug_print`). The expected output shows the computed value (3) along with timestamps.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, run_graph, const\nfrom hgraph.nodes import debug_print\n\n@graph\ndef main():\n    a = const(1)\n    c = a + 2\n    debug_print(\"a + 2\", c)\n\nrun_graph(main)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Compute Node in HGraph (Python)\nDESCRIPTION: Defines a compute node using the `@compute_node` decorator. The `sum_time_series` function takes an integer time-series (`ts: TS[int]`) as input and computes a running sum. It utilizes the special `_output: TS_OUT[int]` parameter to access the previous output value, enabling stateful computation. The function returns the new sum if the input `ts` is valid, otherwise it maintains the current state. If `None` is returned, the output time-series is not updated.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/graphs_and_nodes.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, TS, TS_OUT\n\n@compute_node\ndef sum_time_series(ts: TS[int], _output: TS_OUT[int] = None) -> TS[int]:\n    return _output.value + ts.value if _output.valid else ts.value\n```\n\n----------------------------------------\n\nTITLE: Defining Functions Using Decorators in HGraph - Python\nDESCRIPTION: Illustrates the canonical way to define node or graph functions in HGraph with decorators like @graph. Emphasizes use of input and output signatures, highlighting Python's function-only approach and avoidance of classes in user code. Requires HGraph decorators as dependencies, and expects all arguments and return types to be annotated for runtime wiring. Inputs represent time-series or state; a single (possibly composite) output is mandatory. Intended for deterministic, stateless computation with full immutability.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/mental_model.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@<decorator>\ndef <function_name>(<inputs>?) -> <output>?:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining an hgraph Graph with Typed Inputs and Outputs (Python)\nDESCRIPTION: Illustrates how to define an hgraph graph function with type-hinted parameters and return values. The example function `my_graph` takes a time-series of integers (`ts: TS[int]`) and a string (`v: str`) as input, and is declared to return a time-series of strings (`-> TS[str]`). Type hints are mandatory for hgraph function signatures.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/quick_start/graph.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef my_graph(ts: TS[int], v: str) -> TS[str]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Creating a Generator Source Node in HGraph (Python)\nDESCRIPTION: Defines a source node using the `@generator` decorator in Python. This specific generator, `counter`, yields a sequence of integers up to `max_count`, each associated with a timestamp. Timestamps are generated using `MIN_ST` (minimum start time) and `MIN_TD` (minimum time delta). Generator nodes introduce data into the graph and cannot have time-series inputs, only scalar inputs like `max_count`.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/graphs_and_nodes.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import generator, TS, MIN_ST, MIN_TD\n\n@generator\ndef counter(max_count: int) -> TS[int]:\n    for i in range(max_count):\n        yield MIN_ST + i * MIN_TD, i\n```\n\n----------------------------------------\n\nTITLE: Defining HGraph Node Types (Generator, Compute, Sink) in Python\nDESCRIPTION: This Python code showcases the definition of different HGraph node types using specific decorators. It defines a `const` generator node (`@generator`) to yield an initial value, an `add_` compute node (`@compute_node`) to perform addition on time-series inputs, and a `debug_print` sink node (`@sink_node`) to consume and print time-series values. It utilizes HGraph types like `TS` (Time Series), `SCALAR`, and constants like `MIN_ST`, demonstrating how nodes handle data flow and computation.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/program_anatomy.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import generator, compute_node, sink_node, SCALAR, TS, MIN_ST\n\n@generator\ndef const(value: int) -> TS[int]:\n    \"\"\" A simplified version of a const generator\"\"\"\n    yield MIN_ST, value\n    \n@compute_node\ndef add_(lhs: TS[int], rhs: TS[int]) -> TS[int]:\n    return lhs.value + rhs.value\n\n@sink_node\ndef debug_print(label: str, ts: TS[int]):\n    print(f\"{label}: {ts.value}\")\n```\n\n----------------------------------------\n\nTITLE: Switching Between Lambda Functions at Runtime Using switch_ - HGraph Python\nDESCRIPTION: This snippet demonstrates use of lambdas as switch_ dictionary values, allowing for rapid in-line definition of switching behaviors. The selector chooses between addition and subtraction lambdas operating on lhs and rhs. Requires hgraph, TS, graph, switch_. Input: selector (TS[str]), lhs/rhs (TS[int]), Output: TS[int].\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/map_reduce_switch.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import TS, graph, switch_\n\n@graph\ndef graph_switch_lambda(selector: TS[str], lhs: TS[int], rhs: TS[int]) -> TS[int]:\n    return switch_(selector, {\n        \"add\": lambda lhs, rhs: lhs + rhs,\n        \"sub\": lambda lhs, rhs: lhs - rhs,\n    }, lhs, rhs)\n\n```\n\n----------------------------------------\n\nTITLE: Capturing Node Exceptions with exception_time_series in hgraph (Python)\nDESCRIPTION: Demonstrates how to wrap a single node with exception_time_series in hgraph to convert runtime errors into NodeError events. It includes setup with constant nodes, a division by zero that triggers the exception, and debug_print statements to show both calculation and error output. Requires hgraph and its dependencies to be installed. Inputs are constant time series, and outputs include standard error traces for failed node execution.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/exception_handling.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom hgraph import graph, exception_time_series, const, debug_print\n\n\n@graph\ndef capture_an_exception():\n    a = const(1.0)\n    b = const(0.0)\n    c = a / b\n    e = exception_time_series(c)\n    debug_print(\"a / b\", c)\n    debug_print(\"exception\", e)\n```\n\n----------------------------------------\n\nTITLE: Defining a Pull Source Node with generator Decorator in Python\nDESCRIPTION: This snippet shows how to implement a pull-based source node that produces values for consumption in HGraph by decorating a function with @generator. The function returns a generator yielding a tuple with scheduled time and value, which is used to initialize a time-series output. Requires access to @generator decorator, MIN_ST constant, and SCALAR/TS typing. Input is a single value, output is a time-series. The node is scheduled during graph start and participates in both simulation and real-time modes. The example is minimal and intended for conceptual demonstration.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/node_based_computation.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@generator\n    def const(value: SCALAR) -> TS[SCALAR]:\n        yield MIN_ST, value\n```\n\n----------------------------------------\n\nTITLE: Implementing a Subscription Service in hgraph (Python)\nDESCRIPTION: Shows an implementation (`static_market_data`) for the `market_data` subscription service using `@service_impl`. The implementation receives a time-series set (`TSS`) of requested instrument IDs. It returns a time-series dictionary (`TSD`) mapping each instrument ID (key type `str`) to its corresponding price time-series (`TS[float]`). This example uses `hgraph.map_` to process each requested key, returning a constant price of 1.0 for simplicity.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/services.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@service_impl(interfaces=[market_data])\ndef static_market_data(instrument_id: TSS[str]) -> TSD[str, TS[float]]:\n    return map_(lambda key: const(1.0), __key_set__=instrument_id)\n```\n\n----------------------------------------\n\nTITLE: Mapping With Lambda Functions in map_ - HGraph Python\nDESCRIPTION: This snippet shows use of a lambda function (anonymous function) as the node argument for map_. The input TSD[str, TS[int]] is transformed by incrementing each value by 1 using the provided lambda, with automatic signature deduction. Requires hgraph, graph, map_, TSD, TS. Input: TSD[str, TS[int]], Output: TSD[str, TS[int]].\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/map_reduce_switch.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, map_, TSD, TS\n\n@graph\ndef g(tsd: TSD[str, TS[int]]):\n    return map_(lambda i: i + 1, i=tsd)\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Sink Node in HGraph (Python)\nDESCRIPTION: Defines a sink node using the `@sink_node` decorator. The `print_time_series` function acts as a terminal point in the graph's data flow. It takes an integer time-series (`ts: TS[int]`) as input and prints its current value (`ts.value`) whenever it updates. Sink nodes cannot have outputs and their defining function must return `None`.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/graphs_and_nodes.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import sink_node, TS\n\n@sink_node\ndef print_time_series(ts: TS[int]):\n    print(ts.value)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Request-Reply Service in hgraph (Python)\nDESCRIPTION: Provides an implementation (`static_create_order`) for the `create_order` request-reply service using `@service_impl`. The implementation receives a time-series dictionary (`TSD`) where keys are unique integers identifying the client request instance, and values are the time-series (`TS`) of `Order` objects. It returns a `TSD` mapping the client request ID (int) to the result time-series (`TS[str]`). This example uses `hgraph.map_` to process each order request, returning a constant \"order_id\".\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/services.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@service_impl(interfaces=[create_order])\ndef static_create_order(order: TSD[int, TS[Order]]) -> TSD[int, TS[str]]:\n    return map_(lambda order: const(\"order_id\"), order)\n```\n\n----------------------------------------\n\nTITLE: Implementing Corrected HGraph Rank Compute Node in Python\nDESCRIPTION: Presents the corrected implementation of the `rank` compute node. The normalization formula is adjusted by changing the divisor from `sz` to `(sz-1.0)` to correctly map the ranks to the range [-1.0, 1.0], inclusive of the endpoints. Requires HGraph library.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/code_organisation.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef rank(raw_signal: TSD[str, TS[float]]) -> TSD[str, TS[float]]:\n    \"\"\"\n    Takes a raw_signal that needs to be evenly normalised over the range [-1.0,1.0].\n    \"\"\"\n    sz = len(raw_signal)\n    keys = (k for _, k in sorted((v, k) for k, v in raw_signal.value))\n    return {k: (-1.0 + i*2.0/(sz-1.0)) for k, i in zip(keys, range(sz))}\n```\n\n----------------------------------------\n\nTITLE: Defining and Plotting an hgraph Time Series from a Polars DataFrame Source (Python)\nDESCRIPTION: Demonstrates creating an hgraph time series bundle from a Polars DataFrame. It defines a custom `MyDataFrameSource` class inheriting from `PolarsDataFrameSource`, initializes it with a sample Polars DataFrame using minimal datetime constants (`MIN_ST`, `MIN_TD`). It then uses `tsb_from_data_source` to convert this source into a time series bundle `t`, specifying 'date' as the time index column, and finally plots the bundle. Requires `polars`, `hgraph`, and `hgraph.adaptors.data_frame`.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/examples/notebook/example_book.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport polars as pl\nfrom hgraph.adaptors.data_frame import PolarsDataFrameSource, tsb_from_data_source\nfrom hgraph import MIN_ST,MIN_TD\n\nclass MyDataFrameSource(PolarsDataFrameSource):\n    \n    def __init__(self):\n        super().__init__(\n            pl.DataFrame(\n                {\n                    \"date\": [MIN_ST, MIN_ST+MIN_TD, MIN_ST+2*MIN_TD],\n                    \"a\": [1.0, 2.0, 3.0],\n                    \"b\": [2.0, 4.0, 8.0]\n                }\n            )\n        )\n    \nt = tsb_from_data_source(MyDataFrameSource, 'date')\nt.plot()\n```\n\n----------------------------------------\n\nTITLE: Defining a Compute Node with compute_node Decorator in Python\nDESCRIPTION: This example demonstrates a compute node in HGraph, decorated with @compute_node, which takes two integer-valued time-series as input and produces a single output time-series by summing the current values of inputs. The function is triggered when an input changes. Requires the @compute_node decorator, TS type for time-series, and int type. Input parameters a and b are TS[int] and are accessed with their .value property. Output is of type TS[int].\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/node_based_computation.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\n    def sum_a_b(a: TS[int], b: TS[int]) -> TS[int]:\n        return a.value + b.value\n```\n\n----------------------------------------\n\nTITLE: Defining a Compute Node with compute_node Decorator in hgraph (Python)\nDESCRIPTION: This snippet illustrates the use of the compute_node decorator to define a processing node in hgraph that takes two time-series integer inputs and returns their sum as a new time-series output. The node function my_compute_node relies on the presence of a and b as TS[int] (time-series of integers) and accesses their .value property. The output is an integer time-series. Dependencies include the hgraph package (compute_node and TS). The compute node will be triggered whenever input values change.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/quick_start/node.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom hgraph import compute_node, TS\n\n@compute_node\ndef my_compute_node(a: TS[int], b: TS[int]) -> TS[int]:\n    return a.value + b.value\n```\n\n----------------------------------------\n\nTITLE: Implementing Windowed State with hgraph Compute Node - Python\nDESCRIPTION: Demonstrates how to use state injection in hgraph compute nodes for windowed data processing. The window function maintains an internal deque buffer in the injected state object, which is initialized in a corresponding start function. Required dependency: hgraph. Parameters include an integer time series ('ts'), window size, and an optional injected state. Returns a tuple containing the windowed values when the buffer reaches the defined size. If not enough values are present, the result is None.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/injectable_attributes.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, TS, STATE\n\n\n@compute_node\ndef window(ts: TS[int], size: int, _state: STATE = None) -> TS[tuple[int, ...]]:\n    window = _state.window\n    window.append(ts.value)\n    if len(window) == size:\n        return tuple(window)\n\n\n@window.start\ndef window_start(size: int, _state: STATE) -> STATE[int]:\n    from collections import deque\n    _state.window = deque(maxlen=size)\n```\n\n----------------------------------------\n\nTITLE: Arrow Function Pipelines with Operator Overloading (Python)\nDESCRIPTION: Illustrates how an arrow-wrapped value is piped to a downstream function using the | operator, exemplifying the monoidal Arrow-style API for composing time-series operations. The right-side argument is a regular function (lambda or wrapped compute node) and can be debug-printed within the pipeline.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/arrow/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\narrow(1) | arrow(lambda x: debug_print(\"Out\", x))\n```\n\n----------------------------------------\n\nTITLE: Performing Input Validity Checks in a Compute Node using Python\nDESCRIPTION: This Python snippet is the typical body logic of a compute node's handler function in the hgraph framework, manually checking the validity of 'market_data' and 'parameters' before proceeding. If both are valid, application-specific checks are run and a result is returned; otherwise, False is returned. This pattern ensures only meaningful, properly-validated input data can cause acceptance, reducing invalid output propagation.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/node_based_computation.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nif market_data.valid and parameters.valid:\n    # Perform checks\n    ...\n    return result\nelse:\n    return False\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Previous Output in a Compute Node (Python)\nDESCRIPTION: This snippet shows a compute node function that uses the special `_output` argument to access the previous value of its own output time series. The `_output` argument is typed using `TSOut[int]` for type hinting and represents the output time series. The function calculates the new output value by incrementing the previous value (`_output.value`). This pattern avoids storing the previous output in the node's state.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/node_signature.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef count(ts: TIME_SERIES_TYPE, _output: TSOut[int]) -> TS[int]:\n    return _output.value + 1\n```\n\n----------------------------------------\n\nTITLE: Mapping Over Collections Using map_ in HGraph - Python\nDESCRIPTION: This snippet demonstrates the use of the map_ function in HGraph to transform a collection of time-series data nodes (TSD) by mapping a compute_node over each element. It includes creating a converter node, then mapping it over a TSD structure to return a new collection with type conversion. Requires hgraph and dependent types (TS, TSD, compute_node, graph, map_). Inputs are a TSD[str, TS[int]], output is TSD[str, TS[str]].\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/map_reduce_switch.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, TS, graph, TSD, map_\n\n\n@compute_node\ndef convert(ts: TS[int]) -> TS[str]:\n    \"\"\"Convert the input to a time series.\"\"\"\n    return str(ts.value)\n\n\n@graph\ndef graph(tsd: TSD[str, TS[int]]) -> TSD[str, TS[str]]:\n    return map_(convert, tsd)\n\n```\n\n----------------------------------------\n\nTITLE: Registering and Using an hgraph Service (Python)\nDESCRIPTION: Demonstrates the registration and usage of an hgraph service. The `main` graph function registers the `static_account_ids` implementation using `register_service`, binding it to the `default_path`. The `my_logic` graph function then consumes the service by calling the interface `account_ids()`, implicitly using the `default_path` to retrieve the shared account IDs.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/services.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef main():\n    register_service(default_path, static_account_ids)\n    ...\n\n@graph\ndef my_logic():\n    ...\n    accounts = account_ids()\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Operator Interface with hgraph Decorators (Python)\nDESCRIPTION: This snippet demonstrates how to use the @operator decorator from the hgraph framework to create a generic operator interface, such as 'add_', supporting multiple implementations. The TIME_SERIES_TYPE is used to keep the function generic, serving as a template for downstream overloads. No behavior is defined here; it acts as a protocol or interface that can later be implemented with specific types. Dependencies: hgraph library.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/developers_guide/library_writers_guide.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import operator, TIME_SERIES_TYPE\n\n@operator\ndef add_(lhs: TIME_SERIES_TYPE, rhs: TIME_SERIES_TYPE) -> TIME_SERIES_TYPE:\n    \"\"\" My documentation \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Compute Node with Implicit Type Resolution in hgraph (Python)\nDESCRIPTION: This snippet shows how to use the previously defined generic `add` function within an `hgraph` graph (`main`). It calls `add` with integer scalars (1 and 2), which `hgraph` implicitly converts to `const` time-series (`TS[int]`). The `TypeVar` `NUMERIC` in `add` is implicitly resolved to `int`, and the result is printed using `debug_print`. Dependencies include `graph`, `run_graph`, `debug_print` from `hgraph`, and the previously defined `add` function.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/generics.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n```python\n@graph\ndef main():\n    debug_print(\"1+2\", add(a=1, b=2))\n\n\nrun_graph(main)\n```\n```\n\n----------------------------------------\n\nTITLE: Evaluating the Main Graph using HGraph in Python\nDESCRIPTION: This snippet demonstrates how to import the necessary HGraph modules, define a main graph via the @graph decorator, initialize a GraphConfiguration, and launch graph evaluation using evaluate_graph. Users must have the hgraph package installed and available in their Python environment. The key parameters are the main graph function and configuration instance; the graph is expected to be constructed by the user. This approach works for both real-time and simulation modes depending on later configuration.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/quick_start/run_loop.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom hgraph import evaluate_graph, GraphConfiguration, graph\\n\\n@graph\\ndef my_main_graph():\\n    ...\\n\\n...\\nconfig = GraphConfiguration()\\nevaluate_graph(my_main_graph, config)\\n\n```\n\n----------------------------------------\n\nTITLE: Registering HTTP Server Handler with Tornado Adaptor in Python\nDESCRIPTION: This function facilitates the creation and registration of an HTTP server handler using the Tornado-based adaptor. It serves as the main entrypoint for exposing server logic and routes within the hgraph framework. Input parameters typically include route patterns and handler callbacks; output is a bound server-side interface for processing HTTP requests. Requires Tornado and hgraph to be installed.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/http_api.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. autofunction:: hgraph.adaptors.tornado.http_server_adaptor.http_server_handler\n```\n\n----------------------------------------\n\nTITLE: Applying Lambda Function with map_ in HGraph (Python)\nDESCRIPTION: Shows how to use the `map_` operator in HGraph to apply a lambda function (element-wise addition) to corresponding elements of two time-series dictionaries (`TSD`). The result is a new `TSD` containing the sums. `map_` dynamically creates graph instances for each unique key present in the input `TSD`s.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\na: TSD[str, TS[float]] = ...\nb: TSD[str, TS[float]] = ...\nc: TSD[str, TS[float]] = map_(lambda a, b: a + b, a, b)\n```\n\n----------------------------------------\n\nTITLE: Optimizing Node Activations using REF Inputs in hgraph Python\nDESCRIPTION: This refactored hgraph compute node employs REF typing for on_true and on_false inputs (and output), signaling that only reference changes (not value changes) on those inputs should cause re-evaluation. This dramatically reduces unnecessary activations when the value itself is not needed. Dependencies: hgraph, REF/OUT types. Inputs: condition (TS[bool]), on_true/on_false (REF[OUT]). Output: REF[OUT]. Functionally similar to the value-variant select, but activates less frequently.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/node_based_computation.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef select(condition: TS[bool], on_true: REF[OUT], on_false: REF[OUT]) -> REF[OUT]:\n    if condition.value:\n        if on_true.ticked or condition.ticked:\n            return on_true.value\n    else:\n        if on_false.ticked or condition.ticked:\n            return on_false.value\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Subscription Service Interface in hgraph (Python)\nDESCRIPTION: Defines the interface for a subscription service named `market_data` using the `@subscription_service` decorator. This service accepts a time-series (`TS`) of instrument IDs (strings) and an optional `path`. It returns a time-series (`TS`) of corresponding market prices (floats). Subscription services manage dynamic data streams where subscribers receive initial data and ongoing updates.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/services.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@subscription_service\ndef market_data(instrument_id: TS[str], path: str=default_path) -> TS[float]:\n    \"\"\" A simplified concept of subscription to market data returning a mid price \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Basic Reduction of TSD with reduce in HGraph (Python)\nDESCRIPTION: Illustrates a simple application of the `reduce` operator in HGraph to aggregate a time-series dictionary (`values`) into a single time-series value (`result`). It uses the `add_` binary operator and implicitly requires a `zero` operator defined for `TS[float]` and `add_`. The reduction graph dynamically adjusts as keys are added or removed from the `TSD`.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nvalues: TSD[str, TS[float]]\nresult: TS[float] = reduce(add_, values)\n```\n\n----------------------------------------\n\nTITLE: Defining a Reference Service Interface in hgraph (Python)\nDESCRIPTION: Defines the interface for a reference service named `account_ids` using the `@reference_service` decorator. This service is intended to provide a time-series set (`TSS`) of strings representing available client IDs. It accepts an optional `path` parameter, which defaults to `default_path`. Reference services are suitable for sharing static or infrequently updated data.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/services.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@reference_service\ndef account_ids(path: str = default_path) -> TSS[str]:\n    \"\"\" The set of available clients \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing HGraph Time-Series List (TSL) Elements in Python\nDESCRIPTION: Shows how to create a non-peered `TSL` (Time-Series List) of `TS[int]` using the `from_ts` constructor with individual time-series (`ts_1`, ..., `ts_n`). It also demonstrates accessing TSL elements both at wiring time using a literal index (`tsl[2]`) and at run-time within a compute node (`my_other_func`) using a time-series index (`tsl[ndx.value].value`). `SIZE` is a placeholder for the required size specification.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/hg_types.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntsl: TSL[TS[int], SIZE].from_ts(ts_1, ..., ts_n)\n...\n\nmy_func(tsl[2])  # at wiring time extract the 3rd element\n\n@compute_node\ndef my_other_func(tsl: TSL[TS[int], SIZE], ndx: TS[int]) -> TS[int]:\n    return tsl[ndx.value].value\n```\n\n----------------------------------------\n\nTITLE: Marking Pass-Through and Using Key Sets in map_ - HGraph Python\nDESCRIPTION: This example demonstrates using pass_through to mark inputs and specifying a key set (__keys__) for determining mapping over a TSD time-series dictionary. The print_input sink_node outputs change tracking for each key and value, and the snippet highlights how to control the mapping operation and override default input interpretations. Requires hgraph (TS, graph, TSD, map_, pass_through, TIME_SERIES_TYPE, sink_node) and hgraph.test (eval_node).\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/map_reduce_switch.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import sink_node, TS, graph, TSD, map_, pass_through, TIME_SERIES_TYPE\nfrom hgraph.test import eval_node\n\n@sink_node\ndef print_input(key: TS[str], ts: TIME_SERIES_TYPE, mode: str):\n    print(f\"[{mode}] {key.value}: {ts.delta_value}\")\n\n\n@graph\ndef graph_undecided(tsd: TSD[str, TS[int]]):\n    map_(print_input, tsd, \"No Passthrough\")\n    map_(print_input, pass_through(tsd), \"Passthrough\", __keys__=tsd.key_set)\n\n\nprint(eval_node(graph_undecided, tsd=[{\"a\": 1, \"b\": 6}, {\"a\": 2, \"b\": 7}]))\n\n```\n\n----------------------------------------\n\nTITLE: Constructing a Simple hgraph Graph with Nodes (Python)\nDESCRIPTION: This snippet provides a complete example of a simple hgraph graph. It imports necessary components (`graph`, `const`, `debug_print`) from the `hgraph` library. The `@graph` decorated function `my_graph` creates a constant node (`const(\"World\")`) and wires its output to a debug printing node (`debug_print`), effectively creating a graph with two nodes and one edge connecting them.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/quick_start/graph.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, const, debug_print\n\n@graph\ndef my_graph():\n    c = const(\"World\")\n    debug_print(\"Hello\", c)\n```\n\n----------------------------------------\n\nTITLE: Testing an HGraph compute_node using eval_node and pytest\nDESCRIPTION: This Python snippet demonstrates how to test a simple HGraph `compute_node` named `add` using the `eval_node` function from `hgraph.test`. It utilizes `pytest.mark.parametrize` to define multiple test cases with different time-series inputs (`a`, `b`) and expected outputs. The `eval_node` function executes the `add` node with the provided inputs, simulating time steps, and the result is asserted against the expected list. Time-series inputs are represented as lists, where `None` indicates no value at a specific time step.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/node_testing.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pytest\n\nfrom hgraph import compute_node, TS\nfrom hgraph.test import eval_node\n\n\n@compute_node\ndef add(a: TS[int], b: TS[int]) -> TS[int]:\n    return a.value + b.value\n\n\n@pytest.mark.parametrize(\n    \"a,b,expected\", [\n       [[1, 2, 3], [2, 3, 4], [3, 5, 7]],\n       [[None, 2, None], [2, 3, 4], [None, 5, 6]],\n    ])\ndef test_add(a, b, expected):\n    assert eval_node(add, a=a, b=b) == expected\n```\n\n----------------------------------------\n\nTITLE: Defining a Compute Node with Selective Activation using hgraph Python\nDESCRIPTION: This Python snippet demonstrates the use of hgraph's @compute_node decorator to define a trade acceptor node with explicit input activation and validation constraints. Dependencies include the hgraph framework and type definitions for TradeRequest, L2Price, TradeParams, and corresponding TS/TSD types. The function triggers evaluation only on new trade requests and includes inline validity checks for data inputs; the return is determined by the validity and content of market data and parameters. Inputs are: trade_request (active tick trigger), market_data (data), parameters (data); output is a boolean indicating trade acceptance.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/node_based_computation.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@compute_node(active=(\"trade_request\",), valid=tuple())\ndef trade_acceptor(trade_request: TS[TradeRequest], market_data: TS[L2Price], parameters: TSD[TradeParams]) -> TS[bool]:\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Request-Reply Service Interface in hgraph (Python)\nDESCRIPTION: Defines the interface for a request-reply service named `create_order` using the `@request_reply_service` decorator. This service requires a `path` string and a time-series (`TS`) of `Order` objects as input. It returns a time-series (`TS`) of strings representing the IDs of the created orders. Request-reply services handle discrete, individual requests.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/services.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@request_reply_service\ndef create_order(path: str, order: TS[Order]) -> TS[str]:\n    \"\"\" Creates a new order and returns the order id of the newly created order\"\n```\n\n----------------------------------------\n\nTITLE: Building a Graph with Output and Input Ports (Python, HGraph)\nDESCRIPTION: This Python snippet illustrates constructing a simple HGraph computation graph using a decorator and node composition. The @graph-decorated function defines a \"const\" node whose output time-series is assigned to variable 'c', and a \"debug_print\" node that consumes 'c' as its input. This example demonstrates time-series output (from const) connected as input to another node (debug_print), with \"world\" as a scalar configuration. Assumes the presence of the HGraph library, as well as the 'const' and 'debug_print' node factories. Expected input is none (hardcoded value), and output is the graph reference; this code is designed for HGraph applications and requires proper node definitions and decorators.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/time_series_types.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n@graph\\ndef my_example_graph():\\n    c = const(\"world\")\\n    debug_print(\"hello\", c)\n```\n\n----------------------------------------\n\nTITLE: Setting up and Running the HGraph Evaluation Loop (Python)\nDESCRIPTION: Shows how to initialize HGraph's GraphConfig and execute the evaluation loop with a previously defined master graph. This snippet first checks if the script is running as the main program, then creates a new 'GraphConfig', and finally starts evaluating 'main' via 'hg.evaluate_graph'. Requires the master graph 'main' and the HGraph package to be defined and imported. Does not accept user input and outputs according to the runtime logic of HGraph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/getting_started.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nif __name__  == '__main__':\n    config = hg.GraphConfig()\n    hg.evaluate_graph(main, config)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Graph Selection with switch_ in HGraph (Python)\nDESCRIPTION: Shows how to use the `switch_` operator in HGraph to implement conditional graph execution. Based on the string value of the `selector` time-series, `switch_` instantiates either the `add_` or `sub_` node, wiring the `lhs` and `rhs` inputs to the selected node. When the `selector` changes, the old graph is stopped, and the new one is started.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import TS, graph, switch_, add_, sub_\n\n@graph\ndef graph_switch(selector: TS[str], lhs: TS[int], rhs: TS[int]) -> TS[int]:\n    return switch_(selector, {\n        \"add\": add_,\n        \"sub\": sub_,\n    }, lhs, rhs)\n```\n\n----------------------------------------\n\nTITLE: Initializing an hgraph Mesh for Dynamic Instantiation in Python\nDESCRIPTION: This Python code defines an hgraph graph named 'compute_a_plus_b' using the @graph decorator. It demonstrates how to initialize the graph 'f' using `mesh_`. The `__key_arg__` specifies 'k' as the key input, `__key_set__` initializes the mesh only with the key 'a+b' (using `const` and `frozenset`), and crucially, `__name__` assigns the name 'f' to this mesh instance. This naming allows the 'f' graph itself to recursively call `mesh_('f')` as shown in the previous snippet.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef compute_a_plus_b() -> TS[float]:\n    return mesh_(f,\n                 __key_arg__ = 'k',\n                 __key_set__ = const(frozenset({'a+b'}), TSS[str]),\n                 __name__='f')\n```\n\n----------------------------------------\n\nTITLE: Explicit Type Resolution for Generic hgraph Nodes (Python)\nDESCRIPTION: This snippet defines a `cast` compute node that takes a generic scalar time-series (`TS[SCALAR]`) and is intended to return a generic time-series type (`TIME_SERIES_TYPE`). Since the output type cannot be inferred directly from the input, the example demonstrates explicit type resolution using the `[]` syntax when calling `cast` within a `graph`. It shows how to resolve `TIME_SERIES_TYPE` to `TS[Mapping[int, str]]`, `TSL[TS[str], Size[2]]`, and `TSD[int, TS[str]]` respectively for different calls, using a `frozendict` as input. Dependencies include `Mapping`, `Size` from `typing`, `frozendict`, and various components from `hgraph` (`compute_node`, `TS`, `TSD`, `TSL`, `SCALAR`, `TIME_SERIES_TYPE`, `graph`, `run_graph`, `debug_print`).\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/generics.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n```python\nfrom typing import Mapping\nfrom frozendict import frozendict\nfrom hgraph import compute_node, TS, TSD, TSL, SCALAR, TIME_SERIES_TYPE, graph, run_graph, Size, debug_print\n\n@compute_node\ndef cast(value: TS[SCALAR]) -> TIME_SERIES_TYPE:\n    return value.value\n\n\n@graph\ndef main():\n    debug_print(\"TS[Mapping[int, str]]\", cast[TIME_SERIES_TYPE: TS[Mapping[int, str]]](value=frozendict({1: 'a'})))\n    debug_print(\"TSL[TS[str], Size[2]]\", cast[TIME_SERIES_TYPE: TSL[TS[str], Size[2]]](value=frozendict({1: 'a'})))\n    debug_print(\"TSD[int, TS[str]]\", cast[TIME_SERIES_TYPE: TSD[int, TS[str]]](value=frozendict({1: 'a'})))\n\n\nrun_graph(main)\n```\n```\n\n----------------------------------------\n\nTITLE: Defining an HGraph Compute Node with a Generic Output Type\nDESCRIPTION: Defines an HGraph `compute_node` function `do_something` that takes a concrete input type `TS[int]` but returns a generic output type `TS[SCALAR]`. The generic type `SCALAR` is defined elsewhere (likely as a `TypeVar`) and needs to be resolved when this function is used in a graph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef do_something(ts: TS[int]) -> TS[SCALAR]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining Time-Series Schemas with TimeSeriesSchema - Python\nDESCRIPTION: This snippet introduces the TimeSeriesSchema class, which serves as the base class for all time-series schemas utilized with TSD in hgraph. It provides the necessary structure and methods to model time-indexed data. Use this class as a superclass when defining new schemas for time-series data to ensure integration with TSD features.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/typing.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nhgraph.TimeSeriesSchema\n```\n\n----------------------------------------\n\nTITLE: Defining a TimeSeriesSchema in HGraph with Python\nDESCRIPTION: Establishes a schema for time-series data using HGraph's TimeSeriesSchema base class and Python's dataclass. Dependencies include hgraph (TimeSeriesSchema, TS) and dataclasses (dataclass). Fields (p1, p2) must be wrapped with the TS type to indicate that each is a time-series of the given type. Used for structuring complex time-series inputs to TSB types. Outputs a reusable, statically typed schema class for further integration.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/schema_based_types.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import TimeSeriesSchema, TS\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyTimeSeriesSchema(TimeSeriesSchema):\n    p1: TS[int]\n    p2: TS[str]\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic hgraph Graph Function (Python)\nDESCRIPTION: This snippet shows the basic structure for defining an hgraph graph using the `@graph` decorator. The function body (`...`) would contain the logic for wiring nodes together. This decorator marks the function as a graph definition to be processed by the hgraph engine during wiring time.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/quick_start/graph.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef my_graph():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a User Input Push Source Node with hgraph (Python)\nDESCRIPTION: This Python code demonstrates creating a push source node using the `@push_queue` decorator from the `hgraph` library. The `user_input` function, decorated with `@push_queue(TS[str])`, launches a separate thread (`_user_input`) to read lines from standard input. The received lines are injected into the graph via the `sender` callable. The main graph (`main`) consumes this input, prints it using `debug_print`, and uses `stop_engine` triggered by the \"exit\" command to terminate execution. The graph runs in real-time mode for up to 2 minutes. Dependencies include `hgraph`, `threading`, `sys`, and `datetime`.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/push_source_node.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n```python\nfrom typing import Callable\nimport sys\nfrom datetime import datetime, timedelta\nimport threading\nfrom hgraph import push_queue, TS, graph, run_graph, EvaluationMode, debug_print, if_true\nfrom hgraph.nodes import stop_engine\n\n\ndef _user_input(sender: Callable[[str], None]):\n    while(True):\n        s = sys.stdin.readline().strip('\\n')\n        sender(s)\n        if s == 'exit':\n            break\n\n\n@push_queue(TS[str])\ndef user_input(sender: Callable[[str], None]):\n    threading.Thread(target=_user_input, args=(sender,)).start()\n\n\n@graph\ndef main():\n    in_ = user_input()\n    debug_print(\">\", in_)\n    stop_engine(if_true(in_ == \"exit\"))\n\n\nrun_graph(main, run_mode=EvaluationMode.REAL_TIME, end_time=datetime.utcnow() + timedelta(minutes=2))\n```\n```\n\n----------------------------------------\n\nTITLE: Switching Between Functions at Runtime Using switch_ - HGraph Python\nDESCRIPTION: This example shows dynamic switching between operations ('add' and 'sub') based on a string selector with switch_, to perform either addition or subtraction in a TS[int] computation. Useful for runtime selection of function variants. Requires hgraph, TS, graph, switch_, add_, sub_. Input: selector (TS[str]), lhs/rhs (TS[int]), Output: TS[int].\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/map_reduce_switch.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import TS, graph, switch_, add_, sub_\n\n\n@graph\ndef graph_switch(selector: TS[str], lhs: TS[int], rhs: TS[int]) -> TS[int]:\n    return switch_(\n        selector,\n        {\n            \"add\": add_,\n            \"sub\": sub_,\n        }, lhs, rhs)\n\n```\n\n----------------------------------------\n\nTITLE: Handling Asynchronous Events with push_queue Source Node in hgraph (Python)\nDESCRIPTION: This snippet exemplifies an asynchronous (push-style) source node for hgraph using the push_queue decorator in Python. The function my_push_queue sets up a background thread to read from stdin, using the sender argument to enqueue events into the node. Required dependencies are hgraph (for push_queue and TS), sys, and threading. The sender parameter sends string values into the node as they are entered by the user. This node is suitable for event-driven/asynchronous sources like user input. The function must handle termination (e.g., 'exit') to stop the event stream properly.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/quick_start/node.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom hgraph import push_queue, TS\n\ndef _user_input(sender: Callable[[str], None]):\n    while True:\n        s = sys.stdin.readline().strip(\"\\n\")\n        sender(s)\n        if s == \"exit\":\n            break\n\n@push_queue(TS[str])\ndef my_push_queue(sender: Callable[[str], None]) -> TS[str]:\n    threading.Thread(target=_user_input, args=(sender,)).start()\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TSB with Sphinx Autoclass (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` feature to automatically generate documentation for the Python class `hgraph.TSB`. The `:members:` option ensures that all documented members of the class are included. This class represents a time-series bundle in HGraph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TSB\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Using TSB with a Time-Series Schema in HGraph\nDESCRIPTION: Illustrates how to use a `TSB` (Time-Series Bundle) typed with a previously defined `MySchema` within an HGraph graph function. The example shows how to access the individual time-series components (like `tsb.p2`) within the TSB using attribute syntax. HGraph's type system ensures the type consistency, validating that `tsb.p2` is indeed `TS[int]`.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef my_function(tsb: TSB[MySchema]) -> TS[int]:\n    return tsb.p2\n```\n\n----------------------------------------\n\nTITLE: Defining a Push Source Node with push_queue Decorator in Python\nDESCRIPTION: This code defines a push-based source node using the @push_queue decorator with a specified output type. The decorated function receives a sender callback that allows it to push new values into the graph asynchronously, typically from another thread or callback source. The node is only supported in real-time execution mode. Requires the @push_queue decorator, Callable, TS, and SCALAR type definitions. The function should handle external event binding or thread launching as needed.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/node_based_computation.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@push_queue(TS[bool])\n    def my_message_sender(sender: Callable[[SCALAR], None]):\n        ...\n```\n\n----------------------------------------\n\nTITLE: Specifying Input Constraints Using the requires Parameter (Python)\nDESCRIPTION: This snippet illustrates how to use the requires argument in hgraph node decorators to validate input arguments beyond type checks. The '_check_int_convertable' function validates scalars, enabling or rejecting the overload based on logic in the function. This mechanism facilitates context-aware node activation. Dependencies: hgraph, Python typing.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/developers_guide/library_writers_guide.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import TS, generator, SCALAR, MIN_ST\n\ndef _check_int_convertable(m, s) -> bool:\n    \"\"\"\n    As with resolvers m and s represent the resolved types and the scalar values.\n    True implies the requires is successful. False fails the resolution.\n    \"\"\"\n    try:\n        int(s['v'])\n        return True\n    finally:\n        return False\n        \n\n@generator(requires=_check_int_convertable)\ndef int_const(v: SCALAR) -> TS[int]:\n    yield MIN_ST, int(v)\n```\n\n----------------------------------------\n\nTITLE: Defining a Dynamically Switching hgraph Graph in Python\nDESCRIPTION: This Python code defines an hgraph graph named 'f' using the @graph decorator. It takes a time-series string 'k' as input and returns a time-series float. The `switch_` function routes execution based on the value of 'k', returning constant floats for 'a' and 'b'. For 'a+b', it dynamically calls the parent mesh (named 'f') using `mesh_('f')` to retrieve the outputs for keys 'a' and 'b' and sums them, demonstrating recursive mesh instantiation.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, TS, switch_, const, mesh_\n\n@graph\ndef f(k: TS[str]) -> TS[float]:\n    return switch_(\n        k,\n        {\n            'a': lambda : const(1.0),\n            'b': lambda : const(2.0),\n            'a+b': lambda: mesh_('f')['a'] + mesh_('f')['b']\n        },\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing a Sink Node with sink_node Decorator in hgraph (Python)\nDESCRIPTION: This Python snippet showcases a sink node in hgraph, implemented with the sink_node decorator. The function my_sink_node consumes a string time-series (TS[str]) and prints each received value to stdout. There is no return value as sink nodes are designed only to consume, not produce, time-series events. Dependencies: hgraph (sink_node and TS). The main parameter, a, is the input time-series. The node marks the end of the chain in a DAG and helps determine completion of graph evaluation cycles.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/quick_start/node.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom hgraph import sink_node, TS\n\n@sink_node\ndef my_sink_node(a: TS[str]):\n    print(a.value)\n```\n\n----------------------------------------\n\nTITLE: Creating a Generator-Based Source Node Using hgraph in Python\nDESCRIPTION: This snippet demonstrates the implementation of a pull-style source node in hgraph using the generator decorator in Python. It defines a my_generator function that emits a time-series of integer values, scheduled according to calculated times. Dependencies include the hgraph package and its generator, TS, MIN_ST, and MIN_TD elements. The generator produces ten integer values with their corresponding times as output, and does not require any time-series input. The main limitation is its unsuitability for asynchronous data sources.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/quick_start/node.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom hgraph import generator, TS, MIN_ST, MIN_TD\n\n@generator\ndef my_generator() -> TS[int]:\n    for i in range(10):\n        yield MIN_ST + i * MIN_TD, i\n```\n\n----------------------------------------\n\nTITLE: Configuring exception_time_series Parameters in hgraph (Python)\nDESCRIPTION: Illustrates adjusting exception reporting by configuring trace_back_depth and capture_values when using exception_time_series. By increasing trace_back_depth and enabling value capture, the snippet provides enhanced debugging information for errors in node evaluation. Prerequisites include a functioning hgraph environment. The adjusted parameters affect the granularity of the error report, especially useful for diagnosing complex graph errors.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/exception_handling.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom hgraph import graph, const, exception_time_series, debug_print\n\n@graph\ndef capture_an_exception():\n    a = const(1.0) + const(2.0)\n    b = const(0.0)\n    c = a / b\n    e = exception_time_series(c, trace_back_depth = 2, capture_values = True)\n    debug_print(\"a / b\", c)\n    debug_print(\"exception\", e)\n```\n\n----------------------------------------\n\nTITLE: Defining Arrow Combinators (swap, second, assoc, cross_over, fanout, apply) in Python\nDESCRIPTION: Defines several standard Arrow combinator functions using the 'arr' helper. 'swap' reverses elements in a pair. 'second' applies a function to the second element of a pair using 'swap' and 'first'. 'assoc' rearranges nested pairs. 'cross_over' (equivalent to '***' in Haskell) applies two different functions to the elements of a pair independently. 'fanout' (equivalent to '&&&' in Haskell) applies two functions to the same input, producing a pair of results. 'apply' applies a function contained in the first element of a pair to the second element.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nswap = arr(lambda pair: (pair[1], pair[0]))\n\ndef second(f: Arrow[B, C]) -> Arrow[tuple[D, B], tuple[D, C]]:\n    return swap >> first(f) >> swap\n\ndef assoc(pair):\n    (a, b), c = pair\n    return a, (b, c)\n\ndef cross_over(f: Arrow[A, B], g: Arrow[C, D]) -> Arrow[tuple[A, C], tuple[B, D]]:\n    # In the paper this uses *** as the operator\n    # Allowing f *** g to be used\n    return first(f) >> second(g)\n\ndef fanout(f: Arrow[A, B], g: Arrow[A, C]) -> Arrow[A, Tuple[B, C]]:\n    # Uses &&& in the paper allowing for syntax such as f &&& g\n    return arr(lambda b: (b, b)) >> cross(f, g)\n\ndef apply(pair):\n    return arr(lambda pair: pair[0](pair[1]))\n```\n\n----------------------------------------\n\nTITLE: Defining a Time-Series List (TSL) Type in HGraph\nDESCRIPTION: Represents a fixed-size, homogeneous collection (list) of time-series signals in HGraph. 'TIME_SERIES_TYPE' specifies the type of the contained time-series, and 'SIZE' specifies the fixed number of elements in the list. Due to Python generic limitations, SIZE must be represented as a type (e.g., Size[2]).\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nTSL[TIME_SERIES_TYPE, SIZE]\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Type Variable in an HGraph Compute Node\nDESCRIPTION: Shows how to use the previously defined `NUMBER_TYPE` generic in the signature of an HGraph `compute_node` function named `add_`. The function takes two time-series inputs (`lhs`, `rhs`) and returns a time-series output, all constrained to the same concrete type (either `TS[int]` or `TS[float]`) resolved during graph wiring.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef add_(lhs: TS[NUMBER_TYPE], rhs: TS[NUMBER_TYPE]) -> TS[NUMBER_TYPE]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining Independent Generic Type Variables in HGraph\nDESCRIPTION: Illustrates how to create two independent generic type variables, `NUMBER_TYPE_1` and `NUMBER_TYPE_2`, with the same constraints (`int`, `float`). Using `hgraph.clone_type_var` ensures that these variables can be resolved to different concrete types independently during graph wiring.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import clone_type_var\n\nNUMBER_TYPE_1 = TypeVar(\"NUMBER_TYPE_1\", int, float)\nNUMBER_TYPE_2 = clone_type_var(NUMBER_TYPE_1, \"NUMBER_TYPE_2\")\n```\n\n----------------------------------------\n\nTITLE: Checking Global State Before Node Resolution Using requires (Python)\nDESCRIPTION: This example shows validating node usage with a lambda in the requires argument that checks the GlobalState before activating a graph overload. If the specified flag in global state is not set, the implementation is not considered a match for that context. This enables context-sensitive overloading. Dependencies: hgraph, GlobalState.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/developers_guide/library_writers_guide.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import GlobalState, graph, TS, record\n\n@graph(overloads=record, requires=lambda m, s: GlobalState.instance().get(\"record_to_memory\", False))\ndef record_to_memory(ts: TS[float], key: str, record_delta_values: bool = True, suffix: str = None):\n    ...\n```\n\n----------------------------------------\n\nTITLE: De-duplicating Time Series Output via Output Injectable in hgraph Python\nDESCRIPTION: Here, a compute node uses the '_output' injectable to implement de-duplication: it only returns a new value if the current output is either invalid or differs from the new input. It requires the hgraph framework, a scalar TS type, and optionally an output injectable TS_OUT. Only values different from the previous state are propagated; otherwise, no result is produced, avoiding redundant output ticks. Inputs: ts (time series scalar), _output (output proxy). Output: scalar or None if duplicate.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/node_based_computation.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef de_dup(ts: TS[SCALAR], _output: TS_OUT[SCALAR] = None) -> TS[SCALAR]:\n    if _output.valid and _output.value == ts.value:\n        return\n    else:\n        return ts.value\n\n```\n\n----------------------------------------\n\nTITLE: Calling a Request-Reply Service in hgraph (Python)\nDESCRIPTION: Illustrates how user code calls the `create_order` request-reply service. It defines the target `order_path` and provides the `order` time-series input (assuming `Order` type and `TS` are defined elsewhere). The function call `create_order(order_path, order)` initiates the request and returns the `order_id` time-series. Each such call instance within the graph is assigned a unique internal identifier by the framework.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/services.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n...\norder_path = \"main_order_handler\"\norder: TS[Order] = ...\norder_id = create_order(order_path, order)\n...\n```\n\n----------------------------------------\n\nTITLE: Dynamic Graph Construction with mesh_, switch_, and const - HGraph Python\nDESCRIPTION: This code presents an advanced dynamic graph where mesh_ instantiates a function 'f' for each key, supporting recursive key extension inside f. The function f switches the computation path (e.g., 'a', 'b', 'a+b'), and compute_a_plus_b builds a mesh over a custom key set. Demonstrates use of __key_arg__, __key_set__, and __name__ in mesh_. Requires hgraph (graph, TS, switch_, const, mesh_, TSS). Inputs vary by graph; outputs are TS[float].\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/map_reduce_switch.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, TS, switch_, const, mesh_\n\n@graph\ndef f(k: TS[str]) -> TS[float]:\n    return switch_(\n        k,\n        {\n            'a': lambda : const(1.0),\n            'b': lambda : const(2.0),\n            'a+b': lambda: mesh_('f')['a'] + mesh_('f')['b']\n        },\n    )\n\n@graph\ndef compute_a_plus_b() -> TS[float]:\n    return mesh_(f, \n                 __key_arg__ = 'k', \n                 __key_set__ = const(frozenset({'a+b'}), TSS[str]), \n                 __name__='f')\n\n```\n\n----------------------------------------\n\nTITLE: Running an HGraph Graph in Simulation Mode (Python)\nDESCRIPTION: Demonstrates how to execute an HGraph graph using the `run_graph` function. This function takes the graph definition (`main` in this case) as input, builds the computational graph by connecting the nodes as defined, and then runs the graph in simulation mode. The execution proceeds based on the ticks generated by the source nodes.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/graphs_and_nodes.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import run_graph\n\nrun_graph(main)\n```\n\n----------------------------------------\n\nTITLE: Integrating Inspector Node with Perspective Web in Hgraph (Python)\nDESCRIPTION: This Python code snippet illustrates the integration of the 'inspector' node for real-time visualization and introspection of an hgraph application's state. It demonstrates registering perspective adaptors, launching a web interface for graph inspection, and optionally configuring PerspectiveTablesManager to optimize client-side table performance. Dependencies include the hgraph library and perspective adaptors, and the main entrypoint is decorated with @graph. The code expects a running perspective service accessible via hostname and port, and outputs a URL for browser-based inspection.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/debug/inspector.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\\nfrom _socket import gethostname\\n\\nfrom hgraph import graph\\nfrom hgraph.adaptors.perspective import perspective_web, PerspectiveTablesManager, register_perspective_adaptors\\nfrom hgraph.debug import inspector\\n\\n@graph\\ndef main():\\n    inspector()\\n\\n    register_perspective_adaptors()\\n    perspective_web(gethostname(), 8080)\\n    \\n    # optional if you want to use the client side tables (improves performance for smaller frequently updated tables)\\n    PerspectiveTablesManager.set_current(PerspectiveTablesManager(host_server_tables=False))  \\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Time-Series Dictionary (TSD) Type in HGraph\nDESCRIPTION: Represents a dictionary where keys map to time-series signals, equivalent to a dictionary in FRP. 'K' specifies the type of the keys (e.g., str), and 'V' specifies the type of the time-series values associated with those keys. TSD is the only dynamically sizeable time-series collection, supporting the addition and removal of key-value pairs during runtime.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nTSD[K, V]\n```\n\n----------------------------------------\n\nTITLE: Defining and Using HGraph Time-Series Bundle (TSB) with Schema in Python\nDESCRIPTION: Demonstrates defining a `TimeSeriesSchema` named `MySchema` with `TS[int]` and `TS[str]` fields. It shows how to use a `TSB[MySchema]` (Time-Series Bundle) as an input in an HGraph graph (`my_graph`) and a sink node (`print_tsb`). Accessing bundle elements directly (`tsb.p2`) and using `as_schema` for type inference and value access (`tsb.as_schema.p1.value`) are illustrated. Necessary imports from `hgraph` and `hgraph.nodes` are included.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/hg_types.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import TimeSeriesSchema, TSB, TS, sink_node, graph\nfrom hgraph.nodes import debug_print\n\nclass MySchema(TimeSeriesSchema):\n    p1: TS[int]\n    p2: TS[str]\n    \n    \n@graph\ndef my_graph(tsb: TSB[MySchema]):\n    ...\n    debug_print(\"Test\", tsb.p2)\n    \n@sink_node\ndef print_tsb(tsb: TSB[MySchema]):\n    print(f\"p1: {tsb.as_schema.p1.value}, p2: {tsb.p2.value}\")\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Sink Node with sink_node Decorator in Python\nDESCRIPTION: This example defines a sink node using the @sink_node decorator, accepting a time-series of strings as input. The node consumes the latest value from its input and prints it, acting as a final output node in the graph. Requires the @sink_node decorator and TS[str] type for the input. The function has no output and is typically used for logging or side effects. Triggered when input changes.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/node_based_computation.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@sink_node\n    def write(ts: TS[str]):\n        print(ts.value)\n```\n\n----------------------------------------\n\nTITLE: Wiring an HGraph for Real-Time Processing using Kafka in Python\nDESCRIPTION: Defines an HGraph main graph (`real_time_main_graph`) for real-time data processing. It utilizes hypothetical `subscribe_kafka` and `publish_kafka` components (not shown) to receive market/sentiment data from Kafka topics and publish the generated signal. This illustrates wiring the same `generate_signal` logic for a real-time streaming context, requiring the `hgraph` library and the Kafka components.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/code_organisation.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef real_time_main_graph():\n    market_data = subscribe_kafka(\"market_data\")\n    sentiment = subscribe_kafka(\"sentiment\")\n    signal = generate_signal(market_data, sentiment)\n    publish_kafka(\"signal\", signal)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Type Resolvers for Generics in hgraph Nodes (Python)\nDESCRIPTION: This example details implementation of custom type resolution for generics in compute_node decorators. The '_resolve_type' function computes the resolved output type based on resolved input types and scalars, facilitating dynamic typing using schema metadata from compound scalar types. This is useful for advanced scenarios where default resolution rules do not suffice. Dependencies: hgraph, Python typing.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/developers_guide/library_writers_guide.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, COMPOUND_SCALAR, OUT, TS, HgTypeMetaData, TIME_SERIES_TYPE\nfrom typing import TypeVar, Any\n\ndef _resolve_type(mappings: dict[TypeVar: HgTypeMetaData], scalars: dict[str, Any]) -> TIME_SERIES_TYPE:\n    \"\"\"\n    mappings - the type vars that have been resolved so far\n    scalars - the scalar values provided to the function.\n    \n    This must return the resolved type\n    \"\"\"\n    cs = mappings[COMPOUND_SCALAR].py_type\n    key = scalars['key']\n    return TS[cs.__meta_data_schema__[key]]\n    \n\n@compute_node(resolvers={OUT: _resolve_type})\ndef select_field(ts: TS[COMPOUND_SCALAR], key: str) -> OUT:\n    return getattr(ts.value, key)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Reference Service in hgraph (Python)\nDESCRIPTION: Provides a concrete implementation (`static_account_ids`) for the `account_ids` reference service interface. It uses the `@service_impl` decorator, linking it to the `account_ids` interface. This specific implementation returns a constant `frozenset` containing \"a\" and \"b\" wrapped in the expected `TSS[str]` type using `hgraph.const`. The implementation signature matches the interface but omits the `path` parameter.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/services.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@service_impl(interfaces=[account_ids])\ndef static_account_ids() -> TSS[str]:\n    return const(frozenset(\"a\", \"b\"), TSS[str])\n```\n\n----------------------------------------\n\nTITLE: Printing Evaluation Clock Properties Using hgraph Sink Node - Python\nDESCRIPTION: Demonstrates accessing and printing evaluation time, current time, and cycle duration via the injected EvaluationClock parameter of an hgraph sink_node. Dependencies: hgraph. Parameters: an input time series and optional EvaluationClock. Outputs various time properties to standard output on each invocation. Useful for debugging or observing graph evaluation timing.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/injectable_attributes.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import sink_node, TIME_SERIES_TYPE, EvaluationClock\n\n@sink_node\ndef print_tick_time(ts: TIME_SERIES_TYPE, _clock: EvaluationClock = None):\n    print(\"Tick time: \", _clock.evaluation_time)\n    print(\"Now: \", _clock.now)\n    print(\"Cycle Time: \", _clock.cycle_time)\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Time-Series (TS) Type in HGraph\nDESCRIPTION: Represents the fundamental time-series type in HGraph, equivalent to a stream of scalar values over time in FRP. 'SCALAR' specifies the data type of the values within the stream (e.g., int, float, str). All non-time-series values in HGraph are expected to be immutable.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nTS[SCALAR]\n```\n\n----------------------------------------\n\nTITLE: Reducing Over TSD Collections Using reduce - HGraph Python\nDESCRIPTION: This code uses reduce to aggregate a TSD (dictionary-like time-series) into a single TS[int], specifically summing all values at each time tick using a built-in add_ operation and a zero-initializer. Demonstrates recursive aggregation over collections. Requires hgraph, TS, graph, TSD, reduce, add_. Input: TSD[str, TS[int]], Output: TS[int].\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/map_reduce_switch.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import TS, graph, TSD, reduce, add_\n\n\n@graph\ndef graph_reduce_tsd(tsd: TSD[str, TS[int]]) -> TS[int]:\n    return reduce(add_, tsd, 0)\n\n```\n\n----------------------------------------\n\nTITLE: Using a TimeSeriesSchema with the TSB Data Structure in HGraph (Python)\nDESCRIPTION: Demonstrates passing a type-annotated TSB instance, parameterized by a custom TimeSeriesSchema (MyTimeSeriesSchema), to a sink_node. Requires hgraph (TSB, sink_node) as dependencies. The function accesses the underlying time-series value (p1) and prints it, illustrating both how schemas integrate into TSB and runtime value access. Inputs are instances of TSB[MyTimeSeriesSchema]; output is printed data. Intended as part of a dataflow or processing pipeline.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/schema_based_types.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import TSB, sink_node\n\n@sink_node\ndef write(tsb: TSB[MyTimeSeriesSchema]):\n    print(\"p1\", tsb.p1.value)\n```\n\n----------------------------------------\n\nTITLE: Defining a Conditional Reference Switch in hgraph (Python)\nDESCRIPTION: This snippet defines a compute node \"if_\" using the hgraph library that takes a boolean condition and references to two time-series streams, returning a reference to the selected stream. The dependencies are hgraph, specifically the compute_node decorator, the REF, and TS types. Inputs are a TS[bool] for the condition, and two REF[TS[str]], with output as a REF[TS[str]]. The node reacts to changes in the condition or the referenced outputs. This approach ensures infrequent recomputation if only data values, not references, change.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/hg_types.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, REF, TS\n\n@compute_node\ndef if_(condition: TS[bool], true_: REF[TS[str]], false_: REF[TS[str]]) -> REF[TS[str]]:\n    if condition.value:\n        return true_.value\n    else:\n        return false_.value\n```\n\n----------------------------------------\n\nTITLE: Defining an HGraph Compute Node Function in Python\nDESCRIPTION: Illustrates the definition of an HGraph compute node function named `my_func` using the `@compute_node` decorator. It specifies type hints for its time-series input (`ts: TS[int]`) and time-series output (`-> TS[str]`), indicating it processes integer time-series data and produces string time-series data.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/hg_types.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef my_func(ts: TS[int]) -> TS[str]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Mapping Over TSL Collections Using map_ in HGraph - Python\nDESCRIPTION: This code shows mapping a function over a fixed-size sequence of time-series nodes (TSL) using map_. It relies on the convert function and takes a TSL[TS[int], Size[2]] input, returning a TSL[TS[str], Size[2]]. The snippet demonstrates use with bounded-length lists/arrays. Requires hgraph, TSL, Size, TS, and map_.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/map_reduce_switch.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, TSL, TS, Size, map_, convert\n\n@graph\ndef graph_tsl(tsl: TSL[TS[int], Size[2]]) -> TSL[TS[str], Size[2]]:\n    return map_(convert, tsl)\n\n```\n\n----------------------------------------\n\nTITLE: Explicitly Setting Instantiation Keys in map_ using __keys__ in HGraph (Python)\nDESCRIPTION: Demonstrates using the `__keys__` keyword argument in the `map_` operator to provide an explicit set of keys that determines which graph instances are created. In this example, only keys present in `b.key_set` will cause `my_logic` graph instances to be instantiated, regardless of the keys in `a` or `c`. This is useful for fine-grained control or when input key types differ.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef my_logic(a: TS[int], b: TS[int], c: TS[str]) -> TS[str]:\n    ...\n\na: TSD[str, TS[int]]\nb: TSD[str, TS[int]]\nc: TSD[str, TS[str]]\n\nresult = map_(my_logic, a, b, c, __keys__ = b.key_set)\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Compute Node with TypeVar in hgraph (Python)\nDESCRIPTION: This snippet demonstrates defining a generic `compute_node` named `add` using Python's `TypeVar`. It defines `NUMERIC` as a `TypeVar` constrained to `int` or `float`. The `add` function takes two time-series inputs (`TS`) of type `NUMERIC` and returns a time-series of the same resolved `NUMERIC` type, performing addition on the input values. Dependencies include `TypeVar` from `typing` and `compute_node`, `TS` from `hgraph`.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/generics.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n```python\nfrom typing import TypeVar\nfrom hgraph import compute_node, TS\n\nNUMERIC = TypeVar(\"NUMERIC\", int, float)\n\n\n@compute_node\ndef add(a: TS[NUMERIC], b: TS[NUMERIC]) -> TS[NUMERIC]:\n    return a.value + b.value\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Start/Stop Life-cycle Methods for hgraph Compute Nodes (Python)\nDESCRIPTION: This Python snippet demonstrates how to define `start` and `stop` life-cycle methods for an `hgraph` compute node. The `@compute_node` decorator defines the main node logic (`life_cycle_example`), while `@life_cycle_example.start` and `@life_cycle_example.stop` decorators register separate functions (`life_cycle_example_start`, `life_cycle_example_stop`) to be executed upon node initialization and termination, respectively. These handlers simply print messages to the console.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/life_cycle.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, TS\n\n\n@compute_node\ndef life_cycle_example(a: TS[str]) -> TS[str]:\n    return a.value\n\n\n@life_cycle_example.start\ndef life_cycle_example_start():\n    print(\"Start\")\n\n\n@life_cycle_example.stop\ndef life_cycle_example_stop():\n    print(\"Stop\")\n```\n\n----------------------------------------\n\nTITLE: Conditional Output Selection Based on Input Ticks using hgraph Python (Value Inputs)\nDESCRIPTION: This compute node demonstrates conditional value selection using standard time-series inputs for on_true and on_false branches. It leverages the hgraph framework and TS types; upon each tick, it evaluates the condition input and responds with the most recent ticked value from either on_true or on_false. Inputs: condition (boolean timeseries), on_true/on_false (output value proxies). Output: scalar or referenced OUT value.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/node_based_computation.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef select(condition: TS[bool], on_true: OUT, on_false: OUT) -> OUT:\n    if condition.value:\n        if on_true.ticked or condition.ticked:\n            return on_true.value\n    else:\n        if on_false.ticked or condition.ticked:\n            return on_false.value\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Time-Series Bundle (TSB) Type in HGraph\nDESCRIPTION: Represents a heterogeneous collection of time-series signals, akin to a class or struct in FRP. 'TS_SCHEMA' is a class definition that describes the structure and types of the time-series signals contained within the bundle.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nTSB[TS_SCHEMA]\n```\n\n----------------------------------------\n\nTITLE: Declaring a Graph Component with Multiple Outputs in Python\nDESCRIPTION: This snippet shows how to define a graph component that produces multiple un-named outputs using a dictionary of type-annotated values. The @graph decorator registers the function as a graph component. The return type is specified as a dictionary mapping output names to type-annotated time-series objects, which enables bundle outputs. Required dependencies include the @graph decorator and time-series type definitions such as TS[str] and TS[float]. The component can take any mix of arguments, and returns a dictionary with specific, named time-series outputs.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/component_signature.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef my_component() -> {\"out1\": TS[str], \"out2\": TS[float]}:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesOutput Base Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to generate documentation for the `hgraph.TimeSeriesOutput` Python class. It includes documented (`:members:`) and undocumented (`:undoc-members:`) members, and displays its inheritance hierarchy (`:show-inheritance:`). This class serves as a base for time-series output types.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_9\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesOutput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesInput Base Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to generate documentation for the `hgraph.TimeSeriesInput` Python class. It includes documented (`:members:`) and undocumented (`:undoc-members:`) members, and displays its inheritance hierarchy (`:show-inheritance:`). This class serves as a base for time-series input types.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_10\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesInput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Excluding Input Keys in map_ using no_key in HGraph (Python)\nDESCRIPTION: Illustrates the use of the `no_key` marker within a `map_` call in HGraph. This prevents the keys from the wrapped input (`market_data`) from influencing the creation of new graph instances, ensuring instances are only created based on the keys from other inputs (`requests` in this case). The `market_data` is still de-multiplexed and provided to the relevant graph instances.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef price(instrument_id: TS[str], request: TS[PriceRequest], market_data: TS[Price]) -> TS[Price]:\n    ...\n\nrequests = TSD[str, TS[PriceRequest]] = ...\nmarket_data = TSD[str, TS[Price]] = ...\n\nresult = map_(price, requests, no_key(market_data), __key_arg__ = 'instrument_id')\n```\n\n----------------------------------------\n\nTITLE: Unit Testing an HGraph Compute Node with Pytest and Eval_Node in Python\nDESCRIPTION: Demonstrates how to unit test an HGraph compute node (`rank`) using `pytest` and the `hgraph.test.eval_node` helper function. It uses `pytest.mark.parametrize` to define test cases with input time-series data (`raw_signal`) and expected output (`expected`), comparing the actual node output against the expectation. `frozendict` is used for immutable dictionary inputs/outputs in tests.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/code_organisation.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport pytest\nfrom hgraph.test import eval_node\nfrom frozendict import frozendict as fd\n\n@pytest.mark.parametrize(\n[\"raw_signal\", \"expected\"],\n[\n   [[fd(a=0.1, b=0.3, c=-3.0)], [fd(c=-1.0, a=0.0, b=1.0)]],\n   ...\n])\ndef test_rank(raw_signal, expected):\n    assert eval_node(rank, raw_signal) == expected\n```\n\n----------------------------------------\n\nTITLE: Defining an HGraph Signal Generation Stub in Python\nDESCRIPTION: Defines the initial structure of an HGraph graph named `generate_signal`. It takes two Time Series Dictionaries (TSD) keyed by string (instrument symbol) containing Time Series (TS) of floats (market data and sentiment) as input and outputs a TSD of floats representing the calculated signal. The docstring details the expected input types and value ranges.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/code_organisation.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, TSD, TS\n\n@graph\ndef generate_signal(market_data: TSD[str, TS[float]], sentiment: TSD[str, TS[float]]) -> TSD[str, TS[float]]:\n    \"\"\"\n    Extracts a signal from the sentiment and market_data provided.\n    The inputs and outputs are keyed by the instruments symbol represented as a string.\n    The market data is in USD and the sentiment is a value between -1. and 1. with\n    1. being the most positive sentiment and -1 being the most negative sentiment.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Constant String Time Series Node in hgraph (Python)\nDESCRIPTION: Creates an hgraph node `c` representing a constant time series that emits the string \"Hello World\" at every computational tick. This uses the `const` function within an active graph definition context initiated by `start_wiring_graph`.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/examples/notebook/example_book.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nc = const(\"Hello World\")\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesSignalInput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesSignalInput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an input specifically for signal-like time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_12\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesSignalInput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesValueOutput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesValueOutput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an output port for a standard value time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_13\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesValueOutput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Implementing a Feedback Loop in hgraph (Python)\nDESCRIPTION: This Python code demonstrates how to create and use a feedback loop in hgraph. A `compute_node` named `i_need_feedback` takes a time-series input (`ts`) and the previous cycle's output (`prev_ts` from feedback) to compute a new value. The `use_feedback` graph initializes a feedback variable `fb` with an initial value of 0.0, uses its current value via `fb()`, computes the output `out`, and then feeds this output back into the feedback variable using `fb(out)`. The `active` parameter in `compute_node` excludes the feedback input (`prev_ts`) to prevent infinite computation loops.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/feedback.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import feedback, TS, graph, compute_node\n\n\n@compute_node(active=(\"ts\",), valid=(\"ts\",))\ndef i_need_feedback(ts: TS[float], prev_ts: TS[float]) -> TS[float]:\n    return ts.value + prev_ts.value\n\n\n@graph\ndef use_feedback(ts: TS[float]) -> TS[float]:\n    fb = feedback(TS[float], 0.0)\n    out = i_need_feedback(ts, fb())\n    fb(out)\n    return out\n```\n\n----------------------------------------\n\nTITLE: Structuring an HGraph Signal Generation Graph with Sub-Components in Python\nDESCRIPTION: Expands the `generate_signal` graph by outlining its internal steps using stubbed sub-graphs (`compute_returns`, `combine_sentiment_and_returns`, `rank`). This demonstrates a top-down design approach, breaking the problem into smaller, manageable graph components. Each sub-graph defines its expected inputs and outputs using HGraph type hints.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/code_organisation.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef generate_signal(market_data: TSD[str, TS[float]], sentiment: TSD[str, TS[float]]) -> TSD[str, TS[float]]:\n    \"\"\"\n    ...\n    \"\"\"\n    returns = compute_returns(market_data)\n    combined = combine_sentiment_and_returns(returns, sentiment)\n    return rank(combined)\n\n@graph\ndef compute_returns(market_data: TSD[str, TS[float]) -> TSD[str, TS[float]]:\n    ...\n\n@graph\ndef combine_sentiment_and_returns(returns: TSD[str, TS[float]], sentiment: TSD[str, TS[float]]) -> TSD[str, TS[float]]:\n    ...\n\n@graph\ndef rank(raw_signal: TSD[str, TS[float]]) -> TSD[str, TS[float]]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesSetInput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesSetInput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an input port for a set-based time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_17\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesSetInput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesSetOutput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesSetOutput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an output port for a set-based time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_18\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesSetOutput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Providing Explicit Zero Value in reduce in HGraph (Python)\nDESCRIPTION: Demonstrates using the `reduce` operator in HGraph with an explicitly provided zero value (`MyDataType()`). This is necessary when a suitable `zero` operator cannot be automatically resolved for the given data type (`TS[MyDataType]`) and binary operator (`add_`). The `reduce` operator aggregates the `TSD` (`values`) into a single `TS` (`result`).\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nvalues: TSD[str, TS[MyDataType]]\nresult: TS[MyDataType] = reduce(add_, values, MyDataType())\n```\n\n----------------------------------------\n\nTITLE: Example of a Time-Series Dictionary (TSD) Definition in HGraph\nDESCRIPTION: An example showing a TSD where string keys map to time-series signals carrying float values. This illustrates a dynamic collection mapping string identifiers to floating-point time-series data.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nTSD[str, TS[float]]\n```\n\n----------------------------------------\n\nTITLE: Defining a Master Wiring Graph with HGraph (Python)\nDESCRIPTION: Defines a master wiring graph in HGraph using the @hg.graph decorator and a main function. Within the graph, 'hg.debug_print' outputs 'Hello' and 'World'. Assumes HGraph has been imported as 'hg'. The main() function can be invoked by the HGraph runtime to set up processing, and expects no parameters or return values. The key dependency is HGraph itself.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/getting_started.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@hg.graph\ndef main():\n    hg.debug_print(\"Hello\", \"World\")\n```\n\n----------------------------------------\n\nTITLE: Registering Pre/Post Evaluation Hooks with EvaluationEngineApi in hgraph - Python\nDESCRIPTION: This example shows how to inject the EvaluationEngineApi object into a hgraph compute node to register before- and after-evaluation callbacks using the node's input. Dependencies: hgraph. Input is a time-series integer. The injected engine enables adding notifications to be executed pre- and post-evaluation, useful for logging, auditing, or custom hooks. The node returns the current input value.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/injectable_attributes.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, TS, EvaluationEngineApi\n\n@compute_node\ndef register_hooks(ts: TS[int], _engine: EvaluationEngineApi = None) -> TS[int]:\n    _engine.add_after_evaluation_notification(lambda: print(f\"After evaluation [{ts.value}]\"))\n    _engine.add_before_evaluation_notification(lambda: print(f\"Before evaluation [{ts.value}]\"))\n    return ts.value\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesList Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesList` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents the implementation of a time-series containing list values.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_20\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesList\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Defining a Time-Series Set (TSS) Type in HGraph\nDESCRIPTION: Represents the time-series equivalent of a set in FRP, describing the changes in a collection of unique, hashable values over time. 'SCALAR' must be a hashable type.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nTSS[SCALAR]\n```\n\n----------------------------------------\n\nTITLE: Using Independent Generics in an HGraph Compute Node\nDESCRIPTION: Shows the usage of independent generic type variables (`NUMBER_TYPE_1`, `NUMBER_TYPE_2`) in an HGraph `compute_node` function `div_`. This allows the input time-series `lhs` and `rhs` to have potentially different concrete types (e.g., `TS[int]` and `TS[float]`) while still respecting the `int`/`float` constraint for each. The output type is fixed to `TS[float]`.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef div_(lhs: TS[NUMBER_TYPE_1], rhs: TS[NUMBER_TYPE_2]) -> TS[float]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Delaying Values Using the Scheduler in hgraph - Python\nDESCRIPTION: Shows how to delay time-series emission by one timestep using the injected Scheduler and State objects in hgraph compute nodes. This implementation leverages the scheduler's schedule() and is_scheduled features, and the state attribute to hold the last value. State is initialized with last_value = None. Dependencies: hgraph. Parameters: a time-series integer input, optional scheduler, and state. Outputs input value delayed by one activation; outputs None if unavailable.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/injectable_attributes.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, TS, SCHEDULER, STATE, MIN_TD\n\n\n@compute_node\ndef lag(ts: TS[int], _scheduler: SCHEDULER = None, _state: STATE = None) -> TS[int]:\n    \"\"\"Lag the input by one time step.\"\"\"\n    out = None\n    if _scheduler.is_scheduled:\n        out = _state.last_value\n\n    if ts.modified:\n        _scheduler.schedule(ts.last_modified_time + MIN_TD)\n        _state.last_value = ts.value\n\n    return out\n\n\n@lag.start\ndef lag_start(_state: STATE):\n    _state.last_value = None\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Manager in Compute Node Context (hgraph, Python)\nDESCRIPTION: This Python snippet demonstrates the integration of custom context managers with time-series values in hgraph via CONTEXT. It defines a simple context manager class and ensures that its __enter__ and __exit__ methods control the instance state. The compute_node uses CONTEXT[TS[AContextManager]], retrieving and combining contextual information for output. All nodes and graphs are decorated per hgraph conventions, and const is used to wrap the context manager. This requires the context's scalar type to implement __enter__ and __exit__; the value is injected into graph's context at runtime.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/hg_types.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass AContextManager:\n    __instance__ = None\n\n    def __init__(self, msg: str):\n        self.msg = msg\n\n    @classmethod\n    def instance(cls):\n        return cls.__instance__\n\n    def __enter__(self):\n        type(self).__instance__ = self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        type(self).__instance__ = None\n        \n@compute_node\ndef use_context(context: CONTEXT[TS[AContextManager]] = None) -> TS[str]:\n    return f\"{AContextManager.instance().msg} World\"\n\n@graph\ndef g() -> TS[str]:\n    with const(AContextManager(\"Hello\")):\n        return use_context(ts)\n```\n\n----------------------------------------\n\nTITLE: Creating a Constant Node with HGraph in Python\nDESCRIPTION: Demonstrates usage of the const factory to create a constant node within the HGraph framework. It imports const from the hgraph module and initializes a node 'c' with the string value 'Hello World'. Requires the hgraph package to be installed. The resulting node can be attached to other nodes or evaluated; it expects a single input value and produces a constant output.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/notebook/NoteBook.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import const\nc = const(\"Hello World\")\n```\n\n----------------------------------------\n\nTITLE: Handling Graph-Level Errors Using try_except in hgraph (Python)\nDESCRIPTION: Shows use of try_except to wrap a subgraph, capturing all exceptions across its execution. Demonstrates passing constant inputs causing division by zero to a_graph, with separated debug_print outputs for both the result and the caught exception. This snippet requires hgraph and its type system (TS, TSB), and is appropriate for managing and logging exceptions of complex graph compositions in a unified way. Inputs are time-series arguments, and output is a schema with error and result streams.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/exception_handling.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom hgraph import graph, TS, try_except, const, debug_print, run_graph\n\n@graph\ndef a_graph(lhs: TS[float], rhs: TS[float]) -> TS[float]:\n    return lhs / rhs\n\n\n@graph\ndef capture_an_exception():\n    result = try_except(a_graph, const(1.0), const(0.0))\n    debug_print(\"(1.0 + 2.0) / 0.0\", result.out)\n    debug_print(\"exception\", result.exception)\n\n\nrun_graph(capture_an_exception)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Spreadsheet-Style DAG Dependencies in Graphviz - graphviz\nDESCRIPTION: This snippet visualizes the dependency relationships between cells in a spreadsheet using the DOT language for Graphviz. It illustrates how variable assignments and formulas (as seen in spreadsheet cells) form a directed acyclic graph of computations. The graph displays how changes propagate according to dependency structure, an essential concept for understanding evaluation in both backward and forward propagation models. No external Python dependencies are required beyond Graphviz for rendering; input is a static, hard-coded graph description, and output is the rendered visualization.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/mental_model.rst#_snippet_0\n\nLANGUAGE: graphviz\nCODE:\n```\ndigraph {\n   \"A1\" -> \"B2\";\n   \"A2\" -> \"B2\";\n   \"A2\" -> \"C2\";\n   \"B2\" -> \"C2\";\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Time-Series Input Tuples with Arrow (Python)\nDESCRIPTION: Demonstrates creating single or tuple inputs for graph processing using the arrow function. Functions such as const are wrapped to represent constant values, supporting both single values and nested tuples. Accepts time-series values directly or as constants, simplifying pipeline origin specification.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/arrow/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\narrow(const(1))  # Single value\narrow(const(1), const(2))  # A pair\narrow((const(1), const(2)), const(3))  # A pair with first being a tuple and the second a time-series.\n```\n\n----------------------------------------\n\nTITLE: Defining a Bounded Generic Type Variable in Python\nDESCRIPTION: Demonstrates defining a generic type variable `NUMBER_TYPE` using `typing.TypeVar`. This variable is constrained to accept only `int` or `float` types, allowing functions to operate generically on these numeric types within the HGraph framework.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nNUMBER_TYPE = TypeVar(\"NUMBER_TYPE\", int, float)\n```\n\n----------------------------------------\n\nTITLE: Creating and Plotting a Tuple Constant Time Series in hgraph (Python)\nDESCRIPTION: Defines a constant time series node `c` emitting a tuple of integers, explicitly typed using `TS[tuple[int, ...]]`. It then uses `emit` to create a plottable time series bundle `t` from `c` and calls the `plot` method (likely from `hgraph.notebook`) to visualize the time series data with a specified title.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/examples/notebook/example_book.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nc = const((1, 2, 4, 8, 16, 32), TS[tuple[int, ...]])\nt = emit(c)\nt.plot(title=\"My Plot\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Time-Series Schema in HGraph\nDESCRIPTION: Shows how to define a `TimeSeriesSchema` named `MySchema` using `dataclasses`. This schema describes a named collection of time-series values (p1: TS[str], p2: TS[int]) and is intended to be used with the `TSB` (Time-Series Bundle) type.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom hgraph import TimeSeriesSchema, TS\n\n@dataclass(frozen=True)\nclass MySchema(TimeSeriesSchema):\n    p1: TS[str]\n    p2: TS[int]\n```\n\n----------------------------------------\n\nTITLE: Defining Homogeneous Tuple Type Hint in Python\nDESCRIPTION: Shows the Python type hint syntax for a homogeneous tuple containing integers of unspecified length using the ellipsis (...). This pattern is applicable within the HGraph type system for defining tuples with elements of the same type.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/hg_types.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntuple[int, ...]\n```\n\n----------------------------------------\n\nTITLE: Running a Simple Hello World Graph in hgraph (Python)\nDESCRIPTION: This Python code defines and runs a basic hgraph computation graph. It utilizes the `@graph` decorator to define the graph structure, creates a constant string node using `const`, and prints its value combined with 'Hello' using `debug_print`. The graph is then executed using `run_graph` in `EvaluationMode.SIMULATION`, producing a single line of output.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/hello_world.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, run_graph, EvaluationMode, const, debug_print\n\n@graph\ndef hello_world() -> None:\n    c = const(\"World\")\n    debug_print(\"Hello\", c)\n\nrun_graph(hello_world, run_mode=EvaluationMode.SIMULATION)\n\n>> [1970-01-01 00:00:00.000425][1970-01-01 00:00:00.000001] Hello: World\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TSD with Sphinx Autoclass (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` feature to automatically generate documentation for the Python class `hgraph.TSD`. The `:members:` option ensures that all documented members of the class are included. This class represents a time-series dictionary in HGraph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_4\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TSD\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesIterable Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesIterable` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class likely provides an iterable interface for time-series data.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_19\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesIterable\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting websocket_client_adaptor_impl Function (rst)\nDESCRIPTION: Uses the Sphinx `autofunction` directive in reStructuredText to automatically include documentation for the `websocket_client_adaptor_impl` function from the `hgraph.adaptors.tornado.websocket_client_adaptor` Python module. This directive instructs Sphinx to pull the docstring and signature of the specified implementation function.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/websocket_api.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hgraph.adaptors.tornado.websocket_client_adaptor.websocket_client_adaptor_impl\n```\n\n----------------------------------------\n\nTITLE: Documenting websocket_server_adaptor_helper Function (rst)\nDESCRIPTION: Uses the Sphinx `autofunction` directive in reStructuredText to automatically include documentation for the `websocket_server_adaptor_helper` function from the `hgraph.adaptors.tornado.websocket_server_adaptor` Python module. This directive instructs Sphinx to pull the docstring and signature of the specified helper function.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/websocket_api.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hgraph.adaptors.tornado.websocket_server_adaptor.websocket_server_adaptor_helper\n```\n\n----------------------------------------\n\nTITLE: Implicitly Resolving a Default Generic Output Type in HGraph\nDESCRIPTION: Shows how to resolve the generic output type for the `do_something` compute node when its generic `SCALAR` is marked with `Default`. By using `do_something[TS[int]]`, the user provides the resolution type directly without needing to specify `SCALAR:`, making the code cleaner.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef my_graph():\n    out = do_something[TS[int]](const(1))\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for hgraph.mesh_ using Sphinx\nDESCRIPTION: This reStructuredText directive instructs Sphinx to automatically generate documentation for the Python function `hgraph.mesh_`. It extracts the function signature, docstring, and other relevant information from the source code. Requires Sphinx environment and access to the hgraph module.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/dynamic_graphs.rst#_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hgraph.mesh_\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting hgraph.EvaluationMode Class (Sphinx)\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `hgraph.EvaluationMode` Python class, including its members. It's used within a reStructuredText file to pull documentation from the source code.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/graph_run_loop.rst#_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autoclass:: hgraph.EvaluationMode\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Accessing the HTTP Client Adaptor via Service in Tornado/hgraph (Python)\nDESCRIPTION: This function acts as the primary interface for accessing HTTP client functionality via the hgraph service adaptor. It abstracts Tornado's asynchronous client capabilities and is imported from hgraph.adaptors.tornado.http_client_adaptor. Requires hgraph and Tornado; input includes HTTP request metadata, output is the client adaptor for making requests.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/http_api.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n.. autofunction:: hgraph.adaptors.tornado.http_client_adaptor.http_client_adaptor\n```\n\n----------------------------------------\n\nTITLE: Defining a Compound Scalar Type in HGraph\nDESCRIPTION: Demonstrates how to define a custom scalar type `MyScalar` using `CompoundScalar` and `dataclasses`. This approach creates a named collection of scalar values (p1: str, p2: int), leveraging HGraph's type validation and schema tracking capabilities, which is preferable to standard dataclasses for integration with HGraph's features.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom hgraph import CompoundScalar\n\n@dataclass(frozen=True)\nclass MyScalar(CompoundScalar):\n    p1: str\n    p2: int\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting hgraph.test.EvaluationProfiler Class (Sphinx)\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `hgraph.test.EvaluationProfiler` Python class, including members and inherited members. This class likely implements `EvaluationLifeCycleObserver` for profiling purposes during testing.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/graph_run_loop.rst#_snippet_6\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autoclass:: hgraph.test.EvaluationProfiler\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesDeltaValue Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesDeltaValue` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class likely represents the change or delta in a time-series value.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_11\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesDeltaValue\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Referencing the hgraph Service Input Retrieval Function\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autofunction` to automatically generate documentation for the `hgraph.get_service_inputs` Python function. This function is intended to be used within an hgraph service to retrieve the inputs passed to that service.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/services.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hgraph.get_service_inputs\n```\n\n----------------------------------------\n\nTITLE: Applying Logical OR Operation in Python-like Contexts\nDESCRIPTION: Represents the logical OR operation between `a` and `b`, typically using a function `or_`. The surrounding table indicates broad support across most contexts except REF, TSL, and TSD.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nor_(a, b)\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesBundleInput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesBundleInput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an input port for a time-series bundle.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_24\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesBundleInput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesBundleOutput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesBundleOutput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an output port for a time-series bundle.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_25\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesBundleOutput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesDict Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesDict` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents the implementation of a time-series containing dictionary values.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_26\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesDict\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Accessing Schema Properties via TSB.as_schema in HGraph (Python)\nDESCRIPTION: Shows how to access schema-defined properties on a TSB instance in HGraph by using the as_schema property, enhancing code completion and clarity. Assumes a TSB instance parameterized by MyTimeSeriesSchema has already been defined. No explicit dependencies in code, but relies on prior definition and import of TSB and the appropriate schema. There are no input arguments; this pattern enables attribute-style access for downstream applications.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/schema_based_types.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntsb: TSB[MyTimeSeriesSchema]\ntsb.as_schema.p1\n```\n\n----------------------------------------\n\nTITLE: Defining a Time-Series Reference (REF) Type in HGraph\nDESCRIPTION: Represents a reference (similar to a pointer) to a time-series signal, allowing the signal to be passed by reference instead of by value. It holds the reference but doesn't provide direct access to the signal's value. De-referencing happens automatically when the REF is passed to a node input not expecting a REF type. Used mainly for performance optimization by framework developers.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nREF[TS[float]]\n```\n\n----------------------------------------\n\nTITLE: Modifying Output Directly in a Compute Node (Python)\nDESCRIPTION: This snippet illustrates modifying the node's output directly using the injected `_output` argument within a compute node. Instead of returning a new value, the function increments `_output.value` in place. When the output is modified directly like this, the function typically returns `None` (or nothing explicitly). The framework ensures that the final state of `_output` after the function executes determines the value for the current evaluation tick.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/node_signature.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef count(ts: TIME_SERIES_TYPE, _output: TSOut[int]) -> TS[int]:\n    _output.value += 1\n```\n\n----------------------------------------\n\nTITLE: Explicitly Resolving a Generic Output Type in HGraph\nDESCRIPTION: Demonstrates how to explicitly resolve the generic output type `SCALAR` for the `do_something` compute node within an HGraph `graph` function. The syntax `do_something[SCALAR: TS[int]]` specifies that the generic `SCALAR` should be resolved to `TS[int]` for this specific usage, allowing the graph wiring to succeed.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef my_graph():\n    out = do_something[SCALAR: TS[int]](const(1))\n```\n\n----------------------------------------\n\nTITLE: Defining a Base Schema with AbstractSchema - Python\nDESCRIPTION: This snippet refers to the AbstractSchema class in hgraph, which is the foundational class for schema-based types. All custom schemas in hgraph should extend this class to provide field definitions, validation, and serialization logic as required. It is a prerequisite for advanced schema manipulation and integration with the hgraph type system.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/typing.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nhgraph.AbstractSchema\n```\n\n----------------------------------------\n\nTITLE: Dynamic Schema Construction with compound_scalar - Python\nDESCRIPTION: The compound_scalar function in hgraph is provided for dynamic creation of scalar-based schemas. This function allows users to programmatically generate schema types at runtime, offering flexibility for scenarios requiring on-the-fly schema definition. It is essential for advanced use cases where schemas need to be constructed or modified during execution.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/typing.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nhgraph.compound_scalar\n```\n\n----------------------------------------\n\nTITLE: Simplified Arrow Invocation with Scalars (Python)\nDESCRIPTION: Shows usage of arrow function with direct scalar arguments (without const wrapper), implicitly lifting scalars as time-series elements. Useful for concise test graphs, this eases constructing pipelines with literal values as time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/arrow/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\narrow(1)\narrow(1, 2)\narrow((1, 2), 3)\n```\n\n----------------------------------------\n\nTITLE: Fan-Out Operator / for Parallel Processing (Python)\nDESCRIPTION: Exemplifies using the overloaded / (fan-out) operator to apply a single input to two parallel functions, with results collected as a dictionary. Useful for duplicating and splitting data early in an Arrow pipeline.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/arrow/README.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\narrow(1) | i / i >> (lambda x: debug_print(\"out\", x))\n\n>>> out: {0: 1, 1: 1}\n```\n\n----------------------------------------\n\nTITLE: Emitting Values from a Collection using HGraph Emit Operator in Python\nDESCRIPTION: This code demonstrates the use of the emit operator from the hgraph Python library. The emit function receives a tuple as input and releases its elements one by one as separate ticks in the resulting time series. Dependencies include the hgraph package. The print function is used to display each emitted value. The input tuple (1, 2, 3) causes values 1, 2, and 3 to be printed in order. The code is limited to input collections compatible with emit and assumes synchronous output. No additional configuration is shown.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/library/index.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import emit, print\n\nvalues = emit( (1, 2, 3) )\nprint(values)\n\n>> 1\n>> 2\n>> 3\n```\n\n----------------------------------------\n\nTITLE: Plotting Time-Series Data in HGraph with Python\nDESCRIPTION: Illustrates creating a time-series node from a tuple of values, emitting it as a signal, and plotting the result using Matplotlib in a Jupyter notebook. The snippet imports const, emit, and TS types from hgraph, defines a time-series constant, emits it, and calls plot() on the resulting node. Assumes that hgraph and matplotlib are installed and available; only supports numerical signal plots. No parameters are required for plot(), and the output is an inline time-series graph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/notebook/NoteBook.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import const, emit, TS\nc = const((1, 2, 3, 4), TS[tuple[int, ...]])\nt = emit(c)\nt.plot()\n```\n\n----------------------------------------\n\nTITLE: Dynamic Time-Series Schema Construction with ts_schema - Python\nDESCRIPTION: The ts_schema function is mentioned as the tool for dynamically creating time-series schemas in the hgraph framework. Like compound_scalar, it enables runtime definition and instantiation of time-series types, which is critical for applications needing adaptable schema structures. This function should be used when the schema definition must be determined based on dynamic inputs.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/typing.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nhgraph.ts_schema\n```\n\n----------------------------------------\n\nTITLE: Implementing HGraph Rank Functionality as a Compute Node in Python\nDESCRIPTION: Implements the `rank` functionality as an HGraph compute node using the `@compute_node` decorator. This version takes a TSD of floats, sorts the items based on their values, and attempts to return a new dictionary where keys are mapped to evenly spaced values between -1.0 and 1.0 based on their rank. This initial version contains a subtle bug in the normalization calculation.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/code_organisation.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef rank(raw_signal: TSD[str, TS[float]]) -> TSD[str, TS[float]]:\n    \"\"\"\n    Takes a raw_signal that needs to be evenly normalised over the range [-1.0,1.0].\n    \"\"\"\n    sz = len(raw_signal)\n    keys = (k for _, k in sorted((v, k) for k, v in raw_signal.value.items()))\n    return {k: -1.0 + i * 2.0 / sz for k, i in zip(keys, range(sz))}\n```\n\n----------------------------------------\n\nTITLE: Specifying Custom Key Argument Name in map_ using __key_arg__ in HGraph (Python)\nDESCRIPTION: Explains how to use the `__key_arg__` keyword argument in the `map_` operator to specify which argument in the target graph function (`order_handler`) should receive the instance key. This is useful when the key argument has a name other than the default 'key'.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef order_handler(order_id: TS[str], order: TS[Order]) -> ...\n\norders: TSD[str, TS[Order] = ...\nresults = map_(order_handler, orders, __key_arg__='order_id')\n```\n\n----------------------------------------\n\nTITLE: Accessing Instance Key in map_ via Argument in HGraph (Python)\nDESCRIPTION: Demonstrates how an HGraph graph function (`order_handler`) designed to be used with `map_` can receive the specific key (e.g., order ID) for which it was instantiated. This is achieved by naming the first argument `key` and typing it as `TS[<key_type>]`, where `<key_type>` matches the key type of the input `TSD`.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef order_handler(key: TS[str], order: TS[Order]) -> ...\n\norders: TSD[str, TS[Order] = ...\nresults = map_(order_handler, orders)\n```\n\n----------------------------------------\n\nTITLE: Defining an HGraph Compute Node with a Default Generic Output\nDESCRIPTION: Defines an HGraph `compute_node` function `do_something` where the generic output type `SCALAR` is wrapped with `Default`. This indicates that `SCALAR` is the default type variable to be resolved if only one type is provided during instantiation, simplifying the syntax.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef do_something(ts: TS[int]) -> TS[Default[SCALAR]]:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Initializing HGraph Inspector with Perspective Adaptor in Python\nDESCRIPTION: This Python snippet demonstrates how to initialize the HGraph Inspector within a graph definition. It imports necessary modules (`hgraph`, `perspective`, `inspector`), defines a graph function `main`, calls `inspector()` to enable introspection, registers Perspective adaptors, and starts the Perspective web server using `perspective_web`. This makes the inspector accessible via a browser URL printed at startup. An optional configuration for `PerspectiveTablesManager` is also shown.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/tools/inspector.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom _socket import gethostname\n\nfrom hgraph import graph\nfrom hgraph.adaptors.perspective import perspective_web, PerspectiveTablesManager, register_perspective_adaptors\nfrom hgraph.debug import inspector\n\n@graph\ndef main():\n    inspector()\n\n    register_perspective_adaptors()\n    perspective_web(gethostname(), 8080)\n\n    # optional if you want to use the client side tables (improves performance for smaller frequently updated tables)\n    PerspectiveTablesManager.set_current(PerspectiveTablesManager(host_server_tables=False))\n```\n\n----------------------------------------\n\nTITLE: Evaluating the Current HGraph Graph in Python\nDESCRIPTION: Runs the notebook_evaluate_graph() function to evaluate the global graph state in a Jupyter notebook. This is intended for more comprehensive evaluation beyond single nodes and displays aggregate results. Relies on all prior node definitions and graph construction in the working notebook session. Requires no parameters and outputs the evaluation result to the current notebook output.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/notebook/NoteBook.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnotebook_evaluate_graph()\n```\n\n----------------------------------------\n\nTITLE: Passing Input Directly in map_ using pass_through in HGraph (Python)\nDESCRIPTION: Shows how to use the `pass_through` marker in HGraph's `map_` operator. This prevents the marked input (`a`) from being de-multiplexed based on keys. Instead, the entire `a` input is passed as-is to every instance of the `scale` graph created by `map_`. This is useful when an input should be shared globally among mapped instances.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/dynamic_graphs.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef scale(a: TIME_SERIES_TYPE, b: TS[float]) -> TS[float]:\n    ...\n\na: TSD[str, TS[float]] = ...\nb: TSD[str, TS[float]] = ...\n\nresult = map_(scale, pass_through(a), b)\n```\n\n----------------------------------------\n\nTITLE: Wiring an HGraph for Back-Testing using Database Sources in Python\nDESCRIPTION: Defines an HGraph main graph (`back_test_main_graph`) specifically for back-testing scenarios. It assumes the existence of `db_reader` and `db_writer` components (not shown) to source market and sentiment data from database tables and write the resulting signal back to a table. This demonstrates decoupling the core `generate_signal` logic from specific data sources, requiring the `hgraph` library and the mentioned data components.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/code_organisation.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef back_test_main_graph():\n    market_data = db_reader(\"select * from market_data_tbl\")\n    sentiment = db_reader(\"select * from sentiment_tbl\")\n    signal = generate_signal(market_data, sentiment)\n    db_writer(\"signal_tbl\", signal)\n```\n\n----------------------------------------\n\nTITLE: Defining a Generator Node with EvaluationEngineApi Injection (Python)\nDESCRIPTION: This snippet demonstrates how to define an hgraph generator node function that accepts a special injectable argument `_engine`. The `_engine` argument, typed as `EvaluationEngineApi`, provides access to the evaluation engine's API during runtime. It's defined with a default value of `None` as the framework injects the actual instance. The leading underscore convention helps distinguish these framework-provided inputs.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/node_signature.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@generator\ndef const(value: SCALAR, _engine: EvaluationEngineApi=None) -> TIME_SERIES_VALUE:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Function Chain as First-Class Callable (Python)\nDESCRIPTION: Demonstrates defining a reusable chain of Arrow operations by assigning it to a variable, which can be subsequently called with time-series tuple input. Illustrates first-class usage of operator pipelines for flexible function composition and evaluation.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/arrow/README.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsum_and_print = i >> lambda pair: pair[0] + pair[1] >> lambda x: debug_print(\"out\": x)\nsum_and_print(TSL.from_ts(const(1), const(2)))\n```\n\n----------------------------------------\n\nTITLE: Setting the Evaluation Mode of HGraphConfiguration in Python\nDESCRIPTION: This snippet shows how to select the execution mode for an HGraph event loop via the GraphConfiguration class. It imports EvaluationMode from hgraph and passes it to GraphConfiguration to set REAL_TIME mode, allowing integration with external threaded event sources. The config object thus controls simulation versus real-time behavior during graph evaluation.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/quick_start/run_loop.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom hgraph import GraphConfiguration, EvaluationMode\\nconfig = GraphConfiguration(run_mode=EvaluationMode.REAL_TIME)\\n\n```\n\n----------------------------------------\n\nTITLE: Evaluating an hgraph Node Directly in Python\nDESCRIPTION: Executes the computation for the specific hgraph node `c` and returns its output value(s) using the `eval()` method. This is often used for debugging or inspecting the output of individual nodes outside the full graph evaluation cycle.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/examples/notebook/example_book.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nc.eval()\n```\n\n----------------------------------------\n\nTITLE: Time-Series Type Examples in HGraph\nDESCRIPTION: Provides examples of supported time-series types in HGraph. Time-series types represent values with a time dimension and ultimately decompose into scalar types. Examples include basic time-series (TS), time-series sets (TSS), time-series lists (TSL) with size constraints, time-series bundles (TSB) using schemas, time-series dictionaries (TSD), and references to time-series outputs (REF). All time-series types are generics requiring specification of contained types.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n- TS[int]  # A time-series of integer values\n- TSS[str]  # A time-series set of string values\n- TSL[TS[int], Size[2]]  # A time-series list of length 2 containing TS[int] entries\n- TSB[MySchema]  # A time-series bundle, or named collection of time-series values\n- TSD[str, TS[int]]  # A time-series dictionary of time-series elements.\n- REF[TS[int]]  # A reference to a time-series output.\n```\n\n----------------------------------------\n\nTITLE: Defining a CompoundScalar Type in HGraph with Python\nDESCRIPTION: Creates an immutable (frozen) CompoundScalar by extending HGraph's CompoundScalar class using Python's dataclass. Requires imports from hgraph (CompoundScalar) and dataclasses (dataclass). The properties p1 (type int) and p2 (type str, default 'temp') model a compound value, supporting type checking and inclusion in other compound structures. Takes no runtime input but can be instantiated with or without a custom value for p2.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/schema_based_types.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import CompoundScalar\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass MyCompoundScalar(CompoundScalar):\n    p1: int\n    p2: str = \"temp\"\n```\n\n----------------------------------------\n\nTITLE: Defining HGraph Rank Logic using Pseudo-Code in Python\nDESCRIPTION: Outlines the pseudo-code implementation for the `rank` graph component using the `@graph` decorator. It aims to normalize a raw signal (TSD of floats) evenly over the range [-1.0, 1.0]. It uses placeholders like `len_`, `sort`, `range_`, and `combine` to represent desired functionalities before checking for existing HGraph library components.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/code_organisation.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef rank(raw_signal: TSD[str, TS[float]]) -> TSD[str, TS[float]]:\n    \"\"\"\n    Takes a raw_signal that needs to be evenly normalised over the range [-1.0,1.0].\n    \"\"\"\n    sz = len_(raw_signal)\n    keys = sort(raw_signal)\n    values = range_(-1.0, step=2.0/sz)\n    return combine[TSD[str, TS[float]](keys, values)\n```\n\n----------------------------------------\n\nTITLE: Chaining Arrow Functions using >> (Python)\nDESCRIPTION: Shows chaining multiple functions in a pipeline using the >> operator, where the first step must be an arrow wrapped function. The identity function, aliased as i, is used as a no-op initiator for the chain. Each lambda processes the output of the previous pipeline stage.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/arrow/README.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\narrow(1, 2) | i >> (lambda pair: pair[0] + pair[1]) >> (lambda x: debug_print(\"out\", x))\n```\n\n----------------------------------------\n\nTITLE: Adding a Debug Print Node to an hgraph Graph in Python\nDESCRIPTION: Adds a `debug_print` node to the current graph definition. This node takes a message string (\"Message\") and an input time series (`c`) and prints the values emitted by `c` along with the message during graph evaluation. Requires `hgraph` and an active graph context.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/examples/notebook/example_book.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import debug_print\ndebug_print(\"Message\", c)\n```\n\n----------------------------------------\n\nTITLE: Marking Deprecated APIs and Suggesting Alternatives (Python)\nDESCRIPTION: This snippet demonstrates marking a graph API as deprecated using the 'deprecated' option in the @graph decorator. When the function 'accumulate' is used, users will receive a warning, guiding them to use the recommended 'sums(ts)' replacement function. This practice encourages smooth migration and maintainability of public APIs. Dependencies: hgraph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/developers_guide/library_writers_guide.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, TS\n\n@graph(deprecated=\"accumulate is deprecated, use sums(ts) instead.\")\ndef accumulate(ts: TS[float]) -> TS[float]:\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: Including README and Toctree for Documentation Navigation - Sphinx reStructuredText\nDESCRIPTION: This snippet uses reStructuredText syntax and Sphinx directives to include external README content and define the table of contents hierarchy for the documentation site. Dependencies include Sphinx and a valid project folder structure. `.. include::` imports static content, while `.. toctree::` and nested files establish documentation pages with specified depth; filenames must exist relative to the documentation root. The output is a navigable multi-page documentation site.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/index.rst#_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. include:: ../../README.rst\n\nHGraph Documentation\n====================\n\n\nContents\n--------\n\n.. toctree::\n    :maxdepth: 1\n\n    Home <self>\n    getting_started\n    quick_start/index\n    programming_model/index\n    concepts/index\n    tools/index\n    adaptors/index\n    reference/index\n    papers/index\n    references\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Schema Using Python Dataclasses\nDESCRIPTION: Defines a basic schema class by extending another schema base using Python's dataclass feature. No external dependencies beyond dataclasses are required for the structure itself; however, in practical usage within HGraph, the parent base should be an HGraph schema type. Parameters include p1 (with an unspecified type) and p2 (optionally with a default value). Inputs are type definitions, and outputs are Python classes ready for type-checked data usage within HGraph or similar frameworks.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/schema_based_types.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass MySchema(ParentSchemaType):\n    p1: type_1\n    p2: type_2 = default_value\n```\n\n----------------------------------------\n\nTITLE: Installing hgraph Project Dependencies using uv (Bash)\nDESCRIPTION: Provides commands for installing the hgraph project and its dependencies using 'uv pip install'. The first command installs the project in editable mode (`-e .`) with its core dependencies. The subsequent commands demonstrate how to install optional dependencies (extras) for documentation (`docs`), web features (`web`), notebooks (`notebook`), and testing (`test`) by specifying them within square brackets.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Install the project with all dependencies\nuv pip install -e .\n\n# Install with optional dependencies\nuv pip install -e \".[docs,web,notebook]\"\n\n# Install with all optional dependencies\nuv pip install -e \".[docs,web,notebook,test]\"\n```\n\n----------------------------------------\n\nTITLE: Specifying a Default Return Type Using DEFAULT[OUT] (Python)\nDESCRIPTION: This snippet shows tagging the OUT TypeVar with DEFAULT for a graph, letting the type resolver infer the output type if not explicitly provided at calltime. This pattern enables cleaner function signatures without needing user-specified output type hints. Applies to any template input. Dependencies: hgraph, Python's typing.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/developers_guide/library_writers_guide.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import graph, TIME_SERIES_TYPE, OUT, DEFAULT, TS\n\n@graph\ndef div_(lhs: TIME_SERIES_TYPE, rhs: TIME_SERIES_TYPE) -> DEFAULT[OUT]:\n    ...\n\n...\n\nc = div_[TS[float]](1, 2)\n```\n\n----------------------------------------\n\nTITLE: Evaluating an HGraph Node in Python\nDESCRIPTION: Calls the eval() method on an HGraph node, triggering its computation and displaying the result in the notebook if it is a compute or source node. This requires that the node (here, 'c') supports the eval interface. Evaluation is supported only in SIMULATION mode and is useful for inspecting node outputs interactively. The method does not require parameters and outputs the computed graph result inline.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/notebook/NoteBook.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nc.eval()\n```\n\n----------------------------------------\n\nTITLE: Defining and Registering Reference Data Services with HGraph (Python)\nDESCRIPTION: This snippet demonstrates how to declare a reference data service interface, provide its implementation, and register it for use in other graphs using the HGraph Python framework. Required dependencies include the 'hgraph' library and Python's 'datetime' module. The snippet defines a holiday calendar service interface, implements it (as a compute node), and shows graph nodes consuming the service and registering the implementations. Inputs consist mainly of typed time-series data, while outputs are exposed as graphs or references. The code is illustrative, focusing on structure and usage patterns rather than concrete computation.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/concepts/services.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n    from hgraph import reference_service, TSD, TSS, service_impl, register_service, \\\n         graph, TS, compute_node\n    from datetime import date\n\n    @reference_service\n    def holiday_calendar(path: str | None = None) -> TSD[str, TSS[date]]:\n        \"\"\"\n        The holidays for locals, e.g. GB for UK or GBP for currency holiday or\n        LME for exchange holidays.\n        \"\"\"\n\n    @service_impl(interface=holiday_calendar)\n    @compute_node\n    def holiday_calendar_impl() -> TSD[str, TSS[date]]:\n        \"\"\"Do the work to compute / update the holiday calendar\"\"\"\n        return ...\n    \n    \n    @graph\n    def price_quote(...) -> TS[float]:\n        ...\n        trade_currency: TS[str]\n        holiday = holiday_calendar()[trade_currency]\n        ...\n        return ...\n\n    @graph\n    def main():\n        register_service(None, holiday_calendar, holiday_calendar_impl)\n        ...\n        quote = price_quote(...)\n\n```\n\n----------------------------------------\n\nTITLE: Visualizing HGraph Structure with PlantUML\nDESCRIPTION: This PlantUML diagram visualizes the wiring structure of the `what_is_one_plus_one` graph defined in the Python example. It shows three nodes (`const`, `add_`, `debug_print`) and the directed edges representing data flow: `const` outputs to both `lhs` and `rhs` inputs of `add_`, and the output of `add_` feeds into `debug_print`. This represents the graph built during the wiring phase.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/program_anatomy.md#_snippet_1\n\nLANGUAGE: plantuml\nCODE:\n```\n@startuml what_is_1_1\nstate const {\n}\nstate add_ {\n}\n\nstate debug_print {\n}\n\nconst --> add_ : lhs \nconst --> add_ : rhs \nadd_ --> debug_print\n\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Handling Output Time Series via _output Injection in hgraph - Python\nDESCRIPTION: This code snippet illustrates how to use the special _output argument to access or update the output time series directly in an hgraph compute node. Dependencies: hgraph. The function sums the current output value and input if the output is valid; otherwise, it emits the input value alone. Inputs: a TS[int] and an optional _output object. Returns the next output time-series value.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/injectable_attributes.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, TS, TS_OUT\n\n\n@compute_node\ndef sum_(ts: TS[int], _output: TS_OUT[int] = None) -> TS[int]:\n    return _output.value + ts.value if _output.valid else ts.value\n```\n\n----------------------------------------\n\nTITLE: Scalar Type Examples in HGraph\nDESCRIPTION: Lists examples of supported scalar types in HGraph. Scalar types represent values without a time dimension and include basic Python types like bool, date, datetime, str, int, as well as immutable collections like tuples, frozensets, and frozendicts with specified element types.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n- bool\n- date\n- datetime\n- str\n- int\n- tuple[str, ...]\n- tuple[int, float]\n- frozenset[int]\n- frozendict[str, int]\n```\n\n----------------------------------------\n\nTITLE: Logging Time-Series Data with Injected LOGGER in hgraph Sink Node - Python\nDESCRIPTION: Shows how to inject and use the LOGGER object in a hgraph sink node to log the current value of a time-series input. Dependencies: hgraph. Parameters: an integer time-series and an optional logger instance. The node logs each value received using info-level logging. Useful for tracking or auditing stream values.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/injectable_attributes.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import TS, LOGGER, sink_node\n\n@sink_node\ndef log(ts: TS[int], _logger: LOGGER = None):\n    _logger.info(f\"Logging: {ts.value}\")\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Request and Response Object Models in Tornado Adaptor (Python)\nDESCRIPTION: These classes encapsulate HTTP message handling for GET, DELETE, PUT, POST requests and responses in the HTTP server context. They provide structured objects, typically used as parameters or return types in handler logic, to simplify request parsing and response formulation. Dependencies are hgraph and Tornado; input includes typical HTTP request parameters, output is a normalized response or request object.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/http_api.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n.. autoclass:: hgraph.adaptors.tornado.http_server_adaptor.HttpRequest\n```\n\nLANGUAGE: python\nCODE:\n```\n.. autoclass:: hgraph.adaptors.tornado.http_server_adaptor.HttpGetRequest\n```\n\nLANGUAGE: python\nCODE:\n```\n.. autoclass:: hgraph.adaptors.tornado.http_server_adaptor.HttpDeleteRequest\n```\n\nLANGUAGE: python\nCODE:\n```\n.. autoclass:: hgraph.adaptors.tornado.http_server_adaptor.HttpPutRequest\n```\n\nLANGUAGE: python\nCODE:\n```\n.. autoclass:: hgraph.adaptors.tornado.http_server_adaptor.HttpPostRequest\n```\n\nLANGUAGE: python\nCODE:\n```\n.. autoclass:: hgraph.adaptors.tornado.http_server_adaptor.HttpResponse\n```\n\n----------------------------------------\n\nTITLE: Defining Type Meta-Data with HgTypeMetaData - Python\nDESCRIPTION: This snippet references the HgTypeMetaData class in the hgraph library, which serves as the entry point for managing Python type meta-data. It is designed to wrap native Python types and provides extraction logic to parse function signatures for type information. This class is necessary for any operations requiring introspection or manipulation of types within the hgraph framework.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/typing.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nhgraph.HgTypeMetaData\n```\n\n----------------------------------------\n\nTITLE: Evaluating the Defined hgraph Graph in a Notebook (Python)\nDESCRIPTION: Executes the complete hgraph graph defined within the current notebook context using `notebook_evaluate_graph`. This function triggers the computation of all nodes in the graph and renders any outputs or side effects (like `debug_print`) defined within it. Requires `hgraph.notebook` utilities.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/examples/notebook/example_book.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnotebook_evaluate_graph()\n```\n\n----------------------------------------\n\nTITLE: Example of a Time-Series List (TSL) Definition in HGraph\nDESCRIPTION: An example illustrating the definition of a TSL containing a fixed list of 2 time-series signals, where each signal carries integer values. It uses `TS[int]` for the element type and `Size[2]` to specify the fixed size.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nTSL[TS[int], Size[2]]\n```\n\n----------------------------------------\n\nTITLE: Returning Added and Removed Elements for HGraph TSS in Python\nDESCRIPTION: Shows an HGraph compute node function `f` returning a value for a `TSS[int]` (Time-Series Set of integers). The returned set `{1, 2, Removed(3)}` represents a delta, indicating that elements 1 and 2 should be added to the set, and element 3 should be removed in the current engine cycle. The `Removed` marker class is imported from `hgraph` to signify elements for removal.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/hg_types.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import Removed, compute_node, TSS\n\n@compute_node\ndef f(...) -> TSS[int]:\n    return {1, 2, Removed(3)}\n```\n\n----------------------------------------\n\nTITLE: Running hgraph Tests without Coverage using pytest (Bash)\nDESCRIPTION: This command executes the project's test suite using the `pytest` framework. It runs all discovered tests within the project but does not collect code coverage information. This is a standard way to quickly check if the tests pass. Requires `pytest` to be installed in the active Python environment.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# No Coverage\npython -m pytest\n```\n\n----------------------------------------\n\nTITLE: Utilizing Scalar Values with CompoundScalar - Python\nDESCRIPTION: The CompoundScalar class in hgraph is referenced here as the base for scalar value types. This class provides a standard interface and behaviors for handling single-value or compound scalar types, which are essential for consistent data handling in schemas. It should be used when creating schema fields representing primitive or compound scalar values.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/typing.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nhgraph.CompoundScalar\n```\n\n----------------------------------------\n\nTITLE: Defining the Node Interface and Core Methods for Evaluation - PlantUML\nDESCRIPTION: This PlantUML diagram establishes the contract for the base 'Node' interface, enumerating properties such as node/index ids, graph associations, metadata signatures, and scheduling/evaluation methods. It covers both structural (inputs/outputs) and behavioral (eval and notify) elements required by all node types. The snippet is intended for architectural descriptionno runtime behavior is encoded.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/concepts/graph_runtime.md#_snippet_5\n\nLANGUAGE: PlantUML\nCODE:\n```\n@startuml node_uml\\ninterface Node {\\n    + node_ndx: int\\n    + node_id: tuple[int, ...]\\n    + owning_graph_id: tuple[int, ...]\\n    + graph: Graph\\n    + signature: NodeSignature\\n    + input: TimeSeriesBundleInput | None\\n    + output: TimeSeriesOutput | None\\n    + scheduler: NodeScheduler | None\\n    + eval()\\n    + notify()\\n}\\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Using OUT as a Result Type for Flexible Resolution (Python)\nDESCRIPTION: This snippet demonstrates specifying OUT in the return type of a compute node, enabling external type hinting at usage time to resolve specific implementation types. The function 'div_' divides two inputs of TIME_SERIES_TYPE and users can select the particular return type via a type resolution at call time. Dependencies: hgraph, Python type system.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/developers_guide/library_writers_guide.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, OUT, TIME_SERIES_TYPE, TS\n\n@compute_node\ndef div_(lhs: TIME_SERIES_TYPE, rhs: TIME_SERIES_TYPE) -> OUT:\n    return lhs.value / rhs.value\n\n...\n\nc = div_[OUT: TS[float]](1, 2)\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Scalar Type Parser in HGraph\nDESCRIPTION: Illustrates how to register a custom scalar type metadata parser (`MyNewTypeMetaData`) with the HGraph type system. This allows user-defined types to be fully integrated, enabling proper type checking and resolution, as opposed to being treated as generic Python objects.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/typing_system.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import HgScalarTypeMetaData\n\nHgScalarTypeMetaData.register_parser(MyNewTypeMetaData)\n```\n\n----------------------------------------\n\nTITLE: Initializing an hgraph Wiring Graph in Python\nDESCRIPTION: Begins the definition of an hgraph computation graph named \"test\" using the `start_wiring_graph` function. This function establishes a context within which hgraph nodes and connections can be defined, typically used in interactive or notebook environments.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/examples/notebook/example_book.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nstart_wiring_graph(\"test\")\n```\n\n----------------------------------------\n\nTITLE: Time-Series Class Structure and Properties Visualization (PlantUML)\nDESCRIPTION: This PlantUML snippet defines a UML class diagram for the TimeSeries class used in HGraph, enumerating key properties such as owning_node, owning_graph, value, delta_value, modified, valid, all_valid, and last_modified. It visually specifies the high-level API/attributes available on time-series objects that inform the data pipeline and debugging. It expects PlantUML as a prerequisite for rendering and does not interact with actual data; it's strictly documentation for developers and architects.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/time_series_types.rst#_snippet_3\n\nLANGUAGE: PlantUML\nCODE:\n```\n@startuml\\nclass TimeSeries {\\n    owning_node: Node\\n    owning_graph: Graph\\n    value\\n    delta_value\\n    modified: bool\\n    valid: bool\\n    all_valid: bool\\n    last_modified: datetime\\n}\\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Modeling Evaluation Engine API Methods and Observers - PlantUML\nDESCRIPTION: This snippet represents the 'EvaluationEngineAPI' interface using PlantUML, identifying public properties and control methods for interacting with the engine at runtime. It defines start/end times, clock reference, lifecycle observer registration, engine stop mechanisms, and callback-based notifications. Usage requires only PlantUML and is focused on structuring the API for diagrammatic/architectural clarity.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/concepts/graph_runtime.md#_snippet_3\n\nLANGUAGE: PlantUML\nCODE:\n```\n@startuml evaluation_engine_api\\ninterface EvaluationEngineAPI {\\n    + start_time: datetime\\n    + end_time: datetime\\n    + evaluation_clock: EvaluationClock\\n    + is_stop_requested: bool\\n    + request_engine_stop()\\n    + add_before_evaluation_notification(fn: callback[[], None]) -> None\\n    + add_after_evaluation_notification(fn: callback[[], None]) -> None\\n    + add_life_cycle_observer(observer: EvaluationLifeCycleObserver)\\n    + remove_life_cycle_observer(observer: EvaluationLifeCycleObserver)\\n}\\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing HGraph in Jupyter Notebook with Python\nDESCRIPTION: Imports all notebook utilities from the hgraph.notebook module and initializes the graph wiring for use in a Jupyter environment. Assumes hgraph is installed and available in the current Python environment. The start_wiring_graph() function prepares the notebook environment for subsequent cell-by-cell graph construction; it does not require parameters and does not return a value.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/notebook/NoteBook.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph.notebook import *\nstart_wiring_graph()\n```\n\n----------------------------------------\n\nTITLE: Implementing an Operator Overload Using @compute_node (Python)\nDESCRIPTION: This snippet shows the concrete implementation of a previously defined operator interface 'add_' using the @compute_node decorator. The function 'add_ts_int' is registered as an overload for 'add_' to handle TS[int] types, performing addition on the 'value' of input time series. All matching implementations must be imported for operator registration. Dependencies: hgraph, TS[int], add_ operator.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/developers_guide/library_writers_guide.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import compute_node, TS\n\n@compute_node(overloads=add_)\ndef add_ts_int(lhs: TS[int], rhs: TS[int]) -> TS[int]:\n    return lhs.value + rhs.value\n```\n\n----------------------------------------\n\nTITLE: Registering the HTTP Server Adaptor Service in hgraph (Python)\nDESCRIPTION: This function is used to register the Tornado-based HTTP server adaptor as a service within hgraph. It ensures the server is appropriately initialized and routes are activated for use. Requires hgraph and Tornado to be present; key parameters include application settings or service hooks.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/http_api.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n.. autofunction:: hgraph.adaptors.tornado.register_http_server_adaptor\n```\n\n----------------------------------------\n\nTITLE: Graph Context Usage with Contextual Time Series in hgraph (Python)\nDESCRIPTION: This code demonstrates how to use CONTEXT-typed time series in hgraph graph definitions, both with and without naming contexts. The example highlights optional and required context arguments, use of the with-statement for context propagation, and context matching by name. Dependencies include hgraph's graph decorator and CONTEXT/TS types; format_ is assumed as a utility for string formatting. Inputs are contextual time series, and outputs are formatted TS[str] results. Context wiring ensures only matching context types or names are injected; missing contexts default to nothing() if not required.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/hg_types.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef use_context(a: CONTEXT[TS[str]] = None) -> TS[str]:\n    return format_(\"{} World\",a)\n\n@graph\ndef f() -> TS[str]:\n    return use_context()\n\n@graph\ndef g(ts1: TS[str]) -> TS[str]:\n    with ts1 as a:\n        return f()\n```\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef use_context(a: CONTEXT[TIME_SERIES_TYPE] = 'a', b: CONTEXT[TIME_SERIES_TYPE] = 'b') -> TS[str]:\n    return format_(\"{} {}\",a, b)\n\n@graph\ndef f() -> TS[str]:\n    return use_context()\n\n@graph\ndef g(ts1: TS[str], ts2: TS[str]) -> TS[str]:\n    with ts1 as a, ts2 as b:\n        return f()\n```\n\nLANGUAGE: python\nCODE:\n```\n@graph\ndef use_context(a: CONTEXT[TS[str]] = None) -> TS[str]:  # Context is optional, nothing() will be wired if not present \n    return format_(\"{} World\",a)\n\n@graph\ndef use_context(a: CONTEXT[TS[str]] = 'HelloContext') -> TS[str]:  # Named context is optional, nothing() will be wired if not present\n    return format_(\"{} World\",a)\n\n@graph\ndef use_context(a: CONTEXT[TS[str]] = REQUIRED) -> TS[str]:  # Context is required, will raise an error if not present\n    return format_(\"{} World\",a)\n\n@graph\ndef use_context(a: CONTEXT[TS[str]] = REQUIRED['HelloContext']) -> TS[str]:  # Named context is required, will raise an error if not present\n    return format_(\"{} World\",a)\n```\n\n----------------------------------------\n\nTITLE: Creating a Virtual Environment using uv (Bash)\nDESCRIPTION: This command utilizes the 'uv' tool to create a Python virtual environment within the current project directory. Creating a virtual environment is a standard practice to isolate project dependencies and avoid conflicts. This step is typically performed before installing project-specific packages.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuv venv\n```\n\n----------------------------------------\n\nTITLE: Importing hgraph Core and Notebook Utilities in Python\nDESCRIPTION: Imports essential functions and types like `const`, `emit`, `TS`, `from_table`, `MIN_DT` from the `hgraph` library, along with notebook-specific utilities (`hgraph.notebook.*`). This setup is necessary for defining and interacting with hgraph graphs, especially in interactive environments like Jupyter notebooks.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/examples/notebook/example_book.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom hgraph import const, emit, TS, from_table, MIN_DT\nfrom hgraph.notebook import *\n```\n\n----------------------------------------\n\nTITLE: Calculating Multi-Argument Maximum in Python-like Contexts\nDESCRIPTION: Represents finding the maximum value among multiple arguments (`*args`) using a function `max_`. Supported in basic types (BOOL, INT, FLOAT, STR, DT, TIME) as a value comparison, and in LIST, DICT, TSD, TS as an item-wise maximum, according to the table.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nmax_(*args)\n```\n\n----------------------------------------\n\nTITLE: Calculating Multi-Argument Minimum in Python-like Contexts\nDESCRIPTION: Represents finding the minimum value among multiple arguments (`*args`) using a function `min_`. Supported in basic types (BOOL, INT, FLOAT, STR, DT, TIME) as a value comparison, and in LIST, DICT, TSD, TS as an item-wise minimum, according to the table.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nmin_(*args)\n```\n\n----------------------------------------\n\nTITLE: Calculating Unary Maximum (Running or Aggregate) in Python-like Contexts\nDESCRIPTION: Represents finding the maximum within a single argument `a` using the `max_` function. Behavior varies based on context as shown in the table: acts as a running maximum for basic types (BOOL to TIME), finds the maximum item/value in collections (TSB, TSL, SET, TUPLE, LIST, DICT, TSD, TS).\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nmax_(a)\n```\n\n----------------------------------------\n\nTITLE: Getting Length/Size in Python-like Contexts\nDESCRIPTION: Represents obtaining the length or number of items in `a`, using a function `len_`. The surrounding table shows support mainly for sequence/collection types like TSL, SET, TUPLE, LIST, DICT, TSD, and TS, indicating it returns the number of items.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nlen_(a)\n```\n\n----------------------------------------\n\nTITLE: Calculating Unary Minimum (Running or Aggregate) in Python-like Contexts\nDESCRIPTION: Represents finding the minimum within a single argument `a` using the `min_` function. Behavior varies based on context as shown in the table: acts as a running minimum for basic types (BOOL to TIME), finds the minimum item/value in collections (TSB, TSL, SET, TUPLE, LIST, DICT, TSD, TS).\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nmin_(a)\n```\n\n----------------------------------------\n\nTITLE: Calculating Multi-Argument Sum in Python-like Contexts\nDESCRIPTION: Represents summing multiple arguments (`*args`) using a function `sum_`. Supported in numeric types (BOOL, INT, FLOAT, TIME) and potentially STR (concatenation), and item-wise in LIST, DICT, TSD, TS, as indicated by the table.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nsum_(*args)\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeries Base Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to generate documentation for the base Python class `hgraph.TimeSeries`. The `:members:` option includes documented members, and `:undoc-members:` includes undocumented ones, providing a comprehensive view of the class API. This is a fundamental base class for all time-series types in HGraph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_8\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeries\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Installing HGraph with pip - Bash\nDESCRIPTION: This Bash code snippet demonstrates how to install the HGraph package using pip, assuming Python 3.11 or later is available. No additional dependencies are required if pip is already installed. The sole parameter is the package name 'hgraph'; running the command downloads and installs the package, making HGraph available for use in Python scripts on the system. The command should be executed in a command-line interface with appropriate permissions.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/quick_start.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install hgraph\n```\n\n----------------------------------------\n\nTITLE: Installing HGraph with pip (bash)\nDESCRIPTION: Demonstrates how to install the HGraph Python package using the pip package manager in a terminal or command prompt. Requires Python 3.11 or greater to be installed prior to running this command. This is the first step before using any HGraph functionality.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/getting_started.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install hgraph\n```\n\n----------------------------------------\n\nTITLE: Using a Scalar Context Manager as Graph CONTEXT Parameter (hgraph, Python)\nDESCRIPTION: This snippet shows how a compute node can accept a CONTEXT argument parameterized by a scalar context manager type in hgraph, removing the need for TS[] wrapper when the bundle itself is the context manager. The parameter context expects a subclass of AContextManager implementing context-management protocol, and use_context returns a string formed by accessing the current contextual instance. This simplifies context wiring when using bundles whose scalar is itself a context manager.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/hg_types.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n@compute_node\ndef use_context(context: CONTEXT[AContextManager] = None) -> TS[str]:  # Note absence of TS[]\n    return f\"{AContextManager.instance().msg} World\"\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TS with Sphinx Autoclass (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` feature to automatically generate documentation for the Python class `hgraph.TS`. The `:members:` option ensures that all documented members of the class are included in the generated documentation. This class represents a basic time-series type in HGraph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TS\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Arrow Class and 'arr' Function in Python\nDESCRIPTION: Defines a generic 'Arrow' class in Python to encapsulate a function, enabling arrow-like composition. It includes an '__rshift__' method for chaining (>>) and a '__call__' method for execution. The 'arr' helper function wraps a standard Python callable into an Arrow instance. Type hinting using 'Generic', 'A', 'B', 'C', 'D', 'TypeVar', and 'Callable' is implied for proper typing.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass Arrow(Generic[A, B]):  # Where A, C, C, D are TypeVar's\n    def __init__(self, func: Callable[[A], B]):\n        self.func = func\n\n    def __rshift__(self, other: 'Arrow[B, C]') -> 'Arrow[A, C]':\n        return Arrow(lambda x: other.func(self.func(x)))\n\n    def __call__(self, value: A) -> B:\n        return self.func(value)\n\ndef arr(func: Callable[[A], B]) -> Arrow[A, B]:\n    return Arrow(func)\n\ndef first(fn) -> 'Arrow[tuple[A, D], tuple[B, D]]':\n    return arr(lambda pair, _fn=fn: (_fn(pair[0]), pair[1]))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Arrow Chaining in Python\nDESCRIPTION: Illustrates the usage of the previously defined 'Arrow' class and 'arr' function. It creates two Arrow instances, 'mul_2' (multiplies by 2) and 'add_5' (adds 5), and chains them using the '>>' operator ('__rshift__'). The chained operation is then applied to the input value 3, resulting in 11.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmul_2 = arr(lambda x: x*2)\nadd_5 = arr(lambda x: x+5)\n(mul_2 >> add_5)(3)\n\n>>> 11\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting hgraph.test.WiringTracer Class (Sphinx)\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `hgraph.test.WiringTracer` Python class, including members and inherited members. This class likely implements `WiringObserver` to trace the wiring process during testing.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/graph_run_loop.rst#_snippet_8\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autoclass:: hgraph.test.WiringTracer\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesWindowInput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesWindowInput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an input port that receives data for a time-series window.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_34\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesWindowInput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Applying Logical NOT Operation in Python-like Contexts\nDESCRIPTION: Represents the logical negation of `a`, typically using a function `not_`. The surrounding table shows broad support across most contexts except REF and TSL.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nnot_(a)\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesWindowOutput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesWindowOutput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an output port for a time-series window.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_33\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesWindowOutput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Accessing Item by Index in Python-like Contexts\nDESCRIPTION: Represents accessing an element `b` within a container `a` using index-based lookup (getitem). The surrounding table indicates its support across different types/contexts, specifically highlighting support for TSB, TSL, SET, TUPLE, LIST, DICT, TS.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\na[b]\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.SetDelta Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.SetDelta` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class likely represents the changes (additions/removals) in a set-based time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_15\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.SetDelta\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Conceptual HGraph Run Loop Logic in Python\nDESCRIPTION: A conceptual Python code snippet illustrating the core evaluation loop of the HGraph run loop. It iterates based on time from `start_time` to `end_time`, evaluates the graph state (`self.evaluate_graph()`), determines the next scheduled event time (`next_scheduled_time()`), waits until that time (`self.wait_until()`), and advances the `current_time`. The wait behavior differs between REAL_TIME (actual wait) and SIMULATION (immediate return) modes. Note: This is a conceptual representation, not the actual implementation.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/run_loop_concept.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncurrent_time = start_time\nwhile current_time <= end_time:\n    self.evaluate_graph()\n    next_time = next_scheduled_time()\n    self.wait_until(next_time)\n    current_time = next_time\n```\n\n----------------------------------------\n\nTITLE: Applying Logical AND Operation in Python-like Contexts\nDESCRIPTION: Represents the logical AND operation between `a` and `b`, typically using a function `and_`. The surrounding table indicates broad support across most contexts except REF, TSL, and TSD.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nand_(a, b)\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TSL with Sphinx Autoclass (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` feature to automatically generate documentation for the Python class `hgraph.TSL`. The `:members:` option ensures that all documented members of the class are included. This class represents a time-series list in HGraph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TSL\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Installing Python and Node.js Dependencies for Perspective (Bash)\nDESCRIPTION: This bash command installs the required Python packages (perspective-python, pandas, tornado) via pip and Node.js packages (Perspective core, viewers, workspace, and custom plugins) globally via npm. These dependencies are necessary for running the associated Perspective example project, likely within a specified conda environment. Requires pip and npm to be installed.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/examples/web_ui/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install \"perspective-python>=2.10.1\" pandas tornado\nnpm install -g @finos/perspective@2.10.1 @finos/perspective-viewer-d3fc@2.10.1 @finos/perspective-viewer-datagrid@2.10.1 @finos/perspective-viewer@2.10.1 @finos/perspective-workspace@2.10.1 perspective-viewer-datagrid-norollups perspective-viewer-summary\n```\n\n----------------------------------------\n\nTITLE: Conceptual HGraph Node Evaluation Logic in Python\nDESCRIPTION: A conceptual Python snippet showing how the HGraph scheduler might evaluate nodes based on a time schedule. It iterates through the graph's nodes and checks if a node's scheduled time stored in the `self.schedule` list (aligned with `self.nodes`) matches the `current_time`. If it matches, the node's `eval()` method is called. Pre and post evaluation life-cycle observer methods are invoked around the `eval()` call.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/run_loop_concept.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfor i in range(len(self.nodes)):\n    if self.schedule[i] == current_time\n        self.nodes[i].eval()\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for hgraph.map_ using Sphinx\nDESCRIPTION: This reStructuredText directive instructs Sphinx to automatically generate documentation for the Python function `hgraph.map_`. It extracts the function signature, docstring, and other relevant information from the source code. Requires Sphinx environment and access to the hgraph module.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/dynamic_graphs.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hgraph.map_\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for hgraph.reduce using Sphinx\nDESCRIPTION: This reStructuredText directive instructs Sphinx to automatically generate documentation for the Python function `hgraph.reduce`. It extracts the function signature, docstring, and other relevant information from the source code. Requires Sphinx environment and access to the hgraph module.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/dynamic_graphs.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hgraph.reduce\n```\n\n----------------------------------------\n\nTITLE: Documenting websocket_client_adaptor Function (rst)\nDESCRIPTION: Uses the Sphinx `autofunction` directive in reStructuredText to automatically include documentation for the `websocket_client_adaptor` function from the `hgraph.adaptors.tornado.websocket_client_adaptor` Python module. This directive instructs Sphinx to pull the docstring and signature of the specified function.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/websocket_api.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hgraph.adaptors.tornado.websocket_client_adaptor.websocket_client_adaptor\n```\n\n----------------------------------------\n\nTITLE: Internal Implementation of HTTP Client Adaptor in Tornado (Python)\nDESCRIPTION: This function exposes the internal implementation details of the HTTP client adaptor for hgraph using Tornado. It is meant for advanced users who need low-level or custom integration with the HTTP client service. Prerequisites are hgraph and Tornado libraries.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/http_api.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n.. autofunction:: hgraph.adaptors.tornado.http_client_adaptor.http_client_adaptor_impl\n```\n\n----------------------------------------\n\nTITLE: Documenting WebSocketResponse Class (rst)\nDESCRIPTION: Uses the Sphinx `autoclass` directive in reStructuredText to automatically include documentation for the `WebSocketResponse` class from the `hgraph.adaptors.tornado.websocket_server_adaptor` Python module. This directive instructs Sphinx to pull the class docstring, methods, and attributes.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/websocket_api.rst#_snippet_7\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.adaptors.tornado.websocket_server_adaptor.WebSocketResponse\n```\n\n----------------------------------------\n\nTITLE: Documenting WebSocketConnectRequest Class (rst)\nDESCRIPTION: Uses the Sphinx `autoclass` directive in reStructuredText to automatically include documentation for the `WebSocketConnectRequest` class from the `hgraph.adaptors.tornado.websocket_server_adaptor` Python module. This directive instructs Sphinx to pull the class docstring, methods, and attributes.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/websocket_api.rst#_snippet_4\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.adaptors.tornado.websocket_server_adaptor.WebSocketConnectRequest\n```\n\n----------------------------------------\n\nTITLE: Using the 'first' Arrow Combinator in Python\nDESCRIPTION: Shows how to use the 'first' combinator (defined implicitly by the 'Arrow' definition context) with an Arrow instance. It creates an 'arr' instance 'to_upper' to convert a string to uppercase. The 'first' combinator applies 'to_upper' only to the first element of an input tuple ('hello', 42), leaving the second element unchanged. The result is ('HELLO', 42).\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/positioning_paper.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nto_upper = arr(lambda x: x.upper())\nfirst(to_upper)(('hello', 42))\n\n>>> (\"HELLO\", 42)\n```\n\n----------------------------------------\n\nTITLE: UML Visualization for Mesh Ranking in mesh_ - PlantUML\nDESCRIPTION: This PlantUML diagram shows the ranking/evaluation order in the mesh_ operator's graph construction. It models state transitions between nodes (f_a, f_b, f_a_b) with input dependencies for mesh-oriented compute graphs. No code logic, serves as documentation/visual aid.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/quick_start/map_reduce_switch.md#_snippet_7\n\nLANGUAGE: plantuml\nCODE:\n```\n@startuml mesh_ranking.png\nstate f_a {\n}\nstate f_b {\n}\n\nstate f_a_b {\n}\n\nf_a --> f_a_b : lhs \nf_b --> f_a_b : rhs\n\n@enduml\n\n```\n\n----------------------------------------\n\nTITLE: Cross Operator // for Tuple Splitting (Python)\nDESCRIPTION: Shows the use of the // operator to route elements of an input tuple to two distinct processing functions, then combining outputs downstream. Facilitates parallel processing and selective function application within tuple-valued graphs.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/src/hgraph/arrow/README.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\narrow(1, 2) | arrow(lambda x: x+1) // (lambda x: x+2) >> (lambda x: debug_print(\"out\", x))\n\n>>> out: {0: 2, 1: 4}\n```\n\n----------------------------------------\n\nTITLE: Defining Run Modes with PlantUML Enumeration - PlantUML\nDESCRIPTION: This snippet illustrates the possible configuration modes ('REAL_TIME' and 'SIMULATION') for the graph evaluation system in PlantUML. There are no dependencies aside from PlantUML for rendering, and it defines an enumeration named 'RunMode' with two public values. No parameters or inputs; serves solely for documentation and visualization within class diagrams.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/concepts/graph_runtime.md#_snippet_0\n\nLANGUAGE: PlantUML\nCODE:\n```\n@startuml run_mode_uml\\nenum RunMode {\\n    +REAL_TIME\\n    +SIMULATION\\n}\\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Describing Graph Structure and Scheduling Interface - PlantUML\nDESCRIPTION: The code models the interface of a 'Graph' used in the evaluation engine, detailing the accessor and behavioral methods including node listing, scheduling, evaluation, and metadata. Dependencies include a range of types like 'Node', 'ExecutionContext', and 'datetime'. The snippet is purely for UML diagramming using PlantUML and does not enforce validation beyond well-defined interface structure.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/concepts/graph_runtime.md#_snippet_4\n\nLANGUAGE: PlantUML\nCODE:\n```\n@startuml graph_uml\\ninterface Graph {\\n    + parent_node: Node | None\\n    + graph_id: tuple[int, ...]\\n    + nodes: tuple[Node, ...]\\n    + schedule: tuple[datetime, ...]\\n    + context: ExecutionContext\\n    + schedule_node(node_ndx: int, time: datetime) -> None\\n    + evaluate_graph()\\n}\\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Documenting websocket_server_handler Function (rst)\nDESCRIPTION: Uses the Sphinx `autofunction` directive in reStructuredText to automatically include documentation for the `websocket_server_handler` function from the `hgraph.adaptors.tornado.websocket_server_adaptor` Python module. This directive instructs Sphinx to pull the docstring and signature of the specified server handler function.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/websocket_api.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hgraph.adaptors.tornado.websocket_server_adaptor.websocket_server_handler\n```\n\n----------------------------------------\n\nTITLE: Defining Heterogeneous Tuple Type Hint in Python\nDESCRIPTION: Demonstrates the Python type hint syntax for a heterogeneous tuple containing a string, an integer, and a date. This is used within the HGraph type system context for defining tuple types.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/python/hg_types.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntuple[str, int, date]\n```\n\n----------------------------------------\n\nTITLE: Documenting WebSocketClientRequest Class (rst)\nDESCRIPTION: Uses the Sphinx `autoclass` directive in reStructuredText to automatically include documentation for the `WebSocketClientRequest` class from the `hgraph.adaptors.tornado.websocket_server_adaptor` Python module. This directive instructs Sphinx to pull the class docstring, methods, and attributes.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/websocket_api.rst#_snippet_6\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.adaptors.tornado.websocket_server_adaptor.WebSocketClientRequest\n```\n\n----------------------------------------\n\nTITLE: Documenting WebSocketServerRequest Class (rst)\nDESCRIPTION: Uses the Sphinx `autoclass` directive in reStructuredText to automatically include documentation for the `WebSocketServerRequest` class from the `hgraph.adaptors.tornado.websocket_server_adaptor` Python module. This directive instructs Sphinx to pull the class docstring, methods, and attributes.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/adaptors/tornado/websocket_api.rst#_snippet_5\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.adaptors.tornado.websocket_server_adaptor.WebSocketServerRequest\n```\n\n----------------------------------------\n\nTITLE: Visualizing HGraph Life Cycle with PlantUML\nDESCRIPTION: A PlantUML state diagram illustrating the basic life cycle of an HGraph graph and its nodes. It shows the transitions from an initial state to Starting upon `start()`, from Starting to Evaluating, and from Evaluating to Stopping upon `stop()`, finally returning to a terminal state.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/run_loop_concept.rst#_snippet_0\n\nLANGUAGE: plantuml\nCODE:\n```\n@startuml\n[*] --> Starting : start()\nStarting --> Evaluating\nEvaluating --> Stopping : stop()\nStopping --> [*]\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.SIGNAL with Sphinx Autoclass (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` feature to automatically generate documentation for the Python class `hgraph.SIGNAL`. The `:members:` option ensures that all documented members are included. This special type wraps any time-series type as an input, often used for triggering events.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_5\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.SIGNAL\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.REF with Sphinx Autoclass (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` feature to automatically generate documentation for the Python class `hgraph.REF`. The `:members:` option ensures that all documented members are included. This type represents a reference to another standard time-series type in HGraph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_6\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.REF\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesSet Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesSet` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents the implementation of a time-series containing set values.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_16\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesSet\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesBundle Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesBundle` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents the implementation of a time-series bundle, grouping multiple time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_23\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesBundle\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesDictOutput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesDictOutput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an output port for a dictionary-based time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_28\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesDictOutput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesDictInput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesDictInput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an input port for a dictionary-based time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_27\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesDictInput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Running hgraph Tests with Coverage using pytest (Bash)\nDESCRIPTION: Executes the project's test suite using `pytest` while simultaneously generating a code coverage report. The `--cov=hgraph` flag specifies that coverage should be measured for the `hgraph` package, and `--cov-report=xml` instructs the coverage plugin (`pytest-cov`) to output the results in XML format, often used for integration with CI/CD systems or other reporting tools. Requires `pytest` and `pytest-cov` to be installed.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Generate Coverage Report\npython -m pytest --cov=hgraph --cov-report=xml\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesReferenceOutput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesReferenceOutput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an output port that emits a reference to a time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_30\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesReferenceOutput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Example Pytest Failure Output for HGraph Node Test\nDESCRIPTION: Shows example output from a failing pytest run for the `rank` node test. It highlights the difference between the expected output and the actual output generated by the initial (buggy) implementation of the `rank` compute node, aiding in debugging.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/code_organisation.rst#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n>>>  Expected :[frozendict.frozendict({'c': -1.0, 'a': 0.0, 'b': 1.0})]\n>>>  Actual   :[frozendict.frozendict({'c': -1.0, 'a': -0.33333333333333337, 'b': 0.33333333333333326})]\n```\n\n----------------------------------------\n\nTITLE: Accessing Item by Attribute Name in Python-like Contexts\nDESCRIPTION: Represents accessing an attribute or item `b` from an object `a` using dot notation (getattr). The surrounding table shows limited support, primarily for REF and potentially when `values` is a schema type in TSD and TS.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/operators_support.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\na.b\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesReference Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesReference` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents the implementation of a reference to another time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_29\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesReference\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesReferenceInput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesReferenceInput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an input port that receives a reference to a time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_31\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesReferenceInput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Importing HGraph in Python\nDESCRIPTION: Illustrates how to import the HGraph package in a Python script using the standard 'import' statement. This snippet is essential for accessing all HGraph features and should be included at the top of any file utilizing HGraph. No input or output is produced by this statement, but it is a prerequisite for subsequent usage.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/getting_started.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport hgraph as hg\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting hgraph.evaluate_graph Function (Sphinx)\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `hgraph.evaluate_graph` Python function. It's used within a reStructuredText file to pull documentation from the source code.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/graph_run_loop.rst#_snippet_2\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autofunction:: hgraph.evaluate_graph\n```\n\n----------------------------------------\n\nTITLE: Visualizing Graph Connection between Nodes using PlantUML (PlantUML)\nDESCRIPTION: This PlantUML snippet provides a visual representation of how nodes 'const' and 'debug_print' are connected in an HGraph graph. It shows 'const' with an output pin, 'debug_print' with an input pin (ts), and an arrow from 'out' to 'ts' depicting the flow of the time-series data. It is intended solely for visual documentation and requires PlantUML to render. There are no parameters or dynamic inputs/outputsthis diagram clarifies graph structural relationships.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/time_series_types.rst#_snippet_2\n\nLANGUAGE: PlantUML\nCODE:\n```\n@startuml\\nstate const {\\n    state out <<outputPin>>\\n}\\nstate debug_print {\\n    state ts <<inputPin>>\\n}\\nout --> ts\\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesValueInput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesValueInput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an input port for a standard value time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_14\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesValueInput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Visualizing Node Ports and Connections using PlantUML (PlantUML)\nDESCRIPTION: This PlantUML snippet provides a state diagram representing the internal structure of a graph node in HGraph, showing multiple time-series input pins (ts_1, ts_i, ts_n) and a single output pin (out). It visually reflects constraints where a node has at most one output port connected to zero or more input ports. There are no dependencies beyond PlantUML, and the snippet outputs a diagram for documentation or design discussion purposes. No parameters are required, and no actual data is processedthis is strictly visual documentation.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/concepts/time_series_types.rst#_snippet_0\n\nLANGUAGE: PlantUML\nCODE:\n```\n@startuml\\nstate node {\\n    state ts_1 <<inputPin>>\\n    state ts_i <<inputPin>>\\n    state ts_n <<inputPin>>\\n    state out <<outputPin>>\\n}\\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting hgraph.test.eval_node Function (Sphinx)\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `hgraph.test.eval_node` Python function, a dedicated function for testing graph or node evaluation. It's used within a reStructuredText file.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/graph_run_loop.rst#_snippet_3\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autofunction:: hgraph.test.eval_node\n```\n\n----------------------------------------\n\nTITLE: Declaring Graph Executor Interface for Run Control - PlantUML\nDESCRIPTION: This code snippet uses PlantUML to model the 'GraphExecutor' interface, describing its association to the 'Graph', its control over run modes, and method signature for running the graph over specific time intervals. The interface exposes three members and a principal 'run' method, all for documentation/class diagram purposes with no code execution required.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/concepts/graph_runtime.md#_snippet_1\n\nLANGUAGE: PlantUML\nCODE:\n```\n@startuml graph_executor_uml\\ninterface GraphExecutor {\\n    +graph: Graph\\n    +run_mode: RunMode\\n    +run(start_time: datetime, end_time: datetime, observers=None) -> None\\n}\\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesListOutput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesListOutput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an output port for a list-based time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_22\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesListOutput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TSS with Sphinx Autoclass (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` feature to automatically generate documentation for the Python class `hgraph.TSS`. The `:members:` option ensures that all documented members of the class are included. This class represents a time-series of sets in HGraph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TSS\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesListInput Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesListInput` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents an input port for a list-based time-series.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_21\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesListInput\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TSW with Sphinx Autoclass (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` feature to automatically generate documentation for the Python class `hgraph.TSW`. The `:members:` option ensures that all documented members are included. This special type is used to define a buffered time-series in HGraph.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_7\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TSW\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Referencing the hgraph Service Output Setting Function\nDESCRIPTION: This reStructuredText directive employs Sphinx's `autofunction` to create documentation for the `hgraph.set_service_output` Python function. This function is designed to be called within an hgraph service to set the output value that the service will return.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/services.rst#_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hgraph.set_service_output\n```\n\n----------------------------------------\n\nTITLE: Including Documents in Sphinx Table of Contents using reStructuredText\nDESCRIPTION: This reStructuredText snippet utilizes the Sphinx `toctree` directive to create a table of contents entry that links to the document named 'positioning_paper'. When processed by Sphinx, this directive incorporates the content or link of the specified document into the generated documentation's navigation structure. It requires the Sphinx documentation generator and the existence of the 'positioning_paper' document file (e.g., positioning_paper.rst).\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/papers/index.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n    positioning_paper\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting hgraph.EvaluationLifeCycleObserver Class (Sphinx)\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `hgraph.EvaluationLifeCycleObserver` Python interface class, including its members. Implementations of this interface can observe graph evaluation state transitions.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/graph_run_loop.rst#_snippet_4\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autoclass:: hgraph.EvaluationLifeCycleObserver\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Documenting hgraph.TimeSeriesWindow Class (rst)\nDESCRIPTION: This reStructuredText directive uses Sphinx's `autoclass` to document the `hgraph.TimeSeriesWindow` class. It includes all members (`:members:`, `:undoc-members:`) and shows inheritance (`:show-inheritance:`). This class represents the implementation of a time-series window or buffer.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/time_series_types.rst#_snippet_32\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: hgraph.TimeSeriesWindow\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting hgraph.WiringObserver Class (Sphinx)\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `hgraph.WiringObserver` Python interface class, including its members. Implementations can hook into the graph wiring process.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/graph_run_loop.rst#_snippet_7\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autoclass:: hgraph.WiringObserver\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting hgraph.GraphConfiguration Class (Sphinx)\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `hgraph.GraphConfiguration` Python class, including its members. It's used within a reStructuredText file to pull documentation from the source code.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/graph_run_loop.rst#_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autoclass:: hgraph.GraphConfiguration\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for hgraph.switch_ using Sphinx\nDESCRIPTION: This reStructuredText directive instructs Sphinx to automatically generate documentation for the Python function `hgraph.switch_`. It extracts the function signature, docstring, and other relevant information from the source code. Requires Sphinx environment and access to the hgraph module.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/dynamic_graphs.rst#_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: hgraph.switch_\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting hgraph.test.EvaluationTrace Class (Sphinx)\nDESCRIPTION: This Sphinx directive automatically generates documentation for the `hgraph.test.EvaluationTrace` Python class, including members and inherited members. This class likely implements `EvaluationLifeCycleObserver` for tracing purposes during testing.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/reference/graph_run_loop.rst#_snippet_5\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autoclass:: hgraph.test.EvaluationTrace\n    :members:\n    :undoc-members:\n    :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Generating a Cited Bibliography in Sphinx (ReStructuredText)\nDESCRIPTION: This ReStructuredText snippet utilizes the Sphinx `bibliography` directive to automatically generate a list of references. The `:cited:` option specifies that only references explicitly cited elsewhere in the document should be included in this bibliography section. This requires Sphinx and a configured bibliography data source (like a BibTeX file).\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/references.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. bibliography::\n   :cited:\n```\n\n----------------------------------------\n\nTITLE: Illustrating Spreadsheet Cell Assignments and Formula Computation - text\nDESCRIPTION: This snippet mimics spreadsheet cell assignments and computations in plain text, not code, showing how each cell can be defined either by value or by formula referencing other cells. It clarifies the relationships that will later be mapped to graph nodes and dependencies when implemented in a computation graph such as HGraph. There are no explicit dependencies nor code for execution; inputs are described symbolically, and outputs are expected as the computed value of the referenced cell formulas.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs/source/programming_model/mental_model.rst#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nA1 = 5\nA2 = 2\nB2 = A1 + A2\nC2 = B2 / A1\n```\n\n----------------------------------------\n\nTITLE: Specifying Evaluation Clock Interface and Properties - PlantUML\nDESCRIPTION: This PlantUML interface diagram details the properties provided by an 'EvaluationClock', such as evaluation and wall times, cycle timing, and next evaluation schedule. It documents four key attributes as read-only interface members, to guide proper usage for time-based node evaluation within the engine. Intended for visualization only; no execution required.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/concepts/graph_runtime.md#_snippet_2\n\nLANGUAGE: PlantUML\nCODE:\n```\n@startuml evaluation_clock_uml\\ninterface EvaluationClock {\\n    + evaluation_time: datetime\\n    + now: datetime\\n    + cycle_time: timedelta\\n    + next_cycle_evaluation_time: datetime\\n}\\n@enduml\n```\n\n----------------------------------------\n\nTITLE: Visualizing FPG Node Flow with PlantUML/ditaa\nDESCRIPTION: This PlantUML snippet uses the ditaa renderer to create a simple diagram illustrating the basic flow of data in a Forward Propagation Graph (FPG). It shows a 'Source' node feeding into a 'Compute' node, which in turn feeds into a 'Sink' node, representing the typical directed path in the DAG.\nSOURCE: https://github.com/hhenson/hgraph/blob/main/docs_md/concepts/forward_propagation_graph.md#_snippet_0\n\nLANGUAGE: plantuml\nCODE:\n```\n@startditaa src_cmpt_snk_diagram\n +--------+\n | Source |\n +--------+\n     |\n     v\n+---------+\n| Compute |\n+---------+\n     |\n     v\n +-------+\n | Sink  |\n +-------+\n@endditaa\n```"
  }
]