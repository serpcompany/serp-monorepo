[
  {
    "owner": "kludex",
    "repo": "python-multipart",
    "content": "TITLE: Computing SHA-256 Hashes of Uploaded Files with Python-Multipart\nDESCRIPTION: An in-depth example showing how to use Python-Multipart to compute SHA-256 hashes of uploaded files in a streaming manner without storing the entire file in memory. It demonstrates parsing the Content-Type header, setting up callbacks for multipart events, and feeding data to the parser from the request stream.\nSOURCE: https://github.com/kludex/python-multipart/blob/master/docs/index.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport hashlib\nimport python_multipart\nfrom python_multipart.multipart import parse_options_header\n\ndef simple_app(environ, start_response):\n    ret = []\n\n    # Python 2 doesn't have the \"nonlocal\" keyword from Python 3, so we get\n    # around it by setting attributes on a dummy object.\n    class g(object):\n        hash = None\n\n    # This is called when a new part arrives.  We create a new hash object\n    # in this callback.\n    def on_part_begin():\n        g.hash = hashlib.sha256()\n\n    # We got some data!  Update our hash.\n    def on_part_data(data, start, end):\n        g.hash.update(data[start:end])\n\n    # Our current part is done, so we can finish the hash.\n    def on_part_end():\n        ret.append(\"Part hash: %s\" % (g.hash.hexdigest(),))\n\n    # Parse the Content-Type header to get the multipart boundary.\n    content_type, params = parse_options_header(environ['CONTENT_TYPE'])\n    boundary = params.get(b'boundary')\n\n    # Callbacks dictionary.\n    callbacks = {\n        'on_part_begin': on_part_begin,\n        'on_part_data': on_part_data,\n        'on_part_end': on_part_end,\n    }\n\n    # Create the parser.\n    parser = python_multipart.MultipartParser(boundary, callbacks)\n\n    # The input stream is from the WSGI environ.\n    inp = environ['wsgi.input']\n\n    # Feed the parser with data from the request.\n    size = int(environ['CONTENT_LENGTH'])\n    while size > 0:\n        to_read = min(size, 1024 * 1024)\n        data = inp.read(to_read)\n        parser.write(data)\n\n        size -= len(data)\n        if len(data) != to_read:\n            break\n\n    start_response('200 OK', [('Content-type', 'text/plain')])\n    return ret\n\nfrom wsgiref.simple_server import make_server\nhttpd = make_server('', 8123, simple_app)\nprint(\"Serving on port 8123...\")\nhttpd.serve_forever()\n```\n\n----------------------------------------\n\nTITLE: Parsing Multipart Form Data in a Simple WSGI Application with Python-Multipart\nDESCRIPTION: This example demonstrates how to parse an incoming multipart request body in a WSGI application using Python-Multipart. It shows how to set up callback functions for handling form fields and file uploads, and how to convert WSGI environment variables to HTTP headers for the parser.\nSOURCE: https://github.com/kludex/python-multipart/blob/master/docs/index.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport python_multipart\n\ndef simple_app(environ, start_response):\n    ret = []\n\n    # The following two callbacks just append the name to the return value.\n    def on_field(field):\n        ret.append(b\"Parsed value parameter named: %s\" % (field.field_name,))\n\n    def on_file(file):\n        ret.append(b\"Parsed file parameter named: %s\" % (file.field_name,))\n\n    # Create headers object.  We need to convert from WSGI to the actual\n    # name of the header, since this library does not assume that you are\n    # using WSGI.\n    headers = {'Content-Type': environ['CONTENT_TYPE']}\n    if 'HTTP_X_FILE_NAME' in environ:\n        headers['X-File-Name'] = environ['HTTP_X_FILE_NAME']\n    if 'CONTENT_LENGTH' in environ:\n        headers['Content-Length'] = environ['CONTENT_LENGTH']\n\n    # Parse the form.\n    python_multipart.parse_form(headers, environ['wsgi.input'], on_field, on_file)\n\n    # Return something.\n    start_response('200 OK', [('Content-type', 'text/plain')])\n    ret.append(b'\\n')\n    return ret\n\nfrom wsgiref.simple_server import make_server\nfrom wsgiref.validate import validator\n\nhttpd = make_server('', 8123, simple_app)\nprint(\"Serving on port 8123...\")\nhttpd.serve_forever()\n```\n\n----------------------------------------\n\nTITLE: Basic WSGI Application Setup for Python-Multipart Example\nDESCRIPTION: A minimal WSGI application setup that serves as the foundation for demonstrating Python-Multipart functionality. This code initializes a simple server that responds with a 'Hashes:' message, which will be extended in the in-depth example.\nSOURCE: https://github.com/kludex/python-multipart/blob/master/docs/index.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport python_multipart\n\ndef simple_app(environ, start_response):\n    start_response('200 OK', [('Content-type', 'text/plain')])\n    return ['Hashes:\\n']\n\nfrom wsgiref.simple_server import make_server\nhttpd = make_server('', 8123, simple_app)\nprint(\"Serving on port 8123...\")\nhttpd.serve_forever()\n```\n\n----------------------------------------\n\nTITLE: Running Fuzz Tests with Python\nDESCRIPTION: Command to execute the fuzz testing script fuzz_form.py located in the fuzz directory.\nSOURCE: https://github.com/kludex/python-multipart/blob/master/fuzz/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ python fuzz/fuzz_form.py\n```\n\n----------------------------------------\n\nTITLE: Fuzz Testing Output Example\nDESCRIPTION: Sample output from running the fuzz tests showing coverage statistics, execution progress, and memory usage information.\nSOURCE: https://github.com/kludex/python-multipart/blob/master/fuzz/README.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n#2      INITED cov: 32 ft: 32 corp: 1/1b exec/s: 0 rss: 49Mb\n#3      NEW    cov: 33 ft: 33 corp: 2/2b lim: 4 exec/s: 0 rss: 49Mb L: 1/1 MS: 1 ChangeByte-\n#4      NEW    cov: 97 ft: 97 corp: 3/4b lim: 4 exec/s: 0 rss: 49Mb L: 2/2 MS: 1 InsertByte-\n#11     NEW    cov: 116 ft: 119 corp: 4/5b lim: 4 exec/s: 0 rss: 49Mb L: 1/2 MS: 2 ChangeBinInt-EraseBytes-\n#30     NEW    cov: 131 ft: 134 corp: 5/8b lim: 4 exec/s: 0 rss: 49Mb L: 3/3 MS: 4 ChangeByte-ChangeBit-InsertByte-CopyPart-\n#31     NEW    cov: 135 ft: 138 corp: 6/11b lim: 4 exec/s: 0 rss: 49Mb L: 3/3 MS: 1 CrossOver-\n#39     NEW    cov: 135 ft: 142 corp: 7/15b lim: 4 exec/s: 0 rss: 49Mb L: 4/4 MS: 3 ChangeBit-CrossOver-CopyPart-\n```\n\n----------------------------------------\n\nTITLE: Listing Development Scripts in Markdown\nDESCRIPTION: A markdown list of development scripts available in the python-multipart project, including setup, test, lint, check, and rename scripts with their respective purposes.\nSOURCE: https://github.com/kludex/python-multipart/blob/master/scripts/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* `scripts/setup` - Install dependencies.\n* `scripts/test` - Run the test suite.\n* `scripts/lint` - Run the code format.\n* `scripts/check` - Run the lint in check mode, and the type checker.\n* `scripts/rename` - Check that the backward-compat `multipart` name works as expected.\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Format\nDESCRIPTION: A markdown-formatted changelog documenting version history, with each version containing links to relevant pull requests and descriptions of changes\nSOURCE: https://github.com/kludex/python-multipart/blob/master/CHANGELOG.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Changelog\n\n## 0.0.20 (2024-12-16)\n\n* Handle messages containing only end boundary [#142](https://github.com/Kludex/python-multipart/pull/142).\n\n## 0.0.19 (2024-11-30)\n\n* Don't warn when CRLF is found after last boundary on `MultipartParser` [#193](https://github.com/Kludex/python-multipart/pull/193).\n```"
  }
]