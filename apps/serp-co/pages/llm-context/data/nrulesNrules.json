[
  {
    "owner": "nrules",
    "repo": "nrules",
    "content": "TITLE: Creating InsuranceQuote Domain Model\nDESCRIPTION: This C# snippet defines an `InsuranceQuote` class with properties for the driver, base premium, and final premium. It also includes methods to apply surcharges and discounts to the final premium. This class serves as a fact in the NRules engine to represent an insurance quote.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\npublic class InsuranceQuote(Driver driver, decimal basePremium)\n{\n    public Driver Driver { get; } = driver;\n    public decimal BasePremium { get; } = basePremium;\n    public decimal FinalPremium { get; private set; } = basePremium;\n\n    public void ApplySurcharge(decimal amount) => FinalPremium += amount;\n    public void ApplyDiscount(decimal amount) => FinalPremium -= amount;\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Facts with Patterns in NRules (Fluent DSL)\nDESCRIPTION: This code snippet illustrates how to match facts with patterns using the fluent C# DSL in NRules. It shows how to bind a pattern to a variable (`customer`, `account`) and use that variable in subsequent patterns and actions. The rule matches a `Customer` that `IsPreferred` and an `Account` that belongs to that customer and `IsActive`, then executes `customer.DoSomething()`.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fluent-rules-dsl.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic class PreferredCustomerActiveAccountsRule : Rule\n{\n    public override void Define()\n    {\n        Customer customer = default!;\n        Account account = default!;\n\n        When()\n            .Match<Customer>(() => customer, c => c.IsPreferred)\n            .Match<Account>(() => account, a => a.Owner == customer, a => a.IsActive);\n\n        Then()\n            .Do(ctx => customer.DoSomething());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Traffic Violation Surcharge Rule\nDESCRIPTION: This C# snippet defines a more complex rule that applies a surcharge based on the number of recent traffic violations (excluding parking) within the last 2 years. It matches an `InsuranceQuote` and then queries for `TrafficViolation` facts associated with the same driver. It calculates the total number of relevant violations and applies a surcharge if there are more than one.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic class TrafficViolationSurchargeRule : Rule\n{\n    public override void Define()\n    {\n        InsuranceQuote quote = default!;\n        IEnumerable<TrafficViolation> violations = default!;\n        int totalViolations = 0;\n\n        When()\n            .Match(() => quote)\n            .Query(() => violations, q => q\n                .Match<TrafficViolation>()\n                .Where(v => v.Driver == quote.Driver,\n                    v => v.ViolationType != \"Parking\",\n                    v => v.Date >= DateTime.Now.AddYears(-2))\n                .Collect())\n            .Let(() => totalViolations, () => violations.Count())\n            .Having(() => totalViolations > 1);\n        \n        Then()\n            .Do(ctx => quote.ApplySurcharge(20 * totalViolations));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Rule with Metadata in NRules (Fluent DSL)\nDESCRIPTION: This code snippet shows how to define a rule with metadata using the fluent C# DSL in NRules. It demonstrates how to use attributes like `Name`, `Description`, `Tag`, `Priority`, and `Repeatability` to associate additional information with the rule.  The rule matches a `Customer` named \"John Do\" and then executes `DoSomething()`.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fluent-rules-dsl.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\n[Name(\"MyRule\"), Description(\"Test rule that demonstrates metadata usage\")]\n[Tag(\"Test\"), Tag(\"Metadata\")]\n[Priority(10)]\n[Repeatability(RuleRepeatability.Repeatable)]\npublic class RuleWithMetadata : Rule\n{\n    public override void Define()\n    {\n        When()\n            .Match<Customer>(c => c.Name == \"John Do\");\n        Then()\n            .Do(ctx => DoSomething());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Experienced Driver Discount Rule\nDESCRIPTION: This C# snippet defines a rule that applies a discount to an insurance quote if the driver has 5 or more years of experience. It inherits from `Rule` and uses the fluent DSL to define the conditions and actions. The `When` part matches an `InsuranceQuote` with a driver having sufficient experience, and the `Then` part applies a discount of 50 to the quote.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class ExperiencedDriverDiscountRule : Rule\n{\n    public override void Define()\n    {\n        InsuranceQuote quote = default!;\n\n        When()\n            .Match(() => quote, q => q.Driver.YearsOfExperience >= 5);\n\n        Then()\n            .Do(ctx => quote.ApplyDiscount(50));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running NRules Engine\nDESCRIPTION: This C# snippet demonstrates how to load, compile, and run rules using the NRules engine. It loads rules from an assembly, compiles them into a session factory, creates a session, inserts facts (driver, quote, violations), fires the rules, and prints the results. An event handler is set up to print the name of each fired rule to the console.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\n//Load rules\nvar repository = new RuleRepository();\nrepository.Load(x => x.From(typeof(YoungDriverSurchargeRule).Assembly));\n\n//Compile rules\nvar factory = repository.Compile();\n\n//Create rules session\nvar session = factory.CreateSession();\n\n//Setup an event handler that prints the name of the fired rule\nsession.Events.RuleFiredEvent += (_, args) \n    => Console.WriteLine($\"Fired rule: {args.Rule.Name}\");\n\n//Load domain model\nvar driver = new Driver(name: \"John Doe\", age: 24, yearsOfExperience: 1);\nvar quote = new InsuranceQuote(driver, basePremium: 1000);\nTrafficViolation[] violations =\n[\n    new(driver, DateTime.Now.AddMonths(-1), \"Speeding\"),\n    new(driver, DateTime.Now.AddMonths(-2), \"Parking\"),\n    new(driver, DateTime.Now.AddYears(-1), \"Red Light\"),\n    new(driver, DateTime.Now.AddYears(-3), \"Speeding\")\n];\n\n//Insert facts into rules engine's memory\nsession.Insert(quote);\nsession.InsertAll(violations);\n\n//Start match/resolve/act cycle\nsession.Fire();\n\n//Print results\nConsole.WriteLine($\"Base premium for {driver.Name}: {quote.BasePremium}\");\nConsole.WriteLine($\"Final premium for {driver.Name}: {quote.FinalPremium}\");\n```\n\n----------------------------------------\n\nTITLE: Order Amount Calculation Rule with Agenda Filter C#\nDESCRIPTION: This C# code defines a rule that calculates the order amount based on quantity, unit price, and discount. It uses an agenda filter to trigger the rule only when quantity, unit price, or discount changes and the quantity is greater than zero.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/agenda-filters.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic class OrderAmountCalculationRule : Rule\n{\n    public override void Define()\n    {\n        Order order = default!;\n\n        When()\n            .Match(() => order);\n\n        Filter()\n            .OnChange(() => order.Quantity, () => order.UnitPrice, () => order.PercentDiscount)\n            .Where(() => order.Quantity > 0);\n\n        Then()\n            .Do(ctx => ctx.Update(order, CalculateAmount));\n    }\n\n    private static void CalculateAmount(Order order)\n    {\n        order.Amount = order.UnitPrice * order.Quantity * (1.0 - order.PercentDiscount / 100.0);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Rule Dependencies using Fluent DSL in NRules (C#)\nDESCRIPTION: This C# code snippet demonstrates how to declare dependencies within a NRules rule using the fluent DSL. It shows how to resolve a dependency (INotificationService) and bind it to a variable, which can then be used in rule actions. The service variable can be used in rule actions. The rules engine will inject the dependency when the rule fires.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/rule-dependencies.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic class DeniedClaimNotificationRule : Rule\n{\n    public override void Define()\n    {\n        INotificationService service = default!;\n        Claim claim = default!;\n\n        Dependency()\n            .Resolve(() => service);\n\n        When()\n            .Match(() => claim, c => c.Status == ClaimStatus.Denied);\n\n        Then()\n            .Do(_ => service.ClaimDenied(claim));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Preferred Customer Discount Rule with Reactive LINQ Query in C#\nDESCRIPTION: This C# code defines a rule that applies a discount to a preferred customer's orders. It uses a reactive LINQ query to collect all open and non-discounted orders for a given customer. The `Match` operator starts the query, filtering orders based on customer, open status, and discount status. `Collect` aggregates the matching orders into a collection, and `Where` ensures the collection is not empty.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/reactive-linq-queries.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[Name(\"Preferred customer discount\")]\npublic class PreferredCustomerDiscountRule : Rule\n{\n    public override void Define()\n    {\n        Customer customer = default!;\n        IEnumerable<Order> orders = default!;\n\n        When()\n            .Match<Customer>(() => customer, c => c.IsPreferred)\n            .Query(() => orders, x => x\n                .Match<Order>(\n                    o => o.Customer == customer,\n                    o => o.IsOpen,\n                    o => !o.IsDiscounted)\n                .Collect()\n                .Where(c => c.Any()));\n\n        Then()\n            .Do(ctx => ApplyDiscount(orders, 10.0)));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Rule Definition using RuleBuilder in C#\nDESCRIPTION: This code snippet demonstrates how to build a rule definition using the RuleBuilder class. It creates a rule with conditions based on the Customer's name and the Order's amount. The rule also includes an action to print the customer's name and order amount to the console when the conditions are met.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/rule-builder.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nprivate IRuleDefinition BuildRule()\n{\n    //Create rule builder\n    var builder = new RuleBuilder();\n    builder.Name(\"TestRule\");\n\n    //Build conditions\n    PatternBuilder customerPattern = builder.LeftHandSide().Pattern(typeof (Customer), \"customer\");\n    Expression<Func<Customer, bool>> customerCondition = \n        customer => customer.Name == \"John Do\";\n    customerPattern.Condition(customerCondition);\n\n    PatternBuilder orderPattern = builder.LeftHandSide().Pattern(typeof (Order), \"order\");\n    Expression<Func<Order, Customer, bool>> orderCondition1 = \n        (order, customer) => order.Customer == customer;\n    Expression<Func<Order, bool>> orderCondition2 = \n        order => order.Amount > 100.00m;\n    orderPattern.Condition(orderCondition1);\n    orderPattern.Condition(orderCondition2);\n\n    //Build actions\n    Expression<Action<IContext, Customer, Order>> action = \n        (ctx, customer, order) => Console.WriteLine(\"Customer {0} has an order in amount of ${1}\", customer.Name, order.Amount);\n    builder.RightHandSide().Action(action);\n\n    //Build rule model\n    return builder.Build();\n}\n```\n\n----------------------------------------\n\nTITLE: Young Driver Surcharge Rule\nDESCRIPTION: This C# snippet defines a rule that applies a surcharge to an insurance quote if the driver is younger than 25. It inherits from `Rule` and uses the fluent DSL to define the conditions and actions. The `When` part matches an `InsuranceQuote` with a driver younger than 25, and the `Then` part applies a surcharge of 100 to the quote.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\npublic class YoungDriverSurchargeRule : Rule\n{\n    public override void Define()\n    {\n        InsuranceQuote quote = default!;\n\n        When()\n            .Match(() => quote, q => q.Driver.Age < 25);\n\n        Then()\n            .Do(ctx => quote.ApplySurcharge(100));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Rule with Query, Let, and Having in NRules (C#)\nDESCRIPTION: This C# code snippet demonstrates how to define a rule in NRules using the Query, Let, and Having operators to express complex logic. It matches a preferred customer, queries their open orders, calculates the total amount of the orders using LINQ's Sum method, and then checks if the total is greater than 100. The Then part executes some action on the customer if all conditions are met. The rule depends on the Customer and Order classes.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fluent-rules-dsl.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class LargeTotalRule : Rule\n{\n    public override void Define()\n    {\n        Customer customer = default!;\n        IEnumerable<Order> orders = default!;\n        double total = 0;\n\n        When()\n            .Match<Customer>(() => customer, c => c.IsPreferred)\n            .Query(() => orders, x => x\n                .Match<Order>(\n                    o => o.Customer == customer,\n                    o => o.IsOpen)\n                .Collect())\n            .Let(() => total, () => orders.Sum(x => x.Amount))\n            .Having(() => total > 100);\n\n        Then()\n            .Do(ctx => customer.DoSomething(total));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Matched Facts in C#\nDESCRIPTION: This code shows how to verify that a rule fired with specific facts that satisfy a condition. It uses the Matched.Fact method to specify a constraint on the Customer fact, ensuring that IsPreferred is true when the rule fires three times. Requires NRules.Testing.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/unit-testing-rules.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nVerify(x => x.Rule().Fired(Times.Exactly(3), Matched.Fact<Customer>(c => c.IsPreferred)));\n```\n\n----------------------------------------\n\nTITLE: Testing Rules with Dependencies (Mocking) in C#\nDESCRIPTION: This code illustrates how to test rules with injected dependencies by mocking the dependencies using a mocking framework (e.g., Moq). The mock object is passed into the rule's constructor during the test setup, allowing for isolated testing of the rule's logic.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/unit-testing-rules.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar serviceMock = new Mock<IMyService>();\nvar rule = new MyRule(serviceMock.Object);\nSetup.Rule(rule);\n```\n\n----------------------------------------\n\nTITLE: Serializing/Deserializing NRules rules to/from JSON - C#\nDESCRIPTION: This code snippet demonstrates how to serialize an NRules rule into JSON and deserialize it back using JsonSerializer from System.Text.Json. It configures JsonSerializerOptions for indented output and camel case property naming, and then uses RuleSerializer to set up the options for NRules types. The rule is built using BuildRule() method, which is not shown in this snippet, and is expected to return an IRuleDefinition object.  Deserialization requires specifying the type to deserialize into, in this case IRuleDefinition. Care must be taken to not deserialize rules from untrusted sources due to associated security risk.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/json-serialization.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nIRuleDefinition rule = BuildRule();\n\n//Set up JsonSerializerOptions\nvar options = new JsonSerializerOptions\n{\n    WriteIndented = true,\n    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\n};\nRuleSerializer.Setup(options);\n\n//Serialize a rule into JSON\nvar json = JsonSerializer.Serialize(rule, options);\n\n//Deserialize a rule from JSON\nvar ruleClone = JsonSerializer.Deserialize<IRuleDefinition>(json, options);\n```\n\n----------------------------------------\n\nTITLE: Using Existential Rules in NRules (Fluent DSL)\nDESCRIPTION: This code snippet demonstrates the use of existential rules in NRules using the fluent C# DSL. It shows how to use the `Exists` method to check for the presence of facts that match certain conditions. The rule matches a `Customer` that `IsPreferred` and checks if there exists an `Account` that belongs to that customer and `IsActive`, then executes `customer.DoSomething()`.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fluent-rules-dsl.md#_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\npublic class PreferredCustomerActiveAccountsRule : Rule\n{\n    public override void Define()\n    {\n        Customer customer = default!;\n\n        When()\n            .Match<Customer>(() => customer, c => c.IsPreferred)\n            .Exists<Account>(a => a.Owner == customer, a => a.IsActive);\n\n        Then()\n            .Do(ctx => customer.DoSomething());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Negative Rules in NRules (Fluent DSL)\nDESCRIPTION: This code snippet demonstrates negative rules (testing for absence of facts) in NRules using the fluent C# DSL. It uses the `Not` method to check for the absence of facts that match certain conditions. The rule matches a `Customer` that `IsPreferred` and checks if there is NOT an `Account` that belongs to that customer and `IsDelinquent`, then executes `customer.DoSomething()`.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fluent-rules-dsl.md#_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\npublic class PreferredCustomerNotDelinquentRule : Rule\n{\n    public override void Define()\n    {\n        Customer customer = default!;\n\n        When()\n            .Match<Customer>(() => customer, c => c.IsPreferred)\n            .Not<Account>(a => a.Owner == customer, a => a.IsDelinquent);\n\n        Then()\n            .Do(ctx => customer.DoSomething());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Driver Domain Model\nDESCRIPTION: This C# snippet defines a `Driver` class with properties for name, age, and years of experience. It represents a driver in the auto insurance domain model. The class utilizes C# 9 record-like syntax with a constructor initializing the properties.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic class Driver(string name, int age, int yearsOfExperience)\n{\n    public string Name { get; } = name;\n    public int Age { get; } = age;\n    public int YearsOfExperience { get; } = yearsOfExperience;\n}\n```\n\n----------------------------------------\n\nTITLE: Example NRules rule in JSON format - JSON\nDESCRIPTION: This JSON snippet represents an example NRules rule that identifies large orders placed by John Do. It defines conditions based on customer name and order amount, and includes an action to write a message to the console when the rule is matched. The rule's structure consists of a left-hand side (LHS) defining the conditions (patterns and expressions) and a right-hand side (RHS) specifying the actions to be executed. Requires types `Customer`, `Order`, and `Context`.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/json-serialization.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"name\": \"John Do Large Order Rule\",\n  \"leftHandSide\": {\n    \"elementType\": \"And\",\n    \"childElements\": [\n      {\n        \"elementType\": \"Pattern\",\n        \"name\": \"customer\",\n        \"type\": \"Customer\",\n        \"expressions\": [\n          {\n            \"name\": \"Condition\",\n            \"expression\": {\n              \"nodeType\": \"Lambda\",\n              \"parameters\": [\n                {\n                  \"name\": \"customer\",\n                  \"type\": \"Customer\"\n                }\n              ],\n              \"body\": {\n                \"nodeType\": \"Equal\",\n                \"left\": {\n                  \"nodeType\": \"MemberAccess\",\n                  \"memberType\": \"Property\",\n                  \"name\": \"Name\",\n                  \"declaringType\": \"Customer\",\n                  \"expression\": {\n                    \"nodeType\": \"Parameter\",\n                    \"name\": \"customer\",\n                    \"type\": \"Customer\"\n                  }\n                },\n                \"right\": {\n                  \"nodeType\": \"Constant\",\n                  \"type\": \"string\",\n                  \"value\": \"John Do\"\n                }\n              }\n            }\n          }\n        ]\n      },\n      {\n        \"elementType\": \"Pattern\",\n        \"name\": \"order\",\n        \"type\": \"Order\",\n        \"expressions\": [\n          {\n            \"name\": \"Condition\",\n            \"expression\": {\n              \"nodeType\": \"Lambda\",\n              \"parameters\": [\n                {\n                  \"name\": \"order\",\n                  \"type\": \"Order\"\n                },\n                {\n                  \"name\": \"customer\",\n                  \"type\": \"Customer\"\n                }\n              ],\n              \"body\": {\n                \"nodeType\": \"Equal\",\n                \"left\": {\n                  \"nodeType\": \"MemberAccess\",\n                  \"memberType\": \"Property\",\n                  \"name\": \"Customer\",\n                  \"declaringType\": \"Order\",\n                  \"expression\": {\n                    \"nodeType\": \"Parameter\",\n                    \"name\": \"order\",\n                    \"type\": \"Order\"\n                  }\n                },\n                \"right\": {\n                  \"nodeType\": \"Parameter\",\n                  \"name\": \"customer\",\n                  \"type\": \"Customer\"\n                }\n              }\n            }\n          },\n          {\n            \"name\": \"Condition\",\n            \"expression\": {\n              \"nodeType\": \"Lambda\",\n              \"parameters\": [\n                {\n                  \"name\": \"order\",\n                  \"type\": \"Order\"\n                }\n              ],\n              \"body\": {\n                \"nodeType\": \"GreaterThan\",\n                \"left\": {\n                  \"nodeType\": \"MemberAccess\",\n                  \"memberType\": \"Property\",\n                  \"name\": \"Amount\",\n                  \"declaringType\": \"Order\",\n                  \"expression\": {\n                    \"nodeType\": \"Parameter\",\n                    \"name\": \"order\",\n                    \"type\": \"Order\"\n                  }\n                },\n                \"right\": {\n                  \"nodeType\": \"Constant\",\n                  \"type\": \"double\",\n                  \"value\": 100\n                }\n              }\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"rightHandSide\": [\n    {\n      \"expression\": {\n        \"nodeType\": \"Lambda\",\n        \"parameters\": [\n          {\n            \"name\": \"ctx\",\n            \"type\": \"Context\"\n          }\n        ],\n        \"body\": {\n          \"nodeType\": \"Call\",\n          \"methodName\": \"WriteLine\",\n          \"declaringType\": \"Console\",\n          \"arguments\": [\n            {\n              \"nodeType\": \"Constant\",\n              \"type\": \"string\",\n              \"value\": \"Found large order\"\n            }\n          ]\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Universal Quantifier in NRules (Fluent DSL)\nDESCRIPTION: This code snippet demonstrates the use of a universal quantifier in NRules using the fluent C# DSL. It showcases how to use the `All` method to ensure that all facts matching a particular condition also satisfy subsequent conditions. The rule matches a `Customer` that `IsPreferred` and ensures that ALL `Account`s that belong to that customer are `IsActive`, then executes `customer.DoSomething()`.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fluent-rules-dsl.md#_snippet_4\n\nLANGUAGE: c#\nCODE:\n```\npublic class PreferredCustomerAllAccountsActiveRule : Rule\n{\n    public override void Define()\n    {\n        Customer customer = default!;\n\n        When()\n            .Match<Customer>(() => customer, c => c.IsPreferred)\n            .All<Account>(a => a.Owner == customer, a => a.IsActive);\n\n        Then()\n            .Do(ctx => customer.DoSomething());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Print Instant Discount Rule\nDESCRIPTION: This code defines a rule that prints the instant discount information to the console when an `InstantDiscount` fact is present. It uses `Console.WriteLine` to output the customer's name and the discount amount. The rule depends on the existence of an `InstantDiscount` fact, which would typically be created by another rule (e.g., `PreferredCustomerDiscountRule`).\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/forward-chaining.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic class PrintInstantDiscountRule : Rule\n{\n    public override void Define()\n    {\n        InstantDiscount discount = default!;\n\n        When()\n            .Match(() => discount);\n\n        Then()\n            .Do(_ => Console.WriteLine(\"Customer {0} has instant discount of {1}\", \n                discount.Customer.Name, discount.Amount));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Grouping Patterns with OR in NRules (Fluent DSL)\nDESCRIPTION: This code snippet demonstrates how to group patterns using the OR operator in NRules using the fluent C# DSL. It shows how to combine multiple conditions such that the rule activates if any of the groups of conditions are met. The rule matches a `Customer` that `IsPreferred` OR a customer that is NOT preferred but has an `Order` where the `Customer` matches, and the `Price` is over 1000, then executes `customer.DoSomething()`.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fluent-rules-dsl.md#_snippet_5\n\nLANGUAGE: c#\nCODE:\n```\npublic class PreferredCustomerOrHasLargeOrderRule : Rule\n{\n    public override void Define()\n    {\n        Customer customer = default!;\n\n        When()\n            .Or(x => x\n                .Match<Customer>(() => customer, c => c.IsPreferred)\n                .And(xx => xx\n                    .Match<Customer>(() => customer, c => !c.IsPreferred)\n                    .Exists<Order>(o => o.Customer == customer, o => o.Price >= 1000.00)));\n\n        Then()\n            .Do(ctx => customer.DoSomething());\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining NRules Rule with Extended DSL - C#\nDESCRIPTION: This code demonstrates a more readable version of the NRules rule using DSL extension methods. It utilizes custom verbs like `Claim`, `Patient`, `Insured`, and `Warning` to simplify the rule definition. These extensions encapsulate complex matching logic, making the rule easier to understand and maintain.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/dsl-extensions.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n[Name(\"Self insured name validation\")]\npublic class SelfInsuredNameValidationRule : Rule\n{\n    public override void Define()\n    {\n        Claim claim = default!;\n        Patient patient = default!;\n\n        When()\n            .Claim(() => claim)\n            .Patient(() => patient, p => p == claim.Patient, \n                p => p.RelationshipToInsured == Relationship.Self)\n            .Insured(i => i == claim.Insured, \n                i => !Equals(patient.Name, i.Name));\n\n        Then()\n            .Warning(claim, \"Self insured name does not match\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up a Test Fixture with RulesTestFixture in C#\nDESCRIPTION: This code demonstrates how to set up a test fixture using the RulesTestFixture class from the NRules.Testing library with xUnit. It defines a simple rule and facts, inserts the fact into the session, fires the rule, and asserts that the rule fired once. This uses NRules and xUnit.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/unit-testing-rules.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyRuleTest : RulesTestFixture\n{\n    public class MyFact { }\n\n    public class MyRule : Rule\n    {\n        public override void Define()\n        {\n            MyFact fact = default!;\n\n            When()\n                .Match(() => fact);\n\n            Then()\n                .Do(_ => NoOp());\n        }\n\n        private void NoOp() { }\n    }\n\n    public MyRuleTest()\n    {\n        Setup.Rule<MyRule>();\n    }\n    \n    [Fact]\n    public void Fire_InsertedOneMatchingFact_FiredOnce()\n    {\n        //Arrange\n        var fact = new MyFact();\n        Session.Insert(fact);\n\n        //Act\n        Session.Fire();\n\n        //Assert\n        Verify(x => x.Rule().Fired(Times.Once));\n    }\n    \n    [Fact]\n    public void Fire_NoMatchingFacts_DidNotFire()\n    {\n        //Arrange - Act\n        Session.Fire();\n\n        //Assert\n        Verify(x => x.Rule().Fired(Times.Never));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating NRules with .NET Dependency Injection (C#)\nDESCRIPTION: This C# code snippet shows how to integrate NRules with .NET's built-in dependency injection container. It uses the NRules.Integration.DependencyInjection package to register NRules with the service collection.  It configures NRules to load rules from the assembly containing the 'MyRule' type.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/rule-dependencies.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\nHost.CreateDefaultBuilder(args)  \n    .ConfigureServices((context, services) =>\n    {\n        services.AddRules(x => x.AssemblyOf(typeof(MyRule)));\n    });\n```\n\n----------------------------------------\n\nTITLE: NRules Unit Test Example\nDESCRIPTION: This code shows a unit test fixture for an NRules rule. It inherits from RulesTestFixture, adds the YoungDriverSurchargeRule to the setup, and includes two test methods to verify the rule's behavior based on driver age. It uses xUnit for assertions and NRules.Testing to verify rule firing.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_13\n\nLANGUAGE: c#\nCODE:\n```\npublic class YoungDriverSurchargeRuleTest : RulesTestFixture\n{\n    [Fact]\n    public void Fire_QuoteWithDriverAt25_DoesNotFire()\n    {\n        // Arrange\n        var driver = new Driver(\"John Do\", 25, 6);\n        var quote = new InsuranceQuote(driver, 1000);\n\n        // Act\n        Session.Insert(quote);\n        Session.Fire();\n\n        // Assert\n        Verify(x => x.Rule().Fired(Times.Never));\n    }\n    \n    [Fact]\n    public void Fire_QuoteWithDriverUnder25_Fires()\n    {\n        // Arrange\n        var driver = new Driver(\"John Do\", 24, 6);\n        var quote = new InsuranceQuote(driver, 1000);\n\n        // Act\n        Session.Insert(quote);\n        Session.Fire();\n\n        // Assert\n        Verify(x => x.Rule().Fired(Matched.Fact(quote)));\n        Assert.Equal(1100, quote.FinalPremium);\n    }\n    \n    public YoungDriverSurchargeRuleTest()\n    {\n        Setup.Rule<YoungDriverSurchargeRule>();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Rule Activator with Autofac - C#\nDESCRIPTION: This code snippet demonstrates how to implement a custom rule activator using Autofac, an IoC container.  The AutofacRuleActivator resolves rule types from the container's lifetime scope.  It then shows how to register rules with Autofac, create the container, set the custom activator on the RuleRepository, load rules from the assembly, and compile them into a session factory. This provides control over the instantiation process, enabling dependency injection into the rules.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fluent-rules-loading.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class AutofacRuleActivator : IRuleActivator\n{\n    private readonly ILifetimeScope _scope;\n    \n    public AutofacRuleActivator(ILifetimeScope scope)\n    {\n        _scope = scope;\n    }\n    \n    public IEnumerable<Rule> Activate(Type type)\n    {\n        yield return (Rule)_scope.Resolve(type);\n    }\n}\n\n//Build container\nvar builder = new ContainerBuilder();\nbuilder.RegisterAssemblyTypes(Assembly.GetExecutingAssembly())\n    .Where(t => t.IsAssignableTo<Rule>())\n    .AsSelf();\nvar container = builder.Build();\n\n// Load rules\nvar ruleRepository = new RuleRepository();\nruleRepository.Activator = new AutofacRuleActivator(container);\nruleRepository.Load(r => r.From(Assembly.GetExecutingAssembly()));\n\n// Compile rules\nvar factory = ruleRepository.Compile();\n```\n\n----------------------------------------\n\nTITLE: Defining a Preferred Customer Discount Rule with Yield\nDESCRIPTION: This code defines a rule that calculates and yields an instant discount for preferred customers who have placed orders totaling over $1000. It uses the `Yield` method to generate a linked fact (`InstantDiscount`). The `Yield` method automatically handles the creation, updating, and retraction of the linked fact based on the rule's activation status.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/forward-chaining.md#_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\npublic class PreferredCustomerDiscountRule : Rule\n{\n    public override void Define()\n    {\n        Customer customer = default!;\n        IEnumerable<Order> orders = default!;\n        Double total = Double.NaN;\n\n        When()\n            .Match<Customer>(() => customer, c => c.IsPreferred)\n            .Query(() => orders, x => x\n                .Match<Order>(\n                    o => o.Customer == customer,\n                    o => o.IsOpen)\n                .Collect())\n            .Let(() => total, () => orders.Sum(x => x.Amount))\n            .Having(() => total > 1000);\n\n        Then()\n            .Yield(_ => new InstantDiscount(customer, total * 0.05));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Project Structure with .NET CLI\nDESCRIPTION: This snippet shows how to create a new Visual Studio solution and project structure using the .NET CLI. It creates a solution named 'GettingStarted' and three projects: 'App' (console application), 'Domain' (class library for domain model), and 'Rules' (class library for rules). It also adds project references to establish dependencies.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ndotnet new sln -o GettingStarted\ncd GettingStarted\n\ndotnet new console -o App\ndotnet sln GettingStarted.sln add App\\App.csproj\n\ndotnet new classlib -o Domain\ndotnet sln GettingStarted.sln add Domain\\Domain.csproj\n\ndotnet new classlib -o Rules\ndotnet sln GettingStarted.sln add Rules\\Rules.csproj\n\ndotnet add App\\App.csproj reference Rules\\Rules.csproj\ndotnet add App\\App.csproj reference Domain\\Domain.csproj\ndotnet add Rules\\Rules.csproj reference Domain\\Domain.csproj\n```\n\n----------------------------------------\n\nTITLE: Defining NRules Rule with Fluent DSL - C#\nDESCRIPTION: This code defines an NRules rule using the fluent DSL. It matches a claim, patient, and insured based on certain conditions and creates a warning-level claim alert if the names of the patient and insured do not match. It uses the `Match` and `Do` verbs.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/dsl-extensions.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n[Name(\"Self insured name validation\")]\npublic class SelfInsuredNameValidationRule : Rule\n{\n    public override void Define()\n    {\n        Claim claim = default!;\n        Patient patient = default!;\n\n        When()\n            .Match<Claim>(() => claim)\n            .Match<Patient>(() => patient, p => p == claim.Patient,\n                p => p.RelationshipToInsured == Relationship.Self)\n            .Match<Insured>(i => i == claim.Insured,\n                i => !Equals(patient.Name, i.Name));\n\n        Then()\n            .Do(ctx => ctx.Warning(claim, \"Self insured name does not match\"));\n    }\n}\n\npublic static class ContextExtensions\n{\n    public static void Warning(this IContext context, Claim claim, string message)\n    {\n        var warning = new ClaimAlert { Severity = 2, Claim = claim, RuleName = context.Rule.Name, Message = message };\n        context.Insert(warning);\n    }        \n}\n```\n\n----------------------------------------\n\nTITLE: Creating Project Structure with .NET CLI (MacOS/Linux)\nDESCRIPTION: This snippet shows how to create a new Visual Studio solution and project structure using the .NET CLI on MacOS or Linux. It creates a solution named 'GettingStarted' and three projects: 'App' (console application), 'Domain' (class library for domain model), and 'Rules' (class library for rules). It also adds project references to establish dependencies.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\ndotnet new sln -o GettingStarted\ncd GettingStarted\n\ndotnet new console -o App\ndotnet sln GettingStarted.sln add App/App.csproj\n\ndotnet new classlib -o Domain\ndotnet sln GettingStarted.sln add Domain/Domain.csproj\n\ndotnet new classlib -o Rules\ndotnet sln GettingStarted.sln add Rules/Rules.csproj\n\ndotnet add App/App.csproj reference Rules/Rules.csproj\ndotnet add App/App.csproj reference Domain/Domain.csproj\ndotnet add Rules/Rules.csproj reference Domain/Domain.csproj\n```\n\n----------------------------------------\n\nTITLE: Creating Action Interceptor in NRules (C#)\nDESCRIPTION: This code snippet demonstrates how to create an action interceptor by implementing the `IActionInterceptor` interface. The interceptor logs the firing rule's name and matched facts, then executes the actions within a try-catch block to handle exceptions. The `Intercept` method receives the rule context and a collection of actions to invoke.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/action-interceptor.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class ActionInterceptor : IActionInterceptor\n{\n    public void Intercept(IContext context, IReadOnlyCollection<IActionInvocation> actions)\n    {\n        Console.WriteLine($\"Firing rule. Name={context.Rule.Name}\");\n        Console.WriteLine($\"Matched facts. Facts={string.Join(\",\", context.Match.Facts.Select(x => x.Value))}\");\n\n        try\n        {\n            foreach (var action in actions)\n            {\n                action.Invoke();\n            }\n        }\n        catch (Exception e)\n        {\n            Console.WriteLine($\"Rule execution failed. Name={context.Rule.Name} Exception={e.Message}\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Serialization with TypeResolver - C#\nDESCRIPTION: This code snippet demonstrates how to configure the TypeResolver to use aliases for known types during JSON serialization and deserialization.  This simplifies the JSON output by replacing verbose CLR type names with shorter aliases. It registers default aliases, as well as custom aliases for types like Customer, Order, IContext and Console. The configured TypeResolver is then passed to the RuleSerializer.Setup method, along with the JsonSerializerOptions, to ensure that the aliases are used during serialization and deserialization. Requires NRules.Json.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/json-serialization.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar typeResolver = new TypeResolver();\ntypeResolver.RegisterDefaultAliases();\ntypeResolver.RegisterAlias(\"Customer\", typeof(Customer));\ntypeResolver.RegisterAlias(\"Order\", typeof(Order));\ntypeResolver.RegisterAlias(\"Context\", typeof(IContext));\ntypeResolver.RegisterAlias(\"Console\", typeof(Console));\n\nRuleSerializer.Setup(options, typeResolver);\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Rules Together in C#\nDESCRIPTION: This snippet demonstrates how to test multiple rules together in the same test fixture using NRules.Testing. It registers two rules (MyRule1 and MyRule2) and verifies that each rule fires the expected number of times when a matching fact is inserted and the session is fired.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/unit-testing-rules.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class MyRuleTest : RulesTestFixture\n{\n    public MyRuleTest()\n    {\n        Setup.Rule<MyRule1>();\n        Setup.Rule<MyRule2>();\n    }\n    \n    [Fact]\n    public void Fire_InsertedOneMatchingFact_FiredBothRules()\n    {\n        //Arrange\n        var fact = new MyFact();\n        Session.Insert(fact);\n\n        //Act\n        Session.Fire();\n\n        //Assert\n        Verify(x =>\n        {\n            x.Rule<MyRule1>().Fired(Times.Once);\n            x.Rule<MyRule2>().Fired(Times.Twice);\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing the Custom Rule in C#\nDESCRIPTION: This code snippet demonstrates how to test the custom rule that was built. It creates an instance of the custom rule repository, loads the rules, compiles them into a session factory, and then creates a session. It inserts facts into the session (customer and orders) and fires the rules, which triggers the action if the conditions are met.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/rule-builder.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar repository = new CustomRuleRepository();\nrepository.LoadRules();\nISessionFactory factory = repository.Compile();\n\nISession session = factory.CreateSession();\nvar customer = new Customer(\"John Do\");\nsession.Insert(customer);\nsession.Insert(new Order(customer, 90.00m));\nsession.Insert(new Order(customer, 110.00m));\n\nsession.Fire();\n```\n\n----------------------------------------\n\nTITLE: Compiling Rules after Loading - C#\nDESCRIPTION: This code snippet shows how to compile a subset of rule sets after loading them into a RuleRepository. It retrieves the rule sets and then compiles the rule set named \"MyRuleSet\" into an executable session factory using RuleCompiler. The resulting ISessionFactory can then be used to create sessions and execute the rules.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fluent-rules-loading.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar ruleSets = repository.GetRuleSets();\nvar compiler = new RuleCompiler();\nISessionFactory factory = compiler.Compile(ruleSets.Where(x => x.Name == \"MyRuleSet\"));\n```\n\n----------------------------------------\n\nTITLE: Creating TrafficViolation Domain Model\nDESCRIPTION: This C# snippet defines a `TrafficViolation` class with properties for the driver, date, and violation type.  It represents a traffic violation event, which are facts used in the NRules rules engine.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\npublic class TrafficViolation(Driver driver, DateTime date, string violationType)\n{\n    public Driver Driver { get; } = driver;\n    public DateTime Date { get; } = date;\n    public string ViolationType { get; } = violationType;\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Rule Firing Event in NRules (C#)\nDESCRIPTION: This code snippet demonstrates how to subscribe to the RuleFiringEvent in NRules to receive notifications before a rule's actions are executed. It shows how to access the Events property on the ISession interface and attach an event handler to the RuleFiringEvent. The event handler then prints the name of the rule that is about to fire to the console.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/diagnostics.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nISession session = factory.CreateSession();\nsession.Events.RuleFiringEvent += OnRuleFiringEvent;\n\n//...\n\nprivate static void OnRuleFiringEvent(object sender, AgendaEventArgs e)\n{\n    Console.WriteLine(\"Rule about to fire {0}\", e.Rule.Name);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Domain Model in C#\nDESCRIPTION: This code snippet defines a simple domain model consisting of Customer and Order classes. These classes are used in the example rule to demonstrate how to access fact properties and create rule conditions. The classes have basic properties like Name, Amount, and Customer.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/rule-builder.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class Customer\n{\n    public Customer(string name)\n    {\n        Name = name;\n    }\n\n    public string Name { get; private set; }\n}\n\npublic class Order\n{\n    public Order(Customer customer, decimal amount)\n    {\n        Customer = customer;\n        Amount = amount;\n    }\n\n    public Customer Customer { get; private set; }\n    public decimal Amount { get; private set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Rules from Assembly with Filtering - C#\nDESCRIPTION: This code snippet demonstrates how to load rules from the executing assembly into a RuleRepository, filtering them by name and tag. It loads rules whose name starts with \"Test\" or are tagged with the \"Test\" tag, into a rule set named \"MyRuleSet\". It shows the usage of the RuleRepository.Load method with a fluent specification.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fluent-rules-loading.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvar repository = new RuleRepository();\nrepository.Load(x => x\n    .From(Assembly.GetExecutingAssembly())\n    .Where(rule => rule.Name.StartsWith(\"Test\") || rule.IsTagged(\"Test\"))\n    .To(\"MyRuleSet\"));\n```\n\n----------------------------------------\n\nTITLE: Using Custom Expression Compiler for Rules Compilation in C#\nDESCRIPTION: This code snippet shows how to integrate the custom expression compiler (in this case, FastExpressionCompiler) into the NRules compilation process. It instantiates a RuleRepository, loads rules, creates a RuleCompiler, assigns the custom expression compiler to the RuleCompiler's ExpressionCompiler property, and then compiles the rules.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/expression-compiler.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar repository = new RuleRepository();\n//Load rules\n\nvar compiler = new RuleCompiler();\ncompiler.ExpressionCompiler = new FastExpressionCompiler();\nvar factory = compiler.Compile(repository.GetRuleSets());\n```\n\n----------------------------------------\n\nTITLE: Installing NRules Packages\nDESCRIPTION: This snippet shows how to add NRules package references to the corresponding projects using the .NET CLI.  The 'App' project references the 'NRules' metapackage. The 'Rules' project references the 'NRules.Fluent' package for rule definition.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\ndotnet add App\\App.csproj package NRules\ndotnet add Rules\\Rules.csproj package NRules.Fluent\n```\n\n----------------------------------------\n\nTITLE: Defining NRules DSL Extension Methods - C#\nDESCRIPTION: This code defines DSL extension methods for NRules to create custom verbs like `Claim`, `Patient`, `Insured`, and `Warning`. These extensions simplify rule definitions by encapsulating complex matching logic and actions. The `Claim`, `Patient` extension methods extend `ILeftHandSideExpression` to add matching capabilities, and the `Warning` extension method extends `IRightHandSideExpression` to add actions.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/dsl-extensions.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic static class DslExtensions\n{\n    public static ILeftHandSideExpression Claim(this ILeftHandSideExpression lhs, Expression<Func<Claim>> alias, params Expression<Func<Claim, bool>>[] conditions)\n    {\n        return lhs.Match(alias, conditions);\n    }\n\n    public static ILeftHandSideExpression Patient(this ILeftHandSideExpression lhs, Expression<Func<Patient>> alias, params Expression<Func<Patient, bool>>[] conditions)\n    {\n        return lhs.Match(alias, conditions);\n    }\n\n    public static ILeftHandSideExpression Insured(this ILeftHandSideExpression lhs, params Expression<Func<Insured, bool>>[] conditions)\n    {\n        return lhs.Match(conditions);\n    }\n\n    public static IRightHandSideExpression Warning(this IRightHandSideExpression rhs, Claim claim, string message)\n    {\n        return rhs.Do(ctx => ctx.Warning(claim, message));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing NRules Packages (MacOS/Linux)\nDESCRIPTION: This snippet shows how to add NRules package references to the corresponding projects using the .NET CLI on MacOS or Linux. The 'App' project references the 'NRules' metapackage. The 'Rules' project references the 'NRules.Fluent' package for rule definition.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\ndotnet add App/App.csproj package NRules\ndotnet add Rules/Rules.csproj package NRules.Fluent\n```\n\n----------------------------------------\n\nTITLE: Using Action Interceptor with NRules Session (C#)\nDESCRIPTION: This code snippet shows how to use the created action interceptor with a rules session. It creates a session from the session factory and assigns a new instance of the `ActionInterceptor` to the `ActionInterceptor` property of the session. This allows the interceptor to be invoked when rules are fired within the session.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/action-interceptor.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nvar session = factory.CreateSession();\nsession.ActionInterceptor = new ActionInterceptor();\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Asserter for xUnit in C#\nDESCRIPTION: This code defines a custom asserter for xUnit that implements the IRuleAsserter interface. It uses XunitException to throw exceptions when rule assertions fail, tailoring the assertion mechanism to the xUnit framework. Requires NRules.Testing and xunit.assert NuGet packages.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/unit-testing-rules.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nusing NRules.Testing;\nusing Xunit.Sdk;\n\npublic class XUnitRuleAsserter : IRuleAsserter\n{\n    public void Assert(RuleAssertResult result)\n    {\n        if (result.Status == RuleAssertStatus.Failed)\n        {\n            throw new XunitException(result.GetMessage());\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Rules Session in C#\nDESCRIPTION: This code snippet shows how to update the rules session using the FactType defined with IIdentityProvider. The Update method will correctly replace the existing fact with the same Id, even if the TestProperty is different.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fact-equality-and-identity.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nSession.Insert(new FactType(1, \"Original Value\"));\nSession.Update(new FactType(1, \"New Value\"));\n```\n\n----------------------------------------\n\nTITLE: Implementing IIdentityProvider in C#\nDESCRIPTION: This code snippet demonstrates how to implement the IIdentityProvider interface in a C# record type. The GetIdentity() method returns the value that will be used to compare the identity of facts of this type. This allows NRules to correctly update facts based on their identity rather than full equality.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fact-equality-and-identity.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic record FactType(int Id, string TestProperty) : IIdentityProvider\n{\n    public object GetIdentity() => Id;\n}\n```\n\n----------------------------------------\n\nTITLE: Install NRules package using dotnet CLI\nDESCRIPTION: This command installs the NRules package using the .NET CLI. It adds the NRules package as a dependency to your project.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/index.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n> dotnet add package NRules\n```\n\n----------------------------------------\n\nTITLE: Implementing IExpressionCompiler with FastExpressionCompiler in C#\nDESCRIPTION: This snippet demonstrates how to implement the NRules.Extensibility.IExpressionCompiler interface using FastExpressionCompiler.  It defines a class FastExpressionCompiler which takes an Expression<TDelegate> as input and compiles it using the CompileFast() method from FastExpressionCompiler. This enables faster compilation of expressions within NRules.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/expression-compiler.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nusing FastExpressionCompiler;\n\npublic class FastExpressionCompiler : NRules.Extensibility.IExpressionCompiler\n{\n    public TDelegate Compile<TDelegate>(Expression<TDelegate> expression) where TDelegate : Delegate\n    {\n        return expression.CompileFast();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Rule Repository in C#\nDESCRIPTION: This code snippet demonstrates how to implement the IRuleRepository interface to create a custom rule repository. The repository stores rules in a rule set and provides a method to load rules from a user-defined source. It includes a placeholder method for building the rule definition.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/advanced/rule-builder.md#_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic class CustomRuleRepository : IRuleRepository\n{\n    private readonly IRuleSet _ruleSet = new RuleSet(\"MyRuleSet\");\n\n    public IEnumerable<IRuleSet> GetRuleSets()\n    {\n        return new[] {_ruleSet};\n    }\n\n    public void LoadRules()\n    {\n        //Assuming there is only one rule in this example\n        var rule = BuildRule();\n        _ruleSet.Add(new []{rule});\n    }\n\n    private IRuleDefinition BuildRule()\n    {\n        //...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom IEqualityComparer Implementation in C#\nDESCRIPTION: This code snippet provides an example of a custom IEqualityComparer<FactType> implementation. It overrides the Equals and GetHashCode methods to compare FactType objects based on their Id property.  This is registered with the NRules compiler to be used for comparing facts of type FactType.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fact-equality-and-identity.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class FactTypeIdentityComparer : IEqualityComparer<FactType>\n{\n    public bool Equals(FactType? obj1, FactType? obj2)\n    {\n        return obj1!.Id == obj2!.Id;\n    }\n\n    public int GetHashCode(FactType obj)\n    {\n        return obj.Id;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Custom IEqualityComparer in C#\nDESCRIPTION: This code snippet demonstrates how to register a custom IEqualityComparer with the NRules compiler.  The FactIdentityComparerRegistry is used to associate the comparer with the FactType. This allows NRules to use the custom comparer when comparing facts of that type.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fact-equality-and-identity.md#_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nvar compiler = new RuleCompiler();\ncompiler.FactIdentityComparerRegistry.RegisterComparer(new FactTypeIdentityComparer());\n```\n\n----------------------------------------\n\nTITLE: Custom Default Identity Comparer Implementation in C#\nDESCRIPTION: This code snippet defines a custom default identity comparer for NRules.  It checks if the objects implement a custom interface `IMyIdentityProvider` and compares them based on the value returned by `GetIdentity`.  If not, it falls back to the default equality comparison.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fact-equality-and-identity.md#_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IMyIdentityProvider\n{\n    int GetIdentity();\n}\n\ninternal class MyDefaultFactIdentityComparer : IEqualityComparer<object>\n{\n    bool IEqualityComparer<object>.Equals(object? obj1, object? obj2)\n    {\n        if (obj1 is IMyIdentityProvider provider1 && obj2 is IMyIdentityProvider provider2)\n            return provider1.GetIdentity() == provider2.GetIdentity();\n\n        return Equals(obj1, obj2);\n    }\n\n    int IEqualityComparer<object>.GetHashCode(object obj)\n    {\n        if (obj is IMyIdentityProvider provider)\n            return provider.GetIdentity();\n\n        return obj.GetHashCode();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Build NRules on Windows\nDESCRIPTION: This command executes the build script on Windows using PowerShell. It builds the NRules project with specified target and component.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/index.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n> .\\build.bat [Target] [Component]\n```\n\n----------------------------------------\n\nTITLE: Disabled Rule Filter C#\nDESCRIPTION: This C# code defines an agenda filter that disables rules tagged with \"Disabled\". It implements the IAgendaFilter interface and checks the rule's tags in the Accept method.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/agenda-filters.md#_snippet_1\n\nLANGUAGE: c#\nCODE:\n```\npublic class DisabledRuleFilter : IAgendaFilter\n{\n    public bool Accept(Activation activation)\n    {\n        if (activation.Rule.Tags.Contains(\"Disabled\")) return false;\n        return true;\n    }\n}\n\n//...\n\nvar filter = new DisabledRuleFilter();\nvar session = factory.CreateSession(x =>\n    x.Agenda.AddFilter(filter));\n```\n\n----------------------------------------\n\nTITLE: Build NRules on MacOS/Linux\nDESCRIPTION: This command executes the build script on MacOS/Linux. It builds the NRules project with specified target and component. Requires bash.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/index.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n> ./build.sh [Target] [Component]\n```\n\n----------------------------------------\n\nTITLE: Integrating NRules with Autofac IoC Container (C#)\nDESCRIPTION: This C# code snippet illustrates how to integrate NRules with the Autofac IoC container using the NRules.Integration.Autofac package. It demonstrates registering rules, a rule repository, a session factory, and a session with the Autofac container. Registration extensions return registration builders that allow customization of individual registrations.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/rule-dependencies.md#_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\nvar types = builder.RegisterRules(x => x.AssemblyOf(typeof(MyRule)));\nbuilder.RegisterRepository(r => r.Load(x => x.From(types)));\nbuilder.RegisterSessionFactory();\nbuilder.RegisterSession();\n```\n\n----------------------------------------\n\nTITLE: Setting the Custom Asserter in Base Test Fixture in C#\nDESCRIPTION: This code shows how to create a base test fixture that sets the custom asserter (XUnitRuleAsserter) for all rule tests. By setting the Asserter property in the constructor of the base fixture, all derived test fixtures will use the custom assertion mechanism. Requires NRules.Testing.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/unit-testing-rules.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nusing NRules.Testing;\n\npublic abstract class BaseRulesTestFixture : RulesTestFixture\n{\n    protected BaseRulesTestFixture()\n    {\n        Asserter = new XUnitRuleAsserter();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Performance Metrics in NRules (C#)\nDESCRIPTION: This code snippet demonstrates how to access and utilize performance metrics in NRules. It retrieves the Rete graph from the session, finds a specific node by type (BetaMemory), and then accesses the metrics for that node to calculate and print the total time spent in the node. This shows how to use the IMetricsProvider and INodeMetrics interfaces to profile rule performance.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/diagnostics.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nReteGraph reteGraph = session.GetSchema();\nReteNode node = reteGraph.Nodes.First(n => n.NodeType == NodeType.BetaMemory);\nINodeMetrics nodeMetrics = session.Metrics.FindByNodeId(node.Id);\nlong totalTimeSpentMsec = nodeMetrics.InsertDurationMilliseconds +\n                          nodeMetrics.UpdateDurationMilliseconds +\n                          nodeMetrics.RetractDurationMilliseconds;\nConsole.WriteLine($\"Node {node.Id}:{node.NodeType}. ElementCount={nodeMetrics.ElementCount}, TotalTimeSpentMsec={totalTimeSpentMsec}\");\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Default Identity Comparer in C#\nDESCRIPTION: This code snippet shows how to register the custom default identity comparer with the NRules compiler.  This overrides the default behavior of NRules and uses the provided comparer for all fact types unless a specific comparer is registered for that fact type.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/fact-equality-and-identity.md#_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nvar compiler = new RuleCompiler();\ncompiler.FactIdentityComparerRegistry.DefaultFactIdentityComparer = new MyDefaultFactIdentityComparer();\n```\n\n----------------------------------------\n\nTITLE: Resetting Performance Metrics in NRules (C#)\nDESCRIPTION: This code snippet shows how to reset the cumulative performance metrics for the current session in NRules. It calls the Reset() method on the IMetricsProvider accessible through the Metrics property on the ISession interface. This allows for isolating performance measurements to specific sections of the rules execution cycle.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/diagnostics.md#_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nsession.Metrics.Reset();\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring Test Project - MacOS/Linux\nDESCRIPTION: These commands create a new .NET class library project for tests, add it to the solution, add project references, and add necessary NuGet packages for testing NRules rules on MacOS/Linux. It includes packages for testing and xUnit.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_12\n\nLANGUAGE: console\nCODE:\n```\ndotnet new classlib -o Rules.Tests\ndotnet sln GettingStarted.sln add Rules.Tests/Rules.Tests.csproj\ndotnet add Rules.Tests/Rules.Tests.csproj reference Rules/Rules.csproj\ndotnet add Rules.Tests/Rules.Tests.csproj package Microsoft.NET.Test.Sdk\ndotnet add Rules.Tests/Rules.Tests.csproj package NRules.Testing\ndotnet add Rules.Tests/Rules.Tests.csproj package xunit\ndotnet add Rules.Tests/Rules.Tests.csproj package xunit.runner.visualstudio\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring Test Project - Windows\nDESCRIPTION: These commands create a new .NET class library project for tests, add it to the solution, add project references, and add necessary NuGet packages for testing NRules rules on Windows.  It includes packages for testing and xUnit.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/getting-started.md#_snippet_11\n\nLANGUAGE: console\nCODE:\n```\ndotnet new classlib -o Rules.Tests\ndotnet sln GettingStarted.sln add Rules.Tests\\Rules.Tests.csproj\ndotnet add Rules.Tests\\Rules.Tests.csproj reference Rules\\Rules.csproj\ndotnet add Rules.Tests\\Rules.Tests.csproj package Microsoft.NET.Test.Sdk\ndotnet add Rules.Tests\\Rules.Tests.csproj package NRules.Testing\ndotnet add Rules.Tests\\Rules.Tests.csproj package xunit\ndotnet add Rules.Tests\\Rules.Tests.csproj package xunit.runner.visualstudio\n```\n\n----------------------------------------\n\nTITLE: Install NRules package using Package Manager\nDESCRIPTION: This command installs the NRules package using the Package Manager Console in Visual Studio. It adds the NRules package as a dependency to your project.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/index.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n> Install-Package NRules\n```\n\n----------------------------------------\n\nTITLE: Installing NRules Package via NuGet\nDESCRIPTION: This command installs the NRules package from NuGet using the package manager console. It is a prerequisite for using NRules in a .NET project. The command fetches the latest version of the NRules package and adds it as a dependency to the project.\nSOURCE: https://github.com/nrules/nrules/blob/develop/README.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\n> Install-Package NRules\n```\n\n----------------------------------------\n\nTITLE: Building NRules Visualizer (console)\nDESCRIPTION: This code snippet shows how to build the NRules debugger visualizer using the build.bat script. First builds the core NRules library and then builds the visualizer project.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/diagnostics.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\nbuild.bat\n```\n\n----------------------------------------\n\nTITLE: Building NRules Visualizer specifically (console)\nDESCRIPTION: This code snippet shows how to specifically build the NRules debugger visualizer using the build.bat script.\nSOURCE: https://github.com/nrules/nrules/blob/develop/docs/articles/diagnostics.md#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\nbuild.bat Build Visualizer\n```"
  }
]