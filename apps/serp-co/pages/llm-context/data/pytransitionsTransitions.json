[
  {
    "owner": "pytransitions",
    "repo": "transitions",
    "content": "TITLE: Integrating PyTransitions state machine with Django models in Python\nDESCRIPTION: Provides an example of integrating PyTransitions state machines into Django ORM models by defining a Django model with a state field and connecting a state machine in a post_init signal receiver. The state machine's states are derived from model choices, and transitions are added dynamically. This approach allows state machines to work with Django's lifecycle and database persistence. Dependencies include Django and PyTransitions. Key parameters include the CharField 'state' storing the current state and Machine instance attached to the model instance.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom django.db import models\nfrom django.db.models.signals import post_init\nfrom django.dispatch import receiver\nfrom django.utils.translation import ugettext_lazy as _\nfrom transitions import Machine\n\n\nclass ModelWithState(models.Model):\n    ASLEEP = 'asleep'\n    HANGING_OUT = 'hanging out'\n    HUNGRY = 'hungry'\n    SWEATY = 'sweaty'\n    SAVING_THE_WORLD = 'saving the world'\n    STATE_TYPES = [\n        (ASLEEP, _('asleep')),\n        (HANGING_OUT, _('hanging out')),\n        (HUNGRY, _('hungry')),\n        (SWEATY, _('sweaty')),\n        (SAVING_THE_WORLD, _('saving the world')),\n    ]\n    state = models.CharField(\n        _('state'),\n        max_length=100,\n        choices=STATE_TYPES,\n        default=ASLEEP,\n        help_text=_('actual state'),\n    )\n\n\n@receiver(post_init, sender=ModelWithState)\ndef init_state_machine(instance, **kwargs):\n\n    states = [state for state, _ in instance.STATE_TYPES]\n    machine = instance.machine = Machine(model=instance, states=states, initial=instance.state)\n    machine.add_transition('work_out', instance.HANGING_OUT, instance.HUNGRY)\n    machine.add_transition('eat', instance.HUNGRY, instance.HANGING_OUT)\n\n```\n\n----------------------------------------\n\nTITLE: Interacting with a `transitions` State Machine in Python (Quickstart)\nDESCRIPTION: Illustrates how to use the previously defined `NarcolepticSuperhero` state machine. It shows instantiating the object, checking the initial state (`batman.state`), triggering transitions via automatically generated methods (`batman.wake_up()`, `batman.nap()`, etc.), observing state changes, seeing the effect of callbacks (checking `batman.kittens_rescued`), and handling invalid transitions which raise a `MachineError`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> batman = NarcolepticSuperhero(\"Batman\")\n>>> batman.state\n'asleep'\n\n>>> batman.wake_up()\n>>> batman.state\n'hanging out'\n\n>>> batman.nap()\n>>> batman.state\n'asleep'\n\n>>> batman.clean_up()\nMachineError: \"Can't trigger event clean_up from state asleep!\"\n\n>>> batman.wake_up()\n>>> batman.work_out()\n>>> batman.state\n'hungry'\n\n# Batman still hasn't done anything useful...\n>>> batman.kittens_rescued\n0\n\n# We now take you live to the scene of a horrific kitten entreement...\n>>> batman.distress_call()\n'Beauty, eh?'\n>>> batman.state\n'saving the world'\n\n# Back to the crib.\n>>> batman.complete_mission()\n>>> batman.state\n'sweaty'\n\n>>> batman.clean_up()\n>>> batman.state\n'asleep'   # Too tired to shower!\n\n# Another productive day, Alfred.\n>>> batman.kittens_rescued\n1\n```\n\n----------------------------------------\n\nTITLE: Defining States and Transitions with transitions Machine - Python\nDESCRIPTION: This snippet demonstrates initializing a state machine by defining states as strings, specifying a list of transitions, and assigning an initial state. The Machine object attaches dynamic trigger methods to the model instance for state changes. Dependencies: 'transitions' package. Parameters include the model object, the list of state names, a transition dictionary with 'trigger', 'source', and 'dest', and the initial state. Input: events or method calls corresponding to triggers. Output: updated model state with accessible convenience methods. The snippet omits inverse transitions and focuses on unidirectional changes.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n# The states\nstates=['solid', 'liquid', 'gas', 'plasma']\n\n# And some transitions between states. We're lazy, so we'll leave out\n# the inverse phase transitions (freezing, condensation, etc.).\ntransitions = [\n    { 'trigger': 'melt', 'source': 'solid', 'dest': 'liquid' },\n    { 'trigger': 'evaporate', 'source': 'liquid', 'dest': 'gas' },\n    { 'trigger': 'sublimate', 'source': 'solid', 'dest': 'gas' },\n    { 'trigger': 'ionize', 'source': 'gas', 'dest': 'plasma' }\n]\n\n# Initialize\nmachine = Machine(lump, states=states, transitions=transitions, initial='liquid')\n\n# Now lump maintains state...\nlump.state\n>>> 'liquid'\n\n# And that state can change...\n# Either calling the shiny new trigger methods\nlump.evaporate()\nlump.state\n>>> 'gas'\n\n# Or by calling the trigger method directly\nlump.trigger('ionize')\nlump.state\n>>> 'plasma'\n```\n\n----------------------------------------\n\nTITLE: Defining a State Machine with `transitions` in Python (Quickstart)\nDESCRIPTION: Demonstrates defining a Python class (`NarcolepticSuperhero`) that incorporates a state machine using the `transitions` library. It initializes the `Machine` with states and an initial state, adds various transitions with triggers, sources, destinations, callbacks (`before`, `after`), and conditions (`conditions`). Callback methods (`update_journal`, `change_into_super_secret_costume`) and a conditional property (`is_exhausted`) are also defined within the class.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom transitions import Machine\nimport random\n\nclass NarcolepticSuperhero(object):\n\n    # Define some states. Most of the time, narcoleptic superheroes are just like\n    # everyone else. Except for...\n    states = ['asleep', 'hanging out', 'hungry', 'sweaty', 'saving the world']\n\n    def __init__(self, name):\n\n        # No anonymous superheroes on my watch! Every narcoleptic superhero gets\n        # a name. Any name at all. SleepyMan. SlumberGirl. You get the idea.\n        self.name = name\n\n        # What have we accomplished today?\n        self.kittens_rescued = 0\n\n        # Initialize the state machine\n        self.machine = Machine(model=self, states=NarcolepticSuperhero.states, initial='asleep')\n\n        # Add some transitions. We could also define these using a static list of\n        # dictionaries, as we did with states above, and then pass the list to\n        # the Machine initializer as the transitions= argument.\n\n        # At some point, every superhero must rise and shine.\n        self.machine.add_transition(trigger='wake_up', source='asleep', dest='hanging out')\n\n        # Superheroes need to keep in shape.\n        self.machine.add_transition('work_out', 'hanging out', 'hungry')\n\n        # Those calories won't replenish themselves!\n        self.machine.add_transition('eat', 'hungry', 'hanging out')\n\n        # Superheroes are always on call. ALWAYS. But they're not always\n        # dressed in work-appropriate clothing.\n        self.machine.add_transition('distress_call', '*', 'saving the world',\n                         before='change_into_super_secret_costume')\n\n        # When they get off work, they're all sweaty and disgusting. But before\n        # they do anything else, they have to meticulously log their latest\n        # escapades. Because the legal department says so.\n        self.machine.add_transition('complete_mission', 'saving the world', 'sweaty',\n                         after='update_journal')\n\n        # Sweat is a disorder that can be remedied with water.\n        # Unless you've had a particularly long day, in which case... bed time!\n        self.machine.add_transition('clean_up', 'sweaty', 'asleep', conditions=['is_exhausted'])\n        self.machine.add_transition('clean_up', 'sweaty', 'hanging out')\n\n        # Our NarcolepticSuperhero can fall asleep at pretty much any time.\n        self.machine.add_transition('nap', '*', 'asleep')\n\n    def update_journal(self):\n        \"\"\" Dear Diary, today I saved Mr. Whiskers. Again. \"\"\"\n        self.kittens_rescued += 1\n\n    @property\n    def is_exhausted(self):\n        \"\"\" Basically a coin toss. \"\"\"\n        return random.random() < 0.5\n\n    def change_into_super_secret_costume(self):\n        print(\"Beauty, eh?\")\n```\n\n----------------------------------------\n\nTITLE: Adding and Using Callbacks with States in transitions Machine - Python\nDESCRIPTION: This snippet illustrates assigning enter and exit callbacks to states via the State constructor, dictionary properties, and dynamically after initialization. It demonstrates that callbacks like 'on_exit' and 'on_enter' can be bound either during initialization or dynamically to ensure actions execute on state transitions. Dependencies: 'transitions' library, model methods matching the callback names. Parameters: State objects with 'on_exit' or 'on_enter' lists, model methods, Machine and model instances. Input: callback function names; output: triggered side effects during state transitions. Constraints: Initial state does not invoke on_enter callback until re-entered.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n# Our old Matter class, now with  a couple of new methods we\n# can trigger when entering or exit states.\nclass Matter(object):\n    def say_hello(self): print(\"hello, new state!\")\n    def say_goodbye(self): print(\"goodbye, old state!\")\n\nlump = Matter()\n\n# Same states as above, but now we give StateA an exit callback\nstates = [\n    State(name='solid', on_exit=['say_goodbye']),\n    'liquid',\n    { 'name': 'gas', 'on_exit': ['say_goodbye']}\n    ]\n\nmachine = Machine(lump, states=states)\nmachine.add_transition('sublimate', 'solid', 'gas')\n\n# Callbacks can also be added after initialization using\n# the dynamically added on_enter_ and on_exit_ methods.\n# Note that the initial call to add the callback is made\n# on the Machine and not on the model.\nmachine.on_enter_gas('say_hello')\n\n# Test out the callbacks...\nmachine.set_state('solid')\nlump.sublimate()\n>>> 'goodbye, old state!'\n>>> 'hello, new state!'\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic State Machine with Python Transitions\nDESCRIPTION: Creates a narcoleptic superhero class using the transitions library to manage state transitions. The superhero can perform actions like waking up, working out, and rescuing kittens based on defined states and transitions.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Playground.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine\nimport random\n\nclass NarcolepticSuperhero(object):\n\n    # Define some states. Most of the time, narcoleptic superheroes are just like\n    # everyone else. Except for...\n    states = ['asleep', 'hanging out', 'hungry', 'sweaty', 'saving the world']\n    # A more compact version of the quickstart transitions\n    transitions = [['wakeup', 'asleep', 'hanging out'],\n                   ['work_out',  'hanging out', 'hungry'],\n                   ['eat', 'hungry', 'hanging out'],\n                   {'trigger': 'distress_call', 'source': '*', 'dest':  'saving the world', 'before': 'change_into_super_secret_costume'},\n                   {'trigger': 'complete_mission', 'source': 'saving the world', 'dest':  'sweaty', 'after': 'update_journal'},\n                   {'trigger': 'clean_up', 'source': 'sweaty', 'dest':  'asleep', 'conditions': 'is_exhausted'},\n                   ['clean_up', 'sweaty', 'hanging out'],\n                   ['nap', '*', 'asleep']]\n\n\n    def __init__(self, name):\n\n        # No anonymous superheroes on my watch! Every narcoleptic superhero gets\n        # a name. Any name at all. SleepyMan. SlumberGirl. You get the idea.\n        self.name = name\n        self.kittens_rescued = 0  # What have we accomplished today?\n\n        # Initialize the state machine\n        self.machine = Machine(model=self, states=NarcolepticSuperhero.states,\n                               transitions=NarcolepticSuperhero.transitions, initial='asleep')\n\n    def update_journal(self):\n        \"\"\" Dear Diary, today I saved Mr. Whiskers. Again. \"\"\"\n        self.kittens_rescued += 1\n\n    @property\n    def is_exhausted(self):\n        \"\"\" Basically a coin toss. \"\"\"\n        return random.random() < 0.5\n\n    def change_into_super_secret_costume(self):\n        print(\"Beauty, eh?\")\n        \n    def yell(self):\n        print(f\"I am {self.name} and I am {self.state}!\")\n        \nbatman = NarcolepticSuperhero(\"Batman\")\nbatman.wakeup()\nassert batman.state == 'hanging out'\nbatman.yell()\n#  the rest is up to you ...\n```\n\n----------------------------------------\n\nTITLE: Loading state machine configuration with PyTransitions using JSON in Python\nDESCRIPTION: Demonstrates how to load a state machine configuration from a JSON string matching the Machine constructor's required structure. Shows defining states, transitions, and an initial state within the JSON; loading it with Python's json module; injecting a model instance; and initializing a Machine using unpacked JSON parameters. The example includes a custom model method used as an on_enter callback and illustrates validating state transitions and triggering callbacks. Dependencies include PyTransitions and Python's built-in json module.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine\nimport json\n\n\nclass Model:\n\n    def say_hello(self, name):\n        print(f\"Hello {name}!\")\n\n\n# import json\njson_config = \"\"\"\n{\n  \"name\": \"MyMachine\",\n  \"states\": [\n    \"A\",\n    \"B\",\n    { \"name\": \"C\", \"on_enter\": \"say_hello\" }\n  ],\n  \"transitions\": [\n    [\"go\", \"A\", \"B\"],\n    {\"trigger\": \"hello\", \"source\": \"*\", \"dest\": \"C\"}\n  ],\n  \"initial\": \"A\"\n}\n\"\"\"\n\nmodel = Model()\n\nconfig = json.loads(json_config)\nconfig['model'] = model  # adding a model to the configuration\nm = Machine(**config)  # **config unpacks arguments as kwargs\nassert model.is_A()\nmodel.go()\nassert model.is_B()\nmodel.hello(\"world\")  # >>> Hello world!\nassert model.state == 'C'\n\n```\n\n----------------------------------------\n\nTITLE: Initializing `transitions.Machine` with an External Model in Python\nDESCRIPTION: Demonstrates the basic initialization of a `transitions.Machine` by passing an existing object (`lump`) as the `model`. The machine is configured with a list of states and an initial state. After initialization, the model object (`lump`) gains a `state` attribute managed by the machine.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfrom transitions import Machine\nmachine = Machine(model=lump, states=['solid', 'liquid', 'gas', 'plasma'], initial='solid')\n\n# Lump now has a new state attribute!\nlump.state\n>>> 'solid'\n```\n\n----------------------------------------\n\nTITLE: Adding Transitions with Multiple Source States or Wildcard Sources in Python 'transitions' Library\nDESCRIPTION: Demonstrates attaching a single trigger to multiple source states simultaneously using lists, allowing one trigger to handle different transitions based on the current state. Also covers the use of the '*' wildcard to create transitions from all existing states at the time of definition. The snippet explains that only the first matching transition will execute when multiple are defined for the same trigger.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nmachine.add_transition('transmogrify', ['solid', 'liquid', 'gas'], 'plasma')\nmachine.add_transition('transmogrify', 'plasma', 'solid')\n# This next transition will never execute\nmachine.add_transition('transmogrify', 'plasma', 'gas')\n\n# wildcard example\nmachine.add_transition('to_liquid', '*', 'liquid')\n```\n\n----------------------------------------\n\nTITLE: Suppressing Exceptions on Invalid Triggers in Python 'transitions' Library\nDESCRIPTION: Demonstrates how to configure a state machine to silently ignore invalid trigger attempts by setting 'ignore_invalid_triggers=True' either globally on the machine, for specific states, or groups of states. This behavior adjustment prevents exceptions and allows transitions to fail quietly. The snippet also notes that the global setting might not override already-initialized states.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> # Globally suppress invalid trigger exceptions\n>>> m = Machine(lump, states, initial='solid', ignore_invalid_triggers=True)\n>>> # ...or suppress for only one group of states\n>>> states = ['new_state1', 'new_state2']\n>>> m.add_states(states, ignore_invalid_triggers=True)\n>>> # ...or even just for a single state. Here, exceptions will only be suppressed when the current state is A.\n>>> states = [State('A', ignore_invalid_triggers=True), 'B', 'C']\n>>> m = Machine(lump, states)\n>>> # ...this can be inverted as well if just one state should raise an exception\n>>> # since the machine's global value is not applied to a previously initialized state.\n>>> states = ['A', 'B', State('C')] # the default value for 'ignore_invalid_triggers' is False\n>>> m = Machine(lump, states, ignore_invalid_triggers=True)\n```\n\n----------------------------------------\n\nTITLE: Defining Internal Transitions That Do Not Change State in Python 'transitions' Library\nDESCRIPTION: Illustrates how to specify internal transitions that keep the current state intact by setting the transition's destination to None. Such transitions execute transition callbacks like 'before' and 'after' but do not trigger state exit or entry callbacks. Useful for side-effects or actions within a state without causing a state change.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nmachine.add_transition('internal', ['liquid', 'gas'], None, after='change_shape')\n```\n\n----------------------------------------\n\nTITLE: Defining State Transitions Using Dictionaries with Transitions Library in Python\nDESCRIPTION: Illustrates the creation of a list of transition definitions as dictionaries mapping triggers, source states, and destination states. This format enhances readability and explicitness when initializing a 'Machine' instance with states, transitions, and optional models. The snippet requires a defined 'states' list and an appropriate model class instance, e.g., 'Matter()'. This pattern aids in clear transition definition but can be verbose.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ntransitions = [\n    { 'trigger': 'melt', 'source': 'solid', 'dest': 'liquid' },\n    { 'trigger': 'evaporate', 'source': 'liquid', 'dest': 'gas' },\n    { 'trigger': 'sublimate', 'source': 'solid', 'dest': 'gas' },\n    { 'trigger': 'ionize', 'source': 'gas', 'dest': 'plasma' }\n]\nmachine = Machine(model=Matter(), states=states, transitions=transitions)\n```\n\n----------------------------------------\n\nTITLE: Passing Data to Conditional Transition Checks in pytransitions (Python)\nDESCRIPTION: Illustrates how keyword arguments passed to a trigger method (e.g., `lump.heat(temp=74)`, equivalent to `lump.trigger('heat', temp=74)`) in `pytransitions` are automatically passed to the associated condition-checking methods (like `is_flammable` or `is_really_hot`). This allows conditions to be evaluated based on runtime data provided during the trigger call.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nlump.heat(temp=74)\n# equivalent to lump.trigger('heat', temp=74)\n```\n\n----------------------------------------\n\nTITLE: Triggering Transitions via Auto-Attached Model Methods in Python 'transitions' Library\nDESCRIPTION: Illustrates triggering state transitions by calling dynamically created methods on the model instance named after transition triggers. This convention simplifies usage by binding trigger functions to the model, eliminating the need for explicit method definitions. Model state can be inspected to verify successful transitions. It requires the model not to have pre-existing methods with the same trigger names to avoid conflicts.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> lump.melt()\n>>> lump.state\n'liquid'\n>>> lump.evaporate()\n>>> lump.state\n'gas'\n```\n\n----------------------------------------\n\nTITLE: Defining Parallel and Nested States with Logging in HierarchicalMachine Using Python\nDESCRIPTION: Creates a HierarchicalMachine with complex nested and parallel states, demonstrating state entries and exits with logging output. Defines parallel substates using the 'parallel' keyword, local transitions within nested states, and initial substates for each nested or parallel branch. The snippet shows transition triggering and resetting the machine with logged info messages indicating each state transition event for debugging and understanding state machine processing order.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_66\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions.nesting import HierarchicalMachine\nimport logging\nstates = ['A', 'B', {'name': 'C', 'parallel': [{'name': '1', 'children': ['a', 'b', 'c'], 'initial': 'a',\n                                                'transitions': [['go', 'a', 'b']]},\n                                               {'name': '2', 'children': ['x', 'y', 'z'], 'initial': 'z'}],\n                      'transitions': [['go', '2_z', '2_x']]}]\n\ntransitions = [['reset', 'C_1_b', 'B']]\nlogging.basicConfig(level=logging.INFO)\nmachine = HierarchicalMachine(states=states, transitions=transitions, initial='A')\nmachine.to_C()\n# INFO:transitions.extensions.nesting:Exited state A\n# INFO:transitions.extensions.nesting:Entered state C\n# INFO:transitions.extensions.nesting:Entered state C_1\n# INFO:transitions.extensions.nesting:Entered state C_2\n# INFO:transitions.extensions.nesting:Entered state C_1_a\n# INFO:transitions.extensions.nesting:Entered state C_2_z\nmachine.go()\n# INFO:transitions.extensions.nesting:Exited state C_1_a\n# INFO:transitions.extensions.nesting:Entered state C_1_b\n# INFO:transitions.extensions.nesting:Exited state C_2_z\n# INFO:transitions.extensions.nesting:Entered state C_2_x\nmachine.reset()\n# INFO:transitions.extensions.nesting:Exited state C_1_b\n# INFO:transitions.extensions.nesting:Exited state C_2_x\n# INFO:transitions.extensions.nesting:Exited state C_1\n# INFO:transitions.extensions.nesting:Exited state C_2\n# INFO:transitions.extensions.nesting:Exited state C\n# INFO:transitions.extensions.nesting:Entered state B\n```\n\n----------------------------------------\n\nTITLE: Defining `before` and `after` Transition Callbacks in pytransitions (Python)\nDESCRIPTION: Shows how to attach `before` and `after` callbacks directly within the transition definition dictionary when initializing a `pytransitions` `Machine`. These callbacks (specified by method names as strings, e.g., 'make_hissing_noises', 'disappear') execute immediately before the state change and immediately after the state change completes, respectively. Requires a model (`Matter`) with the specified callback methods.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nclass Matter(object):\n    def make_hissing_noises(self): print(\"HISSSSSSSSSSSSSSSS\")\n    def disappear(self): print(\"where'd all the liquid go?\")\n\ntransitions = [\n    { 'trigger': 'melt', 'source': 'solid', 'dest': 'liquid', 'before': 'make_hissing_noises'},\n    { 'trigger': 'evaporate', 'source': 'liquid', 'dest': 'gas', 'after': 'disappear' }\n]\n\nlump = Matter()\nmachine = Machine(lump, states, transitions=transitions, initial='solid')\nlump.melt()\n>>> \"HISSSSSSSSSSSSSSSS\"\nlump.evaporate()\n>>> \"where'd all the liquid go?\"\n```\n\n----------------------------------------\n\nTITLE: Checking and Customizing State Attribute Name in transitions Machine - Python\nDESCRIPTION: This snippet explains how to check the current state using either the '.state' attribute, 'is_<state>()' methods, or custom state attributes set via 'model_attribute' during Machine initialization. It also shows retrieving the State object and dynamically customizing state-related methods. Dependencies: 'transitions' library. Parameters: 'model_attribute' string, state names, Machine instance. Input: queries to state attributes or is_/to_ methods. Output: boolean checks and state attribute values reflecting the current model state. Limitation: auto-generated method names are adjusted to reflect the custom attribute.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nlump.state\n>>> 'solid'\nlump.is_gas()\n>>> False\nlump.is_solid()\n>>> True\nmachine.get_state(lump.state).name\n>>> 'solid'\n```\n\nLANGUAGE: Python\nCODE:\n```\nlump = Matter()\nmachine = Machine(lump, states=['solid', 'liquid', 'gas'],  model_attribute='matter_state', initial='solid')\nlump.matter_state\n>>> 'solid'\n# with a custom 'model_attribute', states can also be checked like this:\nlump.is_matter_state_solid()\n>>> True\nlump.to_matter_state_gas()\n>>> True\n```\n\n----------------------------------------\n\nTITLE: Using Enum-Based State Definitions with Python 'transitions' Library\nDESCRIPTION: Demonstrates how to define states using Python's 'enum.Enum' for stricter typing and better IDE support when working with state machines. The snippet imports the 'enum' module and uses it with the 'transitions.Machine' class to define states, transitions, initial state, and perform state changes and checks. It shows how to instantiate the state machine with enum states, trigger transitions, and access state information. Requires the 'enum34' module for Python 2.7 users. Emphasizes that although mixing enums and strings is possible, states are internally handled by their enum names.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport enum  # Python 2.7 users need to have 'enum34' installed\nfrom transitions import Machine\n\nclass States(enum.Enum):\n    ERROR = 0\n    RED = 1\n    YELLOW = 2\n    GREEN = 3\n\ntransitions = [['proceed', States.RED, States.YELLOW],\n               ['proceed', States.YELLOW, States.GREEN],\n               ['error', '*', States.ERROR]]\n\nm = Machine(states=States, transitions=transitions, initial=States.RED)\nassert m.is_RED()\nassert m.state is States.RED\nstate = m.get_state(States.RED)  # get transitions.State object\nprint(state.name)  # >>> RED\nm.proceed()\nm.proceed()\nassert m.is_GREEN()\nm.error()\nassert m.state is States.ERROR\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Models Dynamically with Python Transitions\nDESCRIPTION: Shows initialization of a Machine without an initial model by passing `model=None`. Models (`lump1`, `lump2`) are then added dynamically with `add_model`, allowing independent initial states. The machine sends events such as `to_plasma` to all registered models using `dispatch`. Removal of models is demonstrated with `remove_model` for garbage collection. Parameters explained include `model`, `states`, `transitions`, and `initial`. This approach supports managing multiple models flexibly in one state machine.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nclass Matter():\n    pass\n\nlump1 = Matter()\nlump2 = Matter()\n\n# setting 'model' to None or passing an empty list will initialize the machine without a model\nmachine = Machine(model=None, states=states, transitions=transitions, initial='solid')\n\nmachine.add_model(lump1)\nmachine.add_model(lump2, initial='liquid')\n\nlump1.state\n>>> 'solid'\nlump2.state\n>>> 'liquid'\n\n# custom events as well as auto transitions can be dispatched to all models\nmachine.dispatch(\"to_plasma\")\n\nlump1.state\n>>> 'plasma'\nassert lump1.state == lump2.state\n\nmachine.remove_model([lump1, lump2])\ndel lump1  # lump1 is garbage collected\ndel lump2  # lump2 is garbage collected\n```\n\n----------------------------------------\n\nTITLE: Model-defined Callbacks with transitions Machine - Python\nDESCRIPTION: This snippet demonstrates defining callback methods directly in the model class to react to state transitions, specifically on entering a state. When the Machine detects a transition into the respective state, the model method (such as on_enter_A) automatically fires. Dependencies: 'transitions' library. Parameters: model instance with specifically named callback methods (on_enter_<state-name>). Input: transition events. Output: execution of side-effects as defined in model methods. Note: Initial state does not auto-trigger on_enter callbacks upon Machine creation.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nclass Matter(object):\n    def say_hello(self): print(\"hello, new state!\")\n    def say_goodbye(self): print(\"goodbye, old state!\")\n    def on_enter_A(self): print(\"We've just entered state A!\")\n\nlump = Matter()\nmachine = Machine(lump, states=['A', 'B', 'C'])\n```\n\n----------------------------------------\n\nTITLE: Adding Tags and Timeout State Features in Python\nDESCRIPTION: This snippet shows how to enhance a `transitions.Machine` by adding `Tags` and `Timeout` features using the `@add_state_features` decorator. It defines a `SocialSuperhero` model, configures states with `tags` and `timeout`/`on_timeout` properties, sets up transitions, and demonstrates the state machine's behavior, including timeout triggers and tag checking. Requires `time`, `transitions`, and `transitions.extensions.states`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_84\n\nLANGUAGE: python\nCODE:\n```\nfrom time import sleep\nfrom transitions import Machine\nfrom transitions.extensions.states import add_state_features, Tags, Timeout\n\n\n@add_state_features(Tags, Timeout)\nclass CustomStateMachine(Machine):\n    pass\n\n\nclass SocialSuperhero(object):\n    def __init__(self):\n        self.entourage = 0\n\n    def on_enter_waiting(self):\n        self.entourage += 1\n\n\nstates = [{'name': 'preparing', 'tags': ['home', 'busy']},\n          {'name': 'waiting', 'timeout': 1, 'on_timeout': 'go'},\n          {'name': 'away'}]  # The city needs us!\n\ntransitions = [['done', 'preparing', 'waiting'],\n               ['join', 'waiting', 'waiting'],  # Entering Waiting again will increase our entourage\n               ['go', 'waiting', 'away']]  # Okay, let' move\n\nhero = SocialSuperhero()\nmachine = CustomStateMachine(model=hero, states=states, transitions=transitions, initial='preparing')\nassert hero.state == 'preparing'  # Preparing for the night shift\nassert machine.get_state(hero.state).is_busy  # We are at home and busy\nhero.done()\nassert hero.state == 'waiting'  # Waiting for fellow superheroes to join us\nassert hero.entourage == 1  # It's just us so far\nsleep(0.7)  # Waiting...\nhero.join()  # Weeh, we got company\nsleep(0.5)  # Waiting...\nhero.join()  # Even more company \\o/\nsleep(2)  # Waiting...\nassert hero.state == 'away'  # Impatient superhero already left the building\nassert machine.get_state(hero.state).is_home is False  # Yupp, not at home anymore\nassert hero.entourage == 3  # At least he is not alone\n```\n\n----------------------------------------\n\nTITLE: Initializing States with Different Inputs in transitions Machine - Python\nDESCRIPTION: This snippet shows multiple approaches to defining states for the Machine: as State objects, strings, or dictionaries. It demonstrates passing mixed types to the Machine initializer and explicitly adding states using the 'add_states' method. Dependencies: 'transitions' package. Key parameters: a model object, a list of states (can include State instances, strings, or dicts). Input: state names and configurations. Output: Machine instance with initialized states. Limitations: Improperly configured state objects could persist their attributes if not managed carefully.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n# import Machine and State class\nfrom transitions import Machine, State\n\n# Create a list of 3 states to pass to the Machine\n# initializer. We can mix types; in this case, we\n# pass one State, one string, and one dict.\nstates = [\n    State(name='solid'),\n    'liquid',\n    { 'name': 'gas'}\n    ]\nmachine = Machine(lump, states)\n\n# This alternative example illustrates more explicit\n# addition of states and state callbacks, but the net\n# result is identical to the above.\nmachine = Machine(lump)\nsolid = State('solid')\nliquid = State('liquid')\ngas = State('gas')\nmachine.add_states([solid, liquid, gas])\n```\n\n----------------------------------------\n\nTITLE: Defining State Transitions Using Lists with Transitions Library in Python\nDESCRIPTION: Demonstrates a concise format to define transitions as lists containing trigger, source, and destination in order. This list of lists approach must align with the positional arguments expected by the 'Transition' object. The example is functionally equivalent to dictionary-based transition definitions but offers brevity at the cost of clarity.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ntransitions = [\n    ['melt', 'solid', 'liquid'],\n    ['evaporate', 'liquid', 'gas'],\n    ['sublimate', 'solid', 'gas'],\n    ['ionize', 'gas', 'plasma']\n]\n```\n\n----------------------------------------\n\nTITLE: Initializing Standalone Machine Using Python Transitions\nDESCRIPTION: Demonstrates creating a state machine without an associated model by omitting the model argument during the Machine initialization. This pattern consolidates all state machine triggers and callbacks on the Machine instance itself, removing the need to separate model and machine logic. Key parameters include `states`, `transitions`, and `initial` specifying states, transitions, and the starting state respectively. The snippet showcases triggering an event (`melt`) and querying the machine state. No external dependencies beyond Transitions are needed.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nmachine = Machine(states=states, transitions=transitions, initial='solid')\nmachine.melt()\nmachine.state\n>>> 'liquid'\n```\n\n----------------------------------------\n\nTITLE: Adding Transitions to a Machine After Initialization in Python Using 'transitions' Library\nDESCRIPTION: Shows how to augment an existing 'Machine' instance with additional transitions dynamically using the 'add_transition' method. It specifies the trigger name, source state, and destination state. This allows flexible modification of state machines post-instantiation without redefining all transitions upfront.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nmachine = Machine(model=lump, states=states, initial='solid')\nmachine.add_transition('melt', source='solid', dest='liquid')\n```\n\n----------------------------------------\n\nTITLE: Initializing `transitions.Machine` without an Explicit Model in Python\nDESCRIPTION: Shows an alternative initialization pattern where no `model` is passed to the `Machine` constructor. In this case, the `Machine` instance itself acts as the model and holds the state information. The states and initial state are defined as usual.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n\nmachine = Machine(states=['solid', 'liquid', 'gas', 'plasma'], initial='solid')\n```\n\n----------------------------------------\n\nTITLE: Using Hierarchical State Machine Python\nDESCRIPTION: Illustrates the use of `transitions.extensions.HierarchicalMachine` to create state machines with nested states. Demonstrates defining states with the `children` parameter, defining transitions including those entering or exiting nested states, and triggering transitions to move between parent and child states. Requires `transitions.extensions.HierarchicalMachine`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_59\n\nLANGUAGE: Python\nCODE:\n```\nfrom transitions.extensions import HierarchicalMachine\n\nstates = ['standing', 'walking', {'name': 'caffeinated', 'children':['dithering', 'running']}]\ntransitions = [\n  ['walk', 'standing', 'walking'],\n  ['stop', 'walking', 'standing'],\n  ['drink', '*', 'caffeinated'],\n  ['walk', ['caffeinated', 'caffeinated_dithering'], 'caffeinated_running'],\n  ['relax', 'caffeinated', 'standing']\n]\n\nmachine = HierarchicalMachine(states=states, transitions=transitions, initial='standing', ignore_invalid_triggers=True)\n\nmachine.walk() # Walking now\nmachine.stop() # let's stop for a moment\nmachine.drink() # coffee time\nmachine.state\n>>> 'caffeinated'\nmachine.walk() # we have to go faster\nmachine.state\n>>> 'caffeinated_running'\nmachine.stop() # can't stop moving!\nmachine.state\n>>> 'caffeinated_running'\nmachine.relax() # leave nested state\nmachine.state # phew, what a ride\n>>> 'standing'\n# machine.on_enter_caffeinated_running('callback_method')\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Transitions with `conditions` in pytransitions (Python)\nDESCRIPTION: Shows how to define conditional transitions in `pytransitions` using the `conditions` argument in `add_transition`. The transition only occurs if the specified method or list of methods (e.g., `is_flammable`, `is_really_hot` in the `Matter` class) return `True`. Requires a model class with the condition methods defined.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n# Our Matter class, now with a bunch of methods that return booleans.\nclass Matter(object):\n    def is_flammable(self): return False\n    def is_really_hot(self): return True\n\nmachine.add_transition('heat', 'solid', 'gas', conditions='is_flammable')\nmachine.add_transition('heat', 'solid', 'liquid', conditions=['is_really_hot'])\n```\n\n----------------------------------------\n\nTITLE: Enabling Queued Transitions for Sequential Execution in pytransitions (Python)\nDESCRIPTION: Demonstrates enabling queued processing in a `pytransitions` `Machine` by setting `queued=True` during initialization. This ensures that transitions triggered within callbacks (like `to_C` inside `on_enter_B`) are added to a queue and processed only after the current transition (`advance`) fully completes, including its `after` callbacks. This results in the expected sequential execution order: `prepare -> before -> on_enter_B -> queue(to_C) -> after -> on_enter_C`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nmachine = Machine(states=states, queued=True, initial='A')\n# ... (assuming previous setup: states, callbacks, transitions)\nmachine.advance()\n>>> 'I am in state B now!'\n>>> 'I am in state C now!' # That's better!\n```\n\n----------------------------------------\n\nTITLE: Using `prepare_event` and `finalize_event` Callbacks in pytransitions (Python)\nDESCRIPTION: Illustrates the `prepare_event` and `finalize_event` callbacks, set during `Machine` initialization in `pytransitions`. `prepare_event` ('prepare') runs once before any potential transitions or their callbacks are processed. `finalize_event` ('finalize') runs once after all processing for the event is complete, regardless of success or failure. Shows accessing potential errors via `event.error` within `finalize` when `send_event=True` is enabled and an error occurs (e.g., in `before_state_change`).\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine\n\nclass Matter(object):\n    def raise_error(self, event): raise ValueError(\"Oh no\")\n    def prepare(self, event): print(\"I am ready!\")\n    def finalize(self, event): print(\"Result: \", type(event.error), event.error)\n\nstates=['solid', 'liquid', 'gas', 'plasma']\n\nlump = Matter()\nm = Machine(lump, states, prepare_event='prepare', before_state_change='raise_error',\n            finalize_event='finalize', send_event=True)\ntry:\n    lump.to_gas()\nexcept ValueError:\n    pass\nprint(lump.state)\n\n# >>> I am ready!\n# >>> Result:  <class 'ValueError'> Oh no\n# >>> initial\n```\n\n----------------------------------------\n\nTITLE: Using Final States and on_final Callbacks in transitions Machine - Python\nDESCRIPTION: This code demonstrates how to define and utilize final states in a state machine, and how to attach a callback ('on_final') that is executed when such a state is entered. The example involves a model with speed-based transition logic and validates reaching a final state, executing the final state's callback method. Dependencies: 'transitions' library. Parameters: State objects with 'final=True', a Machine with the 'on_final' parameter, and model methods. Inputs: transition triggers with arguments. Outputs: model state changes and side-effectful callback execution. The population of final states allows for terminalization of machine execution.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nfrom transitions import Machine, State\n\nstates = [State(name='idling'),\n          State(name='rescuing_kitten'),\n          State(name='offender_gone', final=True),\n          State(name='offender_caught', final=True)]\n\ntransitions = [[\"called\", \"idling\", \"rescuing_kitten\"],  # we will come when  called\n               {\"trigger\": \"intervene\",\n                \"source\": \"rescuing_kitten\",\n                \"dest\": \"offender_gone\",  # we\n                \"conditions\": \"offender_is_faster\"},  # unless they are faster\n               [\"intervene\", \"rescuing_kitten\", \"offender_caught\"]]\n\nclass FinalSuperhero(object):\n\n    def __init__(self, speed):\n        self.machine = Machine(self, states=states, transitions=transitions, initial=\"idling\", on_final=\"claim_success\")\n        self.speed = speed\n\n    def offender_is_faster(self, offender_speed):\n        return self.speed < offender_speed\n\n    def claim_success(self, **kwargs):\n        print(\"The kitten is safe.\")\n\n\nhero = FinalSuperhero(speed=10)  # we are not in shape today\nhero.called()\nassert hero.is_rescuing_kitten()\nhero.intervene(offender_speed=15)\n# >>> 'The kitten is safe'\nassert hero.machine.get_state(hero.state).final  # it's over\nassert hero.is_offender_gone()  # maybe next time ...\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Model Class for `transitions` in Python\nDESCRIPTION: Defines a basic Python class `Matter` and creates an instance `lump`. This class serves as a placeholder model object to which a state machine will be attached in a subsequent example.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nclass Matter(object):\n    pass\n\nlump = Matter()\n```\n\n----------------------------------------\n\nTITLE: Creating Ordered Linear Transitions Among States in Python 'transitions' Library\nDESCRIPTION: Describes the use of 'add_ordered_transitions()' to enforce strict linear state progression across a predefined sequence of states. The method facilitates chaining transitions from one state to the next in order and wrapping around to the first state, with support for custom orders and conditional guards. This snippet emphasizes how to setup the machine and invoke state progression using the 'next_state()' method.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nstates = ['A', 'B', 'C']\n # See the \"alternative initialization\" section for an explanation of the 1st argument to init\nmachine = Machine(states=states, initial='A')\nmachine.add_ordered_transitions()\nmachine.next_state()\nprint(machine.state)\n>>> 'B'\n# We can also define a different order of transitions\nmachine = Machine(states=states, initial='A')\nmachine.add_ordered_transitions(['A', 'C', 'B'])\nmachine.next_state()\nprint(machine.state)\n>>> 'C'\n# Conditions can be passed to 'add_ordered_transitions' as well\n```\n\n----------------------------------------\n\nTITLE: Configuring Callbacks with Different References in transitions (Python)\nDESCRIPTION: Demonstrates the various ways to reference callables (methods, properties, attributes, imported functions) when defining conditions and callbacks for state transitions in the transitions library. It shows examples using string names, property names, attribute names, direct object references, and string paths to imported functions.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine\nfrom mod import imported_func\n\nimport random\n\n\nclass Model(object):\n\n    def a_callback(self):\n        imported_func()\n\n    @property\n    def a_property(self):\n        \"\"\" Basically a coin toss. \"\"\"\n        return random.random() < 0.5\n\n    an_attribute = False\n\n\nmodel = Model()\nmachine = Machine(model=model, states=['A'], initial='A')\nmachine.add_transition('by_name', 'A', 'A', conditions='a_property', after='a_callback')\nmachine.add_transition('by_reference', 'A', 'A', unless=['a_property', 'an_attribute'], after=model.a_callback)\nmachine.add_transition('imported', 'A', 'A', after='mod.imported_func')\n\nmodel.by_name()\nmodel.by_reference()\nmodel.imported()\n```\n\n----------------------------------------\n\nTITLE: Passing Direct Arguments to Callbacks in transitions (Python)\nDESCRIPTION: Demonstrates the default method of passing data to callbacks by providing positional or keyword arguments directly to the state machine's trigger methods. These arguments are passed directly to the registered callback functions, requiring all targeted callbacks to accept the same signature.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nclass Matter(object):\n    def __init__(self): self.set_environment()\n    def set_environment(self, temp=0, pressure=101.325):\n        self.temp = temp\n        self.pressure = pressure\n    def print_temperature(self): print(\"Current temperature is %d degrees celsius.\" % self.temp)\n    def print_pressure(self): print(\"Current pressure is %.2f kPa.\" % self.pressure)\n\nlump = Matter()\nmachine = Machine(lump, ['solid', 'liquid'], initial='solid')\nmachine.add_transition('melt', 'solid', 'liquid', before='set_environment')\n\nlump.melt(45)  # positional arg;\n# equivalent to lump.trigger('melt', 45)\nlump.print_temperature()\n#>>> 'Current temperature is 45 degrees celsius.'\n\nmachine.set_state('solid')  # reset state so we can melt again\nlump.melt(pressure=300.23)  # keyword args also work\nlump.print_pressure()\n#>>> 'Current pressure is 300.23 kPa.'\n```\n\n----------------------------------------\n\nTITLE: Optimizing PyTransitions memory footprint with a static Machine and dynamic attribute resolution in Python\nDESCRIPTION: Demonstrates a memory-efficient approach to using PyTransitions with many instances by defining a static Machine class attribute without specific models and using __getattribute__ to dynamically route event triggers. The Model simulates callbacks using MagicMock and overrides __getattribute__ to return partial event wrappers on demand. Limitations include removal of is_<state>() helper methods and lack of automatic on_enter/on_exit callbacks. Dependencies are PyTransitions and unittest.mock. The snippet also validates transitions and event calling counts.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine\nfrom functools import partial\nfrom mock import MagicMock\n\n\nclass Model(object):\n\n    machine = Machine(model=None, states=['A', 'B', 'C'], initial=None,\n                      transitions=[\n                          {'trigger': 'go', 'source': 'A', 'dest': 'B', 'before': 'before'},\n                          {'trigger': 'check', 'source': 'B', 'dest': 'C', 'conditions': 'is_large'},\n                      ], finalize_event='finalize')\n\n    def __init__(self):\n        self.state = 'A'\n        self.before = MagicMock()\n        self.after = MagicMock()\n        self.finalize = MagicMock()\n\n    @staticmethod\n    def is_large(value=0):\n        return value > 9000\n\n    def __getattribute__(self, item):\n        try:\n            return super(Model, self).__getattribute__(item)\n        except AttributeError:\n            if item in self.machine.events:\n                return partial(self.machine.events[item].trigger, self)\n            raise\n\n\nmodel = Model()\nmodel.go()\nassert model.state == 'B'\nassert model.before.called\nassert model.finalize.called\nmodel.check()\nassert model.state == 'B'\nmodel.check(value=500)\nassert model.state == 'B'\nmodel.check(value=9001)\nassert model.state == 'C'\nassert model.finalize.call_count == 4\n\n```\n\n----------------------------------------\n\nTITLE: Handling Exceptions with `on_exception` Callback in pytransitions (Python)\nDESCRIPTION: Shows how to use the `on_exception` callback, passed during `Machine` initialization in `pytransitions`, to gracefully handle exceptions raised during transition processing (e.g., by `raise_error` called via `before_state_change`). The `handle_error` callback receives the event data, including the exception in `event.error` (requires `send_event=True`), allowing for custom error handling or cleanup. Deleting `event.error` suppresses the exception from propagating further.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine\n\nclass Matter(object):\n    def raise_error(self, event): raise ValueError(\"Oh no\")\n    def handle_error(self, event):\n        print(\"Fixing things ...\")\n        del event.error  # it did not happen if we cannot see it ...\n\nstates=['solid', 'liquid', 'gas', 'plasma']\n\nlump = Matter()\nm = Machine(lump, states, before_state_change='raise_error', on_exception='handle_error', send_event=True)\ntry:\n    lump.to_gas()\nexcept ValueError:\n    pass\nprint(lump.state)\n\n# >>> Fixing things ...\n# >>> initial\n```\n\n----------------------------------------\n\nTITLE: Passing EventData Object to Callbacks in transitions (Python)\nDESCRIPTION: Shows how enabling `send_event=True` during Machine initialization modifies data passing to callbacks. Instead of direct arguments, all arguments are wrapped into an `EventData` object, which is then passed as the single argument to each callback, allowing callbacks to access positional (`.args`) and keyword (`.kwargs`) arguments consistently.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nclass Matter(object):\n\n    def __init__(self):\n        self.temp = 0\n        self.pressure = 101.325\n\n    # Note that the sole argument is now the EventData instance.\n    # This object stores positional arguments passed to the trigger method in the\n    # .args property, and stores keywords arguments in the .kwargs dictionary.\n    def set_environment(self, event):\n        self.temp = event.kwargs.get('temp', 0)\n        self.pressure = event.kwargs.get('pressure', 101.325)\n\n    def print_pressure(self): print(\"Current pressure is %.2f kPa.\" % self.pressure)\n\nlump = Matter()\nmachine = Machine(lump, ['solid', 'liquid'], send_event=True, initial='solid')\nmachine.add_transition('melt', 'solid', 'liquid', before='set_environment')\n\nlump.melt(temp=45, pressure=1853.68)  # keyword args\nlump.print_pressure()\n#>>> 'Current pressure is 1853.68 kPa.'\n```\n\n----------------------------------------\n\nTITLE: Exporting and loading PyTransitions configurations with MarkupMachine in Python\nDESCRIPTION: Shows usage of the MarkupMachine from transitions.extensions.markup to create, export, and reload state machine configurations with enriched metadata useful for visualization and introspection. The example demonstrates creating a machine, adding states and transitions programmatically, associating a model, performing transitions, and serializing the machine's markup property to JSON and YAML. It then reloads the configuration into a new MarkupMachine and verifies state preservation and callbacks. Dependencies include PyTransitions, json, and pyyaml. Note the necessity of removing 'models' attribute when transferring config for use with a plain Machine.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#export\nfrom transitions.extensions.markup import MarkupMachine\nimport json\nimport yaml\n\n\nclass Model:\n\n    def say_hello(self, name):\n        print(f\"Hello {name}!\")\n\n\nmodel = Model()\nm = MarkupMachine(model=None, name=\"ExportedMachine\")\nm.add_state('A')\nm.add_state('B')\nm.add_state('C', on_enter='say_hello')\nm.add_transition('go', 'A', 'B')\nm.add_transition(trigger='hello', source='*', dest='C')\nm.initial = 'A'\nm.add_model(model)\nmodel.go()\n\nprint(\"JSON:\")\nprint(json.dumps(m.markup, indent=2))\nprint('\\nYAML:')\nprint(yaml.dump(m.markup))\n\nconfig2 = json.loads(json.dumps(m.markup))  # simulate saving and loading\nm2 = MarkupMachine(markup=config2)\nmodel2 = m2.models[0]  # get the initialized model\nassert model2.is_B()  # the model state was preserved\nmodel2.hello('again')  # >>> Hello again!\nassert model2.state == 'C'\n\n```\n\n----------------------------------------\n\nTITLE: Querying Valid Event Triggers for States in Python 'transitions' Library\nDESCRIPTION: Explains how to retrieve the list of valid triggers from one or multiple states using the 'get_triggers' method of the machine instance. This facilitates introspection and conditional logic based on allowable transitions from the current state(s).\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nm.get_triggers('solid')\n>>> ['melt', 'sublimate']\nm.get_triggers('liquid')\n>>> ['evaporate']\nm.get_triggers('plasma')\n>>> []\n# you can also query several states at once\nm.get_triggers('solid', 'liquid', 'gas', 'plasma')\n>>> ['melt', 'evaporate', 'sublimate', 'ionize']\n```\n\n----------------------------------------\n\nTITLE: Using Hierarchical State Machine with Initial Substate Python\nDESCRIPTION: Expands on the hierarchical state machine example by demonstrating how to use the `initial` parameter within a nested state definition. This causes the machine to automatically transition into the specified substate upon entering the parent state. Requires `transitions.extensions.HierarchicalMachine`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_60\n\nLANGUAGE: Python\nCODE:\n```\n# ...\nstates = ['standing', 'walking', {'name': 'caffeinated', 'initial': 'dithering', 'children': ['dithering', 'running']}]\ntransitions = [\n  ['walk', 'standing', 'walking'],\n  ['stop', 'walking', 'standing'],\n  # this transition will end in 'caffeinated_dithering'...\n  ['drink', '*', 'caffeinated'],\n  # ... that is why we do not need do specify 'caffeinated' here anymore\n  ['walk', 'caffeinated_dithering', 'caffeinated_running'],\n  ['relax', 'caffeinated', 'standing']\n]\n# ...\n```\n\n----------------------------------------\n\nTITLE: Initializing Inherited Machine Class in Python Transitions\nDESCRIPTION: Illustrates how a user model can directly inherit from the Transitions `Machine` class, consolidating all state machine functionality within the model by overriding the `__init__` method. The example defines a `Matter` class with states and a transition, showing state queries and triggering transitions on the model instance. Key dependencies include the Transitions Machine class, and the example requires overriding `__init__` to initialize states and transitions.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nclass Matter(Machine):\n    def say_hello(self): print(\"hello, new state!\")\n    def say_goodbye(self): print(\"goodbye, old state!\")\n\n    def __init__(self):\n        states = ['solid', 'liquid', 'gas']\n        Machine.__init__(self, states=states, initial='solid')\n        self.add_transition('melt', 'solid', 'liquid')\n\nlump = Matter()\nlump.state\n>>> 'solid'\nlump.melt()\nlump.state\n>>> 'liquid'\n```\n\n----------------------------------------\n\nTITLE: Initializing HierarchicalMachine with Auto Transitions in Python\nDESCRIPTION: Initializes a HierarchicalMachine instance with hierarchical states and transitions, utilizing auto-generated transition methods for state changes. Demonstrates how to trigger transitions, check current states including substates, and reset the machine state. Includes handling of state naming conflicts by prefixing numeric substates with 's' to maintain valid attribute names. The snippet uses the machine.to_<state>() and machine.to('<state>') methods along with FunctionWrapper variants for hierarchical state management.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_63\n\nLANGUAGE: python\nCODE:\n```\n# we rely on auto transitions\nmachine = HierarchicalMachine(states=states, transitions=transitions, initial='A')\nmachine.to_B()  # exit state A, enter state B\nmachine.to_C()  # exit B, enter C\nmachine.to_C.s3.a()  # enter C↦a; enter C↦3↦a;\nmachine.state\n>>> 'C↦3↦a'\nassert machine.is_C.s3.a()\nmachine.to('C↦2')  # not interactive; exit C↦3↦a, exit C↦3, enter C↦2\nmachine.reset()  # exit C↦2; reset C has been overwritten by C↦3\nmachine.state\n>>> 'C'\nmachine.reset()  # exit C, enter A\nmachine.state\n>>> 'A'\n# s.on_enter('C↦3↦a', 'callback_method')\n```\n\n----------------------------------------\n\nTITLE: Drawing State Diagrams with Graphviz in Python transitions\nDESCRIPTION: Demonstrates how to generate state diagrams using graphviz or pygraphviz backends with the GraphMachine extension, including options for visualizing auto-transitions and regions of interest.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_74\n\nLANGUAGE: python\nCODE:\n```\n# import transitions\n\nfrom transitions.extensions import GraphMachine\nm = Model()\n# without further arguments pygraphviz will be used\nmachine = GraphMachine(model=m, ...)\n# when you want to use graphviz explicitly\nmachine = GraphMachine(model=m, graph_engine=\"graphviz\", ...)\n# in cases where auto transitions should be visible\nmachine = GraphMachine(model=m, show_auto_transitions=True, ...)\n\n# draw the whole graph ...\nm.get_graph().draw('my_state_diagram.png', prog='dot')\n# ... or just the region of interest\n# (previous state, active state and all reachable states)\nroi = m.get_graph(show_roi=True).draw('my_state_diagram.png', prog='dot')\n```\n\n----------------------------------------\n\nTITLE: Triggering Transitions Dynamically Using the 'trigger' Method in Python 'transitions' Library\nDESCRIPTION: Demonstrates the use of the 'trigger' method attached to the model instance for dynamically invoking transitions by their string names. This method is useful when transition names are determined at runtime and provides an alternative to direct method calls. The model's state is updated accordingly on successful triggers.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> lump.trigger('melt')\n>>> lump.state\n'liquid'\n>>> lump.trigger('evaporate')\n>>> lump.state\n'gas'\n```\n\n----------------------------------------\n\nTITLE: Creating a Hierarchical State Machine with Python Transitions\nDESCRIPTION: Demonstrates how to use the HierarchicalMachine extension in transitions to create nested states. The example models a person who can be standing, walking, or in a caffeinated state with sub-states of dithering and running.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Playground.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions import HierarchicalMachine as Machine\n\nstates = ['standing', 'walking', {'name': 'caffeinated', 'children':['dithering', 'running']}]\ntransitions = [\n  ['walk', 'standing', 'walking'],\n  ['stop', 'walking', 'standing'],\n  ['drink', '*', 'caffeinated'],\n  ['walk', ['caffeinated', 'caffeinated_dithering'], 'caffeinated_running'],\n  ['relax', 'caffeinated', 'standing']\n]\n\nmachine = Machine(states=states, transitions=transitions, initial='standing', ignore_invalid_triggers=True)\n\nassert machine.walk() # Walking now\n# I fancy a coffee right now ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Transitions with `unless` in pytransitions (Python)\nDESCRIPTION: Demonstrates using the `unless` argument in `add_transition` within the `pytransitions` library. The transition executes only if all specified condition methods (e.g., `is_flammable`, `is_really_hot`) return `False`. This provides an inverse logic to the `conditions` argument, allowing transitions when certain conditions are *not* met.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nmachine.add_transition('heat', 'solid', 'gas', unless=['is_flammable', 'is_really_hot'])\n```\n\n----------------------------------------\n\nTITLE: Checking HierarchicalMachine States and Substates with FunctionWrapper in Python\nDESCRIPTION: Illustrates how to check the current hierarchical state and its substates using the is_state methods and their FunctionWrapper variants. Demonstrates the use of the allow_substates keyword parameter to verify if the current state is a substate of a specified higher-level state. This enables flexible state querying in hierarchical state machines, allowing match checks for direct states or their nested substates.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_64\n\nLANGUAGE: python\nCODE:\n```\nmachine.state\n>>> 'C.2.a'\nmachine.is_C() # checks for specific states\n>>> False\nmachine.is_C(allow_substates=True)\n>>> True\nassert machine.is_C.s2() is False\nassert machine.is_C.s2(allow_substates=True)  # FunctionWrapper support allow_substate as well\n```\n\n----------------------------------------\n\nTITLE: Using the `prepare` Transition Callback in pytransitions (Python)\nDESCRIPTION: Illustrates the use of the `prepare` callback in `pytransitions`, defined within a transition dictionary. `prepare` callbacks (e.g., 'heat_up', 'count_attempts') are executed when a transition is triggered from a valid source state, *before* any `conditions` (like 'is_really_hot') are evaluated. This is useful for setup tasks, logging attempts, or modifying state needed for condition checks. `prepare` is not called if the source state doesn't match.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nimport random\n\nclass Matter(object):\n    heat = False\n    attempts = 0\n    def count_attempts(self): self.attempts += 1\n    def heat_up(self): self.heat = random.random() < 0.25\n    def stats(self): print('It took you %i attempts to melt the lump!' %self.attempts)\n\n    @property\n    def is_really_hot(self):\n        return self.heat\n\n\nstates=['solid', 'liquid', 'gas', 'plasma']\n\ntransitions = [\n    { 'trigger': 'melt', 'source': 'solid', 'dest': 'liquid', 'prepare': ['heat_up', 'count_attempts'], 'conditions': 'is_really_hot', 'after': 'stats'},\n]\n\nlump = Matter()\nmachine = Machine(lump, states, transitions=transitions, initial='solid')\nlump.melt()\nlump.melt()\nlump.melt()\nlump.melt()\n>>> \"It took you 4 attempts to melt the lump!\"\n```\n\n----------------------------------------\n\nTITLE: Handling Model Removal with Queued Transitions in pytransitions (Python)\nDESCRIPTION: Demonstrates that if a model is removed from a `pytransitions` `Machine` (`machine.remove_model(self)`) while it has pending events in the queue (due to `queued=True`), those associated events are automatically removed from the queue. This prevents attempts to process transitions for models no longer managed by the state machine.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nclass Model:\n    def on_enter_B(self):\n        self.to_C()  # add event to queue ...\n        self.machine.remove_model(self)  # aaaand it's gone\n```\n\n----------------------------------------\n\nTITLE: Setting Default `before`/`after` Callbacks for All Transitions in pytransitions (Python)\nDESCRIPTION: Demonstrates how to define default callbacks that execute for *every* state transition by passing method names as strings to the `before_state_change` and `after_state_change` parameters during `Machine` initialization in `pytransitions`. These global callbacks run before and after any transition-specific `before`/`after` callbacks, respectively.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nclass Matter(object):\n    def make_hissing_noises(self): print(\"HISSSSSSSSSSSSSSSS\")\n    def disappear(self): print(\"where'd all the liquid go?\")\n\nstates=['solid', 'liquid', 'gas', 'plasma']\n\nlump = Matter()\nm = Machine(lump, states, before_state_change='make_hissing_noises', after_state_change='disappear')\nlump.to_gas()\n>>> \"HISSSSSSSSSSSSSSSS\"\n>>> \"where'd all the liquid go?\"\n```\n\n----------------------------------------\n\nTITLE: Reusing Hierarchical State Machines in Python with transitions\nDESCRIPTION: Demonstrates how to create a counter state machine and embed it within a collector state machine, showing the nested state hierarchy and reference behavior in transitions 0.8.0+.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_69\n\nLANGUAGE: python\nCODE:\n```\ncount_states = ['1', '2', '3', 'done']\ncount_trans = [\n    ['increase', '1', '2'],\n    ['increase', '2', '3'],\n    ['decrease', '3', '2'],\n    ['decrease', '2', '1'],\n    ['done', '3', 'done'],\n    ['reset', '*', '1']\n]\n\ncounter = HierarchicalMachine(states=count_states, transitions=count_trans, initial='1')\n\ncounter.increase() # love my counter\nstates = ['waiting', 'collecting', {'name': 'counting', 'children': counter}]\n\ntransitions = [\n    ['collect', '*', 'collecting'],\n    ['wait', '*', 'waiting'],\n    ['count', 'collecting', 'counting']\n]\n\ncollector = HierarchicalMachine(states=states, transitions=transitions, initial='waiting')\ncollector.collect()  # collecting\ncollector.count()  # let's see what we got; counting_1\ncollector.increase()  # counting_2\ncollector.increase()  # counting_3\ncollector.done()  # collector.state == counting_done\ncollector.wait()  # collector.state == waiting\n```\n\n----------------------------------------\n\nTITLE: Checking Transition Feasibility with `may_<trigger>` in pytransitions (Python)\nDESCRIPTION: Demonstrates using the automatically generated `may_<trigger_name>` methods (e.g., `lump.may_heat()`) or the general `may_trigger(\"trigger_name\")` method in `pytransitions`. These methods check if a specific transition is possible from the model's current state by evaluating its defined conditions, returning `True` or `False` without actually executing the transition.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n# check if the current temperature is hot enough to trigger a transition\nif lump.may_heat():\n# if lump.may_trigger(\"heat\"):\n    lump.heat()\n```\n\n----------------------------------------\n\nTITLE: Filtering Valid Triggers with Condition-Aware PeekMachine Extension in PyTransitions (Python)\nDESCRIPTION: This snippet enhances the PyTransitions Machine to provide a method that returns only triggers currently valid under given runtime conditions. It defines a custom PeekMachine subclass overriding the internal _can_trigger method. This method evaluates conditions of available transitions for the model's current state and filters triggers accordingly. It also attaches a 'can_trigger' function dynamically to each added model for simplified querying. The associated Model class implements example condition methods. Inputs are model state and optional parameters passed as conditions; outputs are filtered trigger names. This functionality depends on PyTransitions core modules, functools.partial, and supports complex conditional logic for state transitions, improving introspection and decision-making in state machines.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine, EventData\nfrom transitions.core import listify\nfrom functools import partial\n\n\nclass Model(object):\n\n    def fails(self, condition=False):\n        return False\n\n    def success(self, condition=False):\n        return True\n\n    # condition is passed by EventData\n    def depends_on(self, condition=False):\n        return condition\n\n    def is_state_B(self, condition=False):\n        return self.state == 'B'\n\n\nclass PeekMachine(Machine):\n\n    def _can_trigger(self, model, *args, **kwargs):\n        # We can omit the first two arguments state and event since they are only needed for\n        # actual state transitions. We do have to pass the machine (self) and the model as well as\n        # args and kwargs meant for the callbacks.\n        e = EventData(None, None, self, model, args, kwargs)\n\n        return [trigger_name for trigger_name in self.get_triggers(model.state)\n                if any(all(c.check(e) for c in t.conditions)\n                       for t in self.events[trigger_name].transitions[model.state])]\n\n    # override Machine.add_model to assign 'can_trigger' to the model\n    def add_model(self, model, initial=None):\n        for mod in listify(model):\n            mod = self if mod is self.self_literal else mod\n            if mod not in self.models:\n                setattr(mod, 'can_trigger', partial(self._can_trigger, mod))\n                super(PeekMachine, self).add_model(mod, initial)\n\nstates = ['A', 'B', 'C', 'D']\ntransitions = [\n    dict(trigger='go_A', source='*', dest='A', conditions=['depends_on']),  # only available when condition=True is passed\n    dict(trigger='go_B', source='*', dest='B', conditions=['success']),  # always available\n    dict(trigger='go_C', source='*', dest='C', conditions=['fails']),  # never available\n    dict(trigger='go_D', source='*', dest='D', conditions=['is_state_B']),  # only available in state B\n    dict(trigger='reset', source='D', dest='A', conditions=['success', 'depends_on']), # only available in state D when condition=True is passed\n    dict(trigger='forwards', source='A', dest='D', conditions=['success', 'fails']),  # never available\n    dict(trigger='forwards', source='D', dest='D', unless=['depends_on'])\n]\n\nmodel = Model()\nmachine = PeekMachine(model, states=states, transitions=transitions, initial='A', auto_transitions=False)\nassert model.can_trigger() == ['go_B']\nassert set(model.can_trigger(condition=True)) == set(['go_A', 'go_B'])\nmodel.go_B(condition=True)\nassert set(model.can_trigger()) == set(['go_B', 'go_D'])\nmodel.go_D()\nassert model.can_trigger() == ['go_B', 'forwards']\nassert set(model.can_trigger(condition=True)) == set(['go_A', 'go_B', 'reset'])\n```\n\n----------------------------------------\n\nTITLE: Checking Transitions with Potentially Unavailable Destinations in pytransitions (Python)\nDESCRIPTION: Illustrates how `may_<trigger_name>` (e.g., `may_elevate`) or `may_trigger` in `pytransitions` evaluates the possibility of a transition, returning `False` if the transition cannot proceed. This check considers not only explicit conditions but also whether the source state allows the transition and if the destination state is valid, even if temporarily unreachable due to conditions.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nmachine.add_transition('elevate', 'solid', 'spiritual')\nassert not lump.may_elevate()  # not ready yet :(\nassert not lump.may_trigger(\"elevate\")  # same result for checks via trigger name\n```\n\n----------------------------------------\n\nTITLE: Dynamically Adding Nested States and Checking Substates in HierarchicalMachine Using Python\nDESCRIPTION: Demonstrates the dynamic addition of nested substates to an existing HierarchicalMachine instance. Shows that adding a state with underscores (denoting hierarchy) will automatically create parent states if they do not exist. Validates state membership checking including substates by using the allow_substates flag on is_state method, enabling flexible queries on dynamic state hierarchies.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_67\n\nLANGUAGE: python\nCODE:\n```\nm = HierarchicalMachine(states=['A'], initial='A')\nm.add_state('B_1_a')\nm.to_B_1()\nassert m.is_B(allow_substates=True)\n```\n\n----------------------------------------\n\nTITLE: Defining Ordered Transitions with Conditions in pytransitions (Python)\nDESCRIPTION: Shows how to use `add_ordered_transitions` in the `pytransitions` library to create sequential transitions between states (e.g., A->B->...->X->A). Examples cover applying a single condition to all transitions, applying specific conditions to each transition in the sequence based on the initial state, and disabling the loop from the last to the first state using `loop=False`. Requires a `Machine` instance and defined states.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n# If one condition is passed, it will be used for all transitions\nmachine = Machine(states=states, initial='A')\nmachine.add_ordered_transitions(conditions='check')\n\n# If a list is passed, it must contain exactly as many elements as the\n# machine contains states (A->B, ..., X->A)\nmachine = Machine(states=states, initial='A')\nmachine.add_ordered_transitions(conditions=['check_A2B', ..., 'check_X2A'])\n\n# Conditions are always applied starting from the initial state\nmachine = Machine(states=states, initial='B')\nmachine.add_ordered_transitions(conditions=['check_B2C', ..., 'check_A2B'])\n\n# With `loop=False`, the transition from the last state to the first state will be omitted (e.g. C->A)\n# When you also pass conditions, you need to pass one condition less (len(states)-1)\nmachine = Machine(states=states, initial='A')\nmachine.add_ordered_transitions(loop=False)\nmachine.next_state()\nmachine.next_state()\nmachine.next_state() # transitions.core.MachineError: \"Can't trigger event next_state from state C!\"\n```\n\n----------------------------------------\n\nTITLE: Customizing Callable Resolution in transitions (Python)\nDESCRIPTION: Illustrates how to create a custom Machine subclass to override the static method `resolve_callable`. This allows developers to implement their own logic for how string references or other identifiers are translated into executable Python callables, potentially manipulating arguments before execution.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nclass CustomMachine(Machine):\n    @staticmethod\n    def resolve_callable(func, event_data):\n        # manipulate arguments here and return func, or super() if no manipulation is done.\n        super(CustomMachine, CustomMachine).resolve_callable(func, event_data)\n```\n\n----------------------------------------\n\nTITLE: Associating Multiple State Machines to One Model with Different Attributes Using Python Transitions\nDESCRIPTION: Demonstrates attaching multiple machines to the same model using distinct `model_attribute` names, allowing for managing multiple independent state machines within a single class instance. The snippet includes creating two machines with different state sets, initial states, and associated attributes. It shows condition checks and state transitions scoped to each machine's attribute namespace, illustrating the use of custom `is` and `to_` methods to distinguish state logic per attribute.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nlump = Matter()\n\nmatter_machine = Machine(lump, states=['solid', 'liquid', 'gas'], initial='solid')\n# add a second machine to the same model but assign a different state attribute\nshipment_machine = Machine(lump, states=['delivered', 'shipping'], initial='delivered', model_attribute='shipping_state')\n\nlump.state\n>>> 'solid'\nlump.is_solid()  # check the default field\n>>> True\nlump.shipping_state\n>>> 'delivered'\nlump.is_shipping_state_delivered()  # check the custom field.\n>>> True\nlump.to_shipping_state_shipping()\n>>> True\nlump.is_shipping_state_delivered()\n>>> False\n```\n\n----------------------------------------\n\nTITLE: Visualizing State Machines with GraphMachine and Custom State Features\nDESCRIPTION: Demonstrates how to visualize state machines using the GraphMachine extension combined with state features like Timeout and Tags. Creates a complex state system with conditions and actions, then renders it as a graph image.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Playground.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions.states import Timeout, Tags, add_state_features\nfrom transitions.extensions.diagrams import GraphMachine\n\nimport io\nfrom IPython.display import Image, display, display_png\n\n\n@add_state_features(Timeout, Tags)\nclass CustomMachine(GraphMachine):\n    pass\n\n\nstates = ['new', 'approved', 'ready', 'finished', 'provisioned',\n          {'name': 'failed', 'on_enter': 'notify', 'on_exit': 'reset',\n           'tags': ['error', 'urgent'], 'timeout': 10, 'on_timeout': 'shutdown'},\n          'in_iv', 'initializing', 'booting', 'os_ready', {'name': 'testing', 'on_exit': 'create_report'},\n          'provisioning']\n\ntransitions = [{'trigger': 'approve', 'source': ['new', 'testing'], 'dest':'approved',\n                'conditions': 'is_valid', 'unless': 'abort_triggered'},\n               ['fail', '*', 'failed'],\n               ['add_to_iv', ['approved', 'failed'], 'in_iv'],\n               ['create', ['failed','in_iv'], 'initializing'],\n               ['init', 'in_iv', 'initializing'],\n               ['finish', 'approved', 'finished'],\n               ['boot', ['booting', 'initializing'], 'booting'],\n               ['ready', ['booting', 'initializing'], 'os_ready'],\n               ['run_checks', ['failed', 'os_ready'], 'testing'],\n               ['provision', ['os_ready', 'failed'], 'provisioning'],\n               ['provisioning_done', 'provisioning', 'os_ready']]\n\n\nclass Model:\n    \n    # graph object is created by the machine\n    def show_graph(self, **kwargs):\n        stream = io.BytesIO()\n        self.get_graph(**kwargs).draw(stream, prog='dot', format='png')\n        display(Image(stream.getvalue()))\n    \n    def is_valid(self):\n        return True\n    \n    def abort_triggered(self):\n        return False\n\nmodel = Model()\nmachine = CustomMachine(model=model, states=states, transitions=transitions, initial='new', title='System State',\n                        show_conditions=True, show_state_attributes=True)\nmodel.approve()\nmodel.show_graph()\n\n# Your turn! What happens next?\n```\n\n----------------------------------------\n\nTITLE: (Re-)Storing and Loading State Machine Instances Using Pickle with Python Transitions\nDESCRIPTION: Demonstrates storing (pickling) and restoring (unpickling) a Transitions Machine instance, preserving its states and current state. For Python versions <=3.3, the `dill` library is required instead of the standard `pickle`. The snippet initializes a machine with states, triggers a transition, serializes the machine, and later deserializes it to continue usage with preserved state information. This enables persistence and stateful restoration of machines.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nimport dill as pickle # only required for Python 3.3 and earlier\n\nm = Machine(states=['A', 'B', 'C'], initial='A')\nm.to_B()\nm.state\n>>> B\n\n# store the machine\ndump = pickle.dumps(m)\n\n# load the Machine instance again\nm2 = pickle.loads(dump)\n\nm2.state\n>>> B\n\nm2.states.keys()\n>>> ['A', 'B', 'C']\n```\n\n----------------------------------------\n\nTITLE: Using Custom Context Managers with LockedMachine in Python\nDESCRIPTION: Shows how to provide custom, re-entrant context managers (like `threading.RLock`) to a `LockedMachine` instance using the `machine_context` keyword argument during initialization. These contexts will be applied globally to the machine. Depends on `transitions.extensions.LockedMachine` and `threading.RLock`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_79\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions import LockedMachine\nfrom threading import RLock\n\nstates = ['A', 'B', 'C']\n\nlock1 = RLock()\nlock2 = RLock()\n\nmachine = LockedMachine(states=states, initial='A', machine_context=[lock1, lock2])\n```\n\n----------------------------------------\n\nTITLE: Defining Transitions via Model Decorators Python\nDESCRIPTION: Illustrates an experimental approach to define state transitions directly within a model class using `Enum` for states and decorators like `@add_transitions` and `event`. Requires a custom `Machine` subclass decorated with `@with_model_definitions`. Shows instantiation and triggering events.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_56\n\nLANGUAGE: Python\nCODE:\n```\nfrom enum import Enum\n\nfrom transitions.experimental.utils import with_model_definitions, event, add_transitions, transition\nfrom transitions import Machine\n\n\nclass State(Enum):\n    A = \"A\"\n    B = \"B\"\n    C = \"C\"\n\n\nclass Model:\n\n    state: State = State.A\n\n    @add_transitions(transition(source=State.A, dest=State.B), [State.C, State.A])\n    @add_transitions({\"source\": State.B,  \"dest\": State.A})\n    def foo(self): ...\n\n    bar = event(\n        {\"source\": State.B, \"dest\": State.A, \"conditions\": lambda: False},\n        transition(source=State.B, dest=State.C)\n    )\n\n\n@with_model_definitions  # don't forget to define your model with this decorator!\nclass MyMachine(Machine):\n    pass\n\n\nmodel = Model()\nmachine = MyMachine(model, states=State, initial=model.state)\nmodel.foo()\nmodel.bar()\nassert model.state == State.C\nmodel.foo()\nassert model.state == State.A\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Transitions with Exception Raising in Python 'transitions' Library\nDESCRIPTION: Shows the default error handling behavior where attempting to trigger a transition invalid for the current state raises a 'MachineError' exception. This safeguards the state machine by notifying developers of improper state actions. Example demonstrates an invalid transition attempted after a state change that doesn't allow the specified trigger.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> lump.to_gas()\n>>> # This won't work because only objects in a solid state can melt\n>>> lump.melt()\ntransitions.core.MachineError: \"Can't trigger event melt from state gas!\"\n```\n\n----------------------------------------\n\nTITLE: Using Enumerations as States in HierarchicalMachine with Python\nDESCRIPTION: Shows how to use Enum members as state names in HierarchicalMachine state definitions. Emphasizes that Enum states are compared by value and notes a limitation where duplicate Enum values in the state tree prevent unique state differentiation. The snippet demonstrates nested states and transitioning to an Enum state while clarifying that state checks may return True for equivalent Enum values even if the current state context differs.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_65\n\nLANGUAGE: python\nCODE:\n```\nstates = [States.RED, States.YELLOW, {'name': States.GREEN, 'children': ['tick', 'tock']}]\nstates = ['A', {'name': 'B', 'children': states, 'initial': States.GREEN}, States.GREEN]\nmachine = HierarchicalMachine(states=states)\nmachine.to_B()\nmachine.is_GREEN()  # returns True even though the actual state is B_GREEN\n```\n\n----------------------------------------\n\nTITLE: Using Automatic Transitions ('to_<state>') for Every State with Python 'transitions' Library\nDESCRIPTION: Highlights that for each defined state, the machine automatically creates a 'to_<state>()' method allowing a transition to that state from any current state, bypassing explicit transition definitions. This automatic behavior can be disabled by setting 'auto_transitions=False' on the 'Machine' initializer if undesired.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nlump.to_liquid()\nlump.state\n>>> 'liquid'\nlump.to_solid()\nlump.state\n>>> 'solid'\n```\n\n----------------------------------------\n\nTITLE: Visualizing State Machines with Callback References using transitions in Python\nDESCRIPTION: Illustrates how to create a state machine using `GraphMachine` and visualize it, including references to callback methods used in transitions. It shows how to define a model class with methods used as conditions, instantiate `GraphMachine`, and pass method references (including those wrapped with `functools.partial`) within transition definitions. The resulting graph is saved to a file. Depends on `transitions.extensions.GraphMachine` and `functools.partial`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_77\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions import GraphMachine\nfrom functools import partial\n\n\nclass Model:\n\n    def clear_state(self, deep=False, force=False):\n        print(\"Clearing state ...\")\n        return True\n\n\nmodel = Model()\nmachine = GraphMachine(model=model, states=['A', 'B', 'C'],\n                       transitions=[\n                           {'trigger': 'clear', 'source': 'B', 'dest': 'A', 'conditions': model.clear_state},\n                           {'trigger': 'clear', 'source': 'C', 'dest': 'A',\n                            'conditions': partial(model.clear_state, False, force=True)},\n                       ],\n                       initial='A', show_conditions=True)\n\nmodel.get_graph().draw('my_state_diagram.png', prog='dot')\n```\n\n----------------------------------------\n\nTITLE: Adding Reflexive Transitions From Multiple States in Python 'transitions' Library\nDESCRIPTION: Shows how to create reflexive transitions (where source and destination states are identical) for multiple states at once by setting destination to '='. Includes a trigger and optional callback executed after each trigger. This approach streamlines adding identical self-transitions across several states.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nmachine.add_transition('touch', ['liquid', 'gas', 'plasma'], '=', after='change_shape')\n```\n\n----------------------------------------\n\nTITLE: Adding 'during' Callback Support to PyTransitions Machine in Python\nDESCRIPTION: This snippet extends PyTransitions by introducing a 'during' callback feature called when no state transition has been successfully executed. It involves subclassing State as DuringState to parse and handle 'during' callbacks, subclassing Event as DuringEvent to detect failed transitions and invoke 'during', and subclassing Machine as DuringMachine to use the custom state and event classes. A sample model demonstrates dynamic and explicit callback assignments. Dependencies include the PyTransitions core modules. Inputs are state and event data; outputs are side-effect callback executions. This extension allows executing code during inactivity within states, useful for periodic actions or monitoring.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.core import Machine, State, Event, EventData, listify\n\n\nclass DuringState(State):\n\n    # add `on_during` to the dynamic callback methods\n    # this way on_during_<state> can be recognized by `Machine`\n    dynamic_methods = State.dynamic_methods + ['on_during']\n    \n    # parse 'during' and remove the keyword before passing the rest along to state\n    def __init__(self, *args, **kwargs):\n        during = kwargs.pop('during', [])\n        self.on_during = listify(during)\n        super(DuringState, self).__init__(*args, **kwargs)\n\n    def during(self, event_data):\n        for handle in self.on_during:\n            event_data.machine.callback(handle, event_data)\n\n\nclass DuringEvent(Event):\n\n    def _trigger(self, model, *args, **kwargs):\n        # a successful transition returns `res=True` if res is False, we know that\n        # no transition has been executed\n        res = super(DuringEvent, self)._trigger(model, *args, **kwargs)\n        if res is False:\n            state = self.machine.get_state(model.state)\n            event_data = EventData(state, self, self.machine, model, args=args, kwargs=kwargs)\n            event_data.result = res\n            state.during(event_data)\n        return res\n\n\nclass DuringMachine(Machine):\n    # we need to override the state and event classes used by `Machine`\n    state_cls = DuringState\n    event_cls = DuringEvent\n\n\nclass Model:\n\n    def on_during_A(self):\n        print(\"Dynamically assigned callback\")\n\n    def another_callback(self):\n        print(\"Explicitly assigned callback\")\n\n\nmodel = Model()\nmachine = DuringMachine(model=model, states=[{'name': 'A', 'during': 'another_callback'}, 'B'],\n                        transitions=[['go', 'B', 'A']], initial='A', ignore_invalid_triggers=True)\nmachine.add_transition('test', source='A', dest='A', conditions=lambda: False)\n\nassert not model.go()\nassert not model.test()\n```\n\n----------------------------------------\n\nTITLE: Implementing Threadsafe State Machines with LockedMachine in Python\nDESCRIPTION: Demonstrates the use of `LockedMachine` from `transitions.extensions` to create a thread-safe state machine where function access is synchronized using reentrant locks. It shows how triggering transitions from different threads is serialized, but warns that direct attribute manipulation is not synchronized and can cause issues. Depends on `transitions.extensions.LockedMachine`, `threading.Thread`, and `time`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_78\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions import LockedMachine\nfrom threading import Thread\nimport time\n\nstates = ['A', 'B', 'C']\nmachine = LockedMachine(states=states, initial='A')\n\n# let us assume that entering B will take some time\nthread = Thread(target=machine.to_B)\nthread.start()\ntime.sleep(0.01) # thread requires some time to start\nmachine.to_C() # synchronized access; won't execute before thread is done\n# accessing attributes directly\nthread = Thread(target=machine.to_B)\nthread.start()\nmachine.new_attrib = 42 # not synchronized! will mess with execution order\n```\n\n----------------------------------------\n\nTITLE: Customizing Nested State Separator Python\nDESCRIPTION: Illustrates how to change the separator character used for concatenating nested state names in `HierarchicalMachine` by modifying `NestedState.separator`. Demonstrates defining states and transitions using the newly defined separator. Requires `HierarchicalMachine` and `NestedState`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_62\n\nLANGUAGE: Python\nCODE:\n```\nfrom transitions.extensions import HierarchicalMachine\nfrom transitions.extensions.nesting import NestedState\nNestedState.separator = '↦'\nstates = ['A', 'B',\n  {'name': 'C', 'children':['1', '2',\n    {'name': '3', 'children': ['a', 'b', 'c']}\n  ]}\n]\n\ntransitions = [\n    ['reset', 'C', 'A'],\n    ['reset', 'C↦2', 'C']  # overwriting parent reset\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Logging for Transitions State Machine Events\nDESCRIPTION: Shows how to enable and configure rudimentary logging provided by Transitions using Python's built-in `logging` module. The log level is set to DEBUG globally but limited to INFO for the 'transitions' logger to capture state changes, transition triggers, and conditional checks as INFO events output to standard output. This setup is useful for monitoring state machine behaviors during development or debugging without adding extra instrumentation code.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_51\n\nLANGUAGE: python\nCODE:\n```\n# Set up logging; The basic log level will be DEBUG\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n# Set transitions' log level to INFO; DEBUG messages will be omitted\nlogging.getLogger('transitions').setLevel(logging.INFO)\n\n# Business as usual\nmachine = Machine(states=states, transitions=transitions, initial='solid')\n...\n```\n\n----------------------------------------\n\nTITLE: Generating Static Base Model Classes from Machine Configurations Using Python Transitions\nDESCRIPTION: Introduces the `generate_base_model` utility from `transitions.experimental.utils`, which creates a string representation of a base model class source code based on a machine configuration dictionary. This supports complex scenarios where statically defined models with callbacks and event methods are preferred, facilitating integration with type checking and IDEs. The snippet outputs the generated class definition to a Python file.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.experimental.utils import generate_base_model\nsimple_config = {\n    \"states\": [\"A\", \"B\"],\n    \"transitions\": [\n        [\"go\", \"A\", \"B\"],\n    ],\n    \"initial\": \"A\",\n    \"before_state_change\": \"call_this\",\n    \"model_override\": True,\n} \n\nclass_definition = generate_base_model(simple_config)\nwith open(\"base_model.py\", \"w\") as f:\n    f.write(class_definition)\n```\n\n----------------------------------------\n\nTITLE: State Type Requirement for Hierarchical Machine Python\nDESCRIPTION: Emphasizes the requirement that states used with `HierarchicalMachine` must be instances of `NestedState` (or a derived class) from `transitions.extensions.nesting`. Demonstrates that attempting to add a standard `transitions.State` object will fail. Requires `HierarchicalMachine` and `NestedState`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_61\n\nLANGUAGE: Python\nCODE:\n```\nfrom transitions.extensions.nesting import HierarchicalMachine, NestedState\nfrom transitions import  State\nm = HierarchicalMachine(states=['A'], initial='initial')\nm.add_state('B')  # fine\nm.add_state({'name': 'C'})  # also fine\nm.add_state(NestedState('D'))  # fine as well\nm.add_state(State('E'))  # does not work!\n```\n\n----------------------------------------\n\nTITLE: Remapping State Transitions in Nested State Machines\nDESCRIPTION: Shows how to use the 'remap' feature to make a nested state machine return to a parent state after reaching a specific state, allowing for better state flow control between hierarchies.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_70\n\nLANGUAGE: python\nCODE:\n```\nstates = ['waiting', 'collecting', {'name': 'counting', 'children': counter, 'remap': {'done': 'waiting'}}]\n\n... # same as above\n\ncollector.increase() # counting_3\ncollector.done()\ncollector.state\n>>> 'waiting' # be aware that 'counting_done' will be removed from the state machine\n```\n\n----------------------------------------\n\nTITLE: Saving Generated State Diagrams to Files or Streams\nDESCRIPTION: Shows how to save generated state diagrams to files or binary streams using different output methods with GraphMachine in the transitions library.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_75\n\nLANGUAGE: python\nCODE:\n```\nimport io\n\nwith open('a_graph.png', 'bw') as f:\n    # you need to pass the format when you pass objects instead of filenames.\n    m.get_graph().draw(f, format=\"png\", prog='dot')\n```\n\n----------------------------------------\n\nTITLE: Configuring Hierarchical State Machines with Dictionary Definitions\nDESCRIPTION: Shows how to define nested state machine configurations using dictionaries, which can be easily stored and loaded via JSON or YAML for complex state machine definitions.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_72\n\nLANGUAGE: python\nCODE:\n```\ncounter_conf = {\n    'name': 'counting',\n    'states': ['1', '2', '3', 'done'],\n    'transitions': [\n        ['increase', '1', '2'],\n        ['increase', '2', '3'],\n        ['decrease', '3', '2'],\n        ['decrease', '2', '1'],\n        ['done', '3', 'done'],\n        ['reset', '*', '1']\n    ],\n    'initial': '1'\n}\n\ncollector_conf = {\n    'name': 'collector',\n    'states': ['waiting', 'collecting', counter_conf],\n    'transitions': [\n        ['collect', '*', 'collecting'],\n        ['wait', '*', 'waiting'],\n        ['count', 'collecting', 'counting']\n    ],\n    'initial': 'waiting'\n}\n\ncollector = HierarchicalMachine(**collector_conf)\ncollector.collect()\ncollector.count()\ncollector.increase()\nassert collector.is_counting_2()\n```\n\n----------------------------------------\n\nTITLE: Customizing State Machine Graph Styling with GraphMachine and pygraphviz in Python\nDESCRIPTION: This code snippet demonstrates how to customize the visual styling of state machine graphs using the transitions library's GraphMachine extension combined with pygraphviz. It defines a CustomGraphMachine class that overrides default graph direction and resets style attributes for nodes and edges, using deepcopy and defaultdict to manage styling dictionaries. The snippet also shows directly modifying returned pygraphviz AGraph object's node and edge attributes (e.g., fill color and edge color), changing individual edge colors, passing layout engine arguments for Graphviz, and obtaining the raw graph source as a string. Required dependencies include transitions.extensions.GraphMachine, pygraphviz, and standard Python libraries.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom copy import deepcopy\nfrom transitions.extensions import GraphMachine\nfrom collections import defaultdict\n\nstates = ['A', 'B', 'C', 'D']\ntransitions = [\n    {'trigger': 'go', 'source': 'A', 'dest': 'B'},\n    {'trigger': 'go', 'source': 'B', 'dest': 'C'},\n    {'trigger': 'back', 'source': 'C', 'dest': 'B'},\n    {'trigger': 'back', 'source': 'B', 'dest': 'A'},\n    {'trigger': 'forward', 'source': 'A', 'dest': 'C'},\n    {'trigger': 'forward', 'source': 'C', 'dest': 'D'},\n    {'trigger': 'backward', 'source': 'D', 'dest': 'C'},\n    {'trigger': 'backward', 'source': 'C', 'dest': 'A'}\n]\n\nclass CustomGraphMachine(GraphMachine):\n\n    # Override Graphmachine's default styling for nodes and edges [1]\n    # Copy default graph attributes but change direction to top to bottom\n    machine_attributes = deepcopy(GraphMachine.machine_attributes)\n    machine_attributes[\"rankdir\"] = \"TB\"  # Left to right layout\n\n     # Reset styling\n    style_attributes = defaultdict(dict) \n    style_attributes[\"node\"][\"default\"] = { \"fontname\": \"arial\", \"shape\": \"circle\"}\n    style_attributes[\"edge\"][\"default\"] = { \"fontname\": \"arial\" }\n\n\nmachine = CustomGraphMachine(states=states, transitions=transitions, initial='A', title=\"State Diagram\")\ngraph = machine.get_graph()\n# directly modify the graph's attributes (works only with pygraphviz) [2]\n# note: this will only work for attributes that haven't been set by the GraphMachine\ngraph.node_attr.update(fillcolor=\"turquoise\")\ngraph.edge_attr.update(color=\"blue\")\n# modify the attributes of a specific edge\ngraph.edges([\"A\", \"B\"])[0].attr.update(color=\"red\")\n# pass additional arguments to the graphviz layout engine via args [3]\ngraph.draw('state_diagram.png', prog='dot', args='-Gnodesep=1')\n# get the graphs source code [4]\nsource = graph.string()\n```\n\n----------------------------------------\n\nTITLE: Creating Machine Without Default Initial State and Adding Models in Python Transitions\nDESCRIPTION: Explains the behavior when initializing a machine with `initial=None` to disable the automatic addition of the default 'initial' state. Models added afterwards must be given explicit initial states to avoid runtime errors. The snippet demonstrates adding a model without specifying an initial state results in a `MachineError`, but adding with an explicit `initial` succeeds. This pattern requires careful management of initial states per model and is useful when initial states vary between models.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nmachine = Machine(model=None, states=states, transitions=transitions, initial=None)\n\nmachine.add_model(Matter())\n>>> \"MachineError: No initial state configured for machine, must specify when adding model.\"\nmachine.add_model(Matter(), initial='liquid')\n```\n\n----------------------------------------\n\nTITLE: Initializing State Machine with Model Python\nDESCRIPTION: Demonstrates creating a basic `transitions.Machine` instance by passing a custom model object. The model is expected to inherit from `BaseModel` and may define methods that serve as callbacks or triggers for state transitions. Requires `transitions` and a `base_model` class.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_55\n\nLANGUAGE: Python\nCODE:\n```\n# ... in another file\nfrom transitions import Machine\nfrom base_model import BaseModel\n\nclass Model(BaseModel):  #  call_this will be an abstract method in BaseModel\n\n    def call_this(self) -> None:\n        # do something  \n\nmodel = Model()\nmachine = Machine(model, **simple_config)\n```\n\n----------------------------------------\n\nTITLE: Using Model Override to Limit Dynamically Added Methods for Typing Compatibility in Python Transitions\nDESCRIPTION: Explains the use of the `model_override` parameter in the Machine constructor to prevent Transitions from adding all convenience trigger methods dynamically to the model, helping static type checkers avoid unresolved attribute errors. Example code contrasts dynamic method addition in a plain model with limited override mode where only already defined methods are kept. This requires predefined method signatures on the model to enable better type checking while still supporting Transitions functionality.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine\n\n# Dynamic assignment\nclass Model:\n    pass\n\nmodel = Model()\ndefault_machine = Machine(model, states=[\"A\", \"B\"], transitions=[[\"go\", \"A\", \"B\"]], initial=\"A\")\nprint(model.__dict__.keys())  # all convenience functions have been assigned\n# >> dict_keys(['trigger', 'to_A', 'may_to_A', 'to_B', 'may_to_B', 'go', 'may_go', 'is_A', 'is_B', 'state'])\nassert model.is_A()  # Unresolved attribute reference 'is_A' for class 'Model'\n\n\n# Predefined assigment: We are just interested in calling our 'go' event and will trigger the other events by name\nclass PredefinedModel:\n    # state (or another parameter if you set 'model_attribute') will be assigned anyway \n    # because we need to keep track of the model's state\n    state: str\n\n    def go(self) -> bool:\n        raise RuntimeError(\"Should be overridden!\")\n\n    def trigger(self, trigger_name: str) -> bool:\n        raise RuntimeError(\"Should be overridden!\")\n\n\nmodel = PredefinedModel()\noverride_machine = Machine(model, states=[\"A\", \"B\"], transitions=[[\"go\", \"A\", \"B\"]], initial=\"A\", model_override=True)\nprint(model.__dict__.keys())\n# >> dict_keys(['trigger', 'go', 'state'])\nmodel.trigger(\"to_B\")\nassert model.state == \"B\"\n```\n\n----------------------------------------\n\nTITLE: Generating State Diagrams as Binary Data with transitions in Python\nDESCRIPTION: Demonstrates how to generate a state machine graph visualization and output it as binary data. The graph can be written to a binary stream (like `io.BytesIO`) or obtained directly as a binary string by passing `None` as the first argument to `draw()`. Requires an existing state machine object (`m`) and the `io` module.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_76\n\nLANGUAGE: python\nCODE:\n```\n# you can pass a (binary) stream too\nb = io.BytesIO()\nm.get_graph().draw(b, format=\"png\", prog='dot')\n\n# or just handle the binary string yourself\nresult = m.get_graph().draw(None, format=\"png\", prog='dot')\nassert result == b.getvalue()\n```\n\n----------------------------------------\n\nTITLE: Creating Extended Machine Classes via Factory Python\nDESCRIPTION: Explains how to use `transitions.extensions.MachineFactory.get_predefined` to obtain `Machine` classes pre-configured with specific extensions (e.g., graph, nested, locked, asyncio). Demonstrates creating instances of these extended classes. Requires `transitions.extensions`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_57\n\nLANGUAGE: Python\nCODE:\n```\nfrom transitions.extensions import MachineFactory\n\n# create a machine with mixins\ndiagram_cls = MachineFactory.get_predefined(graph=True)\nnested_locked_cls = MachineFactory.get_predefined(nested=True, locked=True)\nasync_machine_cls = MachineFactory.get_predefined(asyncio=True)\n\n# create instances from these classes\n# instances can be used like simple machines\nmachine1 = diagram_cls(model, state, transitions)\nmachine2 = nested_locked_cls(model, state, transitions)\n```\n\n----------------------------------------\n\nTITLE: Deep Copying States and Transitions for Independent State Machines\nDESCRIPTION: Demonstrates how to maintain pre-0.8.0 behavior by creating copies of states and transitions, ensuring changes in one state machine won't affect others using the same state definitions.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_71\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions.nesting import NestedState\nfrom copy import deepcopy\n\n# ... configuring and creating counter\n\ncounting_state = NestedState(name=\"counting\", initial='1')\ncounting_state.states = deepcopy(counter.states)\ncounting_state.events = deepcopy(counter.events)\n\nstates = ['waiting', 'collecting', counting_state]\n```\n\n----------------------------------------\n\nTITLE: Importing Specific Extended Machine Class Python\nDESCRIPTION: Demonstrates the alternative method to obtain a feature-rich machine by directly importing the specific extended class from `transitions.extensions`, such as `LockedHierarchicalGraphMachine`. Shows instantiating the imported class. Requires the specific extended class from `transitions.extensions`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_58\n\nLANGUAGE: Python\nCODE:\n```\nfrom transitions.extensions import LockedHierarchicalGraphMachine as LHGMachine\n\nmachine = LHGMachine(model, states, transitions)\n```\n\n----------------------------------------\n\nTITLE: Applying Per-Model Context Managers with transitions in Python\nDESCRIPTION: Illustrates how to add model-specific context managers to a `Machine` instance (including `LockedMachine`). This is done using the `add_model` method with the `model_context` parameter, allowing finer-grained locking or context management for individual models associated with the machine. Requires an existing machine instance and a model object. Depends on `threading.RLock`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_80\n\nLANGUAGE: python\nCODE:\n```\nlock3 = RLock()\n\nmachine.add_model(model, model_context=lock3)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Default (Non-Queued) Transition Behavior in pytransitions (Python)\nDESCRIPTION: Defines a `pytransitions` state machine and callbacks (`go_to_C`, `after_advance`, `entering_C`) to show the default execution order where nested transitions initiated from `on_enter` callbacks (like `go_to_C` called from `on_enter_B`) execute immediately, potentially before the `after` callback (`after_advance`) of the original transition (`advance`) completes. This demonstrates the default, potentially non-intuitive, execution order without queuing.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ndef go_to_C():\n    global machine\n    machine.to_C()\n\ndef after_advance():\n    print(\"I am in state B now!\")\n\ndef entering_C():\n    print(\"I am in state C now!\")\n\nstates = ['A', 'B', 'C']\nmachine = Machine(states=states, initial='A')\n\n# we want a message when state transition to B has been completed\nmachine.add_transition('advance', 'A', 'B', after=after_advance)\n\n# call transition from state B to state C\nmachine.on_enter_B(go_to_C)\n\n# we also want a message when entering state C\nmachine.on_enter_C(entering_C)\nmachine.advance()\n>>> 'I am in state C now!'\n>>> 'I am in state B now!' # what?\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous State Machines with transitions AsyncMachine in Python\nDESCRIPTION: This snippet defines two asynchronous state machine classes, Machine1 and Machine2, using the AsyncMachine extension from the transitions library. Machine1 simulates a heavy processing callback before transitioning from 'off' to 'started' asynchronously using await asyncio.sleep. Machine2 depends on Machine1's state, asynchronously waiting until Machine1 has started before continuing. The snippet demonstrates orchestrating parallel asynchronous state transitions using asyncio.gather, ensuring callbacks complete in order while supporting concurrency. Dependencies on Python's asyncio and transitions.extensions.asyncio.AsyncMachine are required.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions.asyncio import AsyncMachine\nimport asyncio\n\nstates = ['off', 'started']\n\n\nclass Machine1(AsyncMachine):\n\n    transitions = [{'trigger': 'boot', 'source': 'off', 'dest': 'started', 'before': 'heavy_processing'}]\n\n    def __init__(self):\n        super(Machine1, self).__init__(states=states, transitions=self.transitions, initial='off')\n\n    async def heavy_processing(self):\n        # we need to do some heavy lifting before we can proceed with booting\n        await asyncio.sleep(0.5)\n        print(\"Processing done!\")\n\n\nclass Machine2(AsyncMachine):\n\n    transitions = [['boot', 'off', 'started']]\n\n    def __init__(self, dependency):\n        super(Machine2, self).__init__(states=states, transitions=self.transitions, initial='off')\n        self.dependency = dependency\n\n    async def on_enter_started(self):\n        while not self.dependency.is_started():\n            print(\"Waiting for dependency to be ready...\")\n            await asyncio.sleep(0.1)\n        print(\"Machine2 up and running\")\n\n\nmachine1 = Machine1()\nmachine2 = Machine2(machine1)\nasyncio.get_event_loop().run_until_complete(asyncio.gather(machine1.boot(), machine2.boot()))\nassert machine1.state == machine2.state\n```\n\n----------------------------------------\n\nTITLE: Using Asynchronous Callbacks with AsyncMachine in Python\nDESCRIPTION: Demonstrates `AsyncMachine` from `transitions.extensions.asyncio` for handling asynchronous callbacks in state transitions (requires Python 3.7+). It shows defining an async model with both synchronous (`prepare_model`, `sync_before_change`, `after_change`) and asynchronous (`before_change`) methods, configuring transitions to use them, and running the event loop using `asyncio`. Note that synchronous callbacks blocking the event loop should generally be avoided. Depends on `transitions.extensions.asyncio.AsyncMachine`, `asyncio`, and `time`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_81\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions.asyncio import AsyncMachine\nimport asyncio\nimport time\n\n\nclass AsyncModel:\n\n    def prepare_model(self):\n        print(\"I am synchronous.\")\n        self.start_time = time.time()\n\n    async def before_change(self):\n        print(\"I am asynchronous and will block now for 100 milliseconds.\")\n        await asyncio.sleep(0.1)\n        print(\"I am done waiting.\")\n\n    def sync_before_change(self):\n        print(\"I am synchronous and will block the event loop (what I probably shouldn't)\")\n        time.sleep(0.1)\n        print(\"I am done waiting synchronously.\")\n\n    def after_change(self):\n        print(f\"I am synchronous again. Execution took {int((time.time() - self.start_time) * 1000)} ms.\")\n\n\ntransition = dict(trigger=\"start\", source=\"Start\", dest=\"Done\", prepare=\"prepare_model\",\n                  before=[\"before_change\"] * 5 + [\"sync_before_change\"],\n                  after=\"after_change\")  # execute before function in asynchronously 5 times\nmodel = AsyncModel()\nmachine = AsyncMachine(model, states=[\"Start\", \"Done\"], transitions=[transition], initial='Start')\n\nasyncio.get_event_loop().run_until_complete(model.start())\n# >>> I am synchronous.\n#     I am asynchronous and will block now for 100 milliseconds.\n#     I am asynchronous and will block now for 100 milliseconds.\n#     I am asynchronous and will block now for 100 milliseconds.\n#     I am asynchronous and will block now for 100 milliseconds.\n#     I am asynchronous and will block now for 100 milliseconds.\n#     I am synchronous and will block the event loop (what I probably shouldn't)\n#     I am done waiting synchronously.\n#     I am done waiting.\n#     I am done waiting.\n#     I am done waiting.\n#     I am done waiting.\n#     I am done waiting.\n#     I am synchronous again. Execution took 101 ms.\nassert model.is_Done()\n```\n\n----------------------------------------\n\nTITLE: Using AsyncTimeout with AsyncMachine in Python\nDESCRIPTION: This code demonstrates how to use the `AsyncTimeout` feature with `transitions.extensions.asyncio.AsyncMachine`. It decorates an `AsyncMachine` subclass with `@add_state_features(AsyncTimeout)`, defines states including one with `timeout` and `on_timeout`, and uses `asyncio.run` to test the asynchronous timeout behavior. Passing `queued=True` to the machine constructor is recommended to avoid race conditions. Requires `asyncio`, `transitions.extensions.states`, and `transitions.extensions.asyncio`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_86\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom transitions.extensions.states import add_state_features\nfrom transitions.extensions.asyncio import AsyncTimeout, AsyncMachine\n\n@add_state_features(AsyncTimeout)\nclass TimeoutMachine(AsyncMachine):\n    pass\n\nstates = ['A', {'name': 'B', 'timeout': 0.2, 'on_timeout': 'to_C'}, 'C']\nm = TimeoutMachine(states=states, initial='A', queued=True)  # see remark below\nasyncio.run(asyncio.wait([m.to_B(), asyncio.sleep(0.1)]))\nassert m.is_B()  # timeout shouldn't be triggered\nasyncio.run(asyncio.wait([m.to_B(), asyncio.sleep(0.3)]))\nassert m.is_C()   # now timeout should have been processed\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous State Machines with AsyncMachine Extension\nDESCRIPTION: Shows how to create asynchronous state machines using the AsyncMachine extension. The example creates two dancers with different beat times who perform coordinated steps through state transitions with asyncio.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Playground.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions.asyncio import AsyncMachine\nimport asyncio\n\nclass Dancer:\n    \n    states = ['start', 'left_food_left', 'left', 'right_food_right']\n    \n    def __init__(self, name, beat):\n        self.my_name = name\n        self.my_beat = beat\n        self.moves_done = 0\n        \n    async def on_enter_start(self):\n        self.moves_done += 1\n        \n    async def wait(self):\n        print(f'{self.my_name} stepped {self.state}')\n        await asyncio.sleep(self.my_beat)\n\n    async def dance(self):\n        while self.moves_done < 5:\n            await self.step()\n        \ndancer1 = Dancer('Tick', 1)\ndancer2 = Dancer('Tock', 1.1)\n\nm = AsyncMachine(model=[dancer1, dancer2], states=Dancer.states, initial='start', after_state_change='wait')\nm.add_ordered_transitions(trigger='step')\n\n# it starts okay but becomes quite a mess\n_ = await asyncio.gather(dancer1.dance(), dancer2.dance())\n```\n\n----------------------------------------\n\nTITLE: Handling Concurrent Events in AsyncMachine using Contextvars (Python 3.7+)\nDESCRIPTION: Illustrates how `AsyncMachine` leverages `contextvars` (Python 3.7+) to correctly handle concurrent events targeting potentially different machines or the same machine. It shows a scenario where one transition (`m2.go`) is initiated with a long-running `before` callback, and subsequent events (`m1.go`, `m2.fix`) are triggered. `contextvars` ensures that `m1.go` completes its transition sequence and `m2.fix` correctly interrupts the ongoing `m2.go` transition without affecting `m1`. Depends on `transitions.extensions.asyncio.AsyncMachine` and `asyncio`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_82\n\nLANGUAGE: python\nCODE:\n```\nasync def await_never_return():\n    await asyncio.sleep(100)\n    raise ValueError(\"That took too long!\")\n\nasync def fix():\n    await m2.fix()\n\nm1 = AsyncMachine(states=['A', 'B', 'C'], initial='A', name=\"m1\")\nm2 = AsyncMachine(states=['A', 'B', 'C'], initial='A', name=\"m2\")\nm2.add_transition(trigger='go', source='A', dest='B', before=await_never_return)\nm2.add_transition(trigger='fix', source='A', dest='C')\nm1.add_transition(trigger='go', source='A', dest='B', after='go')\nm1.add_transition(trigger='go', source='B', dest='C', after=fix)\nasyncio.get_event_loop().run_until_complete(asyncio.gather(m2.go(), m1.go()))\n\nassert m1.state == m2.state\n```\n\n----------------------------------------\n\nTITLE: Defining Custom State Classes in Python\nDESCRIPTION: This example illustrates how to integrate a custom state class (`MyState`) into a `transitions.Machine`. It presents two approaches: assigning the custom class to the `state_cls` attribute of a `Machine` subclass (`CustomMachine`) or overriding the `_create_state` method (`VerboseMachine`) for more control over state creation. Requires `transitions`.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_85\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine, State\n\nclass MyState(State):\n    pass\n\nclass CustomMachine(Machine):\n    # Use MyState as state class\n    state_cls = MyState\n\n\nclass VerboseMachine(Machine):\n\n    # `Machine._create_state` is a class method but we can\n    # override it to be an instance method\n    def _create_state(self, *args, **kwargs):\n        print(\"Creating a new state with machine '{0}'\".format(self.name))\n        return MyState(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Comparing AsyncMachine Queue Modes ('True' vs 'model') in Python\nDESCRIPTION: Conceptually demonstrates the difference in execution order between `AsyncMachine(queued=True)` (default global queue) and `AsyncMachine(queued='model')` (per-model queues) when processing concurrent events for multiple models using `asyncio.gather`. With `queued=True`, events are processed strictly sequentially across all models. With `queued='model'`, events for different models can run concurrently, while events for the same model remain queued. Error handling also differs: an exception with `queued=True` clears the entire queue, while with `queued='model'`, only the specific model's queue is cleared. Depends on `asyncio` and `AsyncMachine` concepts.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_83\n\nLANGUAGE: python\nCODE:\n```\n# Conceptual Example - Illustrates execution order differences\n\n# Scenario 1: Basic concurrent events\nasyncio.gather(model1.event1(), model1.event2(), model2.event1())\n# execution order with AsyncMachine(queued=True)\n# model1.event1 -> model1.event2 -> model2.event1\n# execution order with AsyncMachine(queued='model')\n# (model1.event1, model2.event1) -> model1.event2\n\n# Scenario 2: Concurrent events with an error\nasyncio.gather(model1.event1(), model1.error(), model1.event3(), model2.event1(), model2.event2(), model2.event3())\n# execution order with AsyncMachine(queued=True)\n# model1.event1 -> model1.error # Queue cleared\n# execution order with AsyncMachine(queued='model')\n# (model1.event1, model2.event1) -> (model1.error, model2.event2) -> model2.event3 # model1 queue cleared, model2 continues\n```\n\n----------------------------------------\n\nTITLE: Generating Mermaid State Diagrams in Python with transitions\nDESCRIPTION: Shows how to create a mermaid-based state diagram using the HierarchicalGraphMachine extension, demonstrating state hierarchy, final states, and parallel states in a visual format.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_73\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions.diagrams import HierarchicalGraphMachine\nimport pyperclip\n\nstates = ['A', 'B', {'name': 'C',\n                     'final': True,\n                     'parallel': [{'name': '1', 'children': ['a', {\"name\": \"b\", \"final\": True}],\n                                   'initial': 'a',\n                                   'transitions': [['go', 'a', 'b']]},\n                                  {'name': '2', 'children': ['a', {\"name\": \"b\", \"final\": True}],\n                                   'initial': 'a',\n                                   'transitions': [['go', 'a', 'b']]}]}]\ntransitions = [['reset', 'C', 'A'], [\"init\", \"A\", \"B\"], [\"do\", \"B\", \"C\"]]\n\n\nm = HierarchicalGraphMachine(states=states, transitions=transitions, initial=\"A\", show_conditions=True,\n                             title=\"Mermaid\", graph_engine=\"mermaid\", auto_transitions=False)\nm.init()\n\npyperclip.copy(m.get_graph().draw(None))  # using pyperclip for convenience\nprint(\"Graph copied to clipboard!\")\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies for pytransitions\nDESCRIPTION: Lists the external Python packages required for the pytransitions library to function properly, including 'six' for Python 2/3 compatibility and 'graphviz' for graph visualization capabilities.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/binder/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nsix\ngraphviz\n```\n\n----------------------------------------\n\nTITLE: Implementing Final State Callbacks in Parallel HierarchicalMachine Using Python\nDESCRIPTION: Implements a parallel hierarchical state machine with states marked as final and registers on_final callback functions. The callback triggers when a final state is entered either because the state itself is final or all its substates are final. Demonstrates automatic final event propagation up the state hierarchy, useful for coordinating processing where parallel substates collectively determine completion. Uses functools.partial to bind callbacks and shows how transitions progressing substates trigger the final state callbacks.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_68\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions.extensions import HierarchicalMachine\nfrom functools import partial\n\n# We initialize this parallel HSM in state A:\n#        / X\n#       /   / yI\n# A -> B - Y - yII [final]\n#        \\ Z - zI\n#            \\ zII [final]\n\ndef final_event_raised(name):\n    print(\"{} is final!\".format(name))\n\n\nstates = ['A', {'name': 'B', 'parallel': [{'name': 'X', 'final': True, 'on_final': partial(final_event_raised, 'X')},\n                                          {'name': 'Y', 'transitions': [['final_Y', 'yI', 'yII']],\n                                           'initial': 'yI',\n                                           'on_final': partial(final_event_raised, 'Y'),\n                                           'states':\n                                               ['yI', {'name': 'yII', 'final': True}]\n                                           },\n                                          {'name': 'Z', 'transitions': [['final_Z', 'zI', 'zII']],\n                                           'initial': 'zI',\n                                           'on_final': partial(final_event_raised, 'Z'),\n                                           'states':\n                                               ['zI', {'name': 'zII', 'final': True}]\n                                           },\n                                          ],\n                \"on_final\": partial(final_event_raised, 'B')}]\n\nmachine = HierarchicalMachine(states=states, on_final=partial(final_event_raised, 'Machine'), initial='A')\n# X will emit a final event right away\nmachine.to_B()\n# >>> X is final!\nprint(machine.state)\n# >>> ['B_X', 'B_Y_yI', 'B_Z_zI']\n# Y's substate is final now and will trigger 'on_final' on Y\nmachine.final_Y()\n# >>> Y is final!\nprint(machine.state)\n# >>> ['B_X', 'B_Y_yII', 'B_Z_zI']\n# Z's substate becomes final which also makes all children of B final and thus machine itself\nmachine.final_Z()\n# >>> Z is final!\n# >>> B is final!\n# >>> Machine is final!\n```\n\n----------------------------------------\n\nTITLE: Importing Six Python Compatibility Module\nDESCRIPTION: A simple import statement for the 'six' module, which provides utilities for writing code that works on both Python 2 and Python 3.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/requirements.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nsix\n```\n\n----------------------------------------\n\nTITLE: Loading state machine configuration with PyTransitions using YAML in Python\nDESCRIPTION: Illustrates how to load a PyTransitions state machine configuration from a YAML string using the pyyaml library. The YAML defines the machine's name, states (including states with on_enter callbacks), transitions, and initial state. The loaded configuration dictionary is augmented with a model instance and unpacked into a Machine constructor. The snippet demonstrates state change validation and invoking callbacks. Prerequisites include the PyTransitions package and PyYAML.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine\nimport yaml\n\n\nclass Model:\n\n    def say_hello(self, name):\n        print(f\"Hello {name}!\")\n\n        \nyaml_config = \"\"\"\n---\n\nname: \"MyMachine\"\n\nstates:\n  - \"A\"\n  - \"B\"\n  - name: \"C\"\n    on_enter: \"say_hello\"\n\ntransitions:\n  - [\"go\", \"A\", \"B\"]\n  - {trigger: \"hello\", source: \"*\", dest: \"C\"}\n\ninitial: \"A\"\n\"\"\"\n\nmodel = Model()\n\nconfig = yaml.safe_load(yaml_config)  \nconfig['model'] = model  # adding a model to the configuration\nm = Machine(**config)  # **config unpacks arguments as kwargs\nassert model.is_A()\nmodel.go()\nassert model.is_B()\nmodel.hello(\"world\")  # >>> Hello world!\nassert model.state == 'C'\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Transition Destinations with Custom PyTransitions Transition in Python\nDESCRIPTION: This snippet defines a custom Transition subclass, DependingTransition, that provides dynamic state transition destinations based on a function's return value. It accepts a dictionary mapping outcomes to target states and a 'depends_on' callable determining which destination to select at runtime. The DependingMachine subclass employs this transition class to add transitions that adapt destination states dynamically. The code demonstrates adding a 'shuffle' transition with multiple potential target states resolved by a user-defined function. This approach depends on PyTransitions and six (for string type checks). Inputs include the triggering event and function parameters; outputs are transitions to evaluated target states. It enables more flexible and context-sensitive state machines, though graph visualizations may not reflect all paths.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine, Transition\nfrom six import string_types\n\nclass DependingTransition(Transition):\n\n    def __init__(self, source, dest, conditions=None, unless=None, before=None,\n                 after=None, prepare=None, **kwargs):\n\n        self._result = self._dest = None\n        super(DependingTransition, self).__init__(source, dest, conditions, unless, before, after, prepare)\n        if isinstance(dest, dict):\n            try:\n                self._func = kwargs.pop('depends_on')\n            except KeyError:\n                raise AttributeError(\"A multi-destination transition requires a 'depends_on'\")\n        else:\n            # use base version in case transition does not need special handling\n            self.execute = super(DependingTransition, self).execute\n\n    def execute(self, event_data):\n        func = getattr(event_data.model, self._func) if isinstance(self._func, string_types) \\\n               else self._func\n        self._result = func(*event_data.args, **event_data.kwargs)\n        super(DependingTransition, self).execute(event_data)\n\n    @property\n    def dest(self):\n        return self._dest[self._result] if self._result is not None else self._dest\n\n    @dest.setter\n    def dest(self, value):\n        self._dest = value\n\n# subclass Machine to use DependingTransition instead of standard Transition\nclass DependingMachine(Machine):\n    transition_cls = DependingTransition\n    \n\ndef func(value):\n    return value\n\nm = DependingMachine(states=['A', 'B', 'C', 'D'], initial='A')\n# define a dynamic transition with a 'depends_on' function which will return the required value\nm.add_transition(trigger='shuffle', source='A', dest=({1: 'B', 2: 'C', 3: 'D'}), depends_on=func)\nm.shuffle(value=2)  # func returns 2 which makes the transition dest to be 'C'\nassert m.is_C()\n```\n\n----------------------------------------\n\nTITLE: Implementing dynamic state callbacks with PyTransitions for memory-limited Django usage in Python\nDESCRIPTION: Defines a DynamicState subclass of transitions.State that dynamically invokes on_enter and on_exit callbacks on models, circumventing the need to register models directly with the Machine and reducing memory footprint. The DynamicMachine subclass defines state_cls to use DynamicState, ensuring callbacks are invoked at state transitions via event_data. This pattern supports memory-limited environments where callback methods are resolved at runtime rather than statically bound. Dependencies include PyTransitions and Python's logging module.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import State\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass DynamicState(State):\n    \"\"\" Need to dynamically get the on_enter and on_exit callbacks since the\n        model can not be registered to the Machine due to Memory limitations\n    \"\"\"\n\n    def enter(self, event_data):\n        \"\"\" Triggered when a state is entered. \"\"\"\n        logger.debug(\"%sEntering state %s. Processing callbacks...\", event_data.machine.name, self.name)\n        if hasattr(event_data.model, f'on_enter_{self.name}'):\n            event_data.machine.callbacks([getattr(event_data.model, f'on_enter_{self.name}')], event_data)\n        logger.info(\"%sFinished processing state %s enter callbacks.\", event_data.machine.name, self.name)\n\n    def exit(self, event_data):\n        \"\"\" Triggered when a state is exited. \"\"\"\n        logger.debug(\"%sExiting state %s. Processing callbacks...\", event_data.machine.name, self.name)\n        if hasattr(event_data.model, f'on_exit_{self.name}'):\n            event_data.machine.callbacks([getattr(event_data.model, f'on_exit_{self.name}')], event_data)\n        logger.info(\"%sFinished processing state %s exit callbacks.\", event_data.machine.name, self.name)\n\n\nclass DynamicMachine(Machine):\n    \"\"\"Required to use DynamicState\"\"\"\n    state_cls = DynamicState\n\n```\n\n----------------------------------------\n\nTITLE: Return Value Behavior with Queued Transitions in pytransitions (Python)\nDESCRIPTION: Illustrates that when `queued=True` is set in a `pytransitions` `Machine`, triggering a transition (e.g., `machine.jump()`) always returns `True`, even if the transition's conditions (`will_fail`) will eventually cause it to fail during processing. This contrasts with non-queued mode (`queued=False`) where `False` is returned immediately if conditions are not met at the time of the call.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nmachine.add_transition('jump', 'A', 'C', conditions='will_fail')\n# ...\n# queued=False\nmachine.jump()\n>>> False\n# queued=True\nmachine.jump()\n>>> True\n```\n\n----------------------------------------\n\nTITLE: Implementing an Event Bus for Inter-dependent pytransitions Machines (Python)\nDESCRIPTION: Presents an event bus pattern as a solution for managing interactions between multiple `transitions` state machines without causing deadlocks. Includes `EventBus`, `Machine1`, and `Machine2` classes, demonstrating asynchronous-like communication via broadcasted events (`boot`, `Machine1Started`). Requires the `transitions` library and `logging`. Uses `queued=True` for sequential event processing per machine and `ignore_invalid_triggers=True` to handle events not relevant to a machine's current state.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import Machine\nimport logging\n\n\nclass EventBus:\n\n    def __init__(self):\n        self.members = []\n\n    def add_member(self, member):\n        \"\"\"Member can be a model or a machine acting as a model\"\"\"\n        # We decorate each member with an 'emit' function to fire events.\n        # EventBus will then broadcast that event to ALL members, including the one that triggered the event.\n        # Furthermore, we can pass a payload in case there is data that needs to be sent with an event.\n        setattr(member, 'emit', self.broadcast)\n        self.members.append(member)\n\n    def broadcast(self, event, payload=None):\n        for member in self.members:\n            member.trigger(event, payload)\n\n\n# Our machines can either be off or started\nstates = ['off', 'started']\n\n\nclass Machine1(Machine):\n\n    # this machine can only boot once.\n    transitions = [['boot', 'off', 'started']]\n\n    def __init__(self):\n        # we pass 'ignore_invalid_triggers' since a machine on an event bus might get events it cannot process\n        # right now and we do not want to throw an exception every time that happens.\n        # Furthermore, we will set 'queued=True' to process events sequentially instead of nested.\n        super(Machine1, self).__init__(states=states, transitions=self.transitions,\n                                       ignore_invalid_triggers=True, initial='off', queued=True)\n\n    def on_enter_started(self, payload=None):\n        print(\"Starting successful\")\n        # We emit out start event and attach ourselves as payload just in case\n        self.emit(\"Machine1Started\", self)\n\n\nclass Machine2(Machine):\n\n    # This machine can also reboot (boot from every state) but only when the 'ready' flag has been set.\n    # 'ready' is set once the event 'Machine1Started' has been processed (before the transition is from 'off' to 'on'\n    # is actually executed). Furthermore, we will also boot the machine when we catch that event.\n    transitions = [{'trigger': 'boot', 'source': '*', 'dest': 'started', 'conditions': 'ready'},\n                   {'trigger': 'Machine1Started', 'source': 'off', 'dest': 'started', 'before': 'on_machine1_started'}]\n\n    def __init__(self):\n        super(Machine2, self).__init__(states=states, transitions=self.transitions,\n                                       ignore_invalid_triggers=True, initial='off', queued=True)\n        self._ready = False\n\n    # Callbacks also work with properties. Passing the string 'ready' will evaluate this property\n    @property\n    def ready(self):\n        return self._ready\n\n    @ready.setter\n    def ready(self, value):\n        self._ready = value\n\n    def on_machine1_started(self, payload=None):\n        self.ready = True\n        print(\"I am ready now!\")\n\n    def on_enter_started(self, payload=None):\n        print(\"Booting successful\")\n\n\nlogging.basicConfig(level=logging.DEBUG)\nbus = EventBus()\nmachine1 = Machine1()\nmachine2 = Machine2()\nbus.add_member(machine2)\nbus.add_member(machine1)\nbus.broadcast('boot')\n# what will happen:\n# - bus will broadcast 'boot' event to machine2\n# - machine2 will attempt to boot but fail and return since ready is set to false\n# - bus will broadcast 'boot' event to machine1\n# - machine1 will boot and emit the 'Machine1Started'\n# - bus will broadcast 'Machine1Started' to machine2\n# - machine2 will handle the event, boot and return\n# - bus will broadcast 'Machine1Started' to machine1\n# - machine1 will add that event to its event queue\n# - bus broadcast of 'Machine1Started' returns\n# - machine1 is done with handling 'boot' and process the next event in the event queue\n# - machine1 cannot handle 'Machine1Started' and will ignore it\n# - bus broadcast of 'boot' returns\nassert machine1.state == machine2.state\nbus.broadcast('boot')\n# broadcast 'boot' event to all members:\n# - machine2 will reboot\n```\n\n----------------------------------------\n\nTITLE: Installing the `transitions` Library using pip\nDESCRIPTION: Installs the `transitions` Python library using the pip package manager. This is the standard method for adding the library to a Python environment.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\npip install transitions\n```\n\n----------------------------------------\n\nTITLE: Installing the `transitions` Library from Source\nDESCRIPTION: Installs the `transitions` library by running the `setup.py` script after cloning the repository. This method is used for development versions or when installing without pip.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/README.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\npython setup.py install\n```\n\n----------------------------------------\n\nTITLE: Customizing Method Assignment in pytransitions (Python)\nDESCRIPTION: Demonstrates how to force `transitions` to add trigger methods even if methods with the same name already exist in the model by overriding `Machine._checked_assignment`. Shows two approaches: `OverrideMachine` simply overwrites existing methods, while `CallingMachine` wraps the existing method and the new trigger method, enabling both to be executed. This is useful when default behavior (avoiding overwrite and emitting a warning) is not desired. Requires the `transitions` library.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom transitions import State, Machine\n\nclass StateMachineModel:\n\n    state = None\n\n    def __init__(self):\n        pass\n\n    def transition_one(self):\n        print('transitioning states...')\n\n    def transition_two(self):\n        print('transitioning states...')\n\n\nclass OverrideMachine(Machine):\n\n    def _checked_assignment(self, model, name, func):\n        setattr(model, name, func)\n\n\nclass CallingMachine(Machine):\n\n    def _checked_assignment(self, model, name, func):\n        if hasattr(model, name):\n            predefined_func = getattr(model, name)\n            def nested_func(*args, **kwargs):\n                predefined_func()\n                func(*args, **kwargs)\n            setattr(model, name, nested_func)\n        else:\n            setattr(model, name, func)\n\n\nstates = [State(name='A'), State(name='B'), State(name='C'), State(name='D')]\ntransitions = [\n    {'trigger': 'transition_one', 'source': 'A', 'dest': 'B'},\n    {'trigger': 'transition_two', 'source': 'B', 'dest': 'C'},\n    {'trigger': 'transition_three', 'source': 'C', 'dest': 'D'}\n]\nstate_machine_model = StateMachineModel()\n\nprint('OverrideMachine ...')\nstate_machine = OverrideMachine(model=state_machine_model, states=states, transitions=transitions, initial=states[0])\nprint('state_machine_model (current state): %s' % state_machine_model.state)\nstate_machine_model.transition_one()\nprint('state_machine_model (current state): %s' % state_machine_model.state)\nstate_machine_model.transition_two()\nprint('state_machine_model (current state): %s' % state_machine_model.state)\n\nprint('\\nCallingMachine ...')\nstate_machine_model = StateMachineModel()\nstate_machine = CallingMachine(model=state_machine_model, states=states, transitions=transitions, initial=states[0])\nprint('state_machine_model (current state): %s' % state_machine_model.state)\nstate_machine_model.transition_one()\nprint('state_machine_model (current state): %s' % state_machine_model.state)\nstate_machine_model.transition_two()\nprint('state_machine_model (current state): %s' % state_machine_model.state)\n```\n\n----------------------------------------\n\nTITLE: Illustrating Deadlock Potential in pytransitions Callbacks (Python)\nDESCRIPTION: Demonstrates a common anti-pattern where a callback (`on_enter_state`) blocks execution while waiting indefinitely for an external event using `time.sleep` within a `while` loop. This blocking behavior within a sequential callback processor like `transitions.Machine` can prevent other events from being processed, potentially leading to deadlocks, especially in systems with multiple interacting state machines.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/examples/Frequently asked questions.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass Model:\n    def on_enter_state(self):\n        while not event:\n            time.sleep(1)\n```\n\n----------------------------------------\n\nTITLE: Declaring Graph Visualization Dependencies\nDESCRIPTION: Lists `pygraphviz` and `graphviz` as required packages. These libraries enable the generation of visual diagrams for state machines created with pytransitions. `graphviz` provides the core graph layout engine, while `pygraphviz` acts as the Python interface.\nSOURCE: https://github.com/pytransitions/transitions/blob/master/requirements_diagrams.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npygraphviz\ngraphviz\n```"
  }
]