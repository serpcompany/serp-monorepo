[
  {
    "owner": "swiftlang",
    "repo": "swift-testing",
    "content": "TITLE: Migrating Conditional Test Execution in Swift\nDESCRIPTION: This snippet shows how to migrate from XCTest's XCTSkip and related functions to the new framework's ConditionTrait for controlling test execution. The new approach allows for more declarative test and suite-level execution control.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nclass FoodTruckTests: XCTestCase {\n  func testArepasAreTasty() throws {\n    try XCTSkipIf(CashRegister.isEmpty)\n    try XCTSkipUnless(FoodTruck.sells(.arepas))\n    ...\n  }\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Suite(.disabled(if: CashRegister.isEmpty))\nstruct FoodTruckTests {\n  @Test(.enabled(if: FoodTruck.sells(.arepas)))\n  func arepasAreTasty() {\n    ...\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using require() Macro to Stop Test on Failure in Swift\nDESCRIPTION: This example shows how to use the require() macro to stop test execution when a critical requirement is not met. It demonstrates creating a customer object and checking its usual order.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/Expectations.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Test func returningCustomerRemembersUsualOrder() throws {\n  let customer = try #require(Customer(id: 123))\n  // The test runner doesn't reach this line if the customer is nil.\n  #expect(customer.usualOrder.countOfItems == 2)\n}\n```\n\n----------------------------------------\n\nTITLE: Importing the Testing Library in Swift\nDESCRIPTION: Shows how to import the Testing library into a Swift test file. This should only be done in test targets, not in application, library, or binary targets.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/DefiningTests.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport Testing\n```\n\n----------------------------------------\n\nTITLE: Using Expect Macro in Swift Testing\nDESCRIPTION: Demonstrates the basic usage of the #expect macro in Swift Testing for assertions. The example shows a failing test where a greeting string doesn't match the expected value, and how the API reports the actual evaluated values.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/README.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Test func helloWorld() {\n  let greeting = \"Hello, world!\"\n  #expect(greeting == \"Hello\") // Expectation failed: (greeting → \"Hello, world!\") == \"Hello\"\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Expected Values with expect() Macro in Swift\nDESCRIPTION: This snippet demonstrates how to use the expect() macro to validate that a calculation produces an expected result. It shows how the macro captures the expression and provides detailed information on failure.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/Expectations.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Test func calculatingOrderTotal() {\n  let calculator = OrderCalculator()\n  #expect(calculator.total(of: [3, 3]) == 7)\n  // Prints \"Expectation failed: (calculator.total(of: [3, 3]) → 6) == 7\"\n}\n```\n\n----------------------------------------\n\nTITLE: Converting XCTest assertions to Swift Testing expectations\nDESCRIPTION: Shows how to replace various XCTest assertion methods with Swift Testing's #expect and #require macros. These macros evaluate conditions and record test issues, with #require throwing an error when conditions aren't met.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nfunc testEngineWorks() throws {\n  let engine = FoodTruck.shared.engine\n  XCTAssertNotNil(engine.parts.first)\n  XCTAssertGreaterThan(engine.batteryLevel, 0)\n  try engine.start()\n  XCTAssertTrue(engine.isRunning)\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Test func engineWorks() throws {\n  let engine = FoodTruck.shared.engine\n  try #require(engine.parts.first != nil)\n  #expect(engine.batteryLevel > 0)\n  try engine.start()\n  #expect(engine.isRunning)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Basic Test Function in Swift\nDESCRIPTION: Demonstrates how to declare a simple test function using the @Test attribute. This creates a basic test function that can be recognized by the testing framework.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/DefiningTests.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Test func foodTruckExists() {\n  // Test logic goes here.\n}\n```\n\n----------------------------------------\n\nTITLE: Testing for No Errors in Swift Code Using Never.self\nDESCRIPTION: Illustrates how to verify that a Swift function doesn't throw an error by comparing against Never.self. The test adds a valid topping to a pizza and checks both the non-throwing behavior and the result.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/testing-for-errors-in-swift-code.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Test func canAddToppingToPizzaInPositionZero() throws {\n  var order = PizzaToppings(bases: [.thinCrust, .thinCrust])\n  #expect(throws: Never.self) {\n    try order.add(topping: .caper, toPizzasIn: 0..<1)\n  }\n  let toppings = try order.toppings(forPizzaAt: 0)\n  #expect(toppings == [.caper])\n}\n```\n\n----------------------------------------\n\nTITLE: Testing for Specific Errors in Swift Code\nDESCRIPTION: Demonstrates how to test that a Swift function throws a specific expected error. The test uses the #expect macro to validate that adding a topping to an out-of-range pizza index throws the appropriate error.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/testing-for-errors-in-swift-code.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Test func cannotAddToppingToPizzaBeforeStartOfList() {\n  var order = PizzaToppings(bases: [.calzone, .deepCrust])\n  #expect(throws: PizzaToppings.Error.outOfRange) {\n    try order.add(topping: .mozarella, toPizzasIn: -1..<0)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterizing Swift Tests with CaseIterable Enum\nDESCRIPTION: This example shows how to use a CaseIterable enum to parameterize a test function, automatically testing all cases of the Food enum.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/ParameterizedTesting.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nenum Food: CaseIterable {\n  case burger, iceCream, burrito, noodleBowl, kebab\n}\n\n@Test(\"All foods available\", arguments: Food.allCases)\nfunc foodAvailable(_ food: Food) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food))\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Advanced Known Issue Options in Swift Testing\nDESCRIPTION: Demonstrates how to migrate from XCTest's advanced XCTExpectFailure options to Swift Testing's withKnownIssue with conditional enabling and issue matching.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nfunc testGrillWorks() async {\n  let options = XCTExpectedFailure.Options()\n  options.isEnabled = FoodTruck.shared.hasGrill\n  options.issueMatcher = { issue in\n    issue.type == thrownError\n  }\n  XCTExpectFailure(\n    \"Grill is out of fuel\",\n    options: options\n  ) {\n    try FoodTruck.shared.grill.start()\n  }\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Test func grillWorks() async {\n  withKnownIssue(\"Grill is out of fuel\") {\n    try FoodTruck.shared.grill.start()\n  } when: {\n    FoodTruck.shared.hasGrill\n  } matching: { issue in\n    issue.error != nil \n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterizing Swift Tests with an Array of Enum Values\nDESCRIPTION: This snippet demonstrates how to parameterize a test function using an array of enum values. It tests the availability of different food types in a FoodTruck class.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/ParameterizedTesting.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nenum Food {\n  case burger, iceCream, burrito, noodleBowl, kebab\n}\n\n@Test(\"All foods available\", arguments: [Food.burger, .iceCream, .burrito, .noodleBowl, .kebab])\nfunc foodAvailable(_ food: Food) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food))\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterized Testing in Swift Testing\nDESCRIPTION: Shows how to create parameterized tests that run with multiple input values. This example demonstrates a test that verifies continent count across different videos using the arguments parameter.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/README.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Continents mentioned in videos\", arguments: [\n    \"A Beach\",\n    \"By the Lake\",\n    \"Camping in the Woods\"\n])\nfunc mentionedContinents(videoName: String) async throws {\n    let videoLibrary = try await VideoLibrary()\n    let video = try #require(await videoLibrary.video(named: videoName))\n    #expect(video.mentionedContinents.count <= 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Absence of Events with Confirmation in Swift\nDESCRIPTION: This example shows how to use the Confirmation API to ensure that a particular event (in this case, an error) does not occur during the test. It sets the expected count to 0 and attaches an error handler that would trigger the confirmation if called.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/testing-asynchronous-code.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Test func orderCalculatorEncountersNoErrors() async {\n  let calculator = OrderCalculator()\n  await confirmation(expectedCount: 0) { confirmation in\n    calculator.errorHandler = { _ in confirmation() }\n    calculator.subtotal(for: PizzaToppings(bases: []))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing for Any Error Type in Swift Code\nDESCRIPTION: Shows how to validate that a Swift function throws any error type by using (any Error).self as the argument to the #expect macro. This approach tests that an error occurs without specifying which error.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/testing-for-errors-in-swift-code.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Test func cannotAddToppingToPizzaBeforeStartOfList() {\n  var order = PizzaToppings(bases: [.calzone, .deepCrust])\n  #expect(throws: (any Error).self) {\n    try order.add(topping: .mozarella, toPizzasIn: -1..<0)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Asynchronous Price Lookup in Swift\nDESCRIPTION: This snippet demonstrates how to test an asynchronous price lookup function using Swift's async/await feature. It awaits the result of a unitPrice function and checks if the returned price matches the expected value.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/testing-asynchronous-code.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Test func priceLookupYieldsExpectedValue() async {\n  let mozarellaPrice = await unitPrice(for: .mozarella)\n  #expect(mozarellaPrice == 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterizing Swift Tests with Integer Range\nDESCRIPTION: This snippet demonstrates how to parameterize a test function using a range of integers, testing large order quantities for a food truck.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/ParameterizedTesting.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Can make large orders\", arguments: 1 ... 100)\nfunc makeLargeOrder(count: Int) async throws {\n  let foodTruck = FoodTruck(selling: .burger)\n  #expect(await foodTruck.cook(.burger, quantity: count))\n}\n```\n\n----------------------------------------\n\nTITLE: Importing the Testing module instead of XCTest\nDESCRIPTION: Shows how to replace the XCTest import statement with the Swift Testing module import. This is the first step in migrating a test from XCTest to Swift Testing.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nimport XCTest\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\nimport Testing\n```\n\n----------------------------------------\n\nTITLE: Handling Complex Conditions in Swift Testing Framework\nDESCRIPTION: Demonstrates how to handle complex conditions by factoring them out into helper functions, improving readability and maintainability of test conditions.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/EnablingAndDisabling.md#2025-04-18_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nfunc allIngredientsAvailable(for food: Food) -> Bool { ... }\n\n@Test(\n  \"Can make sundaes\",\n  .enabled(if: Season.current == .summer),\n  .enabled(if: allIngredientsAvailable(for: .sundae))\n)\nfunc makeSundae() async throws { ... }\n```\n\n----------------------------------------\n\nTITLE: Matching Specific Issues in Swift Testing\nDESCRIPTION: This snippet illustrates how to use 'withKnownIssue()' with a matching closure to selectively mark issues as known based on specific criteria. In this case, only required expectations are considered known issues.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/known-issues.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Test func batteryLevel() throws {\n  var foodTruck = FoodTruck()\n  try withKnownIssue {\n    let batteryLevel = try #require(foodTruck.batteryLevel) // Known\n    #expect(batteryLevel >= 0.8) // Not considered known\n  } matching: { issue in\n    guard case .expectationFailed(let expectation) = issue.kind else {\n      return false\n    }\n    return expectation.isRequired\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Marking Expectation Failure as Known Issue in Swift Testing\nDESCRIPTION: This snippet demonstrates how to use 'withKnownIssue()' to mark an expectation failure as a known issue in a Swift test. It wraps the failing expectation in a closure passed to 'withKnownIssue()', preventing the test from being marked as a failure.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/known-issues.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  withKnownIssue(\"Propane tank is empty\") {\n    #expect(foodTruck.grill.isHeating) // Known issue\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Test Execution with Traits in Swift Testing\nDESCRIPTION: Shows how to use traits to conditionally enable tests based on runtime conditions. This example demonstrates enabling a test only when a specific feature is available in the application.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/README.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Test(.enabled(if: AppFeatures.isCommentingEnabled))\nfunc videoCommenting() async throws {\n    let video = try #require(await videoLibrary.video(named: \"A Beach\"))\n    #expect(video.comments.contains(\"So picturesque!\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Converting XCTest test methods to Swift Testing test functions\nDESCRIPTION: Shows how to replace the XCTest convention of methods with names starting with 'test' with Swift Testing's @Test attribute. In Swift Testing, test functions can have any name but must be marked with @Test.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nclass FoodTruckTests: XCTestCase {\n  func testEngineWorks() { ... }\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\nstruct FoodTruckTests {\n  @Test func engineWorks() { ... }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Nondeterministic Failures with Precondition in Swift Testing\nDESCRIPTION: This example demonstrates how to handle nondeterministic failures by adding a precondition to 'withKnownIssue()'. The 'when:' closure determines whether issues should be considered known based on a specific condition.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/known-issues.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  withKnownIssue {\n    // Only considered known when hasPropane == false\n    #expect(foodTruck.grill.isHeating)\n  } when: {\n    !hasPropane\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Continuous Test Execution in Swift\nDESCRIPTION: This snippet demonstrates how to migrate from using XCTest's continueAfterFailure property to the new framework's #require macro for handling test failures. The new approach uses Swift error throwing instead of Objective-C exceptions.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nfunc testTruck() async {\n  continueAfterFailure = false\n  XCTAssertTrue(FoodTruck.shared.isLicensed)\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Test func truck() throws {\n  try #require(FoodTruck.shared.isLicensed)\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Functions as Instance Methods in Swift Test Suites\nDESCRIPTION: This example shows how test functions can be defined as instance methods within a test suite. The testing library initializes a new instance for each test function call.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/OrganizingTests.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Suite struct FoodTruckTests {\n  @Test func foodTruckExists() { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditionally Enabling a Test in Swift Testing Framework\nDESCRIPTION: Illustrates how to conditionally enable a test based on a specific condition using the .enabled(if:) trait. The test will only run if the condition is met.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/EnablingAndDisabling.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Ice cream is cold\", .enabled(if: Season.current == .summer))\nfunc isCold() async throws { ... }\n```\n\n----------------------------------------\n\nTITLE: Customizing Test Suite Name with @Suite Attribute in Swift\nDESCRIPTION: This snippet demonstrates how to use the @Suite attribute to customize the name of a test suite. It creates a suite named 'Food truck tests' containing a test function.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/OrganizingTests.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Suite(\"Food truck tests\") struct FoodTruckTests {\n  @Test func foodTruckExists() { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterizing Swift Tests with Multiple Collections\nDESCRIPTION: This example shows how to use multiple collections to parameterize a test function, testing all combinations of food types and order quantities.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/ParameterizedTesting.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Can make large orders\", arguments: Food.allCases, 1 ... 100)\nfunc makeLargeOrder(of food: Food, count: Int) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food, quantity: count))\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Time Limit for Swift Tests Using Trait\nDESCRIPTION: This example demonstrates how to set a time limit for a Swift test function using the .timeLimit trait. The test will be marked as failing if it runs for more than the specified duration (60 minutes in this case), with the task being cancelled and an issue of kind timeLimitExceeded being raised.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/LimitingExecutionTime.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Test(.timeLimit(.minutes(60)))\nfunc serve100CustomersInOneHour() async {\n  for _ in 0 ..< 100 {\n    let customer = await Customer.next()\n    await customer.order()\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting XCTUnwrap to Swift Testing's #require for optionals\nDESCRIPTION: Shows how to replace XCTest's XCTUnwrap function with Swift Testing's #require macro to safely unwrap optional values. The #require macro throws an error if the optional is nil, similar to XCTUnwrap.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nfunc testEngineWorks() throws {\n  let engine = FoodTruck.shared.engine\n  let part = try XCTUnwrap(engine.parts.first)\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Test func engineWorks() throws {\n  let engine = FoodTruck.shared.engine\n  let part = try #require(engine.parts.first)\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests Sequentially with Swift Testing\nDESCRIPTION: Shows how to migrate from XCTest's default sequential test execution to Swift Testing's @Suite(.serialized) annotation for running tests in a serial manner.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nclass RefrigeratorTests : XCTestCase {\n  func testLightComesOn() throws {\n    try FoodTruck.shared.refrigerator.openDoor()\n    XCTAssertEqual(FoodTruck.shared.refrigerator.lightState, .on)\n  }\n  \n  func testLightGoesOut() throws {\n    try FoodTruck.shared.refrigerator.openDoor()\n    try FoodTruck.shared.refrigerator.closeDoor()\n    XCTAssertEqual(FoodTruck.shared.refrigerator.lightState, .off)\n  }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Suite(.serialized)\nclass RefrigeratorTests {\n  @Test func lightComesOn() throws {\n    try FoodTruck.shared.refrigerator.openDoor()\n    #expect(FoodTruck.shared.refrigerator.lightState == .on)\n  }\n  \n  @Test func lightGoesOut() throws {\n    try FoodTruck.shared.refrigerator.openDoor()\n    try FoodTruck.shared.refrigerator.closeDoor()\n    #expect(FoodTruck.shared.refrigerator.lightState == .off)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Test Parallelization with .serialized Trait in Swift\nDESCRIPTION: Example showing how to use the `.serialized` trait to control test execution flow. The trait can be applied to parameterized test functions to run test cases serially, or to test suites to run all contained tests serially. The trait is recursively applied to nested test structures.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/Parallelization.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Test(.serialized, arguments: Food.allCases) func prepare(food: Food) {\n  // This function will be invoked serially, once per food, because it has the\n  // .serialized trait.\n}\n\n@Suite(.serialized) struct FoodTruckTests {\n  @Test(arguments: Condiment.allCases) func refill(condiment: Condiment) {\n    // This function will be invoked serially, once per condiment, because the\n    // containing suite has the .serialized trait.\n  }\n\n  @Test func startEngine() async throws {\n    // This function will not run while refill(condiment:) is running. One test\n    // must end before the other will start.\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Intermittent Test Failures with Swift Testing\nDESCRIPTION: Shows how to migrate from XCTest's non-strict XCTExpectFailure to Swift Testing's withKnownIssue with the isIntermittent parameter for tests that may fail intermittently.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nfunc testGrillWorks() async {\n  XCTExpectFailure(\n    \"Grill may need fuel\",\n    options: .nonStrict()\n  ) {\n    try FoodTruck.shared.grill.start()\n  }\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Test func grillWorks() async {\n  withKnownIssue(\n    \"Grill may need fuel\", \n    isIntermittent: true\n  ) {\n    try FoodTruck.shared.grill.start()\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling a Test in Swift Testing Framework\nDESCRIPTION: Demonstrates how to unconditionally disable a test using the .disabled() trait. This prevents the test from running under any circumstances.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/EnablingAndDisabling.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Food truck sells burritos\", .disabled())\nfunc sellsBurritos() async throws { ... }\n```\n\n----------------------------------------\n\nTITLE: Basic Tag Declaration and Usage in Swift Tests\nDESCRIPTION: Demonstrates how to declare a simple tag and apply it to a test using the Tag macro and tags trait.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/AddingTags.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nextension Tag {\n  @Tag static var legallyRequired: Self\n}\n\n@Test(\"Vendor's license is valid\", .tags(.legallyRequired))\nfunc licenseValid() { ... }\n```\n\n----------------------------------------\n\nTITLE: Marking Thrown Error as Known Issue in Swift Testing\nDESCRIPTION: This example shows how to use 'withKnownIssue()' to mark a thrown error as a known issue in a Swift test. The function call that might throw an error is wrapped in the 'withKnownIssue()' closure, along with any dependent code.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/known-issues.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Test func grillHeating() {\n  var foodTruck = FoodTruck()\n  withKnownIssue {\n    try foodTruck.startGrill() // Known issue\n    #expect(foodTruck.grill.isHeating)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Time Limit for Swift Tests\nDESCRIPTION: This code snippet shows how to set a time limit for a test function or suite using the 'timeLimit' trait.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/Traits.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Trait.timeLimit(10.0)\n```\n\n----------------------------------------\n\nTITLE: Applying Enabled Trait in Swift Testing\nDESCRIPTION: This code snippet shows how to apply the 'enabled' trait to a test function or suite. It conditionally enables the test based on a given condition.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/Traits.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Trait.enabled(if: condition, \"Reason for enabling\")\n```\n\n----------------------------------------\n\nTITLE: Inspecting Thrown Errors in Swift Testing\nDESCRIPTION: Demonstrates how to capture and inspect properties of a thrown error in Swift tests. The test checks that adding marshmallows to a pizza throws the expected error type and validates the error's properties.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/testing-for-errors-in-swift-code.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Test func cannotAddMarshmallowsToPizza() throws {\n  let error = #expect(throws: PizzaToppings.InvalidToppingError.self) {\n    try Pizza.current.add(topping: .marshmallows)\n  }\n  #expect(error?.topping == .marshmallows)\n  #expect(error?.reason == .dessertToppingOnly)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Order Calculation with Confirmation in Swift\nDESCRIPTION: This example shows how to use the Confirmation API to test if an OrderCalculator successfully calculates a subtotal for an order with no pizzas. It sets up a success handler that calls the confirmation when invoked.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/testing-asynchronous-code.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"OrderCalculator successfully calculates subtotal for no pizzas\")\nfunc subtotalForNoPizzas() async {\n  let calculator = OrderCalculator()\n  await confirmation() { confirmation in\n    calculator.successHandler = { _ in confirmation() }\n    _ = await calculator.subtotal(for: PizzaToppings(bases: []))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Line Comments to Swift Tests\nDESCRIPTION: This example demonstrates how to add a line comment to a test function using Swift's standard line comment syntax. The comment is automatically captured by the testing library and displayed when issues are recorded.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/AddingComments.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n// Assumes the standard lunch menu includes a taco\n@Test func lunchMenu() {\n  let foodTruck = FoodTruck(\n    menu: .lunch,\n    ingredients: [.tortillas, .cheese]\n  )\n  #expect(foodTruck.menu.contains { $0 is Taco })\n}\n```\n\n----------------------------------------\n\nTITLE: Associating Bugs with Swift Tests\nDESCRIPTION: This code snippet demonstrates how to associate a bug with a test function or suite using the 'bug' trait.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/Traits.md#2025-04-18_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n@Trait.bug(\"BUG-123\", \"Description of the bug\")\n```\n\n----------------------------------------\n\nTITLE: Associating a Test with a Bug URL in Swift Testing\nDESCRIPTION: Demonstrates how to associate a test with a bug using its URL. The test verifies that a food truck's engine works correctly, and is linked to a bug at the specified URL.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/AssociatingBugs.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Food truck engine works\", .bug(\"https://www.example.com/issues/12345\"))\nfunc engineWorks() async {\n  var foodTruck = FoodTruck()\n  await foodTruck.engine.start()\n  #expect(foodTruck.engine.isRunning)\n}\n```\n\n----------------------------------------\n\nTITLE: Test Organization with Tags in Swift Testing\nDESCRIPTION: Demonstrates how to organize tests with descriptive names and tags for flexible management. This example shows a test for video metadata that is tagged for easier filtering and organization.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/README.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Check video metadata\",\n      .tags(.metadata))\nfunc videoMetadata() {\n    let video = Video(fileName: \"By the Lake.mov\")\n    let expectedMetadata = Metadata(duration: .seconds(90))\n    #expect(video.metadata == expectedMetadata)\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Asynchronous Validation in Swift Tests\nDESCRIPTION: This snippet shows how to migrate from XCTest's expectation-based asynchronous testing to the new framework's confirmation-based approach. The new method uses a closure-based API that doesn't block or suspend the caller.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nfunc testTruckEvents() async {\n  let soldFood = expectation(description: \"…\")\n  FoodTruck.shared.eventHandler = { event in\n    if case .soldFood = event {\n      soldFood.fulfill()\n    }\n  }\n  await Customer().buy(.soup)\n  await fulfillment(of: [soldFood])\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Test func truckEvents() async {\n  await confirmation(\"…\") { soldFood in\n    FoodTruck.shared.eventHandler = { event in\n      if case .soldFood = event {\n        soldFood()\n      }\n    }\n    await Customer().buy(.soup)\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Main Entry Point for Swift Testing\nDESCRIPTION: This Swift code defines the required @main entry point for a Swift Testing executable. It uses the SwiftPM entry point which is expected to change in future releases.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/CMake.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nimport Testing\n\n@main struct Runner {\n    static func main() async {\n        await Testing.__swiftPMEntryPoint() as Never\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting an XCTestCase subclass to a Swift Testing suite\nDESCRIPTION: Shows how to convert an XCTest class to a Swift Testing suite by removing the XCTestCase inheritance and changing it to a struct. Swift Testing recommends using struct or actor instead of class for better concurrency safety.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nclass FoodTruckTests: XCTestCase {\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\nstruct FoodTruckTests {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Multiple Expectation Fulfillments in Swift Tests\nDESCRIPTION: This snippet demonstrates how to migrate from XCTest's expectation with multiple fulfillments to the new framework's confirmation with a range-based expected count. The new approach allows for more flexible confirmation counting.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nfunc testRegularCustomerOrders() async {\n  let soldFood = expectation(description: \"…\")\n  soldFood.expectedFulfillmentCount = 10\n  soldFood.assertForOverFulfill = false\n  FoodTruck.shared.eventHandler = { event in\n    if case .soldFood = event {\n      soldFood.fulfill()\n    }\n  }\n  for customer in regularCustomers() {\n    await customer.buy(customer.regularOrder)\n  }\n  await fulfillment(of: [soldFood])\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Test func regularCustomerOrders() async {\n  await confirmation(\n    \"…\",\n    expectedCount: 10...\n  ) { soldFood in\n    FoodTruck.shared.eventHandler = { event in\n      if case .soldFood = event {\n        soldFood()\n      }\n    }\n    for customer in regularCustomers() {\n      await customer.buy(customer.regularOrder)\n    }\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Building Swift Tests for WebAssembly\nDESCRIPTION: Command to build Swift tests for WebAssembly using the wasm32-unknown-wasi SDK. This step compiles your test code to WebAssembly format that can be executed by a WASI-compliant runtime.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/WASI.md#2025-04-18_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nswift build --swift-sdk wasm32-unknown-wasi --build-tests\n```\n\n----------------------------------------\n\nTITLE: Adding Tags to Swift Tests\nDESCRIPTION: This code snippet shows how to add tags to a test function or suite for categorization purposes.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/Traits.md#2025-04-18_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\n@Tag(\"category\")\n```\n\n----------------------------------------\n\nTITLE: Testing Random Event Occurrences with Range in Swift\nDESCRIPTION: This snippet demonstrates using a range with the Confirmation API to test a scenario where the number of occurrences is unpredictable. It tests if customers bought sandwiches from a food truck, allowing for 0 to 999 occurrences.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/testing-asynchronous-code.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Customers bought sandwiches\")\nfunc boughtSandwiches() async {\n  await confirmation(expectedCount: 0 ..< 1000) { boughtSandwich in\n    var foodTruck = FoodTruck()\n    foodTruck.orderHandler = { order in\n      if order.contains(.sandwich) {\n        boughtSandwich()\n      }\n    }\n    await FoodTruck.operate()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Namespaced Tag Declaration Using Reverse-DNS\nDESCRIPTION: Shows how to create uniquely namespaced tags using reverse-DNS notation to avoid naming conflicts across different modules.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/AddingTags.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nextension Tag {\n  enum com_example_foodtruck {}\n}\n\nextension Tag.com_example_foodtruck {\n  @Tag static var extraSpecial: Tag\n}\n\n@Test(\n  \"Extra Special Sauce recipe is secret\",\n  .tags(.com_example_foodtruck.extraSpecial)\n)\nfunc secretSauce() { ... }\n```\n\n----------------------------------------\n\nTITLE: Recommended placement of try inside #expect macro parameter\nDESCRIPTION: The proper way to use effect keywords with the #expect macro, placing try within the macro argument list to avoid compilation issues.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n#expect(try h())\n```\n\n----------------------------------------\n\nTITLE: Creating Concurrent and Main Actor Test Functions in Swift\nDESCRIPTION: Demonstrates how to create an asynchronous, throwing test function that runs on the main actor. This pattern is useful for UI tests or tests that need main thread access.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/DefiningTests.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Test @MainActor func foodTruckExists() async throws { ... }\n```\n\n----------------------------------------\n\nTITLE: Disabling a Test with Comment in Swift Testing Framework\nDESCRIPTION: Shows how to disable a test while providing a comment that explains why the test is disabled. This comment will be displayed in the test runner output.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/EnablingAndDisabling.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Food truck sells burritos\", .disabled(\"We only sell Thai cuisine\"))\nfunc sellsBurritos() async throws { ... }\n```\n\n----------------------------------------\n\nTITLE: Associating a Test with Bug IDs in Swift Testing\nDESCRIPTION: Shows how to associate a test with bugs using their unique identifiers. This example demonstrates linking a test to bugs using just an ID or a combination of URL and ID.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/AssociatingBugs.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\n  \"Food truck engine works\",\n  .bug(id: \"12345\"),\n  .bug(\"https://www.example.com/issues/67890\", id: 67890)\n)\nfunc engineWorks() async {\n  var foodTruck = FoodTruck()\n  await foodTruck.engine.start()\n  #expect(foodTruck.engine.isRunning)\n}\n```\n\n----------------------------------------\n\nTITLE: After expansion of throwing function comparison with #expect\nDESCRIPTION: The new expansion implementation of #expect for a comparison involving a throwing function, showing how the try keyword is preserved in the expanded closure.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_15\n\nLANGUAGE: swift\nCODE:\n```\ntry Testing.__checkCondition(\n  { (__ec: inout Testing.__ExpectationContext) -> Swift.Bool in\n    try __ec(__ec(f(), 0xc) < __ec(g(), 0x1004), 0x4)\n  },\n  sourceCode: [\n    0x4: \"f() < g()\",\n    0xc: \"f()\",\n    0x1004: \"g()\"\n  ],\n  comments: [],\n  isRequired: false,\n  sourceLocation: Testing.SourceLocation.__here()\n).__expected()\n```\n\n----------------------------------------\n\nTITLE: Adding Swift Testing to a CMake Project using FetchContent\nDESCRIPTION: This snippet demonstrates how to add Swift Testing to a CMake project using the FetchContent mechanism. It declares the Swift Testing repository and makes it available for the project.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/CMake.md#2025-04-18_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(FetchContent)\nFetchContent_Declare(SwiftTesting\n  GIT_REPOSITORY https://github.com/swiftlang/swift-testing.git\n  GIT_TAG main)\nFetchContent_MakeAvailable(SwiftTesting)\n```\n\n----------------------------------------\n\nTITLE: Attaching Values to Test Results in Swift Testing\nDESCRIPTION: Demonstrates how to migrate from XCTest's XCTAttachment to Swift Testing's Attachment for recording values and objects with test results.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_16\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nimport Foundation\n\nclass Tortilla: NSSecureCoding { /* ... */ }\n\nfunc testTortillaIntegrity() async {\n  let tortilla = Tortilla(diameter: .large)\n  ...\n  let attachment = XCTAttachment(\n    archivableObject: tortilla\n  )\n  self.add(attachment)\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\nimport Foundation\n\nstruct Tortilla: Codable, Attachable { /* ... */ }\n\n@Test func tortillaIntegrity() async {\n  let tortilla = Tortilla(diameter: .large)\n  ...\n  Attachment.record(tortilla)\n}\n```\n\n----------------------------------------\n\nTITLE: Annotating Known Issues with Swift Testing\nDESCRIPTION: Demonstrates how to migrate from XCTest's XCTExpectFailure to Swift Testing's withKnownIssue function to annotate a test section with a known issue.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nfunc testGrillWorks() async {\n  XCTExpectFailure(\"Grill is out of fuel\") {\n    try FoodTruck.shared.grill.start()\n  }\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Test func grillWorks() async {\n  withKnownIssue(\"Grill is out of fuel\") {\n    try FoodTruck.shared.grill.start()\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Runtime Test Discovery for a Custom Platform\nDESCRIPTION: Demonstrates how to implement the _sectionBounds(_:) function for a platform with a non-ELF format. The example uses Classic Mac OS resource manager to load section information from the resource fork.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/Porting.md#2025-04-18_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n--- a/Sources/_TestDiscovery/SectionBounds.swift\n+++ b/Sources/_TestDiscovery/SectionBounds.swift\n\n // ...\n+#elseif os(Classic)\n+private func _sectionBounds(_ kind: SectionBounds.Kind) -> [SectionBounds] {\n+  let resourceName: Str255 = switch kind {\n+  case .testContent:\n+    \"__swift5_tests\"\n+#if !SWT_NO_LEGACY_TEST_DISCOVERY\n+  case .typeMetadata:\n+    \"__swift5_types\"\n+#endif\n+  }\n+\n+  let oldRefNum = CurResFile()\n+  defer {\n+    UseResFile(oldRefNum)\n+  }\n+\n+  var refNum = ResFileRefNum(0)\n+  guard noErr == GetTopResourceFile(&refNum) else {\n+    return []\n+  }\n+\n+  var result = [SectionBounds]()\n+  repeat {\n+    UseResFile(refNum)\n+    guard let handle = Get1NamedResource(ResType(\"swft\"), resourceName) else {\n+      continue\n+    }\n+    let sb = SectionBounds(\n+      imageAddress: UnsafeRawPointer(bitPattern: UInt(refNum)),\n+      start: handle.pointee!,\n+      size: GetHandleSize(handle)\n+    )\n+    result.append(sb)\n+  } while noErr == GetNextResourceFile(refNum, &refNum))\n+  return result\n+}\n+\n #elseif !SWT_NO_DYNAMIC_LINKING\n // MARK: - Missing dynamic implementation\n\n private func _sectionBounds(_ kind: SectionBounds.Kind) -> EmptyCollection<SectionBounds> {\n #warning(\"Platform-specific implementation missing: Runtime test discovery unavailable (dynamic)\")\n   return EmptyCollection()\n }\n #endif\n```\n\n----------------------------------------\n\nTITLE: Parameterizing Swift Tests with Zipped Collections\nDESCRIPTION: This snippet demonstrates how to use zipped collections to avoid combinatorial explosion when parameterizing tests with multiple collections.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/ParameterizedTesting.md#2025-04-18_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Can make large orders\", arguments: zip(Food.allCases, 1 ... 100))\nfunc makeLargeOrder(of food: Food, count: Int) async throws {\n  let foodTruck = FoodTruck(selling: food)\n  #expect(await foodTruck.cook(food, quantity: count))\n}\n```\n\n----------------------------------------\n\nTITLE: Converting XCTFail to Swift Testing's Issue.record\nDESCRIPTION: Shows how to replace XCTest's XCTFail function with Swift Testing's Issue.record function for unconditional test failures. Used to manually record issues when automatic assertion handling isn't possible.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nfunc testEngineWorks() {\n  let engine = FoodTruck.shared.engine\n  guard case .electric = engine else {\n    XCTFail(\"Engine is not electric\")\n    return\n  }\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\n@Test func engineWorks() {\n  let engine = FoodTruck.shared.engine\n  guard case .electric = engine else {\n    Issue.record(\"Engine is not electric\")\n    return\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Linkage for Runtime Test Discovery in Swift\nDESCRIPTION: This code snippet demonstrates how to implement static linkage for runtime test discovery on platforms that don't support dynamic linking. It defines necessary symbols and section bounds for test content and type metadata.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/Porting.md#2025-04-18_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n--- a/Sources/_TestDiscovery/SectionBounds.swift\n+++ b/Sources/_TestDiscovery/SectionBounds.swift\n // ...\n+#elseif os(Classic)\n+@_silgen_name(raw: \"...\") private nonisolated(unsafe) var _testContentSectionBegin: _SectionBound\n+@_silgen_name(raw: \"...\") private nonisolated(unsafe) var _testContentSectionEnd: _SectionBound\n+#if !SWT_NO_LEGACY_TEST_DISCOVERY\n+@_silgen_name(raw: \"...\") private nonisolated(unsafe) var _typeMetadataSectionBegin: _SectionBound\n+@_silgen_name(raw: \"...\") private nonisolated(unsafe) var _typeMetadataSectionEnd: _SectionBound\n+#endif\n #else\n #warning(\"Platform-specific implementation missing: Runtime test discovery unavailable (static)\")\n private nonisolated(unsafe) let _testContentSectionBegin = UnsafeMutableRawPointer.allocate(byteCount: 1, alignment: 16)\n private nonisolated(unsafe) let _testContentSectionEnd = _testContentSectionBegin\n #if !SWT_NO_LEGACY_TEST_DISCOVERY\n private nonisolated(unsafe) let _typeMetadataSectionBegin = UnsafeMutableRawPointer.allocate(byteCount: 1, alignment: 16)\n private nonisolated(unsafe) let _typeMetadataSectionEnd = _typeMetadataSectionBegin\n #endif\n #endif\n // ...\n```\n\n----------------------------------------\n\nTITLE: Handling Intermittent Issues in Swift Testing\nDESCRIPTION: This snippet shows how to handle intermittent issues by passing 'isIntermittent: true' to 'withKnownIssue()'. This informs the testing library that the issue may not always occur, preventing it from recording an issue when no known issues are found.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/known-issues.md#2025-04-18_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@Test func grillHeating() throws {\n  var foodTruck = FoodTruck()\n  try foodTruck.startGrill()\n  withKnownIssue(isIntermittent: true) {\n    #expect(foodTruck.grill.isHeating)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Serialized Trait in Swift Testing\nDESCRIPTION: This code snippet demonstrates how to apply the 'serialized' trait to ensure tests run serially rather than in parallel.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/Traits.md#2025-04-18_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@Trait.serialized\n```\n\n----------------------------------------\n\nTITLE: Defining Record Types for Swift Testing Output Stream\nDESCRIPTION: Defines the record types that can appear in the Swift testing output stream. Each record has a version, kind field, and payload that contains either test information or event data.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/JSON.md#2025-04-18_snippet_2\n\nLANGUAGE: bnf\nCODE:\n```\n<output-record> ::= <test-record> | <event-record>\n\n<test-record> ::= {\n  <version>,\n  \"kind\": \"test\",\n  \"payload\": <test>\n}\n\n<event-record> ::= {\n  <version>,\n  \"kind\": \"event\",\n  \"payload\": <event>\n}\n```\n\n----------------------------------------\n\nTITLE: Converting XCTest setUp and tearDown methods to Swift Testing\nDESCRIPTION: Shows how to convert both setUp and tearDown methods to Swift initializers and deinitializers. When teardown is needed, the suite should be declared as a class or actor instead of a struct.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nclass FoodTruckTests: XCTestCase {\n  var batteryLevel: NSNumber!\n  override func setUp() async throws {\n    batteryLevel = 100\n  }\n  override func tearDown() {\n    batteryLevel = 0 // drain the battery\n  }\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\nfinal class FoodTruckTests {\n  var batteryLevel: NSNumber\n  init() async throws {\n    batteryLevel = 100\n  }\n  deinit {\n    batteryLevel = 0 // drain the battery\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Conforming to DiscoverableAsTestContent Protocol in Swift\nDESCRIPTION: This code demonstrates how to make a type conform to the `DiscoverableAsTestContent` protocol. It includes setting the `testContentKind` static property.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/TestContent.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\nextension FoodTruckDiagnostic: DiscoverableAsTestContent {\n  static var testContentKind: TestContentKind { /* Your `kind` value here. */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Tag Colors Configuration in JSON\nDESCRIPTION: Example of JSON configuration for customizing tag colors in the test output.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/AddingTags.md#2025-04-18_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \".critical\": \"orange\",\n  \".legallyRequired\": \"#66FFCC\"\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Test Conditions in Swift Testing Framework\nDESCRIPTION: Demonstrates how to combine multiple conditions for enabling and disabling a test. All conditions must pass for the test to run.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/EnablingAndDisabling.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\n  \"Ice cream is cold\",\n  .enabled(if: Season.current == .summer),\n  .disabled(\"We ran out of sprinkles\")\n)\nfunc isCold() async throws { ... }\n```\n\n----------------------------------------\n\nTITLE: Customizing TestContentContext and TestContentAccessorHint in Swift\nDESCRIPTION: This snippet shows how to customize the `TestContentContext` and `TestContentAccessorHint` associated types when conforming to `DiscoverableAsTestContent`. It's useful for specifying custom context and hint types.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/TestContent.md#2025-04-18_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\nextension FoodTruckDiagnostic: DiscoverableAsTestContent {\n  static var testContentKind: TestContentKind { /* Your `kind` value here. */ }\n  \n  typealias TestContentContext = UnsafePointer<FoodTruck.Name>\n  typealias TestContentAccessorHint = String\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling expression expansion with type casting\nDESCRIPTION: Examples of using type casting to prevent the Swift Testing macro from expanding an expression, useful when expansion causes issues or when side effects need to be avoided.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_9\n\nLANGUAGE: swift\nCODE:\n```\nlet x = ...\nlet y = ...\n#expect((x == y) as Bool)\n\nlet z: String?\nlet w = try #require(z as String?)\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Target for Swift Testing Macros\nDESCRIPTION: Sets up the build target for Swift Testing Macros, either as an executable or a shared library, depending on the build configuration. Includes compilation options, installation settings, and platform-specific configurations.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/TestingMacros/CMakeLists.txt#2025-04-18_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(SwiftTesting_BuildMacrosAsExecutables)\n  # When swift-syntax is built locally, the macro plugin must be built as an\n  # executable.\n  add_executable(TestingMacros)\n\n  set_target_properties(TestingMacros PROPERTIES\n    ENABLE_EXPORTS TRUE)\n\n  # Parse the module as a library, even though it's an executable, because it\n  # uses an `@main` type to define its entry point.\n  target_compile_options(TestingMacros PRIVATE -parse-as-library)\n\n  # Include the .swift file which contains its `@main` entry point type.\n  target_compile_definitions(TestingMacros PRIVATE SWT_NO_LIBRARY_MACRO_PLUGINS)\n\n  install(TARGETS TestingMacros\n    RUNTIME DESTINATION bin)\nelse()\n  add_library(TestingMacros SHARED)\n\n  target_link_options(TestingMacros PRIVATE \"-no-toolchain-stdlib-rpath\")\n  set_property(TARGET TestingMacros PROPERTY BUILD_WITH_INSTALL_RPATH YES)\n\n  if(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n    set(plugin_destination_dir \"lib/swift/host/plugins/testing\")\n    set_property(TARGET TestingMacros PROPERTY INSTALL_RPATH)\n  else()\n    set(plugin_destination_dir \"lib/swift/host/plugins\")\n    # RPATH 'lib/swift/{system}' and 'lib/swift/host'\n    set_property(TARGET TestingMacros PROPERTY\n      INSTALL_RPATH \"$ORIGIN/../../$<LOWER_CASE:${CMAKE_SYSTEM_NAME}>;$ORIGIN/..\")\n  endif()\n\n  install(TARGETS TestingMacros\n    LIBRARY DESTINATION \"${plugin_destination_dir}\"\n    RUNTIME DESTINATION bin)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Associating a Test with a Bug ID and Title in Swift Testing\nDESCRIPTION: Demonstrates how to add a descriptive title to a bug association, providing more context about the bug being tested. The example associates a test with a bug and includes its title \"Forgot to buy more napkins\".\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/AssociatingBugs.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\n  \"Food truck has napkins\",\n  .bug(id: \"12345\", \"Forgot to buy more napkins\")\n)\nfunc hasNapkins() async {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Private Property Accessor in Swift\nDESCRIPTION: Example of using underscore prefix for private storage properties with public accessors that include validation logic.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/StyleGuide.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\nprivate var _errorCount: Int\n\npublic var errorCount: Int {\n  get {\n    _errorCount\n  }\n  set {\n    precondition(newValue >= 0, \"Error count cannot be negative\")\n    _errorCount = newValue\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SwiftSyntax Dependency for Swift Testing Macros\nDESCRIPTION: Handles the SwiftSyntax dependency, either finding an installed package or cloning and building it from source if building macros as executables.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/TestingMacros/CMakeLists.txt#2025-04-18_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(SwiftSyntax CONFIG GLOBAL)\n\nif(SwiftTesting_BuildMacrosAsExecutables)\n  # When building the macro plugin as an executable, clone and build\n  # swift-syntax.\n  include(FetchContent)\n  set(FETCHCONTENT_BASE_DIR ${CMAKE_BINARY_DIR}/_d)\n  FetchContent_Declare(SwiftSyntax\n    GIT_REPOSITORY https://github.com/swiftlang/swift-syntax\n    GIT_TAG 340f8400262d494c7c659cd838223990195d7fed) # 602.0.0-prerelease-2025-04-10\n  FetchContent_MakeAvailable(SwiftSyntax)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Customizing a Test Name in Swift Testing\nDESCRIPTION: Shows how to provide a custom display name for a test by passing a string literal to the @Test attribute. This improves readability in IDEs and command line output.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/DefiningTests.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\"Food truck exists\") func foodTruckExists() { ... }\n```\n\n----------------------------------------\n\nTITLE: Availability Constraints on Test Suite Types in Swift\nDESCRIPTION: This example demonstrates the requirement that test suite types and their containing types must always be available. It shows valid and invalid use of the @available attribute with test suites.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/OrganizingTests.md#2025-04-18_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@Suite struct FoodTruckTests { ... } // ✅ OK: The type is always available.\n\n@available(macOS 11.0, *) // ❌ ERROR: The suite type must always be available.\n@Suite struct CashRegisterTests { ... }\n\n@available(macOS 11.0, *) struct MenuItemTests { // ❌ ERROR: The suite type's\n                                                 // containing type must always\n                                                 // be available too.\n  @Suite struct BurgerTests { ... }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Library Autolinking for Swift Testing\nDESCRIPTION: Sets up compiler options for static library builds to enable autolinking of the internal libraries (_TestDiscovery and _TestingInternals), which ensures they are automatically included when the Testing library is linked.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/CMakeLists.txt#2025-04-18_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT BUILD_SHARED_LIBS)\n  # When building a static library, tell clients to autolink the internal\n  # libraries.\n  target_compile_options(Testing PRIVATE\n    \"SHELL:-Xfrontend -public-autolink-library -Xfrontend _TestDiscovery\"\n    \"SHELL:-Xfrontend -public-autolink-library -Xfrontend _TestingInternals\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Basic Swift Testing Expectation Example\nDESCRIPTION: Demonstrates a simple expectation using the #expect macro with a comparison operation\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n#expect(f() < g())\n```\n\n----------------------------------------\n\nTITLE: Test Suite Type Constraints and Initializer Requirements in Swift\nDESCRIPTION: This code block illustrates the constraints on test suite types, particularly the requirement for a zero-argument initializer when using instance method test functions. It shows valid and invalid examples.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/OrganizingTests.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Suite struct FoodTruckTests {\n  var batteryLevel = 100\n\n  @Test func foodTruckExists() { ... } // ✅ OK: The type has an implicit init().\n}\n\n@Suite struct CashRegisterTests {\n  private init(cashOnHand: Decimal = 0.0) async throws { ... }\n\n  @Test func calculateSalesTax() { ... } // ✅ OK: The type has a callable init().\n}\n\nstruct MenuTests {\n  var foods: [Food]\n  var prices: [Food: Decimal]\n\n  @Test static func specialOfTheDay() { ... } // ✅ OK: The function is static.\n  @Test func orderAllFoods() { ... } // ❌ ERROR: The suite type requires init().\n}\n```\n\n----------------------------------------\n\nTITLE: Listing and Filtering Swift Tests in WebAssembly\nDESCRIPTION: Commands to list all available tests and run specific tests by applying filters. These examples show how to pass command-line arguments to the WebAssembly program through the Wasmtime runtime.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/WASI.md#2025-04-18_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nwasmtime .build/debug/{YOURPACKAGE}PackageTests.wasm list --testing-library swift-testing\nwasmtime .build/debug/{YOURPACKAGE}PackageTests.wasm --testing-library swift-testing --filter \"FoodTruckTests.foodTruckExists\"\n```\n\n----------------------------------------\n\nTITLE: Applying Disabled Trait in Swift Testing\nDESCRIPTION: This code snippet demonstrates how to apply the 'disabled' trait to a test function or suite. It conditionally disables the test based on a given condition.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/Traits.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Trait.disabled(if: condition, \"Reason for disabling\")\n```\n\n----------------------------------------\n\nTITLE: Breaking up complex expressions to avoid type-checking issues\nDESCRIPTION: Example showing how to break up complex expressions into separate variable assignments before using them in a #expect macro to avoid overwhelming the type checker.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_7\n\nLANGUAGE: swift\nCODE:\n```\nlet x = ...\nlet y = ...\n#expect(x == y)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Tag Declaration Examples\nDESCRIPTION: Demonstrates unsupported ways of declaring tags, including redeclaration and incorrect placement of tag declarations.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/AddingTags.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\nextension Tag {\n  @Tag static var legallyRequired: Self // ✅ OK: Declaring a new tag.\n\n  static var requiredByLaw: Self { // ❌ ERROR: This tag name isn't\n                                   // recognized at runtime.\n    legallyRequired\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using #expect with try outside the macro (problematic pattern)\nDESCRIPTION: An example of a problematic pattern where the effect keyword (try) is placed to the left of the macro name, which causes issues with the current macro implementation.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\ntry #expect(h())\n```\n\n----------------------------------------\n\nTITLE: Limiting Test Availability Based on OS and Swift Version\nDESCRIPTION: Shows how to use the @available attribute to restrict when a test can run based on OS version and Swift language version requirements. Includes a custom message for unavailable tests.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/DefiningTests.md#2025-04-18_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@available(macOS 11.0, *)\n@available(swift, introduced: 8.0, message: \"Requires Swift 8.0 features to run\")\n@Test func foodTruckExists() { ... }\n```\n\n----------------------------------------\n\nTITLE: After expansion of complex logical expression with #expect\nDESCRIPTION: The new expansion implementation of #expect for a complex logical expression, demonstrating how the context is captured for each subexpression with unique identifiers.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_13\n\nLANGUAGE: swift\nCODE:\n```\nTesting.__checkCondition(\n  { (__ec: inout Testing.__ExpectationContext) -> Swift.Bool in\n    __ec(__ec(__ec(x, 0x6) && __ec(y, 0x42), 0x2) && __ec(!__ec(z, 0x1400), 0x400), 0x0)\n  },\n  sourceCode: [\n    0x0: \"x && y && !z\",\n    0x2: \"x && y\",\n    0x6: \"x\",\n    0x42: \"y\",\n    0x400: \"!z\",\n    0x1400: \"z\"\n  ],\n  comments: [],\n  isRequired: false,\n  sourceLocation: Testing.SourceLocation.__here()\n).__expected()\n```\n\n----------------------------------------\n\nTITLE: Error Handling Expectation Example\nDESCRIPTION: Demonstrates current limitations with throwing functions in expectations\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n#expect(try f() < g())\n```\n\n----------------------------------------\n\nTITLE: Converting XCTest setUp method to Swift Testing initializer\nDESCRIPTION: Shows how to replace XCTest's setUp method with a standard Swift initializer in a testing suite. This demonstrates handling asynchronous setup code and instance property initialization.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/MigratingFromXCTest.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n// Before\nclass FoodTruckTests: XCTestCase {\n  var batteryLevel: NSNumber!\n  override func setUp() async throws {\n    batteryLevel = 100\n  }\n  ...\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\n// After\nstruct FoodTruckTests {\n  var batteryLevel: NSNumber\n  init() async throws {\n    batteryLevel = 100\n  }\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Before expansion of complex logical expression with #expect\nDESCRIPTION: The original expansion implementation of #expect for a complex logical expression with multiple operators, showing the previous approach to handling nested conditions.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_12\n\nLANGUAGE: swift\nCODE:\n```\nTesting.__checkBinaryOperation(\n  x && y,\n  { $0 && $1() },\n  !z,\n  expression: .__fromBinaryOperation(\n    .__fromSyntaxNode(\"x && y\"),\n    \"&&\",\n    .__fromSyntaxNode(\"!z\")\n  ),\n  comments: [],\n  isRequired: false,\n  sourceLocation: Testing.SourceLocation.__here()\n).__expected()\n```\n\n----------------------------------------\n\nTITLE: Using Bug Reports in Test Conditions for Swift Testing Framework\nDESCRIPTION: Shows how to reference a bug report when disabling a test, providing context for why the test cannot run.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/EnablingAndDisabling.md#2025-04-18_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n@Test(\n  \"Ice cream is cold\",\n  .enabled(if: Season.current == .summer),\n  .disabled(\"We ran out of sprinkles\"),\n  .bug(id: \"12345\")\n)\nfunc isCold() async throws { ... }\n```\n\n----------------------------------------\n\nTITLE: Complex Logical Expression Example\nDESCRIPTION: Shows a more complex expectation using logical operators that currently has limitations in expansion\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_1\n\nLANGUAGE: swift\nCODE:\n```\n#expect(x && y && !z)\n```\n\n----------------------------------------\n\nTITLE: Before expansion of throwing function comparison with #expect\nDESCRIPTION: The original expansion implementation of #expect for a comparison involving a throwing function, showing how try was handled previously.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_14\n\nLANGUAGE: swift\nCODE:\n```\nTesting.__checkValue(\n  try f() < g(),\n  expression: .__fromSyntaxNode(\"try f() < g()\"),\n  comments: [],\n  isRequired: false,\n  sourceLocation: Testing.SourceLocation.__here()\n).__expected()\n```\n\n----------------------------------------\n\nTITLE: Declaring C External Functions\nDESCRIPTION: Example of C function declarations using the swt_ prefix and SWT_EXTERN macro for cross-language visibility.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/StyleGuide.md#2025-04-18_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nSWT_EXTERN bool swt_isDebugModeEnabled(void);\n\nSWT_EXTERN void swt_setDebugModeEnabled(bool isEnabled);\n```\n\n----------------------------------------\n\nTITLE: Enumerating and Loading Test Content Records in Swift\nDESCRIPTION: This code demonstrates how to enumerate test content records and load them into instances of the conforming type. It uses the `allTestContentRecords()` method and the `load()` function with an optional hint.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/TestContent.md#2025-04-18_snippet_5\n\nLANGUAGE: swift\nCODE:\n```\nfor diagnosticRecord in FoodTruckDiagnostic.allTestContentRecords() {\n  if diagnosticRecord.context.pointee == .briansBranMuffins {\n    if let diagnostic = diagnosticRecord.load(withHint: \"...\") {\n      diagnostic.run()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Potentially problematic expression with ambiguous reference\nDESCRIPTION: An example of an expression where the macro can't determine if a syntax node refers to a variable, type, or module, which may cause expansion issues.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_8\n\nLANGUAGE: swift\nCODE:\n```\n#expect(a.b == c) // a may not be expressible in isolation\n```\n\n----------------------------------------\n\nTITLE: Setting Platform-Specific Installation Runtime Path (RPATH)\nDESCRIPTION: Configures installation RPATH with platform-specific values for Darwin (macOS) and other platforms, and disables environment RPATH.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_INSTALL_RPATH \"$<IF:$<PLATFORM_ID:Darwin>,@loader_path/..,$ORIGIN>\")\nset(CMAKE_INSTALL_REMOVE_ENVIRONMENT_RPATH YES)\n```\n\n----------------------------------------\n\nTITLE: Equivalent Static Test Function Implementation in Swift\nDESCRIPTION: This snippet demonstrates the equivalent implementation of an instance method test function as a static method. It shows how the testing library internally handles instance method test functions.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/OrganizingTests.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@Suite struct FoodTruckTests {\n  func foodTruckExists() { ... }\n\n  @Test static func staticFoodTruckExists() {\n    let instance = FoodTruckTests()\n    instance.foodTruckExists()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Including Platform-Specific Headers in Swift Testing\nDESCRIPTION: Demonstrates how to add platform-specific headers to the internal module's Includes.h file. This example shows adding DateTimeUtils.h for a hypothetical Classic Mac OS port using conditional compilation.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/Porting.md#2025-04-18_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n--- a/Sources/_TestingInternals/include/Includes.h\n+++ b/Sources/_TestingInternals/include/Includes.h\n\n+#if defined(macintosh)\n+#include <DateTimeUtils.h>\n+#endif\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Module Path and Output Directories\nDESCRIPTION: Sets up module search paths and defines standard output directories for libraries, archives, and executables.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(GNUInstallDirs)\n\nlist(APPEND CMAKE_MODULE_PATH\n  ${PROJECT_SOURCE_DIR}/cmake/modules\n  ${PROJECT_SOURCE_DIR}/cmake/modules/shared)\n\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\n```\n\n----------------------------------------\n\nTITLE: Defining SPI Groups for Swift Testing\nDESCRIPTION: This snippet demonstrates the syntax for defining SPI groups in Swift Testing. It shows how to use @_spi attributes for different purposes such as tool integration and experimental features.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/SPI.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\n@_spi(ForToolsIntegrationOnly)\n@_spi(Experimental)\n```\n\n----------------------------------------\n\nTITLE: Adding Platform-Specific Section Attributes for Test Content\nDESCRIPTION: Shows how to update the makeTestContentRecordDecl() function in the TestingMacros target to emit the correct @_section attribute for a new platform. The example adds support for Classic Mac OS.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/Porting.md#2025-04-18_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n--- a/Sources/TestingMacros/Support/TestContentGeneration.swift\n+++ b/Sources/TestingMacros/Support/TestContentGeneration.swift\n   // ...\n+  #elseif os(Classic)\n+  @_section(\".rsrc,swft,__swift5_tests\")\n   #else\n   @__testing(warning: \"Platform-specific implementation missing: test content section name unavailable\")\n   #endif\n```\n\n----------------------------------------\n\nTITLE: Defining a Swift Testing Executable in CMake\nDESCRIPTION: This snippet shows how to define a test executable for Swift Testing in CMake. It creates an executable with the .swift-testing suffix and links it with the Testing library and other project targets.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/CMake.md#2025-04-18_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_executable(ExamplePackageTests\n  ExampleTests.swift\n  ...)\nset_target_properties(ExamplePackageTests PROPERTIES\n  SUFFIX .swift-testing)\ntarget_link_libraries(ExamplePackageTests PRIVATE\n  Example\n  Testing\n  ...)\n```\n\n----------------------------------------\n\nTITLE: Initializing SwiftTesting Project with CXX and Swift Languages\nDESCRIPTION: Defines the SwiftTesting project and specifies that it uses C++ and Swift programming languages.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nproject(SwiftTesting\n  LANGUAGES CXX Swift)\n```\n\n----------------------------------------\n\nTITLE: Importing TestDiscovery Module in Swift\nDESCRIPTION: This snippet shows how to import the `_TestDiscovery` module with SPI enabled. This is necessary for adding test content discovery support to a package.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/TestContent.md#2025-04-18_snippet_2\n\nLANGUAGE: swift\nCODE:\n```\n@_spi(Experimental) @_spi(ForToolsIntegrationOnly) import _TestDiscovery\n```\n\n----------------------------------------\n\nTITLE: Integrating Swift Testing with CTest\nDESCRIPTION: This snippet shows how to register the Swift Testing executable with CTest to enable running tests through the CTest framework.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/CMake.md#2025-04-18_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(CTest)\nadd_test(NAME ExamplePackageTests\n  COMMAND ExamplePackageTests)\n```\n\n----------------------------------------\n\nTITLE: Handling CMake Policy CMP0157 for Android Cross-Compilation\nDESCRIPTION: Sets CMake policy CMP0157 based on build environment, with special handling for Windows-to-Android cross-compilation to avoid issues with swift-driver availability.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(POLICY CMP0157)\n  if(CMAKE_HOST_SYSTEM_NAME STREQUAL Windows AND CMAKE_SYSTEM_NAME STREQUAL Android)\n    # CMP0157 causes builds to fail when targetting Android with the Windows\n    # toolchain, because the early swift-driver isn't (yet) available. Disable\n    # it for now.\n    cmake_policy(SET CMP0157 OLD)\n  else()\n    cmake_policy(SET CMP0157 NEW)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: After expansion of simple comparison with #expect\nDESCRIPTION: The new expansion implementation of #expect for a binary comparison operation, showing how expressions are now handled with better context capture.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_11\n\nLANGUAGE: swift\nCODE:\n```\nTesting.__checkCondition(\n  { (__ec: inout Testing.__ExpectationContext) -> Swift.Bool in\n    __ec(__ec(f(), 0x2) < __ec(g(), 0x400), 0x0)\n  },\n  sourceCode: [\n    0x0: \"f() < g()\",\n    0x2: \"f()\",\n    0x400: \"g()\"\n  ],\n  comments: [],\n  isRequired: false,\n  sourceLocation: Testing.SourceLocation.__here()\n).__expected()\n```\n\n----------------------------------------\n\nTITLE: Enabling Testing Mode in CMake for Swift\nDESCRIPTION: This snippet demonstrates how to enable testing mode when building Swift code in CMake. It adds the -enable-testing compiler option only when testing is enabled.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/CMake.md#2025-04-18_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(CTest)\nif(BUILD_TESTING)\n  add_compile_options($<$<COMPILE_LANGUAGE:Swift>:-enable-testing>)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Version Requirements for SwiftTesting\nDESCRIPTION: Sets the minimum required CMake version range for building the SwiftTesting project.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.19.6...3.29)\n```\n\n----------------------------------------\n\nTITLE: Implementing Platform-Specific Clock Functionality in Swift\nDESCRIPTION: Shows how to implement platform-specific time functionality in the Clock.swift file. This example demonstrates using the GetDateTime() function for Classic Mac OS with epoch time adjustment.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/Porting.md#2025-04-18_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n--- a/Sources/Testing/Events/Clock.swift\n+++ b/Sources/Testing/Events/Clock.swift\n\n fileprivate(set) var wall: TimeValue = {\n #if !SWT_NO_TIMESPEC\n   // ...\n+#elseif os(Classic)\n+  var seconds = CUnsignedLong(0)\n+  GetDateTime(&seconds)\n+  seconds -= 2_082_844_800 // seconds between epochs\n+  return TimeValue((seconds: Int64(seconds), attoseconds: 0))\n #else\n #warning(\"Platform-specific implementation missing: UTC time unavailable (no timespec)\")\n #endif\n }\n```\n\n----------------------------------------\n\nTITLE: Running Swift Tests with Wasmtime\nDESCRIPTION: Command to run WebAssembly tests using the Wasmtime runtime. This executes the compiled WebAssembly module with the swift-testing library parameter. Replace {YOURPACKAGE} with your actual package name.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/WASI.md#2025-04-18_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nwasmtime .build/debug/{YOURPACKAGE}PackageTests.wasm --testing-library swift-testing\n```\n\n----------------------------------------\n\nTITLE: Before expansion of simple comparison with #expect\nDESCRIPTION: The original expansion implementation of #expect for a binary comparison operation, showing how expressions were handled before the redesign.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_10\n\nLANGUAGE: swift\nCODE:\n```\nTesting.__checkBinaryOperation(\n  f(),\n  { $0 < $1() },\n  g(),\n  expression: .__fromBinaryOperation(\n    .__fromSyntaxNode(\"f()\"),\n    \"<\",\n    .__fromSyntaxNode(\"g()\")\n  ),\n  comments: [],\n  isRequired: false,\n  sourceLocation: Testing.SourceLocation.__here()\n).__expected()\n```\n\n----------------------------------------\n\nTITLE: Installing Testing Foundation Target\nDESCRIPTION: Installs the _Testing_Foundation target using a custom Swift testing installation function.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Overlays/_Testing_Foundation/CMakeLists.txt#2025-04-18_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n_swift_testing_install_target(_Testing_Foundation)\n```\n\n----------------------------------------\n\nTITLE: Invalid Tag Declaration Locations\nDESCRIPTION: Shows examples of invalid tag declarations outside of Tag extensions.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/AddingTags.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\n@Tag let needsKetchup: Self // ❌ ERROR: Tags must be declared in an extension\n                            // to Tag.\nstruct Food {\n  @Tag var needsMustard: Self // ❌ ERROR: Tags must be declared in an extension\n                              // to Tag.\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Swift Module Interface Generation\nDESCRIPTION: Sets compilation options for generating module interface without Library Evolution support. Specifies the output path for the Swift interface file.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Overlays/_Testing_Foundation/CMakeLists.txt#2025-04-18_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_compile_options(_Testing_Foundation PRIVATE\n  -emit-module-interface -emit-module-interface-path $<TARGET_PROPERTY:_Testing_Foundation,Swift_MODULE_DIRECTORY>/_Testing_Foundation.swiftinterface)\n```\n\n----------------------------------------\n\nTITLE: Defining Test Content Record Type Structure in Swift\nDESCRIPTION: Defines the Swift type structure for test content records used by the Swift Testing library. This includes the Accessor function type and the TestContentRecord tuple structure that stores test metadata in binary sections.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/TestContent.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\ntypealias Accessor = @convention(c) (\n  _ outValue: UnsafeMutableRawPointer,\n  _ type: UnsafeRawPointer,\n  _ hint: UnsafeRawPointer?,\n  _ reserved: UInt\n) -> CBool\n\ntypealias TestContentRecord = (\n  kind: UInt32,\n  reserved1: UInt32,\n  accessor: Accessor?,\n  context: UInt,\n  reserved2: UInt\n)\n```\n\n----------------------------------------\n\nTITLE: Linking Testing Library Dependencies\nDESCRIPTION: Links the Testing library as a public dependency for _Testing_Foundation.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Overlays/_Testing_Foundation/CMakeLists.txt#2025-04-18_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(_Testing_Foundation PUBLIC\n  Testing)\n```\n\n----------------------------------------\n\nTITLE: Defining Test Content Record Structure in C\nDESCRIPTION: Provides the C structure equivalent of the Swift TestContentRecord type. This allows C code to interact with the test content records emitted by Swift Testing.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/TestContent.md#2025-04-18_snippet_1\n\nLANGUAGE: c\nCODE:\n```\ntypedef bool (* SWTAccessor)(\n  void *outValue,\n  const void *type,\n  const void *_Nullable hint,\n  uintptr_t reserved\n);\n\nstruct SWTTestContentRecord {\n  uint32_t kind;\n  uint32_t reserved1;\n  SWTAccessor _Nullable accessor;\n  uintptr_t context;\n  uintptr_t reserved2;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Common Data Types in JSON Schema for Swift Testing\nDESCRIPTION: Defines basic data types used throughout the Swift testing framework JSON schema, including boolean values, source location information, timestamp instants, and version specification.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/JSON.md#2025-04-18_snippet_0\n\nLANGUAGE: bnf\nCODE:\n```\n<bool> ::= true | false ; as in JSON\n\n<source-location> ::= {\n  \"fileID\": <string>, ; the Swift file ID of the file\n  \"line\": <number>,\n  \"column\": <number>,\n}\n\n<instant> ::= {\n  \"absolute\": <number>, ; floating-point seconds since system-defined epoch\n  \"since1970\": <number>, ; floating-point seconds since 1970-01-01 00:00:00 UT\n}\n\n<version> ::= \"version\": 0 ; will be incremented as the format changes\n```\n\n----------------------------------------\n\nTITLE: Adding Testing Foundation Subdirectory in CMake\nDESCRIPTION: CMake command to include the _Testing_Foundation subdirectory in the build process. This ensures the Testing Foundation components are built as part of the Swift testing framework.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Overlays/CMakeLists.txt#2025-04-18_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_subdirectory(_Testing_Foundation)\n```\n\n----------------------------------------\n\nTITLE: Configuring Platform-Specific Dependencies for Swift Testing Library\nDESCRIPTION: Sets up platform-specific dependencies for non-Apple platforms, including dispatch and Foundation libraries. Special handling is added for FreeBSD which requires the execinfo library, and WASI which doesn't need dispatch.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/CMakeLists.txt#2025-04-18_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT APPLE)\n  if(NOT CMAKE_SYSTEM_NAME STREQUAL WASI)\n    target_link_libraries(Testing PUBLIC\n      dispatch)\n  endif()\n  target_link_libraries(Testing PUBLIC\n    Foundation)\n  if (CMAKE_SYSTEM_NAME STREQUAL \"FreeBSD\")\n    target_link_libraries(Testing PUBLIC execinfo)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Event Record Structure for Swift Testing Framework\nDESCRIPTION: Specifies the JSON structure for event records, which represent things that happen during testing such as test starts, issues, and value attachments. Each event includes timing information and human-readable messages.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/JSON.md#2025-04-18_snippet_4\n\nLANGUAGE: bnf\nCODE:\n```\n<event> ::= {\n  \"kind\": <event-kind>,\n  \"instant\": <instant>, ; when the event occurred\n  [\"issue\": <issue>,] ; the recorded issue (if \"kind\" is \"issueRecorded\")\n  [\"attachment\": <attachment>,] ; the attachment (if kind is \"valueAttached\")\n  \"messages\": <array:message>,\n  [\"testID\": <test-id>,]\n}\n\n<event-kind> ::= \"runStarted\" | \"testStarted\" | \"testCaseStarted\" |\n  \"issueRecorded\" | \"testCaseEnded\" | \"testEnded\" | \"testSkipped\" |\n  \"runEnded\" | \"valueAttached\"; additional event kinds may be added in the future\n\n<issue> ::= {\n  \"isKnown\": <bool>, ; is this a known issue or not?\n  [\"sourceLocation\": <source-location>,] ; where the issue occurred, if known\n}\n\n<attachment> ::= {\n  \"path\": <string>, ; the absolute path to the attachment on disk\n}\n\n<message> ::= {\n  \"symbol\": <message-symbol>,\n  \"text\": <string>, ; the human-readable text of this message\n}\n\n<message-symbol> ::= \"default\" | \"skip\" | \"pass\" | \"passWithKnownIssue\" |\n  \"fail\" | \"difference\" | \"warning\" | \"details\"\n```\n\n----------------------------------------\n\nTITLE: Including SwiftTesting Subdirectories in CMake\nDESCRIPTION: Includes various subdirectories and CMake modules required for the SwiftTesting project, such as availability definitions, compiler settings, and testing components.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/CMakeLists.txt#2025-04-18_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(AvailabilityDefinitions)\ninclude(CompilerSettings)\nadd_subdirectory(_TestDiscovery)\nadd_subdirectory(_TestingInternals)\nadd_subdirectory(Overlays)\nadd_subdirectory(Testing)\n```\n\n----------------------------------------\n\nTITLE: Defining Test Record Structure for Swift Testing Framework\nDESCRIPTION: Specifies the JSON structure for test records, which represent individual test functions and test suites. These include details like the test name, source location, and unique identifier.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/JSON.md#2025-04-18_snippet_3\n\nLANGUAGE: bnf\nCODE:\n```\n<test> ::= <test-suite> | <test-function>\n\n<test-suite> ::= {\n  \"kind\": \"suite\",\n  \"name\": <string>, ; the unformatted, unqualified type name\n  [\"displayName\": <string>,] ; the user-supplied custom display name\n  \"sourceLocation\": <source-location>, ; where the test suite is defined\n  \"id\": <test-id>,\n}\n\n<test-function> ::= {\n  \"kind\": \"function\",\n  \"name\": <string>, ; the unformatted function name\n  [\"displayName\": <string>,] ; the user-supplied custom display name\n  \"sourceLocation\": <source-location>, ; where the test is defined\n  \"id\": <test-id>,\n  \"isParameterized\": <bool> ; is this a parameterized test function or not?\n}\n\n<test-id> ::= <string> ; an opaque string representing the test case\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Kebab-Case Filename for DocC Bundle Article\nDESCRIPTION: Example of how to name a Markdown file for a DocC bundle article using kebab-case, based on the article title.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/StyleGuide.md#2025-04-18_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\nadding-tags-to-tests.md\n```\n\n----------------------------------------\n\nTITLE: Configuring SwiftTesting Macro Path in CMake\nDESCRIPTION: Sets up a cache variable for the SwiftTesting macro plugin path, allowing for automatic building or custom path specification.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/CMakeLists.txt#2025-04-18_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(SwiftTesting_MACRO \"<auto>\" CACHE STRING\n    \"Path to SwiftTesting macro plugin, or '<auto>' for automatically building it\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Core Dependencies for Swift Testing Library\nDESCRIPTION: Links the Testing library with its core dependencies _TestDiscovery and _TestingInternals, which are essential components for the framework's functionality.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/CMakeLists.txt#2025-04-18_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(Testing PRIVATE\n  _TestDiscovery\n  _TestingInternals)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Kebab-Case Filename for DocC Bundle API Collection\nDESCRIPTION: Example of how to name a Markdown file for a DocC bundle API collection page using kebab-case, based on the collection title.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/StyleGuide.md#2025-04-18_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nevent-tags.md\n```\n\n----------------------------------------\n\nTITLE: Installing Swift Testing Library and Cross-Import Overlay\nDESCRIPTION: Configures the installation of the Testing target and its Swift cross-import overlay directory, which enables integration with other Swift modules through cross-imports.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/CMakeLists.txt#2025-04-18_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\n_swift_testing_install_target(Testing)\n\n# Install the Swift cross-import overlay directory.\n_swift_testing_install_swiftcrossimport(Testing\n  Testing.swiftcrossimport)\n```\n\n----------------------------------------\n\nTITLE: Swift Package Manager Dependency Configuration\nDESCRIPTION: Package.swift configuration for adding Swift Testing dependency from development branch\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_3\n\nLANGUAGE: swift\nCODE:\n```\ndependencies: [\n  /* ... */\n  .package(\n    url: \"https://github.com/swiftlang/swift-testing.git\",\n    branch: \"jgrynspan/162-redesign-value-capture\"\n  ),\n],\n```\n\n----------------------------------------\n\nTITLE: Automatic Building of SwiftTesting Macro Plugin using ExternalProject in CMake\nDESCRIPTION: Configures and builds the SwiftTesting macro plugin as an external project when the path is set to '<auto>'. It sets up build flags, finds SwiftSyntax, and determines whether to build macros as executables.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/CMakeLists.txt#2025-04-18_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(SwiftTesting_MACRO STREQUAL \"<auto>\")\n  # Macros must be built for the build machine, not the host.\n  include(ExternalProject)\n  if(NOT SwiftTesting_MACRO_MAKE_PROGRAM)\n    set(SwiftTesting_MACRO_MAKE_PROGRAM ${CMAKE_MAKE_PROGRAM})\n  endif()\n  # ... (additional configuration)\n  ExternalProject_Add(TestingMacros\n    PREFIX \"tm\"\n    SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/TestingMacros\"\n    BUILD_ALWAYS ON\n    CMAKE_ARGS\n      -DCMAKE_MAKE_PROGRAM=${SwiftTesting_MACRO_MAKE_PROGRAM}\n      # ... (additional arguments)\n      -DCMAKE_INSTALL_PREFIX=${SwiftTesting_MACRO_INSTALL_PREFIX})\n  # ... (path determination based on system)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Swift Testing Library Source Files in CMake\nDESCRIPTION: Defines the 'Testing' library target with a comprehensive list of source files organized by functionality areas including ABI, Attachments, Events, ExitTests, Expectations, Issues, Parameterization, Running, SourceAttribution, Support, and Traits.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/CMakeLists.txt#2025-04-18_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(Testing\n  ABI/EntryPoints/ABIEntryPoint.swift\n  ABI/EntryPoints/EntryPoint.swift\n  ABI/EntryPoints/SwiftPMEntryPoint.swift\n  ABI/ABI.Record.swift\n  ABI/ABI.Record+Streaming.swift\n  ABI/ABI.swift\n  ABI/Encoded/ABI.EncodedAttachment.swift\n  ABI/Encoded/ABI.EncodedBacktrace.swift\n  ABI/Encoded/ABI.EncodedError.swift\n  ABI/Encoded/ABI.EncodedEvent.swift\n  ABI/Encoded/ABI.EncodedInstant.swift\n  ABI/Encoded/ABI.EncodedIssue.swift\n  ABI/Encoded/ABI.EncodedMessage.swift\n  ABI/Encoded/ABI.EncodedTest.swift\n  Attachments/Attachable.swift\n  Attachments/AttachableWrapper.swift\n  Attachments/Attachment.swift\n  Events/Clock.swift\n  Events/Event.swift\n  Events/Recorder/Event.ConsoleOutputRecorder.swift\n  Events/Recorder/Event.HumanReadableOutputRecorder.swift\n  Events/Recorder/Event.JUnitXMLRecorder.swift\n  Events/Recorder/Event.Symbol.swift\n  Events/TimeValue.swift\n  ExitTests/ExitTest.swift\n  ExitTests/ExitTest.CapturedValue.swift\n  ExitTests/ExitTest.Condition.swift\n  ExitTests/ExitTest.Result.swift\n  ExitTests/SpawnProcess.swift\n  ExitTests/StatusAtExit.swift\n  ExitTests/WaitFor.swift\n  Expectations/Expectation.swift\n  Expectations/Expectation+Macro.swift\n  Expectations/ExpectationChecking+Macro.swift\n  Issues/Confirmation.swift\n  Issues/ErrorSnapshot.swift\n  Issues/Issue.swift\n  Issues/Issue+Recording.swift\n  Issues/KnownIssue.swift\n  Parameterization/CustomTestArgumentEncodable.swift\n  Parameterization/Test.Case.Generator.swift\n  Parameterization/Test.Case.ID.swift\n  Parameterization/Test.Case.swift\n  Parameterization/TypeInfo.swift\n  Running/Configuration.swift\n  Running/Configuration.TestFilter.swift\n  Running/Configuration+EventHandling.swift\n  Running/Runner.Plan.swift\n  Running/Runner.Plan+Dumping.swift\n  Running/Runner.RuntimeState.swift\n  Running/Runner.swift\n  Running/SkipInfo.swift\n  SourceAttribution/Backtrace.swift\n  SourceAttribution/Backtrace+Symbolication.swift\n  SourceAttribution/CustomTestStringConvertible.swift\n  SourceAttribution/Expression.swift\n  SourceAttribution/Expression+Macro.swift\n  SourceAttribution/SourceContext.swift\n  SourceAttribution/SourceLocation.swift\n  SourceAttribution/SourceLocation+Macro.swift\n  Support/Additions/ArrayAdditions.swift\n  Support/Additions/CollectionDifferenceAdditions.swift\n  Support/Additions/CommandLineAdditions.swift\n  Support/Additions/NumericAdditions.swift\n  Support/Additions/ResultAdditions.swift\n  Support/Additions/WinSDKAdditions.swift\n  Support/CartesianProduct.swift\n  Support/CError.swift\n  Support/CustomIssueRepresentable.swift\n  Support/Environment.swift\n  Support/FileHandle.swift\n  Support/GetSymbol.swift\n  Support/Graph.swift\n  Support/JSON.swift\n  Support/Locked.swift\n  Support/Locked+Platform.swift\n  Support/Versions.swift\n  Discovery+Macro.swift\n  Test.ID.Selection.swift\n  Test.ID.swift\n  Test.swift\n  Test+Discovery.swift\n  Test+Discovery+Legacy.swift\n  Test+Macro.swift\n  Traits/Bug.swift\n  Traits/Comment.swift\n  Traits/Comment+Macro.swift\n  Traits/ConditionTrait.swift\n  Traits/ConditionTrait+Macro.swift\n  Traits/HiddenTrait.swift\n  Traits/ParallelizationTrait.swift\n  Traits/Tags/Tag.Color.swift\n  Traits/Tags/Tag.Color+Loading.swift\n  Traits/Tags/Tag.List.swift\n  Traits/Tags/Tag.swift\n  Traits/Tags/Tag+Macro.swift\n  Traits/Tags/Tag+Predefined.swift\n  Traits/TimeLimitTrait.swift\n  Traits/Trait.swift)\n```\n\n----------------------------------------\n\nTITLE: Test Target Configuration\nDESCRIPTION: Configuration for adding Swift Testing as a dependency to a test target\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ExpectationCapture.md#2025-04-18_snippet_4\n\nLANGUAGE: swift\nCODE:\n```\n.testTarget(\n  name: \"MyTests\",\n  dependencies: [\n    /* ... */\n    .productItem(name: \"Testing\", package: \"swift-testing\"),\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Including Platform and Swift Module Installation CMake Modules\nDESCRIPTION: Includes custom CMake modules for platform information and Swift module installation.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(PlatformInfo)\ninclude(SwiftModuleInstallation)\n```\n\n----------------------------------------\n\nTITLE: Implementing Platform-Specific Stub for isTTY Property in Swift\nDESCRIPTION: This code snippet demonstrates how to implement a platform-specific stub for the isTTY property of the FileHandle type in Swift Testing. It provides a fallback implementation for platforms like Classic that don't support pseudoterminals.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/Porting.md#2025-04-18_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\n--- a/Sources/Testing/Support/FileHandle.swift\n+++ b/Sources/Testing/Support/FileHandle.swift\n\n var isTTY: Bool {\n #if SWT_TARGET_OS_APPLE || os(Linux) || os(FreeBSD) || os(OpenBSD) || os(Android) || os(WASI)\n   // ...\n+#elseif os(Classic)\n+  return false\n #else\n #warning(\"Platform-specific implementation missing: cannot tell if a file is a TTY\")\n   return false\n #endif\n }\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Streams Structure for Swift Testing Output\nDESCRIPTION: Specifies the format of output streams in the Swift testing framework, which consist of a sequence of values encoded as JSON Lines. Each line in the stream represents a single output record.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/ABI/JSON.md#2025-04-18_snippet_1\n\nLANGUAGE: bnf\nCODE:\n```\n<output-stream> ::= <output-record>\\n | <output-record>\\n <output-stream>\n```\n\n----------------------------------------\n\nTITLE: Configuring Installation Directories with Nested Subdirectory Option\nDESCRIPTION: Defines an option for nested installation subdirectories and sets up library and Swift module installation paths with platform-specific configurations.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\noption(SwiftTesting_INSTALL_NESTED_SUBDIR \"Install libraries under a platform and architecture subdirectory\" NO)\nset(SwiftTesting_INSTALL_LIBDIR \"${CMAKE_INSTALL_LIBDIR}/swift$<$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>:_static>/${SwiftTesting_PLATFORM_SUBDIR}$<$<AND:$<PLATFORM_ID:Darwin>,$<NOT:$<BOOL:${SwiftTesting_INSTALL_NESTED_SUBDIR}>>>:/testing>$<$<BOOL:${SwiftTesting_INSTALL_NESTED_SUBDIR}>:/${SwiftTesting_ARCH_SUBDIR}>\")\nset(SwiftTesting_INSTALL_SWIFTMODULEDIR \"${CMAKE_INSTALL_LIBDIR}/swift$<$<NOT:$<BOOL:${BUILD_SHARED_LIBS}>>:_static>/${SwiftTesting_PLATFORM_SUBDIR}$<$<AND:$<PLATFORM_ID:Darwin>,$<NOT:$<BOOL:${SwiftTesting_INSTALL_NESTED_SUBDIR}>>>:/testing>\")\n```\n\n----------------------------------------\n\nTITLE: Importing Swift Testing Traits Module\nDESCRIPTION: This code snippet demonstrates how to import the Swift Testing Traits module. It is inferred from the context of the documentation.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/Testing.docc/Traits.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\nimport Testing\n```\n\n----------------------------------------\n\nTITLE: Configuring Testing Foundation Library Components\nDESCRIPTION: Defines the _Testing_Foundation library components and their source files. Includes various Swift files related to attachments, events, and testing functionality.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Overlays/_Testing_Foundation/CMakeLists.txt#2025-04-18_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(_Testing_Foundation\n  Attachments/_AttachableURLWrapper.swift\n  Attachments/EncodingFormat.swift\n  Attachments/Attachment+URL.swift\n  Attachments/Attachable+NSSecureCoding.swift\n  Attachments/Data+Attachable.swift\n  Attachments/Attachable+Encodable+NSSecureCoding.swift\n  Attachments/Attachable+Encodable.swift\n  Events/Clock+Date.swift\n  ReexportTesting.swift)\n```\n\n----------------------------------------\n\nTITLE: Finding Required Dependencies for Non-Apple Platforms\nDESCRIPTION: Locates dispatch and Foundation packages required for non-Apple platforms, with special handling for WASI (WebAssembly System Interface).\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT APPLE)\n  if(NOT CMAKE_SYSTEM_NAME STREQUAL WASI)\n    find_package(dispatch CONFIG)\n  endif()\n  find_package(Foundation CONFIG)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Including Sources Subdirectory\nDESCRIPTION: Adds the Sources subdirectory to the build process to compile the actual project source files.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(Sources)\n```\n\n----------------------------------------\n\nTITLE: Setting Compilation Options and Linking Libraries for Swift Testing Macros\nDESCRIPTION: Configures compilation options and links necessary libraries for the TestingMacros target, including SwiftSyntax components and conditional linking based on build type.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/TestingMacros/CMakeLists.txt#2025-04-18_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(TestingMacros PRIVATE\n  \"SHELL:-Xfrontend -disable-implicit-string-processing-module-import\")\n\ntarget_link_libraries(TestingMacros PRIVATE\n  SwiftSyntax::SwiftSyntax\n  SwiftSyntax::SwiftSyntaxMacroExpansion\n  SwiftSyntax::SwiftSyntaxMacros)\nif(SwiftTesting_BuildMacrosAsExecutables)\n  # Link the 'SwiftCompilerPlugin' target, but only when built as an executable.\n  target_link_libraries(TestingMacros PRIVATE\n    SwiftSyntax::SwiftCompilerPlugin)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Disabling Toolchain Standard Library Runtime Path for Swift\nDESCRIPTION: Adds a compiler option specifically for Swift language to disable the toolchain standard library runtime path.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nadd_compile_options($<$<COMPILE_LANGUAGE:Swift>:-no-toolchain-stdlib-rpath>)\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build\nDESCRIPTION: Command to configure the project build using CMake with Ninja generator.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncmake -G Ninja -B build\n```\n\n----------------------------------------\n\nTITLE: Conditional Installation of _TestDiscovery Static Library in CMake\nDESCRIPTION: Configures the installation of the _TestDiscovery library archive for static library builds. This step is skipped for shared library builds as the internal library is linked into the main library.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/_TestDiscovery/CMakeLists.txt#2025-04-18_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT BUILD_SHARED_LIBS)\n  # When building a static library, install the internal library archive\n  # alongside the main library. In shared library builds, the internal library\n  # is linked into the main library and does not need to be installed separately.\n  install(TARGETS _TestDiscovery\n    ARCHIVE DESTINATION \"${SwiftTesting_INSTALL_LIBDIR}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining _TestDiscovery Library in CMake\nDESCRIPTION: Creates a static library named _TestDiscovery with specified source files. It sets up the library's dependencies and compile options, including enabling library evolution and emitting module interfaces.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/_TestDiscovery/CMakeLists.txt#2025-04-18_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(_TestDiscovery STATIC\n  Additions/WinSDKAdditions.swift\n  DiscoverableAsTestContent.swift\n  SectionBounds.swift\n  TestContentKind.swift\n  TestContentRecord.swift)\n\ntarget_link_libraries(_TestDiscovery PRIVATE\n  _TestingInternals)\n\ntarget_compile_options(_TestDiscovery PRIVATE\n  -enable-library-evolution\n  -emit-module-interface -emit-module-interface-path $<TARGET_PROPERTY:_TestDiscovery,Swift_MODULE_DIRECTORY>/_TestDiscovery.swiftinterface)\nset(CMAKE_STATIC_LIBRARY_PREFIX_Swift \"lib\")\n\n_swift_testing_install_target(_TestDiscovery)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Testing Macros Dependency and Compiler Options\nDESCRIPTION: Adds a dependency on TestingMacros and configures compiler options for library evolution and module interface generation, which enable ABI stability and make the module available to Swift clients.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Testing/CMakeLists.txt#2025-04-18_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_dependencies(Testing\n  TestingMacros)\ntarget_compile_options(Testing PRIVATE\n  -enable-library-evolution\n  -emit-module-interface -emit-module-interface-path $<TARGET_PROPERTY:Testing,Swift_MODULE_DIRECTORY>/Testing.swiftinterface)\n```\n\n----------------------------------------\n\nTITLE: Installing Built Content with CMake\nDESCRIPTION: Command to install the built content into the specified install directory.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncmake --install build\n```\n\n----------------------------------------\n\nTITLE: Platform-Specific Foundation Library Linking\nDESCRIPTION: Conditionally links the Foundation library for non-Apple platforms. Apple platforms handle Foundation linking automatically through auto-linking.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/Overlays/_Testing_Foundation/CMakeLists.txt#2025-04-18_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT APPLE)\n  target_link_libraries(_Testing_Foundation PUBLIC\n    Foundation)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for Swift Testing Library\nDESCRIPTION: This CMake script configures the build process for the Swift Testing library. It sets up a static library, includes necessary modules, configures compiler options for different platforms, and defines installation rules.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/_TestingInternals/CMakeLists.txt#2025-04-18_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_CXX_SCAN_FOR_MODULES 0)\n\ninclude(LibraryVersion)\ninclude(TargetTriple)\nadd_library(_TestingInternals STATIC\n  Discovery.cpp\n  Versions.cpp\n  WillThrow.cpp)\ntarget_include_directories(_TestingInternals PUBLIC\n  ${CMAKE_CURRENT_SOURCE_DIR}/include)\nif(\"${CMAKE_CXX_COMPILER_FRONTEND_VARIANT}\" STREQUAL \"MSVC\" OR\n   \"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"MSVC\")\n  target_compile_options(_TestingInternals PRIVATE\n    /EHa-c)\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"FreeBSD\")\n  target_compile_options(_TestingInternals PRIVATE\n    -fno-exceptions -fPIC)\nelse()\n  target_compile_options(_TestingInternals PRIVATE\n    -fno-exceptions)\nendif()\n\nif(NOT BUILD_SHARED_LIBS)\n  # When building a static library, install the internal library archive\n  # alongside the main library. In shared library builds, the internal library\n  # is linked into the main library and does not need to be installed separately.\n  install(TARGETS _TestingInternals\n    ARCHIVE DESTINATION \"${SwiftTesting_INSTALL_LIBDIR}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Docker Container\nDESCRIPTION: Command to run the test suite in a Docker container.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -v \"$(pwd)\":/swift-testing -w /swift-testing swift-testing swift test --skip-update\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project for Swift Testing Macros\nDESCRIPTION: Sets up the CMake project for Swift Testing Macros, including minimum CMake version, project name, and language settings.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/TestingMacros/CMakeLists.txt#2025-04-18_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.19.6...3.29)\n\nif(POLICY CMP0157)\n  cmake_policy(SET CMP0157 NEW)\nendif()\n\nproject(TestingMacros\n  LANGUAGES Swift)\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files to Swift Testing Macros Target\nDESCRIPTION: Specifies the source files to be included in the TestingMacros target, including various Swift files for macros, support functions, and additions.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/TestingMacros/CMakeLists.txt#2025-04-18_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(TestingMacros PRIVATE\n  ConditionMacro.swift\n  PragmaMacro.swift\n  SourceLocationMacro.swift\n  SuiteDeclarationMacro.swift\n  Support/Additions/DeclGroupSyntaxAdditions.swift\n  Support/Additions/EditorPlaceholderExprSyntaxAdditions.swift\n  Support/Additions/FunctionDeclSyntaxAdditions.swift\n  Support/Additions/IntegerLiteralExprSyntaxAdditions.swift\n  Support/Additions/MacroExpansionContextAdditions.swift\n  Support/Additions/TokenSyntaxAdditions.swift\n  Support/Additions/TriviaPieceAdditions.swift\n  Support/Additions/TypeSyntaxProtocolAdditions.swift\n  Support/Additions/VersionTupleSyntaxAdditions.swift\n  Support/Additions/WithAttributesSyntaxAdditions.swift\n  Support/Argument.swift\n  Support/AttributeDiscovery.swift\n  Support/AvailabilityGuards.swift\n  Support/ClosureCaptureListParsing.swift\n  Support/CommentParsing.swift\n  Support/ConditionArgumentParsing.swift\n  Support/DiagnosticMessage.swift\n  Support/DiagnosticMessage+Diagnosing.swift\n  Support/EffectfulExpressionHandling.swift\n  Support/SHA256.swift\n  Support/SourceCodeCapturing.swift\n  Support/SourceLocationGeneration.swift\n  Support/TestContentGeneration.swift\n  TagMacro.swift\n  TestDeclarationMacro.swift\n  TestingMacrosMain.swift)\n```\n\n----------------------------------------\n\nTITLE: Starting Interactive Docker Session\nDESCRIPTION: Command to start an interactive bash session in the Docker container.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -i -t -v \"$(pwd)\":/swift-testing swift-testing /bin/bash\n```\n\n----------------------------------------\n\nTITLE: Setting up Swift Toolchain on non-macOS Systems\nDESCRIPTION: Commands to configure PATH and verify Swift toolchain installation on non-macOS systems or macOS without Xcode.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport PATH=/path/to/swift-toolchain/usr/bin:\"${PATH}\"\nwhich swift\n```\n\n----------------------------------------\n\nTITLE: Setting up Swift Toolchain on macOS with Xcode\nDESCRIPTION: Commands to configure and verify Swift toolchain installation on macOS when Xcode is installed.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport TOOLCHAINS=swift\nxcrun --find swift\n```\n\n----------------------------------------\n\nTITLE: Building Swift Testing Project\nDESCRIPTION: Command to build the Swift Testing project using Swift package manager.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nswift build\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Install Prefix\nDESCRIPTION: Command to configure CMake project with a specific install prefix.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncmake -G Ninja --install-prefix \"$(pwd)/build/install\" -B build\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image for Linux Testing\nDESCRIPTION: Command to build a Docker image for testing on Linux.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -t swift-testing:latest .\n```\n\n----------------------------------------\n\nTITLE: Configuring SwiftTesting Macro Compilation Options in CMake\nDESCRIPTION: Sets up compilation options for the SwiftTesting macro plugin based on whether it's a shared library or executable. It adds the appropriate Swift compiler flags to load the plugin.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Sources/CMakeLists.txt#2025-04-18_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT SwiftTesting_MACRO_PATH)\n  message(STATUS \"TestingMacros: (none)\")\nelseif(SwiftTesting_MACRO_PATH)\n  if(SwiftTesting_MACRO_PATH MATCHES [[\\.\\(dylib|so|dll\\)$]])\n    message(STATUS \"TestingMacros: ${SwiftTesting_MACRO_PATH} (shared library)\")\n    add_compile_options(\"$<$<COMPILE_LANGUAGE:Swift>:SHELL:-load-plugin-library \\\"${SwiftTesting_MACRO_PATH}\\\">\")\n  else()\n    message(STATUS \"TestingMacros: ${SwiftTesting_MACRO_PATH} (executable)\")\n    add_compile_options(\"$<$<COMPILE_LANGUAGE:Swift>:SHELL:-load-plugin-executable \\\"${SwiftTesting_MACRO_PATH}#TestingMacros\\\">\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining C Types and Structures\nDESCRIPTION: Example of C type definitions using the SWT prefix following Swift-style naming conventions.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/StyleGuide.md#2025-04-18_snippet_3\n\nLANGUAGE: c\nCODE:\n```\ntypedef intmax_t SWTBigInteger;\n\ntypedef struct SWTContainer {\n  ...\n} SWTContainer;\n```\n\n----------------------------------------\n\nTITLE: Triggering CI Testing\nDESCRIPTION: Comment command to trigger CI testing on pull requests.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n@swift-ci test\n```\n\n----------------------------------------\n\nTITLE: Configuring Compiler Standards and Module Directory\nDESCRIPTION: Sets C++ standard to 20, Swift language version to 6, and defines the output directory for Swift modules.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CMakeLists.txt#2025-04-18_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset(CMAKE_MSVC_RUNTIME_LIBRARY MultiThreadedDLL)\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_Swift_LANGUAGE_VERSION 6)\nset(CMAKE_Swift_MODULE_DIRECTORY ${CMAKE_BINARY_DIR}/swift)\n```\n\n----------------------------------------\n\nTITLE: Implementing Public Internal Function in Swift\nDESCRIPTION: Example of using double underscores for public functions that are meant for internal use only.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/StyleGuide.md#2025-04-18_snippet_0\n\nLANGUAGE: swift\nCODE:\n```\npublic func __check()\n```\n\n----------------------------------------\n\nTITLE: Building with CMake\nDESCRIPTION: Command to perform the build using CMake.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncmake --build build\n```\n\n----------------------------------------\n\nTITLE: Runtime Library Exception to the Apache 2.0 License\nDESCRIPTION: A license exception that allows users to embed portions of the Swift Testing software into binary products without providing attribution that would normally be required by sections 4(a), 4(b), and 4(d) of the Apache License.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/LICENSE.txt#2025-04-18_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nAs an exception, if you use this Software to compile your source code and\nportions of this Software are embedded into the binary product as a result,\nyou may redistribute such product without providing attribution as would\notherwise be required by Sections 4(a), 4(b) and 4(d) of the License.\n```\n\n----------------------------------------\n\nTITLE: Adding C++ Stub Implementation for NewTimerUPP in Swift Testing\nDESCRIPTION: This snippet shows how to add a C++ stub implementation for the NewTimerUPP function in the Stubs.h file. This is necessary for using timers on Classic platforms where the function is defined as a macro and cannot be called directly from Swift.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/Documentation/Porting.md#2025-04-18_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n--- a/Sources/_TestingInternals/include/Stubs.h\n+++ b/Sources/_TestingInternals/include/Stubs.h\n\n+#if defined(macintosh)\n+static TimerUPP swt_NewTimerUPP(TimerProcPtr userRoutine) {\n+  return NewTimerUPP(userRoutine);\n+}\n+#endif\n```\n\n----------------------------------------\n\nTITLE: Running Swift Testing Tests\nDESCRIPTION: Command to run the test suite for Swift Testing project.\nSOURCE: https://github.com/swiftlang/swift-testing/blob/main/CONTRIBUTING.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nswift test\n```"
  }
]