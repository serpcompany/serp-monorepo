[
  {
    "owner": "stackexchange",
    "repo": "stackexchange.redis",
    "content": "TITLE: Initializing Redis Connection with ConnectionMultiplexer\nDESCRIPTION: Demonstrates how to create and properly use a ConnectionMultiplexer instance for Redis connections. The connection should be shared and reused rather than created per operation.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Basics.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing StackExchange.Redis;\n...\nConnectionMultiplexer redis = ConnectionMultiplexer.Connect(\"localhost\");\n// ^^^ store and re-use this!!!\n```\n\n----------------------------------------\n\nTITLE: Establishing Redis Connections in C#\nDESCRIPTION: This snippet demonstrates methods for connecting to Redis using the ConnectionMultiplexer class. It includes both synchronous and asynchronous connection methods, as well as methods for connecting to Redis Sentinel.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.ConnectionMultiplexer.Connect(StackExchange.Redis.ConfigurationOptions! configuration, System.IO.TextWriter? log = null) -> StackExchange.Redis.ConnectionMultiplexer!\nstatic StackExchange.Redis.ConnectionMultiplexer.ConnectAsync(string! configuration, System.IO.TextWriter? log = null) -> System.Threading.Tasks.Task<StackExchange.Redis.ConnectionMultiplexer!>!\nstatic StackExchange.Redis.ConnectionMultiplexer.SentinelConnect(StackExchange.Redis.ConfigurationOptions! configuration, System.IO.TextWriter? log = null) -> StackExchange.Redis.ConnectionMultiplexer!\n```\n\n----------------------------------------\n\nTITLE: Basic String Operations in Redis\nDESCRIPTION: Shows basic string operations using Redis, including setting and getting string values with both text and binary data.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Basics.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstring value = \"abcdefg\";\ndb.StringSet(\"mykey\", value);\n...\nstring value = db.StringGet(\"mykey\");\nConsole.WriteLine(value); // writes: \"abcdefg\"\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbyte[] key = ..., value = ...;\ndb.StringSet(key, value);\n...\nbyte[] value = db.StringGet(key);\n```\n\n----------------------------------------\n\nTITLE: Connecting to Redis Primary/Replica Setup\nDESCRIPTION: Shows how to connect to multiple Redis nodes in a primary/replica configuration by specifying multiple server addresses.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Basics.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nConnectionMultiplexer redis = ConnectionMultiplexer.Connect(\"server1:6379,server2:6379\");\n```\n\n----------------------------------------\n\nTITLE: Accessing Redis Database\nDESCRIPTION: Demonstrates how to obtain an IDatabase instance for Redis operations, including optional database number and async state specification.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Basics.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nIDatabase db = redis.GetDatabase();\n```\n\nLANGUAGE: csharp\nCODE:\n```\nint databaseNumber = ...\nobject asyncState = ...\nIDatabase db = redis.GetDatabase(databaseNumber, asyncState);\n```\n\n----------------------------------------\n\nTITLE: Adding a Single Entry to a Redis Stream in C#\nDESCRIPTION: Demonstrates how to add a simple message with a single name/value pair to a Redis stream using the StreamAdd method. The method returns a unique message ID.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar db = redis.GetDatabase();\nvar messageId = db.StreamAdd(\"events_stream\", \"foo_name\", \"bar_value\");\n// messageId = 1518951480106-0\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Redis Operations\nDESCRIPTION: Demonstrates asynchronous operations using async/await pattern with Redis commands.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Basics.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nstring value = \"abcdefg\";\nawait db.StringSetAsync(\"mykey\", value);\n...\nstring value = await db.StringGetAsync(\"mykey\");\nConsole.WriteLine(value); // writes: \"abcdefg\"\n```\n\n----------------------------------------\n\nTITLE: Configuring StackExchange.Redis with Manual Settings\nDESCRIPTION: Demonstrates manual configuration of StackExchange.Redis including endpoints, command mapping, keepalive settings, and authentication. Shows how to exclude specific commands and set connection parameters.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nConfigurationOptions config = new ConfigurationOptions\n{\n    EndPoints =\n    {\n        { \"redis0\", 6379 },\n        { \"redis1\", 6380 }\n    },\n    CommandMap = CommandMap.Create(new HashSet<string>\n    { // EXCLUDE a few commands\n        \"INFO\", \"CONFIG\", \"CLUSTER\",\n        \"PING\", \"ECHO\", \"CLIENT\"\n    }, available: false),\n    KeepAlive = 180,\n    DefaultVersion = new Version(2, 8, 8),\n    Password = \"changeme\"\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Redis Connection\nDESCRIPTION: Demonstrates the basic connection setup using ConnectionMultiplexer with a configuration parameter that can be either a string or ConfigurationOptions instance.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar conn = ConnectionMultiplexer.Connect(configuration);\n```\n\n----------------------------------------\n\nTITLE: StackExchange.Redis Transaction with Conditions\nDESCRIPTION: C# code showing how to use StackExchange.Redis's transaction API with conditions to implement atomic operations, adding a condition to ensure a hash field doesn't already exist.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Transactions.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar newId = CreateNewId();\nvar tran = db.CreateTransaction();\ntran.AddCondition(Condition.HashNotExists(custKey, \"UniqueID\"));\ntran.HashSetAsync(custKey, \"UniqueID\", newId);\nbool committed = tran.Execute();\n// ^^^ if true: it was applied; if false: it was rolled back\n```\n\n----------------------------------------\n\nTITLE: Redis Sentinel Connection\nDESCRIPTION: Shows how to connect to Redis using Sentinel mode by specifying a service name.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar conn = ConnectionMultiplexer.Connect(\"localhost,serviceName=myprimary\");\n```\n\n----------------------------------------\n\nTITLE: Simple Localhost Connection\nDESCRIPTION: Shows how to connect to a local Redis instance using the default port 6379.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar conn = ConnectionMultiplexer.Connect(\"localhost\");\n```\n\n----------------------------------------\n\nTITLE: Using LuaScript class for Redis scripting in C#\nDESCRIPTION: This snippet demonstrates how to use the LuaScript class to prepare and execute a Lua script in Redis. It shows how to set a key-value pair using a Lua script with named parameters.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Scripting.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nconst string Script = \"redis.call('set', @key, @value)\";\n\nusing (ConnectionMultiplexer conn = /* init code */)\n{\n\tvar db = conn.GetDatabase(0);\n\n\tvar prepared = LuaScript.Prepare(Script);\n\tdb.ScriptEvaluate(prepared, new { key = (RedisKey)\"mykey\", value = 123 });\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Redis Operations with Async/Await in C#\nDESCRIPTION: Example of using continuation-based asynchronous code with Redis operations, demonstrating the integration of async/await pattern with the multiplexer to maintain high throughput.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/PipelinesMultiplexers.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nstring value = await db.StringGetAsync(key);\nif (value == null) {\n    value = await ComputeValueFromDatabase(...);\n    db.StringSet(key, value, flags: CommandFlags.FireAndForget);\n}\nreturn value;\n```\n\n----------------------------------------\n\nTITLE: Redis Pub/Sub Implementation\nDESCRIPTION: Demonstrates publish/subscribe functionality in Redis, including subscription handling and message publishing.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Basics.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nISubscriber sub = redis.GetSubscriber();\n```\n\nLANGUAGE: csharp\nCODE:\n```\nsub.Subscribe(\"messages\", (channel, message) => {\n    Console.WriteLine((string)message);\n});\n```\n\nLANGUAGE: csharp\nCODE:\n```\nsub.Subscribe(\"messages\").OnMessage(channelMessage => {\n    Console.WriteLine((string) channelMessage.Message);\n});\n```\n\nLANGUAGE: csharp\nCODE:\n```\nsub.Subscribe(\"messages\").OnMessage(async channelMessage => {\n    await Task.Delay(1000);\n    Console.WriteLine((string) channelMessage.Message);\n});\n```\n\nLANGUAGE: csharp\nCODE:\n```\nsub.Publish(\"messages\", \"hello\");\n```\n\n----------------------------------------\n\nTITLE: Azure Redis Connection\nDESCRIPTION: Example of connecting to Microsoft Azure Redis Cache with SSL and password authentication.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar conn = ConnectionMultiplexer.Connect(\"contoso5.redis.cache.windows.net,ssl=true,password=...\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Reconnection Retry Policies\nDESCRIPTION: Demonstrates how to configure exponential and linear retry policies for connection recovery.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nconfig.ReconnectRetryPolicy = new ExponentialRetry(5000); // defaults maxDeltaBackoff to 10000 ms\n//retry#    retry to re-connect after time in milliseconds\n//1\t        a random value between 5000 and 5500\t   \n//2\t        a random value between 5000 and 6050\t   \n//3\t        a random value between 5000 and 6655\t   \n//4\t        a random value between 5000 and 8053\n//5\t        a random value between 5000 and 10000, since maxDeltaBackoff was 10000 ms\n//6\t        a random value between 5000 and 10000\n\nconfig.ReconnectRetryPolicy = new LinearRetry(5000);\n//retry#    retry to re-connect after time in milliseconds\n//1\t        5000\n//2\t        5000 \t   \n//3\t        5000 \t   \n//4\t        5000\n//5\t        5000\n//6\t        5000\n```\n\n----------------------------------------\n\nTITLE: Basic string value storage with StackExchange.Redis\nDESCRIPTION: Example of storing a string value in Redis using the StringSet method. This demonstrates the implicit conversion from string to RedisValue, allowing you to directly pass a string without explicit type conversion.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysValues.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ndb.StringSet(\"mykey\", \"myvalue\");\n```\n\n----------------------------------------\n\nTITLE: Pipelined Redis Operations Using Tasks in C#\nDESCRIPTION: Example of using pipelining with asynchronous methods to initiate multiple Redis operations in parallel, reducing latency by sending requests without waiting for previous responses.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/PipelinesMultiplexers.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar aPending = db.StringGetAsync(\"a\");\nvar bPending = db.StringGetAsync(\"b\");\nvar a = db.Wait(aPending);\nvar b = db.Wait(bPending);\n```\n\n----------------------------------------\n\nTITLE: Defining IDatabase Method Signatures for StackExchange.Redis\nDESCRIPTION: This snippet defines method signatures for various Redis operations in the IDatabase interface of StackExchange.Redis. It includes methods for lock management, pub/sub, Lua script evaluation, set operations, sorted set operations, and more. Each method specifies its parameters and return type, often including optional parameters with default values.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabase.LockTake(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, System.TimeSpan expiry, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.Publish(StackExchange.Redis.RedisChannel channel, StackExchange.Redis.RedisValue message, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.ScriptEvaluate(byte[]! hash, StackExchange.Redis.RedisKey[]? keys = null, StackExchange.Redis.RedisValue[]? values = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisResult!\nStackExchange.Redis.IDatabase.ScriptEvaluate(StackExchange.Redis.LoadedLuaScript! script, object? parameters = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisResult!\nStackExchange.Redis.IDatabase.ScriptEvaluate(StackExchange.Redis.LuaScript! script, object? parameters = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisResult!\nStackExchange.Redis.IDatabase.ScriptEvaluate(string! script, StackExchange.Redis.RedisKey[]? keys = null, StackExchange.Redis.RedisValue[]? values = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisResult!\nStackExchange.Redis.IDatabase.ScriptEvaluateReadOnly(byte[]! hash, StackExchange.Redis.RedisKey[]? keys = null, StackExchange.Redis.RedisValue[]? values = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisResult!\nStackExchange.Redis.IDatabase.ScriptEvaluateReadOnly(string! script, StackExchange.Redis.RedisKey[]? keys = null, StackExchange.Redis.RedisValue[]? values = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisResult!\nStackExchange.Redis.IDatabase.SetAdd(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.SetAdd(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue[]! values, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SetCombine(StackExchange.Redis.SetOperation operation, StackExchange.Redis.RedisKey first, StackExchange.Redis.RedisKey second, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SetCombine(StackExchange.Redis.SetOperation operation, StackExchange.Redis.RedisKey[]! keys, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SetCombineAndStore(StackExchange.Redis.SetOperation operation, StackExchange.Redis.RedisKey destination, StackExchange.Redis.RedisKey first, StackExchange.Redis.RedisKey second, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SetCombineAndStore(StackExchange.Redis.SetOperation operation, StackExchange.Redis.RedisKey destination, StackExchange.Redis.RedisKey[]! keys, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SetContains(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.SetContains(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue[]! values, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool[]!\nStackExchange.Redis.IDatabase.SetIntersectionLength(StackExchange.Redis.RedisKey[]! keys, long limit = 0, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SetLength(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SetMembers(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SetMove(StackExchange.Redis.RedisKey source, StackExchange.Redis.RedisKey destination, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.SetPop(StackExchange.Redis.RedisKey key, long count, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SetPop(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue\nStackExchange.Redis.IDatabase.SetRandomMember(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue\nStackExchange.Redis.IDatabase.SetRandomMembers(StackExchange.Redis.RedisKey key, long count, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SetRemove(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.SetRemove(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue[]! values, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SetScan(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue pattern = default(StackExchange.Redis.RedisValue), int pageSize = 250, long cursor = 0, int pageOffset = 0, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Collections.Generic.IEnumerable<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabase.SetScan(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue pattern, int pageSize, StackExchange.Redis.CommandFlags flags) -> System.Collections.Generic.IEnumerable<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabase.Sort(StackExchange.Redis.RedisKey key, long skip = 0, long take = -1, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, StackExchange.Redis.SortType sortType = StackExchange.Redis.SortType.Numeric, StackExchange.Redis.RedisValue by = default(StackExchange.Redis.RedisValue), StackExchange.Redis.RedisValue[]? get = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SortAndStore(StackExchange.Redis.RedisKey destination, StackExchange.Redis.RedisKey key, long skip = 0, long take = -1, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, StackExchange.Redis.SortType sortType = StackExchange.Redis.SortType.Numeric, StackExchange.Redis.RedisValue by = default(StackExchange.Redis.RedisValue), StackExchange.Redis.RedisValue[]? get = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetAdd(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, double score, StackExchange.Redis.CommandFlags flags) -> bool\nStackExchange.Redis.IDatabase.SortedSetAdd(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, double score, StackExchange.Redis.When when, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.SortedSetAdd(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, double score, StackExchange.Redis.SortedSetWhen when = StackExchange.Redis.SortedSetWhen.Always, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.SortedSetAdd(StackExchange.Redis.RedisKey key, StackExchange.Redis.SortedSetEntry[]! values, StackExchange.Redis.CommandFlags flags) -> long\nStackExchange.Redis.IDatabase.SortedSetAdd(StackExchange.Redis.RedisKey key, StackExchange.Redis.SortedSetEntry[]! values, StackExchange.Redis.When when, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetAdd(StackExchange.Redis.RedisKey key, StackExchange.Redis.SortedSetEntry[]! values, StackExchange.Redis.SortedSetWhen when = StackExchange.Redis.SortedSetWhen.Always, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetCombine(StackExchange.Redis.SetOperation operation, StackExchange.Redis.RedisKey[]! keys, double[]? weights = null, StackExchange.Redis.Aggregate aggregate = StackExchange.Redis.Aggregate.Sum, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SortedSetCombineWithScores(StackExchange.Redis.SetOperation operation, StackExchange.Redis.RedisKey[]! keys, double[]? weights = null, StackExchange.Redis.Aggregate aggregate = StackExchange.Redis.Aggregate.Sum, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.SortedSetEntry[]!\nStackExchange.Redis.IDatabase.SortedSetCombineAndStore(StackExchange.Redis.SetOperation operation, StackExchange.Redis.RedisKey destination, StackExchange.Redis.RedisKey first, StackExchange.Redis.RedisKey second, StackExchange.Redis.Aggregate aggregate = StackExchange.Redis.Aggregate.Sum, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\n```\n\n----------------------------------------\n\nTITLE: Reading from Multiple Redis Streams in C#\nDESCRIPTION: Demonstrates reading from multiple Redis streams simultaneously using the StreamRead method with an array of StreamPosition objects. This is useful for processing data from multiple sources.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar streams = db.StreamRead(new StreamPosition[]\n{\n    new StreamPosition(\"events_stream\", \"0-0\"),\n    new StreamPosition(\"score_stream\", \"0-0\")\n});\n\nConsole.WriteLine($\"Stream = {streams.First().Key}\");\nConsole.WriteLine($\"Length = {streams.First().Entries.Length}\");\n```\n\n----------------------------------------\n\nTITLE: Using string keys with StackExchange.Redis\nDESCRIPTION: Example of using a string as a RedisKey with implicit conversion when incrementing a string value. The RedisKey type handles the conversion automatically, allowing you to pass a string directly to methods that expect a RedisKey parameter.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysValues.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstring key = ...\ndb.StringIncrement(key);\n```\n\n----------------------------------------\n\nTITLE: Fire-and-Forget Redis Operations\nDESCRIPTION: Shows how to perform fire-and-forget operations that don't wait for responses using CommandFlags.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Basics.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\ndb.StringIncrement(pageKey, flags: CommandFlags.FireAndForget);\n```\n\n----------------------------------------\n\nTITLE: Alternative to Blocking Operations Using Pub/Sub in C#\nDESCRIPTION: Example of using Redis pub/sub as an alternative to blocking pop operations, which maintains high throughput by not blocking the multiplexer while still achieving the same intent.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/PipelinesMultiplexers.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nsub.Subscribe(channel, delegate {\n    string work = db.ListRightPop(key);\n    if (work != null) Process(work);\n});\n//...\ndb.ListLeftPush(key, newWork, flags: CommandFlags.FireAndForget);\nsub.Publish(channel, \"\");\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Name/Value Pairs to a Redis Stream in C#\nDESCRIPTION: Shows how to add multiple name/value pairs to a Redis stream using an array of NameValueEntry objects. This is useful for adding more complex data structures to the stream.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar values = new NameValueEntry[]\n{\n    new NameValueEntry(\"sensor_id\", \"1234\"),\n    new NameValueEntry(\"temp\", \"19.8\")\n};\n\nvar db = redis.GetDatabase();\nvar messageId = db.StreamAdd(\"sensor_stream\", values);\n```\n\n----------------------------------------\n\nTITLE: Initializing and Running MemoryCacheRedisServer in C#\nDESCRIPTION: This snippet demonstrates how to create, start, and shut down a MemoryCacheRedisServer instance. It listens on localhost:6379 and uses Console.Out for logging. The server runs until the Shutdown task completes.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/toys/StackExchange.Redis.Server/readme.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Net;\nusing System.Threading.Tasks;\nusing StackExchange.Redis.Server;\n\nstatic class Program\n{\n    static async Task Main()\n    {\n        using (var server = new MemoryCacheRedisServer(Console.Out))\n        {\n            server.Listen(new IPEndPoint(IPAddress.Loopback, 6379));\n            await server.Shutdown;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using nullable types with Redis values\nDESCRIPTION: Example showing how to use nullable types with StackExchange.Redis to handle nil values more naturally. This approach allows you to use C#'s nullable type system with Redis responses.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysValues.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\ndb.KeyDelete(\"abc\");\nvar value = (int?)db.StringGet(\"abc\"); // behaves as you would expect\n```\n\n----------------------------------------\n\nTITLE: Accessing Server Commands in StackExchange.Redis with C#\nDESCRIPTION: Demonstrates how to use server-specific Redis commands like Keys() for pattern matching and FlushDatabase() for wiping keys, by first obtaining a server reference instead of working through the database interface.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysScan.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// get the target server\nvar server = conn.GetServer(someServer);\n\n// show all keys in database 0 that include \"foo\" in their name\nforeach(var key in server.Keys(pattern: \"*foo*\")) {\n    Console.WriteLine(key);\n}\n\n// completely wipe ALL keys from database 0\nserver.FlushDatabase();\n```\n\n----------------------------------------\n\nTITLE: Reading Messages into Consumers in a Redis Stream Consumer Group in C#\nDESCRIPTION: Demonstrates how to read messages into multiple consumers within a consumer group using the StreamReadGroup method. This example reads 5 new messages for each of two consumers.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// Read 5 messages into two consumers.\nvar consumer_1_messages = db.StreamReadGroup(\"events_stream\", \"events_cg\", \"consumer_1\", \">\", count: 5);\nvar consumer_2_messages = db.StreamReadGroup(\"events_stream\", \"events_cg\", \"consumer_2\", \">\", count: 5);\n```\n\n----------------------------------------\n\nTITLE: Reading a Range of Entries from a Redis Stream in C#\nDESCRIPTION: Shows how to read a range of entries from a Redis stream using the StreamRange method. This example demonstrates reading all entries in descending order with a limit of 100 messages.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar messages = db.StreamRange(\"events_stream\",\n    minId: \"0-0\",\n    maxId: \"+\",\n    count: 100,\n    messageOrder: Order.Descending);\n```\n\n----------------------------------------\n\nTITLE: Redis Connection Multiplexer Interface Definition\nDESCRIPTION: Interface definition for IConnectionMultiplexer that provides Redis connection management, configuration, and event handling capabilities. Includes methods for database access, server operations, and connection status monitoring.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IConnectionMultiplexer {\n    string ClientName { get; }\n    void Close(bool allowCommandsToComplete = true);\n    Task CloseAsync(bool allowCommandsToComplete = true);\n    string Configuration { get; }\n    EventHandler<EndPointEventArgs> ConfigurationChanged { get; }\n    bool IsConnected { get; }\n    IDatabase GetDatabase(int db = -1, object asyncState = null);\n    IServer[] GetServers();\n    ISubscriber GetSubscriber(object asyncState = null);\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Redis Stream Operations in StackExchange.Redis\nDESCRIPTION: Method signatures for asynchronous operations on Redis streams. These methods provide functionality for adding entries to streams, creating and managing consumer groups, and processing messages through Redis streams.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.StreamAcknowledgeAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue messageId, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StreamAcknowledgeAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue[]! messageIds, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StreamAddAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.NameValueEntry[]! streamPairs, StackExchange.Redis.RedisValue? messageId = null, int? maxLength = null, bool useApproximateMaxLength = false, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabaseAsync.StreamAddAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue streamField, StackExchange.Redis.RedisValue streamValue, StackExchange.Redis.RedisValue? messageId = null, int? maxLength = null, bool useApproximateMaxLength = false, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabaseAsync.StreamAutoClaimAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue consumerGroup, StackExchange.Redis.RedisValue claimingConsumer, long minIdleTimeInMs, StackExchange.Redis.RedisValue startAtId, int? count = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamAutoClaimResult>!\nStackExchange.Redis.IDatabaseAsync.StreamAutoClaimIdsOnlyAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue consumerGroup, StackExchange.Redis.RedisValue claimingConsumer, long minIdleTimeInMs, StackExchange.Redis.RedisValue startAtId, int? count = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamAutoClaimIdsOnlyResult>!\nStackExchange.Redis.IDatabaseAsync.StreamClaimAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue consumerGroup, StackExchange.Redis.RedisValue claimingConsumer, long minIdleTimeInMs, StackExchange.Redis.RedisValue[]! messageIds, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamEntry[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamClaimIdsOnlyAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue consumerGroup, StackExchange.Redis.RedisValue claimingConsumer, long minIdleTimeInMs, StackExchange.Redis.RedisValue[]! messageIds, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamConsumerGroupSetPositionAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue position, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\nStackExchange.Redis.IDatabaseAsync.StreamConsumerInfoAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamConsumerInfo[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamCreateConsumerGroupAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue? position = null, bool createStream = true, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\nStackExchange.Redis.IDatabaseAsync.StreamCreateConsumerGroupAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue? position, StackExchange.Redis.CommandFlags flags) -> System.Threading.Tasks.Task<bool>!\n```\n\n----------------------------------------\n\nTITLE: Reading from a Redis Stream in C#\nDESCRIPTION: Shows how to read messages from a Redis stream using the StreamRead method. This example reads all messages from a specific ID to the end of the stream.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar messages = db.StreamRead(\"events_stream\", \"0-0\");\n```\n\n----------------------------------------\n\nTITLE: Redis Minimal ACL Configuration\nDESCRIPTION: Shows a minimal Redis ACL configuration for basic functionality with StackExchange.Redis client.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n-@all +@pubsub +@read +echo +info\n```\n\n----------------------------------------\n\nTITLE: Accessing Individual Redis Servers\nDESCRIPTION: Shows how to access individual Redis servers for maintenance operations and retrieve server information.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Basics.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nIServer server = redis.GetServer(\"localhost\", 6379);\n```\n\nLANGUAGE: csharp\nCODE:\n```\nEndPoint[] endpoints = redis.GetEndPoints();\n```\n\nLANGUAGE: csharp\nCODE:\n```\nDateTime lastSave = server.LastSave();\nClientInfo[] clients = server.ClientList();\n```\n\n----------------------------------------\n\nTITLE: Redis Database Interface Definition\nDESCRIPTION: Interface definition for IDatabase that provides Redis database operations including transactions, batches, and geospatial commands. Contains methods for executing Redis commands and handling geo-related operations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\npublic interface IDatabase {\n    IBatch CreateBatch(object asyncState = null);\n    ITransaction CreateTransaction(object asyncState = null);\n    int Database { get; }\n    RedisResult Execute(string command, params object[] args);\n    bool GeoAdd(RedisKey key, double longitude, double latitude, RedisValue member, CommandFlags flags = CommandFlags.None);\n    GeoRadiusResult[] GeoRadius(RedisKey key, double longitude, double latitude, double radius, GeoUnit unit = GeoUnit.Meters, int count = -1, Order? order = null);\n}\n```\n\n----------------------------------------\n\nTITLE: Acknowledging Messages in a Redis Stream Consumer Group in C#\nDESCRIPTION: Shows how to acknowledge messages in a consumer group using the StreamAcknowledge method. This removes messages from the pending state after they have been processed.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n// Returns the number of messages acknowledged.\ndb.StreamAcknowledge(\"events_stream\", \"events_cg\", pendingMessage.MessageId);\n```\n\n----------------------------------------\n\nTITLE: Storing and retrieving numeric values in Redis\nDESCRIPTION: Example showing how to store an integer value and cast it back when retrieving. This demonstrates the implicit conversion from int to RedisValue when storing, and the explicit cast from RedisValue to int when retrieving.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysValues.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ndb.StringSet(\"mykey\", 123); // this is still a RedisKey and RedisValue\n...\nint i = (int)db.StringGet(\"mykey\");\n```\n\n----------------------------------------\n\nTITLE: Implementing COPY Command Support in C#\nDESCRIPTION: Adds support for the Redis COPY command through new methods KeyCopy and KeyCopyAsync, allowing for copying of keys between databases or within the same database.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ReleaseNotes.md#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\n// Usage example:\nawait db.KeyCopyAsync(\"sourceKey\", \"destinationKey\", destinationDatabase: 1);\n```\n\n----------------------------------------\n\nTITLE: Redis Subscriber Interface Methods\nDESCRIPTION: Interface definitions for Redis pub/sub operations including synchronous and asynchronous subscription methods with various overloads.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ISubscriber.Subscribe(StackExchange.Redis.RedisChannel channel, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.ChannelMessageQueue!\nStackExchange.Redis.ISubscriber.Subscribe(StackExchange.Redis.RedisChannel channel, System.Action<StackExchange.Redis.RedisChannel, StackExchange.Redis.RedisValue>! handler, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> void\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Redis Channel with Sequential Message Processing in C#\nDESCRIPTION: This snippet demonstrates how to subscribe to a Redis channel using StackExchange.Redis with sequential message processing. It preserves the order of events but may introduce delays between messages.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/PubSubOrder.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar channel = multiplexer.GetSubscriber().Subscribe(\"messages\");\nchannel.OnMessage(message =>\n{\n    Console.WriteLine((string)message.Message);\n});\n```\n\n----------------------------------------\n\nTITLE: Multi-Server Redis Connection\nDESCRIPTION: Demonstrates connecting to multiple Redis servers with custom port and admin privileges enabled.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar conn = ConnectionMultiplexer.Connect(\"redis0:6380,redis1:6380,allowAdmin=true\");\n```\n\n----------------------------------------\n\nTITLE: Adding LMOVE Command Support in C#\nDESCRIPTION: Implements support for the Redis LMOVE command with new methods ListMove and ListMoveAsync, enabling atomic list element transfers between lists.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ReleaseNotes.md#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\n// Usage example:\nawait db.ListMoveAsync(\"sourceList\", \"destinationList\", ListSide.Left, ListSide.Right);\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Redis Channel with Concurrent Message Processing in C#\nDESCRIPTION: This snippet shows how to subscribe to a Redis channel using StackExchange.Redis with concurrent message processing. It offers better performance and scalability but requires thread-safe handling of messages.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/PubSubOrder.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nmultiplexer.GetSubscriber().Subscribe(\"messages\", (channel, message) => {\n    Console.WriteLine((string)message);\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Stream Entry with Custom ID and Length Trimming in C#\nDESCRIPTION: Demonstrates adding a stream entry with a custom message ID and specifying a maximum stream length. This allows for more control over the stream's content and size.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ndb.StreamAdd(\"events_stream\", \"foo_name\", \"bar_value\", messageId: \"0-1\", maxLength: 100);\n```\n\n----------------------------------------\n\nTITLE: Adding SMISMEMBER Command Support in C#\nDESCRIPTION: Implements support for the Redis SMISMEMBER command through enhanced SetContains and SetContainsAsync methods, allowing for checking multiple set memberships in a single operation.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ReleaseNotes.md#2025-04-23_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\n// Usage example:\nvar results = await db.SetContainsAsync(\"mySet\", new RedisValue[] { \"value1\", \"value2\", \"value3\" });\n```\n\n----------------------------------------\n\nTITLE: Using LoadedLuaScript for cached Redis scripting in C#\nDESCRIPTION: This example shows how to use LoadedLuaScript for more control over Lua script transmission to Redis. It demonstrates script preparation, loading onto the server, and execution using EVALSHA.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Scripting.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nconst string Script = \"redis.call('set', @key, @value)\";\n\nusing (ConnectionMultiplexer conn = /* init code */)\n{\n\tvar db = conn.GetDatabase(0);\n\tvar server = conn.GetServer(/* appropriate parameters*/);\n\n\tvar prepared = LuaScript.Prepare(Script);\n\tvar loaded = prepared.Load(server);\n\tloaded.Evaluate(db, new { key = (RedisKey)\"mykey\", value = 123 });\n}\n```\n\n----------------------------------------\n\nTITLE: ConnectionMultiplexer Method Signatures\nDESCRIPTION: Public API methods and properties for the ConnectionMultiplexer class, which handles Redis connection management and operations\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\npublic class ConnectionMultiplexer {\n    public IServer[] GetServers();\n    public string GetStatus();\n    public void GetStatus(TextWriter log);\n    public string GetStormLog();\n    public ISubscriber GetSubscriber(object asyncState = null);\n    public int HashSlot(RedisKey key);\n    public bool IncludeDetailInExceptions { get; set; }\n    public bool IsConnected { get; }\n    public bool IsConnecting { get; }\n    public long OperationCount { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: String Operations Method Signatures in StackExchange.Redis\nDESCRIPTION: Method signatures for asynchronous Redis string operations including appending, bit operations, incrementing/decrementing, getting/setting values, and handling ranges. These methods provide comprehensive string manipulation capabilities in the IDatabaseAsync interface.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.StringAppendAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StringBitCountAsync(StackExchange.Redis.RedisKey key, long start, long end, StackExchange.Redis.CommandFlags flags) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StringBitCountAsync(StackExchange.Redis.RedisKey key, long start = 0, long end = -1, StackExchange.Redis.StringIndexType indexType = StackExchange.Redis.StringIndexType.Byte, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StringBitOperationAsync(StackExchange.Redis.Bitwise operation, StackExchange.Redis.RedisKey destination, StackExchange.Redis.RedisKey first, StackExchange.Redis.RedisKey second = default(StackExchange.Redis.RedisKey), StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StringBitOperationAsync(StackExchange.Redis.Bitwise operation, StackExchange.Redis.RedisKey destination, StackExchange.Redis.RedisKey[]! keys, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StringBitPositionAsync(StackExchange.Redis.RedisKey key, bool bit, long start, long end, StackExchange.Redis.CommandFlags flags) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StringBitPositionAsync(StackExchange.Redis.RedisKey key, bool bit, long start = 0, long end = -1, StackExchange.Redis.StringIndexType indexType = StackExchange.Redis.StringIndexType.Byte, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StringDecrementAsync(StackExchange.Redis.RedisKey key, double value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<double>!\nStackExchange.Redis.IDatabaseAsync.StringDecrementAsync(StackExchange.Redis.RedisKey key, long value = 1, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StringGetAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabaseAsync.StringGetAsync(StackExchange.Redis.RedisKey[]! keys, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue[]!>!\nStackExchange.Redis.IDatabaseAsync.StringGetBitAsync(StackExchange.Redis.RedisKey key, long offset, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\nStackExchange.Redis.IDatabaseAsync.StringGetDeleteAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabaseAsync.StringGetLeaseAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.Lease<byte>?>!\nStackExchange.Redis.IDatabaseAsync.StringGetRangeAsync(StackExchange.Redis.RedisKey key, long start, long end, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabaseAsync.StringGetSetAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabaseAsync.StringGetSetExpiryAsync(StackExchange.Redis.RedisKey key, System.TimeSpan? expiry, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabaseAsync.StringGetSetExpiryAsync(StackExchange.Redis.RedisKey key, System.DateTime expiry, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabaseAsync.StringGetWithExpiryAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValueWithExpiry>!\n```\n\n----------------------------------------\n\nTITLE: Implementing Redis Key Management Methods in C#\nDESCRIPTION: Defines various asynchronous methods for managing Redis keys, including operations like copying, deleting, dumping, and checking existence of keys. These methods provide comprehensive key management functionality.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.KeyCopyAsync(StackExchange.Redis.RedisKey sourceKey, StackExchange.Redis.RedisKey destinationKey, int destinationDatabase = -1, bool replace = false, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.KeyDeleteAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.KeyDeleteAsync(StackExchange.Redis.RedisKey[]! keys, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.KeyDumpAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<byte[]?>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.KeyExistsAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.KeyExistsAsync(StackExchange.Redis.RedisKey[]! keys, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\n```\n\n----------------------------------------\n\nTITLE: Installing StackExchange.Redis via NuGet Package Manager\nDESCRIPTION: Command to install the StackExchange.Redis package using the NuGet Package Manager Console in Visual Studio.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/index.md#2025-04-23_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nPM> Install-Package StackExchange.Redis\n```\n\n----------------------------------------\n\nTITLE: Using binary keys with StackExchange.Redis\nDESCRIPTION: Example of using a byte array as a RedisKey with implicit conversion when incrementing a string value. This demonstrates how StackExchange.Redis supports binary keys through automatic conversion from byte[] to RedisKey.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysValues.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbyte[] key = ...\ndb.StringIncrement(key);\n```\n\n----------------------------------------\n\nTITLE: Redis String Operations in C#\nDESCRIPTION: Method signatures for Redis String operations including appending values, bit operations, and atomic increments/decrements. These methods provide functionality for manipulating Redis String data type.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nStringAppend(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None) -> long\nStringDecrement(RedisKey key, long value = 1, CommandFlags flags = CommandFlags.None) -> long\nStringGet(RedisKey key, CommandFlags flags = CommandFlags.None) -> RedisValue\n```\n\n----------------------------------------\n\nTITLE: Redis Asynchronous Operations Method Signatures in C#\nDESCRIPTION: Method signatures for asynchronous database operations in the StackExchange.Redis IDatabaseAsync interface. These methods provide asynchronous versions of Redis operations, primarily focused on geo-spatial functions like adding, removing, and searching for geographic points in Redis.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync\nStackExchange.Redis.IDatabaseAsync.DebugObjectAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\nStackExchange.Redis.IDatabaseAsync.ExecuteAsync(string! command, params object![]! args) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisResult!>!\nStackExchange.Redis.IDatabaseAsync.ExecuteAsync(string! command, System.Collections.Generic.ICollection<object!>? args, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisResult!>!\nStackExchange.Redis.IDatabaseAsync.GeoAddAsync(StackExchange.Redis.RedisKey key, double longitude, double latitude, StackExchange.Redis.RedisValue member, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\nStackExchange.Redis.IDatabaseAsync.GeoAddAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.GeoEntry value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\nStackExchange.Redis.IDatabaseAsync.GeoAddAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.GeoEntry[]! values, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.GeoDistanceAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member1, StackExchange.Redis.RedisValue member2, StackExchange.Redis.GeoUnit unit = StackExchange.Redis.GeoUnit.Meters, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<double?>!\nStackExchange.Redis.IDatabaseAsync.GeoHashAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<string?>!\nStackExchange.Redis.IDatabaseAsync.GeoHashAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue[]! members, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<string?[]!>!\nStackExchange.Redis.IDatabaseAsync.GeoPositionAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.GeoPosition?>!\nStackExchange.Redis.IDatabaseAsync.GeoPositionAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue[]! members, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.GeoPosition?[]!>!\nStackExchange.Redis.IDatabaseAsync.GeoRadiusAsync(StackExchange.Redis.RedisKey key, double longitude, double latitude, double radius, StackExchange.Redis.GeoUnit unit = StackExchange.Redis.GeoUnit.Meters, int count = -1, StackExchange.Redis.Order? order = null, StackExchange.Redis.GeoRadiusOptions options = StackExchange.Redis.GeoRadiusOptions.Default, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.GeoRadiusResult[]!>!\nStackExchange.Redis.IDatabaseAsync.GeoRadiusAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, double radius, StackExchange.Redis.GeoUnit unit = StackExchange.Redis.GeoUnit.Meters, int count = -1, StackExchange.Redis.Order? order = null, StackExchange.Redis.GeoRadiusOptions options = StackExchange.Redis.GeoRadiusOptions.Default, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.GeoRadiusResult[]!>!\nStackExchange.Redis.IDatabaseAsync.GeoRemoveAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\nStackExchange.Redis.IDatabaseAsync.GeoSearchAsync(StackExchange.Redis.RedisKey key, double longitude, double latitude, StackExchange.Redis.GeoSearchShape! shape, int count = -1, bool demandClosest = true, StackExchange.Redis.Order? order = null, StackExchange.Redis.GeoRadiusOptions options = StackExchange.Redis.GeoRadiusOptions.Default, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.GeoRadiusResult[]!>!\n```\n\n----------------------------------------\n\nTITLE: Retrieving Stream Information in C#\nDESCRIPTION: Demonstrates how to retrieve basic information about a Redis stream using the StreamInfo method. This information includes the stream's length and the IDs of the first and last entries.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar info = db.StreamInfo(\"events_stream\");\n\nConsole.WriteLine(info.Length);\nConsole.WriteLine(info.FirstEntry.Id);\nConsole.WriteLine(info.LastEntry.Id);\n```\n\n----------------------------------------\n\nTITLE: Fire and Forget Redis Operation in C#\nDESCRIPTION: Example of using the FireAndForget flag to queue a Redis operation without waiting for its response, allowing the code to continue execution while the operation proceeds in the background.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/PipelinesMultiplexers.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// sliding expiration\ndb.KeyExpire(key, TimeSpan.FromMinutes(5), flags: CommandFlags.FireAndForget);\nvar value = (string)db.StringGet(key);\n```\n\n----------------------------------------\n\nTITLE: Hash Operations in StackExchange.Redis\nDESCRIPTION: Comprehensive set of async hash operations including increment/decrement, field management, and value retrieval. Supports various data types and command flags.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nTask<double> HashDecrementAsync(RedisKey key, RedisValue hashField, double value, CommandFlags flags = CommandFlags.None);\nTask<bool> HashDeleteAsync(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None);\nTask<HashEntry[]> HashGetAllAsync(RedisKey key, CommandFlags flags = CommandFlags.None);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Pending Message Information for a Redis Stream Consumer Group in C#\nDESCRIPTION: Shows how to retrieve information about pending messages in a consumer group using the StreamPending method. This provides details such as the number of pending messages and consumer-specific information.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar pendingInfo = db.StreamPending(\"events_stream\", \"events_cg\");\n\nConsole.WriteLine(pendingInfo.PendingMessageCount);\nConsole.WriteLine(pendingInfo.LowestPendingMessageId);\nConsole.WriteLine(pendingInfo.HighestPendingMessageId);\nConsole.WriteLine($\"Consumer count: {pendingInfo.Consumers.Length}.\");\nConsole.WriteLine(pendingInfo.Consumers.First().Name);\nConsole.WriteLine(pendingInfo.Consumers.First().PendingMessageCount);\n```\n\n----------------------------------------\n\nTITLE: Implementing Redis List Operations in C#\nDESCRIPTION: Defines asynchronous methods for Redis list operations, including inserting, moving, popping, and pushing elements. These methods provide comprehensive functionality for manipulating Redis lists.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.ListGetByIndexAsync(StackExchange.Redis.RedisKey key, long index, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.ListInsertAfterAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue pivot, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.ListInsertBeforeAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue pivot, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.ListMoveAsync(StackExchange.Redis.RedisKey sourceKey, StackExchange.Redis.RedisKey destinationKey, StackExchange.Redis.ListSide sourceSide, StackExchange.Redis.ListSide destinationSide, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.ListLeftPopAsync(StackExchange.Redis.RedisKey key, long count, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue[]!>!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.ListLeftPushAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, StackExchange.Redis.When when = StackExchange.Redis.When.Always, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\n```\n\n----------------------------------------\n\nTITLE: ConnectionMultiplexer Events in StackExchange.Redis\nDESCRIPTION: List of events exposed by the ConnectionMultiplexer type that can be used to monitor and respond to various Redis connection states, configuration changes, and errors. These events provide insight into the internal operations of the Redis connection.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Events.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `ConfigurationChanged` - raised when the configuration of a connection is changed from inside the `ConnectionMultiplexer`\n- `ConfigurationChangedBroadcast` - raised when a reconfiguration message is received via pub/sub; this is most commonly caused by `IServer.MakeMaster` being used to change a node's replication configuration, which can optionally broadcast such a request to all clients\n- `ConnectionFailed` - raised when a connection fails for any reason; note that you will not receive further `ConnectionFailed` notifications for that connection until connectivity has been re-established\n- `ConnectionRestored` - raised when connectivity is re-established to a node that previously failed\n- `ErrorMessage` - raised when the redis server responds to any user-initiated request with an error message; this is in addition to the regular exception / fault that will be reported to the immediate caller\n- `HashSlotMoved` - raised when a \"redis cluster\" indicates that a hash-slot has been migrated between nodes; note that requests will normally be automatically re-routed, so the user is not required to do anything special here\n- `InternalError` - raised when the library fails in some unanticipated way; this is intended primarily for debugging purposes, and most users should have no need of this event\n```\n\n----------------------------------------\n\nTITLE: Configuring Twemproxy Support\nDESCRIPTION: Demonstrates how to configure StackExchange.Redis to work with Twemproxy for sharding and fault tolerance.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = new ConfigurationOptions\n{\n    EndPoints = { \"my-server\" },\n    Proxy = Proxy.Twemproxy\n};\n```\n\n----------------------------------------\n\nTITLE: Retrieving Detailed Pending Message Information for a Redis Stream Consumer in C#\nDESCRIPTION: Demonstrates how to retrieve detailed information about pending messages for a specific consumer using the StreamPendingMessages method. This provides information such as message IDs and idle times.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n// Read the first pending message for the consumer.\nvar pendingMessages = db.StreamPendingMessages(\"events_stream\",\n    \"events_cg\",\n    count: 1,\n    consumerName: \"consumer_1\",\n    minId: pendingInfo.LowestPendingMessageId);\n\nConsole.WriteLine(pendingMessages.Single().MessageId);\nConsole.WriteLine(pendingMessages.Single().IdleTimeInMilliseconds);\n```\n\n----------------------------------------\n\nTITLE: Redis List Operation Methods in C#\nDESCRIPTION: Collection of methods for manipulating Redis lists including push/pop operations, insertions, and position queries. Supports both left and right operations with various overloads for different use cases.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nIDatabase.ListLeftPush(RedisKey key, RedisValue value, When when = When.Always, CommandFlags flags = CommandFlags.None) -> long\nIDatabase.ListRightPop(RedisKey key, CommandFlags flags = CommandFlags.None) -> RedisValue\nIDatabase.ListInsertAfter(RedisKey key, RedisValue pivot, RedisValue value, CommandFlags flags = CommandFlags.None) -> long\n```\n\n----------------------------------------\n\nTITLE: Redis Hash Operations - C# Method Signatures\nDESCRIPTION: Method signatures for Redis Hash operations including increment/decrement, get/set, delete, and field management operations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nIDatabase.HashDecrement(RedisKey key, RedisValue hashField, double value, CommandFlags flags = CommandFlags.None) -> double\nIDatabase.HashIncrement(RedisKey key, RedisValue hashField, long value = 1, CommandFlags flags = CommandFlags.None) -> long\nIDatabase.HashDelete(RedisKey key, RedisValue hashField, CommandFlags flags = CommandFlags.None) -> bool\n```\n\n----------------------------------------\n\nTITLE: Command String Configuration Example\nDESCRIPTION: Shows the equivalent connection string format for the manual configuration options, demonstrating how to specify endpoints, keepalive, version, and disabled commands.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_8\n\nLANGUAGE: config\nCODE:\n```\nredis0:6379,redis1:6380,keepAlive=180,version=2.8.8,$CLIENT=,$CLUSTER=,$CONFIG=,$ECHO=,$INFO=,$PING=\n```\n\n----------------------------------------\n\nTITLE: Redis Key Management Methods in C#\nDESCRIPTION: Methods for managing Redis keys including existence checks, expiration, persistence, and type information. These methods handle core key operations with support for command flags and various expiration options.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nIDatabase.KeyExists(RedisKey key, CommandFlags flags = CommandFlags.None) -> bool\nIDatabase.KeyExpire(RedisKey key, DateTime? expiry, CommandFlags flags) -> bool\nIDatabase.KeyPersist(RedisKey key, CommandFlags flags = CommandFlags.None) -> bool\nIDatabase.KeyType(RedisKey key, CommandFlags flags = CommandFlags.None) -> RedisType\n```\n\n----------------------------------------\n\nTITLE: Redis Set Operations - C# Interface Definitions\nDESCRIPTION: Async interface methods for Redis set operations including adding/removing elements, combining sets, checking membership and getting set statistics.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\nTask<bool> SetAddAsync(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None);\nTask<long> SetAddAsync(RedisKey key, RedisValue[] values, CommandFlags flags = CommandFlags.None);\nTask<RedisValue[]> SetCombineAsync(SetOperation operation, RedisKey[] keys, CommandFlags flags = CommandFlags.None);\nTask<bool> SetContainsAsync(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None);\n```\n\n----------------------------------------\n\nTITLE: Changing Ownership of Pending Messages in a Redis Stream Consumer Group in C#\nDESCRIPTION: Demonstrates how to change the ownership of pending messages from one consumer to another using the StreamClaim method. This is useful for load balancing or handling failed consumers.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n// Change ownership to consumer_2 for the first 5 messages pending for consumer_1.\nvar pendingMessages = db.StreamPendingMessages(\"events_stream\",\n    \"events_cg\",\n    count: 5,\n    consumerName: \"consumer_1\",\n    minId: \"0-0\");\n\ndb.StreamClaim(\"events_stream\",\n    \"events_cg\",\n    claimingConsumer: \"consumer_2\",\n    minIdleTimeInMs: 0,\n    messageIds: pendingMessages.Select(m => m.MessageId).ToArray());\n```\n\n----------------------------------------\n\nTITLE: Converting script results to strongly-typed arrays\nDESCRIPTION: Example showing how to interpret script evaluation results as arrays of values. The RedisResult type returned by ScriptEvaluate can be implicitly converted to various types, including arrays of strings as shown here.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysValues.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nstring[] items = db.ScriptEvaluate(...);\n```\n\n----------------------------------------\n\nTITLE: Runtime Configuration Setup\nDESCRIPTION: Shows how to combine basic configuration string with runtime-specific options.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nstring configString = GetRedisConfiguration();\nvar options = ConfigurationOptions.Parse(configString);\noptions.ClientName = GetAppName(); // only known at runtime\noptions.AllowAdmin = true;\nconn = ConnectionMultiplexer.Connect(options);\n```\n\n----------------------------------------\n\nTITLE: Redis Lock Operations - C# Interface Definitions\nDESCRIPTION: Async interface methods for Redis distributed locking operations including taking, releasing, extending and querying locks.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\nTask<bool> LockTakeAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags = CommandFlags.None);\nTask<bool> LockReleaseAsync(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None);\nTask<bool> LockExtendAsync(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags = CommandFlags.None);\nTask<RedisValue> LockQueryAsync(RedisKey key, CommandFlags flags = CommandFlags.None);\n```\n\n----------------------------------------\n\nTITLE: Redis Server Management Interface Methods\nDESCRIPTION: Interface methods for Redis server management including client operations, cluster configuration, and server settings. These methods are part of the IServer interface.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IServer.ClientKill(System.Net.EndPoint! endpoint, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> void\nStackExchange.Redis.IServer.ClusterNodes(StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.ClusterConfiguration?\n```\n\n----------------------------------------\n\nTITLE: Redis Stream Operations in C#\nDESCRIPTION: Method signatures for Redis Stream operations including adding entries, reading streams, managing consumer groups, and handling stream metadata. These methods provide functionality for working with Redis Streams data structure.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nStreamAdd(RedisKey key, NameValueEntry[] streamPairs, RedisValue? messageId = null, int? maxLength = null, bool useApproximateMaxLength = false, CommandFlags flags = CommandFlags.None) -> RedisValue\nStreamRead(RedisKey key, RedisValue position, int? count = null, CommandFlags flags = CommandFlags.None) -> StreamEntry[]!\nStreamDelete(RedisKey key, RedisValue[] messageIds, CommandFlags flags = CommandFlags.None) -> long\n```\n\n----------------------------------------\n\nTITLE: Using Redis' Built-in Operations with When Parameter\nDESCRIPTION: C# code demonstrating how to use StackExchange.Redis's When parameter to leverage Redis' built-in atomic operations like HSETNX instead of using a transaction.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Transactions.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar newId = CreateNewId();\nbool wasSet = db.HashSet(custKey, \"UniqueID\", newId, When.NotExists);\n```\n\n----------------------------------------\n\nTITLE: Redis Geo Operations - C# Method Signatures\nDESCRIPTION: Method signatures for Redis Geo search and store operations that allow searching by coordinates or member reference, with options for shape, count, and ordering.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nIDatabase.GeoSearchAndStore(RedisKey sourceKey, RedisKey destinationKey, double longitude, double latitude, GeoSearchShape shape, int count = -1, bool demandClosest = true, Order? order = null, bool storeDistances = false, CommandFlags flags = CommandFlags.None) -> long\nIDatabase.GeoSearchAndStore(RedisKey sourceKey, RedisKey destinationKey, RedisValue member, GeoSearchShape shape, int count = -1, bool demandClosest = true, Order? order = null, bool storeDistances = false, CommandFlags flags = CommandFlags.None) -> long\n```\n\n----------------------------------------\n\nTITLE: Redis Sentinel Management Operations\nDESCRIPTION: Methods for managing Redis Sentinel operations including failover, master/replica management, and sentinel monitoring. Provides both synchronous and asynchronous implementations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IServer.SentinelFailover(string serviceName, CommandFlags flags = CommandFlags.None) -> void\nStackExchange.Redis.IServer.SentinelGetMasterAddressByName(string serviceName, CommandFlags flags = CommandFlags.None) -> System.Net.EndPoint?\n```\n\n----------------------------------------\n\nTITLE: Executing Lua scripts with keys and values in Redis\nDESCRIPTION: Example of using the ScriptEvaluate method with separate arrays for keys and values. This is one of the few cases where you need to explicitly use RedisKey and RedisValue types in your code, due to array variance rules.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysValues.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar result = db.ScriptEvaluate(TransferScript,\n    new RedisKey[] { from, to }, new RedisValue[] { quantity });\n```\n\n----------------------------------------\n\nTITLE: Configuration Options Class\nDESCRIPTION: Configuration class for setting up Redis connection and behavior options including timeouts, security, and connection management\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ConfigurationOptions.AbortOnConnectFail.get -> bool\nStackExchange.Redis.ConfigurationOptions.AllowAdmin.get -> bool\nStackExchange.Redis.ConfigurationOptions.AsyncTimeout.get -> int\nStackExchange.Redis.ConfigurationOptions.ConfigurationOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing Thread-based Profiler for StackExchange.Redis\nDESCRIPTION: This example shows how to create a toy profiler that associates commands from multiple threads. It uses ThreadLocal<T> to manage per-thread sessions and demonstrates how to gather profiling data from multiple threads executing Redis commands.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Profiling_v2.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass ToyProfiler\n{\n    // note this won't work over \"await\" boundaries; \"AsyncLocal\" would be necessary there\n    private readonly ThreadLocal<ProfilingSession> perThreadSession = new ThreadLocal<ProfilingSession>();\n    public ProfilingSession PerThreadSession\n    {\n        get => perThreadSession.Value;\n        set => perThreadSession.Value = value;\n    }\n}\n\n// ...\n\nConnectionMultiplexer conn = /* initialization */;\nvar profiler = new ToyProfiler();\nvar sharedSession = new ProfilingSession();\n\nconn.RegisterProfiler(() => profiler.PerThreadSession);\n\nvar threads = new List<Thread>();\n\nfor (var i = 0; i < 16; i++)\n{\n    var db = conn.GetDatabase(i);\n\n    var thread =\n        new Thread(\n            delegate()\n            {\n                // set each thread to share a session\n            \tprofiler.PerThreadSession = sharedSession;\n\n                var threadTasks = new List<Task>();\n\n                for (var j = 0; j < 1000; j++)\n                {\n                    var task = db.StringSetAsync(\"\" + j, \"\" + j);\n                    threadTasks.Add(task);\n                }\n\n                Task.WaitAll(threadTasks.ToArray());\n            }\n        );\n\n\tthreads.Add(thread);\n}\n\nthreads.ForEach(thread => thread.Start());\nthreads.ForEach(thread => thread.Join());\n\nvar timings = sharedSession.FinishProfiling();\n```\n\n----------------------------------------\n\nTITLE: Creating a Consumer Group for a Redis Stream in C#\nDESCRIPTION: Shows how to create a consumer group for a Redis stream using the StreamCreateConsumerGroup method. This example creates a group that will only read new messages added after the group's creation.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Streams.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// Returns true if created, otherwise false.\ndb.StreamCreateConsumerGroup(\"events_stream\", \"events_consumer_group\", \"$\");\n// or\ndb.StreamCreateConsumerGroup(\"events_stream\", \"events_consumer_group\", StreamPosition.NewMessages);\n```\n\n----------------------------------------\n\nTITLE: Redis String Operation Method Signatures in C#\nDESCRIPTION: Method signatures for string operations in the StackExchange.Redis IDatabase interface. These methods allow interaction with Redis string values, including getting, setting, incrementing, and manipulating string data with various options for expiration and conditional operations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabase.StringGet(StackExchange.Redis.RedisKey[]! keys, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.StringGetBit(StackExchange.Redis.RedisKey key, long offset, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.StringGetDelete(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue\nStackExchange.Redis.IDatabase.StringGetLease(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.Lease<byte>?\nStackExchange.Redis.IDatabase.StringGetRange(StackExchange.Redis.RedisKey key, long start, long end, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue\nStackExchange.Redis.IDatabase.StringGetSet(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue\nStackExchange.Redis.IDatabase.StringGetSetExpiry(StackExchange.Redis.RedisKey key, System.TimeSpan? expiry, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue\nStackExchange.Redis.IDatabase.StringGetSetExpiry(StackExchange.Redis.RedisKey key, System.DateTime expiry, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue\nStackExchange.Redis.IDatabase.StringGetWithExpiry(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValueWithExpiry\nStackExchange.Redis.IDatabase.StringIncrement(StackExchange.Redis.RedisKey key, double value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> double\nStackExchange.Redis.IDatabase.StringIncrement(StackExchange.Redis.RedisKey key, long value = 1, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.StringLength(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.StringLongestCommonSubsequence(StackExchange.Redis.RedisKey first, StackExchange.Redis.RedisKey second, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> string?\nStackExchange.Redis.IDatabase.StringLongestCommonSubsequenceLength(StackExchange.Redis.RedisKey first, StackExchange.Redis.RedisKey second, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.StringLongestCommonSubsequenceWithMatches(StackExchange.Redis.RedisKey first, StackExchange.Redis.RedisKey second, long minLength = 0, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.LCSMatchResult\nStackExchange.Redis.IDatabase.StringSet(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, System.TimeSpan? expiry = null, bool keepTtl = false, StackExchange.Redis.When when = StackExchange.Redis.When.Always, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.StringSet(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, System.TimeSpan? expiry, StackExchange.Redis.When when) -> bool\nStackExchange.Redis.IDatabase.StringSet(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, System.TimeSpan? expiry, StackExchange.Redis.When when, StackExchange.Redis.CommandFlags flags) -> bool\nStackExchange.Redis.IDatabase.StringSet(System.Collections.Generic.KeyValuePair<StackExchange.Redis.RedisKey, StackExchange.Redis.RedisValue>[]! values, StackExchange.Redis.When when = StackExchange.Redis.When.Always, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.StringSetAndGet(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, System.TimeSpan? expiry = null, bool keepTtl = false, StackExchange.Redis.When when = StackExchange.Redis.When.Always, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue\nStackExchange.Redis.IDatabase.StringSetAndGet(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value, System.TimeSpan? expiry, StackExchange.Redis.When when, StackExchange.Redis.CommandFlags flags) -> StackExchange.Redis.RedisValue\nStackExchange.Redis.IDatabase.StringSetBit(StackExchange.Redis.RedisKey key, long offset, bool bit, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.StringSetRange(StackExchange.Redis.RedisKey key, long offset, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue\n```\n\n----------------------------------------\n\nTITLE: Enabling RESP Stream Logging in StackExchange.Redis\nDESCRIPTION: This snippet shows how to enable logging of RESP streams to a specified directory. It uses the LoggingTunnel.LogToDirectory method to set up logging before connecting to Redis.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/RespLogging.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// connect\nConsole.WriteLine(\"Connecting...\");\nvar options = ConfigurationOptions.Parse(ConnectionString);\nLoggingTunnel.LogToDirectory(options, @\"C:\\Code\\RedisLog\"); // <=== added!\nawait using var muxer = await ConnectionMultiplexer.ConnectAsync(options);\n...\n```\n\n----------------------------------------\n\nTITLE: Stream Operations Method Signatures in StackExchange.Redis\nDESCRIPTION: Method signatures for asynchronous Redis stream operations including deleting messages, managing consumer groups, retrieving stream information, reading from streams, and trimming streams. These methods are part of the IDatabaseAsync interface in StackExchange.Redis.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.StreamDeleteAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue[]! messageIds, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StreamDeleteConsumerAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue consumerName, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StreamDeleteConsumerGroupAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\nStackExchange.Redis.IDatabaseAsync.StreamGroupInfoAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamGroupInfo[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamInfoAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamInfo>!\nStackExchange.Redis.IDatabaseAsync.StreamLengthAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.StreamPendingAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamPendingInfo>!\nStackExchange.Redis.IDatabaseAsync.StreamPendingMessagesAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, int count, StackExchange.Redis.RedisValue consumerName, StackExchange.Redis.RedisValue? minId = null, StackExchange.Redis.RedisValue? maxId = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamPendingMessageInfo[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamRangeAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue? minId = null, StackExchange.Redis.RedisValue? maxId = null, int? count = null, StackExchange.Redis.Order messageOrder = StackExchange.Redis.Order.Ascending, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamEntry[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamReadAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue position, int? count = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamEntry[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamReadAsync(StackExchange.Redis.StreamPosition[]! streamPositions, int? countPerStream = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisStream[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamReadGroupAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue consumerName, StackExchange.Redis.RedisValue? position = null, int? count = null, bool noAck = false, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamEntry[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamReadGroupAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue consumerName, StackExchange.Redis.RedisValue? position, int? count, StackExchange.Redis.CommandFlags flags) -> System.Threading.Tasks.Task<StackExchange.Redis.StreamEntry[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamReadGroupAsync(StackExchange.Redis.StreamPosition[]! streamPositions, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue consumerName, int? countPerStream = null, bool noAck = false, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisStream[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamReadGroupAsync(StackExchange.Redis.StreamPosition[]! streamPositions, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue consumerName, int? countPerStream, StackExchange.Redis.CommandFlags flags) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisStream[]!>!\nStackExchange.Redis.IDatabaseAsync.StreamTrimAsync(StackExchange.Redis.RedisKey key, int maxLength, bool useApproximateMaxLength = false, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\n```\n\n----------------------------------------\n\nTITLE: Defining Redis Data Structures in C#\nDESCRIPTION: This snippet shows the declaration of various Redis-related data structures such as ChannelMessage, GeoEntry, and HashEntry. It includes method overrides for equality comparison and string representation.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\noverride StackExchange.Redis.ChannelMessage.Equals(object? obj) -> bool\noverride StackExchange.Redis.ChannelMessage.GetHashCode() -> int\noverride StackExchange.Redis.ChannelMessage.ToString() -> string!\n\noverride StackExchange.Redis.GeoEntry.Equals(object? obj) -> bool\noverride StackExchange.Redis.GeoEntry.GetHashCode() -> int\noverride StackExchange.Redis.GeoEntry.ToString() -> string!\n\noverride StackExchange.Redis.HashEntry.Equals(object? obj) -> bool\noverride StackExchange.Redis.HashEntry.GetHashCode() -> int\noverride StackExchange.Redis.HashEntry.ToString() -> string!\n```\n\n----------------------------------------\n\nTITLE: Redis String Operations Interface Methods\nDESCRIPTION: Async interface methods for Redis string operations including increment, length, common subsequence, and set operations. These methods are part of the IDatabaseAsync interface.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.StringIncrementAsync(StackExchange.Redis.RedisKey key, double value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<double>!\nStackExchange.Redis.IDatabaseAsync.StringLengthAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\n```\n\n----------------------------------------\n\nTITLE: Implementing Redis Profiler for MVC5 Application\nDESCRIPTION: This example shows how to implement a Redis profiler in an MVC5 application. It uses HttpContext to store profiling sessions per request and demonstrates how to set up profiling at the beginning and end of each request.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Profiling_v2.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class RedisProfiler\n{\n    const string RequestContextKey = \"RequestProfilingContext\";\n\n    public ProfilingSession GetSession()\n    {\n        var ctx = HttpContext.Current;\n        if (ctx == null) return null;\n\n        return (ProfilingSession)ctx.Items[RequestContextKey];\n    }\n\n    public void CreateSessionForCurrentRequest()\n    {\n        var ctx = HttpContext.Current;\n        if (ctx != null)\n        {\n            ctx.Items[RequestContextKey] = new ProfilingSession();\n        }\n    }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nprotected void Application_BeginRequest()\n{\n    _redisProfiler.CreateSessionForCurrentRequest();\n}\n\nprotected void Application_EndRequest()\n{\n    var session = _redisProfiler.GetSession();\n    if (session != null)\n    {\n        var timings = session.FinishProfiling();\n\n\t\t// do what you will with `timings` here\n    }\n}\n```\n\nLANGUAGE: csharp\nCODE:\n```\nconnection.RegisterProfiler(() => _redisProfiler.GetSession());\n```\n\n----------------------------------------\n\nTITLE: StackExchange.Redis Lua Script Evaluation\nDESCRIPTION: C# code showing how to execute a Lua script in Redis using StackExchange.Redis's ScriptEvaluate method, providing keys and arguments to the script.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Transactions.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar wasSet = (bool) db.ScriptEvaluate(@\"if redis.call('hexists', KEYS[1], 'UniqueId') then return redis.call('hset', KEYS[1], 'UniqueId', ARGV[1]) else return 0 end\",\n        new RedisKey[] { custKey }, new RedisValue[] { newId });\n```\n\n----------------------------------------\n\nTITLE: GeoSearch Operations in StackExchange.Redis\nDESCRIPTION: Async methods for performing geospatial searches and storing results in Redis. Includes options for searching by member or coordinates with various search parameters.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nTask<GeoRadiusResult[]> GeoSearchAsync(RedisKey key, RedisValue member, GeoSearchShape shape, int count = -1, bool demandClosest = true, Order? order = null, GeoRadiusOptions options = GeoRadiusOptions.Default, CommandFlags flags = CommandFlags.None);\nTask<long> GeoSearchAndStoreAsync(RedisKey sourceKey, RedisKey destinationKey, double longitude, double latitude, GeoSearchShape shape, int count = -1, bool demandClosest = true, Order? order = null, bool storeDistances = false, CommandFlags flags = CommandFlags.None);\n```\n\n----------------------------------------\n\nTITLE: RedisValue Static Members and Operators in C#\nDESCRIPTION: Defines static members and operators for RedisValue, including a Null property, equality operators, and an Unbox method for converting from object to RedisValue.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.RedisValue.Null.get -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.operator !=(StackExchange.Redis.RedisValue x, StackExchange.Redis.RedisValue y) -> bool\nstatic StackExchange.Redis.RedisValue.operator ==(StackExchange.Redis.RedisValue x, StackExchange.Redis.RedisValue y) -> bool\nstatic StackExchange.Redis.RedisValue.Unbox(object? value) -> StackExchange.Redis.RedisValue\n```\n\n----------------------------------------\n\nTITLE: Sequential Redis Operations in C#\nDESCRIPTION: Example of sequential operations to retrieve two Redis values, which introduces significant latency as each operation waits for the previous one to complete before starting.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/PipelinesMultiplexers.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nstring a = db.StringGet(\"a\");\nstring b = db.StringGet(\"b\");\n```\n\n----------------------------------------\n\nTITLE: Redis Lock Management Methods in C#\nDESCRIPTION: Methods for implementing distributed locks in Redis, including lock extension, querying, and release operations. These methods provide atomic operations for distributed synchronization.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nIDatabase.LockExtend(RedisKey key, RedisValue value, TimeSpan expiry, CommandFlags flags = CommandFlags.None) -> bool\nIDatabase.LockQuery(RedisKey key, CommandFlags flags = CommandFlags.None) -> RedisValue\nIDatabase.LockRelease(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi-threaded Redis Profiling in C#\nDESCRIPTION: Demonstrates a toy example of profiling Redis commands across multiple threads using a custom IProfiler implementation. Shows how to track and group commands from different threads using a shared context.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Profiling_v1.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass ToyProfiler : IProfiler\n{\n\tpublic ConcurrentDictionary<Thread, object> Contexts = new ConcurrentDictionary<Thread, object>();\n\n\tpublic object GetContext()\n\t{\n\t\tobject ctx;\n\t\tif(!Contexts.TryGetValue(Thread.CurrentThread, out ctx)) ctx = null;\n\n\t\treturn ctx;\n\t}\n}\n\n// ...\n\nConnectionMultiplexer conn = /* initialization */;\nvar profiler = new ToyProfiler();\nvar thisGroupContext = new object();\n\nconn.RegisterProfiler(profiler);\n\nvar threads = new List<Thread>();\n\nfor (var i = 0; i < 16; i++)\n{\n    var db = conn.GetDatabase(i);\n\n    var thread =\n        new Thread(\n            delegate()\n            {\n                var threadTasks = new List<Task>();\n\n                for (var j = 0; j < 1000; j++)\n                {\n                    var task = db.StringSetAsync(\"\" + j, \"\" + j);\n                    threadTasks.Add(task);\n                }\n\n                Task.WaitAll(threadTasks.ToArray());\n            }\n        );\n\n\tprofiler.Contexts[thread] = thisGroupContext;\n\n\tthreads.Add(thread);\n}\n\nconn.BeginProfiling(thisGroupContext);\n\nthreads.ForEach(thread => thread.Start());\nthreads.ForEach(thread => thread.Join());\n\nIEnumerable<IProfiledCommand> timings = conn.FinishProfiling(thisGroupContext);\n```\n\n----------------------------------------\n\nTITLE: Per-Thread Redis Command Profiling in C#\nDESCRIPTION: Shows how to implement profiling that tracks Redis commands separately for each thread, storing timing results in a concurrent dictionary.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Profiling_v1.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nConnectionMultiplexer conn = /* initialization */;\nvar profiler = new ToyProfiler();\n\nconn.RegisterProfiler(profiler);\n\nvar threads = new List<Thread>();\n\nvar perThreadTimings = new ConcurrentDictionary<Thread, List<IProfiledCommand>>();\n\nfor (var i = 0; i < 16; i++)\n{\n    var db = conn.GetDatabase(i);\n\n    var thread =\n        new Thread(\n            delegate()\n            {\n                var threadTasks = new List<Task>();\n\n                conn.BeginProfiling(Thread.CurrentThread);\n\n                for (var j = 0; j < 1000; j++)\n                {\n                    var task = db.StringSetAsync(\"\" + j, \"\" + j);\n                    threadTasks.Add(task);\n                }\n\n                Task.WaitAll(threadTasks.ToArray());\n\n                perThreadTimings[Thread.CurrentThread] = conn.FinishProfiling(Thread.CurrentThread).ToList();\n            }\n        );\n\n    profiler.Contexts[thread] = thread;\n\n    threads.Add(thread);\n}\n\nthreads.ForEach(thread => thread.Start());\nthreads.ForEach(thread => thread.Join());\n```\n\n----------------------------------------\n\nTITLE: Sorted Set Operations in StackExchange.Redis IDatabase Interface\nDESCRIPTION: This snippet showcases various method signatures for performing operations on sorted sets in Redis using the StackExchange.Redis library. It includes methods for combining, incrementing/decrementing, querying, and manipulating sorted set members.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabase.SortedSetCombineAndStore(StackExchange.Redis.SetOperation operation, StackExchange.Redis.RedisKey destination, StackExchange.Redis.RedisKey[]! keys, double[]? weights = null, StackExchange.Redis.Aggregate aggregate = StackExchange.Redis.Aggregate.Sum, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetDecrement(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, double value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> double\nStackExchange.Redis.IDatabase.SortedSetIncrement(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, double value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> double\nStackExchange.Redis.IDatabase.SortedSetIntersectionLength(StackExchange.Redis.RedisKey[]! keys, long limit = 0, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetLength(StackExchange.Redis.RedisKey key, double min = -Infinity, double max = Infinity, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetLengthByValue(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue min, StackExchange.Redis.RedisValue max, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetPop(StackExchange.Redis.RedisKey key, long count, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.SortedSetEntry[]!\nStackExchange.Redis.IDatabase.SortedSetPop(StackExchange.Redis.RedisKey key, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.SortedSetEntry?\nStackExchange.Redis.IDatabase.SortedSetPop(StackExchange.Redis.RedisKey[]! keys, long count, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.SortedSetPopResult\nStackExchange.Redis.IDatabase.SortedSetRandomMember(StackExchange.Redis.RedisKey key, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue\nStackExchange.Redis.IDatabase.SortedSetRandomMembers(StackExchange.Redis.RedisKey key, long count, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SortedSetRandomMembersWithScores(StackExchange.Redis.RedisKey key, long count, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.SortedSetEntry[]!\nStackExchange.Redis.IDatabase.SortedSetRangeByRank(StackExchange.Redis.RedisKey key, long start = 0, long stop = -1, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SortedSetRangeAndStore(StackExchange.Redis.RedisKey sourceKey, StackExchange.Redis.RedisKey destinationKey, StackExchange.Redis.RedisValue start, StackExchange.Redis.RedisValue stop, StackExchange.Redis.SortedSetOrder sortedSetOrder = StackExchange.Redis.SortedSetOrder.ByRank, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, long skip = 0, long? take = null, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetRangeByRankWithScores(StackExchange.Redis.RedisKey key, long start = 0, long stop = -1, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.SortedSetEntry[]!\nStackExchange.Redis.IDatabase.SortedSetRangeByScore(StackExchange.Redis.RedisKey key, double start = -Infinity, double stop = Infinity, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, long skip = 0, long take = -1, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SortedSetRangeByScoreWithScores(StackExchange.Redis.RedisKey key, double start = -Infinity, double stop = Infinity, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, long skip = 0, long take = -1, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.SortedSetEntry[]!\nStackExchange.Redis.IDatabase.SortedSetRangeByValue(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue min = default(StackExchange.Redis.RedisValue), StackExchange.Redis.RedisValue max = default(StackExchange.Redis.RedisValue), StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, long skip = 0, long take = -1, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SortedSetRangeByValue(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue min, StackExchange.Redis.RedisValue max, StackExchange.Redis.Exclude exclude, long skip, long take = -1, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> StackExchange.Redis.RedisValue[]!\nStackExchange.Redis.IDatabase.SortedSetRank(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long?\nStackExchange.Redis.IDatabase.SortedSetRemove(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.SortedSetRemove(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue[]! members, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetRemoveRangeByRank(StackExchange.Redis.RedisKey key, long start, long stop, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetRemoveRangeByScore(StackExchange.Redis.RedisKey key, double start, double stop, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetRemoveRangeByValue(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue min, StackExchange.Redis.RedisValue max, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.SortedSetScan(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue pattern = default(StackExchange.Redis.RedisValue), int pageSize = 250, long cursor = 0, int pageOffset = 0, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Collections.Generic.IEnumerable<StackExchange.Redis.SortedSetEntry>!\nStackExchange.Redis.IDatabase.SortedSetScan(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue pattern, int pageSize, StackExchange.Redis.CommandFlags flags) -> System.Collections.Generic.IEnumerable<StackExchange.Redis.SortedSetEntry>!\nStackExchange.Redis.IDatabase.SortedSetScore(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> double?\nStackExchange.Redis.IDatabase.SortedSetScores(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue[]! members, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> double?[]!\nStackExchange.Redis.IDatabase.SortedSetUpdate(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, double score, StackExchange.Redis.SortedSetWhen when = StackExchange.Redis.SortedSetWhen.Always, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.IDatabase.SortedSetUpdate(StackExchange.Redis.RedisKey key, StackExchange.Redis.SortedSetEntry[]! values, StackExchange.Redis.SortedSetWhen when = StackExchange.Redis.SortedSetWhen.Always, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\n```\n\n----------------------------------------\n\nTITLE: Redis Subscription Management Interface\nDESCRIPTION: ISubscriber interface methods for managing Redis pub/sub operations, including publishing messages and identifying endpoints. Supports both synchronous and asynchronous operations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ISubscriber.Publish(RedisChannel channel, RedisValue message, CommandFlags flags = CommandFlags.None) -> long\nStackExchange.Redis.ISubscriber.IsConnected(RedisChannel channel = default(RedisChannel)) -> bool\nStackExchange.Redis.ISubscriber.IdentifyEndpoint(RedisChannel channel, CommandFlags flags = CommandFlags.None) -> System.Net.EndPoint?\n```\n\n----------------------------------------\n\nTITLE: Validating Logged RESP Streams in StackExchange.Redis\nDESCRIPTION: This snippet demonstrates how to validate logged RESP streams using the LoggingTunnel.ValidateAsync method. It checks the validity of the RESP fragments in the specified directory.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/RespLogging.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar messages = await LoggingTunnel.ValidateAsync(@\"C:\\Code\\RedisLog\");\nConsole.WriteLine($\"{messages} RESP fragments validated\");\n```\n\n----------------------------------------\n\nTITLE: MVC5 Redis Profiler Implementation\nDESCRIPTION: Implementation of an IProfiler for ASP.NET MVC5 applications that associates Redis commands with HTTP requests using HttpContext.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Profiling_v1.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class RedisProfiler : IProfiler\n{\n    const string RequestContextKey = \"RequestProfilingContext\";\n\n    public object GetContext()\n    {\n        var ctx = HttpContext.Current;\n        if (ctx == null) return null;\n\n        return ctx.Items[RequestContextKey];\n    }\n\n    public object CreateContextForCurrentRequest()\n    {\n        var ctx = HttpContext.Current;\n        if (ctx == null) return null;\n\n        object ret;\n        ctx.Items[RequestContextKey] = ret = new object();\n\n        return ret;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for nil values with IsNull\nDESCRIPTION: Example demonstrating how to check if a retrieved value is null (nil in Redis terms) using the IsNull property. This allows you to distinguish between an actual zero value and a non-existent key.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysValues.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\ndb.KeyDelete(\"abc\");\nvar value = db.StringGet(\"abc\");\nbool isNil = value.IsNull; // this is true\n```\n\n----------------------------------------\n\nTITLE: Redis Script Operations - C# Interface Definitions\nDESCRIPTION: Async interface methods for evaluating Lua scripts in Redis, including support for loaded scripts, script hashes and read-only operations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\nTask<RedisResult> ScriptEvaluateAsync(string script, RedisKey[]? keys = null, RedisValue[]? values = null, CommandFlags flags = CommandFlags.None);\nTask<RedisResult> ScriptEvaluateAsync(byte[] hash, RedisKey[]? keys = null, RedisValue[]? values = null, CommandFlags flags = CommandFlags.None);\nTask<RedisResult> ScriptEvaluateReadOnlyAsync(string script, RedisKey[]? keys = null, RedisValue[]? values = null, CommandFlags flags = CommandFlags.None);\n```\n\n----------------------------------------\n\nTITLE: Redis Data Type Extension Methods in C#\nDESCRIPTION: This snippet shows various extension methods for Redis data types, including conversion methods for HashEntry arrays, SortedSetEntry arrays, and RedisValue arrays. These methods facilitate working with Redis data in more familiar .NET data structures.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.ExtensionMethods.ToDictionary(this StackExchange.Redis.HashEntry[]? hash) -> System.Collections.Generic.Dictionary<StackExchange.Redis.RedisValue, StackExchange.Redis.RedisValue>?\nstatic StackExchange.Redis.ExtensionMethods.ToStringArray(this StackExchange.Redis.RedisValue[]? values) -> string?[]?\nstatic StackExchange.Redis.ExtensionMethods.ToStringDictionary(this StackExchange.Redis.SortedSetEntry[]? sortedSet) -> System.Collections.Generic.Dictionary<string!, double>?\n```\n\n----------------------------------------\n\nTITLE: Redis List Operations - C# Interface Definitions\nDESCRIPTION: Async interface methods for Redis list operations including position finding, range queries, pushing/popping elements, and list manipulation.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\nTask<long[]> ListPositionsAsync(RedisKey key, RedisValue element, long count, long rank = 1, long maxLength = 0, CommandFlags flags = CommandFlags.None);\nTask<RedisValue[]> ListRangeAsync(RedisKey key, long start = 0, long stop = -1, CommandFlags flags = CommandFlags.None);\nTask<long> ListRemoveAsync(RedisKey key, RedisValue value, long count = 0, CommandFlags flags = CommandFlags.None);\n```\n\n----------------------------------------\n\nTITLE: Redis Server Script Management Methods\nDESCRIPTION: Interface methods for managing Lua scripts on Redis server, including loading, checking existence, and flushing scripts. Methods are available in both synchronous and async versions.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IServer.ScriptExists(byte[] sha1, CommandFlags flags = CommandFlags.None) -> bool\nStackExchange.Redis.IServer.ScriptLoad(string script, CommandFlags flags = CommandFlags.None) -> byte[]\nStackExchange.Redis.IServer.ScriptFlush(CommandFlags flags = CommandFlags.None) -> void\n```\n\n----------------------------------------\n\nTITLE: Replaying and Formatting RESP Communication in StackExchange.Redis\nDESCRIPTION: This snippet shows how to replay and format the logged RESP communication using LoggingTunnel.ReplayAsync. It demonstrates custom formatting of commands and responses, including handling of out-of-band responses.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/RespLogging.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar messages = await LoggingTunnel.ReplayAsync(@\"C:\\Code\\RedisLog\", (cmd, resp) =>\n{\n    if (cmd.IsNull)\n    {\n        // out-of-band/\"push\" response\n        Console.WriteLine(\"<< \" + LoggingTunnel.DefaultFormatResponse(resp));\n    }\n    else\n    {\n        Console.WriteLine(\" > \" + LoggingTunnel.DefaultFormatCommand(cmd));\n        Console.WriteLine(\" < \" + LoggingTunnel.DefaultFormatResponse(resp));\n    }\n});\nConsole.WriteLine($\"{messages} RESP commands validated\");\n```\n\n----------------------------------------\n\nTITLE: LuaScript Static Methods in StackExchange.Redis\nDESCRIPTION: Static methods for managing Lua scripts in Redis, including script preparation, cache management, and retrieving cached script count.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_59\n\nLANGUAGE: csharp\nCODE:\n```\nstatic StackExchange.Redis.LuaScript.GetCachedScriptCount() -> int\nstatic StackExchange.Redis.LuaScript.Prepare(string! script) -> StackExchange.Redis.LuaScript!\nstatic StackExchange.Redis.LuaScript.PurgeCache() -> void\n```\n\n----------------------------------------\n\nTITLE: Renaming Redis Commands with CommandMap\nDESCRIPTION: Demonstrates how to disable and rename Redis commands using the CommandMap feature with a Dictionary configuration.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar commands = new Dictionary<string,string> {\n        { \"info\", null }, // disabled\n        { \"select\", \"use\" }, // renamed to SQL equivalent for some reason\n};\nvar options = new ConfigurationOptions {\n    // ...\n    CommandMap = CommandMap.Create(commands),\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Converting RedisKey to string implicitly\nDESCRIPTION: Example showing how a RedisKey returned from a Redis operation can be implicitly converted to a string. The KeyRandom method returns a RedisKey, but it can be assigned directly to a string variable.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysValues.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nstring someKey = db.KeyRandom();\n```\n\n----------------------------------------\n\nTITLE: Configuring minIoThreads in ASP.NET machine.config\nDESCRIPTION: XML configuration for setting the minimum I/O threads in ASP.NET applications through the processModel element. This helps prevent timeouts by ensuring enough threads are available to process Redis operations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Timeouts.md#2025-04-23_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<processModel autoConfig=\"false\" minIoThreads=\"250\" />\n```\n\n----------------------------------------\n\nTITLE: Redis Key Operations - C# Method Signatures\nDESCRIPTION: Method signatures for Redis key management operations including copy, delete, dump, and encoding operations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nIDatabase.KeyCopy(RedisKey sourceKey, RedisKey destinationKey, int destinationDatabase = -1, bool replace = false, CommandFlags flags = CommandFlags.None) -> bool\nIDatabase.KeyDelete(RedisKey key, CommandFlags flags = CommandFlags.None) -> bool\nIDatabase.KeyDump(RedisKey key, CommandFlags flags = CommandFlags.None) -> byte[]?\nIDatabase.KeyEncoding(RedisKey key, CommandFlags flags = CommandFlags.None) -> string?\n```\n\n----------------------------------------\n\nTITLE: Handling non-existent keys with numeric retrieval\nDESCRIPTION: Example showing how Redis treats non-existent keys as zero when performing numeric operations. The code deletes a key and then retrieves its value as an integer, resulting in zero.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/KeysValues.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ndb.KeyDelete(\"abc\");\nint i = (int)db.StringGet(\"abc\"); // this is ZERO\n```\n\n----------------------------------------\n\nTITLE: C# Redis Enumeration Definitions\nDESCRIPTION: Definition of Redis type enumerations including None, List, Set, SortedSet, Hash, and Stream types.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.RedisType.None = 0\nStackExchange.Redis.RedisType.List = 2\nStackExchange.Redis.RedisType.Set = 3\nStackExchange.Redis.RedisType.SortedSet = 4\nStackExchange.Redis.RedisType.Hash = 5\nStackExchange.Redis.RedisType.Stream = 6\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Redis SortedSet Operations in StackExchange.Redis\nDESCRIPTION: Method signatures for asynchronous operations on Redis sorted sets. These methods allow querying, retrieving, and manipulating data in sorted sets by rank, score, or value with various filtering and sorting options.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.SortedSetRangeByRankWithScoresAsync(StackExchange.Redis.RedisKey key, long start = 0, long stop = -1, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.SortedSetEntry[]!>!\nStackExchange.Redis.IDatabaseAsync.SortedSetRangeByScoreAsync(StackExchange.Redis.RedisKey key, double start = -Infinity, double stop = Infinity, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, long skip = 0, long take = -1, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue[]!>!\nStackExchange.Redis.IDatabaseAsync.SortedSetRangeByScoreWithScoresAsync(StackExchange.Redis.RedisKey key, double start = -Infinity, double stop = Infinity, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, long skip = 0, long take = -1, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.SortedSetEntry[]!>!\nStackExchange.Redis.IDatabaseAsync.SortedSetRangeByValueAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue min = default(StackExchange.Redis.RedisValue), StackExchange.Redis.RedisValue max = default(StackExchange.Redis.RedisValue), StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, long skip = 0, long take = -1, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue[]!>!\nStackExchange.Redis.IDatabaseAsync.SortedSetRangeByValueAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue min, StackExchange.Redis.RedisValue max, StackExchange.Redis.Exclude exclude, long skip, long take = -1, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<StackExchange.Redis.RedisValue[]!>!\nStackExchange.Redis.IDatabaseAsync.SortedSetRankAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, StackExchange.Redis.Order order = StackExchange.Redis.Order.Ascending, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long?>!\nStackExchange.Redis.IDatabaseAsync.SortedSetRemoveAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\nStackExchange.Redis.IDatabaseAsync.SortedSetRemoveAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue[]! members, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.SortedSetRemoveRangeByRankAsync(StackExchange.Redis.RedisKey key, long start, long stop, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.SortedSetRemoveRangeByScoreAsync(StackExchange.Redis.RedisKey key, double start, double stop, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.SortedSetRemoveRangeByValueAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue min, StackExchange.Redis.RedisValue max, StackExchange.Redis.Exclude exclude = StackExchange.Redis.Exclude.None, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\nStackExchange.Redis.IDatabaseAsync.SortedSetScanAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue pattern = default(StackExchange.Redis.RedisValue), int pageSize = 250, long cursor = 0, int pageOffset = 0, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Collections.Generic.IAsyncEnumerable<StackExchange.Redis.SortedSetEntry>!\nStackExchange.Redis.IDatabaseAsync.SortedSetScoreAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<double?>!\nStackExchange.Redis.IDatabaseAsync.SortedSetScoresAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue[]! members, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<double?[]!>!\nStackExchange.Redis.IDatabaseAsync.SortedSetUpdateAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member, double score, StackExchange.Redis.SortedSetWhen when = StackExchange.Redis.SortedSetWhen.Always, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\nStackExchange.Redis.IDatabaseAsync.SortedSetUpdateAsync(StackExchange.Redis.RedisKey key, StackExchange.Redis.SortedSetEntry[]! values, StackExchange.Redis.SortedSetWhen when = StackExchange.Redis.SortedSetWhen.Always, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<long>!\n```\n\n----------------------------------------\n\nTITLE: Implementing Redis Channel Operations in C#\nDESCRIPTION: This snippet defines the ChannelMessageQueue class, which handles Redis pub/sub operations. It includes methods for subscribing, unsubscribing, and reading messages asynchronously.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ChannelMessageQueue\nStackExchange.Redis.ChannelMessageQueue.Channel.get -> StackExchange.Redis.RedisChannel\nStackExchange.Redis.ChannelMessageQueue.Completion.get -> System.Threading.Tasks.Task!\nStackExchange.Redis.ChannelMessageQueue.GetAsyncEnumerator(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Collections.Generic.IAsyncEnumerator<StackExchange.Redis.ChannelMessage>!\nStackExchange.Redis.ChannelMessageQueue.OnMessage(System.Action<StackExchange.Redis.ChannelMessage>! handler) -> void\nStackExchange.Redis.ChannelMessageQueue.OnMessage(System.Func<StackExchange.Redis.ChannelMessage, System.Threading.Tasks.Task!>! handler) -> void\nStackExchange.Redis.ChannelMessageQueue.ReadAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) -> System.Threading.Tasks.ValueTask<StackExchange.Redis.ChannelMessage>\nStackExchange.Redis.ChannelMessageQueue.TryGetCount(out int count) -> bool\nStackExchange.Redis.ChannelMessageQueue.TryRead(out StackExchange.Redis.ChannelMessage item) -> bool\nStackExchange.Redis.ChannelMessageQueue.Unsubscribe(StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> void\nStackExchange.Redis.ChannelMessageQueue.UnsubscribeAsync(StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: RedisValue Implicit Conversions in C#\nDESCRIPTION: Defines implicit conversion operators to RedisValue from various data types, including bool, byte[], double, int, long, string, and Memory<byte>. Also includes conversions from RedisValue to byte[]?, string?, and ReadOnlyMemory<byte>.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.RedisValue.implicit operator byte[]?(StackExchange.Redis.RedisValue value) -> byte[]?\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(bool value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(bool? value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(byte[]? value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(double value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(double? value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(int value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(int? value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(long value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(long? value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(string? value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(System.Memory<byte> value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(System.ReadOnlyMemory<byte> value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(uint value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(uint? value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(ulong value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator StackExchange.Redis.RedisValue(ulong? value) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.implicit operator string?(StackExchange.Redis.RedisValue value) -> string?\nstatic StackExchange.Redis.RedisValue.implicit operator System.ReadOnlyMemory<byte>(StackExchange.Redis.RedisValue value) -> System.ReadOnlyMemory<byte>\n```\n\n----------------------------------------\n\nTITLE: Redis Transaction Interface Methods\nDESCRIPTION: Interface definitions for Redis transaction operations including execution and condition handling.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ITransaction.AddCondition(StackExchange.Redis.Condition! condition) -> StackExchange.Redis.ConditionResult!\nStackExchange.Redis.ITransaction.Execute(StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> bool\nStackExchange.Redis.ITransaction.ExecuteAsync(StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task<bool>!\n```\n\n----------------------------------------\n\nTITLE: Redis Lua Scripting Example\nDESCRIPTION: A Lua script for Redis that checks if a hash field exists and sets it if it doesn't exist, all in a single atomic operation.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Transactions.md#2025-04-23_snippet_4\n\nLANGUAGE: lua\nCODE:\n```\nEVAL \"if redis.call('hexists', KEYS[1], 'UniqueId') then return redis.call('hset', KEYS[1], 'UniqueId', ARGV[1]) else return 0 end\" 1 {custKey} {newId}\n```\n\n----------------------------------------\n\nTITLE: RedisKey Methods and Operators in StackExchange.Redis\nDESCRIPTION: Methods and operators for RedisKey, including implicit conversions between RedisKey and string/byte[], equality comparisons, and concatenation operations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_63\n\nLANGUAGE: csharp\nCODE:\n```\nstatic StackExchange.Redis.RedisKey.implicit operator byte[]?(StackExchange.Redis.RedisKey key) -> byte[]?\nstatic StackExchange.Redis.RedisKey.implicit operator StackExchange.Redis.RedisKey(byte[]? key) -> StackExchange.Redis.RedisKey\nstatic StackExchange.Redis.RedisKey.implicit operator StackExchange.Redis.RedisKey(string? key) -> StackExchange.Redis.RedisKey\nstatic StackExchange.Redis.RedisKey.implicit operator string?(StackExchange.Redis.RedisKey key) -> string?\nstatic StackExchange.Redis.RedisKey.operator !=(byte[]! x, StackExchange.Redis.RedisKey y) -> bool\nstatic StackExchange.Redis.RedisKey.operator !=(StackExchange.Redis.RedisKey x, byte[]! y) -> bool\nstatic StackExchange.Redis.RedisKey.operator !=(StackExchange.Redis.RedisKey x, StackExchange.Redis.RedisKey y) -> bool\nstatic StackExchange.Redis.RedisKey.operator !=(StackExchange.Redis.RedisKey x, string! y) -> bool\nstatic StackExchange.Redis.RedisKey.operator !=(string! x, StackExchange.Redis.RedisKey y) -> bool\nstatic StackExchange.Redis.RedisKey.operator +(StackExchange.Redis.RedisKey x, StackExchange.Redis.RedisKey y) -> StackExchange.Redis.RedisKey\nstatic StackExchange.Redis.RedisKey.operator ==(byte[]! x, StackExchange.Redis.RedisKey y) -> bool\nstatic StackExchange.Redis.RedisKey.operator ==(StackExchange.Redis.RedisKey x, byte[]! y) -> bool\nstatic StackExchange.Redis.RedisKey.operator ==(StackExchange.Redis.RedisKey x, StackExchange.Redis.RedisKey y) -> bool\nstatic StackExchange.Redis.RedisKey.operator ==(StackExchange.Redis.RedisKey x, string! y) -> bool\nstatic StackExchange.Redis.RedisKey.operator ==(string! x, StackExchange.Redis.RedisKey y) -> bool\n```\n\n----------------------------------------\n\nTITLE: NameValueEntry Operators and Conversions in StackExchange.Redis\nDESCRIPTION: Operator overloads and implicit conversion methods for NameValueEntry, allowing conversion between NameValueEntry and KeyValuePair<RedisValue, RedisValue>, and equality comparisons.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_60\n\nLANGUAGE: csharp\nCODE:\n```\nstatic StackExchange.Redis.NameValueEntry.implicit operator StackExchange.Redis.NameValueEntry(System.Collections.Generic.KeyValuePair<StackExchange.Redis.RedisValue, StackExchange.Redis.RedisValue> value) -> StackExchange.Redis.NameValueEntry\nstatic StackExchange.Redis.NameValueEntry.implicit operator System.Collections.Generic.KeyValuePair<StackExchange.Redis.RedisValue, StackExchange.Redis.RedisValue>(StackExchange.Redis.NameValueEntry value) -> System.Collections.Generic.KeyValuePair<StackExchange.Redis.RedisValue, StackExchange.Redis.RedisValue>\nstatic StackExchange.Redis.NameValueEntry.operator !=(StackExchange.Redis.NameValueEntry x, StackExchange.Redis.NameValueEntry y) -> bool\nstatic StackExchange.Redis.NameValueEntry.operator ==(StackExchange.Redis.NameValueEntry x, StackExchange.Redis.NameValueEntry y) -> bool\n```\n\n----------------------------------------\n\nTITLE: Accessing and Setting SslClientAuthenticationOptions in StackExchange.Redis ConfigurationOptions\nDESCRIPTION: Property getter and setter for SslClientAuthenticationOptions, which returns a function that accepts a string parameter and returns an SslClientAuthenticationOptions object.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/net8.0/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nStackExchange.Redis.ConfigurationOptions.SslClientAuthenticationOptions.get -> System.Func<string!, System.Net.Security.SslClientAuthenticationOptions!>?\n```\n\nLANGUAGE: csharp\nCODE:\n```\nStackExchange.Redis.ConfigurationOptions.SslClientAuthenticationOptions.set -> void\n```\n\n----------------------------------------\n\nTITLE: Redis Stream and Socket Manager Operations in C#\nDESCRIPTION: Defines static properties and methods for various Redis stream-related types and SocketManager.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.SocketManager.Shared.get -> StackExchange.Redis.SocketManager!\nstatic StackExchange.Redis.SocketManager.ThreadPool.get -> StackExchange.Redis.SocketManager!\nstatic StackExchange.Redis.SortedSetPopResult.Null.get -> StackExchange.Redis.SortedSetPopResult\nstatic StackExchange.Redis.StreamAutoClaimIdsOnlyResult.Null.get -> StackExchange.Redis.StreamAutoClaimIdsOnlyResult\nstatic StackExchange.Redis.StreamAutoClaimResult.Null.get -> StackExchange.Redis.StreamAutoClaimResult\nstatic StackExchange.Redis.StreamEntry.Null.get -> StackExchange.Redis.StreamEntry\nstatic StackExchange.Redis.StreamPosition.Beginning.get -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.StreamPosition.NewMessages.get -> StackExchange.Redis.RedisValue\n```\n\n----------------------------------------\n\nTITLE: RedisResult Methods and Operators in StackExchange.Redis\nDESCRIPTION: Static methods and explicit conversion operators for RedisResult, enabling creation of RedisResult objects from various Redis data types and converting RedisResult to primitive types and Redis-specific types.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_64\n\nLANGUAGE: csharp\nCODE:\n```\nstatic StackExchange.Redis.RedisResult.Create(StackExchange.Redis.RedisChannel channel) -> StackExchange.Redis.RedisResult!\nstatic StackExchange.Redis.RedisResult.Create(StackExchange.Redis.RedisKey key) -> StackExchange.Redis.RedisResult!\nstatic StackExchange.Redis.RedisResult.Create(StackExchange.Redis.RedisResult![]! values) -> StackExchange.Redis.RedisResult!\nstatic StackExchange.Redis.RedisResult.Create(StackExchange.Redis.RedisValue value, StackExchange.Redis.ResultType? resultType = null) -> StackExchange.Redis.RedisResult!\nstatic StackExchange.Redis.RedisResult.Create(StackExchange.Redis.RedisValue[]! values) -> StackExchange.Redis.RedisResult!\nstatic StackExchange.Redis.RedisResult.explicit operator bool(StackExchange.Redis.RedisResult! result) -> bool\nstatic StackExchange.Redis.RedisResult.explicit operator bool?(StackExchange.Redis.RedisResult? result) -> bool?\nstatic StackExchange.Redis.RedisResult.explicit operator bool[]?(StackExchange.Redis.RedisResult? result) -> bool[]?\nstatic StackExchange.Redis.RedisResult.explicit operator byte[]?(StackExchange.Redis.RedisResult? result) -> byte[]?\nstatic StackExchange.Redis.RedisResult.explicit operator byte[]?[]?(StackExchange.Redis.RedisResult? result) -> byte[]?[]?\nstatic StackExchange.Redis.RedisResult.explicit operator double(StackExchange.Redis.RedisResult! result) -> double\nstatic StackExchange.Redis.RedisResult.explicit operator double?(StackExchange.Redis.RedisResult? result) -> double?\nstatic StackExchange.Redis.RedisResult.explicit operator double[]?(StackExchange.Redis.RedisResult? result) -> double[]?\nstatic StackExchange.Redis.RedisResult.explicit operator int(StackExchange.Redis.RedisResult! result) -> int\nstatic StackExchange.Redis.RedisResult.explicit operator int?(StackExchange.Redis.RedisResult? result) -> int?\nstatic StackExchange.Redis.RedisResult.explicit operator int[]?(StackExchange.Redis.RedisResult? result) -> int[]?\nstatic StackExchange.Redis.RedisResult.explicit operator long(StackExchange.Redis.RedisResult! result) -> long\nstatic StackExchange.Redis.RedisResult.explicit operator long?(StackExchange.Redis.RedisResult? result) -> long?\nstatic StackExchange.Redis.RedisResult.explicit operator long[]?(StackExchange.Redis.RedisResult? result) -> long[]?\nstatic StackExchange.Redis.RedisResult.explicit operator StackExchange.Redis.RedisKey(StackExchange.Redis.RedisResult? result) -> StackExchange.Redis.RedisKey\nstatic StackExchange.Redis.RedisResult.explicit operator StackExchange.Redis.RedisKey[]?(StackExchange.Redis.RedisResult? result) -> StackExchange.Redis.RedisKey[]?\nstatic StackExchange.Redis.RedisResult.explicit operator StackExchange.Redis.RedisResult![]?(StackExchange.Redis.RedisResult? result) -> StackExchange.Redis.RedisResult![]?\nstatic StackExchange.Redis.RedisResult.explicit operator StackExchange.Redis.RedisValue(StackExchange.Redis.RedisResult? result) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisResult.explicit operator StackExchange.Redis.RedisValue[]?(StackExchange.Redis.RedisResult? result) -> StackExchange.Redis.RedisValue[]?\nstatic StackExchange.Redis.RedisResult.explicit operator string?(StackExchange.Redis.RedisResult? result) -> string?\nstatic StackExchange.Redis.RedisResult.explicit operator string?[]?(StackExchange.Redis.RedisResult? result) -> string?[]?\nstatic StackExchange.Redis.RedisResult.explicit operator ulong(StackExchange.Redis.RedisResult! result) -> ulong\nstatic StackExchange.Redis.RedisResult.explicit operator ulong?(StackExchange.Redis.RedisResult? result) -> ulong?\nstatic StackExchange.Redis.RedisResult.explicit operator ulong[]?(StackExchange.Redis.RedisResult? result) -> ulong[]?\n```\n\n----------------------------------------\n\nTITLE: Setting User PEM Certificate in StackExchange.Redis ConfigurationOptions\nDESCRIPTION: Method to configure user PEM certificates for SSL authentication, taking a required certificate path and an optional key path.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/net8.0/PublicAPI.Shipped.txt#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nStackExchange.Redis.ConfigurationOptions.SetUserPemCertificate(string! userCertificatePath, string? userKeyPath = null) -> void\n```\n\n----------------------------------------\n\nTITLE: Redis HyperLogLog Operations - C# Method Signatures\nDESCRIPTION: Method signatures for Redis HyperLogLog operations including add, length calculation, and merge operations for probabilistic cardinality estimation.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nIDatabase.HyperLogLogAdd(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None) -> bool\nIDatabase.HyperLogLogLength(RedisKey key, CommandFlags flags = CommandFlags.None) -> long\nIDatabase.HyperLogLogMerge(RedisKey destination, RedisKey first, RedisKey second, CommandFlags flags = CommandFlags.None) -> void\n```\n\n----------------------------------------\n\nTITLE: RedisValue Methods and Operators in StackExchange.Redis\nDESCRIPTION: Static methods and explicit conversion operators for RedisValue, including creating RedisValue from streams and converting RedisValue to various primitive types.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_65\n\nLANGUAGE: csharp\nCODE:\n```\nstatic StackExchange.Redis.RedisValue.CreateFrom(System.IO.MemoryStream! stream) -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.EmptyString.get -> StackExchange.Redis.RedisValue\nstatic StackExchange.Redis.RedisValue.explicit operator bool(StackExchange.Redis.RedisValue value) -> bool\nstatic StackExchange.Redis.RedisValue.explicit operator bool?(StackExchange.Redis.RedisValue value) -> bool?\nstatic StackExchange.Redis.RedisValue.explicit operator decimal(StackExchange.Redis.RedisValue value) -> decimal\nstatic StackExchange.Redis.RedisValue.explicit operator decimal?(StackExchange.Redis.RedisValue value) -> decimal?\nstatic StackExchange.Redis.RedisValue.explicit operator double(StackExchange.Redis.RedisValue value) -> double\nstatic StackExchange.Redis.RedisValue.explicit operator double?(StackExchange.Redis.RedisValue value) -> double?\nstatic StackExchange.Redis.RedisValue.explicit operator float(StackExchange.Redis.RedisValue value) -> float\nstatic StackExchange.Redis.RedisValue.explicit operator float?(StackExchange.Redis.RedisValue value) -> float?\n```\n\n----------------------------------------\n\nTITLE: Declaring SSL Client Authentication Options Properties\nDESCRIPTION: Defines property accessors for SSL client authentication configuration in StackExchange.Redis. The property uses a Func delegate that takes a string parameter and returns SslClientAuthenticationOptions object.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/netcoreapp3.1/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ConfigurationOptions.SslClientAuthenticationOptions.get -> System.Func<string!, System.Net.Security.SslClientAuthenticationOptions!>?\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ConfigurationOptions.SslClientAuthenticationOptions.set -> void\n```\n\n----------------------------------------\n\nTITLE: Hash Field Expiration Management in StackExchange.Redis\nDESCRIPTION: Methods for managing hash field expiration times including setting expiry, retrieving time-to-live, and persistence operations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\nTask<ExpireResult[]> HashFieldExpireAsync(RedisKey key, RedisValue[] hashFields, DateTime expiry, ExpireWhen when = ExpireWhen.Always, CommandFlags flags = CommandFlags.None);\nTask<long[]> HashFieldGetTimeToLiveAsync(RedisKey key, RedisValue[] hashFields, CommandFlags flags = CommandFlags.None);\n```\n\n----------------------------------------\n\nTITLE: HyperLogLog Operations in StackExchange.Redis\nDESCRIPTION: Async methods for HyperLogLog operations including adding values and calculating cardinality estimates.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nTask<bool> HyperLogLogAddAsync(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None);\nTask<long> HyperLogLogLengthAsync(RedisKey key, CommandFlags flags = CommandFlags.None);\nTask<long> HyperLogLogLengthAsync(RedisKey[] keys, CommandFlags flags = CommandFlags.None);\n```\n\n----------------------------------------\n\nTITLE: RedisChannel Methods and Operators in StackExchange.Redis\nDESCRIPTION: Methods and operators for RedisChannel, including implicit conversions between RedisChannel and string/byte[], comparison operators, and methods to create literal and pattern channels.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_61\n\nLANGUAGE: csharp\nCODE:\n```\nstatic StackExchange.Redis.RedisChannel.implicit operator byte[]?(StackExchange.Redis.RedisChannel key) -> byte[]?\nstatic StackExchange.Redis.RedisChannel.implicit operator StackExchange.Redis.RedisChannel(byte[]? key) -> StackExchange.Redis.RedisChannel\nstatic StackExchange.Redis.RedisChannel.implicit operator StackExchange.Redis.RedisChannel(string! key) -> StackExchange.Redis.RedisChannel\nstatic StackExchange.Redis.RedisChannel.implicit operator string?(StackExchange.Redis.RedisChannel key) -> string?\nstatic StackExchange.Redis.RedisChannel.Literal(byte[]! value) -> StackExchange.Redis.RedisChannel\nstatic StackExchange.Redis.RedisChannel.Literal(string! value) -> StackExchange.Redis.RedisChannel\nstatic StackExchange.Redis.RedisChannel.operator !=(byte[]! x, StackExchange.Redis.RedisChannel y) -> bool\nstatic StackExchange.Redis.RedisChannel.operator !=(StackExchange.Redis.RedisChannel x, byte[]! y) -> bool\nstatic StackExchange.Redis.RedisChannel.operator !=(StackExchange.Redis.RedisChannel x, StackExchange.Redis.RedisChannel y) -> bool\nstatic StackExchange.Redis.RedisChannel.operator !=(StackExchange.Redis.RedisChannel x, string! y) -> bool\nstatic StackExchange.Redis.RedisChannel.operator !=(string! x, StackExchange.Redis.RedisChannel y) -> bool\nstatic StackExchange.Redis.RedisChannel.operator ==(byte[]! x, StackExchange.Redis.RedisChannel y) -> bool\nstatic StackExchange.Redis.RedisChannel.operator ==(StackExchange.Redis.RedisChannel x, byte[]! y) -> bool\nstatic StackExchange.Redis.RedisChannel.operator ==(StackExchange.Redis.RedisChannel x, StackExchange.Redis.RedisChannel y) -> bool\nstatic StackExchange.Redis.RedisChannel.operator ==(StackExchange.Redis.RedisChannel x, string! y) -> bool\nstatic StackExchange.Redis.RedisChannel.operator ==(string! x, StackExchange.Redis.RedisChannel y) -> bool\nstatic StackExchange.Redis.RedisChannel.Pattern(byte[]! value) -> StackExchange.Redis.RedisChannel\nstatic StackExchange.Redis.RedisChannel.Pattern(string! value) -> StackExchange.Redis.RedisChannel\nstatic StackExchange.Redis.RedisChannel.UseImplicitAutoPattern.get -> bool\nstatic StackExchange.Redis.RedisChannel.UseImplicitAutoPattern.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining HyperLogLog Merge Methods in C# for Redis\nDESCRIPTION: Defines two asynchronous methods for merging HyperLogLog structures in Redis. These methods allow combining HyperLogLog structures from different keys into a destination key.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.HyperLogLogMergeAsync(StackExchange.Redis.RedisKey destination, StackExchange.Redis.RedisKey first, StackExchange.Redis.RedisKey second, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task!\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabaseAsync.HyperLogLogMergeAsync(StackExchange.Redis.RedisKey destination, StackExchange.Redis.RedisKey[]! sourceKeys, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Threading.Tasks.Task!\n```\n\n----------------------------------------\n\nTITLE: Stream Operations in StackExchange.Redis IDatabase Interface\nDESCRIPTION: This snippet shows method signatures for stream-related operations in Redis using the StackExchange.Redis library. It includes methods for acknowledging messages in a stream.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IDatabase.StreamAcknowledge(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue messageId, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\nStackExchange.Redis.IDatabase.StreamAcknowledge(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue groupName, StackExchange.Redis.RedisValue[]! messageIds, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> long\n```\n\n----------------------------------------\n\nTITLE: Enabling Thread Theft Prevention in StackExchange.Redis with C#\nDESCRIPTION: A code snippet that shows how to set a feature flag early in application startup to prevent thread theft issues in StackExchange.Redis. This is the recommended solution for users experiencing thread theft-related exceptions.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ThreadTheft.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nConnectionMultiplexer.SetFeatureFlag(\"preventthreadtheft\", true);\n```\n\n----------------------------------------\n\nTITLE: Disabling Task-Friendly SynchronizationContext in ASP.NET Web.config\nDESCRIPTION: Configuration that explicitly disables the task-friendly SynchronizationContext in ASP.NET, which can lead to thread theft issues with StackExchange.Redis. This setting causes ASP.NET to use LegacyAspNetSynchronizationContext.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ThreadTheft.md#2025-04-23_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<add key=\"aspnet:UseTaskFriendlySynchronizationContext\" value=\"false\" />\n```\n\n----------------------------------------\n\nTITLE: Redis Configuration Interface Methods\nDESCRIPTION: Interface methods for Redis configuration management including getting and setting config values. These methods are part of the IServer interface.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.IServer.ConfigGet(StackExchange.Redis.RedisValue pattern = default(StackExchange.Redis.RedisValue), StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> System.Collections.Generic.KeyValuePair<string!, string!>[]!\nStackExchange.Redis.IServer.ConfigSet(StackExchange.Redis.RedisValue setting, StackExchange.Redis.RedisValue value, StackExchange.Redis.CommandFlags flags = StackExchange.Redis.CommandFlags.None) -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing AsyncLocal Profiler for StackExchange.Redis\nDESCRIPTION: This snippet demonstrates how to create an AsyncLocal profiler that automatically creates and manages profiling sessions across async contexts. It uses AsyncLocal<T> to maintain session state and provides a method to retrieve the current session.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Profiling_v2.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass AsyncLocalProfiler\n{\n    private readonly AsyncLocal<ProfilingSession> perThreadSession = new AsyncLocal<ProfilingSession>();\n\n    public ProfilingSession GetSession()\n    {\n        var val = perThreadSession.Value;\n        if (val == null)\n        {\n            perThreadSession.Value = val = new ProfilingSession();\n        }\n        return val;\n    }\n}\n...\nvar profiler = new AsyncLocalProfiler();\nmultiplexer.RegisterProfiler(profiler.GetSession);\n```\n\n----------------------------------------\n\nTITLE: Configuration String Parsing\nDESCRIPTION: Demonstrates converting between string and ConfigurationOptions representations.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nConfigurationOptions options = ConfigurationOptions.Parse(configString);\n```\n\nLANGUAGE: csharp\nCODE:\n```\nstring configString = options.ToString();\n```\n\n----------------------------------------\n\nTITLE: Redis Latency Tracking Classes\nDESCRIPTION: Class definitions for tracking Redis operation latency including history and latest entry information.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.LatencyHistoryEntry.DurationMilliseconds.get -> int\nStackExchange.Redis.LatencyHistoryEntry.Timestamp.get -> System.DateTime\nStackExchange.Redis.LatencyLatestEntry.EventName.get -> string!\nStackExchange.Redis.LatencyLatestEntry.MaxDurationMilliseconds.get -> int\n```\n\n----------------------------------------\n\nTITLE: Configuring Envoyproxy Support\nDESCRIPTION: Shows configuration for using StackExchange.Redis with Envoyproxy for cluster management and fault tolerance.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Configuration.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = new ConfigurationOptions+{\n    EndPoints = { \"my-proxy1\", \"my-proxy2\", \"my-proxy3\" },\n    Proxy = Proxy.Envoyproxy\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Redis Conditions in C#\nDESCRIPTION: This snippet shows various static methods for creating Redis conditions, such as checking sorted set lengths, stream lengths, and string comparisons. These methods return StackExchange.Redis.Condition objects.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.Condition.SortedSetLengthLessThan(StackExchange.Redis.RedisKey key, long length, double min = -Infinity, double max = Infinity) -> StackExchange.Redis.Condition!\nstatic StackExchange.Redis.Condition.SortedSetNotContains(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue member) -> StackExchange.Redis.Condition!\nstatic StackExchange.Redis.Condition.StreamLengthEqual(StackExchange.Redis.RedisKey key, long length) -> StackExchange.Redis.Condition!\nstatic StackExchange.Redis.Condition.StringEqual(StackExchange.Redis.RedisKey key, StackExchange.Redis.RedisValue value) -> StackExchange.Redis.Condition!\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Settings in JSON for StackExchange.Redis Tests\nDESCRIPTION: Example of a TestConfig.json file used to override default test settings such as server IP, port, and whether to run long-running tests. This configuration allows for testing different environments and scenarios.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Testing.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"RunLongRunning\": true,\n  \"PrimaryServer\": \"192.168.0.42\",\n  \"PrimaryPort\": 12345\n}\n```\n\n----------------------------------------\n\nTITLE: SSL Configuration Property and Certificate Methods for StackExchange.Redis in C#\nDESCRIPTION: Defines API methods for configuring SSL client authentication in StackExchange.Redis. Includes getter and setter for SslClientAuthenticationOptions property and a method for setting PEM certificates.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/net6.0/PublicAPI.Shipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ConfigurationOptions.SslClientAuthenticationOptions.get -> System.Func<string!, System.Net.Security.SslClientAuthenticationOptions!>?\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ConfigurationOptions.SslClientAuthenticationOptions.set -> void\n```\n\nLANGUAGE: C#\nCODE:\n```\nSystem.Runtime.CompilerServices.IsExternalInit (forwarded, contained in System.Runtime)\n```\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ConfigurationOptions.SetUserPemCertificate(string! userCertificatePath, string? userKeyPath = null) -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Redis Client Information in C#\nDESCRIPTION: This snippet declares the ClientInfo class, which represents information about a Redis client connection. It includes properties for client identification, connection details, and operational flags.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ClientInfo\nStackExchange.Redis.ClientInfo.Address.get -> System.Net.EndPoint?\nStackExchange.Redis.ClientInfo.AgeSeconds.get -> int\nStackExchange.Redis.ClientInfo.ClientInfo() -> void\nStackExchange.Redis.ClientInfo.ClientType.get -> StackExchange.Redis.ClientType\nStackExchange.Redis.ClientInfo.Database.get -> int\nStackExchange.Redis.ClientInfo.Flags.get -> StackExchange.Redis.ClientFlags\nStackExchange.Redis.ClientInfo.FlagsRaw.get -> string?\nStackExchange.Redis.ClientInfo.Host.get -> string?\nStackExchange.Redis.ClientInfo.Id.get -> long\nStackExchange.Redis.ClientInfo.IdleSeconds.get -> int\nStackExchange.Redis.ClientInfo.LastCommand.get -> string?\nStackExchange.Redis.ClientInfo.LibraryName.get -> string?\nStackExchange.Redis.ClientInfo.LibraryVersion.get -> string?\nStackExchange.Redis.ClientInfo.Name.get -> string?\nStackExchange.Redis.ClientInfo.PatternSubscriptionCount.get -> int\nStackExchange.Redis.ClientInfo.Port.get -> int\nStackExchange.Redis.ClientInfo.ProtocolVersion.get -> string?\nStackExchange.Redis.ClientInfo.Raw.get -> string?\nStackExchange.Redis.ClientInfo.SubscriptionCount.get -> int\nStackExchange.Redis.ClientInfo.TransactionCommandLength.get -> int\n```\n\n----------------------------------------\n\nTITLE: Handling ServerMaintenanceEvent in C# with StackExchange.Redis\nDESCRIPTION: This snippet demonstrates how to subscribe to and handle ServerMaintenanceEvents in a C# application using StackExchange.Redis. It shows how to check for specific event types and take appropriate action.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ServerMaintenanceEvent.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nmultiplexer.ServerMaintenanceEvent += (object sender, ServerMaintenanceEvent e) =>\n{\n    if (e is AzureMaintenanceEvent azureEvent && azureEvent.NotificationType == AzureNotificationType.NodeMaintenanceStart)\n    {\n        // Take whatever action is appropriate for your application to handle the maintenance operation gracefully. \n        // This might mean writing a log entry, redirecting traffic away from the impacted Redis server, or\n        // something entirely different.\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: DefaultOptionsProvider Virtual Methods in C#\nDESCRIPTION: Defines virtual methods for the DefaultOptionsProvider class, which provides default configuration options for Redis connections.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.AbortOnConnectFail.get -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.AfterConnectAsync(StackExchange.Redis.ConnectionMultiplexer! multiplexer, System.Action<string!>! log) -> System.Threading.Tasks.Task!\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.AllowAdmin.get -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.BacklogPolicy.get -> StackExchange.Redis.BacklogPolicy!\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.CheckCertificateRevocation.get -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.CommandMap.get -> StackExchange.Redis.CommandMap?\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.ConfigCheckInterval.get -> System.TimeSpan\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.ConfigurationChannel.get -> string!\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.ConnectRetry.get -> int\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.ConnectTimeout.get -> System.TimeSpan?\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.DefaultVersion.get -> System.Version!\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.GetDefaultClientName() -> string!\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.GetDefaultSsl(StackExchange.Redis.EndPointCollection! endPoints) -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.GetSslHostFromEndpoints(StackExchange.Redis.EndPointCollection! endPoints) -> string?\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.HeartbeatConsistencyChecks.get -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.HeartbeatInterval.get -> System.TimeSpan\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.HighIntegrity.get -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.IncludeDetailInExceptions.get -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.IncludePerformanceCountersInExceptions.get -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.IsMatch(System.Net.EndPoint! endpoint) -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.KeepAliveInterval.get -> System.TimeSpan\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.LibraryName.get -> string!\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.LoggerFactory.get -> Microsoft.Extensions.Logging.ILoggerFactory?\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.Password.get -> string?\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.Proxy.get -> StackExchange.Redis.Proxy\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.ReconnectRetryPolicy.get -> StackExchange.Redis.IReconnectRetryPolicy?\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.ResolveDns.get -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.SetClientLibrary.get -> bool\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.SyncTimeout.get -> System.TimeSpan\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.TieBreaker.get -> string!\nvirtual StackExchange.Redis.Configuration.DefaultOptionsProvider.User.get -> string?\n```\n\n----------------------------------------\n\nTITLE: Redis Transaction with WATCH/UNWATCH Example\nDESCRIPTION: Lua pseudo-code demonstrating how to implement a transaction in Redis using WATCH to monitor keys for changes before executing the transaction.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Transactions.md#2025-04-23_snippet_1\n\nLANGUAGE: lua\nCODE:\n```\nWATCH {custKey}\nHEXISTS {custKey} \"UniqueId\"\n-- (check the reply, then either:)\nMULTI\nHSET {custKey} \"UniqueId\" {newId}\nEXEC\n-- (or, if we find there was already an unique-id:)\nUNWATCH\n```\n\n----------------------------------------\n\nTITLE: Traditional SQL Transaction Example (Pseudo-code)\nDESCRIPTION: Illustrative pseudo-code showing how a transaction would work in a traditional SQL database, assigning a unique ID only if one doesn't already exist.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Transactions.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// assign a new unique id only if they don't already\n// have one, in a transaction to ensure no thread-races\nvar newId = CreateNewUniqueID(); // optimistic\nusing(var tran = conn.BeginTran())\n{\n\tvar cust = GetCustomer(conn, custId, tran);\n\tvar uniqueId = cust.UniqueID;\n\tif(uniqueId == null)\n\t{\n\t\tcust.UniqueId = newId;\n\t\tSaveCustomer(conn, cust, tran);\n\t}\n\ttran.Complete();\n}\n```\n\n----------------------------------------\n\nTITLE: Running StackExchange.Redis Tests on Windows Command Line\nDESCRIPTION: Command to execute the build script on Windows, which includes running the tests as part of the build process. The -BuildNumber parameter is set to 'local' for local testing.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Testing.md#2025-04-23_snippet_1\n\nLANGUAGE: cmd\nCODE:\n```\n.\\build.cmd -BuildNumber local\n```\n\n----------------------------------------\n\nTITLE: RedisResult Access Members\nDESCRIPTION: Virtual members for accessing RedisResult data, including Length property and indexed access to result elements.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_75\n\nLANGUAGE: C#\nCODE:\n```\nvirtual StackExchange.Redis.RedisResult.Length.get -> int\nvirtual StackExchange.Redis.RedisResult.this[int index].get -> StackExchange.Redis.RedisResult!\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Connection Options in C#\nDESCRIPTION: This snippet shows methods for parsing and configuring Redis connection options. It includes methods to parse configuration strings and create ConfigurationOptions objects.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.ConfigurationOptions.Parse(string! configuration) -> StackExchange.Redis.ConfigurationOptions!\nstatic StackExchange.Redis.ConfigurationOptions.Parse(string! configuration, bool ignoreUnknown) -> StackExchange.Redis.ConfigurationOptions!\n```\n\n----------------------------------------\n\nTITLE: MVC5 Application Request Profiling Setup\nDESCRIPTION: Global.asax.cs implementation for starting and stopping Redis profiling for each HTTP request in an MVC5 application.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Profiling_v1.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nprotected void Application_BeginRequest()\n{\n    var ctxObj = RedisProfiler.CreateContextForCurrentRequest();\n    if (ctxObj != null)\n    {\n        RedisConnection.BeginProfiling(ctxObj);\n    }\n}\n\nprotected void Application_EndRequest()\n{\n    var ctxObj = RedisProfiler.GetContext();\n    if (ctxObj != null)\n    {\n        var timings = RedisConnection.FinishProfiling(ctxObj);\n\n\t\t// do what you will with `timings` here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Connection Configuration Methods\nDESCRIPTION: Configuration methods for Redis connections, including library name suffix addition and SSL certificate configuration for secure connections.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_76\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ConnectionMultiplexer.AddLibraryNameSuffix(string! suffix)\nStackExchange.Redis.IConnectionMultiplexer.AddLibraryNameSuffix(string! suffix)\nStackExchange.Redis.ConfigurationOptions.SetUserPfxCertificate(string! userCertificatePath, string? password = null)\n```\n\n----------------------------------------\n\nTITLE: Implementing Per-Thread Profiling for StackExchange.Redis\nDESCRIPTION: This snippet demonstrates how to implement per-thread profiling, where each thread has its own profiling session. It uses a ConcurrentDictionary to store profiling results for each thread, allowing for separate analysis of commands executed by different threads.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/Profiling_v2.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nConnectionMultiplexer conn = /* initialization */;\nvar profiler = new ToyProfiler();\n\nconn.RegisterProfiler(() => profiler.PerThreadSession);\n\nvar threads = new List<Thread>();\n\nvar perThreadTimings = new ConcurrentDictionary<Thread, List<IProfiledCommand>>();\n\nfor (var i = 0; i < 16; i++)\n{\n    var db = conn.GetDatabase(i);\n\n    var thread =\n        new Thread(\n            delegate()\n            {\n                var threadTasks = new List<Task>();\n                profiler.PerThreadSession = new ProfilingSession();\n\n                for (var j = 0; j < 1000; j++)\n                {\n                    var task = db.StringSetAsync(\"\" + j, \"\" + j);\n                    threadTasks.Add(task);\n                }\n\n                Task.WaitAll(threadTasks.ToArray());\n\n                perThreadTimings[Thread.CurrentThread] = profiler.PerThreadSession.FinishProfiling().ToList();\n            }\n        );\n    threads.Add(thread);\n}\n\nthreads.ForEach(thread => thread.Start());\nthreads.ForEach(thread => thread.Join());\n```\n\n----------------------------------------\n\nTITLE: Redis Geo-Location Classes\nDESCRIPTION: Class definitions for handling geographical data and operations in Redis, including position, entry, and search functionality\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\npublic struct GeoEntry {\n    public GeoEntry(double longitude, double latitude, RedisValue member);\n    public double Latitude { get; }\n    public double Longitude { get; }\n    public RedisValue Member { get; }\n    public GeoPosition Position { get; }\n}\n\npublic struct GeoPosition {\n    public GeoPosition(double longitude, double latitude);\n    public double Latitude { get; }\n    public double Longitude { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: External Initialization Support through IsExternalInit\nDESCRIPTION: Forwarded reference to System.Runtime.CompilerServices.IsExternalInit which enables init-only setters in C# 9.0 and later.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/net8.0/PublicAPI.Shipped.txt#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nSystem.Runtime.CompilerServices.IsExternalInit (forwarded, contained in System.Runtime)\n```\n\n----------------------------------------\n\nTITLE: Markdown Release Notes\nDESCRIPTION: Changelog entries documenting changes, bug fixes, and improvements in StackExchange.Redis versions 2.6.66 and 2.6.48.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ReleaseNotes.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## 2.6.66\n\n- Fix [#2182](https://github.com/StackExchange/StackExchange.Redis/issues/2182): Be more flexible in which commands are \"primary only\" in order to support users with replicas that are explicitly configured to allow writes ([#2183 by slorello89](https://github.com/StackExchange/StackExchange.Redis/pull/2183))\n- Adds: `IConnectionMultiplexer` now implements `IAsyncDisposable` ([#2161 by kimsey0](https://github.com/StackExchange/StackExchange.Redis/pull/2161))\n- Adds: `IConnectionMultiplexer.GetServers()` to get all `IServer` instances for a multiplexer ([#2203 by NickCraver](https://github.com/StackExchange/StackExchange.Redis/pull/2203))\n- Fix [#2016](https://github.com/StackExchange/StackExchange.Redis/issues/2016): Align server selection with supported commands (e.g. with writable servers) to reduce `Command cannot be issued to a replica` errors ([#2191 by slorello89](https://github.com/StackExchange/StackExchange.Redis/pull/2191))\n- Performance: Optimization around timeout processing to reduce lock contention in the case of many items that haven't yet timed out during a heartbeat ([#2217 by NickCraver](https://github.com/StackExchange/StackExchange.Redis/pull/2217))\n- Fix [#2223](https://github.com/StackExchange/StackExchange.Redis/issues/2223): Resolve sync-context issues (missing `ConfigureAwait(false)`) ([#2229 by mgravell](https://github.com/StackExchange/StackExchange.Redis/pull/2229))\n- Fix [#1968](https://github.com/StackExchange/StackExchange.Redis/issues/1968): Improved handling of EVAL scripts during server restarts and failovers, detecting and re-sending the script for a retry when needed ([#2170 by martintmk](https://github.com/StackExchange/StackExchange.Redis/pull/2170))\n- Adds: `ConfigurationOptions.SslClientAuthenticationOptions` (`netcoreapp3.1`/`net5.0`+ only) to give more control over SSL/TLS authentication ([#2224 by NickCraver](https://github.com/StackExchange/StackExchange.Redis/pull/2224))\n- Fix [#2240](https://github.com/StackExchange/StackExchange.Redis/pull/2241): Improve support for DNS-based IPv6 endpoints ([#2241 by NickCraver](https://github.com/StackExchange/StackExchange.Redis/pull/2241))\n- Adds: `ConfigurationOptions.HeartbeatInterval` (**Advanced Setting** - [see docs](https://stackexchange.github.io/StackExchange.Redis/Configuration#configuration-options)) To allow more finite control of the client heartbeat, which encompases how often command timeouts are actually evaluated - still defaults to 1,000 ms ([#2243 by NickCraver](https://github.com/StackExchange/StackExchange.Redis/pull/2243))\n- Fix [#1879](https://github.com/StackExchange/StackExchange.Redis/issues/1879): Improve exception message when the wrong password is used ([#2246 by NickCraver](https://github.com/StackExchange/StackExchange.Redis/pull/2246))\n- Fix [#2233](https://github.com/StackExchange/StackExchange.Redis/issues/2233): Repeated connection to Sentinel servers using the same ConfigurationOptions would fail ([#2242 by NickCraver](https://github.com/StackExchange/StackExchange.Redis/pull/2242))\n\n\n## 2.6.48\n\n- URGENT Fix: [#2167](https://github.com/StackExchange/StackExchange.Redis/issues/2167), [#2176](https://github.com/StackExchange/StackExchange.Redis/issues/2176): fix error in batch/transaction handling that can result in out-of-order instructions ([#2177 by mgravell](https://github.com/StackExchange/StackExchange.Redis/pull/2177))\n- Fix: [#2164](https://github.com/StackExchange/StackExchange.Redis/issues/2164): fix `LuaScript.Prepare` for scripts that don't have parameters ([#2166 by mgravell](https://github.com/StackExchange/StackExchange.Redis/pull/2166))\n```\n\n----------------------------------------\n\nTITLE: Cluster Configuration and Node Management\nDESCRIPTION: Classes and methods for managing Redis cluster configuration and node interactions\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ClusterConfiguration.GetBySlot(int slot) -> StackExchange.Redis.ClusterNode?\nStackExchange.Redis.ClusterConfiguration.GetBySlot(StackExchange.Redis.RedisKey key) -> StackExchange.Redis.ClusterNode?\nStackExchange.Redis.ClusterConfiguration.Nodes.get -> System.Collections.Generic.ICollection<StackExchange.Redis.ClusterNode!>!\n```\n\n----------------------------------------\n\nTITLE: Redis Type Operator Overloads in C#\nDESCRIPTION: This snippet defines operator overloads for Redis-specific types such as GeoEntry, GeoPosition, and HashEntry. These overloads provide equality comparisons and implicit conversions between Redis types and .NET types.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.GeoEntry.operator !=(StackExchange.Redis.GeoEntry x, StackExchange.Redis.GeoEntry y) -> bool\nstatic StackExchange.Redis.GeoEntry.operator ==(StackExchange.Redis.GeoEntry x, StackExchange.Redis.GeoEntry y) -> bool\nstatic StackExchange.Redis.HashEntry.implicit operator StackExchange.Redis.HashEntry(System.Collections.Generic.KeyValuePair<StackExchange.Redis.RedisValue, StackExchange.Redis.RedisValue> value) -> StackExchange.Redis.HashEntry\n```\n\n----------------------------------------\n\nTITLE: Implementing ZRANDMEMBER Command Support in C#\nDESCRIPTION: Adds support for the Redis ZRANDMEMBER command with new methods for retrieving random members from sorted sets, including options for returning scores.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ReleaseNotes.md#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\n// Usage examples:\nvar randomMember = await db.SortedSetRandomMemberAsync(\"mySortedSet\");\nvar randomMembers = await db.SortedSetRandomMembersAsync(\"mySortedSet\", 5);\nvar randomMembersWithScores = await db.SortedSetRandomMembersWithScoresAsync(\"mySortedSet\", 3);\n```\n\n----------------------------------------\n\nTITLE: Command Flags Enumeration\nDESCRIPTION: Enumeration of command flags used to control Redis command behavior and routing preferences\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.CommandFlags.DemandMaster = 4 -> StackExchange.Redis.CommandFlags\nStackExchange.Redis.CommandFlags.FireAndForget = 2 -> StackExchange.Redis.CommandFlags\nStackExchange.Redis.CommandFlags.HighPriority = 1 -> StackExchange.Redis.CommandFlags\nStackExchange.Redis.CommandFlags.None = 0 -> StackExchange.Redis.CommandFlags\n```\n\n----------------------------------------\n\nTITLE: Redis Result and Protocol-related Operations in C#\nDESCRIPTION: Defines methods and properties related to RedisResult, Role, ClientInfo, ConfigurationOptions, and RedisProtocol.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_72\n\nLANGUAGE: C#\nCODE:\n```\nabstract StackExchange.Redis.RedisResult.ToString(out string? type) -> string?\noverride sealed StackExchange.Redis.RedisResult.ToString() -> string!\noverride StackExchange.Redis.Role.Master.Replica.ToString() -> string!\nStackExchange.Redis.ClientInfo.Protocol.get -> StackExchange.Redis.RedisProtocol?\nStackExchange.Redis.ConfigurationOptions.Protocol.get -> StackExchange.Redis.RedisProtocol?\nStackExchange.Redis.ConfigurationOptions.Protocol.set -> void\nStackExchange.Redis.IServer.Protocol.get -> StackExchange.Redis.RedisProtocol\nStackExchange.Redis.RedisFeatures.ClientId.get -> bool\nStackExchange.Redis.RedisFeatures.Equals(StackExchange.Redis.RedisFeatures other) -> bool\nStackExchange.Redis.RedisFeatures.Resp3.get -> bool\nStackExchange.Redis.RedisProtocol\nStackExchange.Redis.RedisProtocol.Resp2 = 20000 -> StackExchange.Redis.RedisProtocol\n```\n\n----------------------------------------\n\nTITLE: StackExchange.Redis Version History Documentation\nDESCRIPTION: Markdown formatted changelog documenting version history from 2.1.55 to 2.5.43, including feature additions, bug fixes, performance improvements and stability enhancements\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ReleaseNotes.md#2025-04-23_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n## 2.5.43\n\n- Adds: Bounds checking for `ExponentialRetry` backoff policy\n- Adds: `DefaultOptionsProvider` support\n- Adds: Envoy proxy support\n- Performance: When `SUBSCRIBE` is disabled, give proper errors and connect faster\n- Adds: `GET` on `SET` command support\n- Performance: Improves concurrent load performance when backlogs are utilized\n- Stability: Improves cluster connections when `CLUSTER` command is disabled\n- Logging: Improves connection logging and adds overall timing\n```\n\n----------------------------------------\n\nTITLE: Client Type Enumeration\nDESCRIPTION: Enumeration defining different types of Redis clients including Normal, PubSub, and Replica/Slave types\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ClientType.Normal = 0 -> StackExchange.Redis.ClientType\nStackExchange.Redis.ClientType.PubSub = 2 -> StackExchange.Redis.ClientType\nStackExchange.Redis.ClientType.Replica = 1 -> StackExchange.Redis.ClientType\nStackExchange.Redis.ClientType.Slave = 1 -> StackExchange.Redis.ClientType\n```\n\n----------------------------------------\n\nTITLE: Client Kill Filter Properties and Methods\nDESCRIPTION: API definitions for StackExchange.Redis.ClientKillFilter class including property getters and filter methods for managing Redis client connections\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.ClientKillFilter.Id.get -> long?\nStackExchange.Redis.ClientKillFilter.MaxAgeInSeconds.get -> long?\nStackExchange.Redis.ClientKillFilter.ServerEndpoint.get -> System.Net.EndPoint?\nStackExchange.Redis.ClientKillFilter.SkipMe.get -> bool?\nStackExchange.Redis.ClientKillFilter.Username.get -> string?\nStackExchange.Redis.ClientKillFilter.WithClientType(StackExchange.Redis.ClientType? clientType) -> StackExchange.Redis.ClientKillFilter!\n```\n\n----------------------------------------\n\nTITLE: C# Redis Channel Pattern Mode Definitions\nDESCRIPTION: Enumeration defining Redis channel pattern modes including Auto, Literal, and Pattern.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.RedisChannel.PatternMode.Auto = 0\nStackExchange.Redis.RedisChannel.PatternMode.Literal = 1\nStackExchange.Redis.RedisChannel.PatternMode.Pattern = 2\n```\n\n----------------------------------------\n\nTITLE: Connecting to Redis and Performing Set Operations in C#\nDESCRIPTION: This snippet demonstrates connecting to Redis, writing to a set, and reading from it. It's used as an example of a load test that might cause failures in certain setups.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/RespLogging.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// connect\nConsole.WriteLine(\"Connecting...\");\nvar options = ConfigurationOptions.Parse(ConnectionString);\nawait using var muxer = await ConnectionMultiplexer.ConnectAsync(options);\nvar db = muxer.GetDatabase();\n\n// load\nRedisKey testKey = \"marc_abc\";\nawait db.KeyDeleteAsync(testKey);\nConsole.WriteLine(\"Writing...\");\nfor (int i = 0; i < 100; i++)\n{\n    // sync every 50 iterations (pipeline the rest)\n    var flags = (i % 50) == 0 ? CommandFlags.None : CommandFlags.FireAndForget;\n    await db.SetAddAsync(testKey, Guid.NewGuid().ToString(), flags);\n}\n\n// fetch\nConsole.WriteLine(\"Reading...\");\nint count = a;\nfor (int i = 0; i < 10; i++)\n{\n    // this is deliberately not using SCARD\n    // (to put load on the inbound)\n    count += (await db.SetMembersAsync(testKey)).Length;\n}\nConsole.WriteLine(\"all done\");\n```\n\n----------------------------------------\n\nTITLE: Adding Nullable Reference Type Support in C#\nDESCRIPTION: Adds nullable reference type annotations to the entire library, improving type safety and helping developers catch potential null reference errors at compile-time.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ReleaseNotes.md#2025-04-23_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\n// Example of nullable reference type usage:\nstring? nullableString = null;\nstring nonNullableString = \"Hello\";\n\n// The compiler will now warn about potential null reference issues\n```\n\n----------------------------------------\n\nTITLE: C# Redis Proxy Type Definitions\nDESCRIPTION: Enumeration defining Redis proxy types including None, Twemproxy, and Envoyproxy.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.Proxy.None = 0\nStackExchange.Redis.Proxy.Twemproxy = 1\nStackExchange.Redis.Proxy.Envoyproxy = 2\n```\n\n----------------------------------------\n\nTITLE: Implementing SocketManagerSocket Class for Connection Management in C#\nDESCRIPTION: This class implements a socket manager for the StackExchange.Redis library. It wraps a Socket object and provides methods for connecting, sending, and receiving data with error handling and transmission control.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Unshipped.txt#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nnamespace SocketManager\n{\n    internal sealed class SocketManagerSocket : ISocketManagerSocket\n    {\n        internal readonly Socket Socket;\n        private string? _name;\n\n        private static readonly SocketAsyncEventArgs _uselessArgs = new SocketAsyncEventArgs();\n\n        internal SocketManagerSocket(Socket socket, string name)\n        {\n            Socket = socket ?? throw new ArgumentNullException(nameof(socket));\n            _name = name;\n        }\n\n        public bool IsConnected => Socket.Connected;\n\n        public EndPoint? RemoteEndPoint\n        {\n            get\n            {\n                try { return Socket.RemoteEndPoint; }\n                catch { return null; }\n            }\n        }\n\n        public void Close()\n        {\n            try { Socket.Close(); }\n            catch { }\n        }\n\n        public void Dispose()\n        {\n            try { ((IDisposable)Socket).Dispose(); }\n            catch { }\n        }\n\n        public unsafe void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue)\n        {\n            Socket.SetSocketOption(optionLevel, optionName, optionValue);\n        }\n\n        public string GetName() => _name ?? \"\";\n\n        public void SetName(string name) => _name = name;\n\n        public bool SendAsync(SocketAsyncEventArgs args) => Socket.SendAsync(args);\n\n        public bool ReceiveAsync(SocketAsyncEventArgs args) => Socket.ReceiveAsync(args);\n\n        public bool ConnectAsync(SocketAsyncEventArgs args) => Socket.ConnectAsync(args);\n\n        public void Connect(EndPoint endpoint) => Socket.Connect(endpoint);\n\n        public void CancelConnectAsync(SocketAsyncEventArgs args)\n        {\n            Socket.CancelConnectAsync(_uselessArgs);\n        }\n\n        public unsafe bool SendPackage(ReadOnlyMemory<byte> package, ISocketSerializer serializer, ref ConnectionMultiplexer.SocketToken token)\n        {\n            try\n            {\n                var data = serializer.GetBytes(package);\n                fixed (byte* buffer = data.Buffer)\n                {\n                    if (token.WriteBuffer == null)\n                    {\n                        token.LastWriteTickCount = Environment.TickCount;\n                        int sent = Socket.Send(data.Memory.Span, SocketFlags.None, out var errorCode);\n                        if (errorCode == SocketError.WouldBlock || errorCode == SocketError.IOPending || errorCode == SocketError.NoBufferSpaceAvailable)\n                        {\n                            token.SetWriteBuffer(data, 0, sent);\n                            token.Multiplexer.Trace(\"Unable to write entire buffer to socket immediately; buffering for later\");\n                            return true;\n                        }\n                        if (errorCode != SocketError.Success)\n                        {   // this means a genuine failure; report it\n                            token.Multiplexer.Trace(\"Write socket failure: \" + errorCode);\n                            return false;\n                        }\n                        token.Multiplexer.CompleteSyncWrite();\n                        serializer.CompleteSend(data);\n                        return true;\n                    }\n                    else\n                    {   // we already have data pending in the write-buffer; just add this to the buffer\n                        token.Multiplexer.Trace(\"Appending pending buffer; size: \" + data.Length);\n                        token.WriteBuffer.Enqueue(data);\n                        return true;\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                token.Multiplexer.Trace(\"Write socket failure: \" + ex.Message);\n                return false;\n            }\n        }\n\n        public bool WriteBuffer(ref ConnectionMultiplexer.SocketToken token)\n        {\n            if (token.WriteBuffer == null) return true;\n\n            token.LastWriteTickCount = Environment.TickCount;\n\n            try\n            {   // try to write as much of the buffer as possible\n                var writeBuffer = token.WriteBuffer;\n                ISocketSerializer serializer = token.Multiplexer.Serializer;\n                do\n                {   // get as much buffered data as possible\n                    var data = writeBuffer.Peek();\n\n                    int offset = token.WriteBufferOffset;\n                    int count = data.Length - offset;\n                    var source = data.Buffer;\n                    var memory = new Memory<byte>(source, offset, count);\n\n                    int sent = Socket.Send(memory.Span, SocketFlags.None, out var errorCode);\n                    token.Multiplexer.Trace(\"Flushed \" + sent + \" bytes to server \" + (errorCode == SocketError.Success ? \"successfully\" : (\" with error code \" + errorCode));\n                    if (errorCode == SocketError.WouldBlock || errorCode == SocketError.IOPending || errorCode == SocketError.NoBufferSpaceAvailable)\n                    { // these are all \"try me again\" signals\n                        token.SetWriteBuffer(data, offset, sent);\n                        return true;\n                    }\n                    if (errorCode != SocketError.Success)\n                    {   // this means a genuine failure; report it\n                        token.Multiplexer.Trace(\"Write socket failure: \" + errorCode);\n                        return false;\n                    }\n\n                    offset += sent;\n                    if (offset == data.Length)\n                    { // complete buffer\n                        token.SetWriteBuffer(null, 0, 0);\n                        serializer.CompleteSend(writeBuffer.Dequeue());\n\n                        // if we've sent everything, then we want to tell the multiplexer that we've done the write, so that, among other things, it can release\n                        // the write lock to ensure other workers can start writing; otherwise we're going to do another iteration\n                        if (writeBuffer.Count != 0)\n                        {\n                            token.Multiplexer.Trace(\"still have pending operations...\");\n                        }\n                        else\n                        {\n                            token.Multiplexer.CompleteSyncWrite();\n                        }\n                    }\n                    else\n                    { // partial buffer; update offset for next time\n                        token.SetWriteBuffer(data, offset, 0);\n                    }\n                } while (token.WriteBuffer != null && writeBuffer.Count != 0);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                token.Multiplexer.Trace(\"Write socket failure: \" + ex.Message);\n                return false;\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Minimum Target Framework in ASP.NET to Enable Task-Friendly Context\nDESCRIPTION: ASP.NET web.config setting that specifies a minimum target framework of 4.5, which enables the task-friendly SynchronizationContext by default and helps prevent thread theft issues.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/docs/ThreadTheft.md#2025-04-23_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n<httpRuntime targetFramework=\"4.5\" />\n```\n\n----------------------------------------\n\nTITLE: RedisFeatures Equality Operators in StackExchange.Redis\nDESCRIPTION: Equality and inequality operators for comparing RedisFeatures objects.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_62\n\nLANGUAGE: csharp\nCODE:\n```\nstatic StackExchange.Redis.RedisFeatures.operator !=(StackExchange.Redis.RedisFeatures left, StackExchange.Redis.RedisFeatures right) -> bool\nstatic StackExchange.Redis.RedisFeatures.operator ==(StackExchange.Redis.RedisFeatures left, StackExchange.Redis.RedisFeatures right) -> bool\n```\n\n----------------------------------------\n\nTITLE: Redis Protocol and Result Type Enums\nDESCRIPTION: Enum definitions for Redis protocol versions and result types used in the StackExchange.Redis library. Includes both RESP2 and RESP3 protocol constants and various result type values for different data structures.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_73\n\nLANGUAGE: C#\nCODE:\n```\nStackExchange.Redis.RedisProtocol.Resp3 = 30000\nStackExchange.Redis.ResultType.Array = 5\nStackExchange.Redis.ResultType.Attribute = 29\nStackExchange.Redis.ResultType.BigInteger = 17\nStackExchange.Redis.ResultType.BlobError = 10\nStackExchange.Redis.ResultType.Boolean = 11\nStackExchange.Redis.ResultType.Double = 9\nStackExchange.Redis.ResultType.Map = 13\nStackExchange.Redis.ResultType.Null = 8\nStackExchange.Redis.ResultType.Push = 37\nStackExchange.Redis.ResultType.Set = 21\nStackExchange.Redis.ResultType.VerbatimString = 12\n```\n\n----------------------------------------\n\nTITLE: Redis Enumeration Type Definitions\nDESCRIPTION: Enumerations for Redis connection types, exclude options, expire results, and geo-related operations\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\npublic enum ConnectionType {\n    None = 0,\n    Interactive = 1,\n    Subscription = 2\n}\n\npublic enum Exclude {\n    None = 0,\n    Start = 1,\n    Stop = 2,\n    Both = Start | Stop\n}\n\npublic enum ExpireResult {\n    NoSuchField = -2,\n    ConditionNotMet = 0,\n    Success = 1,\n    Due = 2\n}\n```\n\n----------------------------------------\n\nTITLE: RedisValue Explicit Conversions in C#\nDESCRIPTION: Defines explicit conversion operators from RedisValue to various numeric types, including int, long, uint, and ulong, with both nullable and non-nullable versions.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.RedisValue.explicit operator int(StackExchange.Redis.RedisValue value) -> int\nstatic StackExchange.Redis.RedisValue.explicit operator int?(StackExchange.Redis.RedisValue value) -> int?\nstatic StackExchange.Redis.RedisValue.explicit operator long(StackExchange.Redis.RedisValue value) -> long\nstatic StackExchange.Redis.RedisValue.explicit operator long?(StackExchange.Redis.RedisValue value) -> long?\nstatic StackExchange.Redis.RedisValue.explicit operator uint(StackExchange.Redis.RedisValue value) -> uint\nstatic StackExchange.Redis.RedisValue.explicit operator uint?(StackExchange.Redis.RedisValue value) -> uint?\nstatic StackExchange.Redis.RedisValue.explicit operator ulong(StackExchange.Redis.RedisValue value) -> ulong\nstatic StackExchange.Redis.RedisValue.explicit operator ulong?(StackExchange.Redis.RedisValue value) -> ulong?\n```\n\n----------------------------------------\n\nTITLE: SlotRange and SortedSetEntry Operations in C#\nDESCRIPTION: Defines equality operators for SlotRange and SortedSetEntry, as well as conversion operators and static members for SortedSetEntry.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.SlotRange.operator !=(StackExchange.Redis.SlotRange x, StackExchange.Redis.SlotRange y) -> bool\nstatic StackExchange.Redis.SlotRange.operator ==(StackExchange.Redis.SlotRange x, StackExchange.Redis.SlotRange y) -> bool\nstatic StackExchange.Redis.SlotRange.TryParse(string! range, out StackExchange.Redis.SlotRange value) -> bool\nstatic StackExchange.Redis.SortedSetEntry.implicit operator StackExchange.Redis.SortedSetEntry(System.Collections.Generic.KeyValuePair<StackExchange.Redis.RedisValue, double> value) -> StackExchange.Redis.SortedSetEntry\nstatic StackExchange.Redis.SortedSetEntry.implicit operator System.Collections.Generic.KeyValuePair<StackExchange.Redis.RedisValue, double>(StackExchange.Redis.SortedSetEntry value) -> System.Collections.Generic.KeyValuePair<StackExchange.Redis.RedisValue, double>\nstatic StackExchange.Redis.SortedSetEntry.operator !=(StackExchange.Redis.SortedSetEntry x, StackExchange.Redis.SortedSetEntry y) -> bool\nstatic StackExchange.Redis.SortedSetEntry.operator ==(StackExchange.Redis.SortedSetEntry x, StackExchange.Redis.SortedSetEntry y) -> bool\n```\n\n----------------------------------------\n\nTITLE: RedisResult Static Factory Methods\nDESCRIPTION: Static factory methods for creating RedisResult instances from arrays of values. Supports creation from both RedisResult arrays and RedisValue arrays with specified result types.\nSOURCE: https://github.com/stackexchange/stackexchange.redis/blob/main/src/StackExchange.Redis/PublicAPI/PublicAPI.Shipped.txt#2025-04-23_snippet_74\n\nLANGUAGE: C#\nCODE:\n```\nstatic StackExchange.Redis.RedisResult.Create(StackExchange.Redis.RedisResult![]! values, StackExchange.Redis.ResultType resultType)\nstatic StackExchange.Redis.RedisResult.Create(StackExchange.Redis.RedisValue[]! values, StackExchange.Redis.ResultType resultType)\n```"
  }
]