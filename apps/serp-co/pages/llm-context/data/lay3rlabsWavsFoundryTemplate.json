[
  {
    "owner": "lay3rlabs",
    "repo": "wavs-foundry-template",
    "content": "TITLE: Initializing Oracle Component Structure in Rust for WAVS\nDESCRIPTION: This code snippet defines the main structure for the oracle component in WAVS. It imports necessary modules, defines the Component struct, and exports it for use within the WAVS runtime.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/4-component.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nmod trigger;\nuse trigger::{decode_trigger_event, encode_trigger_output, Destination};\nuse wavs_wasi_chain::http::{fetch_json, http_request_get};\npub mod bindings;\nuse crate::bindings::{export, Guest, TriggerAction};\nuse serde::{Deserialize, Serialize};\nuse wstd::{http::HeaderValue, runtime::block_on};\n\nstruct Component;\nexport!(Component with_types_in bindings);\n\nimpl Guest for Component {\n    fn run(action: TriggerAction) -> std::result::Result<Option<Vec<u8>>, String> {\n        let (trigger_id, req, dest) =\n            decode_trigger_event(action.data).map_err(|e| e.to_string())?;\n\n        // Convert bytes to string and parse first char as u64\n        let input = std::str::from_utf8(&req).map_err(|e| e.to_string())?;\n        println!(\"input id: {}\", input);\n\n        let id = input.chars().next().ok_or(\"Empty input\")?;\n        let id = id.to_digit(16).ok_or(\"Invalid hex digit\")? as u64;\n\n        let res = block_on(async move {\n            let resp_data = get_price_feed(id).await?;\n            println!(\"resp_data: {:?}\", resp_data);\n            serde_json::to_vec(&resp_data).map_err(|e| e.to_string())\n        })?;\n\n        let output = match dest {\n            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),\n            Destination::CliOutput => Some(res),\n        };\n        Ok(output)\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Querying NFT Balance with Alloy Provider in Rust\nDESCRIPTION: A complete implementation for querying an ERC721 NFT contract's balanceOf function to determine token ownership. The code demonstrates creating an Ethereum provider, preparing a contract call, executing it, and decoding the result within the Wavs component framework.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::bindings::host::get_eth_chain_config;\nuse alloy_network::{Ethereum, Network};\nuse alloy_primitives::{Address, Bytes, TxKind, U256};\nuse alloy_provider::{Provider, RootProvider};\nuse alloy_rpc_types::{TransactionInput, eth::TransactionRequest}; // Note: use eth::TransactionRequest\nuse alloy_sol_types::{sol, SolCall}; // Removed unused SolType, SolValue\nuse wavs_wasi_chain::ethereum::new_eth_provider;\nuse anyhow::Context;\nuse wstd::runtime::block_on; // Required to run async code\n\n// Define the ERC721 interface subset needed\nsol! {\n    interface IERC721 {\n        function balanceOf(address owner) external view returns (uint256);\n    }\n}\n\n// Function to query NFT ownership (must be async)\npub async fn query_nft_ownership(owner_address: Address, nft_contract: Address) -> Result<bool, String> {\n    // 1. Get chain configuration (using \"eth.local\" as an example)\n    let chain_config = get_eth_chain_config(\"eth.local\")\n        .map_err(|e| format!(\"Failed to get eth.local chain config: {}\", e))?;\n\n    // 2. Create Ethereum provider\n    let provider: RootProvider<Ethereum> = new_eth_provider::<Ethereum>(\n        chain_config.http_endpoint\n            .context(\"http_endpoint missing for eth.local\")?\n    ).map_err(|e| format!(\"Failed to create provider: {}\", e))?; // Handle provider creation error\n\n    // 3. Prepare the contract call using the generated interface\n    let balance_call = IERC721::balanceOfCall { owner: owner_address };\n\n    // 4. Construct the transaction request for a read-only call\n    let tx = TransactionRequest {\n        to: Some(TxKind::Call(nft_contract)), // Specify the contract to call\n        input: TransactionInput {\n            input: Some(balance_call.abi_encode().into()), // ABI-encoded call data\n            data: None // `data` is deprecated, use `input`\n        },\n        // Other fields like nonce, gas, value are not needed for eth_call\n        ..Default::default()\n    };\n\n    // 5. Execute the read-only call using the provider\n    // Note: provider.call() returns the raw bytes result\n    let result_bytes = provider.call(&tx)\n        .await\n        .map_err(|e| format!(\"Provider call failed: {}\", e))?;\n\n    // 6. Decode the result (balanceOf returns uint256)\n    // Ensure the result is exactly 32 bytes for U256::from_be_slice\n    if result_bytes.len() != 32 {\n        return Err(format!(\"Unexpected result length: {}\", result_bytes.len()));\n    }\n    let balance = U256::from_be_slice(&result_bytes);\n\n    // 7. Determine ownership based on balance\n    Ok(balance > U256::ZERO)\n}\n\n// Example of how to call the async function from the main sync component logic\nfn main_logic(owner: Address, contract: Address) -> Result<bool, String> {\n    let is_owner = block_on(async move {\n        query_nft_ownership(owner, contract).await\n    })?; // Use block_on to run the async function\n    Ok(is_owner)\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Price Data in Rust for WAVS Oracle\nDESCRIPTION: This code snippet demonstrates how the oracle component fetches price data from CoinMarketCap. It uses the asset ID to construct a URL, sends an HTTP request, and processes the JSON response to extract relevant price information.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/4-component.mdx#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n        let res = block_on(async move {\n            let resp_data = get_price_feed(id).await?;\n            println!(\"resp_data: {:?}\", resp_data);\n            serde_json::to_vec(&resp_data).map_err(|e| e.to_string())\n        })?;\n\n```\n\n----------------------------------------\n\nTITLE: Fetching Price Feed Data from CoinMarketCap API in Rust\nDESCRIPTION: This function retrieves cryptocurrency price data from CoinMarketCap API using an asset ID. It constructs an HTTP request with required headers, fetches the JSON response, and extracts relevant pricing data into a structured format.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/4-component.mdx#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nasync fn get_price_feed(id: u64) -> Result<PriceFeedData, String> {\n    let url = format!(\n        \"https://api.coinmarketcap.com/data-api/v3/cryptocurrency/detail?id={}&range=1h\",\n        id\n    );\n\n    let current_time = std::time::SystemTime::now().elapsed().unwrap().as_secs();\n\n    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;\n    req.headers_mut().insert(\"Accept\", HeaderValue::from_static(\"application/json\"));\n    req.headers_mut().insert(\"Content-Type\", HeaderValue::from_static(\"application/json\"));\n    req.headers_mut()\n        .insert(\"User-Agent\", HeaderValue::from_static(\"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36\"));\n    req.headers_mut().insert(\n        \"Cookie\",\n        HeaderValue::from_str(&format!(\"myrandom_cookie={}\", current_time)).unwrap(),\n    );\n\n    let json: Root = fetch_json(req).await.map_err(|e| e.to_string())?;\n\n    Ok(PriceFeedData {\n        symbol: json.data.symbol,\n        price: json.data.statistics.price,\n        timestamp: json.status.timestamp,\n    })\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct PriceFeedData {\n    symbol: String,\n    timestamp: String,\n    price: f64,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a WAVS Component with Trigger Data Processing\nDESCRIPTION: A Rust implementation of a WAVS component that processes trigger data. This code demonstrates the three main parts of a component: decoding trigger data, processing it with custom logic, and returning the result.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(warnings)]\nmod bindings;\nuse alloy_sol_types::{sol, SolValue};\nuse bindings::{export, wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent}, Guest, TriggerAction};\nuse wavs_wasi_chain::decode_event_log_data;\n\n// Solidity types for the incoming trigger event using the `sol!` macro\nsol! {\n    event MyEvent(uint64 indexed triggerId, bytes data);\n    struct MyResult {\n        uint64 triggerId;\n        bool success;\n    }\n}\n\n// Define the component\nstruct Component;\nexport!(Component with_types_in bindings);\n\nimpl Guest for Component {\n    fn run(action: TriggerAction) -> Result<Option<Vec<u8>>, String> {\n        match action.data {\n            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {\n                // 1. Decode the event\n                let event: MyEvent = decode_event_log_data!(log)\n                    .map_err(|e| format!(\"Failed to decode event: {}\", e))?;\n                \n                // 2. Process data (your business logic goes here)\n                let result = MyResult {\n                    triggerId,\n                    success: true\n                };\n                \n                // 3. Return encoded result\n                Ok(Some(result.abi_encode()))\n            }\n            _ => Err(\"Unsupported trigger type\".to_string())\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Trigger Events in Rust for WAVS Oracle\nDESCRIPTION: This snippet defines functions for decoding incoming trigger data and encoding output for the WAVS oracle component. It handles Ethereum contract events and raw data, preparing them for processing within the component.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/4-component.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::bindings::wavs::worker::layer_types::{TriggerData, TriggerDataEthContractEvent};\nuse alloy_sol_types::SolValue;\nuse anyhow::Result;\nuse wavs_wasi_chain::decode_event_log_data;\n\npub enum Destination {\n    Ethereum,\n    CliOutput,\n}\n\npub fn decode_trigger_event(trigger_data: TriggerData) -> Result<(u64, Vec<u8>, Destination)> {\n    match trigger_data {\n        TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {\n            let event: solidity::NewTrigger = decode_event_log_data!(log)?;\n            let trigger_info = solidity::TriggerInfo::abi_decode(&event._triggerInfo, false)?;\n            Ok((trigger_info.triggerId, trigger_info.data.to_vec(), Destination::Ethereum))\n        }\n        TriggerData::Raw(data) => Ok((0, data.clone(), Destination::CliOutput)),\n        _ => Err(anyhow::anyhow!(\"Unsupported trigger data type\")),\n    }\n}\n\npub fn encode_trigger_output(trigger_id: u64, output: impl AsRef<[u8]>) -> Vec<u8> {\n    solidity::DataWithId { triggerId: trigger_id, data: output.as_ref().to_vec().into() }\n        .abi_encode()\n}\n\nmod solidity {\n    use alloy_sol_macro::sol;\n    pub use ITypes::*;\n\n    sol!(\"../../src/interfaces/ITypes.sol\");\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing handleSignedData Function in Solidity\nDESCRIPTION: Implementation of the handleSignedData function that validates operator signatures and stores processed data from WAVS components. The function decodes incoming data into a DataWithId struct and maintains state for signatures, data, and trigger validity.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nfunction handleSignedData(bytes calldata _data, bytes calldata _signature) external {\n    // 1. Validate the operator's signature by calling the `validate` function on the `_serviceManager` contract\n    _serviceManager.validate(_data, _signature);\n\n    // 2. Decode the data into a DataWithId struct defined in the `ITypes` interface\n    DataWithId memory dataWithId = abi.decode(_data, (DataWithId));\n\n    // 3. Store the result in state\n    _signatures[dataWithId.triggerId] = _signature;      // 1. Store operator signature\n    _datas[dataWithId.triggerId] = dataWithId.data;      // 2. Store the data\n    _validTriggers[dataWithId.triggerId] = true;         // 3. Mark trigger as valid\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Response Destination for Trigger Output in Rust\nDESCRIPTION: This code snippet determines how to encode the price feed data response based on the destination. It either encodes the output for Ethereum blockchain or formats it for command-line interface output.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/4-component.mdx#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n        let output = match dest {\n            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),\n            Destination::CliOutput => Some(res),\n        };\n        Ok(output)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Trigger Data in Rust for WAVS Oracle\nDESCRIPTION: This snippet shows how the oracle component processes incoming trigger data. It decodes the event, extracts the trigger ID and data, and converts the input into an asset ID for querying price information.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/4-component.mdx#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl Guest for Component {\n    fn run(action: TriggerAction) -> std::result::Result<Option<Vec<u8>>, String> {\n        let (trigger_id, req, dest) =\n            decode_trigger_event(action.data).map_err(|e| e.to_string())?;\n\n        // Convert bytes to string and parse first char as u64\n        let input = std::str::from_utf8(&req).map_err(|e| e.to_string())?;\n        println!(\"input id: {}\", input);\n\n        let id = input.chars().next().ok_or(\"Empty input\")?;\n        let id = id.to_digit(16).ok_or(\"Invalid hex digit\")? as u64;\n\n        let res = block_on(async move {\n            let resp_data = get_price_feed(id).await?;\n            println!(\"resp_data: {:?}\", resp_data);\n            serde_json::to_vec(&resp_data).map_err(|e| e.to_string())\n        })?;\n\n        let output = match dest {\n            Destination::Ethereum => Some(encode_trigger_output(trigger_id, &res)),\n            Destination::CliOutput => Some(res),\n        };\n        Ok(output)\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Making HTTP GET Requests in Rust Component\nDESCRIPTION: Example of making asynchronous HTTP GET requests in a WAVS component using wstd::runtime::block_on.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nuse wstd::runtime::block_on;  // Required for running async code\n\nasync fn make_request() -> Result<YourResponseType, String> {\n    let url = \"https://api.example.com/endpoint\";\n    let mut req = http_request_get(&url).map_err(|e| e.to_string())?;\n    \n    req.headers_mut().insert(\n        \"Accept\",\n        HeaderValue::from_static(\"application/json\")\n    );\n    \n    let json: YourResponseType = fetch_json(req)\n        .await\n        .map_err(|e| e.to_string())?;\n        \n    Ok(json)\n}\n\nfn process_data() -> Result<YourResponseType, String> {\n    block_on(async move {\n        make_request().await\n    })?;\n}\n```\n\n----------------------------------------\n\nTITLE: Ethereum Provider Setup in Rust\nDESCRIPTION: Example of setting up an Ethereum provider using chain configuration and WAVS utilities.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nuse crate::bindings::host::{get_eth_chain_config, get_cosmos_chain_config};\nuse wavs_wasi_chain::ethereum::new_eth_provider;\nuse alloy_provider::{Provider, RootProvider};\nuse alloy_network::Ethereum;\nuse anyhow::Context;\n\nlet chain_config = get_eth_chain_config(\"eth.local\")\n    .map_err(|e| format!(\"Failed to get chain config: {}\", e))?;\n\nlet provider: RootProvider<Ethereum> = new_eth_provider::<Ethereum>(\n    chain_config.http_endpoint\n        .context(\"http_endpoint is missing in chain config\")?\n)?;\n```\n\n----------------------------------------\n\nTITLE: Component Cargo.toml Configuration\nDESCRIPTION: Example configuration for a WAVS component's Cargo.toml file, including package metadata, dependencies, build settings, and component metadata.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n# Package metadata - inherits most values from workspace configuration\n[package]\nname = \"eth-price-oracle\"        # Name of the component\nedition.workspace = true         # Rust edition (inherited from workspace)\nversion.workspace = true         # Version (inherited from workspace)\nauthors.workspace = true         # Authors (inherited from workspace)\nrust-version.workspace = true    # Minimum Rust version (inherited from workspace)\nrepository.workspace = true      # Repository URL (inherited from workspace)\n\n# Component dependencies\n[dependencies]\n# Core dependencies\nwit-bindgen-rt = {workspace = true}    # Required for WASI bindings and Guest trait\nwavs-wasi-chain = { workspace = true }  # Required for core WAVS functionality\n# Helpful dependencies\nserde = { workspace = true }            # For serialization (if working with JSON)\nserde_json = { workspace = true }       # For JSON handling\nalloy-sol-macro = { workspace = true }  # For Ethereum contract interactions\nwstd = { workspace = true }             # For WASI standard library features\nalloy-sol-types = { workspace = true }  # For Ethereum ABI handling\nanyhow = { workspace = true }           # For enhanced error handling\n\n# Library configuration\n[lib]\ncrate-type = [\"cdylib\"]  # Specifies this is a dynamic library crate\n\n# Release build optimization settings\n[profile.release]\ncodegen-units = 1        # Single codegen unit for better optimization\nopt-level = \"s\"          # Optimize for size\ndebug = false            # Disable debug information\nstrip = true            # Strip symbols from binary\nlto = true              # Enable link-time optimization\n\n# WAVS component metadata\n[package.metadata.component]\npackage = \"component:eth-price-oracle\"  # Component package name\ntarget = \"wavs:worker/layer-trigger-world@0.3.0\"  # Target WAVS world and version\n```\n\n----------------------------------------\n\nTITLE: Making HTTP POST Requests in Rust Component\nDESCRIPTION: Example of making POST requests with JSON data using http_request_post_json helper function.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nasync fn make_post_request() -> Result<PostResponse, String> {\n    let url = \"https://api.example.com/endpoint\";\n    let post_data = (\"key1\", \"value1\");\n    \n    let response: PostResponse = fetch_json(\n        http_request_post_json(&url, &post_data)?\n    ).await.map_err(|e| e.to_string())?;\n    \n    Ok(response)\n}\n\nfn process_data() -> Result<PostResponse, String> {\n    block_on(async move {\n        make_post_request().await\n    })?\n}\n```\n\n----------------------------------------\n\nTITLE: Sol Macro Usage in Rust\nDESCRIPTION: Example of using the sol! macro to generate Rust types from Solidity interface files in WAVS components.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nmod solidity {\n    use alloy_sol_macro::sol;\n    \n    // Generate types from Solidity file\n    sol!(\"../../src/interfaces/ITypes.sol\");\n    \n    // Or define types inline\n    sol! {\n        struct TriggerInfo {\n            uint64 triggerId;\n            bytes data;\n        }\n        \n        event NewTrigger(TriggerInfo _triggerInfo);\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nmod solidity {\n    use alloy_sol_macro::sol;\n    pub use ITypes::*;\n\n    // The objects here will be generated automatically into Rust types.\n    // If you update the .sol file, you must re-run `cargo build` to see the changes.\n    sol!(\"../../src/interfaces/ITypes.sol\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TriggerInputData Structure for Prediction Market Oracle\nDESCRIPTION: Structure that defines input data for triggering the prediction market oracle resolution. It includes the LMSR market maker address, conditional tokens address, and the boolean result of the market outcome.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/7-prediction.mdx#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n    struct TriggerInputData {\n        address lmsrMarketMaker;\n        address conditionalTokens;\n        bool result;\n    }\n```\n\n----------------------------------------\n\nTITLE: Data Processing Pattern in Rust\nDESCRIPTION: Example pattern for processing input data and returning output in WAVS components, including Solidity type definitions and event handling.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// 1. Define your Solidity types using the `sol!` macro\nsol! {\n    event MyEvent(uint64 indexed triggerId, bytes data);\n    struct MyResult {\n        uint64 triggerId;\n        bytes processedData;\n    }\n}\n\n// 2. Handle on-chain event trigger and raw trigger types\nimpl Guest for Component {\n    fn run(action: TriggerAction) -> Result<Option<Vec<u8>>, String> {\n        match action.data {\n            // On-chain event handling\n            TriggerData::EthContractEvent(TriggerDataEthContractEvent { log, .. }) => {\n                // Decode the event\n                let event: MyEvent = decode_event_log_data!(log)?;\n                \n                // Process the data\n                let result = MyResult {\n                    triggerId: event.triggerId,\n                    processedData: process_data(&event.data)?,\n                };\n                \n                // Encode for submission\n                Ok(Some(result.abi_encode()))\n            }\n            // Manual trigger handling for testing\n            TriggerData::Raw(data) => {\n                // Process raw data directly\n                let result = process_data(&data)?;\n                Ok(Some(result))\n            }\n            _ => Err(\"Unsupported trigger type\".to_string())\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AvsOutputData Structure for Oracle Response\nDESCRIPTION: Structure that defines the output data from the AVS (Autonomous Validation Service) oracle. Contains the market maker address, conditional tokens address, and the boolean result used to resolve the prediction market.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/7-prediction.mdx#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n    struct AvsOutputData {\n        address lmsrMarketMaker;\n        address conditionalTokens;\n        bool result;\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Payment-Required Trigger Function for Oracle\nDESCRIPTION: Function for adding a new trigger to the oracle with a required payment. It validates that exactly 0.1 ETH is sent with the transaction before initiating the process to resolve the prediction market.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/7-prediction.mdx#2025-04-16_snippet_2\n\nLANGUAGE: solidity\nCODE:\n```\nfunction addTrigger(\n        TriggerInputData calldata triggerData\n    ) external payable returns (ITypes.TriggerId triggerId) {\n        require(msg.value == 0.1 ether, \"Payment must be exactly 0.1 ETH\");\n```\n\n----------------------------------------\n\nTITLE: Accessing Public Environment Variables in Rust\nDESCRIPTION: Rust code example demonstrating how to access public environment variables using std::env::var.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nlet max_retries = std::env::var(\"max_retries\")?;\nlet timeout = std::env::var(\"timeout_seconds\")?;\nlet endpoint = std::env::var(\"api_endpoint\")?;\n```\n\n----------------------------------------\n\nTITLE: Logging Examples in Rust\nDESCRIPTION: Examples of logging implementation for both development and production environments in WAVS components.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nprintln!(\"Debug message: {:?}\", data);\n```\n\nLANGUAGE: rust\nCODE:\n```\nhost::log(LogLevel::Info, \"Production logging message\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Path Remappings for Foundry Solidity Project\nDESCRIPTION: Defines path remappings for Solidity imports used by Foundry build system. Maps OpenZeppelin contracts, WAVS solidity, and Forge Standard Library to their respective node_modules locations, and sets up project-specific directories for contracts and interfaces.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/remappings.txt#2025-04-16_snippet_0\n\nLANGUAGE: config\nCODE:\n```\n@openzeppelin-contracts=node_modules/@openzeppelin/contracts/\n@wavs/=node_modules/@wavs/solidity\nforge-std=node_modules/forge-std/src\n\ncontracts/=src/contracts\ninterfaces/=src/interfaces\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging for WASI Component Development in Rust\nDESCRIPTION: This code demonstrates logging techniques for WASI component development. It uses println!() statements to output debugging information during local development, which can help trace the execution flow when processing price feed requests.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/4-component.mdx#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nimpl Guest for Component {\n    fn run(action: TriggerAction) -> std::result::Result<Option<Vec<u8>>, String> {\n        let (trigger_id, req, dest) =\n            decode_trigger_event(action.data).map_err(|e| e.to_string())?;\n\n        // Convert bytes to string and parse first char as u64\n        let input = std::str::from_utf8(&req).map_err(|e| e.to_string())?;\n        println!(\"input id: {}\", input);\n\n        let id = input.chars().next().ok_or(\"Empty input\")?;\n        let id = id.to_digit(16).ok_or(\"Invalid hex digit\")? as u64;\n\n        let res = block_on(async move {\n            let resp_data = get_price_feed(id).await?;\n            println!(\"resp_data: {:?}\", resp_data);\n\n            serde_json::to_vec(&resp_data).map_err(|e| e.to_string())\n        })?\n```\n\n----------------------------------------\n\nTITLE: Blockchain Dependencies Configuration in Cargo.toml\nDESCRIPTION: Required dependencies for Ethereum blockchain interactions in a WAVS component.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_17\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwit-bindgen-rt = {workspace = true}\nwavs-wasi-chain = { workspace = true }\nalloy-sol-types = { workspace = true }\nalloy-sol-macro = { workspace = true }\nalloy-primitives = { workspace = true }\nalloy-network = \"0.11.1\"\nalloy-provider = { version = \"0.11.1\", default-features = false, features = [\"rpc-api\"] }\nalloy-rpc-types = \"0.11.1\"\nanyhow = { workspace = true }\nserde = { workspace = true }\nserde_json = { workspace = true }\n```\n\n----------------------------------------\n\nTITLE: Chain Configuration in WAVS.toml\nDESCRIPTION: Configuration for different Ethereum networks in the WAVS configuration file.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_18\n\nLANGUAGE: toml\nCODE:\n```\n[chains.eth.local]\nchain_id = \"31337\"\nws_endpoint = \"ws://localhost:8545\"\nhttp_endpoint = \"http://localhost:8545\"\n\n[chains.eth.mainnet]\nchain_id = \"1\"\nws_endpoint = \"wss://mainnet.infura.io/ws/v3/YOUR_INFURA_ID\"\nhttp_endpoint = \"https://mainnet.infura.io/v3/YOUR_INFURA_ID\"\n```\n\n----------------------------------------\n\nTITLE: Building WASI Components\nDESCRIPTION: Command to build WASI components in the project. This compiles components in the /components directory, generates bindings, and outputs to the compiled directory.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/5-build.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake wasi-build\n```\n\n----------------------------------------\n\nTITLE: Building Solidity Contracts and Components\nDESCRIPTION: Command to build both Solidity contracts and WASI components in one step.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/5-build.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake build\n```\n\n----------------------------------------\n\nTITLE: Exploring the WAVS Foundry Template Directory Structure\nDESCRIPTION: Overview of the foundry template's file organization, showing the main directories and files with their respective purposes.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwavs-foundry-template/\n├── README.md\n├── makefile               # Commands, variables, and configs\n├── components/            # WASI components\n│   └── eth-price-oracle/\n│       ├── Cargo.toml     # Component dependencies\n│       ├── lib.rs         # Main Component logic\n│       ├── trigger.rs     # Trigger handling\n│       └── bindings.rs    # Bindings generated by `make build`\n├── compiled/              # WASM files compiled by `make build`\n├── src/\n│   ├── contracts/        # Trigger and submission contracts\n│   └── interfaces/       # Solidity interfaces\n├── script/               # Scripts used in makefile commands\n├── cli.toml              # CLI configuration\n├── wavs.toml             # WAVS service configuration\n├── docs/                 # Documentation\n└── .env                  # Private environment variables\n```\n\n----------------------------------------\n\nTITLE: Private Environment Variable Configuration in Makefile\nDESCRIPTION: Example showing how to configure private environment variables in the SERVICE_CONFIG section.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nSERVICE_CONFIG ?= '{\"fuel_limit\":100000000,\"max_gas\":5000000,\"host_envs\":[\"WAVS_ENV_MY_API_KEY\"],\"kv\":[],\"workflow_id\":\"default\",\"component_id\":\"default\"}'\n```\n\n----------------------------------------\n\nTITLE: Executing WASI Component Locally\nDESCRIPTION: Command to test a WASM component locally in a simulated environment. This example fetches the price of Bitcoin (ID 1) without deploying WAVS.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/5-build.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nCOIN_MARKET_CAP_ID=1 make wasi-exec\n```\n\n----------------------------------------\n\nTITLE: Configuring Public Environment Variables in Makefile\nDESCRIPTION: Example showing how to configure public key-value pairs in the SERVICE_CONFIG section of a Makefile.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nSERVICE_CONFIG ?= '{\"fuel_limit\":100000000,\"max_gas\":5000000,\"host_envs\":[],\"kv\":[[\"max_retries\",\"3\"],[\"timeout_seconds\",\"30\"],[\"api_endpoint\",\"https://api.example.com\"]],\"workflow_id\":\"default\",\"component_id\":\"default\"}'\n```\n\n----------------------------------------\n\nTITLE: Creating New WAVS Project\nDESCRIPTION: Command for initializing a new WAVS project using the Foundry template.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/README.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# If you don't have foundry: `curl -L https://foundry.paradigm.xyz | bash && $HOME/.foundry/bin/foundryup`\nforge init --template Lay3rLabs/wavs-foundry-template my-wavs --branch 0.3\n```\n\n----------------------------------------\n\nTITLE: Service Deployment and Execution Commands\nDESCRIPTION: Commands for deploying and executing WAVS services, including contract deployment and trigger execution.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nexport SERVICE_MANAGER_ADDR=`make get-eigen-service-manager-from-deploy`\nforge script ./script/Deploy.s.sol ${SERVICE_MANAGER_ADDR} --sig \"run(string)\" --rpc-url http://localhost:8545 --broadcast\n\nTRIGGER_EVENT=\"NewTrigger(bytes)\" COMPONENT_FILENAME=usdt_balance.wasm make deploy-service\n\nexport COIN_MARKET_CAP_ID=1\nexport SERVICE_TRIGGER_ADDR=`make get-trigger-from-deploy`\nforge script ./script/Trigger.s.sol ${SERVICE_TRIGGER_ADDR} ${COIN_MARKET_CAP_ID} --sig \"run(string,string)\" --rpc-url http://localhost:8545 --broadcast -v 4\n```\n\n----------------------------------------\n\nTITLE: Customizing Makefile Variables in Bash\nDESCRIPTION: Examples of overriding Makefile variables for component testing and external contract triggering. Shows how to set component filename, market cap ID, trigger address and event.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nCOMPONENT_FILENAME=my_component.wasm COIN_MARKET_CAP_ID=`cast format-bytes32-string 1` make wasi-exec\n```\n\nLANGUAGE: bash\nCODE:\n```\nTRIGGER_ADDRESS ?= 0x1234567890123456789012345678901234567890\nTRIGGER_EVENT ?= MyCustomEvent(bytes)\n```\n\n----------------------------------------\n\nTITLE: Installing Cargo Components\nDESCRIPTION: Commands for installing required cargo components including cargo-component, warg-cli, and wkg with registry configuration.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/README.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Install required cargo components\n# https://github.com/bytecodealliance/cargo-component#installation\ncargo install cargo-binstall\ncargo binstall cargo-component warg-cli wkg --locked --no-confirm --force\n\n# Configure default registry\nwkg config --default-registry wa.dev\n```\n\n----------------------------------------\n\nTITLE: Initializing WAVS Foundry Template Project with Forge\nDESCRIPTION: This command uses Forge to create a new project based on the WAVS Foundry Template. It specifies the template repository, project name, and branch version.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/3-project.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nforge init --template Lay3rLabs/wavs-foundry-template my-wavs --branch 0.3\n```\n\n----------------------------------------\n\nTITLE: Creating Environment Configuration\nDESCRIPTION: Copies the example environment file to create a new .env configuration for the project.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/6-run-service.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Triggering Service Execution\nDESCRIPTION: Commands for triggering the service with a specified CoinMarketCap ID and service trigger address.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/README.md#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nexport COIN_MARKET_CAP_ID=1\nexport SERVICE_TRIGGER_ADDR=`make get-trigger-from-deploy`\nforge script ./script/Trigger.s.sol ${SERVICE_TRIGGER_ADDR} ${COIN_MARKET_CAP_ID} --sig \"run(string,string)\" --rpc-url http://localhost:8545 --broadcast -v 4\n```\n\n----------------------------------------\n\nTITLE: Triggering the Service\nDESCRIPTION: Triggers the oracle service to fetch Bitcoin price data from CoinMarketCap using the deployed trigger contract.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/6-run-service.mdx#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nexport COIN_MARKET_CAP_ID=1\nexport SERVICE_TRIGGER_ADDR=`make get-trigger-from-deploy`\nforge script ./script/Trigger.s.sol ${SERVICE_TRIGGER_ADDR} ${COIN_MARKET_CAP_ID} --sig \"run(string,string)\" --rpc-url http://localhost:8545 --broadcast -v 4\n```\n\n----------------------------------------\n\nTITLE: Customizing Service Deployment Variables\nDESCRIPTION: Example of how to customize deployment variables when running make commands.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/6-run-service.mdx#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nTRIGGER_EVENT=\"NewTrigger(bytes)\" make deploy-service\n```\n\n----------------------------------------\n\nTITLE: WASI Component Testing Command\nDESCRIPTION: Command for testing WASI components locally using the COIN_MARKET_CAP_ID parameter. This allows testing without blockchain deployment.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nCOIN_MARKET_CAP_ID=1 make wasi-exec\n```\n\n----------------------------------------\n\nTITLE: WAVS Service Deployment Configuration\nDESCRIPTION: Bash command configuration for deploying a WAVS service without submission contracts. Uses the deploy-service command with the --submit none flag to indicate no blockchain data submission is required.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndeploy-service:\n\t@$(WAVS_CMD) deploy-service --log-level=info --data /data/.docker --home /data \\\n\t--component \"/data/compiled/${COMPONENT_FILENAME}\" \\\n\t--trigger-event-name \"${TRIGGER_EVENT}\" \\\n\t--trigger-address \"${SERVICE_TRIGGER_ADDR}\" \\\n\t--service-config ${SERVICE_CONFIG} \\\n  --submit none\n```\n\n----------------------------------------\n\nTITLE: Viewing Service Results\nDESCRIPTION: Displays the results of the service execution using a show-result script.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/6-run-service.mdx#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmake show-result\n```\n\n----------------------------------------\n\nTITLE: Deploying WASI Component to WAVS\nDESCRIPTION: Deploys the WASI component and service information to WAVS for operator execution.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/6-run-service.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmake deploy-service\n```\n\n----------------------------------------\n\nTITLE: Deploying Service Contracts\nDESCRIPTION: Deploys the Service's Trigger and Submission contracts using Forge script with the EigenLayer Service Manager address.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/6-run-service.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport SERVICE_MANAGER_ADDR=`make get-eigen-service-manager-from-deploy`\nforge script ./script/Deploy.s.sol ${SERVICE_MANAGER_ADDR} --sig \"run(string)\" --rpc-url http://localhost:8545 --broadcast\n```\n\n----------------------------------------\n\nTITLE: Setting Up Project Dependencies\nDESCRIPTION: This Make command installs necessary dependencies for the project.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/3-project.mdx#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake setup\n```\n\n----------------------------------------\n\nTITLE: Deploying Service Contracts\nDESCRIPTION: Commands for deploying the service contracts using Forge script with service manager address.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/README.md#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nexport SERVICE_MANAGER_ADDR=`make get-eigen-service-manager-from-deploy`\nforge script ./script/Deploy.s.sol ${SERVICE_MANAGER_ADDR} --sig \"run(string)\" --rpc-url http://localhost:8545 --broadcast\n```\n\n----------------------------------------\n\nTITLE: Starting Anvil Chain and WAVS Runtime\nDESCRIPTION: Starts the Anvil test chain and WAVS runtime while deploying EigenLayer contracts.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/6-run-service.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake start-all\n```\n\n----------------------------------------\n\nTITLE: Navigating to Project Directory\nDESCRIPTION: This command changes the current directory to the newly created project folder.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/3-project.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd my-wavs\n```\n\n----------------------------------------\n\nTITLE: Installing Cargo Components for WebAssembly development\nDESCRIPTION: Commands to install necessary tools for building WebAssembly components including cargo-component, warg-cli, and wkg. Also configures the default registry to wa.dev.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo install cargo-binstall\ncargo binstall cargo-component warg-cli wkg --locked --no-confirm --force\n\n# Configure default registry\nwkg config --default-registry wa.dev\n```\n\n----------------------------------------\n\nTITLE: Installing Cargo Components and Warg CLI\nDESCRIPTION: Commands to install necessary tools for building and managing WASI components, including cargo-component, warg-cli, and wkg. Also configures the default registry.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/5-build.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install cargo-binstall\ncargo binstall cargo-component warg-cli wkg --locked --no-confirm --force\n\n# Configure default registry\nwkg config --default-registry wa.dev\n```\n\n----------------------------------------\n\nTITLE: Installing Rust using rustup\nDESCRIPTION: Command to install Rust programming language using the rustup installer script. This is the recommended way to install Rust on Unix-like systems.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n----------------------------------------\n\nTITLE: Project Setup and Build Commands\nDESCRIPTION: Basic setup and build commands for initializing the project and compiling contracts.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/custom-components.mdx#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmake setup\nforge build\nforge test\n```\n\n----------------------------------------\n\nTITLE: Building Solidity Contracts\nDESCRIPTION: Commands for setting up and building Solidity contracts, including package installation and testing.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/README.md#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Install packages (npm & submodules)\nmake setup\n\n# Build the contracts\nforge build\n\n# Run the solidity tests\nforge test\n```\n\n----------------------------------------\n\nTITLE: Installing Docker Mac Net Connect for macOS\nDESCRIPTION: Command to install and start Docker Mac Net Connect, which enables proper host networking on macOS systems. This is an alternative to enabling host networking in Docker Desktop settings.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nbrew install chipmk/tap/docker-mac-net-connect && sudo brew services start chipmk/tap/docker-mac-net-connect\n```\n\n----------------------------------------\n\nTITLE: Building Solidity Contracts with Forge\nDESCRIPTION: This Forge command compiles and builds the Solidity contracts in the project.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/3-project.mdx#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nforge build\n```\n\n----------------------------------------\n\nTITLE: Setting up Rust for fresh installations\nDESCRIPTION: Commands to set up the required toolchain and WebAssembly target for a fresh Rust installation. This installs the stable toolchain and adds wasm32-wasip2 target.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install required target and toolchain\nrustup toolchain install stable\nrustup target add wasm32-wasip2\n```\n\n----------------------------------------\n\nTITLE: Installing Make on Linux\nDESCRIPTION: Command to install Make on Linux using apt package manager. Make is a build automation tool required for this project.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt -y install make\n```\n\n----------------------------------------\n\nTITLE: Upgrading existing Rust installation\nDESCRIPTION: Commands to upgrade an existing Rust installation to the latest stable version and set up the required WebAssembly target. This removes old targets, updates stable, and adds wasm32-wasip2.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Remove old targets if present\nrustup target remove wasm32-wasi || true\nrustup target remove wasm32-wasip1 || true\n\n# Update and add required target\nrustup update stable\nrustup target add wasm32-wasip2\n```\n\n----------------------------------------\n\nTITLE: Installing Rust and WebAssembly Target\nDESCRIPTION: Commands for installing Rust programming language and adding the WebAssembly System Interface (WASI) target.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\nrustup toolchain install stable\nrustup target add wasm32-wasip2\n```\n\n----------------------------------------\n\nTITLE: Installing JQ on Linux\nDESCRIPTION: Command to install JQ on Linux using apt package manager. JQ is a lightweight and flexible command-line JSON processor required for this project.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt -y install jq\n```\n\n----------------------------------------\n\nTITLE: Upgrading Rust and WASI Target\nDESCRIPTION: Commands for updating Rust and configuring the latest WASI target by removing old targets and adding new ones.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Remove old targets if present\nrustup target remove wasm32-wasi || true\nrustup target remove wasm32-wasip1 || true\n\n# Update and add required target\nrustup update stable\nrustup target add wasm32-wasip2\n```\n\n----------------------------------------\n\nTITLE: Installing Foundry's installer (foundryup)\nDESCRIPTION: Command to install Foundryup, the official installer for the Foundry Solidity development suite which includes Anvil, Forge, Cast, and Chisel.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl -L https://foundry.paradigm.xyz | bash\n```\n\n----------------------------------------\n\nTITLE: Installing Foundry using foundryup\nDESCRIPTION: Command to install Foundry using the foundryup installer. Foundry is a comprehensive Solidity development suite.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfoundryup\n```\n\n----------------------------------------\n\nTITLE: Running Solidity Tests with Forge\nDESCRIPTION: This Forge command runs the Solidity tests for the project contracts.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/3-project.mdx#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nforge test\n```\n\n----------------------------------------\n\nTITLE: Installing Docker on macOS\nDESCRIPTION: Command to install Docker on macOS using Homebrew. Docker is required for containerization in this project.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nbrew install --cask docker\n```\n\n----------------------------------------\n\nTITLE: Installing Docker and Docker Compose on Linux\nDESCRIPTION: Commands to install Docker and Docker Compose on Linux systems using apt package manager. These tools are necessary for containerization.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Install Docker\nsudo apt -y install docker.io\n# Install Docker Compose\nsudo apt-get install docker-compose-v2\n```\n\n----------------------------------------\n\nTITLE: Displaying Available Make Commands\nDESCRIPTION: This command shows all available Make commands and environment variable overrides for the project.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/3-project.mdx#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmake help\n```\n\n----------------------------------------\n\nTITLE: Installing Make on macOS\nDESCRIPTION: Command to install Make on macOS using Homebrew. Make is a build automation tool required for this project.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbrew install make\n```\n\n----------------------------------------\n\nTITLE: Installing JQ on macOS\nDESCRIPTION: Command to install JQ on macOS using Homebrew. JQ is a lightweight and flexible command-line JSON processor required for this project.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nbrew install jq\n```\n\n----------------------------------------\n\nTITLE: Setting up Rosetta for Mac with ARM chips\nDESCRIPTION: Command to install Rosetta on Mac systems with ARM processors. Rosetta enables x86_64/amd64 emulation on Apple Silicon.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/2-setup.mdx#2025-04-16_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nsoftwareupdate --install-rosetta`\n```\n\n----------------------------------------\n\nTITLE: Opening Project in Visual Studio Code\nDESCRIPTION: This command opens the current directory (project folder) in Visual Studio Code.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/3-project.mdx#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncode .\n```\n\n----------------------------------------\n\nTITLE: ASCII Art Placeholder in Rust Source Code\nDESCRIPTION: This is an ASCII art placeholder in the source code, likely used as a visual separator or placeholder for development purposes. It doesn't contain functional code but serves as a visual element in the codebase.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/tutorial/4-component.mdx#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠇⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠧⡇⠀⠀⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⡤⡆⠦⠆⢀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠧⣷⣆⠅⢦⠀⠀⠀⠀⠀⠀⠀⠀⠠⠀⠈⠀⠀⠀⠀⠀⢤⣤⣆⢇⣶⣤⡤⡯⣦⣌⡡⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠷⣿⣷⣆⣐⡆⠀⠀⠀⠀⢀⠤⠊⠀⠀⢀⣠⣾⢯⣦⣴⣜⣺⣾⣿⣤⠟⠋⣷⢛⡣⠭⠢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠯⣿⣷⢫⡯⠄⠀⠀⢀⠐⠁⠀⠀⠀⠠⣤⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣙⣷⡗⢤⡤⠀⠈⣰⠶⡤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣩⣿⡏⠉⠉⠀⢠⡔⠁⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠑⣏⠶⡉⠖⣡⠂⣈⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣮⣿⣧⣤⣤⠖⠁⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⢉⡻⣿⣿⣿⣿⣿⣿⣿⣿⠟⠓⠈⠅⠈⠀⠀⠘⢒⣽⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⣿⡿⠛⠉⠀⠀⠀⣀⠔⢀⡴⣃⠀⠀⢀⠷⠲⡄⠸⠟⢋⣿⣿⣿⣿⣿⡇⠀⠀⠀⠐⠁⠀⠀⠂⠀⠀⠰⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⡆⣷⣆⡐⠶⠤⢤⣷⣀⣀⣩⢐⣟⣥⠜⣤⣀⣠⣤⠀⠈⠉⢀⣹⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⢃⣿⣞⣫⡔⢆⡸⡿⣿⣿⣄⣰⣿⠁⢀⣛⠿⣻⣿⣿⣧⣬⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⢀\n⢼⣿⣟⢿⣧⣾⣵⣷⣿⣿⣟⡿⢿⣶⣞⣍⡴⢿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⣠⠈⠀⢀⣀⣼\n⠋⣿⣟⡛⢿⣿⣿⣿⣿⣿⣭⣿⣿⣿⣿⣯⣽⣿⣿⣿⣿⠟⠛⠿⢽⣿⣿⣆⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⣀⢀⡠⣤⣤⣰⣿⠟⠁⠀⠀⡼⢾⣿\n⣻⣿⣟⣇⠈⣉⣯⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠃⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⣴⣶⣤⣤⣤⣤⣴⣴⣴⣶⣦⣦⣤⣦⣀⣦⣤⣶⣿⣿⣿⣿⣿⣿⣿⠿⠁⠀⠀⡀⣤⣬⣾⣿\n⡝⣿⣿⣇⣤⣶⣿⣷⣾⣭⡿⠻⢿⣿⣿⣿⣿⠿⠃⠀⠀⠀⠀⡄⠀⠀⠀⢊⡻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠋⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⢿⠟⢉⠀⡀⢤⣴⣿⣿⣿⠿⠻\n⡁⣻⣿⣿⣿⣿⣷⣿⣿⣿⣿⠾⣿⡿⠞⠁⠀⠀⠀⠀⠀⠔⠫⡅⠀⠀⠀⠀⠁⣀⠀⠈⠻⣿⣿⣿⣿⣻⢟⣁⣄⡄⣀⠙⠻⣿⣿⡿⠿⠛⡋⠕⠂⢀⣀⣄⣓⣳⢿⠟⢛⣩⠴⠈⠀\n⠂⡁⠈⠛⠛⠛⠛⠋⠁⠀⠈⠈⡀⠀⠀⠀⠀⢀⠘⠀⠀⠀⠆⠀⡀⡢⣀⣆⠄⠈⠨⢦⡀⣈⠙⠛⠿⢿⣿⣿⣿⣿⣿⡿⡿⠿⠟⠆⠒⠁⠀⢶⣾⠿⠟⠛⢉⣀⣠⡶⠚⠁⠀⠀⣠\n⠀⡇⡄⣀⡀⠀⠀⠀⠀⠀⠀⠀⢬⠠⠀⡀⠀⠋⠁⠀⡀⠀⠀⡀⠆⢱⣿⣿⣧⣧⣄⠛⣿⣞⣵⣤⣷⣄⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠈⠉⠁⠁⠀⠠⢤⣶⣾⣿⡿⠋⢀⣀⣰⣶⣾⣿\n⡀⡆⠀⡉⡁⢿⣉⢀⠀⣰⣷⣿⣟⠠⡽⢂⡀⡄⠀⠰⣖⢱⢖⢂⡆⠈⣿⣿⣿⣿⣿⣶⣄⡙⠻⢿⣿⣿⣷⣦⣀⠀⠠⣤⣀⡀⢈⣓⣶⣶⣿⣿⣿⣿⣿⠟⠉⠀⠀⠀⣉⣭⣽⣿⣿\n⡇⣯⣿⣿⣿⣾⣿⣿⣿⠿⠟⡡⢞⣹⠾⢻⣚⣛⢺⠞⢋⣭⣾⣧⡃⢄⡈⢿⣿⣿⣿⣿⣿⣿⣯⣿⣮⣽⣿⣿⣿⣿⣷⣬⣽⣿⣿⣿⣽⡿⣿⡿⠟⠋⢀⣀⣐⣺⣿⣿⣟⣫⣭⣿⣿\n⢳⣿⣿⣿⣿⣿⣿⣿⣿⣤⣿⣿⣿⣿⣿⣦⠒⠉⢁⡀⠀⣙⣛⢿⣷⣶⣅⠀⠙⠻⣿⣿⣿⣿⣟⡚⠛⠻⠞⠿⠿⡿⡿⠯⠁⠟⣊⠾⠝⢋⣁⣀⣤⣤⣿⣿⣿⡿⠿⠿⠻⠛⠻⠻⠿\n⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⣐⣾⡿⡟⢶⠾⢋⢹⠿⢿⣿⣿⣷⣦⡈⠙⠛⠿⠿⢿⣶⣶⣶⣶⣶⢶⠟⠚⠀⠁⠀⠀⠙⠛⠛⠛⠛⠛⠋⠉⠁⠀⠀⠀⠀⠀⢀⠀⠀\n```\n\n----------------------------------------\n\nTITLE: React Component Import Statement\nDESCRIPTION: Import statement for React components from lucide-react and fumadocs-ui libraries, used for documentation UI elements.\nSOURCE: https://github.com/Lay3rLabs/wavs-foundry-template/blob/0.3/docs/overview.mdx#2025-04-16_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { HomeIcon, AppWindow, CircuitBoard, Layers, Microscope, Grid2x2, ChevronRight } from 'lucide-react';\nimport { Callout } from 'fumadocs-ui/components/callout';\nimport { DocsPage } from 'fumadocs-ui/page';\n```"
  }
]