[
  {
    "owner": "eyaltoledano",
    "repo": "claude-task-master",
    "content": "TITLE: Configuring MCP Server for Task Master AI - JSON\nDESCRIPTION: This JSON snippet provides an example MCP (Model Control Protocol) server configuration to enable Task Master AI in a developer's editor. It specifies the npx-based launch command, package details, and a set of environment variables needed for the AI backend, such as API keys for Anthropics and Perplexity, model selection, token and temperature parameters, and default tasking options. To use, place this in your editor's MCP configuration (e.g., settings.json), ensuring all environment values (notably API keys) are provided.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n\t\"mcpServers\": {\n\t\t\"taskmaster-ai\": {\n\t\t\t\"command\": \"npx\",\n\t\t\t\"args\": [\"-y\", \"--package=task-master-ai\", \"task-master-ai\"],\n\t\t\t\"env\": {\n\t\t\t\t\"ANTHROPIC_API_KEY\": \"YOUR_ANTHROPIC_API_KEY_HERE\",\n\t\t\t\t\"PERPLEXITY_API_KEY\": \"YOUR_PERPLEXITY_API_KEY_HERE\",\n\t\t\t\t\"MODEL\": \"claude-3-7-sonnet-20250219\",\n\t\t\t\t\"PERPLEXITY_MODEL\": \"sonar-pro\",\n\t\t\t\t\"MAX_TOKENS\": 64000,\n\t\t\t\t\"TEMPERATURE\": 0.2,\n\t\t\t\t\"DEFAULT_SUBTASKS\": 5,\n\t\t\t\t\"DEFAULT_PRIORITY\": \"medium\"\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Model Preferences for LLM Selection\nDESCRIPTION: TypeScript interfaces that allow servers to express preferences for model selection across multiple dimensions including cost, speed, and intelligence. Includes a hints mechanism for more specific model targeting.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_154\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ModelPreferences {\n  /**\n   * Optional hints to use for model selection.\n   *\n   * If multiple hints are specified, the client MUST evaluate them in order\n   * (such that the first match is taken).\n   *\n   * The client SHOULD prioritize these hints over the numeric priorities, but\n   * MAY still use the priorities to select from ambiguous matches.\n   */\n  hints?: ModelHint[];\n\n  /**\n   * How much to prioritize cost when selecting a model. A value of 0 means cost\n   * is not important, while a value of 1 means cost is the most important\n   * factor.\n   *\n   * @TJS-type number\n   * @minimum 0\n   * @maximum 1\n   */\n  costPriority?: number;\n\n  /**\n   * How much to prioritize sampling speed (latency) when selecting a model. A\n   * value of 0 means speed is not important, while a value of 1 means speed is\n   * the most important factor.\n   *\n   * @TJS-type number\n   * @minimum 0\n   * @maximum 1\n   */\n  speedPriority?: number;\n\n  /**\n   * How much to prioritize intelligence and capabilities when selecting a\n   * model. A value of 0 means intelligence is not important, while a value of 1\n   * means intelligence is the most important factor.\n   *\n   * @TJS-type number\n   * @minimum 0\n   * @maximum 1\n   */\n  intelligencePriority?: number;\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ModelHint {\n  /**\n   * A hint for a model name.\n   *\n   * The client SHOULD treat this as a substring of a model name; for example:\n   *  - `claude-3-5-sonnet` should match `claude-3-5-sonnet-20241022`\n   *  - `sonnet` should match `claude-3-5-sonnet-20241022`, `claude-3-sonnet-20240229`, etc.\n   *  - `claude` should match any Claude model\n   *\n   * The client MAY also map the string to a different provider's model name or a different model family, as long as it fills a similar niche; for example:\n   *  - `gemini-1.5-flash` could match `claude-3-haiku-20240307`\n   */\n  name?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Root Interface and Notifications in TypeScript for MCP\nDESCRIPTION: Defines the Root interface which represents a file system root that can be browsed by the server, and the RootsListChangedNotification interface for informing the server when the list of roots has changed.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_158\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * @format uri\n   */\n  uri: string;\n  /**\n   * An optional name for the root. This can be used to provide a human-readable\n   * identifier for the root, which may be useful for display purposes or for\n   * referencing the root in other parts of the application.\n   */\n  name?: string;\n}\n\n/**\n * A notification from the client to the server, informing it that the list of roots has changed.\n * This notification should be sent whenever the client adds, removes, or modifies any root.\n * The server should then request an updated list of roots using the ListRootsRequest.\n */\nexport interface RootsListChangedNotification extends Notification {\n  method: \"notifications/roots/list_changed\";\n}\n```\n\n----------------------------------------\n\nTITLE: Tool and Result Interfaces in TypeScript\nDESCRIPTION: Core interfaces for tool management including ListToolsResult, CallToolResult, CallToolRequest, and related tool definitions with annotations. Defines the structure for tool operations and responses.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_172\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ListToolsResult extends PaginatedResult {\n  tools: Tool[];\n}\n\nexport interface CallToolResult extends Result {\n  content: (TextContent | ImageContent | AudioContent | EmbeddedResource)[];\n  isError?: boolean;\n}\n\nexport interface CallToolRequest extends Request {\n  method: \"tools/call\";\n  params: {\n    name: string;\n    arguments?: { [key: string]: unknown };\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding a Complex Task into Subtasks - Bash\nDESCRIPTION: This bash code block provides commands to decompose a single task (by ID) into a specified number of subtasks, optionally guided by a prompt or using research-backed methods. Flags such as --num, --prompt, --all, and --research offer targeted and bulk subtask generation. Dependencies: Task Master AI must already have populated tasks.json and valid task IDs.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntask-master expand --id=5 --num=3\n\ntask-master expand --id=5 --prompt=\"Focus on security aspects\"\n\ntask-master expand --all\n\ntask-master expand --id=5 --research\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuth 2.0 Authorization Handler in TypeScript\nDESCRIPTION: Implementation of the authorization endpoint handler for an OAuth 2.0 server. It includes parameter validation using Zod, rate limiting configuration, error handling, and the main authorization flow with client validation and scope checking.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_57\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { RequestHandler } from \"express\";\nimport { z } from \"zod\";\nimport express from \"express\";\nimport { OAuthServerProvider } from \"../provider.js\";\nimport { rateLimit, Options as RateLimitOptions } from \"express-rate-limit\";\nimport { allowedMethods } from \"../middleware/allowedMethods.js\";\nimport {\n  InvalidRequestError,\n  InvalidClientError,\n  InvalidScopeError,\n  ServerError,\n  TooManyRequestsError,\n  OAuthError\n} from \"../errors.js\";\n\nexport type AuthorizationHandlerOptions = {\n  provider: OAuthServerProvider;\n  /**\n   * Rate limiting configuration for the authorization endpoint.\n   * Set to false to disable rate limiting for this endpoint.\n   */\n  rateLimit?: Partial<RateLimitOptions> | false;\n};\n\n// Parameters that must be validated in order to issue redirects.\nconst ClientAuthorizationParamsSchema = z.object({\n  client_id: z.string(),\n  redirect_uri: z.string().optional().refine((value) => value === undefined || URL.canParse(value), { message: \"redirect_uri must be a valid URL\" }),\n});\n\n// Parameters that must be validated for a successful authorization request. Failure can be reported to the redirect URI.\nconst RequestAuthorizationParamsSchema = z.object({\n  response_type: z.literal(\"code\"),\n  code_challenge: z.string(),\n  code_challenge_method: z.literal(\"S256\"),\n  scope: z.string().optional(),\n  state: z.string().optional(),\n});\n\nexport function authorizationHandler({ provider, rateLimit: rateLimitConfig }: AuthorizationHandlerOptions): RequestHandler {\n  // Create a router to apply middleware\n  const router = express.Router();\n  router.use(allowedMethods([\"GET\", \"POST\"]));\n  router.use(express.urlencoded({ extended: false }));\n\n  // Apply rate limiting unless explicitly disabled\n  if (rateLimitConfig !== false) {\n    router.use(rateLimit({\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      max: 100, // 100 requests per windowMs\n      standardHeaders: true,\n      legacyHeaders: false,\n      message: new TooManyRequestsError('You have exceeded the rate limit for authorization requests').toResponseObject(),\n      ...rateLimitConfig\n    }));\n  }\n\n  router.all(\"/\", async (req, res) => {\n    res.setHeader('Cache-Control', 'no-store');\n\n    // In the authorization flow, errors are split into two categories:\n    // 1. Pre-redirect errors (direct response with 400)\n    // 2. Post-redirect errors (redirect with error parameters)\n\n    // Phase 1: Validate client_id and redirect_uri. Any errors here must be direct responses.\n    let client_id, redirect_uri, client;\n    try {\n      const result = ClientAuthorizationParamsSchema.safeParse(req.method === 'POST' ? req.body : req.query);\n      if (!result.success) {\n        throw new InvalidRequestError(result.error.message);\n      }\n\n      client_id = result.data.client_id;\n      redirect_uri = result.data.redirect_uri;\n\n      client = await provider.clientsStore.getClient(client_id);\n      if (!client) {\n        throw new InvalidClientError(\"Invalid client_id\");\n      }\n\n      if (redirect_uri !== undefined) {\n        if (!client.redirect_uris.includes(redirect_uri)) {\n          throw new InvalidRequestError(\"Unregistered redirect_uri\");\n        }\n      } else if (client.redirect_uris.length === 1) {\n        redirect_uri = client.redirect_uris[0];\n      } else {\n        throw new InvalidRequestError(\"redirect_uri must be specified when client has multiple registered URIs\");\n      }\n    } catch (error) {\n      // Pre-redirect errors - return direct response\n      //\n      // These don't need to be JSON encoded, as they'll be displayed in a user\n      // agent, but OTOH they all represent exceptional situations (arguably,\n      // \"programmer error\"), so presenting a nice HTML page doesn't help the\n      // user anyway.\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400;\n        res.status(status).json(error.toResponseObject());\n      } else {\n        console.error(\"Unexpected error looking up client:\", error);\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.status(500).json(serverError.toResponseObject());\n      }\n\n      return;\n    }\n\n    // Phase 2: Validate other parameters. Any errors here should go into redirect responses.\n    let state;\n    try {\n      // Parse and validate authorization parameters\n      const parseResult = RequestAuthorizationParamsSchema.safeParse(req.method === 'POST' ? req.body : req.query);\n      if (!parseResult.success) {\n        throw new InvalidRequestError(parseResult.error.message);\n      }\n\n      const { scope, code_challenge } = parseResult.data;\n      state = parseResult.data.state;\n\n      // Validate scopes\n      let requestedScopes: string[] = [];\n      if (scope !== undefined) {\n        requestedScopes = scope.split(\" \");\n        const allowedScopes = new Set(client.scope?.split(\" \"));\n\n        // Check each requested scope against allowed scopes\n        for (const scope of requestedScopes) {\n          if (!allowedScopes.has(scope)) {\n            throw new InvalidScopeError(`Client was not registered with scope ${scope}`);\n          }\n        }\n      }\n\n      // All validation passed, proceed with authorization\n      await provider.authorize(client, {\n        state,\n        scopes: requestedScopes,\n        redirectUri: redirect_uri,\n        codeChallenge: code_challenge,\n      }, res);\n    } catch (error) {\n      // Post-redirect errors - redirect with error parameters\n      if (error instanceof OAuthError) {\n        res.redirect(302, createErrorRedirect(redirect_uri, error, state));\n      } else {\n        console.error(\"Unexpected error during authorization:\", error);\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.redirect(302, createErrorRedirect(redirect_uri, serverError, state));\n      }\n    }\n  });\n\n  return router;\n}\n\n/**\n * Helper function to create redirect URL with error parameters\n */\nfunction createErrorRedirect(redirectUri: string, error: OAuthError, state?: string): string {\n  const errorUrl = new URL(redirectUri);\n  errorUrl.searchParams.set(\"error\", error.errorCode);\n  errorUrl.searchParams.set(\"error_description\", error.message);\n  if (error.errorUri) {\n    errorUrl.searchParams.set(\"error_uri\", error.errorUri);\n  }\n  if (state) {\n\n```\n\n----------------------------------------\n\nTITLE: Defining the FastMCP Server Class and Service Lifecycle - TypeScript\nDESCRIPTION: Implements the FastMCP<T> server class, supporting registration of tools, resources, templates, and prompts, session list introspection, and start/stop lifecycle with either stdio or SSE transport. It handles session management, user authentication, event emission, and connection/disconnection logic. Dependencies include StdioServerTransport, server options, event emitter base, tool/resource/prompt types, and network/server options. Key parameters are the server options and transport configuration; outputs are running/stopped server instances, session events, and error handling for invalid options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class FastMCP<T extends Record<string, unknown> | undefined = undefined> extends FastMCPEventEmitter {\n  #options: ServerOptions<T>;\n  #prompts: InputPrompt[] = [];\n  #resources: Resource[] = [];\n  #resourcesTemplates: InputResourceTemplate[] = [];\n  #sessions: FastMCPSession<T>[] = [];\n  #sseServer: SSEServer | null = null;\n  #tools: Tool<T>[] = [];\n  #authenticate: Authenticate<T> | undefined;\n\n  constructor(public options: ServerOptions<T>) {\n    super();\n\n    this.#options = options;\n    this.#authenticate = options.authenticate;\n  }\n\n  public get sessions(): FastMCPSession<T>[] {\n    return this.#sessions;\n  }\n\n  /**\n   * Adds a tool to the server.\n   */\n  public addTool<Params extends ToolParameters>(tool: Tool<T, Params>) {\n    this.#tools.push(tool as unknown as Tool<T>);\n  }\n\n  /**\n   * Adds a resource to the server.\n   */\n  public addResource(resource: Resource) {\n    this.#resources.push(resource);\n  }\n\n  /**\n   * Adds a resource template to the server.\n   */\n  public addResourceTemplate<\n    const Args extends InputResourceTemplateArgument[],\n  >(resource: InputResourceTemplate<Args>) {\n    this.#resourcesTemplates.push(resource);\n  }\n\n  /**\n   * Adds a prompt to the server.\n   */\n  public addPrompt<const Args extends InputPromptArgument[]>(\n    prompt: InputPrompt<Args>,\n  ) {\n    this.#prompts.push(prompt);\n  }\n\n  /**\n   * Starts the server.\n   */\n  public async start(\n    options:\n      | { transportType: \"stdio\" }\n      | {\n          transportType: \"sse\";\n          sse: { endpoint: `/${string}`; port: number };\n        } = {\n      transportType: \"stdio\",\n    },\n  ) {\n    if (options.transportType === \"stdio\") {\n      const transport = new StdioServerTransport();\n\n      const session = new FastMCPSession<T>({\n        name: this.#options.name,\n        version: this.#options.version,\n        tools: this.#tools,\n        resources: this.#resources,\n        resourcesTemplates: this.#resourcesTemplates,\n        prompts: this.#prompts,\n      });\n\n      await session.connect(transport);\n\n      this.#sessions.push(session);\n\n      this.emit(\"connect\", {\n        session,\n      });\n\n    } else if (options.transportType === \"sse\") {\n      this.#sseServer = await startSSEServer<FastMCPSession<T>>({\n        endpoint: options.sse.endpoint as `/${string}`,\n        port: options.sse.port,\n        createServer: async (request) => {\n          let auth: T | undefined;\n\n          if (this.#authenticate) {\n            auth = await this.#authenticate(request);\n          }\n\n          return new FastMCPSession<T>({\n            auth,\n            name: this.#options.name,\n            version: this.#options.version,\n            tools: this.#tools,\n            resources: this.#resources,\n            resourcesTemplates: this.#resourcesTemplates,\n            prompts: this.#prompts,\n          });\n        },\n        onClose: (session) => {\n          this.emit(\"disconnect\", {\n            session,\n          });\n        },\n        onConnect: async (session) => {\n          this.#sessions.push(session);\n\n          this.emit(\"connect\", {\n            session,\n          });\n        },\n      });\n\n      console.info(\n        `server is running on SSE at http://localhost:${options.sse.port}${options.sse.endpoint}`,\n      );\n    } else {\n      throw new Error(\"Invalid transport type\");\n    }\n  }\n\n  /**\n   * Stops the server.\n   */\n  public async stop() {\n    if (this.#sseServer) {\n      this.#sseServer.close();\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP Architecture Components with Mermaid\nDESCRIPTION: A mermaid diagram illustrating the relationships between MCP core components including host process, clients, servers, and resources across local and remote environments. Shows how multiple clients connect to different servers and access various resources.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n    subgraph \"Application Host Process\"\n        H[Host]\n        C1[Client 1]\n        C2[Client 2]\n        C3[Client 3]\n        H --> C1\n        H --> C2\n        H --> C3\n    end\n\n    subgraph \"Local machine\"\n        S1[Server 1<br>Files & Git]\n        S2[Server 2<br>Database]\n        R1[(\"Local<br>Resource A\")]\n        R2[(\"Local<br>Resource B\")]\n\n        C1 --> S1\n        C2 --> S2\n        S1 <--> R1\n        S2 <--> R2\n    end\n\n    subgraph \"Internet\"\n        S3[Server 3<br>External APIs]\n        R3[(\"Remote<br>Resource C\")]\n\n        C3 --> S3\n        S3 <--> R3\n    end\n```\n\n----------------------------------------\n\nTITLE: Initializing MCP Server with Stdio Transport in TypeScript\nDESCRIPTION: This snippet demonstrates the basic setup of an MCP server using the TypeScript SDK. It initializes a server instance with a name and version, defines capabilities (empty in this case), sets up a request handler for `ListResourcesRequestSchema` to return a predefined resource, and connects the server using `StdioServerTransport` for communication over standard input/output. Dependencies include `@modelcontextprotocol/sdk/server/index.js` and `@modelcontextprotocol/sdk/server/stdio.js`.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\nconst server = new Server({\n  name: \"example-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {\n    resources: {}\n  }\n});\n\n// Handle requests\nserver.setRequestHandler(ListResourcesRequestSchema, async () => {\n  return {\n    resources: [\n      {\n        uri: \"example://resource\",\n        name: \"Example Resource\"\n      }\n    ]\n  };\n});\n\n// Connect transport\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Defining Initialization Request and Response in TypeScript\nDESCRIPTION: Defines the structures for the initialization request sent by the client and the corresponding response from the server. It includes protocol version, capabilities, and implementation information.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_142\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface InitializeRequest extends Request {\n  method: \"initialize\";\n  params: {\n    protocolVersion: string;\n    capabilities: ClientCapabilities;\n    clientInfo: Implementation;\n  };\n}\n\nexport interface InitializeResult extends Result {\n  protocolVersion: string;\n  capabilities: ServerCapabilities;\n  serverInfo: Implementation;\n  instructions?: string;\n}\n\nexport interface InitializedNotification extends Notification {\n  method: \"notifications/initialized\";\n}\n\nexport interface ClientCapabilities {\n  experimental?: { [key: string]: object };\n  roots?: {\n    listChanged?: boolean;\n  };\n  sampling?: object;\n}\n\nexport interface ServerCapabilities {\n  experimental?: { [key: string]: object };\n  logging?: object;\n  prompts?: {\n    listChanged?: boolean;\n  };\n  resources?: {\n    subscribe?: boolean;\n    listChanged?: boolean;\n  };\n  tools?: {\n    listChanged?: boolean;\n  };\n}\n\nexport interface Implementation {\n  name: string;\n  version: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Server Class Implementation with Capability Management\nDESCRIPTION: Core server class implementation that handles protocol initialization, capability management and request/notification routing with type safety.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_114\n\nLANGUAGE: typescript\nCODE:\n```\nexport class Server<\n  RequestT extends Request = Request,\n  NotificationT extends Notification = Notification,\n  ResultT extends Result = Result,\n> extends Protocol<\n  ServerRequest | RequestT,\n  ServerNotification | NotificationT,\n  ServerResult | ResultT\n> {\n  private _clientCapabilities?: ClientCapabilities;\n  private _clientVersion?: Implementation;\n  private _capabilities: ServerCapabilities;\n  private _instructions?: string;\n\n  oninitialized?: () => void;\n\n  constructor(\n    private _serverInfo: Implementation,\n    options?: ServerOptions,\n  ) {\n    super(options);\n    this._capabilities = options?.capabilities ?? {};\n    this._instructions = options?.instructions;\n\n    this.setRequestHandler(InitializeRequestSchema, (request) =>\n      this._oninitialize(request),\n    );\n    this.setNotificationHandler(InitializedNotificationSchema, () =>\n      this.oninitialized?.(),\n    );\n  }\n\n  public registerCapabilities(capabilities: ServerCapabilities): void {\n    if (this.transport) {\n      throw new Error(\n        \"Cannot register capabilities after connecting to transport\",\n      );\n    }\n\n    this._capabilities = mergeCapabilities(this._capabilities, capabilities);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: MCP Architecture Component Diagram\nDESCRIPTION: Mermaid diagram showing the relationship between host process, clients, servers and resources in the Model Context Protocol architecture.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_71\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n    subgraph \"Application Host Process\"\n        H[Host]\n        C1[Client 1]\n        C2[Client 2]\n        C3[Client 3]\n        H --> C1\n        H --> C2\n        H --> C3\n    end\n\n    subgraph \"Local machine\"\n        S1[Server 1<br>Files & Git]\n        S2[Server 2<br>Database]\n        R1[(\"Local<br>Resource A\")]\n        R2[(\"Local<br>Resource B\")]\n\n        C1 --> S1\n        C2 --> S2\n        S1 <--> R1\n        S2 <--> R2\n    end\n\n    subgraph \"Internet\"\n        S3[Server 3<br>External APIs]\n        R3[(\"Remote<br>Resource C\")]\n\n        C3 --> S3\n        S3 <--> R3\n    end\n```\n\n----------------------------------------\n\nTITLE: Defining Tool-Related Interfaces in TypeScript\nDESCRIPTION: TypeScript interfaces for tool-related operations including listing available tools, calling tools, and handling tool results. These interfaces define the structure for tool requests, responses, and notifications between client and server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_149\n\nLANGUAGE: typescript\nCODE:\n```\n/* Tools */\n/**\n * Sent from the client to request a list of tools the server has.\n */\nexport interface ListToolsRequest extends PaginatedRequest {\n  method: \"tools/list\";\n}\n\n/**\n * The server's response to a tools/list request from the client.\n */\nexport interface ListToolsResult extends PaginatedResult {\n  tools: Tool[];\n}\n\n/**\n * The server's response to a tool call.\n *\n * Any errors that originate from the tool SHOULD be reported inside the result\n * object, with `isError` set to true, _not_ as an MCP protocol-level error\n * response. Otherwise, the LLM would not be able to see that an error occurred\n * and self-correct.\n *\n * However, any errors in _finding_ the tool, an error indicating that the\n * server does not support tool calls, or any other exceptional conditions,\n * should be reported as an MCP error response.\n */\nexport interface CallToolResult extends Result {\n  content: (TextContent | ImageContent | EmbeddedResource)[];\n\n  /**\n   * Whether the tool call ended in an error.\n   *\n   * If not set, this is assumed to be false (the call was successful).\n   */\n  isError?: boolean;\n}\n\n/**\n * Used by the client to invoke a tool provided by the server.\n */\nexport interface CallToolRequest extends Request {\n  method: \"tools/call\";\n  params: {\n    name: string;\n    arguments?: { [key: string]: unknown };\n  };\n}\n\n/**\n * An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport interface ToolListChangedNotification extends Notification {\n  method: \"notifications/tools/list_changed\";\n}\n\n/**\n * Definition for a tool the client can call.\n */\nexport interface Tool {\n  /**\n   * The name of the tool.\n   */\n  name: string;\n  /**\n   * A human-readable description of the tool.\n   */\n  description?: string;\n  /**\n   * A JSON Schema object defining the expected parameters for the tool.\n   */\n  inputSchema: {\n    type: \"object\";\n    properties?: { [key: string]: object };\n    required?: string[];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing MCP Server with Stdio Transport in Python\nDESCRIPTION: This Python snippet shows how to set up a basic MCP server using the `mcp` library. It creates a `Server` instance, defines an asynchronous request handler (`list_resources`) using the `@app.list_resources()` decorator to return a sample resource, and sets up an `asyncio` main function to run the server with stdio transport (`stdio_server`). The server listens for requests on standard input and sends responses to standard output. Dependencies include `asyncio`, `mcp.types`, `mcp.server`, and `mcp.server.stdio`.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport mcp.types as types\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\n\napp = Server(\"example-server\")\n\n@app.list_resources()\nasync def list_resources() -> list[types.Resource]:\n    return [\n        types.Resource(\n            uri=\"example://resource\",\n            name=\"Example Resource\"\n        )\n    ]\n\nasync def main():\n    async with stdio_server() as streams:\n        await app.run(\n            streams[0],\n            streams[1],\n            app.create_initialization_options()\n        )\n\nif __name__ == \"__main__\":\n    asyncio.run(main)\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic MCP Server in TypeScript\nDESCRIPTION: Example of setting up a simple MCP server with a calculator tool and a dynamic greeting resource using the TypeScript SDK.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_227\n\nLANGUAGE: typescript\nCODE:\n```\nimport { McpServer, ResourceTemplate } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\n// Create an MCP server\nconst server = new McpServer({\n  name: \"Demo\",\n  version: \"1.0.0\"\n});\n\n// Add an addition tool\nserver.tool(\"add\",\n  { a: z.number(), b: z.number() },\n  async ({ a, b }) => ({\n    content: [{ type: \"text\", text: String(a + b) }]\n  })\n);\n\n// Add a dynamic greeting resource\nserver.resource(\n  \"greeting\",\n  new ResourceTemplate(\"greeting://{name}\", { list: undefined }),\n  async (uri, { name }) => ({\n    contents: [{\n      uri: uri.href,\n      text: `Hello, ${name}!`\n    }]\n  })\n);\n\n// Start receiving messages on stdin and sending messages on stdout\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Management Interfaces in TypeScript\nDESCRIPTION: Defines interfaces for listing, reading, and subscribing to resources, including requests and results for various resource-related operations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_166\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ListResourcesRequest extends PaginatedRequest {\n  method: \"resources/list\";\n}\n\nexport interface ListResourcesResult extends PaginatedResult {\n  resources: Resource[];\n}\n\nexport interface ReadResourceRequest extends Request {\n  method: \"resources/read\";\n  params: {\n    uri: string;\n  };\n}\n\nexport interface ReadResourceResult extends Result {\n  contents: (TextResourceContents | BlobResourceContents)[];\n}\n\nexport interface SubscribeRequest extends Request {\n  method: \"resources/subscribe\";\n  params: {\n    uri: string;\n  };\n}\n\nexport interface UnsubscribeRequest extends Request {\n  method: \"resources/unsubscribe\";\n  params: {\n    uri: string;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP Client-Server Architecture with Mermaid\nDESCRIPTION: A Mermaid flowchart diagram illustrating the basic client-server architecture of MCP. It shows multiple MCP Clients within a Host application connecting to separate MCP Server processes via a transport layer.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nflowchart LR\n    subgraph \"Host\"\n        client1[MCP Client]\n        client2[MCP Client]\n    end\n    subgraph \"Server Process\"\n        server1[MCP Server]\n    end\n    subgraph \"Server Process\"\n        server2[MCP Server]\n    end\n\n    client1 <-->|Transport Layer| server1\n    client2 <-->|Transport Layer| server2\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Server and Adding Tool with Progress Reporting in TypeScript\nDESCRIPTION: Initializes a new FastMCP server instance named 'Test' version '1.0.0'. It then adds a tool named 'add' which takes two numbers ('a', 'b') defined using zod schema, adds them, reports progress using `reportProgress`, introduces a delay, and returns the stringified result. This setup is likely part of a test case.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new FastMCP({\n  name: \"Test\",\n  version: \"1.0.0\",\n});\n\nserver.addTool({\n  name: \"add\",\n  description: \"Add two numbers\",\n  parameters: z.object({\n    a: z.number(),\n    b: z.number(),\n  }),\n  execute: async (args, { reportProgress }) => {\n    reportProgress({\n      progress: 0,\n      total: 10,\n    });\n\n    await delay(100);\n\n    return String(args.a + args.b);\n  },\n});\n\nreturn server;\n```\n\n----------------------------------------\n\nTITLE: Initialize Request in MCP Protocol\nDESCRIPTION: JSON-RPC initialize request sent by the client during the initialization phase. Contains protocol version, client capabilities for roots and sampling, and client information including name and version.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_91\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"initialize\",\n  \"params\": {\n    \"protocolVersion\": \"2024-11-05\",\n    \"capabilities\": {\n      \"roots\": {\n        \"listChanged\": true\n      },\n      \"sampling\": {}\n    },\n    \"clientInfo\": {\n      \"name\": \"ExampleClient\",\n      \"version\": \"1.0.0\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Java Chat Client Implementation with MCP Tools\nDESCRIPTION: Java code demonstrating how to set up a chat client using Spring AI with MCP tool integration, system instructions, and memory management.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_84\n\nLANGUAGE: java\nCODE:\n```\nvar chatClient = chatClientBuilder\n    .defaultSystem(\"You are useful assistant, expert in AI and Java.\")\n    .defaultTools((Object[]) mcpToolAdapter.toolCallbacks())\n    .defaultAdvisors(new MessageChatMemoryAdvisor(new InMemoryChatMemory()))\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Visualizing Complete MCP Authorization Flow\nDESCRIPTION: This diagram provides a comprehensive view of the entire authorization flow in MCP, including server metadata discovery, dynamic client registration, PKCE parameter generation, and the OAuth token exchange process.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_86\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant B as User-Agent (Browser)\n    participant C as Client\n    participant M as MCP Server\n\n    C->>M: GET /.well-known/oauth-authorization-server\n    alt Server Supports Discovery\n        M->>C: Authorization Server Metadata\n    else No Discovery\n        M->>C: 404 (Use default endpoints)\n    end\n\n    alt Dynamic Client Registration\n        C->>M: POST /register\n        M->>C: Client Credentials\n    end\n\n    Note over C: Generate PKCE Parameters\n    C->>B: Open browser with authorization URL + code_challenge\n    B->>M: Authorization Request\n    Note over M: User /authorizes\n    M->>B: Redirect to callback with authorization code\n    B->>C: Authorization code callback\n    C->>M: Token Request + code_verifier\n    M->>C: Access Token (+ Refresh Token)\n    C->>M: API Requests with Access Token\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication in FastMCP\nDESCRIPTION: Shows how to set up authentication with API key validation and session management.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\nimport { AuthError } from \"fastmcp\";\n\nconst server = new FastMCP({\n  name: \"My Server\",\n  version: \"1.0.0\",\n  authenticate: ({request}) => {\n    const apiKey = request.headers[\"x-api-key\"];\n\n    if (apiKey !== '123') {\n      throw new Response(null, {\n        status: 401,\n        statusText: \"Unauthorized\",\n      });\n    }\n\n    // Whatever you return here will be accessible in the `context.session` object.\n    return {\n      id: 1,\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining MCP Prompt Structure in TypeScript/JSON\nDESCRIPTION: This snippet illustrates the structure used to define an MCP prompt. It's represented as a TypeScript interface or a JSON object, containing a unique `name` (string), an optional human-readable `description` (string), and an optional array of `arguments`. Each argument object specifies its `name`, optional `description`, and whether it's `required` (boolean). This structure provides metadata for discovering and using prompts.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  name: string;              // Unique identifier for the prompt\n  description?: string;      // Human-readable description\n  arguments?: [              // Optional list of arguments\n    {\n      name: string;          // Argument identifier\n      description?: string;  // Argument description\n      required?: boolean;    // Whether argument is required\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Resource Request Handlers Implementation\nDESCRIPTION: Implements handlers for resource-related requests including listing resources, templates and reading resources. Includes template matching and completion handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_145\n\nLANGUAGE: typescript\nCODE:\n```\nprivate setResourceRequestHandlers() {\n    if (this._resourceHandlersInitialized) {\n      return;\n    }\n\n    this.server.assertCanSetRequestHandler(\n      ListResourcesRequestSchema.shape.method.value,\n    );\n    this.server.assertCanSetRequestHandler(\n      ListResourceTemplatesRequestSchema.shape.method.value,\n    );\n    this.server.assertCanSetRequestHandler(\n      ReadResourceRequestSchema.shape.method.value,\n    );\n\n    this.server.registerCapabilities({\n      resources: {},\n    });\n\n    this.server.setRequestHandler(\n      ListResourcesRequestSchema,\n      async (request, extra) => {\n        const resources = Object.entries(this._registeredResources).map(\n          ([uri, resource]) => ({\n            uri,\n            name: resource.name,\n            ...resource.metadata,\n          }),\n        );\n\n        const templateResources: Resource[] = [];\n        for (const template of Object.values(\n          this._registeredResourceTemplates,\n        )) {\n          if (!template.resourceTemplate.listCallback) {\n            continue;\n          }\n\n          const result = await template.resourceTemplate.listCallback(extra);\n          for (const resource of result.resources) {\n            templateResources.push({\n              ...resource,\n              ...template.metadata,\n            });\n          }\n        }\n\n        return { resources: [...resources, ...templateResources] };\n      },\n    );\n\n    this.server.setRequestHandler(\n      ListResourceTemplatesRequestSchema,\n      async () => {\n        const resourceTemplates = Object.entries(\n          this._registeredResourceTemplates,\n        ).map(([name, template]) => ({\n          name,\n          uriTemplate: template.resourceTemplate.uriTemplate.toString(),\n          ...template.metadata,\n        }));\n\n        return { resourceTemplates };\n      },\n    );\n\n    this.server.setRequestHandler(\n      ReadResourceRequestSchema,\n      async (request, extra) => {\n        const uri = new URL(request.params.uri);\n\n        // First check for exact resource match\n        const resource = this._registeredResources[uri.toString()];\n        if (resource) {\n          return resource.readCallback(uri, extra);\n        }\n\n        // Then check templates\n        for (const template of Object.values(\n          this._registeredResourceTemplates,\n        )) {\n          const variables = template.resourceTemplate.uriTemplate.match(\n            uri.toString(),\n          );\n          if (variables) {\n            return template.readCallback(uri, variables, extra);\n          }\n        }\n\n        throw new McpError(\n          ErrorCode.InvalidParams,\n          `Resource ${uri} not found`,\n        );\n      },\n    );\n\n    this.setCompletionRequestHandler();\n    \n    this._resourceHandlersInitialized = true;\n  }\n```\n\n----------------------------------------\n\nTITLE: Dynamic Client Registration for OAuth in TypeScript\nDESCRIPTION: Implements OAuth 2.0 Dynamic Client Registration according to RFC 7591. Registers a client with the authorization server by providing client metadata and validates the response containing client credentials.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Performs OAuth 2.0 Dynamic Client Registration according to RFC 7591.\n */\nexport async function registerClient(\n  serverUrl: string | URL,\n  {\n    metadata,\n    clientMetadata,\n  }: {\n    metadata?: OAuthMetadata;\n    clientMetadata: OAuthClientMetadata;\n  },\n): Promise<OAuthClientInformationFull> {\n  let registrationUrl: URL;\n\n  if (metadata) {\n    if (!metadata.registration_endpoint) {\n      throw new Error(\"Incompatible auth server: does not support dynamic client registration\");\n    }\n\n    registrationUrl = new URL(metadata.registration_endpoint);\n  } else {\n    registrationUrl = new URL(\"/register\", serverUrl);\n  }\n\n  const response = await fetch(registrationUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(clientMetadata),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Dynamic client registration failed: HTTP ${response.status}`);\n  }\n\n  return OAuthClientInformationFullSchema.parse(await response.json());\n}\n```\n\n----------------------------------------\n\nTITLE: MCP Tools Message Flow Diagram\nDESCRIPTION: Mermaid sequence diagram illustrating the interaction between the LLM, client, and server for tool discovery, selection, invocation, and updates. The diagram shows the complete lifecycle of tool usage in the Model Context Protocol.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_65\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant LLM\n    participant Client\n    participant Server\n\n    Note over Client,Server: Discovery\n    Client->>Server: tools/list\n    Server-->>Client: List of tools\n\n    Note over Client,LLM: Tool Selection\n    LLM->>Client: Select tool to use\n\n    Note over Client,Server: Invocation\n    Client->>Server: tools/call\n    Server-->>Client: Tool result\n    Client->>LLM: Process result\n\n    Note over Client,Server: Updates\n    Server--)Client: tools/list_changed\n    Client->>Server: tools/list\n    Server-->>Client: Updated tools\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Session Logic in Python\nDESCRIPTION: Python class definition for an MCP `Session`, inheriting from `BaseSession`. It provides asynchronous methods for sending requests (`send_request`), sending notifications (`send_notification`), and handling received requests (`_received_request`) and notifications (`_received_notification`), forming the basis for Python MCP implementations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n```python\nclass Session(BaseSession[RequestT, NotificationT, ResultT]):\n    async def send_request(\n        self,\n        request: RequestT,\n        result_type: type[Result]\n    ) -> Result:\n        \"\"\"\n        Send request and wait for response. Raises McpError if response contains error.\n        \"\"\"\n        # Request handling implementation\n\n    async def send_notification(\n        self,\n        notification: NotificationT\n    ) -> None:\n        \"\"\"Send one-way notification that doesn't expect response.\"\"\"\n        # Notification handling implementation\n\n    async def _received_request(\n        self,\n        responder: RequestResponder[ReceiveRequestT, ResultT]\n    ) -> None:\n        \"\"\"Handle incoming request from other side.\"\"\"\n        # Request handling implementation\n\n    async def _received_notification(\n        self,\n        notification: ReceiveNotificationT\n    ) -> None:\n        \"\"\"Handle incoming notification from other side.\"\"\"\n        # Notification handling implementation\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Tools in TypeScript MCP Server\nDESCRIPTION: Shows how to implement tools in a TypeScript MCP server. It includes setting up the server, defining available tools, and handling tool execution.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new Server({\n  name: \"example-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {\n    tools: {}\n  }\n});\n\n// Define available tools\nserver.setRequestHandler(ListToolsRequestSchema, async () => {\n  return {\n    tools: [{\n      name: \"calculate_sum\",\n      description: \"Add two numbers together\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          a: { type: \"number\" },\n          b: { type: \"number\" }\n        },\n        required: [\"a\", \"b\"]\n      }\n    }]\n  };\n});\n\n// Handle tool execution\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  if (request.params.name === \"calculate_sum\") {\n    const { a, b } = request.params.arguments;\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: String(a + b)\n        }\n      ]\n    };\n  }\n  throw new Error(\"Tool not found\");\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing an MCP Tool for a New Feature in JavaScript\nDESCRIPTION: Details the creation of an MCP tool (`newFeature.js`) using Zod for parameter validation. The `registerNewFeatureTool` function adds the tool to the server, defining its name, description, and parameters. The `execute` method handles incoming requests, parses arguments, calls the underlying Task Master command via `executeTaskMasterCommand` (which likely interacts with `task-master-core.js`), and returns a structured response or error using helper functions.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/MCP_INTEGRATION.md#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// In mcp-server/src/tools/newFeature.js\nimport { z } from 'zod';\nimport {\n\texecuteTaskMasterCommand,\n\tcreateContentResponse,\n\tcreateErrorResponse\n} from './utils.js';\n\nexport function registerNewFeatureTool(server) {\n\tserver.addTool({\n\t\tname: 'newFeature',\n\t\tdescription: 'Run the new feature',\n\t\tparameters: z.object({\n\t\t\tparam1: z.string().describe('First parameter'),\n\t\t\tparam2: z.number().optional().describe('Second parameter'),\n\t\t\tfile: z.string().optional().describe('Path to the tasks file'),\n\t\t\tprojectRoot: z.string().describe('Root directory of the project')\n\t\t}),\n\t\texecute: async (args, { log }) => {\n\t\t\ttry {\n\t\t\t\tlog.info(`Running new feature with args: ${JSON.stringify(args)}`);\n\n\t\t\t\tconst cmdArgs = [];\n\t\t\t\tif (args.param1) cmdArgs.push(`--param1=${args.param1}`);\n\t\t\t\tif (args.param2) cmdArgs.push(`--param2=${args.param2}`);\n\t\t\t\tif (args.file) cmdArgs.push(`--file=${args.file}`);\n\n\t\t\t\tconst projectRoot = args.projectRoot;\n\n\t\t\t\t// Execute the command\n\t\t\t\tconst result = await executeTaskMasterCommand(\n\t\t\t\t\t'new-feature',\n\t\t\t\t\tlog,\n\t\t\t\t\tcmdArgs,\n\t\t\t\t\tprojectRoot\n\t\t\t\t);\n\n\t\t\t\tif (!result.success) {\n\t\t\t\t\tthrow new Error(result.error);\n\t\t\t\t}\n\n\t\t\t\treturn createContentResponse(result.stdout);\n\t\t\t} catch (error) {\n\t\t\t\tlog.error(`Error in new feature: ${error.message}`);\n\t\t\t\treturn createErrorResponse(`Error in new feature: ${error.message}`);\n\t\t\t}\n\t\t}\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Requests with Schema Validation and Progress Support\nDESCRIPTION: Sends a JSON-RPC request and waits for a response, with support for progress reporting, timeout management, and response validation using Zod schemas.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_175\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Sends a request and wait for a response.\n *\n * Do not use this method to emit notifications! Use notification() instead.\n */\nrequest<T extends ZodType<object>>(\n  request: SendRequestT,\n  resultSchema: T,\n  options?: RequestOptions,\n): Promise<z.infer<T>> {\n  return new Promise((resolve, reject) => {\n    if (!this._transport) {\n      reject(new Error(\"Not connected\"));\n      return;\n    }\n\n    if (this._options?.enforceStrictCapabilities === true) {\n      this.assertCapabilityForMethod(request.method);\n    }\n\n    options?.signal?.throwIfAborted();\n\n    const messageId = this._requestMessageId++;\n    const jsonrpcRequest: JSONRPCRequest = {\n      ...request,\n      jsonrpc: \"2.0\",\n      id: messageId,\n    };\n\n    if (options?.onprogress) {\n      this._progressHandlers.set(messageId, options.onprogress);\n      jsonrpcRequest.params = {\n        ...request.params,\n        _meta: { progressToken: messageId },\n      };\n    }\n\n    const cancel = (reason: unknown) => {\n      this._responseHandlers.delete(messageId);\n      this._progressHandlers.delete(messageId);\n      this._cleanupTimeout(messageId);\n\n      this._transport\n        ?.send({\n          jsonrpc: \"2.0\",\n          method: \"notifications/cancelled\",\n          params: {\n            requestId: messageId,\n            reason: String(reason),\n          },\n        })\n        .catch((error) =>\n          this._onerror(new Error(`Failed to send cancellation: ${error}`)),\n        );\n\n      reject(reason);\n    };\n\n    this._responseHandlers.set(messageId, (response) => {\n      if (options?.signal?.aborted) {\n        return;\n      }\n\n      if (response instanceof Error) {\n        return reject(response);\n      }\n\n      try {\n        const result = resultSchema.parse(response.result);\n        resolve(result);\n      } catch (error) {\n        reject(error);\n      }\n    });\n\n    options?.signal?.addEventListener(\"abort\", () => {\n      cancel(options?.signal?.reason);\n    });\n\n    const timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;\n    const timeoutHandler = () => cancel(new McpError(\n      ErrorCode.RequestTimeout,\n      \"Request timed out\",\n      { timeout }\n    ));\n\n    this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler);\n\n    this._transport.send(jsonrpcRequest).catch((error) => {\n      this._cleanupTimeout(messageId);\n      reject(error);\n    });\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MCP Request Message Structure in TypeScript\nDESCRIPTION: TypeScript interface defining the structure of an MCP Request message. It includes a mandatory `method` string indicating the operation and optional `params` object containing parameters for the request.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\ninterface Request {\n  method: string;\n  params?: { ... };\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Executing Prompt Templates in Java - Async API\nDESCRIPTION: Shows asynchronous implementation of prompt template listing and execution using reactive programming patterns. Demonstrates non-blocking operations with the MCP client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_131\n\nLANGUAGE: java\nCODE:\n```\n// List available prompt templates asynchronously\nclient.listPrompts()\n    .doOnNext(prompts -> prompts.forEach(prompt -> \n        System.out.println(prompt.getName())))\n    .subscribe();\n\n// Execute a prompt template asynchronously\nclient.executePrompt(\"echo\", Map.of(\n        \"text\", \"Hello, World!\"\n    ))\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Creating an MCP Client Class in TypeScript\nDESCRIPTION: Implements the Client class for MCP (Model Control Protocol) that extends the Protocol class. The client manages communication with a server, handles capabilities, and provides methods for various protocol operations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexport class Client<\n  RequestT extends Request = Request,\n  NotificationT extends Notification = Notification,\n  ResultT extends Result = Result,\n> extends Protocol<\n  ClientRequest | RequestT,\n  ClientNotification | NotificationT,\n  ClientResult | ResultT\n> {\n  private _serverCapabilities?: ServerCapabilities;\n  private _serverVersion?: Implementation;\n  private _capabilities: ClientCapabilities;\n  private _instructions?: string;\n\n  /**\n   * Initializes this client with the given name and version information.\n   */\n  constructor(\n    private _clientInfo: Implementation,\n    options?: ClientOptions,\n  ) {\n    super(options);\n    this._capabilities = options?.capabilities ?? {};\n  }\n\n  /**\n   * Registers new capabilities. This can only be called before connecting to a transport.\n   *\n   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).\n   */\n  public registerCapabilities(capabilities: ClientCapabilities): void {\n    if (this.transport) {\n      throw new Error(\n        \"Cannot register capabilities after connecting to transport\",\n      );\n    }\n\n    this._capabilities = mergeCapabilities(this._capabilities, capabilities);\n  }\n\n  protected assertCapability(\n    capability: keyof ServerCapabilities,\n    method: string,\n  ): void {\n    if (!this._serverCapabilities?.[capability]) {\n      throw new Error(\n        `Server does not support ${capability} (required for ${method})`,\n      );\n    }\n  }\n\n  override async connect(transport: Transport): Promise<void> {\n    await super.connect(transport);\n\n    try {\n      const result = await this.request(\n        {\n          method: \"initialize\",\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: this._capabilities,\n            clientInfo: this._clientInfo,\n          },\n        },\n        InitializeResultSchema,\n      );\n\n      if (result === undefined) {\n        throw new Error(`Server sent invalid initialize result: ${result}`);\n      }\n\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new Error(\n          `Server's protocol version is not supported: ${result.protocolVersion}`,\n        );\n      }\n\n      this._serverCapabilities = result.capabilities;\n      this._serverVersion = result.serverInfo;\n\n      this._instructions = result.instructions;\n\n      await this.notification({\n        method: \"notifications/initialized\",\n      });\n    } catch (error) {\n      // Disconnect if initialization fails.\n      void this.close();\n      throw error;\n    }\n  }\n\n  /**\n   * After initialization has completed, this will be populated with the server's reported capabilities.\n   */\n  getServerCapabilities(): ServerCapabilities | undefined {\n    return this._serverCapabilities;\n  }\n\n  /**\n   * After initialization has completed, this will be populated with information about the server's name and version.\n   */\n  getServerVersion(): Implementation | undefined {\n    return this._serverVersion;\n  }\n\n  /**\n   * After initialization has completed, this may be populated with information about the server's instructions.\n   */\n  getInstructions(): string | undefined {\n    return this._instructions;\n  }\n```\n\n----------------------------------------\n\nTITLE: Illustrating Server Metadata Discovery Flow in MCP\nDESCRIPTION: This diagram demonstrates the server capability discovery process in MCP, following the OAuth 2.0 Authorization Server Metadata protocol. It shows the interaction between the Client and Server, including the fallback scenario when discovery fails.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_85\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant C as Client\n    participant S as Server\n\n    C->>S: GET /.well-known/oauth-authorization-server\n    alt Discovery Success\n        S->>C: 200 OK + Metadata Document\n        Note over C: Use endpoints from metadata\n    else Discovery Failed\n        S->>C: 404 Not Found\n        Note over C: Fall back to default endpoints\n    end\n    Note over C: Continue with authorization flow\n```\n\n----------------------------------------\n\nTITLE: Setting Up Client-Side Request Handler for ListRootsRequestSchema (TypeScript)\nDESCRIPTION: This snippet demonstrates setting up a request handler on the FastMCP client instance using `client.setRequestHandler`. It registers a handler specifically for requests matching the `ListRootsRequestSchema`. The provided handler function is expected to return an object containing a `roots` array, but the implementation is incomplete in the snippet.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nclient.setRequestHandler(ListRootsRequestSchema, () => {\n  return {\n    roots: [\n      {\n        \n```\n\n----------------------------------------\n\nTITLE: Registering Simple Resources in MCP Server\nDESCRIPTION: Tests basic resource registration with URI and read callback. This verifies the resource is correctly registered and visible in resource listings returned by the server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_124\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should register resource with uri and readCallback\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\"test\", \"test://resource\", async () => ({\n      contents: [\n        {\n          uri: \"test://resource\",\n          text: \"Test content\",\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/list\",\n      },\n      ListResourcesResultSchema,\n    );\n\n    expect(result.resources).toHaveLength(1);\n    expect(result.resources[0].name).toBe(\"test\");\n    expect(result.resources[0].uri).toBe(\"test://resource\");\n  });\n```\n\n----------------------------------------\n\nTITLE: Defining MCP Notification Message Structure in TypeScript\nDESCRIPTION: TypeScript interface defining the structure of an MCP Notification message. Similar to a Request, it includes a mandatory `method` string and optional `params` object, but notifications do not expect a response.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\ninterface Notification {\n  method: string;\n  params?: { ... };\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Client Transport in TypeScript\nDESCRIPTION: A TypeScript class that implements the Transport interface for WebSocket connections. It handles connection establishment, message sending/receiving, and proper connection closure. The class manages WebSocket lifecycle events like onopen, onclose, onerror, and onmessage.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_52\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class WebSocketClientTransport implements Transport {\n  private _socket?: WebSocket;\n  private _url: URL;\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor(url: URL) {\n    this._url = url;\n  }\n\n  start(): Promise<void> {\n    if (this._socket) {\n      throw new Error(\n        \"WebSocketClientTransport already started! If using Client class, note that connect() calls start() automatically.\",\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      this._socket = new WebSocket(this._url, SUBPROTOCOL);\n\n      this._socket.onerror = (event) => {\n        const error =\n          \"error\" in event\n            ? (event.error as Error)\n            : new Error(`WebSocket error: ${JSON.stringify(event)}`);\n        reject(error);\n        this.onerror?.(error);\n      };\n\n      this._socket.onopen = () => {\n        resolve();\n      };\n\n      this._socket.onclose = () => {\n        this.onclose?.();\n      };\n\n      this._socket.onmessage = (event: MessageEvent) => {\n        let message: JSONRPCMessage;\n        try {\n          message = JSONRPCMessageSchema.parse(JSON.parse(event.data));\n        } catch (error) {\n          this.onerror?.(error as Error);\n          return;\n        }\n\n        this.onmessage?.(message);\n      };\n    });\n  }\n\n  async close(): Promise<void> {\n    this._socket?.close();\n  }\n\n  send(message: JSONRPCMessage): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!this._socket) {\n        reject(new Error(\"Not connected\"));\n        return;\n      }\n\n      this._socket?.send(JSON.stringify(message));\n      resolve();\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SQLite Database Integration with MCP Server\nDESCRIPTION: Creates an MCP server that interfaces with a SQLite database. Provides a resource for retrieving database schema and a tool for executing SQL queries, with proper connection handling and error management.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_234\n\nLANGUAGE: typescript\nCODE:\n```\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport sqlite3 from \"sqlite3\";\nimport { promisify } from \"util\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({\n  name: \"SQLite Explorer\",\n  version: \"1.0.0\"\n});\n\n// Helper to create DB connection\nconst getDb = () => {\n  const db = new sqlite3.Database(\"database.db\");\n  return {\n    all: promisify<string, any[]>(db.all.bind(db)),\n    close: promisify(db.close.bind(db))\n  };\n};\n\nserver.resource(\n  \"schema\",\n  \"schema://main\",\n  async (uri) => {\n    const db = getDb();\n    try {\n      const tables = await db.all(\n        \"SELECT sql FROM sqlite_master WHERE type='table'\"\n      );\n      return {\n        contents: [{\n          uri: uri.href,\n          text: tables.map((t: {sql: string}) => t.sql).join(\"\\n\")\n        }]\n      };\n    } finally {\n      await db.close();\n    }\n  }\n);\n\nserver.tool(\n  \"query\",\n  { sql: z.string() },\n  async ({ sql }) => {\n    const db = getDb();\n    try {\n      const results = await db.all(sql);\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify(results, null, 2)\n        }]\n      };\n    } catch (err: unknown) {\n      const error = err as Error;\n      return {\n        content: [{\n          type: \"text\",\n          text: `Error: ${error.message}`\n        }],\n        isError: true\n      };\n    } finally {\n      await db.close();\n    }\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Tool-Related Schemas\nDESCRIPTION: Defines schemas for tools, tool listing, and tool invocation in the protocol. These schemas validate the structure of tool-related requests and responses between client and server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_212\n\nLANGUAGE: typescript\nCODE:\n```\n/* Tools */\n/**\n * Definition for a tool the client can call.\n */\nexport const ToolSchema = z\n  .object({\n    /**\n     * The name of the tool.\n     */\n    name: z.string(),\n    /**\n     * A human-readable description of the tool.\n     */\n    description: z.optional(z.string()),\n    /**\n     * A JSON Schema object defining the expected parameters for the tool.\n     */\n    inputSchema: z\n      .object({\n        type: z.literal(\"object\"),\n        properties: z.optional(z.object({}).passthrough()),\n      })\n      .passthrough(),\n  })\n  .passthrough();\n\n/**\n * Sent from the client to request a list of tools the server has.\n */\nexport const ListToolsRequestSchema = PaginatedRequestSchema.extend({\n  method: z.literal(\"tools/list\"),\n});\n\n/**\n * The server's response to a tools/list request from the client.\n */\nexport const ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: z.array(ToolSchema),\n});\n\n/**\n * The server's response to a tool call.\n */\nexport const CallToolResultSchema = ResultSchema.extend({\n  content: z.array(\n    z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema]),\n  ),\n  isError: z.boolean().default(false).optional(),\n});\n\n/**\n * CallToolResultSchema extended with backwards compatibility to protocol version 2024-10-07.\n */\nexport const CompatibilityCallToolResultSchema = CallToolResultSchema.or(\n  ResultSchema.extend({\n    toolResult: z.unknown(),\n  }),\n);\n\n/**\n * Used by the client to invoke a tool provided by the server.\n */\nexport const CallToolRequestSchema = RequestSchema.extend({\n  method: z.literal(\"tools/call\"),\n  params: BaseRequestParamsSchema.extend({\n    name: z.string(),\n    arguments: z.optional(z.record(z.unknown())),\n  }),\n});\n\n/**\n * An optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport const ToolListChangedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/tools/list_changed\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Dynamic MCP Prompt with Resource Arguments in JSON\nDESCRIPTION: This JSON snippet defines an MCP prompt named `analyze-project` that accepts dynamic arguments related to external resources. Specifically, it takes a `timeframe` argument (presumably for filtering logs) and a `fileUri` argument (pointing to a code file). This allows the prompt interaction to be tailored based on specific resources provided at runtime.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"analyze-project\",\n  \"description\": \"Analyze project logs and code\",\n  \"arguments\": [\n    {\n      \"name\": \"timeframe\",\n      \"description\": \"Time period to analyze logs\",\n      \"required\": true\n    },\n    {\n      \"name\": \"fileUri\",\n      \"description\": \"URI of code file to review\",\n      \"required\": true\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Server with SSE Transport for MCP\nDESCRIPTION: Sets up an Express server with Server-Sent Events (SSE) for the Model Context Protocol. Creates endpoints for SSE connection and message handling, enabling bidirectional communication between clients and the MCP server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_232\n\nLANGUAGE: typescript\nCODE:\n```\nimport express from \"express\";\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { SSEServerTransport } from \"@modelcontextprotocol/sdk/server/sse.js\";\n\nconst server = new McpServer({\n  name: \"example-server\",\n  version: \"1.0.0\"\n});\n\n// ... set up server resources, tools, and prompts ...\n\nconst app = express();\n\napp.get(\"/sse\", async (req, res) => {\n  const transport = new SSEServerTransport(\"/messages\", res);\n  await server.connect(transport);\n});\n\napp.post(\"/messages\", async (req, res) => {\n  // Note: to support multiple simultaneous connections, these messages will\n  // need to be routed to a specific matching transport. (This logic isn't\n  // implemented here, for simplicity.)\n  await transport.handlePostMessage(req, res);\n});\n\napp.listen(3001);\n```\n\n----------------------------------------\n\nTITLE: Defining JSON-RPC Message Types in TypeScript\nDESCRIPTION: Defines various schemas and types for JSON-RPC messages using the Zod library. This includes schemas for requests, notifications, responses, and errors, as well as specific message types like initialization requests and cancellation notifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_193\n\nLANGUAGE: typescript\nCODE:\n```\nexport const LATEST_PROTOCOL_VERSION = \"2024-11-05\";\nexport const SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  \"2024-10-07\",\n];\n\nexport const JSONRPC_VERSION = \"2.0\";\n\nexport const ProgressTokenSchema = z.union([z.string(), z.number().int()]);\n\nexport const CursorSchema = z.string();\n\nconst BaseRequestParamsSchema = z\n  .object({\n    _meta: z.optional(\n      z\n        .object({\n          progressToken: z.optional(ProgressTokenSchema),\n        })\n        .passthrough(),\n    ),\n  })\n  .passthrough();\n\nexport const RequestSchema = z.object({\n  method: z.string(),\n  params: z.optional(BaseRequestParamsSchema),\n});\n\n// ... [additional type definitions] ...\n\nexport const JSONRPCMessageSchema = z.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema,\n]);\n\nexport const InitializeRequestSchema = RequestSchema.extend({\n  method: z.literal(\"initialize\"),\n  params: BaseRequestParamsSchema.extend({\n    protocolVersion: z.string(),\n    capabilities: ClientCapabilitiesSchema,\n    clientInfo: ImplementationSchema,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Starting OAuth Authorization Flow with PKCE Challenge in TypeScript\nDESCRIPTION: Initiates the OAuth authorization flow by generating a PKCE challenge and constructing the authorization URL. Validates that the server supports the required response type and PKCE challenge method before proceeding.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Begins the authorization flow with the given server, by generating a PKCE challenge and constructing the authorization URL.\n */\nexport async function startAuthorization(\n  serverUrl: string | URL,\n  {\n    metadata,\n    clientInformation,\n    redirectUrl,\n  }: {\n    metadata?: OAuthMetadata;\n    clientInformation: OAuthClientInformation;\n    redirectUrl: string | URL;\n  },\n): Promise<{ authorizationUrl: URL; codeVerifier: string }> {\n  const responseType = \"code\";\n  const codeChallengeMethod = \"S256\";\n\n  let authorizationUrl: URL;\n  if (metadata) {\n    authorizationUrl = new URL(metadata.authorization_endpoint);\n\n    if (!metadata.response_types_supported.includes(responseType)) {\n      throw new Error(\n        `Incompatible auth server: does not support response type ${responseType}`,\n      );\n    }\n\n    if (\n      !metadata.code_challenge_methods_supported ||\n      !metadata.code_challenge_methods_supported.includes(codeChallengeMethod)\n    ) {\n      throw new Error(\n        `Incompatible auth server: does not support code challenge method ${codeChallengeMethod}`,\n      );\n    }\n  } else {\n    authorizationUrl = new URL(\"/authorize\", serverUrl);\n  }\n\n  // Generate PKCE challenge\n  const challenge = await pkceChallenge();\n  const codeVerifier = challenge.code_verifier;\n  const codeChallenge = challenge.code_challenge;\n\n  authorizationUrl.searchParams.set(\"response_type\", responseType);\n  authorizationUrl.searchParams.set(\"client_id\", clientInformation.client_id);\n  authorizationUrl.searchParams.set(\"code_challenge\", codeChallenge);\n  authorizationUrl.searchParams.set(\n    \"code_challenge_method\",\n    codeChallengeMethod,\n  );\n  authorizationUrl.searchParams.set(\"redirect_uri\", String(redirectUrl));\n\n  return { authorizationUrl, codeVerifier };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Capability Interfaces in TypeScript for MCP\nDESCRIPTION: Defines interfaces for client and server capabilities that describe what features each side supports, as well as implementation information including name and version.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_162\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Capabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.\n */\nexport interface ClientCapabilities {\n  /**\n   * Experimental, non-standard capabilities that the client supports.\n   */\n  experimental?: { [key: string]: object };\n  /**\n   * Present if the client supports listing roots.\n   */\n  roots?: {\n    /**\n     * Whether the client supports notifications for changes to the roots list.\n     */\n    listChanged?: boolean;\n  };\n  /**\n   * Present if the client supports sampling from an LLM.\n   */\n  sampling?: object;\n}\n\n/**\n * Capabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.\n */\nexport interface ServerCapabilities {\n  /**\n   * Experimental, non-standard capabilities that the server supports.\n   */\n  experimental?: { [key: string]: object };\n  /**\n   * Present if the server supports sending log messages to the client.\n   */\n  logging?: object;\n  /**\n   * Present if the server supports argument autocompletion suggestions.\n   */\n  completions?: object;\n  /**\n   * Present if the server offers any prompt templates.\n   */\n  prompts?: {\n    /**\n     * Whether this server supports notifications for changes to the prompt list.\n     */\n    listChanged?: boolean;\n  };\n  /**\n   * Present if the server offers any resources to read.\n   */\n  resources?: {\n    /**\n     * Whether this server supports subscribing to resource updates.\n     */\n    subscribe?: boolean;\n    /**\n     * Whether this server supports notifications for changes to the resource list.\n     */\n    listChanged?: boolean;\n  };\n  /**\n   * Present if the server offers any tools to call.\n   */\n  tools?: {\n    /**\n     * Whether this server supports notifications for changes to the tool list.\n     */\n    listChanged?: boolean;\n  };\n}\n\n/**\n * Describes the name and version of an MCP implementation.\n */\nexport interface Implementation {\n  name: string;\n  version: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Sampling and Message Interfaces in TypeScript\nDESCRIPTION: Interfaces for LLM sampling and message handling, including request parameters and response structures. Defines the contract for creating and handling LLM messages with various content types.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_174\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CreateMessageRequest extends Request {\n  method: \"sampling/createMessage\";\n  params: {\n    messages: SamplingMessage[];\n    modelPreferences?: ModelPreferences;\n    systemPrompt?: string;\n    includeContext?: \"none\" | \"thisServer\" | \"allServers\";\n    temperature?: number;\n    maxTokens: number;\n    stopSequences?: string[];\n    metadata?: object;\n  };\n}\n\nexport interface CreateMessageResult extends Result, SamplingMessage {\n  model: string;\n  stopReason?: \"endTurn\" | \"stopSequence\" | \"maxTokens\" | string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Content Schemas for Model Context Protocol\nDESCRIPTION: Schemas for resource contents including base, text, and binary blob resources. These schemas define how resources are represented, including URI, MIME type, and the content itself in either text or base64-encoded binary form.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_200\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Resources */\n/**\n * The contents of a specific resource or sub-resource.\n */\nexport const ResourceContentsSchema = z\n  .object({\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n  })\n  .passthrough();\n\nexport const TextResourceContentsSchema = ResourceContentsSchema.extend({\n  /**\n   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).\n   */\n  text: z.string(),\n});\n\nexport const BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  /**\n   * A base64-encoded string representing the binary data of the item.\n   */\n  blob: z.string().base64(),\n});\n```\n\n----------------------------------------\n\nTITLE: Processing JSON-RPC Requests with Abort Support\nDESCRIPTION: Handles incoming JSON-RPC requests by finding the appropriate handler and providing abort capabilities. Wraps execution in promises to handle synchronous and asynchronous errors.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_170\n\nLANGUAGE: typescript\nCODE:\n```\nprivate _onrequest(request: JSONRPCRequest): void {\n  const handler =\n    this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler;\n\n  if (handler === undefined) {\n    this._transport\n      ?.send({\n        jsonrpc: \"2.0\",\n        id: request.id,\n        error: {\n          code: ErrorCode.MethodNotFound,\n          message: \"Method not found\",\n        },\n      })\n      .catch((error) =>\n        this._onerror(\n          new Error(`Failed to send an error response: ${error}`),\n        ),\n      );\n    return;\n  }\n\n  const abortController = new AbortController();\n  this._requestHandlerAbortControllers.set(request.id, abortController);\n\n  // Create extra object with both abort signal and sessionId from transport\n  const extra: RequestHandlerExtra = {\n    signal: abortController.signal,\n    sessionId: this._transport?.sessionId,\n  };\n\n  // Starting with Promise.resolve() puts any synchronous errors into the monad as well.\n  Promise.resolve()\n    .then(() => handler(request, extra))\n    .then(\n      (result) => {\n        if (abortController.signal.aborted) {\n          return;\n        }\n\n        return this._transport?.send({\n          result,\n          jsonrpc: \"2.0\",\n          id: request.id,\n        });\n      },\n      (error) => {\n        if (abortController.signal.aborted) {\n          return;\n        }\n\n        return this._transport?.send({\n          jsonrpc: \"2.0\",\n          id: request.id,\n          error: {\n            code: Number.isSafeInteger(error[\"code\"])\n              ? error[\"code\"]\n              : ErrorCode.InternalError,\n            message: error.message ?? \"Internal error\",\n          },\n        });\n      },\n    )\n    .catch((error) =>\n      this._onerror(new Error(`Failed to send response: ${error}`)),\n    )\n    .finally(() => {\n      this._requestHandlerAbortControllers.delete(request.id);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: OAuth Schema Definitions - TypeScript\nDESCRIPTION: Defines Zod schemas for OAuth 2.0 and 2.1 metadata, tokens, and client registration. Implements RFC 8414, 7591, and 7009 specifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_154\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from \"zod\";\n\nexport const OAuthMetadataSchema = z\n  .object({\n    issuer: z.string(),\n    authorization_endpoint: z.string(),\n    token_endpoint: z.string(),\n    registration_endpoint: z.string().optional(),\n    scopes_supported: z.array(z.string()).optional()\n    // ... additional schema definitions\n  })\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Server Capabilities in Java\nDESCRIPTION: Demonstrates how to configure various capabilities for an MCP server, including resource support, tool support, prompt support, and logging. These capabilities define the features and functionalities available on the server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_142\n\nLANGUAGE: java\nCODE:\n```\nvar capabilities = ServerCapabilities.builder()\n    .resources(false, true)  // Resource support with list changes notifications\n    .tools(true)            // Tool support with list changes notifications\n    .prompts(true)          // Prompt support with list changes notifications\n    .logging()              // Enable logging support (enabled by default with loging level INFO)\n    .build();\n```\n\n----------------------------------------\n\nTITLE: FastMCP Server Core Implementation\nDESCRIPTION: Main server implementation with support for resources, prompts, tools and session management. Includes event handling and transport configuration.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\nexport class FastMCP<T extends Record<string, unknown> | undefined = undefined> extends FastMCPEventEmitter {\n  #options: ServerOptions<T>;\n  #prompts: InputPrompt[] = [];\n  #resources: Resource[] = [];\n  #resourcesTemplates: InputResourceTemplate[] = [];\n  #sessions: FastMCPSession<T>[] = [];\n  #sseServer: SSEServer | null = null;\n  #tools: Tool<T>[] = [];\n  #authenticate: Authenticate<T> | undefined;\n\n  constructor(public options: ServerOptions<T>) {\n    super();\n    this.#options = options;\n    this.#authenticate = options.authenticate;\n  }\n\n  // ... methods implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Static and Dynamic Resources in MCP Server\nDESCRIPTION: Examples of creating static and dynamic resources in an MCP server, demonstrating how to expose data to LLMs.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_228\n\nLANGUAGE: typescript\nCODE:\n```\n// Static resource\nserver.resource(\n  \"config\",\n  \"config://app\",\n  async (uri) => ({\n    contents: [{\n      uri: uri.href,\n      text: \"App configuration here\"\n    }]\n  })\n);\n\n// Dynamic resource with parameters\nserver.resource(\n  \"user-profile\",\n  new ResourceTemplate(\"users://{userId}/profile\", { list: undefined }),\n  async (uri, { userId }) => ({\n    contents: [{\n      uri: uri.href,\n      text: `Profile data for user ${userId}`\n    }]\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Content Types for LLM Communication\nDESCRIPTION: TypeScript interfaces defining content types that can be exchanged with language models. Includes structures for text and image content with optional annotations for audience targeting and priority settings.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_153\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Annotated {\n  annotations?: {\n    /**\n     * Describes who the intended customer of this object or data is.\n     * \n     * It can include multiple entries to indicate content useful for multiple audiences (e.g., `[\"user\", \"assistant\"]`).\n     */\n    audience?: Role[];\n\n    /**\n     * Describes how important this data is for operating the server.\n     * \n     * A value of 1 means \"most important,\" and indicates that the data is\n     * effectively required, while 0 means \"least important,\" and indicates that\n     * the data is entirely optional.\n     *\n     * @TJS-type number\n     * @minimum 0\n     * @maximum 1\n     */\n    priority?: number;\n  }\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TextContent extends Annotated {\n  type: \"text\";\n  /**\n   * The text content of the message.\n   */\n  text: string;\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ImageContent extends Annotated {\n  type: \"image\";\n  /**\n   * The base64-encoded image data.\n   *\n   * @format byte\n   */\n  data: string;\n  /**\n   * The MIME type of the image. Different providers may support different image types.\n   */\n  mimeType: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Asynchronous MCP Server in Java\nDESCRIPTION: Creates an asynchronous MCP server with custom configuration, including server info, capabilities, and tool/resource/prompt registrations. It demonstrates reactive programming patterns for server operations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_137\n\nLANGUAGE: java\nCODE:\n```\n// Create an async server with custom configuration\nMcpAsyncServer asyncServer = McpServer.async(transport)\n    .serverInfo(\"my-server\", \"1.0.0\")\n    .capabilities(ServerCapabilities.builder()\n        .resources(true)     // Enable resource support\n        .tools(true)         // Enable tool support\n        .prompts(true)       // Enable prompt support\n        .logging()           // Enable logging support\n        .build())\n    .build();\n\n// Register tools, resources, and prompts\nasyncServer.addTool(asyncToolRegistration)\n    .doOnSuccess(v -> logger.info(\"Tool registered\"))\n    .subscribe();\n\nasyncServer.addResource(asyncResourceRegistration)\n    .doOnSuccess(v -> logger.info(\"Resource registered\"))\n    .subscribe();\n\nasyncServer.addPrompt(asyncPromptRegistration)\n    .doOnSuccess(v -> logger.info(\"Prompt registered\"))\n    .subscribe();\n\n// Send logging notifications\nasyncServer.loggingNotification(LoggingMessageNotification.builder()\n    .level(LoggingLevel.INFO)\n    .logger(\"custom-logger\")\n    .data(\"Server initialized\")\n    .build());\n\n// Close the server when done\nasyncServer.close()\n    .doOnSuccess(v -> logger.info(\"Server closed\"))\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Receiving Available Prompts via MCP 'prompts/list' Response in TypeScript/JSON\nDESCRIPTION: This snippet displays the JSON-RPC response format returned by an MCP server when a client requests the list of available prompts. The response contains a `prompts` property, which is an array of prompt definition objects adhering to the structure previously defined (including `name`, `description`, and `arguments`).\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// Response\n{\n  prompts: [\n    {\n      name: \"analyze-code\",\n      description: \"Analyze code for potential improvements\",\n      arguments: [\n        {\n          name: \"language\",\n          description: \"Programming language\",\n          required: true\n        }\n      ]\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Tools Capability in JSON\nDESCRIPTION: JSON snippet showing how servers declare support for tools capability in MCP. The listChanged flag indicates if the server will notify when the tool list changes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_132\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"tools\": {\n      \"listChanged\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Low-Level MCP Server with Custom Request Handlers\nDESCRIPTION: Shows how to create a more customized MCP server using the low-level Server class with stdio transport. Implements request handlers for listing and retrieving prompts, demonstrating fine-grained control over the MCP protocol implementation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_235\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema\n} from \"@modelcontextprotocol/sdk/types.js\";\n\nconst server = new Server(\n  {\n    name: \"example-server\",\n    version: \"1.0.0\"\n  },\n  {\n    capabilities: {\n      prompts: {}\n    }\n  }\n);\n\nserver.setRequestHandler(ListPromptsRequestSchema, async () => {\n  return {\n    prompts: [{\n      name: \"example-prompt\",\n      description: \"An example prompt template\",\n      arguments: [{\n        name: \"arg1\",\n        description: \"Example argument\",\n        required: true\n      }]\n    }]\n  };\n});\n\nserver.setRequestHandler(GetPromptRequestSchema, async (request) => {\n  if (request.params.name !== \"example-prompt\") {\n    throw new Error(\"Unknown prompt\");\n  }\n  return {\n    description: \"Example prompt\",\n    messages: [{\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: \"Example prompt text\"\n      }\n    }]\n  };\n});\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Content Type Interfaces in TypeScript\nDESCRIPTION: Interfaces defining different content types (text, image, audio) with annotations and metadata. Provides structures for handling various media types in message content.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_175\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface TextContent {\n  type: \"text\";\n  text: string;\n  annotations?: Annotations;\n}\n\nexport interface ImageContent {\n  type: \"image\";\n  data: string;\n  mimeType: string;\n  annotations?: Annotations;\n}\n\nexport interface AudioContent {\n  type: \"audio\";\n  data: string;\n  mimeType: string;\n  annotations?: Annotations;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Source-Aware Core Functions in JavaScript\nDESCRIPTION: Demonstrates the core pattern for creating functions usable by both CLI and MCP. It checks an `options.source` parameter ('mcp' or other) to conditionally display UI elements (like banners and console logs) and determine the return format (structured JSON object for MCP, side effects like console output and process exit for CLI). Error handling is also adapted based on the source.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/MCP_INTEGRATION.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Example function with source parameter support\n * @param {Object} options - Additional options including source\n * @returns {Object|undefined} - Returns data when source is 'mcp'\n */\nfunction exampleFunction(param1, param2, options = {}) {\n\ttry {\n\t\t// Skip UI for MCP\n\t\tif (options.source !== 'mcp') {\n\t\t\tdisplayBanner();\n\t\t\tconsole.log(chalk.blue('Processing operation...'));\n\t\t}\n\n\t\t// Do the core business logic\n\t\tconst result = doSomething(param1, param2);\n\n\t\t// For MCP, return structured data\n\t\tif (options.source === 'mcp') {\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: result\n\t\t\t};\n\t\t}\n\n\t\t// For CLI, display output\n\t\tconsole.log(chalk.green('Operation completed successfully!'));\n\t} catch (error) {\n\t\t// Handle errors based on source\n\t\tif (options.source === 'mcp') {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message\n\t\t\t};\n\t\t}\n\n\t\t// CLI error handling\n\t\tconsole.error(chalk.red(`Error: ${error.message}`));\n\t\tprocess.exit(1);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Client with stdio Transport in TypeScript\nDESCRIPTION: Demonstrates how to set up an MCP client using the stdio transport in TypeScript. The code initializes a client with name and version, then connects it to a server command via stdio transport with command arguments.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = new Client({\n  name: \"example-client\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {}\n});\n\nconst transport = new StdioClientTransport({\n  command: \"./server\",\n  args: [\"--option\", \"value\"]\n});\nawait client.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Defining CompleteRequest and CompleteResult Structures in JSON\nDESCRIPTION: Defines the structure for CompleteRequest and CompleteResult objects used in the protocol. CompleteRequest includes a reference and an argument object, while CompleteResult contains a completion object with values, total, and hasMore properties.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_34\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"CompleteRequest\": {\n    \"ref\": \"PromptReference or ResourceReference\",\n    \"argument\": {\n      \"name\": \"Argument name\",\n      \"value\": \"Current value\"\n    }\n  },\n  \"CompleteResult\": {\n    \"completion\": {\n      \"values\": [\"Array of suggestions (max 100)\"],\n      \"total\": \"Optional total matches\",\n      \"hasMore\": \"Additional results flag\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LLM Sampling Interfaces for Client-Server Communication\nDESCRIPTION: TypeScript interfaces for requesting and receiving sampled messages from language models. Includes structures for message creation requests with model preferences and content formatting for both text and image data.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_152\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CreateMessageRequest extends Request {\n  method: \"sampling/createMessage\";\n  params: {\n    messages: SamplingMessage[];\n    /**\n     * The server's preferences for which model to select. The client MAY ignore these preferences.\n     */\n    modelPreferences?: ModelPreferences;\n    /**\n     * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.\n     */\n    systemPrompt?: string;\n    /**\n     * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.\n     */\n    includeContext?: \"none\" | \"thisServer\" | \"allServers\";\n    /**\n     * @TJS-type number\n     */\n    temperature?: number;\n    /**\n     * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.\n     */\n    maxTokens: number;\n    stopSequences?: string[];\n    /**\n     * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.\n     */\n    metadata?: object;\n  };\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CreateMessageResult extends Result, SamplingMessage {\n  /**\n   * The name of the model that generated the message.\n   */\n  model: string;\n  /**\n   * The reason why sampling stopped, if known.\n   */\n  stopReason?: \"endTurn\" | \"stopSequence\" | \"maxTokens\" | string;\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SamplingMessage {\n  role: Role;\n  content: TextContent | ImageContent;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Resource and Resource Template Schemas\nDESCRIPTION: Schemas for resources and resource templates. Resources have URI, name, description, and MIME type. Templates define patterns for constructing resource URIs using RFC 6570 URI templates, with metadata to explain their purpose.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_201\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * A known resource that the server is capable of reading.\n */\nexport const ResourceSchema = z\n  .object({\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n\n    /**\n     * A human-readable name for this resource.\n     *\n     * This can be used by clients to populate UI elements.\n     */\n    name: z.string(),\n\n    /**\n     * A description of what this resource represents.\n     *\n     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model.\n     */\n    description: z.optional(z.string()),\n\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n  })\n  .passthrough();\n\n/**\n * A template description for resources available on the server.\n */\nexport const ResourceTemplateSchema = z\n  .object({\n    /**\n     * A URI template (according to RFC 6570) that can be used to construct resource URIs.\n     */\n    uriTemplate: z.string(),\n\n    /**\n     * A human-readable name for the type of resource this template refers to.\n     *\n     * This can be used by clients to populate UI elements.\n     */\n    name: z.string(),\n\n    /**\n     * A description of what this template is for.\n     *\n     * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model.\n     */\n    description: z.optional(z.string()),\n\n    /**\n     * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.\n     */\n    mimeType: z.optional(z.string()),\n  })\n  .passthrough();\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Reference Schema in TypeScript with Zod\nDESCRIPTION: This snippet defines a Zod schema for a resource reference, which includes a type and URI. It's part of the larger MCP type system used for client-server communication.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_215\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const ResourceReferenceSchema = z\n  .object({\n    type: z.literal(\"ref/resource\"),\n    /**\n     * The URI or URI template of the resource.\n     */\n    uri: z.string(),\n  })\n  .passthrough();\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON-RPC Message Buffer and Serialization in TypeScript\nDESCRIPTION: Implementation of a buffer class for handling JSON-RPC messages over a continuous stream. Includes methods for message serialization, deserialization, and buffer management.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_180\n\nLANGUAGE: typescript\nCODE:\n```\nimport { JSONRPCMessage, JSONRPCMessageSchema } from \"../types.js\";\n\n/**\n * Buffers a continuous stdio stream into discrete JSON-RPC messages.\n */\nexport class ReadBuffer {\n  private _buffer?: Buffer;\n\n  append(chunk: Buffer): void {\n    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;\n  }\n\n  readMessage(): JSONRPCMessage | null {\n    if (!this._buffer) {\n      return null;\n    }\n\n    const index = this._buffer.indexOf(\"\\n\");\n    if (index === -1) {\n      return null;\n    }\n\n    const line = this._buffer.toString(\"utf8\", 0, index);\n    this._buffer = this._buffer.subarray(index + 1);\n    return deserializeMessage(line);\n  }\n\n  clear(): void {\n    this._buffer = undefined;\n  }\n}\n\nexport function deserializeMessage(line: string): JSONRPCMessage {\n  return JSONRPCMessageSchema.parse(JSON.parse(line));\n}\n\nexport function serializeMessage(message: JSONRPCMessage): string {\n  return JSON.stringify(message) + \"\\n\";\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Client with SSE Transport in TypeScript\nDESCRIPTION: Demonstrates how to set up an MCP client using Server-Sent Events (SSE) transport in TypeScript. The code initializes a client with name and version, then connects it to a server URL using the SSE transport.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = new Client({\n  name: \"example-client\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {}\n});\n\nconst transport = new SSEClientTransport(\n  new URL(\"http://localhost:3000/sse\")\n);\nawait client.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Implementing Prompts in MCP Server (TypeScript)\nDESCRIPTION: TypeScript example of implementing prompts in an MCP server, including handlers for listing prompts and getting specific prompts. It demonstrates how to define prompts, handle requests, and generate prompt messages.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Server } from \"@modelcontextprotocol/sdk/server\";\nimport {\n  ListPromptsRequestSchema,\n  GetPromptRequestSchema\n} from \"@modelcontextprotocol/sdk/types\";\n\nconst PROMPTS = {\n  \"git-commit\": {\n    name: \"git-commit\",\n    description: \"Generate a Git commit message\",\n    arguments: [\n      {\n        name: \"changes\",\n        description: \"Git diff or description of changes\",\n        required: true\n      }\n    ]\n  },\n  \"explain-code\": {\n    name: \"explain-code\",\n    description: \"Explain how code works\",\n    arguments: [\n      {\n        name: \"code\",\n        description: \"Code to explain\",\n        required: true\n      },\n      {\n        name: \"language\",\n        description: \"Programming language\",\n        required: false\n      }\n    ]\n  }\n};\n\nconst server = new Server({\n  name: \"example-prompts-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {\n    prompts: {}\n  }\n});\n\n// List available prompts\nserver.setRequestHandler(ListPromptsRequestSchema, async () => {\n  return {\n    prompts: Object.values(PROMPTS)\n  };\n});\n\n// Get specific prompt\nserver.setRequestHandler(GetPromptRequestSchema, async (request) => {\n  const prompt = PROMPTS[request.params.name];\n  if (!prompt) {\n    throw new Error(`Prompt not found: ${request.params.name}`);\n  }\n\n  if (request.params.name === \"git-commit\") {\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Generate a concise but descriptive commit message for these changes:\\n\\n${request.params.arguments?.changes}`\n          }\n        }\n      ]\n    };\n  }\n\n  if (request.params.name === \"explain-code\") {\n    const language = request.params.arguments?.language || \"Unknown\";\n    return {\n      messages: [\n        {\n          role: \"user\",\n          content: {\n            type: \"text\",\n            text: `Explain how this ${language} code works:\\n\\n${request.params.arguments?.code}`\n          }\n        }\n      ]\n    };\n  }\n\n  throw new Error(\"Prompt implementation not found\");\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing an MCP Client with stdio Transport\nDESCRIPTION: Shows how to create an MCP client that communicates with a server via stdio. Demonstrates connecting to a server and using various capabilities including listing and retrieving prompts, accessing resources, and calling tools.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_236\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\n\nconst transport = new StdioClientTransport({\n  command: \"node\",\n  args: [\"server.js\"]\n});\n\nconst client = new Client(\n  {\n    name: \"example-client\",\n    version: \"1.0.0\"\n  },\n  {\n    capabilities: {\n      prompts: {},\n      resources: {},\n      tools: {}\n    }\n  }\n);\n\nawait client.connect(transport);\n\n// List prompts\nconst prompts = await client.listPrompts();\n\n// Get a prompt\nconst prompt = await client.getPrompt(\"example-prompt\", {\n  arg1: \"value\"\n});\n\n// List resources\nconst resources = await client.listResources();\n\n// Read a resource\nconst resource = await client.readResource(\"file:///example.txt\");\n\n// Call a tool\nconst result = await client.callTool({\n  name: \"example-tool\",\n  arguments: {\n    arg1: \"value\"\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating AI Operations with AsyncOperationManager for Progress Reporting - JavaScript\nDESCRIPTION: Shows how to wrap a direct AI operation in AsyncOperationManager to orchestrate execution, progress reporting, and error/result handling. Requires AsyncOperationManager, StatusCodes, and a direct AI function. This design lets long-running jobs be tracked and reported in real time, providing immediate operation IDs and well-structured responses.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/ai-client-utils-example.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// In your MCP tool implementation:\nimport {\n\tAsyncOperationManager,\n\tStatusCodes\n} from '../../utils/async-operation-manager.js';\nimport { someAiOperationDirect } from '../../core/direct-functions/some-ai-operation.js';\n\nexport async function someAiOperation(args, context) {\n\tconst { session, mcpLog } = context;\n\tconst log = mcpLog || console;\n\n\ttry {\n\t\t// Create operation description\n\t\tconst operationDescription = `AI operation: ${args.someParam}`;\n\n\t\t// Start async operation\n\t\tconst operation = AsyncOperationManager.createOperation(\n\t\t\toperationDescription,\n\t\t\tasync (reportProgress) => {\n\t\t\t\ttry {\n\t\t\t\t\t// Initial progress report\n\t\t\t\t\treportProgress({\n\t\t\t\t\t\tprogress: 0,\n\t\t\t\t\t\tstatus: 'Starting AI operation...'\n\t\t\t\t\t});\n\n\t\t\t\t\t// Call direct function with session and progress reporting\n\t\t\t\t\tconst result = await someAiOperationDirect(args, log, {\n\t\t\t\t\t\treportProgress,\n\t\t\t\t\t\tmcpLog: log,\n\t\t\t\t\t\tsession\n\t\t\t\t\t});\n\n\t\t\t\t\t// Final progress update\n\t\t\t\t\treportProgress({\n\t\t\t\t\t\tprogress: 100,\n\t\t\t\t\t\tstatus: result.success ? 'Operation completed' : 'Operation failed',\n\t\t\t\t\t\tresult: result.data,\n\t\t\t\t\t\terror: result.error\n\t\t\t\t\t});\n\n\t\t\t\t\treturn result;\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Handle errors in the operation\n\t\t\t\t\treportProgress({\n\t\t\t\t\t\tprogress: 100,\n\t\t\t\t\t\tstatus: 'Operation failed',\n\t\t\t\t\t\terror: {\n\t\t\t\t\t\t\tmessage: error.message,\n\t\t\t\t\t\t\tcode: error.code || 'OPERATION_FAILED'\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// Return immediate response with operation ID\n\t\treturn {\n\t\t\tstatus: StatusCodes.ACCEPTED,\n\t\t\tbody: {\n\t\t\t\tsuccess: true,\n\t\t\t\tmessage: 'Operation started',\n\t\t\t\toperationId: operation.id\n\t\t\t}\n\t\t};\n\t} catch (error) {\n\t\t// Handle errors in the MCP tool\n\t\tlog.error(`Error in someAiOperation: ${error.message}`);\n\t\treturn {\n\t\t\tstatus: StatusCodes.INTERNAL_SERVER_ERROR,\n\t\t\tbody: {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'OPERATION_FAILED',\n\t\t\t\t\tmessage: error.message\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LoggingLevel Types in TypeScript Protocol\nDESCRIPTION: TypeScript definition of logging severity levels following RFC-5424 syslog message severities. These levels range from debug (least severe) to emergency (most severe) and are used for server-to-client log message notifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_151\n\nLANGUAGE: typescript\nCODE:\n```\nexport type LoggingLevel =\n  | \"debug\"\n  | \"info\"\n  | \"notice\"\n  | \"warning\"\n  | \"error\"\n  | \"critical\"\n  | \"alert\"\n  | \"emergency\";\n```\n\n----------------------------------------\n\nTITLE: Defining Data Processing Tool in TypeScript\nDESCRIPTION: Shows a tool definition for analyzing CSV files. It includes the tool's name, description, and input schema for specifying file path and analysis operations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  name: \"analyze_csv\",\n  description: \"Analyze a CSV file\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      filepath: { type: \"string\" },\n      operations: {\n        type: \"array\",\n        items: {\n          enum: [\"sum\", \"average\", \"count\"]\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP General Architecture with Mermaid\nDESCRIPTION: This Mermaid diagram illustrates the general architecture of MCP, showing the relationships between the host with MCP client, multiple MCP servers, and various data sources both local and remote.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_62\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\n    subgraph \"Your Computer\"\n        Host[\"Host with MCP Client\\n(Claude, IDEs, Tools)\"]\n        S1[\"MCP Server A\"]\n        S2[\"MCP Server B\"]\n        S3[\"MCP Server C\"]\n        Host <-->|\"MCP Protocol\"| S1\n        Host <-->|\"MCP Protocol\"| S2\n        Host <-->|\"MCP Protocol\"| S3\n        S1 <--> D1[(\"Local\\nData Source A\")]\n        S2 <--> D2[(\"Local\\nData Source B\")]\n    end\n    subgraph \"Internet\"\n        S3 <-->|\"Web APIs\"| D3[(\"Remote\\nService C\")]\n    end\n```\n\n----------------------------------------\n\nTITLE: Creating and Connecting FastMCP Client using SSE Transport in TypeScript\nDESCRIPTION: Initializes a new FastMCP `Client` instance with specific client metadata (name, version) and capabilities. It then creates an `SSEClientTransport` pointing to the server's SSE endpoint URL. Finally, it connects the client to the server using the configured transport via `client.connect(transport)`.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = new Client(\n  {\n    name: \"example-client\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {},\n  },\n);\n\nconst transport = new SSEClientTransport(\n  new URL(`http://localhost:${port}/sse`),\n);\n\nawait client.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Class in TypeScript\nDESCRIPTION: This snippet shows the constructor of the FastMCP class. It initializes various properties, sets up handlers, and processes input tools, resources, and prompts.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconstructor({\n    name,\n    version,\n    auth,\n    tools,\n    resources,\n    resourcesTemplates,\n    prompts,\n  }) {\n    super();\n\n    this.#auth = auth;\n\n    if (tools.length) {\n      this.#capabilities.tools = {};\n    }\n\n    if (resources.length || resourcesTemplates.length) {\n      this.#capabilities.resources = {};\n    }\n\n    if (prompts.length) {\n      for (const prompt of prompts) {\n        this.addPrompt(prompt);\n      }\n\n      this.#capabilities.prompts = {};\n    }\n\n    this.#capabilities.logging = {};\n\n    this.#server = new Server(\n      { name: name, version: version },\n      { capabilities: this.#capabilities },\n    );\n\n    this.setupErrorHandling();\n    this.setupLoggingHandlers();\n    this.setupRootsHandlers();\n    this.setupCompleteHandlers();\n\n    if (tools.length) {\n      this.setupToolHandlers(tools);\n    }\n\n    if (resources.length || resourcesTemplates.length) {\n      for (const resource of resources) {\n        this.addResource(resource);\n      }\n\n      this.setupResourceHandlers(resources);\n\n      if (resourcesTemplates.length) {\n        for (const resourceTemplate of resourcesTemplates) {\n          this.addResourceTemplate(resourceTemplate);\n        }\n\n        this.setupResourceTemplateHandlers(resourcesTemplates);\n      }\n    }\n\n    if (prompts.length) {\n      this.setupPromptHandlers(prompts);\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Initialize Result Schema for Model Context Protocol\nDESCRIPTION: Schema for server response after receiving an initialization request from the client. Includes protocol version, server capabilities, server information, and optional instructions for using the server and its features.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_195\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * After receiving an initialize request from the client, the server sends this response.\n */\nexport const InitializeResultSchema = ResultSchema.extend({\n  /**\n   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.\n   */\n  protocolVersion: z.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ImplementationSchema,\n  /**\n   * Instructions describing how to use the server and its features.\n   *\n   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a \"hint\" to the model. For example, this information MAY be added to the system prompt.\n   */\n  instructions: z.optional(z.string()),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Specific Messages in TypeScript for MCP\nDESCRIPTION: Defines interfaces for core protocol functionality including empty results, cancellation notifications, and initialization messages that establish the connection between client and server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_161\n\nLANGUAGE: typescript\nCODE:\n```\n/* Empty result */\n/**\n * A response that indicates success but carries no data.\n */\nexport type EmptyResult = Result;\n\n/* Cancellation */\n/**\n * This notification can be sent by either side to indicate that it is cancelling a previously-issued request.\n *\n * The request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.\n *\n * This notification indicates that the result will be unused, so any associated processing SHOULD cease.\n *\n * A client MUST NOT attempt to cancel its `initialize` request.\n */\nexport interface CancelledNotification extends Notification {\n  method: \"notifications/cancelled\";\n  params: {\n    /**\n     * The ID of the request to cancel.\n     *\n     * This MUST correspond to the ID of a request previously issued in the same direction.\n     */\n    requestId: RequestId;\n\n    /**\n     * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.\n     */\n    reason?: string;\n  };\n}\n\n/* Initialization */\n/**\n * This request is sent from the client to the server when it first connects, asking it to begin initialization.\n */\nexport interface InitializeRequest extends Request {\n  method: \"initialize\";\n  params: {\n    /**\n     * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.\n     */\n    protocolVersion: string;\n    capabilities: ClientCapabilities;\n    clientInfo: Implementation;\n  };\n}\n\n/**\n * After receiving an initialize request from the client, the server sends this response.\n */\nexport interface InitializeResult extends Result {\n  /**\n   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.\n   */\n  protocolVersion: string;\n  capabilities: ServerCapabilities;\n  serverInfo: Implementation;\n\n  /**\n   * Instructions describing how to use the server and its features.\n   *\n   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a \"hint\" to the model. For example, this information MAY be added to the system prompt.\n   */\n  instructions?: string;\n}\n\n/**\n * This notification is sent from the client to the server after initialization has finished.\n */\nexport interface InitializedNotification extends Notification {\n  method: \"notifications/initialized\";\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP for Task Master in JSON\nDESCRIPTION: JSON configuration for Model Control Protocol (MCP) to set up Task Master in the editor. Includes environment variables for API keys and model settings.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n\t\"mcpServers\": {\n\t\t\"taskmaster-ai\": {\n\t\t\t\"command\": \"npx\",\n\t\t\t\"args\": [\"-y\", \"--package=task-master-ai\", \"task-master-ai\"],\n\t\t\t\"env\": {\n\t\t\t\t\"ANTHROPIC_API_KEY\": \"YOUR_ANTHROPIC_API_KEY_HERE\",\n\t\t\t\t\"PERPLEXITY_API_KEY\": \"YOUR_PERPLEXITY_API_KEY_HERE\",\n\t\t\t\t\"MODEL\": \"claude-3-7-sonnet-20250219\",\n\t\t\t\t\"PERPLEXITY_MODEL\": \"sonar-pro\",\n\t\t\t\t\"MAX_TOKENS\": \"64000\",\n\t\t\t\t\"TEMPERATURE\": \"0.2\",\n\t\t\t\t\"DEFAULT_SUBTASKS\": \"5\",\n\t\t\t\t\"DEFAULT_PRIORITY\": \"medium\"\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuth Token Revocation Handler in TypeScript\nDESCRIPTION: This code defines a revocation handler for OAuth tokens that validates requests, authenticates clients, and delegates token revocation to a provider. It includes CORS support, rate limiting, and proper error handling according to OAuth standards.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_64\n\nLANGUAGE: typescript\nCODE:\n```\nexport function revocationHandler({ provider, rateLimit: rateLimitConfig }: RevocationHandlerOptions): RequestHandler {\n  if (!provider.revokeToken) {\n    throw new Error(\"Auth provider does not support revoking tokens\");\n  }\n\n  // Nested router so we can configure middleware and restrict HTTP method\n  const router = express.Router();\n\n  // Configure CORS to allow any origin, to make accessible to web-based MCP clients\n  router.use(cors());\n\n  router.use(allowedMethods([\"POST\"]));\n  router.use(express.urlencoded({ extended: false }));\n\n  // Apply rate limiting unless explicitly disabled\n  if (rateLimitConfig !== false) {\n    router.use(rateLimit({\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      max: 50, // 50 requests per windowMs\n      standardHeaders: true,\n      legacyHeaders: false,\n      message: new TooManyRequestsError('You have exceeded the rate limit for token revocation requests').toResponseObject(),\n      ...rateLimitConfig\n    }));\n  }\n\n  // Authenticate and extract client details\n  router.use(authenticateClient({ clientsStore: provider.clientsStore }));\n\n  router.post(\"/\", async (req, res) => {\n    res.setHeader('Cache-Control', 'no-store');\n\n    try {\n      const parseResult = OAuthTokenRevocationRequestSchema.safeParse(req.body);\n      if (!parseResult.success) {\n        throw new InvalidRequestError(parseResult.error.message);\n      }\n\n      const client = req.client;\n      if (!client) {\n        // This should never happen\n        console.error(\"Missing client information after authentication\");\n        throw new ServerError(\"Internal Server Error\");\n      }\n\n      await provider.revokeToken!(client, parseResult.data);\n      res.status(200).json({});\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400;\n        res.status(status).json(error.toResponseObject());\n      } else {\n        console.error(\"Unexpected error revoking token:\", error);\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.status(500).json(serverError.toResponseObject());\n      }\n    }\n  });\n\n  return router;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Server with stdio Transport in Python\nDESCRIPTION: Demonstrates how to set up an MCP server using the stdio transport in Python. The code initializes a server and runs it using streams provided by the stdio_server context manager.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_40\n\nLANGUAGE: python\nCODE:\n```\napp = Server(\"example-server\")\n\nasync with stdio_server() as streams:\n    await app.run(\n        streams[0],\n        streams[1],\n        app.create_initialization_options()\n    )\n```\n\n----------------------------------------\n\nTITLE: Handling JSON-RPC Protocol Requests and Notifications in TypeScript\nDESCRIPTION: Methods for registering, handling, and removing request and notification handlers for a JSON-RPC protocol implementation. Includes capability assertion and request validation using Zod schema.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_177\n\nLANGUAGE: typescript\nCODE:\n```\n  /**\n   * Registers a handler to invoke when this protocol object receives a request with the given method.\n   *\n   * Note that this will replace any previous request handler for the same method.\n   */\n  setRequestHandler<\n    T extends ZodObject<{\n      method: ZodLiteral<string>;\n    }>,\n  >(\n    requestSchema: T,\n    handler: (\n      request: z.infer<T>,\n      extra: RequestHandlerExtra,\n    ) => SendResultT | Promise<SendResultT>,\n  ): void {\n    const method = requestSchema.shape.method.value;\n    this.assertRequestHandlerCapability(method);\n    this._requestHandlers.set(method, (request, extra) =>\n      Promise.resolve(handler(requestSchema.parse(request), extra)),\n    );\n  }\n\n  /**\n   * Removes the request handler for the given method.\n   */\n  removeRequestHandler(method: string): void {\n    this._requestHandlers.delete(method);\n  }\n\n  /**\n   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.\n   */\n  assertCanSetRequestHandler(method: string): void {\n    if (this._requestHandlers.has(method)) {\n      throw new Error(\n        `A request handler for ${method} already exists, which would be overridden`,\n      );\n    }\n  }\n\n  /**\n   * Registers a handler to invoke when this protocol object receives a notification with the given method.\n   *\n   * Note that this will replace any previous notification handler for the same method.\n   */\n  setNotificationHandler<\n    T extends ZodObject<{\n      method: ZodLiteral<string>;\n    }>,\n  >(\n    notificationSchema: T,\n    handler: (notification: z.infer<T>) => void | Promise<void>,\n  ): void {\n    this._notificationHandlers.set(\n      notificationSchema.shape.method.value,\n      (notification) =>\n        Promise.resolve(handler(notificationSchema.parse(notification))),\n    );\n  }\n\n  /**\n   * Removes the notification handler for the given method.\n   */\n  removeNotificationHandler(method: string): void {\n    this._notificationHandlers.delete(method);\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining List Roots Request and Result Schemas in TypeScript with Zod\nDESCRIPTION: These snippets define Zod schemas for requesting a list of root URIs from the client and the corresponding response. They extend the base RequestSchema and ResultSchema respectively.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_220\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const ListRootsRequestSchema = RequestSchema.extend({\n  method: z.literal(\"roots/list\"),\n});\n\nexport const ListRootsResultSchema = ResultSchema.extend({\n  roots: z.array(RootSchema),\n});\n```\n\n----------------------------------------\n\nTITLE: Executing PRD Parsing with Task Master AI - Bash\nDESCRIPTION: This bash snippet shows how to invoke Task Master AI from the command line to parse a Product Requirements Document (PRD). It reads the specified PRD file, generates a structured tasks.json, and populates it with tasks, dependencies, priorities, and test strategies. This step establishes the foundational input for downstream task management workflow.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntask-master parse-prd scripts/prd.txt\n```\n\n----------------------------------------\n\nTITLE: Interactive Chat Interface Implementation\nDESCRIPTION: Implementation of the chat loop and cleanup functionality for the MCP client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\nasync chatLoop() {\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  try {\n    console.log(\"\\nMCP Client Started!\");\n    console.log(\"Type your queries or 'quit' to exit.\");\n\n    while (true) {\n      const message = await rl.question(\"\\nQuery: \");\n      if (message.toLowerCase() === \"quit\") {\n        break;\n      }\n      const response = await this.processQuery(message);\n      console.log(\"\\n\" + response);\n    }\n  } finally {\n    rl.close();\n  }\n}\n\nasync cleanup() {\n  await this.mcp.close();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Standard MCP Error Codes in TypeScript\nDESCRIPTION: TypeScript enum `ErrorCode` defining standard JSON-RPC 2.0 error codes used within the Model Context Protocol (MCP). This includes codes for Parse Error, Invalid Request, Method Not Found, Invalid Params, and Internal Error.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\nenum ErrorCode {\n  // Standard JSON-RPC error codes\n  ParseError = -32700,\n  InvalidRequest = -32600,\n  MethodNotFound = -32601,\n  InvalidParams = -32602,\n  InternalError = -32603\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Up Tool Handlers in FastMCP\nDESCRIPTION: This method sets up handlers for listing and calling tools. It includes parameter validation and progress reporting functionality.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nprivate setupToolHandlers(tools: Tool<T>[]) {\n    this.#server.setRequestHandler(ListToolsRequestSchema, async () => {\n      return {\n        tools: tools.map((tool) => {\n          return {\n            name: tool.name,\n            description: tool.description,\n            inputSchema: tool.parameters\n              ? zodToJsonSchema(tool.parameters)\n              : undefined,\n          };\n        }),\n      };\n    });\n\n    this.#server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const tool = tools.find((tool) => tool.name === request.params.name);\n\n      if (!tool) {\n        throw new McpError(\n          ErrorCode.MethodNotFound,\n          `Unknown tool: ${request.params.name}`,\n        );\n      }\n\n      let args: any = undefined;\n\n      if (tool.parameters) {\n        const parsed = tool.parameters.safeParse(request.params.arguments);\n\n        if (!parsed.success) {\n          throw new McpError(\n            ErrorCode.InvalidParams,\n            `Invalid ${request.params.name} parameters`,\n          );\n        }\n\n        args = parsed.data;\n      }\n\n      const progressToken = request.params?._meta?.progressToken;\n\n      let result: ContentResult;\n\n      try {\n        const reportProgress = async (progress: Progress) => {\n          await this.#server.notification({\n            method: \"notifications/progress\",\n            params: {\n              ...progress,\n              progressToken,\n            },\n          });\n        };\n\n        const log = {\n          debug: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              level: \"debug\",\n              data: {\n                message,\n                context,\n              },\n            });\n          },\n          error: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              level: \"error\",\n              data: {\n                message,\n                context,\n              },\n            });\n          },\n          info: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              level: \"info\",\n              data: {\n                message,\n                context,\n              },\n            });\n          },\n          warn: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              level: \"warning\",\n              data: {\n```\n\n----------------------------------------\n\nTITLE: Mermaid Sequence Diagram for stdio Transport Flow\nDESCRIPTION: Mermaid sequence diagram illustrating the communication flow between client and server in the stdio transport. It shows how the client launches the server subprocess and communicates via stdin/stdout while optionally receiving logs via stderr.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_95\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server Process\n\n    Client->>+Server Process: Launch subprocess\n    loop Message Exchange\n        Client->>Server Process: Write to stdin\n        Server Process->>Client: Write to stdout\n        Server Process--)Client: Optional logs on stderr\n    end\n    Client->>Server Process: Close stdin, terminate subprocess\n    deactivate Server Process\n```\n\n----------------------------------------\n\nTITLE: Initialize Response in MCP Protocol\nDESCRIPTION: JSON-RPC response from the server to the client's initialize request. Contains protocol version, server capabilities for logging, prompts, resources, and tools, along with server information including name and version.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_92\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"protocolVersion\": \"2024-11-05\",\n    \"capabilities\": {\n      \"logging\": {},\n      \"prompts\": {\n        \"listChanged\": true\n      },\n      \"resources\": {\n        \"subscribe\": true,\n        \"listChanged\": true\n      },\n      \"tools\": {\n        \"listChanged\": true\n      }\n    },\n    \"serverInfo\": {\n      \"name\": \"ExampleServer\",\n      \"version\": \"1.0.0\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Language Model Generation in JSON\nDESCRIPTION: JSON request for creating a sampling message, including messages, model preferences, and system prompt.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_26\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"sampling/createMessage\",\n  \"params\": {\n    \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": {\n          \"type\": \"text\",\n          \"text\": \"What is the capital of France?\"\n        }\n      }\n    ],\n    \"modelPreferences\": {\n      \"hints\": [\n        {\n          \"name\": \"claude-3-sonnet\"\n        }\n      ],\n      \"intelligencePriority\": 0.8,\n      \"speedPriority\": 0.5\n    },\n    \"systemPrompt\": \"You are a helpful assistant.\",\n    \"maxTokens\": 100\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Asynchronous MCP Client with Reactive Programming in Java\nDESCRIPTION: Creates and configures an asynchronous MCP client using reactive programming patterns. The example demonstrates reactive initialization, tool execution, resource access, prompt handling, and roots management with custom change consumers for each feature.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_119\n\nLANGUAGE: java\nCODE:\n```\n// Create an async client with custom configuration\nMcpAsyncClient client = McpClient.async(transport)\n    .requestTimeout(Duration.ofSeconds(10))\n    .capabilities(ClientCapabilities.builder()\n        .roots(true)      // Enable roots capability\n        .sampling()       // Enable sampling capability\n        .build())\n    .sampling(request -> Mono.just(new CreateMessageResult(response)))\n    .toolsChangeConsumer(tools -> Mono.fromRunnable(() -> {\n        logger.info(\"Tools updated: {}\", tools);\n    }))\n    .resourcesChangeConsumer(resources -> Mono.fromRunnable(() -> {\n        logger.info(\"Resources updated: {}\", resources);\n    }))\n    .promptsChangeConsumer(prompts -> Mono.fromRunnable(() -> {\n        logger.info(\"Prompts updated: {}\", prompts);\n    }))\n    .build();\n\n// Initialize connection and use features\nclient.initialize()\n    .flatMap(initResult -> client.listTools())\n    .flatMap(tools -> {\n        return client.callTool(new CallToolRequest(\n            \"calculator\", \n            Map.of(\"operation\", \"add\", \"a\", 2, \"b\", 3)\n        ));\n    })\n    .flatMap(result -> {\n        return client.listResources()\n            .flatMap(resources -> \n                client.readResource(new ReadResourceRequest(\"resource://uri\"))\n            );\n    })\n    .flatMap(resource -> {\n        return client.listPrompts()\n            .flatMap(prompts ->\n                client.getPrompt(new GetPromptRequest(\n                    \"greeting\", \n                    Map.of(\"name\", \"Spring\")\n                ))\n            );\n    })\n    .flatMap(prompt -> {\n        return client.addRoot(new Root(\"file:///path\", \"description\"))\n            .then(client.removeRoot(\"file:///path\"));\n    })\n    .doFinally(signalType -> {\n        client.closeGracefully().subscribe();\n    })\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Defining MCP Error Message Structure in TypeScript\nDESCRIPTION: TypeScript interface defining the structure of an MCP Error message, sent in response to a failed Request. It includes a mandatory numeric `code`, a mandatory `message` string, and optional `data` for additional error details.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\ninterface Error {\n  code: number;\n  message: string;\n  data?: unknown;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: MCP Sampling Request Format in TypeScript\nDESCRIPTION: Defines the structure of a sampling request in MCP. It includes fields for messages, model preferences, system prompt, context inclusion, and various sampling parameters.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  messages: [\n    {\n      role: \"user\" | \"assistant\",\n      content: {\n        type: \"text\" | \"image\",\n\n        // For text:\n        text?: string,\n\n        // For images:\n        data?: string,             // base64 encoded\n        mimeType?: string\n      }\n    }\n  ],\n  modelPreferences?: {\n    hints?: [{\n      name?: string                // Suggested model name/family\n    }],\n    costPriority?: number,         // 0-1, importance of minimizing cost\n    speedPriority?: number,        // 0-1, importance of low latency\n    intelligencePriority?: number  // 0-1, importance of capabilities\n  },\n  systemPrompt?: string,\n  includeContext?: \"none\" | \"thisServer\" | \"allServers\",\n  temperature?: number,\n  maxTokens: number,\n  stopSequences?: string[],\n  metadata?: Record<string, unknown>\n}\n```\n\n----------------------------------------\n\nTITLE: Resource Template Class Implementation\nDESCRIPTION: Class implementation for managing URI templates with completion and listing callbacks for resource handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_149\n\nLANGUAGE: typescript\nCODE:\n```\nexport class ResourceTemplate {\n  private _uriTemplate: UriTemplate;\n\n  constructor(\n    uriTemplate: string | UriTemplate,\n    private _callbacks: {\n      list: ListResourcesCallback | undefined;\n      complete?: {\n        [variable: string]: CompleteResourceTemplateCallback;\n      };\n    },\n  ) {\n    this._uriTemplate =\n      typeof uriTemplate === \"string\"\n        ? new UriTemplate(uriTemplate)\n        : uriTemplate;\n  }\n\n  get uriTemplate(): UriTemplate {\n    return this._uriTemplate;\n  }\n\n  get listCallback(): ListResourcesCallback | undefined {\n    return this._callbacks.list;\n  }\n\n  completeCallback(\n    variable: string,\n  ): CompleteResourceTemplateCallback | undefined {\n    return this._callbacks.complete?.[variable];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Support in TypeScript MCP Server\nDESCRIPTION: Demonstrates how to implement basic resource support in an MCP server using TypeScript. It includes handlers for listing available resources and reading resource contents.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new Server({\n  name: \"example-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {\n    resources: {}\n  }\n});\n\n// List available resources\nserver.setRequestHandler(ListResourcesRequestSchema, async () => {\n  return {\n    resources: [\n      {\n        uri: \"file:///logs/app.log\",\n        name: \"Application Logs\",\n        mimeType: \"text/plain\"\n      }\n    ]\n  };\n});\n\n// Read resource contents\nserver.setRequestHandler(ReadResourceRequestSchema, async (request) => {\n  const uri = request.params.uri;\n\n  if (uri === \"file:///logs/app.log\") {\n    const logContents = await readLogFile();\n    return {\n      contents: [\n        {\n          uri,\n          mimeType: \"text/plain\",\n          text: logContents\n        }\n      ]\n    };\n  }\n\n  throw new Error(\"Resource not found\");\n});\n```\n\n----------------------------------------\n\nTITLE: Defining JSON-RPC Types in TypeScript\nDESCRIPTION: Defines the basic types and interfaces for JSON-RPC messages, including requests, notifications, responses, and errors. It also sets constants for the protocol version and JSON-RPC version.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_140\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type JSONRPCMessage =\n  | JSONRPCRequest\n  | JSONRPCNotification\n  | JSONRPCResponse\n  | JSONRPCError;\n\nexport const LATEST_PROTOCOL_VERSION = \"2024-11-05\";\nexport const JSONRPC_VERSION = \"2.0\";\n\nexport type ProgressToken = string | number;\n\nexport type Cursor = string;\n\nexport interface Request {\n  method: string;\n  params?: {\n    _meta?: {\n      progressToken?: ProgressToken;\n    };\n    [key: string]: unknown;\n  };\n}\n\nexport interface Notification {\n  method: string;\n  params?: {\n    _meta?: { [key: string]: unknown };\n    [key: string]: unknown;\n  };\n}\n\nexport interface Result {\n  _meta?: { [key: string]: unknown };\n  [key: string]: unknown;\n}\n\nexport type RequestId = string | number;\n\nexport interface JSONRPCRequest extends Request {\n  jsonrpc: typeof JSONRPC_VERSION;\n  id: RequestId;\n}\n\nexport interface JSONRPCNotification extends Notification {\n  jsonrpc: typeof JSONRPC_VERSION;\n}\n\nexport interface JSONRPCResponse {\n  jsonrpc: typeof JSONRPC_VERSION;\n  id: RequestId;\n  result: Result;\n}\n\nexport const PARSE_ERROR = -32700;\nexport const INVALID_REQUEST = -32600;\nexport const METHOD_NOT_FOUND = -32601;\nexport const INVALID_PARAMS = -32602;\nexport const INTERNAL_ERROR = -32603;\n\nexport interface JSONRPCError {\n  jsonrpc: typeof JSONRPC_VERSION;\n  id: RequestId;\n  error: {\n    code: number;\n    message: string;\n    data?: unknown;\n  };\n}\n\nexport type EmptyResult = Result;\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC 2.0 Response Format in TypeScript\nDESCRIPTION: Definition of the response message format in the MCP protocol following JSON-RPC 2.0. Responses must include the same ID as the corresponding request and must set either a result or an error, but not both.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\";\n  id: string | number;\n  result?: {\n    [key: string]: unknown;\n  }\n  error?: {\n    code: number;\n    message: string;\n    data?: unknown;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: FastMCPSession Implementation with Event Handling\nDESCRIPTION: Defines the FastMCPSession class that manages AI model interactions. It handles capabilities, tools, resources, prompts, and logging while providing event-based communication. The constructor sets up the server and various handlers for error management, logging, and tool execution.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nexport class FastMCPSession<T extends FastMCPSessionAuth = FastMCPSessionAuth> extends FastMCPSessionEventEmitter {\n  #capabilities: ServerCapabilities = {};\n  #clientCapabilities?: ClientCapabilities;\n  #loggingLevel: LoggingLevel = \"info\";\n  #prompts: Prompt[] = [];\n  #resources: Resource[] = [];\n  #resourceTemplates: ResourceTemplate[] = [];\n  #roots: Root[] = [];\n  #server: Server;\n  #auth: T | undefined;\n\n  constructor({\n    auth,\n    name,\n    version,\n    tools,\n    resources,\n    resourcesTemplates,\n    prompts,\n  }: {\n    auth?: T;\n    name: string;\n    version: string;\n    tools: Tool<T>[];\n    resources: Resource[];\n    resourcesTemplates: InputResourceTemplate[];\n    prompts: Prompt[];\n  }) {\n    super();\n\n    this.#auth = auth;\n\n    if (tools.length) {\n      this.#capabilities.tools = {};\n    }\n\n    if (resources.length || resourcesTemplates.length) {\n      this.#capabilities.resources = {};\n    }\n\n    if (prompts.length) {\n      for (const prompt of prompts) {\n        this.addPrompt(prompt);\n      }\n\n      this.#capabilities.prompts = {};\n    }\n\n    this.#capabilities.logging = {};\n\n    this.#server = new Server(\n      { name: name, version: version },\n      { capabilities: this.#capabilities },\n    );\n\n    this.setupErrorHandling();\n    this.setupLoggingHandlers();\n    this.setupRootsHandlers();\n    this.setupCompleteHandlers();\n\n    if (tools.length) {\n      this.setupToolHandlers(tools);\n    }\n\n    if (resources.length || resourcesTemplates.length) {\n      for (const resource of resources) {\n        this.addResource(resource);\n      }\n\n      this.setupResourceHandlers(resources);\n\n      if (resourcesTemplates.length) {\n        for (const resourceTemplate of resourcesTemplates) {\n          this.addResourceTemplate(resourceTemplate);\n        }\n      }\n    }\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Prompts in MCP Server (Python)\nDESCRIPTION: Python example of implementing prompts in an MCP server, showcasing how to define prompts, handle list and get requests, and generate prompt messages. It uses the MCP SDK for Python.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom mcp.server import Server\nimport mcp.types as types\n\n# Define available prompts\nPROMPTS = {\n    \"git-commit\": types.Prompt(\n        name=\"git-commit\",\n        description=\"Generate a Git commit message\",\n        arguments=[\n            types.PromptArgument(\n                name=\"changes\",\n                description=\"Git diff or description of changes\",\n                required=True\n            )\n        ],\n    ),\n    \"explain-code\": types.Prompt(\n        name=\"explain-code\",\n        description=\"Explain how code works\",\n        arguments=[\n            types.PromptArgument(\n                name=\"code\",\n                description=\"Code to explain\",\n                required=True\n            ),\n            types.PromptArgument(\n                name=\"language\",\n                description=\"Programming language\",\n                required=False\n            )\n        ],\n    )\n}\n\n# Initialize server\napp = Server(\"example-prompts-server\")\n\n@app.list_prompts()\nasync def list_prompts() -> list[types.Prompt]:\n    return list(PROMPTS.values())\n\n@app.get_prompt()\nasync def get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -> types.GetPromptResult:\n    if name not in PROMPTS:\n        raise ValueError(f\"Prompt not found: {name}\")\n\n    if name == \"git-commit\":\n        changes = arguments.get(\"changes\") if arguments else \"\"\n        return types.GetPromptResult(\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(\n                        type=\"text\",\n                        text=f\"Generate a concise but descriptive commit message \"\n                        f\"for these changes:\\n\\n{changes}\"\n                    )\n                )\n            ]\n        )\n\n    if name == \"explain-code\":\n        code = arguments.get(\"code\") if arguments else \"\"\n        language = arguments.get(\"language\", \"Unknown\") if arguments else \"Unknown\"\n        return types.GetPromptResult(\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(\n                        type=\"text\",\n                        text=f\"Explain how this {language} code works:\\n\\n{code}\"\n                    )\n                )\n            ]\n        )\n\n    raise ValueError(\"Prompt implementation not found\")\n```\n\n----------------------------------------\n\nTITLE: Calling FastMCP Tool and Verifying Progress Reporting with Vitest in TypeScript\nDESCRIPTION: This snippet executes within a test run context. It uses a mock function `vi.fn()` to track progress reports. It calls the 'add' tool on the client with arguments { a: 1, b: 2 } and provides the mock function as the `onprogress` callback. Finally, it asserts using `vitest`'s `expect` that the `onProgress` mock function was called exactly once with the expected progress payload { progress: 0, total: 10 }.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst onProgress = vi.fn();\n\nawait client.callTool(\n  {\n    name: \"add\",\n    arguments: {\n      a: 1,\n      b: 2,\n    },\n  },\n  undefined,\n  {\n    onprogress: onProgress,\n  },\n);\n\nexpect(onProgress).toHaveBeenCalledTimes(1);\nexpect(onProgress).toHaveBeenCalledWith({\n  progress: 0,\n  total: 10,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Server Capabilities Schema in TypeScript with Zod\nDESCRIPTION: Defines server capabilities for resources and tools using Zod schema validation. This schema specifies whether the server supports subscribing to resource updates and notifications for changes to resource and tool lists.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_194\n\nLANGUAGE: TypeScript\nCODE:\n```\n    resources: z.optional(\n      z\n        .object({\n          /**\n           * Whether this server supports clients subscribing to resource updates.\n           */\n          subscribe: z.optional(z.boolean()),\n\n          /**\n           * Whether this server supports issuing notifications for changes to the resource list.\n           */\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n    /**\n     * Present if the server offers any tools to call.\n     */\n    tools: z.optional(\n      z\n        .object({\n          /**\n           * Whether this server supports issuing notifications for changes to the tool list.\n           */\n          listChanged: z.optional(z.boolean()),\n        })\n        .passthrough(),\n    ),\n  })\n  .passthrough();\n```\n\n----------------------------------------\n\nTITLE: MCP Client/Server CLI Implementation with Multiple Transport Options\nDESCRIPTION: A command-line interface for running Model Control Protocol (MCP) clients and servers with support for different transport mechanisms (WebSocket, SSE, and stdio). Includes setup for Express-based HTTP/SSE servers.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_190\n\nLANGUAGE: typescript\nCODE:\n```\nimport WebSocket from \"ws\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(global as any).WebSocket = WebSocket;\n\nimport express from \"express\";\nimport { Client } from \"./client/index.js\";\nimport { SSEClientTransport } from \"./client/sse.js\";\nimport { StdioClientTransport } from \"./client/stdio.js\";\nimport { WebSocketClientTransport } from \"./client/websocket.js\";\nimport { Server } from \"./server/index.js\";\nimport { SSEServerTransport } from \"./server/sse.js\";\nimport { StdioServerTransport } from \"./server/stdio.js\";\nimport { ListResourcesResultSchema } from \"./types.js\";\n\nasync function runClient(url_or_command: string, args: string[]) {\n  const client = new Client(\n    {\n      name: \"mcp-typescript test client\",\n      version: \"0.1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  let clientTransport;\n\n  let url: URL | undefined = undefined;\n  try {\n    url = new URL(url_or_command);\n  } catch {\n    // Ignore\n  }\n\n  if (url?.protocol === \"http:\" || url?.protocol === \"https:\") {\n    clientTransport = new SSEClientTransport(new URL(url_or_command));\n  } else if (url?.protocol === \"ws:\" || url?.protocol === \"wss:\") {\n    clientTransport = new WebSocketClientTransport(new URL(url_or_command));\n  } else {\n    clientTransport = new StdioClientTransport({\n      command: url_or_command,\n      args,\n    });\n  }\n\n  console.log(\"Connected to server.\");\n\n  await client.connect(clientTransport);\n  console.log(\"Initialized.\");\n\n  await client.request({ method: \"resources/list\" }, ListResourcesResultSchema);\n\n  await client.close();\n  console.log(\"Closed.\");\n}\n\nasync function runServer(port: number | null) {\n  if (port !== null) {\n    const app = express();\n\n    let servers: Server[] = [];\n\n    app.get(\"/sse\", async (req, res) => {\n      console.log(\"Got new SSE connection\");\n\n      const transport = new SSEServerTransport(\"/message\", res);\n      const server = new Server(\n        {\n          name: \"mcp-typescript test server\",\n          version: \"0.1.0\",\n        },\n        {\n          capabilities: {},\n        },\n      );\n\n      servers.push(server);\n\n      server.onclose = () => {\n        console.log(\"SSE connection closed\");\n        servers = servers.filter((s) => s !== server);\n      };\n\n      await server.connect(transport);\n    });\n\n    app.post(\"/message\", async (req, res) => {\n      console.log(\"Received message\");\n\n      const sessionId = req.query.sessionId as string;\n      const transport = servers\n        .map((s) => s.transport as SSEServerTransport)\n        .find((t) => t.sessionId === sessionId);\n      if (!transport) {\n        res.status(404).send(\"Session not found\");\n        return;\n      }\n\n      await transport.handlePostMessage(req, res);\n    });\n\n    app.listen(port, () => {\n      console.log(`Server running on http://localhost:${port}/sse`);\n    });\n  } else {\n    const server = new Server(\n      {\n        name: \"mcp-typescript test server\",\n        version: \"0.1.0\",\n      },\n      {\n        capabilities: {\n          prompts: {},\n          resources: {},\n          tools: {},\n          logging: {},\n        },\n      },\n    );\n\n    const transport = new StdioServerTransport();\n    await server.connect(transport);\n\n    console.log(\"Server running on stdio\");\n  }\n}\n\nconst args = process.argv.slice(2);\nconst command = args[0];\nswitch (command) {\n  case \"client\":\n    if (args.length < 2) {\n      console.error(\"Usage: client <server_url_or_command> [args...]\");\n      process.exit(1);\n    }\n\n    runClient(args[1], args.slice(2)).catch((error) => {\n      console.error(error);\n      process.exit(1);\n    });\n\n    break;\n\n  case \"server\": {\n    const port = args[1] ? parseInt(args[1]) : null;\n    runServer(port).catch((error) => {\n      console.error(error);\n      process.exit(1);\n    });\n\n    break;\n  }\n\n  default:\n    console.error(\"Unrecognized command:\", command);\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating MCP Authorization Decision Flow\nDESCRIPTION: This flowchart outlines the decision-making process in the MCP authorization flow, including checks for metadata discovery, registration endpoint availability, and the subsequent steps in the OAuth flow.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_87\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    A[Start Auth Flow] --> B{Check Metadata Discovery}\n    B -->|Available| C[Use Metadata Endpoints]\n    B -->|Not Available| D[Use Default Endpoints]\n\n    C --> G{Check Registration Endpoint}\n    D --> G\n\n    G -->|Available| H[Perform Dynamic Registration]\n    G -->|Not Available| I[Alternative Registration Required]\n\n    H --> J[Start OAuth Flow]\n    I --> J\n\n    J --> K[Generate PKCE Parameters]\n    K --> L[Request Authorization]\n    L --> M[User Authorization]\n    M --> N[Exchange Code for Tokens]\n    N --> O[Use Access Token]\n```\n\n----------------------------------------\n\nTITLE: MCP Client Implementation - Basic Structure\nDESCRIPTION: Initial TypeScript implementation of the MCP client class with imports and constructor.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_74\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Anthropic } from \"@anthropic-ai/sdk\";\nimport {\n  MessageParam,\n  Tool,\n} from \"@anthropic-ai/sdk/resources/messages/messages.mjs\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport readline from \"readline/promises\";\nimport dotenv from \"dotenv\";\n\ndotenv.config();\n\nconst ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;\nif (!ANTHROPIC_API_KEY) {\n  throw new Error(\"ANTHROPIC_API_KEY is not set\");\n}\n\nclass MCPClient {\n  private mcp: Client;\n  private anthropic: Anthropic;\n  private transport: StdioClientTransport | null = null;\n  private tools: Tool[] = [];\n\n  constructor() {\n    this.anthropic = new Anthropic({\n      apiKey: ANTHROPIC_API_KEY,\n    });\n    this.mcp = new Client({ name: \"mcp-client-cli\", version: \"1.0.0\" });\n  }\n  // methods will go here\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Resources with Asynchronous MCP Client in Java\nDESCRIPTION: Demonstrates how to list and retrieve resources using the asynchronous MCP client API with reactive programming patterns. This approach is suitable for applications requiring non-blocking resource access.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_129\n\nLANGUAGE: java\nCODE:\n```\n// List available resources asynchronously\nclient.listResources()\n    .doOnNext(resources -> resources.forEach(resource -> \n        System.out.println(resource.getName())))\n    .subscribe();\n\n// Retrieve resource content asynchronously\nclient.getResource(\"file\", Map.of(\n        \"path\", \"/path/to/file.txt\"\n    ))\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Response to Prompts List Request\nDESCRIPTION: JSON-RPC response containing available prompts with their definitions, including name, description, and required arguments. The response includes a nextCursor value for pagination.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_117\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"prompts\": [\n      {\n        \"name\": \"code_review\",\n        \"description\": \"Asks the LLM to analyze code quality and suggest improvements\",\n        \"arguments\": [\n          {\n            \"name\": \"code\",\n            \"description\": \"The code to review\",\n            \"required\": true\n          }\n        ]\n      }\n    ],\n    \"nextCursor\": \"next-page-cursor\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables in .env File\nDESCRIPTION: Example .env file configuration showing all available settings for Task Master, including required API keys and optional parameters for Claude and Perplexity integration, along with project and application settings.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/configuration.md#2025-04-23_snippet_0\n\nLANGUAGE: env\nCODE:\n```\n# Required\nANTHROPIC_API_KEY=sk-ant-api03-your-api-key\n\n# Optional - Claude Configuration\nMODEL=claude-3-7-sonnet-20250219\nMAX_TOKENS=4000\nTEMPERATURE=0.7\n\n# Optional - Perplexity API for Research\nPERPLEXITY_API_KEY=pplx-your-api-key\nPERPLEXITY_MODEL=sonar-medium-online\n\n# Optional - Project Info\nPROJECT_NAME=My Project\nPROJECT_VERSION=1.0.0\n\n# Optional - Application Configuration\nDEFAULT_SUBTASKS=3\nDEFAULT_PRIORITY=medium\nDEBUG=false\nLOG_LEVEL=info\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC 2.0 Request Format in TypeScript\nDESCRIPTION: Definition of the request message format in the MCP protocol following JSON-RPC 2.0. Requests must include a non-null string or integer ID that has not been previously used within the same session.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\";\n  id: string | number;\n  method: string;\n  params?: {\n    [key: string]: unknown;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Refreshing OAuth Access Tokens in TypeScript\nDESCRIPTION: Uses a refresh token to obtain a new access token from the authorization server. Validates server support for the refresh_token grant type, builds the token request with client credentials, and validates the response.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Exchange a refresh token for an updated access token.\n */\nexport async function refreshAuthorization(\n  serverUrl: string | URL,\n  {\n    metadata,\n    clientInformation,\n    refreshToken,\n  }: {\n    metadata?: OAuthMetadata;\n    clientInformation: OAuthClientInformation;\n    refreshToken: string;\n  },\n): Promise<OAuthTokens> {\n  const grantType = \"refresh_token\";\n\n  let tokenUrl: URL;\n  if (metadata) {\n    tokenUrl = new URL(metadata.token_endpoint);\n\n    if (\n      metadata.grant_types_supported &&\n      !metadata.grant_types_supported.includes(grantType)\n    ) {\n      throw new Error(\n        `Incompatible auth server: does not support grant type ${grantType}`,\n      );\n    }\n  } else {\n    tokenUrl = new URL(\"/token\", serverUrl);\n  }\n\n  // Exchange refresh token\n  const params = new URLSearchParams({\n    grant_type: grantType,\n    client_id: clientInformation.client_id,\n    refresh_token: refreshToken,\n  });\n\n  if (clientInformation.client_secret) {\n    params.set(\"client_secret\", clientInformation.client_secret);\n  }\n\n  const response = await fetch(tokenUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    body: params,\n  });\n\n  if (!response.ok) {\n    throw new Error(`Token refresh failed: HTTP ${response.status}`);\n  }\n\n  return OAuthTokensSchema.parse(await response.json());\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Log Messages in TypeScript MCP Server\nDESCRIPTION: TypeScript code snippet demonstrating how to send a log message from an MCP server to the client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\nserver.sendLoggingMessage({\n  level: \"info\",\n  data: \"Server started successfully\",\n});\n```\n\n----------------------------------------\n\nTITLE: Establishing SSE Connection with Auth Support in TypeScript\nDESCRIPTION: Establishes the SSE connection and sets up event handlers to manage errors, connection opens, and endpoint events, with support for authentication when needed.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nprivate _startOrAuth(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    this._eventSource = new EventSource(\n      this._url.href,\n      this._eventSourceInit ?? {\n        fetch: (url, init) => this._commonHeaders().then((headers) => fetch(url, {\n          ...init,\n          headers: {\n            ...headers,\n            Accept: \"text/event-stream\"\n          }\n        })),\n      },\n    );\n    this._abortController = new AbortController();\n\n    this._eventSource.onerror = (event) => {\n      if (event.code === 401 && this._authProvider) {\n        this._authThenStart().then(resolve, reject);\n        return;\n      }\n\n      const error = new SseError(event.code, event.message, event);\n      reject(error);\n      this.onerror?.(error);\n    };\n\n    this._eventSource.onopen = () => {\n      // The connection is open, but we need to wait for the endpoint to be received.\n    };\n\n    this._eventSource.addEventListener(\"endpoint\", (event: Event) => {\n      const messageEvent = event as MessageEvent;\n\n      try {\n        this._endpoint = new URL(messageEvent.data, this._url);\n        if (this._endpoint.origin !== this._url.origin) {\n          throw new Error(\n            `Endpoint origin does not match connection origin: ${this._endpoint.origin}`,\n          );\n        }\n      } catch (error) {\n        reject(error);\n\n```\n\n----------------------------------------\n\nTITLE: MCP JSON-RPC Message Format - Responses\nDESCRIPTION: Defines the structure of JSON-RPC 2.0 response messages used by MCP transports. The structure includes the JSON-RPC version, an ID matching the request, a result object, or an error object with code, message, and optional data.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\",\n  id: number | string,\n  result?: object,\n  error?: {\n    code: number,\n    message: string,\n    data?: unknown\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending MCP Request and Handling Response\nDESCRIPTION: Send a request to the MCP server using the client and handle the response. This example shows how to create a request, send it, and process the response asynchronously.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_117\n\nLANGUAGE: java\nCODE:\n```\nimport io.modelcontextprotocol.client.MCPRequest;\nimport io.modelcontextprotocol.client.MCPResponse;\n\nMCPRequest request = new MCPRequest.Builder()\n    .setMethod(\"GET\")\n    .setPath(\"/example\")\n    .build();\n\nclient.sendRequest(request)\n    .thenAccept(response -> {\n        if (response.isSuccess()) {\n            System.out.println(\"Response: \" + response.getBody());\n        } else {\n            System.err.println(\"Error: \" + response.getError());\n        }\n    })\n    .exceptionally(ex -> {\n        System.err.println(\"Exception: \" + ex.getMessage());\n        return null;\n    });\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP Connection Lifecycle Sequence (Mermaid)\nDESCRIPTION: A Mermaid sequence diagram illustrating the three main phases of the Model Context Protocol (MCP) connection lifecycle: Initialization, Operation, and Shutdown. It shows the ordered exchange of messages (`initialize` request, `initialize` response, `initialized` notification) between the Client and Server during the Initialization phase, followed by the Operation and Shutdown phases. Requires a Mermaid renderer to display.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_10\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: Initialization Phase\n    activate Client\n    Client->>+Server: initialize request\n    Server-->>Client: initialize response\n    Client--)Server: initialized notification\n\n    Note over Client,Server: Operation Phase\n    rect rgb(200, 220, 250)\n        note over Client,Server: Normal protocol operations\n    end\n\n    Note over Client,Server: Shutdown\n    Client--)-Server: Disconnect\n    deactivate Server\n    Note over Client,Server: Connection closed\n```\n```\n\n----------------------------------------\n\nTITLE: Tool Registration Implementation\nDESCRIPTION: Implementation for registering tools with optional descriptions and parameter schemas using Zod for validation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_148\n\nLANGUAGE: typescript\nCODE:\n```\ntool(name: string, ...rest: unknown[]): void {\n    if (this._registeredTools[name]) {\n      throw new Error(`Tool ${name} is already registered`);\n    }\n\n    let description: string | undefined;\n    if (typeof rest[0] === \"string\") {\n      description = rest.shift() as string;\n    }\n\n    let paramsSchema: ZodRawShape | undefined;\n    if (rest.length > 1) {\n      paramsSchema = rest.shift() as ZodRawShape;\n    }\n\n    const cb = rest[0] as ToolCallback<ZodRawShape | undefined>;\n    this._registeredTools[name] = {\n      description,\n      inputSchema:\n        paramsSchema === undefined ? undefined : z.object(paramsSchema),\n      callback: cb,\n    };\n\n    this.setToolRequestHandlers();\n  }\n```\n\n----------------------------------------\n\nTITLE: Executing Tools with Asynchronous MCP Client in Java\nDESCRIPTION: Demonstrates how to list available tools and execute them using the asynchronous MCP client API with reactive programming patterns. This approach is suitable for non-blocking application architectures.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_127\n\nLANGUAGE: java\nCODE:\n```\n// List available tools asynchronously\nclient.listTools()\n    .doOnNext(tools -> tools.forEach(tool -> \n        System.out.println(tool.getName())))\n    .subscribe();\n\n// Execute a tool asynchronously\nclient.callTool(\"calculator\", Map.of(\n        \"operation\", \"add\",\n        \"a\", 1,\n        \"b\", 2\n    ))\n    .subscribe();\n```\n\n----------------------------------------\n\nTITLE: Defining Prompt Argument Schema for Model Context Protocol\nDESCRIPTION: Schema for describing arguments that a prompt can accept. Includes name, description, and whether the argument is required. Used in prompt templates to define expected inputs.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_208\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Prompts */\n/**\n * Describes an argument that a prompt can accept.\n */\nexport const PromptArgumentSchema = z\n  .object({\n    /**\n     * The name of the argument.\n     */\n    name: z.string(),\n    /**\n     * A human-readable description of the argument.\n     */\n    description: z.optional(z.string()),\n    /**\n     * Whether this argument must be provided.\n     */\n    required: z.optional(z.boolean()),\n  })\n  .passthrough();\n\n/**\n * A prompt or prompt template that the server offers.\n */\nexport const PromptSchema = z\n  .object({\n    /**\n     * The name of the prompt or prompt template.\n     */\n\n```\n\n----------------------------------------\n\nTITLE: Handling Server Tool Errors\nDESCRIPTION: Tests error handling when a server tool throws an exception. This verifies that the MCP protocol correctly communicates errors to the client when tools fail, returning proper error response structures.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_122\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should handle server tool errors gracefully\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client(\n      {\n        name: \"test client\",\n        version: \"1.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      },\n    );\n\n    mcpServer.tool(\"error-test\", async () => {\n      throw new Error(\"Tool execution failed\");\n    });\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"error-test\",\n        },\n      },\n      CallToolResultSchema,\n    );\n\n    expect(result.isError).toBe(true);\n    expect(result.content).toEqual([\n      {\n        type: \"text\",\n        text: \"Tool execution failed\",\n      },\n    ]);\n  });\n```\n\n----------------------------------------\n\nTITLE: Visualizing Basic OAuth 2.1 Authorization Flow for MCP\nDESCRIPTION: This diagram illustrates the basic OAuth 2.1 authorization flow for public clients using PKCE (Proof Key for Code Exchange) in the context of MCP. It shows the interactions between the User-Agent (Browser), Client, and MCP Server during the authorization process.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_84\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant B as User-Agent (Browser)\n    participant C as Client\n    participant M as MCP Server\n\n    C->>M: MCP Request\n    M->>C: HTTP 401 Unauthorized\n    Note over C: Generate code_verifier and code_challenge\n    C->>B: Open browser with authorization URL + code_challenge\n    B->>M: GET /authorize\n    Note over M: User logs in and authorizes\n    M->>B: Redirect to callback URL with auth code\n    B->>C: Callback with authorization code\n    C->>M: Token Request with code + code_verifier\n    M->>C: Access Token (+ Refresh Token)\n    C->>M: MCP Request with Access Token\n    Note over C,M: Begin standard MCP message exchange\n```\n\n----------------------------------------\n\nTITLE: Initializing Synchronous MCP Server in Java\nDESCRIPTION: Creates a synchronous MCP server with custom configuration, including server info, capabilities, and tool/resource/prompt registrations. It also demonstrates how to send logging notifications and close the server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_136\n\nLANGUAGE: java\nCODE:\n```\n// Create a server with custom configuration\nMcpSyncServer syncServer = McpServer.sync(transport)\n    .serverInfo(\"my-server\", \"1.0.0\")\n    .capabilities(ServerCapabilities.builder()\n        .resources(true)     // Enable resource support\n        .tools(true)         // Enable tool support\n        .prompts(true)       // Enable prompt support\n        .logging()           // Enable logging support\n        .build())\n    .build();\n\n// Register tools, resources, and prompts\nsyncServer.addTool(syncToolRegistration);\nsyncServer.addResource(syncResourceRegistration);\nsyncServer.addPrompt(syncPromptRegistration);\n\n// Send logging notifications\nsyncServer.loggingNotification(LoggingMessageNotification.builder()\n    .level(LoggingLevel.INFO)\n    .logger(\"custom-logger\")\n    .data(\"Server initialized\")\n    .build());\n\n// Close the server when done\nsyncServer.close();\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP Roots Message Flow with Mermaid Diagram\nDESCRIPTION: Sequence diagram showing the interaction between server and client for listing and updating roots.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_102\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Server\n    participant Client\n\n    Note over Server,Client: Discovery\n    Server->>Client: roots/list\n    Client-->>Server: Available roots\n\n    Note over Server,Client: Changes\n    Client--)Server: notifications/roots/list_changed\n    Server->>Client: roots/list\n    Client-->>Server: Updated roots\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variables in JavaScript with FastMCP\nDESCRIPTION: Demonstrates how to create a Config instance and retrieve environment variables from the mcp.json file in JavaScript. The Config class automatically loads the configuration from the file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_22\n\nLANGUAGE: javascript\nCODE:\n```\nconst config = new Config();\nconst envVar = config.env.get('VARIABLE_NAME');\n```\n\n----------------------------------------\n\nTITLE: Executing Prompt Templates in Java - Sync API\nDESCRIPTION: Demonstrates how to list available prompt templates and execute them synchronously using the MCP client API. Shows template discovery and execution with custom parameters.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_130\n\nLANGUAGE: java\nCODE:\n```\n// List available prompt templates\nvar prompts = client.listPrompts();\nprompts.forEach(prompt -> System.out.println(prompt.getName()));\n\n// Execute a prompt template with parameters\nvar response = client.executePrompt(\"echo\", Map.of(\n    \"text\", \"Hello, World!\"\n));\n```\n\n----------------------------------------\n\nTITLE: Registering and Resolving Prompt Handlers - TypeScript\nDESCRIPTION: Defines registration of handlers for listing prompts and resolving a specific prompt by name, using schemas for request validation. Validates required arguments for prompts, loads prompt content asynchronously, handles errors with custom types, and returns structured descriptions and results. Dependencies include prompt objects, prompt argument definitions, and error types. Inputs are prompt definitions and request objects; outputs are prompt metadata or loaded prompt messages.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nprivate setupPromptHandlers(prompts: Prompt[]) {\n  this.#server.setRequestHandler(ListPromptsRequestSchema, async () => {\n    return {\n      prompts: prompts.map((prompt) => {\n        return {\n          name: prompt.name,\n          description: prompt.description,\n          arguments: prompt.arguments,\n          complete: prompt.complete,\n        };\n      }),\n    };\n  });\n\n  this.#server.setRequestHandler(GetPromptRequestSchema, async (request) => {\n    const prompt = prompts.find(\n      (prompt) => prompt.name === request.params.name,\n    );\n\n    if (!prompt) {\n      throw new McpError(\n        ErrorCode.MethodNotFound,\n        `Unknown prompt: ${request.params.name}`,\n      );\n    }\n\n    const args = request.params.arguments;\n\n    for (const arg of prompt.arguments ?? []) {\n      if (arg.required && !(args && arg.name in args)) {\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          `Missing required argument: ${arg.name}`,\n        );\n      }\n    }\n\n    let result: Awaited<ReturnType<Prompt[\"load\"]>>;\n\n    try {\n      result = await prompt.load(args as Record<string, string | undefined>);\n    } catch (error) {\n      throw new McpError(\n        ErrorCode.InternalError,\n        `Error loading prompt: ${error}`,\n      );\n    }\n\n    return {\n      description: prompt.description,\n      messages: [\n        {\n          role: \"user\",\n          content: { type: \"text\", text: result },\n        },\n      ],\n    };\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP Session Flow with Mermaid Diagram\nDESCRIPTION: Sequence diagram showing the interaction between client and server during session initialization and subsequent requests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_97\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server\n\n    note over Client, Server: initialization\n\n    Client->>+Server: POST InitializeRequest\n    Server->>-Client: InitializeResponse<br>Mcp-Session-Id: 1868a90c...\n\n    Client->>+Server: POST InitializedNotification<br>Mcp-Session-Id: 1868a90c...\n    Server->>-Client: 202 Accepted\n\n    note over Client, Server: client requests\n    Client->>+Server: POST ... request ...<br>Mcp-Session-Id: 1868a90c...\n\n    alt single HTTP response\n      Server->>Client: ... response ...\n    else server opens SSE stream\n      loop while connection remains open\n          Server-)Client: ... SSE messages from server ...\n      end\n      Server-)Client: SSE event: ... response ...\n    end\n    deactivate Server\n\n    note over Client, Server: client notifications/responses\n    Client->>+Server: POST ... notification/response ...<br>Mcp-Session-Id: 1868a90c...\n    Server->>-Client: 202 Accepted\n\n    note over Client, Server: server requests\n    Client->>+Server: GET<br>Mcp-Session-Id: 1868a90c...\n    loop while connection remains open\n        Server-)Client: ... SSE messages from server ...\n    end\n    deactivate Server\n```\n\n----------------------------------------\n\nTITLE: Common Task Master AI CLI Commands for Task Management - Bash\nDESCRIPTION: This bash code block documents several common Command Line Interface commands for interacting with Task Master AI post-setup. Each command provides core task operations: parsing a PRD, listing tasks, viewing the next task, and generating individual task files. The commands depend on successful setup of Task Master as described elsewhere in the instructions.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Parse a PRD and generate tasks\ntask-master parse-prd your-prd.txt\n\n# List all tasks\ntask-master list\n\n# Show the next task to work on\ntask-master next\n\n# Generate task files\ntask-master generate\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Prompt Registration and Listing\nDESCRIPTION: Tests the basic functionality of registering a prompt and listing available prompts through the MCP server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_138\n\nLANGUAGE: typescript\nCODE:\n```\nmcpServer.prompt(\"test\", \"Test description\", async () => ({\n  messages: [\n    {\n      role: \"assistant\",\n      content: {\n        type: \"text\",\n        text: \"Test response\",\n      },\n    },\n  ],\n}));\n```\n\n----------------------------------------\n\nTITLE: Configuring WebFlux SSE Server Transport in Java\nDESCRIPTION: Sets up a WebFlux-based Server-Sent Events (SSE) transport for MCP. It requires the 'mcp-spring-webflux' dependency and implements the MCP HTTP with SSE transport specification, providing reactive HTTP streaming and concurrent client connections.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_139\n\nLANGUAGE: java\nCODE:\n```\n@Configuration\nclass McpConfig {\n    @Bean\n    WebFluxSseServerTransport webFluxSseServerTransport(ObjectMapper mapper) {\n        return new WebFluxSseServerTransport(mapper, \"/mcp/message\");\n    }\n\n    @Bean\n    RouterFunction<?> mcpRouterFunction(WebFluxSseServerTransport transport) {\n        return transport.getRouterFunction();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JSON-RPC Transport Interface in TypeScript\nDESCRIPTION: Interface definition for a transport layer that can send and receive JSON-RPC messages. Includes methods for connection lifecycle management and callback handlers for various events.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_181\n\nLANGUAGE: typescript\nCODE:\n```\nimport { JSONRPCMessage } from \"../types.js\";\n\n/**\n * Describes the minimal contract for a MCP transport that a client or server can communicate over.\n */\nexport interface Transport {\n  /**\n   * Starts processing messages on the transport, including any connection steps that might need to be taken.\n   *\n   * This method should only be called after callbacks are installed, or else messages may be lost.\n   *\n   * NOTE: This method should not be called explicitly when using Client, Server, or Protocol classes, as they will implicitly call start().\n   */\n  start(): Promise<void>;\n\n  /**\n   * Sends a JSON-RPC message (request or response).\n   */\n  send(message: JSONRPCMessage): Promise<void>;\n\n  /**\n   * Closes the connection.\n   */\n  close(): Promise<void>;\n\n  /**\n   * Callback for when the connection is closed for any reason.\n   *\n   * This should be invoked when close() is called as well.\n   */\n  onclose?: () => void;\n\n  /**\n   * Callback for when an error occurs.\n   *\n   * Note that errors are not necessarily fatal; they are used for reporting any kind of exceptional condition out of band.\n   */\n  onerror?: (error: Error) => void;\n\n  /**\n   * Callback for when a message (request or response) is received over the connection.\n   */\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  /**\n   * The session ID generated for this connection.\n   */\n  sessionId?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Transport Interface for MCP in TypeScript\nDESCRIPTION: Defines the interface for implementing custom MCP transports in TypeScript. The interface includes methods for starting, sending messages, closing connections, and callback handlers for different events.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Transport {\n  // Start processing messages\n  start(): Promise<void>;\n\n  // Send a JSON-RPC message\n  send(message: JSONRPCMessage): Promise<void>;\n\n  // Close the connection\n  close(): Promise<void>;\n\n  // Callbacks\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Prompt Message and Response Schemas\nDESCRIPTION: Defines schemas for prompt messages and server responses to prompt requests. These schemas specify the structure for messages exchanged between users and assistants in the protocol.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_211\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Describes a message returned as part of a prompt.\n */\nexport const PromptMessageSchema = z\n  .object({\n    role: z.enum([\"user\", \"assistant\"]),\n    content: z.union([\n      TextContentSchema,\n      ImageContentSchema,\n      EmbeddedResourceSchema,\n    ]),\n  })\n  .passthrough();\n\n/**\n * The server's response to a prompts/get request from the client.\n */\nexport const GetPromptResultSchema = ResultSchema.extend({\n  /**\n   * An optional description for the prompt.\n   */\n  description: z.optional(z.string()),\n  messages: z.array(PromptMessageSchema),\n});\n\n/**\n * An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport const PromptListChangedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/prompts/list_changed\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Calling Tools Request in JSON-RPC Format\nDESCRIPTION: Request format for invoking a specific tool with arguments. The client sends this request when the LLM decides to use a particular tool, passing the required arguments according to the tool's input schema.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_62\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"get_weather\",\n    \"arguments\": {\n      \"location\": \"New York\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Log Messages in Python MCP Server\nDESCRIPTION: Python code snippet demonstrating how to send a log message from an MCP server to the client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nserver.request_context.session.send_log_message(\n  level=\"info\",\n  data=\"Server started successfully\",\n)\n```\n\n----------------------------------------\n\nTITLE: Tool Request Handler Implementation\nDESCRIPTION: Implements handlers for tool-related requests including listing available tools and calling tools with arguments. Includes input validation and error handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_144\n\nLANGUAGE: typescript\nCODE:\n```\nprivate setToolRequestHandlers() {\n    if (this._toolHandlersInitialized) {\n      return;\n    }\n    \n    this.server.assertCanSetRequestHandler(\n      ListToolsRequestSchema.shape.method.value,\n    );\n    this.server.assertCanSetRequestHandler(\n      CallToolRequestSchema.shape.method.value,\n    );\n\n    this.server.registerCapabilities({\n      tools: {},\n    });\n\n    this.server.setRequestHandler(\n      ListToolsRequestSchema,\n      (): ListToolsResult => ({\n        tools: Object.entries(this._registeredTools).map(\n          ([name, tool]): Tool => {\n            return {\n              name,\n              description: tool.description,\n              inputSchema: tool.inputSchema\n                ? (zodToJsonSchema(tool.inputSchema, {\n                    strictUnions: true,\n                  }) as Tool[\"inputSchema\"])\n                : EMPTY_OBJECT_JSON_SCHEMA,\n            };\n          },\n        ),\n      }),\n    );\n\n    this.server.setRequestHandler(\n      CallToolRequestSchema,\n      async (request, extra): Promise<CallToolResult> => {\n        const tool = this._registeredTools[request.params.name];\n        if (!tool) {\n          throw new McpError(\n            ErrorCode.InvalidParams,\n            `Tool ${request.params.name} not found`,\n          );\n        }\n\n        if (tool.inputSchema) {\n          const parseResult = await tool.inputSchema.safeParseAsync(\n            request.params.arguments,\n          );\n          if (!parseResult.success) {\n            throw new McpError(\n              ErrorCode.InvalidParams,\n              `Invalid arguments for tool ${request.params.name}: ${parseResult.error.message}`,\n            );\n          }\n\n          const args = parseResult.data;\n          const cb = tool.callback as ToolCallback<ZodRawShape>;\n          try {\n            return await Promise.resolve(cb(args, extra));\n          } catch (error) {\n            return {\n              content: [\n                {\n                  type: \"text\",\n                  text: error instanceof Error ? error.message : String(error),\n                },\n              ],\n              isError: true,\n            };\n          }\n        } else {\n          const cb = tool.callback as ToolCallback<undefined>;\n          try {\n            return await Promise.resolve(cb(extra));\n          } catch (error) {\n            return {\n              content: [\n                {\n                  type: \"text\",\n                  text: error instanceof Error ? error.message : String(error),\n                },\n              ],\n              isError: true,\n            };\n          }\n        }\n      },\n    );\n\n    this._toolHandlersInitialized = true;\n  }\n```\n\n----------------------------------------\n\nTITLE: Calling Tools Request and Response in JSON-RPC\nDESCRIPTION: Examples of the JSON-RPC request and response format for invoking a tool using the tools/call endpoint. Shows how to pass arguments and handle multi-type responses.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_134\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"get_weather\",\n    \"arguments\": {\n      \"location\": \"New York\"\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Current weather in New York:\\nTemperature: 72°F\\nConditions: Partly cloudy\"\n      }\n    ],\n    \"isError\": false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining OAuth Client Authentication Types and Schemas in TypeScript\nDESCRIPTION: This snippet defines the types and schemas used for OAuth client authentication. It includes middleware options, request schema, and type extensions for Express.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_93\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type ClientAuthenticationMiddlewareOptions = {\n  /**\n   * A store used to read information about registered OAuth clients.\n   */\n  clientsStore: OAuthRegisteredClientsStore;\n}\n\nconst ClientAuthenticatedRequestSchema = z.object({\n  client_id: z.string(),\n  client_secret: z.string().optional(),\n});\n\ndeclare module \"express-serve-static-core\" {\n  interface Request {\n    /**\n     * The authenticated client for this request, if the `authenticateClient` middleware was used.\n     */\n    client?: OAuthClientInformationFull;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Server Connection in MCP Client\nDESCRIPTION: Method to connect the MCP client to a server, supporting both Python and Node.js servers, and initializing the session.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_66\n\nLANGUAGE: python\nCODE:\n```\nasync def connect_to_server(self, server_script_path: str):\n    \"\"\"Connect to an MCP server\n\n    Args:\n        server_script_path: Path to the server script (.py or .js)\n    \"\"\"\n    is_python = server_script_path.endswith('.py')\n    is_js = server_script_path.endswith('.js')\n    if not (is_python or is_js):\n        raise ValueError(\"Server script must be a .py or .js file\")\n\n    command = \"python\" if is_python else \"node\"\n    server_params = StdioServerParameters(\n        command=command,\n        args=[server_script_path],\n        env=None\n    )\n\n    stdio_transport = await self.exit_stack.enter_async_context(stdio_client(server_params))\n    self.stdio, self.write = stdio_transport\n    self.session = await self.exit_stack.enter_async_context(ClientSession(self.stdio, self.write))\n\n    await self.session.initialize()\n\n    # List available tools\n    response = await self.session.list_tools()\n    tools = response.tools\n    print(\"\\nConnected to server with tools:\", [tool.name for tool in tools])\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Server with SSE Transport in TypeScript\nDESCRIPTION: Demonstrates how to set up an MCP server using Server-Sent Events (SSE) transport in TypeScript with Express. The code initializes a server with name and version, creates an SSE transport, and sets up Express routes for SSE connections and message handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nimport express from \"express\";\n\nconst app = express();\n\nconst server = new Server({\n  name: \"example-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {}\n});\n\nlet transport: SSEServerTransport | null = null;\n\napp.get(\"/sse\", (req, res) => {\n  transport = new SSEServerTransport(\"/messages\", res);\n  server.connect(transport);\n});\n\napp.post(\"/messages\", (req, res) => {\n  if (transport) {\n    transport.handlePostMessage(req, res);\n  }\n});\n\napp.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Adding Subtasks Directly via MCP - Node.js JavaScript\nDESCRIPTION: Implements a direct function to add subtasks to an existing task and wraps it as an MCP tool, using Node.js and the zod library for schema validation. Requires utilities like findTasksJsonPath and addSubtask from task-manager.js, and returns standardized success/error objects. Expected inputs include parentTaskId, title, description, and details; the output is a result object with either added subtask data or error info.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// addSubtaskDirect.js\nconst { addSubtask } = require('../task-manager');\nconst { findTasksJsonPath } = require('../utils');\n\nmodule.exports = async function addSubtaskDirect({ parentTaskId, title, description, details }) {\n  try {\n    const tasksPath = findTasksJsonPath();\n    // Validate parameters here\n    const subtask = await addSubtask({ tasksPath, parentTaskId, title, description, details });\n    return { success: true, data: subtask };\n  } catch (error) {\n    return { success: false, error };\n  }\n};\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// add-subtask.js (MCP tool)\nconst z = require('zod');\nconst { executeMCPToolAction } = require('./utils');\nconst { addSubtaskDirect } = require('../core/task-master-core');\n\nconst addSubtaskSchema = z.object({\n  parentTaskId: z.string(),\n  title: z.string(),\n  description: z.string().optional(),\n  details: z.any().optional(),\n});\n\nfunction registerAddSubtaskTool(server) {\n  server.addTool({\n    name: 'add_subtask',\n    params: addSubtaskSchema,\n    execute: (params) => executeMCPToolAction(() => addSubtaskDirect(params)),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Client and Testing Protocol Version Handling\nDESCRIPTION: Sets up a client instance, connects it to a transport, and verifies that it correctly sends the initialize method with the latest protocol version. The test checks that the client properly receives and stores instructions from the server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  await client.connect(clientTransport);\n\n  // Should have sent initialize with latest version\n  expect(clientTransport.send).toHaveBeenCalledWith(\n    expect.objectContaining({\n      method: \"initialize\",\n      params: expect.objectContaining({\n        protocolVersion: LATEST_PROTOCOL_VERSION,\n      }),\n    }),\n  );\n\n  // Should have the instructions returned\n  expect(client.getInstructions()).toEqual(\"test instructions\");\n```\n\n----------------------------------------\n\nTITLE: Handling Logging Notifications and Verifying Log Messages with Vitest in TypeScript\nDESCRIPTION: This client-side test snippet sets up a notification handler for logging messages using `client.setNotificationHandler` and `LoggingMessageNotificationSchema`. It captures specific details (level, message, context) from incoming log notifications into a mock function `onLog`. After calling the 'add' tool (which triggers logging on the server), it uses `vitest`'s `expect` to assert that the `onLog` handler was called four times with the correctly structured data for each log level (debug, error, info, warning).\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst onLog = vi.fn();\n\nclient.setNotificationHandler(\n  LoggingMessageNotificationSchema,\n  (message) => {\n    if (message.method === \"notifications/message\") {\n      onLog({\n        level: message.params.level,\n        ...(message.params.data ?? {}),\n      });\n    }\n  },\n);\n\nawait client.callTool({\n  name: \"add\",\n  arguments: {\n    a: 1,\n    b: 2,\n  },\n});\n\nexpect(onLog).toHaveBeenCalledTimes(4);\nexpect(onLog).toHaveBeenNthCalledWith(1, {\n  level: \"debug\",\n  message: \"debug message\",\n  context: {\n    foo: \"bar\",\n  },\n});\nexpect(onLog).toHaveBeenNthCalledWith(2, {\n  level: \"error\",\n  message: \"error message\",\n});\nexpect(onLog).toHaveBeenNthCalledWith(3, {\n  level: \"info\",\n  message: \"info message\",\n});\nexpect(onLog).toHaveBeenNthCalledWith(4, {\n  level: \"warning\",\n  message: \"warn message\",\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Server with SSE Transport in Python\nDESCRIPTION: Demonstrates how to set up an MCP server using Server-Sent Events (SSE) transport in Python with Starlette. The code initializes a server and SSE transport, then sets up Starlette routes for SSE connections and message handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nfrom mcp.server.sse import SseServerTransport\nfrom starlette.applications import Starlette\nfrom starlette.routing import Route\n\napp = Server(\"example-server\")\nsse = SseServerTransport(\"/messages\")\n\nasync def handle_sse(scope, receive, send):\n    async with sse.connect_sse(scope, receive, send) as streams:\n        await app.run(streams[0], streams[1], app.create_initialization_options())\n\nasync def handle_messages(scope, receive, send):\n    await sse.handle_post_message(scope, receive, send)\n\nstarlette_app = Starlette(\n    routes=[\n        Route(\"/sse\", endpoint=handle_sse),\n        Route(\"/messages\", endpoint=handle_messages, methods=[\"POST\"]),\n    ]\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Function to Run MCP Server\nDESCRIPTION: Defines the main function that creates a StdioServerTransport, connects it to the MCP server, and handles any errors that occur during execution.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_101\n\nLANGUAGE: typescript\nCODE:\n```\nasync function main() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  console.error(\"Weather MCP Server running on stdio\");\n}\n\nmain().catch((error) => {\n  console.error(\"Fatal error in main():\", error);\n  process.exit(1);\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Resource URI Error Handling\nDESCRIPTION: Tests that McpServer returns an appropriate error when a client requests a non-existent resource. The test verifies that the error message includes information about the missing resource.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_133\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mcpServer = new McpServer({\n  name: \"test server\",\n  version: \"1.0\",\n});\nconst client = new Client({\n  name: \"test client\",\n  version: \"1.0\",\n});\n\nmcpServer.resource(\"test\", \"test://resource\", async () => ({\n  contents: [\n    {\n      uri: \"test://resource\",\n      text: \"Test content\",\n    },\n  ],\n}));\n\nconst [clientTransport, serverTransport] =\n  InMemoryTransport.createLinkedPair();\n\nawait Promise.all([\n  client.connect(clientTransport),\n  mcpServer.server.connect(serverTransport),\n]);\n\nawait expect(\n  client.request(\n    {\n      method: \"resources/read\",\n      params: {\n        uri: \"test://nonexistent\",\n      },\n    },\n    ReadResourceResultSchema,\n  ),\n).rejects.toThrow(/Resource test:\\/\\/nonexistent not found/);\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Flow for SSE Transport in TypeScript\nDESCRIPTION: Handles the authentication process for the SSE transport, using the provided auth provider to authenticate and start the connection, throwing appropriate errors when needed.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nprivate async _authThenStart(): Promise<void> {\n  if (!this._authProvider) {\n    throw new UnauthorizedError(\"No auth provider\");\n  }\n\n  let result: AuthResult;\n  try {\n    result = await auth(this._authProvider, { serverUrl: this._url });\n  } catch (error) {\n    this.onerror?.(error as Error);\n    throw error;\n  }\n\n  if (result !== \"AUTHORIZED\") {\n    throw new UnauthorizedError();\n  }\n\n  return await this._startOrAuth();\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting Technical Architecture and Planning in Markdown - Markdown\nDESCRIPTION: This Markdown snippet provides a structured format for capturing the technical implementation, development roadmap, dependency chains, risk management, and additional notes for a software project. Each section contains bullet-pointed guidance for what information to supply, ensuring completeness and clarity. The expected inputs are detailed technical and planning descriptions, while the output is an organized technical PRD section. This layout assumes usage within a larger requirements documentation file and has no codebase or tooling dependencies.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/example_prd.txt#2025-04-23_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n# Technical Architecture  \n[Outline the technical implementation details:\n- System components\n- Data models\n- APIs and integrations\n- Infrastructure requirements]\n\n# Development Roadmap  \n[Break down the development process into phases:\n- MVP requirements\n- Future enhancements\n- Do not think about timelines whatsoever -- all that matters is scope and detailing exactly what needs to be build in each phase so it can later be cut up into tasks]\n\n# Logical Dependency Chain\n[Define the logical order of development:\n- Which features need to be built first (foundation)\n- Getting as quickly as possible to something usable/visible front end that works\n- Properly pacing and scoping each feature so it is atomic but can also be built upon and improved as development approaches]\n\n# Risks and Mitigations  \n[Identify potential risks and how they'll be addressed:\n- Technical challenges\n- Figuring out the MVP that we can build upon\n- Resource constraints]\n\n# Appendix  \n[Include any additional information:\n- Research findings\n- Technical specifications]\n```\n\n----------------------------------------\n\nTITLE: Implementing StdioClientTransport class in TypeScript\nDESCRIPTION: Implements a client transport that communicates with a server over standard input/output streams of a spawned process. It implements the Transport interface with methods for starting, sending messages, and closing the connection.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_48\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Client transport for stdio: this will connect to a server by spawning a process and communicating with it over stdin/stdout.\n *\n * This transport is only available in Node.js environments.\n */\nexport class StdioClientTransport implements Transport {\n  private _process?: ChildProcess;\n  private _abortController: AbortController = new AbortController();\n  private _readBuffer: ReadBuffer = new ReadBuffer();\n  private _serverParams: StdioServerParameters;\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor(server: StdioServerParameters) {\n    this._serverParams = server;\n  }\n\n  /**\n   * Starts the server process and prepares to communicate with it.\n   */\n  async start(): Promise<void> {\n    if (this._process) {\n      throw new Error(\n        \"StdioClientTransport already started! If using Client class, note that connect() calls start() automatically.\"\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      this._process = spawn(\n        this._serverParams.command,\n        this._serverParams.args ?? [],\n        {\n          env: this._serverParams.env ?? getDefaultEnvironment(),\n          stdio: [\"pipe\", \"pipe\", this._serverParams.stderr ?? \"inherit\"],\n          shell: false,\n          signal: this._abortController.signal,\n          windowsHide: process.platform === \"win32\" && isElectron(),\n          cwd: this._serverParams.cwd,\n        }\n      );\n\n      this._process.on(\"error\", (error) => {\n        if (error.name === \"AbortError\") {\n          // Expected when close() is called.\n          this.onclose?.();\n          return;\n        }\n\n        reject(error);\n        this.onerror?.(error);\n      });\n\n      this._process.on(\"spawn\", () => {\n        resolve();\n      });\n\n      this._process.on(\"close\", (_code) => {\n        this._process = undefined;\n        this.onclose?.();\n      });\n\n      this._process.stdin?.on(\"error\", (error) => {\n        this.onerror?.(error);\n      });\n\n      this._process.stdout?.on(\"data\", (chunk) => {\n        this._readBuffer.append(chunk);\n        this.processReadBuffer();\n      });\n\n      this._process.stdout?.on(\"error\", (error) => {\n        this.onerror?.(error);\n      });\n    });\n  }\n\n  /**\n   * The stderr stream of the child process, if `StdioServerParameters.stderr` was set to \"pipe\" or \"overlapped\".\n   *\n   * This is only available after the process has been started.\n   */\n  get stderr(): Stream | null {\n    return this._process?.stderr ?? null;\n  }\n\n  private processReadBuffer() {\n    while (true) {\n      try {\n        const message = this._readBuffer.readMessage();\n        if (message === null) {\n          break;\n        }\n\n        this.onmessage?.(message);\n      } catch (error) {\n        this.onerror?.(error as Error);\n      }\n    }\n  }\n\n  async close(): Promise<void> {\n    this._abortController.abort();\n    this._process = undefined;\n    this._readBuffer.clear();\n  }\n\n  send(message: JSONRPCMessage): Promise<void> {\n    return new Promise((resolve) => {\n      if (!this._process?.stdin) {\n        throw new Error(\"Not connected\");\n      }\n\n      const json = serializeMessage(message);\n      if (this._process.stdin.write(json)) {\n        resolve();\n      } else {\n        this._process.stdin.once(\"drain\", resolve);\n      }\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Capability Assertions for Client Requests in MCP\nDESCRIPTION: Defines methods for asserting capabilities required for different client requests in the MCP protocol. The method checks if the server supports necessary capabilities before executing specific requests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nprotected assertCapabilityForMethod(method: RequestT[\"method\"]): void {\n  switch (method as ClientRequest[\"method\"]) {\n    case \"logging/setLevel\":\n      if (!this._serverCapabilities?.logging) {\n        throw new Error(\n          `Server does not support logging (required for ${method})`,\n        );\n      }\n      break;\n\n    case \"prompts/get\":\n    case \"prompts/list\":\n      if (!this._serverCapabilities?.prompts) {\n        throw new Error(\n          `Server does not support prompts (required for ${method})`,\n        );\n      }\n      break;\n\n    case \"resources/list\":\n    case \"resources/templates/list\":\n    case \"resources/read\":\n    case \"resources/subscribe\":\n    case \"resources/unsubscribe\":\n      if (!this._serverCapabilities?.resources) {\n        throw new Error(\n          `Server does not support resources (required for ${method})`,\n        );\n      }\n\n      if (\n        method === \"resources/subscribe\" &&\n        !this._serverCapabilities.resources.subscribe\n      ) {\n        throw new Error(\n          `Server does not support resource subscriptions (required for ${method})`,\n        );\n      }\n\n      break;\n\n    case \"tools/call\":\n    case \"tools/list\":\n      if (!this._serverCapabilities?.tools) {\n        throw new Error(\n          `Server does not support tools (required for ${method})`,\n        );\n      }\n      break;\n\n    case \"completion/complete\":\n      if (!this._serverCapabilities?.prompts) {\n        throw new Error(\n          `Server does not support prompts (required for ${method})`,\n        );\n      }\n      break;\n\n    case \"initialize\":\n      // No specific capability required for initialize\n      break;\n\n    case \"ping\":\n      // No specific capability required for ping\n      break;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Direct Anthropic AI Operations with Error Handling - JavaScript\nDESCRIPTION: Implements a direct AI operation invoking Anthropic/Claude via utilities, with thorough error handling and session-driven model config. Requires importing getAnthropicClientForMCP, getModelConfig, and handleClaudeError from ai-client-utils. Accepts arguments, logging, and context; returns standardized result objects for both success and error states, handling both client and API errors gracefully.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/ai-client-utils-example.md#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// In your direct function implementation:\nimport {\n\tgetAnthropicClientForMCP,\n\tgetModelConfig,\n\thandleClaudeError\n} from '../utils/ai-client-utils.js';\n\nexport async function someAiOperationDirect(args, log, context) {\n\ttry {\n\t\t// Initialize Anthropic client with session from context\n\t\tconst client = getAnthropicClientForMCP(context.session, log);\n\n\t\t// Get model configuration with defaults or session overrides\n\t\tconst modelConfig = getModelConfig(context.session);\n\n\t\t// Make API call with proper error handling\n\t\ttry {\n\t\t\tconst response = await client.messages.create({\n\t\t\t\tmodel: modelConfig.model,\n\t\t\t\tmax_tokens: modelConfig.maxTokens,\n\t\t\t\ttemperature: modelConfig.temperature,\n\t\t\t\tmessages: [{ role: 'user', content: 'Your prompt here' }]\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: response\n\t\t\t};\n\t\t} catch (apiError) {\n\t\t\t// Use helper to get user-friendly error message\n\t\t\tconst friendlyMessage = handleClaudeError(apiError);\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: {\n\t\t\t\t\tcode: 'AI_API_ERROR',\n\t\t\t\t\tmessage: friendlyMessage\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t} catch (error) {\n\t\t// Handle client initialization errors\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: {\n\t\t\t\tcode: 'AI_CLIENT_ERROR',\n\t\t\t\tmessage: error.message\n\t\t\t}\n\t\t};\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Tools Response in JSON-RPC Format\nDESCRIPTION: Response format for the tools/call request, containing the result of the tool invocation with content items. The isError flag indicates whether the tool execution was successful.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_63\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Current weather in New York:\\nTemperature: 72°F\\nConditions: Partly cloudy\"\n      }\n    ],\n    \"isError\": false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Synchronous MCP Client with Capabilities in Java\nDESCRIPTION: Creates and configures a synchronous MCP client with custom timeout, roots capability, and sampling support. The example demonstrates initialization, tool execution, resource access, prompt handling, and roots management before gracefully closing the connection.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_118\n\nLANGUAGE: java\nCODE:\n```\n// Create a sync client with custom configuration\nMcpSyncClient client = McpClient.sync(transport)\n    .requestTimeout(Duration.ofSeconds(10))\n    .capabilities(ClientCapabilities.builder()\n        .roots(true)      // Enable roots capability\n        .sampling()       // Enable sampling capability\n        .build())\n    .sampling(request -> new CreateMessageResult(response))\n    .build();\n\n// Initialize connection\nclient.initialize();\n\n// List available tools\nListToolsResult tools = client.listTools();\n\n// Call a tool\nCallToolResult result = client.callTool(\n    new CallToolRequest(\"calculator\", \n        Map.of(\"operation\", \"add\", \"a\", 2, \"b\", 3))\n);\n\n// List and read resources\nListResourcesResult resources = client.listResources();\nReadResourceResult resource = client.readResource(\n    new ReadResourceRequest(\"resource://uri\")\n);\n\n// List and use prompts\nListPromptsResult prompts = client.listPrompts();\nGetPromptResult prompt = client.getPrompt(\n    new GetPromptRequest(\"greeting\", Map.of(\"name\", \"Spring\"))\n);\n\n// Add/remove roots\nclient.addRoot(new Root(\"file:///path\", \"description\"));\nclient.removeRoot(\"file:///path\");\n\n// Close client\nclient.closeGracefully();\n```\n\n----------------------------------------\n\nTITLE: Testing Server Capability Enforcement in Client Requests\nDESCRIPTION: Tests that the client respects server capabilities during communication. The client should allow requests for capabilities the server supports (resources and tools) but throw errors when attempting to use capabilities not supported by the server (prompts).\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should respect server capabilities\", async () => {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        resources: {},\n        tools: {},\n      },\n    },\n  );\n\n  server.setRequestHandler(InitializeRequestSchema, (_request) => ({\n    protocolVersion: LATEST_PROTOCOL_VERSION,\n    capabilities: {\n      resources: {},\n      tools: {},\n    },\n    serverInfo: {\n      name: \"test\",\n      version: \"1.0\",\n    },\n  }));\n\n  server.setRequestHandler(ListResourcesRequestSchema, () => ({\n    resources: [],\n  }));\n\n  server.setRequestHandler(ListToolsRequestSchema, () => ({\n    tools: [],\n  }));\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // Server supports resources and tools, but not prompts\n  expect(client.getServerCapabilities()).toEqual({\n    resources: {},\n    tools: {},\n  });\n\n  // These should work\n  await expect(client.listResources()).resolves.not.toThrow();\n  await expect(client.listTools()).resolves.not.toThrow();\n\n  // This should throw because prompts are not supported\n  await expect(client.listPrompts()).rejects.toThrow(\n    \"Server does not support prompts\",\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Support in Python MCP Server\nDESCRIPTION: Shows how to implement basic resource support in an MCP server using Python. It includes handlers for listing available resources and reading resource contents.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_24\n\nLANGUAGE: python\nCODE:\n```\napp = Server(\"example-server\")\n\n@app.list_resources()\nasync def list_resources() -> list[types.Resource]:\n    return [\n        types.Resource(\n            uri=\"file:///logs/app.log\",\n            name=\"Application Logs\",\n            mimeType=\"text/plain\"\n        )\n    ]\n\n@app.read_resource()\nasync def read_resource(uri: AnyUrl) -> str:\n    if str(uri) == \"file:///logs/app.log\":\n        log_contents = await read_log_file()\n        return log_contents\n\n    raise ValueError(\"Resource not found\")\n\n# Start server\nasync with stdio_server() as streams:\n    await app.run(\n        streams[0],\n        streams[1],\n        app.create_initialization_options()\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Subscription Request Schemas\nDESCRIPTION: Schemas for subscribing to and unsubscribing from resource updates. These allow clients to request notifications when specific resources change, and to cancel those subscriptions when no longer needed.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_206\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.\n */\nexport const SubscribeRequestSchema = RequestSchema.extend({\n  method: z.literal(\"resources/subscribe\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.\n     */\n    uri: z.string(),\n  }),\n});\n\n/**\n * Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.\n */\nexport const UnsubscribeRequestSchema = RequestSchema.extend({\n  method: z.literal(\"resources/unsubscribe\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The URI of the resource to unsubscribe from.\n     */\n    uri: z.string(),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Progress Notification Sequence Diagram (Mermaid) - Mermaid\nDESCRIPTION: A Mermaid sequence diagram representing a full progress-tracked operation, showing the request initiation with a progress token, multiple progress notifications, and eventual operation completion with a method response. This helps visualize the notification patterns for long-running tasks as supported in the protocol. Inputs/outputs are implicit in messages within the diagram. Requires Mermaid rendering for visualization.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_9\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\\n    participant Sender\\n    participant Receiver\\n\\n    Note over Sender,Receiver: Request with progress token\\n    Sender->>Receiver: Method request with progressToken\\n\\n    Note over Sender,Receiver: Progress updates\\n    loop Progress Updates\\n        Receiver-->>Sender: Progress notification (0.2/1.0)\\n        Receiver-->>Sender: Progress notification (0.6/1.0)\\n        Receiver-->>Sender: Progress notification (1.0/1.0)\\n    end\\n\\n    Note over Sender,Receiver: Operation complete\\n    Receiver->>Sender: Method response\n```\n\n----------------------------------------\n\nTITLE: Testing In-Memory Transport for JSON-RPC Communication in TypeScript\nDESCRIPTION: Jest test suite for InMemoryTransport, which provides linked client-server pairs for testing JSON-RPC communication. The tests verify message passing in both directions and proper handling of connection lifecycle events.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_191\n\nLANGUAGE: typescript\nCODE:\n```\nimport { InMemoryTransport } from \"./inMemory.js\";\nimport { JSONRPCMessage } from \"./types.js\";\n\ndescribe(\"InMemoryTransport\", () => {\n  let clientTransport: InMemoryTransport;\n  let serverTransport: InMemoryTransport;\n\n  beforeEach(() => {\n    [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n  });\n\n  test(\"should create linked pair\", () => {\n    expect(clientTransport).toBeDefined();\n    expect(serverTransport).toBeDefined();\n  });\n\n  test(\"should start without error\", async () => {\n    await expect(clientTransport.start()).resolves.not.toThrow();\n    await expect(serverTransport.start()).resolves.not.toThrow();\n  });\n\n  test(\"should send message from client to server\", async () => {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      id: 1,\n    };\n\n    let receivedMessage: JSONRPCMessage | undefined;\n    serverTransport.onmessage = (msg) => {\n      receivedMessage = msg;\n    };\n\n    await clientTransport.send(message);\n    expect(receivedMessage).toEqual(message);\n  });\n\n  test(\"should send message from server to client\", async () => {\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      method: \"test\",\n      id: 1,\n    };\n\n    let receivedMessage: JSONRPCMessage | undefined;\n    clientTransport.onmessage = (msg) => {\n      receivedMessage = msg;\n    };\n\n    await serverTransport.send(message);\n    expect(receivedMessage).toEqual(message);\n  });\n\n  test(\"should handle close\", async () => {\n    let clientClosed = false;\n    let serverClosed = false;\n\n    clientTransport.onclose = () => {\n      clientClosed = true;\n    };\n\n    serverTransport.onclose = () => {\n      serverClosed = true;\n    };\n\n    await clientTransport.close();\n    expect(clientClosed).toBe(true);\n\n```\n\n----------------------------------------\n\nTITLE: Defining Pagination Interfaces in TypeScript\nDESCRIPTION: Defines interfaces for paginated requests and results, including a cursor for pagination and a nextCursor for indicating more results.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_145\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PaginatedRequest extends Request {\n  params?: {\n    cursor?: Cursor;\n  };\n}\n\nexport interface PaginatedResult extends Result {\n  nextCursor?: Cursor;\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP Connection Initialization Sequence with Mermaid\nDESCRIPTION: A Mermaid sequence diagram illustrating the MCP connection initialization process. It shows the exchange between Client and Server: `initialize` request, `initialize` response, and `initialized` notification, leading to a ready connection.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_8\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Client->>Server: initialize request\n    Server->>Client: initialize response\n    Client->>Server: initialized notification\n\n    Note over Client,Server: Connection ready for use\n```\n```\n\n----------------------------------------\n\nTITLE: Executing Tools with Synchronous MCP Client in Java\nDESCRIPTION: Demonstrates how to list available tools and execute them using the synchronous MCP client API. Tools are server-side functions that clients can discover and invoke with specific parameters.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_126\n\nLANGUAGE: java\nCODE:\n```\n// List available tools and their names\nvar tools = client.listTools();\ntools.forEach(tool -> System.out.println(tool.getName()));\n\n// Execute a tool with parameters\nvar result = client.callTool(\"calculator\", Map.of(\n    \"operation\", \"add\",\n    \"a\", 1,\n    \"b\", 2\n));\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Authorization Handler with Jest in TypeScript\nDESCRIPTION: A comprehensive Jest test suite for the OAuth authorization handler. It tests various aspects of the OAuth 2.0 authorization flow including HTTP method validation, client validation, redirect URI validation, and authorization request validation using mocked OAuth provider and client store.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_54\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { authorizationHandler, AuthorizationHandlerOptions } from './authorize.js';\nimport { OAuthServerProvider, AuthorizationParams } from '../provider.js';\nimport { OAuthRegisteredClientsStore } from '../clients.js';\nimport { OAuthClientInformationFull, OAuthTokens } from '../../../shared/auth.js';\nimport express, { Response } from 'express';\nimport supertest from 'supertest';\nimport { AuthInfo } from '../types.js';\nimport { InvalidTokenError } from '../errors.js';\n\ndescribe('Authorization Handler', () => {\n  // Mock client data\n  const validClient: OAuthClientInformationFull = {\n    client_id: 'valid-client',\n    client_secret: 'valid-secret',\n    redirect_uris: ['https://example.com/callback'],\n    scope: 'profile email'\n  };\n\n  const multiRedirectClient: OAuthClientInformationFull = {\n    client_id: 'multi-redirect-client',\n    client_secret: 'valid-secret',\n    redirect_uris: [\n      'https://example.com/callback1',\n      'https://example.com/callback2'\n    ],\n    scope: 'profile email'\n  };\n\n  // Mock client store\n  const mockClientStore: OAuthRegisteredClientsStore = {\n    async getClient(clientId: string): Promise<OAuthClientInformationFull | undefined> {\n      if (clientId === 'valid-client') {\n        return validClient;\n      } else if (clientId === 'multi-redirect-client') {\n        return multiRedirectClient;\n      }\n      return undefined;\n    }\n  };\n\n  // Mock provider\n  const mockProvider: OAuthServerProvider = {\n    clientsStore: mockClientStore,\n\n    async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise<void> {\n      // Mock implementation - redirects to redirectUri with code and state\n      const redirectUrl = new URL(params.redirectUri);\n      redirectUrl.searchParams.set('code', 'mock_auth_code');\n      if (params.state) {\n        redirectUrl.searchParams.set('state', params.state);\n      }\n      res.redirect(302, redirectUrl.toString());\n    },\n\n    async challengeForAuthorizationCode(): Promise<string> {\n      return 'mock_challenge';\n    },\n\n    async exchangeAuthorizationCode(): Promise<OAuthTokens> {\n      return {\n        access_token: 'mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'mock_refresh_token'\n      };\n    },\n\n    async exchangeRefreshToken(): Promise<OAuthTokens> {\n      return {\n        access_token: 'new_mock_access_token',\n        token_type: 'bearer',\n        expires_in: 3600,\n        refresh_token: 'new_mock_refresh_token'\n      };\n    },\n\n    async verifyAccessToken(token: string): Promise<AuthInfo> {\n      if (token === 'valid_token') {\n        return {\n          token,\n          clientId: 'valid-client',\n          scopes: ['read', 'write'],\n          expiresAt: Date.now() / 1000 + 3600\n        };\n      }\n      throw new InvalidTokenError('Token is invalid or expired');\n    },\n\n    async revokeToken(): Promise<void> {\n      // Do nothing in mock\n    }\n  };\n\n  // Setup express app with handler\n  let app: express.Express;\n  let options: AuthorizationHandlerOptions;\n\n  beforeEach(() => {\n    app = express();\n    options = { provider: mockProvider };\n    const handler = authorizationHandler(options);\n    app.use('/authorize', handler);\n  });\n\n  describe('HTTP method validation', () => {\n    it('rejects non-GET/POST methods', async () => {\n      const response = await supertest(app)\n        .put('/authorize')\n        .query({ client_id: 'valid-client' });\n\n      expect(response.status).toBe(405); // Method not allowed response from handler\n    });\n  });\n\n  describe('Client validation', () => {\n    it('requires client_id parameter', async () => {\n      const response = await supertest(app)\n        .get('/authorize');\n\n      expect(response.status).toBe(400);\n      expect(response.text).toContain('client_id');\n    });\n\n    it('validates that client exists', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({ client_id: 'nonexistent-client' });\n\n      expect(response.status).toBe(400);\n    });\n  });\n\n  describe('Redirect URI validation', () => {\n    it('uses the only redirect_uri if client has just one and none provided', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.origin + location.pathname).toBe('https://example.com/callback');\n    });\n\n    it('requires redirect_uri if client has multiple', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'multi-redirect-client',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(400);\n    });\n\n    it('validates redirect_uri against client registered URIs', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://malicious.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(400);\n    });\n\n    it('accepts valid redirect_uri that client registered with', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.origin + location.pathname).toBe('https://example.com/callback');\n    });\n  });\n\n  describe('Authorization request validation', () => {\n    it('requires response_type=code', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'token', // invalid - we only support code flow\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.get('error')).toBe('invalid_request');\n    });\n\n    it('requires code_challenge parameter', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge_method: 'S256'\n          // Missing code_challenge\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.get('error')).toBe('invalid_request');\n    });\n\n    it('requires code_challenge_method=S256', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n\n```\n\n----------------------------------------\n\nTITLE: Creating STDIO Server Transport in Java\nDESCRIPTION: Initializes a STDIO-based server transport for MCP, which provides bidirectional JSON-RPC message handling over standard input/output streams. It supports non-blocking message processing and graceful shutdown.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_138\n\nLANGUAGE: java\nCODE:\n```\nStdioServerTransport transport = new StdioServerTransport(new ObjectMapper());\n```\n\n----------------------------------------\n\nTITLE: Testing STDIO Server Transport in TypeScript\nDESCRIPTION: Unit tests for the STDIO server transport implementation, verifying message handling, connection lifecycle, and multiple message processing capabilities.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_152\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should start then close cleanly\", async () => {\n  const server = new StdioServerTransport(input, output);\n  server.onerror = (error) => {\n    throw error;\n  };\n\n  let didClose = false;\n  server.onclose = () => {\n    didClose = true;\n  };\n\n  await server.start();\n  expect(didClose).toBeFalsy();\n  await server.close();\n  expect(didClose).toBeTruthy();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Task Model Structure in JSON\nDESCRIPTION: This JSON structure defines the data model for a task in the task management system. It includes fields for task identification, description, status, dependencies, priority, implementation details, and test strategy.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tests/fixtures/sample-prd.txt#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": 1,\n  \"title\": \"Task Title\",\n  \"description\": \"Brief task description\",\n  \"status\": \"pending|done|deferred\",\n  \"dependencies\": [0],\n  \"priority\": \"high|medium|low\",\n  \"details\": \"Implementation instructions\",\n  \"testStrategy\": \"Verification approach\"\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Token Flow Management in OAuth 2.0 with TypeScript\nDESCRIPTION: This snippet handles OAuth authentication flow including client registration, authorization code exchange, token refresh, and initiating new authorization flows. It manages the entire lifecycle of OAuth tokens with proper error handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n  let clientInformation = await Promise.resolve(provider.clientInformation());\n  if (!clientInformation) {\n    if (authorizationCode !== undefined) {\n      throw new Error(\"Existing OAuth client information is required when exchanging an authorization code\");\n    }\n\n    if (!provider.saveClientInformation) {\n      throw new Error(\"OAuth client information must be saveable for dynamic registration\");\n    }\n\n    const fullInformation = await registerClient(serverUrl, {\n      metadata,\n      clientMetadata: provider.clientMetadata,\n    });\n\n    await provider.saveClientInformation(fullInformation);\n    clientInformation = fullInformation;\n  }\n\n  // Exchange authorization code for tokens\n  if (authorizationCode !== undefined) {\n    const codeVerifier = await provider.codeVerifier();\n    const tokens = await exchangeAuthorization(serverUrl, {\n      metadata,\n      clientInformation,\n      authorizationCode,\n      codeVerifier,\n    });\n\n    await provider.saveTokens(tokens);\n    return \"AUTHORIZED\";\n  }\n\n  const tokens = await provider.tokens();\n\n  // Handle token refresh or new authorization\n  if (tokens?.refresh_token) {\n    try {\n      // Attempt to refresh the token\n      const newTokens = await refreshAuthorization(serverUrl, {\n        metadata,\n        clientInformation,\n        refreshToken: tokens.refresh_token,\n      });\n\n      await provider.saveTokens(newTokens);\n      return \"AUTHORIZED\";\n    } catch (error) {\n      console.error(\"Could not refresh OAuth tokens:\", error);\n    }\n  }\n\n  // Start new authorization flow\n  const { authorizationUrl, codeVerifier } = await startAuthorization(serverUrl, {\n    metadata,\n    clientInformation,\n    redirectUrl: provider.redirectUrl\n  });\n\n  await provider.saveCodeVerifier(codeVerifier);\n  await provider.redirectToAuthorization(authorizationUrl);\n  return \"REDIRECT\";\n```\n\n----------------------------------------\n\nTITLE: Error Handling Examples in JSON-RPC\nDESCRIPTION: Examples of protocol errors and tool execution errors returned in JSON-RPC format, showing both standard RPC errors and tool-specific error results.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_138\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Unknown tool: invalid_tool_name\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 4,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Failed to fetch weather data: API rate limit exceeded\"\n      }\n    ],\n    \"isError\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Prompt Registration with Arguments Schema\nDESCRIPTION: Tests registering a prompt with an argument schema to the McpServer and verifies the arguments are correctly reflected in the prompts list. Uses zod for schema validation of the prompt arguments.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_137\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mcpServer = new McpServer({\n  name: \"test server\",\n  version: \"1.0\",\n});\nconst client = new Client({\n  name: \"test client\",\n  version: \"1.0\",\n});\n\nmcpServer.prompt(\n  \"test\",\n  {\n    name: z.string(),\n    value: z.string(),\n  },\n  async ({ name, value }) => ({\n    messages: [\n      {\n        role: \"assistant\",\n        content: {\n          type: \"text\",\n          text: `${name}: ${value}`,\n        },\n      },\n    ],\n  }),\n);\n\nconst [clientTransport, serverTransport] =\n  InMemoryTransport.createLinkedPair();\n\nawait Promise.all([\n  client.connect(clientTransport),\n  mcpServer.server.connect(serverTransport),\n]);\n\nconst result = await client.request(\n  {\n    method: \"prompts/list\",\n  },\n  ListPromptsResultSchema,\n);\n\nexpect(result.prompts).toHaveLength(1);\nexpect(result.prompts[0].name).toBe(\"test\");\nexpect(result.prompts[0].arguments).toEqual([\n  { name: \"name\", required: true },\n  { name: \"value\", required: true },\n]);\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Client with stdio Transport in Python\nDESCRIPTION: Demonstrates how to set up an MCP client using the stdio transport in Python. The code initializes parameters for connecting to a server, then establishes a client session using streams from the stdio_client context manager.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nparams = StdioServerParameters(\n    command=\"./server\",\n    args=[\"--option\", \"value\"]\n)\n\nasync with stdio_client(params) as streams:\n    async with ClientSession(streams[0], streams[1]) as session:\n        await session.initialize()\n```\n\n----------------------------------------\n\nTITLE: Tools Capability Declaration JSON for MCP Server\nDESCRIPTION: JSON structure for declaring tools capability in MCP server, indicating the server supports tool operations and can notify when the available tool list changes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_59\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"tools\": {\n      \"listChanged\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing MCP Lifecycle Phases with Mermaid\nDESCRIPTION: A sequence diagram showing the lifecycle phases of an MCP client-server connection, including initialization phase with capability negotiation, operation phase for normal protocol operations, and graceful shutdown.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_90\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: Initialization Phase\n    activate Client\n    Client->>+Server: initialize request\n    Server-->>Client: initialize response\n    Client--)Server: initialized notification\n\n    Note over Client,Server: Operation Phase\n    rect rgb(200, 220, 250)\n        note over Client,Server: Normal protocol operations\n    end\n\n    Note over Client,Server: Shutdown\n    Client--)-Server: Disconnect\n    deactivate Server\n    Note over Client,Server: Connection closed\n```\n\n----------------------------------------\n\nTITLE: Defining Resource and ResourceTemplate Interfaces in TypeScript\nDESCRIPTION: Defines interfaces for representing resources and resource templates, including URIs, names, descriptions, and MIME types.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_167\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface Resource {\n  uri: string;\n  name: string;\n  description?: string;\n  mimeType?: string;\n  annotations?: Annotations;\n}\n\nexport interface ResourceTemplate {\n  uriTemplate: string;\n  name: string;\n  description?: string;\n  mimeType?: string;\n  annotations?: Annotations;\n}\n```\n\n----------------------------------------\n\nTITLE: Resource Subscription and Update\nDESCRIPTION: JSON-RPC messages for subscribing to resource changes and receiving update notifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_56\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 4,\n  \"method\": \"resources/subscribe\",\n  \"params\": {\n    \"uri\": \"file:///project/src/main.rs\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/resources/updated\",\n  \"params\": {\n    \"uri\": \"file:///project/src/main.rs\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Resources from FastMCP Client and Verifying with Vitest in TypeScript\nDESCRIPTION: This client-side test snippet calls `client.listResources()` to retrieve the list of available resources from the server. It then uses `vitest`'s `expect` to assert that the returned list matches the expected structure, containing the details (URI, name, MIME type) of the 'Application Logs' resource previously added on the server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexpect(await client.listResources()).toEqual({\n  resources: [\n    {\n      uri: \"file:///logs/app.log\",\n      name: \"Application Logs\",\n      mimeType: \"text/plain\",\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Autocomplete Interfaces for Code Assistance\nDESCRIPTION: TypeScript interfaces for code completion functionality, allowing clients to request completion options from the server. Includes structures for referencing resources and prompts.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_155\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CompleteRequest extends Request {\n  method: \"completion/complete\";\n  params: {\n    ref: PromptReference | ResourceReference;\n    /**\n     * The argument's information\n     */\n    argument: {\n      /**\n       * The name of the argument\n       */\n      name: string;\n      /**\n       * The value of the argument to use for completion matching.\n       */\n      value: string;\n    };\n  };\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CompleteResult extends Result {\n  completion: {\n    /**\n     * An array of completion values. Must not exceed 100 items.\n     */\n    values: string[];\n    /**\n     * The total number of completion options available. This can exceed the number of values actually sent in the response.\n     */\n    total?: number;\n    /**\n     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.\n     */\n    hasMore?: boolean;\n  };\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ResourceReference {\n  type: \"ref/resource\";\n  /**\n   * The URI or URI template of the resource.\n   *\n   * @format uri-template\n   */\n  uri: string;\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PromptReference {\n  type: \"ref/prompt\";\n  /**\n   * The name of the prompt or prompt template\n   */\n  name: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Progress Notifications in JSON-RPC Protocol\nDESCRIPTION: Processes progress notifications by finding the corresponding handler and resetting timeouts for ongoing requests. Reports errors for unknown progress tokens.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_171\n\nLANGUAGE: typescript\nCODE:\n```\nprivate _onprogress(notification: ProgressNotification): void {\n  const { progressToken, ...params } = notification.params;\n  const messageId = Number(progressToken);\n  \n  const handler = this._progressHandlers.get(messageId);\n  if (!handler) {\n    this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));\n    return;\n  }\n\n  const responseHandler = this._responseHandlers.get(messageId);\n  if (this._timeoutInfo.has(messageId) && responseHandler) {\n    try {\n      this._resetTimeout(messageId);\n    } catch (error) {\n      responseHandler(error as Error);\n      return;\n    }\n  }\n\n  handler(params);\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Inferred Types from Zod Schemas in TypeScript\nDESCRIPTION: This section exports TypeScript types inferred from the previously defined Zod schemas using the Infer utility type. It covers various components of the MCP system.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_225\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type ProgressToken = Infer<typeof ProgressTokenSchema>;\nexport type Cursor = Infer<typeof CursorSchema>;\nexport type Request = Infer<typeof RequestSchema>;\nexport type Notification = Infer<typeof NotificationSchema>;\nexport type Result = Infer<typeof ResultSchema>;\nexport type RequestId = Infer<typeof RequestIdSchema>;\nexport type JSONRPCRequest = Infer<typeof JSONRPCRequestSchema>;\nexport type JSONRPCNotification = Infer<typeof JSONRPCNotificationSchema>;\nexport type JSONRPCResponse = Infer<typeof JSONRPCResponseSchema>;\nexport type JSONRPCError = Infer<typeof JSONRPCErrorSchema>;\nexport type JSONRPCMessage = Infer<typeof JSONRPCMessageSchema>;\n\n// ... (additional type exports)\n```\n\n----------------------------------------\n\nTITLE: Defining OAuth Server Provider Interface in TypeScript\nDESCRIPTION: This interface outlines the methods required for implementing a full OAuth server. It includes functions for authorization, token exchange, verification, and optional token revocation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_96\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface OAuthServerProvider {\n  get clientsStore(): OAuthRegisteredClientsStore;\n\n  authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise<void>;\n\n  challengeForAuthorizationCode(client: OAuthClientInformationFull, authorizationCode: string): Promise<string>;\n\n  exchangeAuthorizationCode(client: OAuthClientInformationFull, authorizationCode: string): Promise<OAuthTokens>;\n\n  exchangeRefreshToken(client: OAuthClientInformationFull, refreshToken: string, scopes?: string[]): Promise<OAuthTokens>;\n\n  verifyAccessToken(token: string): Promise<AuthInfo>;\n\n  revokeToken?(client: OAuthClientInformationFull, request: OAuthTokenRevocationRequest): Promise<void>;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing MCP Server Class with Core Properties\nDESCRIPTION: Defines the main McpServer class with property declarations for resources, tools, and prompts. Includes constructor and basic connection management methods.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_143\n\nLANGUAGE: typescript\nCODE:\n```\nexport class McpServer {\n  public readonly server: Server;\n\n  private _registeredResources: { [uri: string]: RegisteredResource } = {};\n  private _registeredResourceTemplates: {\n    [name: string]: RegisteredResourceTemplate;\n  } = {};\n  private _registeredTools: { [name: string]: RegisteredTool } = {};\n  private _registeredPrompts: { [name: string]: RegisteredPrompt } = {};\n\n  constructor(serverInfo: Implementation, options?: ServerOptions) {\n    this.server = new Server(serverInfo, options);\n  }\n\n  async connect(transport: Transport): Promise<void> {\n    return await this.server.connect(transport);\n  }\n\n  async close(): Promise<void> {\n    await this.server.close();\n  }\n```\n\n----------------------------------------\n\nTITLE: Generating Image Content from URL, Path, or Buffer in TypeScript\nDESCRIPTION: Function that creates an image content object from a URL, file path, or Buffer. It handles different input sources, fetches and processes the image data, and returns a properly formatted ImageContent object with base64-encoded data and appropriate MIME type.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Generates an image content object from a URL, file path, or buffer.\n */\nexport const imageContent = async (\n  input: { url: string } | { path: string } | { buffer: Buffer },\n): Promise<ImageContent> => {\n  let rawData: Buffer;\n\n  if (\"url\" in input) {\n    const response = await fetch(input.url);\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch image from URL: ${response.statusText}`);\n    }\n\n    rawData = Buffer.from(await response.arrayBuffer());\n  } else if (\"path\" in input) {\n    rawData = await readFile(input.path);\n  } else if (\"buffer\" in input) {\n    rawData = input.buffer;\n  } else {\n    throw new Error(\n      \"Invalid input: Provide a valid 'url', 'path', or 'buffer'\",\n    );\n  }\n\n  const mimeType = await fileTypeFromBuffer(rawData);\n\n  const base64Data = rawData.toString(\"base64\");\n\n  return {\n    type: \"image\",\n    data: base64Data,\n    mimeType: mimeType?.mime ?? \"image/png\",\n  } as const;\n};\n```\n\n----------------------------------------\n\nTITLE: Listing Tools Response in JSON-RPC Format\nDESCRIPTION: Response format for the tools/list request, containing an array of available tools with their metadata and input schemas. The response includes pagination support through the nextCursor field.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_61\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"tools\": [\n      {\n        \"name\": \"get_weather\",\n        \"description\": \"Get current weather information for a location\",\n        \"inputSchema\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"location\": {\n              \"type\": \"string\",\n              \"description\": \"City name or zip code\"\n            }\n          },\n          \"required\": [\"location\"]\n        }\n      }\n    ],\n    \"nextCursor\": \"next-page-cursor\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Directory Structure for Task Management Tool - Markdown\nDESCRIPTION: This Markdown code diagram illustrates the expected file/directory layout of the project, using a tree structure with comments. It specifies the location and hierarchy of key folders such as scripts, tasks, and configuration files. This is intended for documentation, onboarding, or as a reference for contributors. It covers code, environment, ignore files, and the JSON-driven task store, making architectural setup and navigation straightforward.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/prd.txt#2025-04-23_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n```\n/\n├── .cursor/\n│   └── rules/\n│       ├── dev_workflow.mdc\n│       ├── cursor_rules.mdc\n│       └── self_improve.mdc\n├── scripts/\n│   ├── dev.js\n│   └── README.md\n├── tasks/\n│   ├── task_001.txt\n│   ├── task_002.txt\n│   └── ...\n├── .env\n├── .env.example\n├── .gitignore\n├── package.json\n├── README.md\n└── tasks.json\n```\n```\n\n----------------------------------------\n\nTITLE: Standardized Error Response Format for JSON API - JavaScript\nDESCRIPTION: This snippet defines a recommended error response format for functions operating in JSON mode, standardizing structure with properties for error code, user-facing message, additional details, and stack trace (optional based on 'NODE_ENV'). Dependencies include a consistent error-handling policy for API endpoints and the use of Node.js. Input parameters are errors encountered in function execution; output is a JSON-serializable error object. The format is meant for use within refactored MCP task functions and ensures robust, transparent debugging in development environments. The stack trace may be omitted in production for security.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n{\n  code: 'ERROR_CODE',\n  message: 'Human-readable message',\n  details: {}, // Additional context when available\n  stack: process.env.NODE_ENV === 'development' ? error.stack : undefined\n}\n```\n\n----------------------------------------\n\nTITLE: Task Selection Algorithm in JavaScript\nDESCRIPTION: Algorithm for selecting optimal tasks based on priority, dependencies, and project status, including logic for handling blocked tasks and workflow optimization.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_014.txt#2025-04-23_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Setting Up Modular Core Direct Function Structure - Node.js JavaScript\nDESCRIPTION: This snippet documents the modularization of core direct functions, where each is moved to its own file under mcp-server/src/core/direct-functions/ and re-exported from task-master-core.js. The structure allows for clear utility imports, standardized exports (usually as a directFunctions map or individual exports), and facilitates unit testing and backward compatibility.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n// task-master-core.js (import/export hub)\nconst addSubtaskDirect = require('./direct-functions/addSubtaskDirect');\nconst removeSubtaskDirect = require('./direct-functions/removeSubtaskDirect');\nconst analyzeTaskComplexityDirect = require('./direct-functions/analyzeTaskComplexityDirect');\nconst clearSubtasksDirect = require('./direct-functions/clearSubtasksDirect');\nconst expandAllTasksDirect = require('./direct-functions/expandAllTasksDirect');\n\nmodule.exports = {\n  addSubtaskDirect,\n  removeSubtaskDirect,\n  analyzeTaskComplexityDirect,\n  clearSubtasksDirect,\n  expandAllTasksDirect,\n  // ... other direct function exports\n};\n```\n\n----------------------------------------\n\nTITLE: Security Requirement - Prompt Validation\nDESCRIPTION: Core security requirement specifying that implementations must validate all prompt inputs and outputs. This is critical for preventing injection attacks and unauthorized access to resources.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_47\n\nLANGUAGE: markdown\nCODE:\n```\nImplementations **MUST** carefully validate all prompt inputs and outputs to prevent\\ninjection attacks or unauthorized access to resources.\n```\n\n----------------------------------------\n\nTITLE: New Task Addition Commands in Task Master CLI\nDESCRIPTION: Commands for adding new tasks with AI assistance, including options for dependencies and priority.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n# Add a new task using AI\ntask-master add-task --prompt=\"Description of the new task\"\n\n# Add a task with dependencies\ntask-master add-task --prompt=\"Description\" --dependencies=1,2,3\n\n# Add a task with priority\ntask-master add-task --prompt=\"Description\" --priority=high\n```\n\n----------------------------------------\n\nTITLE: Using Source Adapter Utilities in JavaScript\nDESCRIPTION: Shows how to use helper functions `adaptForMcp` and `sourceSplitFunction` from `./source-adapter.js` to simplify making functions compatible with both CLI and MCP interfaces. `adaptForMcp` adds basic source handling, while `sourceSplitFunction` allows separate implementations for each interface.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/MCP_INTEGRATION.md#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { adaptForMcp, sourceSplitFunction } from './source-adapter.js';\n\n// Simple adaptation - just adds source parameter support\nexport const simpleFunction = adaptForMcp(originalFunction);\n\n// Split implementation - completely different code paths for CLI vs MCP\nexport const complexFunction = sourceSplitFunction(\n\t// CLI version with UI\n\tfunction (param1, param2) {\n\t\tdisplayBanner();\n\t\tconsole.log(`Processing ${param1}...`);\n\t\t// ... CLI implementation\n\t},\n\t// MCP version with structured return\n\tfunction (param1, param2, options = {}) {\n\t\t// ... MCP implementation\n\t\treturn { success: true, data };\n\t}\n);\n```\n\n----------------------------------------\n\nTITLE: Request Handlers Setup\nDESCRIPTION: Implementation of various request handlers for completion, roots management, logging and tool execution. Includes error handling and progress reporting.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\nprivate setupCompleteHandlers() {\n    this.#server.setRequestHandler(CompleteRequestSchema, async (request) => {\n      if (request.params.ref.type === \"ref/prompt\") {\n        const prompt = this.#prompts.find(\n          (prompt) => prompt.name === request.params.ref.name,\n        );\n\n        if (!prompt) {\n          throw new UnexpectedStateError(\"Unknown prompt\", {\n            request,\n          });\n        }\n\n        if (!prompt.complete) {\n          throw new UnexpectedStateError(\"Prompt does not support completion\", {\n            request,\n          });\n        }\n\n        const completion = CompletionZodSchema.parse(\n          await prompt.complete(\n            request.params.argument.name,\n            request.params.argument.value,\n          ),\n        );\n\n        return {\n          completion,\n        };\n      }\n\n      if (request.params.ref.type === \"ref/resource\") {\n        const resource = this.#resourceTemplates.find(\n          (resource) => resource.uriTemplate === request.params.ref.uri,\n        );\n\n        if (!resource) {\n          throw new UnexpectedStateError(\"Unknown resource\", {\n            request,\n          });\n        }\n\n        if (!(\"uriTemplate\" in resource)) {\n          throw new UnexpectedStateError(\"Unexpected resource\");\n        }\n\n        if (!resource.complete) {\n          throw new UnexpectedStateError(\n            \"Resource does not support completion\",\n            {\n              request,\n            },\n          );\n        }\n\n        const completion = CompletionZodSchema.parse(\n          await resource.complete(\n            request.params.argument.name,\n            request.params.argument.value,\n          ),\n        );\n\n        return {\n          completion,\n        };\n      }\n\n      throw new UnexpectedStateError(\"Unexpected completion request\", {\n        request,\n      });\n    });\n  }\n```\n\n----------------------------------------\n\nTITLE: Requesting Root List in MCP\nDESCRIPTION: JSON-RPC request from server to client to list available roots.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_99\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"roots/list\"\n}\n```\n\n----------------------------------------\n\nTITLE: Reading a Specific Resource from FastMCP Client and Verifying Content in TypeScript\nDESCRIPTION: This client-side test snippet demonstrates reading a specific resource by its URI. It calls `client.readResource()` with the URI 'file:///logs/app.log'. It then uses `vitest`'s `expect` to assert that the response contains the correct resource details along with its content ('Example log content') as returned by the server's `load` function for that resource.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nexpect(\n  await client.readResource({\n    uri: \"file:///logs/app.log\",\n  }),\n).toEqual({\n  contents: [\n    {\n      uri: \"file:///logs/app.log\",\n      name: \"Application Logs\",\n      text: \"Example log content\",\n      mimeType: \"text/plain\",\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Tool Execution in FastMCP\nDESCRIPTION: This test case verifies that tools can be executed correctly through the FastMCP server. It adds an 'add' tool and tests if it correctly adds two numbers when called by the client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"calls a tool\", async () => {\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      server.addTool({\n        name: \"add\",\n        description: \"Add two numbers\",\n        parameters: z.object({\n          a: z.number(),\n          b: z.number(),\n        }),\n        execute: async (args) => {\n          return String(args.a + args.b);\n        },\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      expect(\n        await client.callTool({\n          name: \"add\",\n          arguments: {\n            a: 1,\n            b: 2,\n          },\n        }),\n      ).toEqual({\n        content: [{ type: \"text\", text: \"3\" }],\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Completion Request in JSON\nDESCRIPTION: JSON request for getting completion suggestions for a prompt argument.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_32\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"completion/complete\",\n  \"params\": {\n    \"ref\": {\n      \"type\": \"ref/prompt\",\n      \"name\": \"code_review\"\n    },\n    \"argument\": {\n      \"name\": \"language\",\n      \"value\": \"py\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Resource Registration\nDESCRIPTION: Tests that McpServer allows registering multiple different resources. Registers two resources with different URIs and verifies that no exceptions are thrown during registration.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_130\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mcpServer = new McpServer({\n  name: \"test server\",\n  version: \"1.0\",\n});\n\n// This should succeed\nmcpServer.resource(\"resource1\", \"test://resource1\", async () => ({\n  contents: [\n    {\n      uri: \"test://resource1\",\n      text: \"Test content 1\",\n    },\n  ],\n}));\n\n// This should also succeed and not throw about request handlers\nmcpServer.resource(\"resource2\", \"test://resource2\", async () => ({\n  contents: [\n    {\n      uri: \"test://resource2\",\n      text: \"Test content 2\",\n    },\n  ],\n}));\n```\n\n----------------------------------------\n\nTITLE: Reading Resources Response Structure in TypeScript\nDESCRIPTION: Defines the structure of the response for a resources/read request in MCP. It includes an array of resource contents, each with a URI, optional MIME type, and either text or blob content.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  contents: [\n    {\n      uri: string;        // The URI of the resource\n      mimeType?: string;  // Optional MIME type\n\n      // One of:\n      text?: string;      // For text resources\n      blob?: string;      // For binary resources (base64 encoded)\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Commit Prompt in TypeScript\nDESCRIPTION: Demonstrates how to add a prompt template for generating Git commit messages with required arguments and async loading.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\nserver.addPrompt({\n  name: \"git-commit\",\n  description: \"Generate a Git commit message\",\n  arguments: [\n    {\n      name: \"changes\",\n      description: \"Git diff or description of changes\",\n      required: true,\n    },\n  ],\n  load: async (args) => {\n    return `Generate a concise but descriptive commit message for these changes:\\n\\n${args.changes}`;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Clearing All Subtasks Directly via MCP - Node.js JavaScript\nDESCRIPTION: Implements functions and tools to clear all subtasks from a specific parent task, using a modular direct function structure in Node.js. This snippet validates the taskId parameter, uses robust error handling, and exposes the action as a standardized MCP command returning status and error info as applicable.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\n// clearSubtasksDirect.js\nconst { clearSubtasks } = require('../task-manager');\nconst { findTasksJsonPath } = require('../utils');\n\nmodule.exports = async function clearSubtasksDirect({ taskId }) {\n  try {\n    const tasksPath = findTasksJsonPath();\n    const result = await clearSubtasks({ tasksPath, taskId });\n    return { success: true, data: result };\n  } catch (error) {\n    return { success: false, error };\n  }\n};\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// clear-subtasks.js (MCP tool)\nconst z = require('zod');\nconst { executeMCPToolAction } = require('./utils');\nconst { clearSubtasksDirect } = require('../core/task-master-core');\n\nconst clearSubtasksSchema = z.object({\n  taskId: z.string(),\n});\n\nfunction registerClearSubtasksTool(server) {\n  server.addTool({\n    name: 'clear_subtasks',\n    params: clearSubtasksSchema,\n    execute: (params) => executeMCPToolAction(() => clearSubtasksDirect(params)),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JSON-RPC Types in TypeScript for MCP\nDESCRIPTION: Defines the basic JSON-RPC message types that form the foundation of the Model Context Protocol, including requests, notifications, responses, and error formats following the JSON-RPC 2.0 specification.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_160\n\nLANGUAGE: typescript\nCODE:\n```\n/* JSON-RPC types */\n\n/**\n * Refers to any valid JSON-RPC object that can be decoded off the wire, or encoded to be sent.\n */\nexport type JSONRPCMessage =\n  | JSONRPCRequest\n  | JSONRPCNotification\n  | JSONRPCBatchRequest\n  | JSONRPCResponse\n  | JSONRPCError\n  | JSONRPCBatchResponse;\n\n/**\n * A JSON-RPC batch request, as described in https://www.jsonrpc.org/specification#batch.\n */\nexport type JSONRPCBatchRequest = (JSONRPCRequest | JSONRPCNotification)[];\n\n/**\n * A JSON-RPC batch response, as described in https://www.jsonrpc.org/specification#batch.\n */\nexport type JSONRPCBatchResponse = (JSONRPCResponse | JSONRPCError)[];\n\nexport const LATEST_PROTOCOL_VERSION = \"2025-03-26\";\nexport const JSONRPC_VERSION = \"2.0\";\n\n/**\n * A progress token, used to associate progress notifications with the original request.\n */\nexport type ProgressToken = string | number;\n\n/**\n * An opaque token used to represent a cursor for pagination.\n */\nexport type Cursor = string;\n\nexport interface Request {\n  method: string;\n  params?: {\n    _meta?: {\n      /**\n       * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\n       */\n      progressToken?: ProgressToken;\n    };\n    [key: string]: unknown;\n  };\n}\n\nexport interface Notification {\n  method: string;\n  params?: {\n    /**\n     * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.\n     */\n    _meta?: { [key: string]: unknown };\n    [key: string]: unknown;\n  };\n}\n\nexport interface Result {\n  /**\n   * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.\n   */\n  _meta?: { [key: string]: unknown };\n  [key: string]: unknown;\n}\n\n/**\n * A uniquely identifying ID for a request in JSON-RPC.\n */\nexport type RequestId = string | number;\n\n/**\n * A request that expects a response.\n */\nexport interface JSONRPCRequest extends Request {\n  jsonrpc: typeof JSONRPC_VERSION;\n  id: RequestId;\n}\n\n/**\n * A notification which does not expect a response.\n */\nexport interface JSONRPCNotification extends Notification {\n  jsonrpc: typeof JSONRPC_VERSION;\n}\n\n/**\n * A successful (non-error) response to a request.\n */\nexport interface JSONRPCResponse {\n  jsonrpc: typeof JSONRPC_VERSION;\n  id: RequestId;\n  result: Result;\n}\n\n// Standard JSON-RPC error codes\nexport const PARSE_ERROR = -32700;\nexport const INVALID_REQUEST = -32600;\nexport const METHOD_NOT_FOUND = -32601;\nexport const INVALID_PARAMS = -32602;\nexport const INTERNAL_ERROR = -32603;\n\n/**\n * A response to a request that indicates an error occurred.\n */\nexport interface JSONRPCError {\n  jsonrpc: typeof JSONRPC_VERSION;\n  id: RequestId;\n  error: {\n    /**\n     * The error type that occurred.\n     */\n    code: number;\n    /**\n     * A short description of the error. The message SHOULD be limited to a concise single sentence.\n     */\n    message: string;\n    /**\n     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).\n     */\n    data?: unknown;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Zero-Argument Prompt Registration\nDESCRIPTION: Tests registering a prompt without arguments to the McpServer and verifies it appears correctly in the prompts list. The registered prompt should have a name but no argument schema.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_136\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mcpServer = new McpServer({\n  name: \"test server\",\n  version: \"1.0\",\n});\nconst client = new Client({\n  name: \"test client\",\n  version: \"1.0\",\n});\n\nmcpServer.prompt(\"test\", async () => ({\n  messages: [\n    {\n      role: \"assistant\",\n      content: {\n        type: \"text\",\n        text: \"Test response\",\n      },\n    },\n  ],\n}));\n\nconst [clientTransport, serverTransport] =\n  InMemoryTransport.createLinkedPair();\n\nawait Promise.all([\n  client.connect(clientTransport),\n  mcpServer.server.connect(serverTransport),\n]);\n\nconst result = await client.request(\n  {\n    method: \"prompts/list\",\n  },\n  ListPromptsResultSchema,\n);\n\nexpect(result.prompts).toHaveLength(1);\nexpect(result.prompts[0].name).toBe(\"test\");\nexpect(result.prompts[0].arguments).toBeUndefined();\n```\n\n----------------------------------------\n\nTITLE: Receiving Dynamic Prompt Response with Embedded Resource Content in JSON\nDESCRIPTION: This JSON example shows the `messages` array returned by the server when handling a `prompts/get` request for a dynamic prompt like `analyze-project`. It demonstrates how the server can embed actual content from resources (identified by URIs provided in the request arguments) directly into the message structure using `content.type: 'resource'`. The example includes fetched log data and code file content.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": {\n        \"type\": \"text\",\n        \"text\": \"Analyze these system logs and the code file for any issues:\"\n      }\n    },\n    {\n      \"role\": \"user\",\n      \"content\": {\n        \"type\": \"resource\",\n        \"resource\": {\n          \"uri\": \"logs://recent?timeframe=1h\",\n          \"text\": \"[2024-03-14 15:32:11] ERROR: Connection timeout in network.py:127\\n[2024-03-14 15:32:15] WARN: Retrying connection (attempt 2/3)\\n[2024-03-14 15:32:20] ERROR: Max retries exceeded\",\n          \"mimeType\": \"text/plain\"\n        }\n      }\n    },\n    {\n      \"role\": \"user\",\n      \"content\": {\n        \"type\": \"resource\",\n        \"resource\": {\n          \"uri\": \"file:///path/to/code.py\",\n          \"text\": \"def connect_to_service(timeout=30):\\n    retries = 3\\n    for attempt in range(retries):\\n        try:\\n            return establish_connection(timeout)\\n        except TimeoutError:\\n            if attempt == retries - 1:\\n                raise\\n            time.sleep(5)\\n\\ndef establish_connection(timeout):\\n    # Connection implementation\\n    pass\",\n          \"mimeType\": \"text/x-python\"\n        }\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Message Flow Sequence Diagram\nDESCRIPTION: Mermaid sequence diagram showing the interaction flow between LLM, Client and Server for tool discovery, selection, invocation and updates.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_136\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant LLM\n    participant Client\n    participant Server\n\n    Note over Client,Server: Discovery\n    Client->>Server: tools/list\n    Server-->>Client: List of tools\n\n    Note over Client,LLM: Tool Selection\n    LLM->>Client: Select tool to use\n\n    Note over Client,Server: Invocation\n    Client->>Server: tools/call\n    Server-->>Client: Tool result\n    Client->>LLM: Process result\n\n    Note over Client,Server: Updates\n    Server--)Client: tools/list_changed\n    Client->>Server: tools/list\n    Server-->>Client: Updated tools\n```\n\n----------------------------------------\n\nTITLE: Exposing Core Functions via task-master-core.js in JavaScript\nDESCRIPTION: Illustrates how to make a newly implemented core function (`newFeature` from `task-manager.js`) available for programmatic use by the MCP server. It involves importing the function and exporting an async wrapper that extracts arguments and calls the core function via `executeFunction`, passing the 'mcp' source implicitly or explicitly via options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/MCP_INTEGRATION.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// In mcp-server/src/core/task-master-core.js\nimport { newFeature } from '../../../scripts/modules/task-manager.js';\n\n// Add to exports\nexport default {\n\t// ... existing functions\n\n\tasync newFeature(args = {}, options = {}) {\n\t\tconst { param1, param2 } = args;\n\t\treturn executeFunction(newFeature, [param1, param2], options);\n\t}\n};\n```\n\n----------------------------------------\n\nTITLE: Research Formatter Utility Structure - JavaScript\nDESCRIPTION: Module structure for processing and formatting research results with various output options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_051.txt#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nutils/researchFormatter.js\n\n// Terminal output formatting\n// File saving functionality\n// Clipboard integration\n// Summarization function\n```\n\n----------------------------------------\n\nTITLE: Resource Subscription Flow\nDESCRIPTION: Message sequence diagram showing the flow of resource discovery, access, subscription and updates between client and server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_131\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: Resource Discovery\n    Client->>Server: resources/list\n    Server-->>Client: List of resources\n\n    Note over Client,Server: Resource Access\n    Client->>Server: resources/read\n    Server-->>Client: Resource contents\n\n    Note over Client,Server: Subscriptions\n    Client->>Server: resources/subscribe\n    Server-->>Client: Subscription confirmed\n\n    Note over Client,Server: Updates\n    Server--)Client: notifications/resources/updated\n    Client->>Server: resources/read\n    Server-->>Client: Updated contents\n```\n\n----------------------------------------\n\nTITLE: Quick Start CLI Commands\nDESCRIPTION: Essential CLI commands for managing tasks with Task Master after global installation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README-task-master.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Initialize a new project\ntask-master init\n\n# Parse a PRD and generate tasks\ntask-master parse-prd your-prd.txt\n\n# List all tasks\ntask-master list\n\n# Show the next task to work on\ntask-master next\n\n# Generate task files\ntask-master generate\n```\n\n----------------------------------------\n\nTITLE: Implementing a New Feature Core Function in JavaScript\nDESCRIPTION: Provides a concrete example of implementing a new feature (`newFeature`) within a core module (`task-manager.js`). It follows the established pattern, using `options.source` to control UI visibility and return values (structured object for MCP, console output for CLI), and includes source-specific error handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/MCP_INTEGRATION.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// In scripts/modules/task-manager.js\nexport async function newFeature(param1, param2, options = {}) {\n\ttry {\n\t\t// Source-specific UI\n\t\tif (options.source !== 'mcp') {\n\t\t\tdisplayBanner();\n\t\t\tconsole.log(chalk.blue('Running new feature...'));\n\t\t}\n\n\t\t// Shared core logic\n\t\tconst result = processFeature(param1, param2);\n\n\t\t// Source-specific return handling\n\t\tif (options.source === 'mcp') {\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: result\n\t\t\t};\n\t\t}\n\n\t\t// CLI output\n\t\tconsole.log(chalk.green('Feature completed successfully!'));\n\t\tdisplayOutput(result);\n\t} catch (error) {\n\t\t// Error handling based on source\n\t\tif (options.source === 'mcp') {\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\terror: error.message\n\t\t\t};\n\t\t}\n\n\t\tconsole.error(chalk.red(`Error: ${error.message}`));\n\t\tprocess.exit(1);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Method Restriction Middleware\nDESCRIPTION: This middleware function restricts endpoints to specified HTTP methods, returning a 405 Method Not Allowed error for unauthorized methods. It also sets the appropriate 'Allow' header with the list of permitted methods as required by HTTP standards.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_78\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Middleware to handle unsupported HTTP methods with a 405 Method Not Allowed response.\n * \n * @param allowedMethods Array of allowed HTTP methods for this endpoint (e.g., ['GET', 'POST'])\n * @returns Express middleware that returns a 405 error if method not in allowed list\n */\nexport function allowedMethods(allowedMethods: string[]): RequestHandler {\n  return (req, res, next) => {\n    if (allowedMethods.includes(req.method)) {\n      next();\n      return;\n    }\n\n    const error = new MethodNotAllowedError(`The method ${req.method} is not allowed for this endpoint`);\n    res.status(405)\n      .set('Allow', allowedMethods.join(', '))\n      .json(error.toResponseObject());\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling in TypeScript for MCP Tools\nDESCRIPTION: Demonstrates proper error handling pattern for MCP tools in TypeScript. The code shows how to structure tool responses with error reporting that allows the LLM to see and handle errors appropriately.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\ntry {\n  // Tool operation\n  const result = performOperation();\n  return {\n    content: [\n      {\n        type: \"text\",\n        text: `Operation successful: ${result}`\n      }\n    ]\n  };\n} catch (error) {\n  return {\n    isError: true,\n    content: [\n      {\n        type: \"text\",\n        text: `Error: ${error.message}`\n      }\n    ]\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Paginated Request Format in JSON-RPC\nDESCRIPTION: JSON-RPC request for continuing pagination by including the cursor received from a previous response. Used to retrieve subsequent pages of results.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_113\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"resources/list\",\n  \"params\": {\n    \"cursor\": \"eyJwYWdlIjogMn0=\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing URI Template Implementation in TypeScript\nDESCRIPTION: Test suite for the UriTemplate class that handles URI template expansion and matching according to RFC 6570. Tests various expansion operators and matching capabilities.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_182\n\nLANGUAGE: typescript\nCODE:\n```\nimport { UriTemplate } from \"./uriTemplate.js\";\n\ndescribe(\"UriTemplate\", () => {\n  describe(\"isTemplate\", () => {\n    it(\"should return true for strings containing template expressions\", () => {\n      expect(UriTemplate.isTemplate(\"{foo}\")).toBe(true);\n      expect(UriTemplate.isTemplate(\"/users/{id}\")).toBe(true);\n      expect(UriTemplate.isTemplate(\"http://example.com/{path}/{file}\")).toBe(true);\n      expect(UriTemplate.isTemplate(\"/search{?q,limit}\")).toBe(true);\n    });\n\n    it(\"should return false for strings without template expressions\", () => {\n      expect(UriTemplate.isTemplate(\"\")).toBe(false);\n      expect(UriTemplate.isTemplate(\"plain string\")).toBe(false);\n      expect(UriTemplate.isTemplate(\"http://example.com/foo/bar\")).toBe(false);\n      expect(UriTemplate.isTemplate(\"{}\")).toBe(false); // Empty braces don't count\n      expect(UriTemplate.isTemplate(\"{ }\")).toBe(false); // Just whitespace doesn't count\n    });\n  });\n\n  describe(\"simple string expansion\", () => {\n    it(\"should expand simple string variables\", () => {\n      const template = new UriTemplate(\"http://example.com/users/{username}\");\n      expect(template.expand({ username: \"fred\" })).toBe(\n        \"http://example.com/users/fred\",\n      );\n    });\n\n    it(\"should handle multiple variables\", () => {\n      const template = new UriTemplate(\"{x,y}\");\n      expect(template.expand({ x: \"1024\", y: \"768\" })).toBe(\"1024,768\");\n    });\n\n    it(\"should encode reserved characters\", () => {\n      const template = new UriTemplate(\"{var}\");\n      expect(template.expand({ var: \"value with spaces\" })).toBe(\n        \"value%20with%20spaces\",\n      );\n    });\n  });\n\n  describe(\"reserved expansion\", () => {\n    it(\"should not encode reserved characters with + operator\", () => {\n      const template = new UriTemplate(\"{+path}/here\");\n      expect(template.expand({ path: \"/foo/bar\" })).toBe(\"/foo/bar/here\");\n    });\n  });\n\n  describe(\"fragment expansion\", () => {\n    it(\"should add # prefix and not encode reserved chars\", () => {\n      const template = new UriTemplate(\"X{#var}\");\n      expect(template.expand({ var: \"/test\" })).toBe(\"X#/test\");\n    });\n  });\n\n  describe(\"label expansion\", () => {\n    it(\"should add . prefix\", () => {\n      const template = new UriTemplate(\"X{.var}\");\n      expect(template.expand({ var: \"test\" })).toBe(\"X.test\");\n    });\n  });\n\n  describe(\"path expansion\", () => {\n    it(\"should add / prefix\", () => {\n      const template = new UriTemplate(\"X{/var}\");\n      expect(template.expand({ var: \"test\" })).toBe(\"X/test\");\n    });\n  });\n\n  describe(\"query expansion\", () => {\n    it(\"should add ? prefix and name=value format\", () => {\n      const template = new UriTemplate(\"X{?var}\");\n      expect(template.expand({ var: \"test\" })).toBe(\"X?var=test\");\n    });\n  });\n\n  describe(\"form continuation expansion\", () => {\n    it(\"should add & prefix and name=value format\", () => {\n      const template = new UriTemplate(\"X{&var}\");\n      expect(template.expand({ var: \"test\" })).toBe(\"X&var=test\");\n    });\n  });\n\n  describe(\"matching\", () => {\n    it(\"should match simple strings and extract variables\", () => {\n      const template = new UriTemplate(\"http://example.com/users/{username}\");\n      const match = template.match(\"http://example.com/users/fred\");\n      expect(match).toEqual({ username: \"fred\" });\n    });\n\n    it(\"should match multiple variables\", () => {\n      const template = new UriTemplate(\"/users/{username}/posts/{postId}\");\n      const match = template.match(\"/users/fred/posts/123\");\n      expect(match).toEqual({ username: \"fred\", postId: \"123\" });\n    });\n\n    it(\"should return null for non-matching URIs\", () => {\n      const template = new UriTemplate(\"/users/{username}\");\n      const match = template.match(\"/posts/123\");\n      expect(match).toBeNull();\n    });\n\n    it(\"should handle exploded arrays\", () => {\n      const template = new UriTemplate(\"{/list*}\");\n      const match = template.match(\"/red,green,blue\");\n    });\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Request Cancellation in MCP Client\nDESCRIPTION: Tests the ability to cancel requests using AbortController. This test creates a client-server pair, issues a request, and immediately cancels it to verify that the promise is properly rejected.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n// Set up abort controller\nconst controller = new AbortController();\n\n// Issue request but cancel it immediately\nconst listResourcesPromise = client.listResources(undefined, {\n  signal: controller.signal,\n});\ncontroller.abort(\"Cancelled by test\");\n\n// Request should be rejected\nawait expect(listResourcesPromise).rejects.toBe(\"Cancelled by test\");\n```\n\n----------------------------------------\n\nTITLE: Listing Tools Request in JSON-RPC Format\nDESCRIPTION: Request format for discovering available tools with optional pagination support. The client sends this request to obtain a list of tools the server provides.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_60\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"tools/list\",\n  \"params\": {\n    \"cursor\": \"optional-cursor-value\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Minimal OAuth Server Provider in TypeScript\nDESCRIPTION: A minimal implementation of an OAuth server provider without registration and revocation capabilities. This implementation supports only the core OAuth functionality including client validation, authorization, and token operations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_99\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst mockProviderMinimal: OAuthServerProvider = {\n  clientsStore: {\n    async getClient(clientId: string): Promise<OAuthClientInformationFull | undefined> {\n      if (clientId === 'valid-client') {\n        return {\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          redirect_uris: ['https://example.com/callback']\n        };\n      }\n      return undefined;\n    }\n  },\n\n  async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise<void> {\n    const redirectUrl = new URL(params.redirectUri);\n    redirectUrl.searchParams.set('code', 'mock_auth_code');\n    if (params.state) {\n      redirectUrl.searchParams.set('state', params.state);\n    }\n    res.redirect(302, redirectUrl.toString());\n  },\n\n  async challengeForAuthorizationCode(): Promise<string> {\n    return 'mock_challenge';\n  },\n\n  async exchangeAuthorizationCode(): Promise<OAuthTokens> {\n    return {\n      access_token: 'mock_access_token',\n      token_type: 'bearer',\n      expires_in: 3600,\n      refresh_token: 'mock_refresh_token'\n    };\n  },\n\n  async exchangeRefreshToken(): Promise<OAuthTokens> {\n    return {\n      access_token: 'new_mock_access_token',\n      token_type: 'bearer',\n      expires_in: 3600,\n      refresh_token: 'new_mock_refresh_token'\n    };\n  },\n\n  async verifyAccessToken(token: string): Promise<AuthInfo> {\n    if (token === 'valid_token') {\n      return {\n        token,\n        clientId: 'valid-client',\n        scopes: ['read'],\n        expiresAt: Date.now() / 1000 + 3600\n      };\n    }\n    throw new InvalidTokenError('Token is invalid or expired');\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Updated Notification Schema\nDESCRIPTION: Schema for server notifications about resource updates. Sent when a resource has changed and may need to be read again, only after a client has subscribed to updates for that resource.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_207\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.\n */\nexport const ResourceUpdatedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/resources/updated\"),\n  params: BaseNotificationParamsSchema.extend({\n    /**\n     * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.\n     */\n    uri: z.string(),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Research Command CLI Interface Structure - JavaScript\nDESCRIPTION: Commander.js command structure with options and parameters for the research command implementation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_051.txt#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\ncommands/research.js\n\n--task (-t) option\n--prompt (-p) option\n--save (-s) option\n--copy (-c) option\n--summary (-m) option\n--detail (-d) option\n```\n\n----------------------------------------\n\nTITLE: Client Calling Server Tools with Arguments\nDESCRIPTION: Tests the interaction between client and server for tool calls with arguments. This test registers a tool that processes input and validates that the client can successfully call it with arguments and receive processed results.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_121\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should allow client to call server tools\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client(\n      {\n        name: \"test client\",\n        version: \"1.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      },\n    );\n\n    mcpServer.tool(\n      \"test\",\n      \"Test tool\",\n      {\n        input: z.string(),\n      },\n      async ({ input }) => ({\n        content: [\n          {\n            type: \"text\",\n            text: `Processed: ${input}`,\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"test\",\n          arguments: {\n            input: \"hello\",\n          },\n        },\n      },\n      CallToolResultSchema,\n    );\n\n    expect(result.content).toEqual([\n      {\n        type: \"text\",\n        text: \"Processed: hello\",\n      },\n    ]);\n  });\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Authorization Code Grant Flow with Jest and Supertest\nDESCRIPTION: Test cases for the OAuth authorization code grant flow. These tests validate parameter requirements, PKCE verification, code validity checks, and successful token exchange for the authorization code grant type.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_72\n\nLANGUAGE: JavaScript\nCODE:\n```\ndescribe('Authorization code grant', () => {\n  it('requires code parameter', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'authorization_code',\n        // Missing code\n        code_verifier: 'valid_verifier'\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_request');\n  });\n\n  it('requires code_verifier parameter', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'authorization_code',\n        code: 'valid_code'\n        // Missing code_verifier\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_request');\n  });\n\n  it('verifies code_verifier against challenge', async () => {\n    // Setup invalid verifier\n    (pkceChallenge.verifyChallenge as jest.Mock).mockResolvedValueOnce(false);\n\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'authorization_code',\n        code: 'valid_code',\n        code_verifier: 'invalid_verifier'\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_grant');\n    expect(response.body.error_description).toContain('code_verifier');\n  });\n\n  it('rejects expired or invalid authorization codes', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'authorization_code',\n        code: 'expired_code',\n        code_verifier: 'valid_verifier'\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_grant');\n  });\n\n  it('returns tokens for valid code exchange', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'authorization_code',\n        code: 'valid_code',\n        code_verifier: 'valid_verifier'\n      });\n\n    expect(response.status).toBe(200);\n    expect(response.body.access_token).toBe('mock_access_token');\n    expect(response.body.token_type).toBe('bearer');\n    expect(response.body.expires_in).toBe(3600);\n    expect(response.body.refresh_token).toBe('mock_refresh_token');\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Defining System Operation Tool in TypeScript\nDESCRIPTION: Shows an example of a tool definition for executing system commands. It includes the tool's name, description, and input schema for command execution.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  name: \"execute_command\",\n  description: \"Run a shell command\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      command: { type: \"string\" },\n      args: { type: \"array\", items: { type: \"string\" } }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving MCP Initialization Response (JSON)\nDESCRIPTION: Example of a JSON-RPC 2.0 response message sent by the server in reply to a successful 'initialize' request. It confirms the negotiated 'protocolVersion', details the server's 'capabilities' (e.g., support for 'logging', 'prompts', 'resources', 'tools'), and provides 'serverInfo'. The 'id' matches the 'id' of the original client request.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"protocolVersion\": \"2024-11-05\",\n    \"capabilities\": {\n      \"logging\": {},\n      \"prompts\": {\n        \"listChanged\": true\n      },\n      \"resources\": {\n        \"subscribe\": true,\n        \"listChanged\": true\n      },\n      \"tools\": {\n        \"listChanged\": true\n      }\n    },\n    \"serverInfo\": {\n      \"name\": \"ExampleServer\",\n      \"version\": \"1.0.0\"\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Server Connection Management Implementation\nDESCRIPTION: Method for connecting to an MCP server and retrieving available tools.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nasync connectToServer(serverScriptPath: string) {\n  try {\n    const isJs = serverScriptPath.endsWith(\".js\");\n    const isPy = serverScriptPath.endsWith(\".py\");\n    if (!isJs && !isPy) {\n      throw new Error(\"Server script must be a .js or .py file\");\n    }\n    const command = isPy\n      ? process.platform === \"win32\"\n        ? \"python\"\n        : \"python3\"\n      : process.execPath;\n    \n    this.transport = new StdioClientTransport({\n      command,\n      args: [serverScriptPath],\n    });\n    this.mcp.connect(this.transport);\n    \n    const toolsResult = await this.mcp.listTools();\n    this.tools = toolsResult.tools.map((tool) => {\n      return {\n        name: tool.name,\n        description: tool.description,\n        input_schema: tool.inputSchema,\n      };\n    });\n    console.log(\n      \"Connected to server with tools:\",\n      this.tools.map(({ name }) => name)\n    );\n  } catch (e) {\n    console.log(\"Failed to connect to MCP server: \", e);\n    throw e;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Task, Workflow, User, and Project Resources with FastMCP Decorators in Python\nDESCRIPTION: This group of Python snippets demonstrates how to define static or parameterized resources in a FastMCP server using the @mcp.resource decorator, exposing key data structures such as task templates, workflow definitions, user preferences, and project metadata. Each function is declared with a resource URI route and appropriate parameter types. These patterns require FastMCP and proper @mcp.resource decorator support, and expect route parameter variables (e.g., template_id, workflow_id, user_id) to be injected by the server. Each endpoint returns a dictionary or a list of dictionaries, representing serialized objects for LLM consumption. Restrictions include ensuring correct resource URI conventions and response types.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@mcp.resource(\"tasks://templates/{template_id}\")\ndef get_task_template(template_id: str) -> dict:\n    # Fetch and return the specified task template\n    ...\n\n```\n\nLANGUAGE: python\nCODE:\n```\n@mcp.resource(\"workflows://definitions/{workflow_id}\")\ndef get_workflow_definition(workflow_id: str) -> dict:\n    # Fetch and return the specified workflow definition\n    ...\n\n```\n\nLANGUAGE: python\nCODE:\n```\n@mcp.resource(\"users://{user_id}/preferences\")\ndef get_user_preferences(user_id: str) -> dict:\n    # Fetch and return user preferences\n    ...\n\n```\n\nLANGUAGE: python\nCODE:\n```\n@mcp.resource(\"projects://metadata\")\ndef get_project_metadata() -> List[dict]:\n    # Fetch and return metadata for all active projects\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: Processing JSON-RPC Notifications\nDESCRIPTION: Handles incoming JSON-RPC notifications by finding the appropriate handler and executing it asynchronously with error handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_169\n\nLANGUAGE: typescript\nCODE:\n```\nprivate _onnotification(notification: JSONRPCNotification): void {\n  const handler =\n    this._notificationHandlers.get(notification.method) ??\n    this.fallbackNotificationHandler;\n\n  // Ignore notifications not being subscribed to.\n  if (handler === undefined) {\n    return;\n  }\n\n  // Starting with Promise.resolve() puts any synchronous errors into the monad as well.\n  Promise.resolve()\n    .then(() => handler(notification))\n    .catch((error) =>\n      this._onerror(\n        new Error(`Uncaught error in notification handler: ${error}`),\n      ),\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: MCP Capability Negotiation Sequence\nDESCRIPTION: Mermaid sequence diagram illustrating the capability negotiation process between host, client and server, including initialization, requests, and notifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_72\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Host\n    participant Client\n    participant Server\n\n    Host->>+Client: Initialize client\n    Client->>+Server: Initialize session with capabilities\n    Server-->>Client: Respond with supported capabilities\n\n    Note over Host,Server: Active Session with Negotiated Features\n\n    loop Client Requests\n        Host->>Client: User- or model-initiated action\n        Client->>Server: Request (tools/resources)\n        Server-->>Client: Response\n        Client-->>Host: Update UI or respond to model\n    end\n\n    loop Server Requests\n        Server->>Client: Request (sampling)\n        Client->>Host: Forward to AI\n        Host-->>Client: AI response\n        Client-->>Server: Response\n    end\n\n    loop Notifications\n        Server--)Client: Resource updates\n        Client--)Server: Status changes\n    end\n\n    Host->>Client: Terminate\n    Client->>-Server: End session\n    deactivate Server\n```\n\n----------------------------------------\n\nTITLE: Server Connection and Client Capabilities\nDESCRIPTION: Methods for establishing server connection, handling client capabilities and maintaining server connection through ping intervals.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\npublic async connect(transport: Transport) {\n    if (this.#server.transport) {\n      throw new UnexpectedStateError(\"Server is already connected\");\n    }\n\n    await this.#server.connect(transport);\n\n    let attempt = 0;\n\n    while (attempt++ < 10) {\n      const capabilities = await this.#server.getClientCapabilities();\n\n      if (capabilities) {\n        this.#clientCapabilities = capabilities;\n\n        break;\n      }\n\n      await delay(100);\n    }\n\n    if (!this.#clientCapabilities) {\n      console.warn('[warning] FastMCP could not infer client capabilities')\n    }\n\n    if (this.#clientCapabilities?.roots?.listChanged) {\n      try {\n        const roots = await this.#server.listRoots();\n        this.#roots = roots.roots;\n      } catch(e) {\n        console.error(`[error] FastMCP received error listing roots.\\n\\n${e instanceof Error ? e.stack : JSON.stringify(e)}`)\n      }\n    }\n\n    this.#pingInterval = setInterval(async () => {\n      try {\n        await this.#server.ping();\n      } catch (error) {\n        this.emit(\"error\", {\n          error: error as Error,\n        });\n      }\n    }, 1000);\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Protocol Type and Timeout Handling in TypeScript\nDESCRIPTION: Defines the core Protocol class with types and implements timeout handling functionality. The code sets up and manages request timeouts with options for resetting on progress updates and enforcing maximum total timeouts.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_163\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Implements MCP protocol framing on top of a pluggable transport, including\n * features like request/response linking, notifications, and progress.\n */\nexport abstract class Protocol<\n  SendRequestT extends Request,\n  SendNotificationT extends Notification,\n  SendResultT extends Result,\n> {\n  private _transport?: Transport;\n  private _requestMessageId = 0;\n  private _requestHandlers: Map<\n    string,\n    (request: JSONRPCRequest, extra: RequestHandlerExtra) => Promise<SendResultT>\n  > = new Map();\n  private _requestHandlerAbortControllers: Map<RequestId, AbortController> =\n    new Map();\n  private _notificationHandlers: Map<\n    string,\n    (notification: JSONRPCNotification) => Promise<void>\n  > = new Map();\n  private _responseHandlers: Map<\n    number,\n    (response: JSONRPCResponse | Error) => void\n  > = new Map();\n  private _progressHandlers: Map<number, ProgressCallback> = new Map();\n  private _timeoutInfo: Map<number, TimeoutInfo> = new Map();\n\n  /**\n   * Callback for when the connection is closed for any reason.\n   *\n   * This is invoked when close() is called as well.\n   */\n  onclose?: () => void;\n\n  /**\n   * Callback for when an error occurs.\n   *\n   * Note that errors are not necessarily fatal; they are used for reporting any kind of exceptional condition out of band.\n   */\n  onerror?: (error: Error) => void;\n\n  /**\n   * A handler to invoke for any request types that do not have their own handler installed.\n   */\n  fallbackRequestHandler?: (request: Request) => Promise<SendResultT>;\n\n  /**\n   * A handler to invoke for any notification types that do not have their own handler installed.\n   */\n  fallbackNotificationHandler?: (notification: Notification) => Promise<void>;\n\n  constructor(private _options?: ProtocolOptions) {\n    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {\n      const controller = this._requestHandlerAbortControllers.get(\n        notification.params.requestId,\n      );\n      controller?.abort(notification.params.reason);\n    });\n\n    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {\n      this._onprogress(notification as unknown as ProgressNotification);\n    });\n\n    this.setRequestHandler(\n      PingRequestSchema,\n      // Automatic pong by default.\n      (_request) => ({}) as SendResultT,\n    );\n  }\n\n  private _setupTimeout(\n    messageId: number,\n    timeout: number,\n    maxTotalTimeout: number | undefined,\n    onTimeout: () => void\n  ) {\n    this._timeoutInfo.set(messageId, {\n      timeoutId: setTimeout(onTimeout, timeout),\n      startTime: Date.now(),\n      timeout,\n      maxTotalTimeout,\n      onTimeout\n    });\n  }\n\n  private _resetTimeout(messageId: number): boolean {\n    const info = this._timeoutInfo.get(messageId);\n    if (!info) return false;\n  }\n```\n\n----------------------------------------\n\nTITLE: Sending Ping Request (JSON-RPC) - JSON\nDESCRIPTION: A minimal JSON-RPC request for the 'ping' method as implemented in the protocol's keepalive utility. Used to check connection liveness between client and server. Inputs: A unique request id. Outputs: An empty result. Dependencies: JSON-RPC 2.0. The message does not require parameters; suitable for use in regular connection checks.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"id\\\": \\\"123\\\",\\n  \\\"method\\\": \\\"ping\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining LLM Sampling-Related Schemas\nDESCRIPTION: Defines schemas for model preferences, sampling messages, and LLM sampling requests/responses. These schemas validate the structure of data when the server requests LLM sampling from the client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_214\n\nLANGUAGE: typescript\nCODE:\n```\n/* Sampling */\n/**\n * Hints to use for model selection.\n */\nexport const ModelHintSchema = z\n  .object({\n    /**\n     * A hint for a model name.\n     */\n    name: z.string().optional(),\n  })\n  .passthrough();\n\n/**\n * The server's preferences for model selection, requested of the client during sampling.\n */\nexport const ModelPreferencesSchema = z\n  .object({\n    /**\n     * Optional hints to use for model selection.\n     */\n    hints: z.optional(z.array(ModelHintSchema)),\n    /**\n     * How much to prioritize cost when selecting a model.\n     */\n    costPriority: z.optional(z.number().min(0).max(1)),\n    /**\n     * How much to prioritize sampling speed (latency) when selecting a model.\n     */\n    speedPriority: z.optional(z.number().min(0).max(1)),\n    /**\n     * How much to prioritize intelligence and capabilities when selecting a model.\n     */\n    intelligencePriority: z.optional(z.number().min(0).max(1)),\n  })\n  .passthrough();\n\n/**\n * Describes a message issued to or received from an LLM API.\n */\nexport const SamplingMessageSchema = z\n  .object({\n    role: z.enum([\"user\", \"assistant\"]),\n    content: z.union([TextContentSchema, ImageContentSchema]),\n  })\n  .passthrough();\n\n/**\n * A request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.\n */\nexport const CreateMessageRequestSchema = RequestSchema.extend({\n  method: z.literal(\"sampling/createMessage\"),\n  params: BaseRequestParamsSchema.extend({\n    messages: z.array(SamplingMessageSchema),\n    /**\n     * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.\n     */\n    systemPrompt: z.optional(z.string()),\n    /**\n     * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.\n     */\n    includeContext: z.optional(z.enum([\"none\", \"thisServer\", \"allServers\"])),\n    temperature: z.optional(z.number()),\n    /**\n     * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.\n     */\n    maxTokens: z.number().int(),\n    stopSequences: z.optional(z.array(z.string())),\n    /**\n     * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.\n     */\n    metadata: z.optional(z.object({}).passthrough()),\n    /**\n     * The server's preferences for which model to select.\n     */\n    modelPreferences: z.optional(ModelPreferencesSchema),\n  }),\n});\n\n/**\n * The client's response to a sampling/create_message request from the server. The client should inform the user before returning the sampled message, to allow them to inspect the response (human in the loop) and decide whether to allow the server to see it.\n */\nexport const CreateMessageResultSchema = ResultSchema.extend({\n  /**\n   * The name of the model that generated the message.\n   */\n  model: z.string(),\n  /**\n   * The reason why sampling stopped.\n   */\n  stopReason: z.optional(\n    z.enum([\"endTurn\", \"stopSequence\", \"maxTokens\"]).or(z.string()),\n  ),\n  role: z.enum([\"user\", \"assistant\"]),\n  content: z.discriminatedUnion(\"type\", [\n    TextContentSchema,\n    ImageContentSchema,\n  ]),\n});\n```\n\n----------------------------------------\n\nTITLE: Listing Resource Templates\nDESCRIPTION: JSON-RPC request and response for retrieving URI templates that allow parameterized access to resources.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_54\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"method\": \"resources/templates/list\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"result\": {\n    \"resourceTemplates\": [\n      {\n        \"uriTemplate\": \"file:///{path}\",\n        \"name\": \"Project Files\",\n        \"description\": \"Access files in the project directory\",\n        \"mimeType\": \"application/octet-stream\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Prompt Argument Completion in MCP Server\nDESCRIPTION: Test that verifies prompt argument completion functionality where the server provides completion suggestions for partial argument values. The server defines a custom completion handler for the 'name' argument of a 'countryPoem' prompt.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_32\n\nLANGUAGE: JavaScript\nCODE:\n```\ntest(\"completes prompt arguments\", async () => {\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      server.addPrompt({\n        name: \"countryPoem\",\n        description: \"Writes a poem about a country\",\n        load: async ({ name }) => {\n          return `Hello, ${name}!`;\n        },\n        arguments: [\n          {\n            name: \"name\",\n            description: \"Name of the country\",\n            required: true,\n            complete: async (value) => {\n              if (value === \"Germ\") {\n                return {\n                  values: [\"Germany\"],\n                };\n              }\n\n              return {\n                values: [],\n              };\n            },\n          },\n        ],\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      const response = await client.complete({\n        ref: {\n          type: \"ref/prompt\",\n          name: \"countryPoem\",\n        },\n        argument: {\n          name: \"name\",\n          value: \"Germ\",\n        },\n      });\n\n      expect(response).toEqual({\n        completion: {\n          values: [\"Germany\"],\n        },\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Resources List Request/Response\nDESCRIPTION: Example of paginated resources/list request and response messages for discovering available resources.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_128\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"resources/list\",\n  \"params\": {\n    \"cursor\": \"optional-cursor-value\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"resources\": [\n      {\n        \"uri\": \"file:///project/src/main.rs\",\n        \"name\": \"main.rs\",\n        \"description\": \"Primary application entry point\",\n        \"mimeType\": \"text/x-rust\"\n      }\n    ],\n    \"nextCursor\": \"next-page-cursor\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Logging Notifications in MCP Server (Java)\nDESCRIPTION: Shows how to send structured log messages to clients with different severity levels using the MCP server's logging capabilities. Clients can control the minimum logging level they receive through separate requests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_143\n\nLANGUAGE: java\nCODE:\n```\n// Send a log message to clients\nserver.loggingNotification(LoggingMessageNotification.builder()\n    .level(LoggingLevel.INFO)\n    .logger(\"custom-logger\")\n    .data(\"Custom log message\")\n    .build());\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Template List Request and Result Schemas\nDESCRIPTION: Schemas for listing resource templates available on the server. Similar to resource listing, but for templates that can be used to construct resource URIs according to patterns.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_203\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Sent from the client to request a list of resource templates the server has.\n */\nexport const ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend(\n  {\n    method: z.literal(\"resources/templates/list\"),\n  },\n);\n\n/**\n * The server's response to a resources/templates/list request from the client.\n */\nexport const ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({\n  resourceTemplates: z.array(ResourceTemplateSchema),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Spring Boot Application for MCP Server\nDESCRIPTION: Java implementation of the main Spring Boot application class for the MCP server. It sets up the application context and configures the ToolCallbackProvider for weather tools.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_108\n\nLANGUAGE: java\nCODE:\n```\n@SpringBootApplication\npublic class McpServerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(McpServerApplication.class, args);\n\t}\n\n\t@Bean\n\tpublic ToolCallbackProvider weatherTools(WeatherService weatherService) {\n\t\treturn  MethodToolCallbackProvider.builder().toolObjects(weatherService).build();\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing message event handler for SSEClientTransport in TypeScript\nDESCRIPTION: Implements the event handler for SSE message events. It parses the received JSON data, validates it against the JSONRPCMessageSchema, and invokes the onmessage callback.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_50\n\nLANGUAGE: TypeScript\nCODE:\n```\n      this._eventSource.onmessage = (event: Event) => {\n        const messageEvent = event as MessageEvent;\n        let message: JSONRPCMessage;\n        try {\n          message = JSONRPCMessageSchema.parse(JSON.parse(messageEvent.data));\n        } catch (error) {\n          this.onerror?.(error as Error);\n          return;\n        }\n\n        this.onmessage?.(message);\n      };\n```\n\n----------------------------------------\n\nTITLE: Defining Prompt-Related Interfaces in TypeScript\nDESCRIPTION: TypeScript interfaces for prompt-related operations including listing available prompts, retrieving prompt templates, and handling prompt messages. These interfaces define the structure for prompt requests, responses, and notifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_148\n\nLANGUAGE: typescript\nCODE:\n```\n/* Prompts */\n/**\n * Sent from the client to request a list of prompts and prompt templates the server has.\n */\nexport interface ListPromptsRequest extends PaginatedRequest {\n  method: \"prompts/list\";\n}\n\n/**\n * The server's response to a prompts/list request from the client.\n */\nexport interface ListPromptsResult extends PaginatedResult {\n  prompts: Prompt[];\n}\n\n/**\n * Used by the client to get a prompt provided by the server.\n */\nexport interface GetPromptRequest extends Request {\n  method: \"prompts/get\";\n  params: {\n    /**\n     * The name of the prompt or prompt template.\n     */\n    name: string;\n    /**\n     * Arguments to use for templating the prompt.\n     */\n    arguments?: { [key: string]: string };\n  };\n}\n\n/**\n * The server's response to a prompts/get request from the client.\n */\nexport interface GetPromptResult extends Result {\n  /**\n   * An optional description for the prompt.\n   */\n  description?: string;\n  messages: PromptMessage[];\n}\n\n/**\n * A prompt or prompt template that the server offers.\n */\nexport interface Prompt {\n  /**\n   * The name of the prompt or prompt template.\n   */\n  name: string;\n  /**\n   * An optional description of what this prompt provides\n   */\n  description?: string;\n  /**\n   * A list of arguments to use for templating the prompt.\n   */\n  arguments?: PromptArgument[];\n}\n\n/**\n * Describes an argument that a prompt can accept.\n */\nexport interface PromptArgument {\n  /**\n   * The name of the argument.\n   */\n  name: string;\n  /**\n   * A human-readable description of the argument.\n   */\n  description?: string;\n  /**\n   * Whether this argument must be provided.\n   */\n  required?: boolean;\n}\n\n/**\n * The sender or recipient of messages and data in a conversation.\n */\nexport type Role = \"user\" | \"assistant\";\n\n/**\n * Describes a message returned as part of a prompt.\n *\n * This is similar to `SamplingMessage`, but also supports the embedding of\n * resources from the MCP server.\n */\nexport interface PromptMessage {\n  role: Role;\n  content: TextContent | ImageContent | EmbeddedResource;\n}\n\n/**\n * The contents of a resource, embedded into a prompt or tool call result.\n *\n * It is up to the client how best to render embedded resources for the benefit\n * of the LLM and/or the user.\n */\nexport interface EmbeddedResource extends Annotated {\n  type: \"resource\";\n  resource: TextResourceContents | BlobResourceContents;\n}\n\n/**\n * An optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport interface PromptListChangedNotification extends Notification {\n  method: \"notifications/prompts/list_changed\";\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking OAuth Provider without Revocation Capability for Testing\nDESCRIPTION: This code creates a mock OAuth provider that implements authorization and token exchange methods but intentionally lacks token revocation capability. It's used to test error handling when a provider without token revocation functionality is supplied to the revocation handler.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_65\n\nLANGUAGE: typescript\nCODE:\n```\n// Mock provider without revocation capability\nconst mockProviderWithoutRevocation: OAuthServerProvider = {\n  clientsStore: mockClientStore,\n\n  async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise<void> {\n    res.redirect('https://example.com/callback?code=mock_auth_code');\n  },\n\n  async challengeForAuthorizationCode(): Promise<string> {\n    return 'mock_challenge';\n  },\n\n  async exchangeAuthorizationCode(): Promise<OAuthTokens> {\n    return {\n      access_token: 'mock_access_token',\n      token_type: 'bearer',\n      expires_in: 3600,\n      refresh_token: 'mock_refresh_token'\n    };\n  },\n\n  async exchangeRefreshToken(): Promise<OAuthTokens> {\n    return {\n      access_token: 'new_mock_access_token',\n      token_type: 'bearer',\n      expires_in: 3600,\n      refresh_token: 'new_mock_refresh_token'\n    };\n  },\n\n  async verifyAccessToken(token: string): Promise<AuthInfo> {\n    if (token === 'valid_token') {\n      return {\n        token,\n        clientId: 'valid-client',\n        scopes: ['read', 'write'],\n        expiresAt: Date.now() / 1000 + 3600\n      };\n    }\n    throw new InvalidTokenError('Token is invalid or expired');\n  }\n  // No revokeToken method\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Client Management Store in TypeScript for OAuth Server\nDESCRIPTION: A mock implementation of a client store with methods to get and register OAuth clients. The store validates client IDs against a hard-coded valid client and returns appropriate client information.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_97\n\nLANGUAGE: TypeScript\nCODE:\n```\nasync getClient(clientId: string): Promise<OAuthClientInformationFull | undefined> {\n  if (clientId === 'valid-client') {\n    return {\n      client_id: 'valid-client',\n      client_secret: 'valid-secret',\n      redirect_uris: ['https://example.com/callback']\n    };\n  }\n  return undefined;\n},\n\nasync registerClient(client: OAuthClientInformationFull): Promise<OAuthClientInformationFull> {\n  return client;\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting and Managing Server in FastMCP\nDESCRIPTION: These methods handle server connection, capability inference, root listing, and periodic pinging. They also include error handling and connection closing.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\npublic async connect(transport: Transport) {\n    if (this.#server.transport) {\n      throw new UnexpectedStateError(\"Server is already connected\");\n    }\n\n    await this.#server.connect(transport);\n\n    let attempt = 0;\n\n    while (attempt++ < 10) {\n      const capabilities = await this.#server.getClientCapabilities();\n\n      if (capabilities) {\n        this.#clientCapabilities = capabilities;\n\n        break;\n      }\n\n      await delay(100);\n    }\n\n    if (!this.#clientCapabilities) {\n      console.warn('[warning] FastMCP could not infer client capabilities')\n    }\n\n    if (this.#clientCapabilities?.roots?.listChanged) {\n      try {\n        const roots = await this.#server.listRoots();\n        this.#roots = roots.roots;\n      } catch(e) {\n        console.error(`[error] FastMCP received error listing roots.\\n\\n${e instanceof Error ? e.stack : JSON.stringify(e)}`)\n      }\n    }\n\n    this.#pingInterval = setInterval(async () => {\n      try {\n        await this.#server.ping();\n      } catch (error) {\n        this.emit(\"error\", {\n          error: error as Error,\n        });\n      }\n    }, 1000);\n  }\n\n  public async close() {\n    if (this.#pingInterval) {\n      clearInterval(this.#pingInterval);\n    }\n\n    try {\n      await this.#server.close();\n    } catch (error) {\n      console.error(\"[MCP Error]\", \"could not close server\", error);\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Listing Tools Request and Response in JSON-RPC\nDESCRIPTION: Examples of the JSON-RPC request and response format for discovering available tools using the tools/list endpoint. Includes pagination support with optional cursor parameter.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_133\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"tools/list\",\n  \"params\": {\n    \"cursor\": \"optional-cursor-value\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"tools\": [\n      {\n        \"name\": \"get_weather\",\n        \"description\": \"Get current weather information for a location\",\n        \"inputSchema\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"location\": {\n              \"type\": \"string\",\n              \"description\": \"City name or zip code\"\n            }\n          },\n          \"required\": [\"location\"]\n        }\n      }\n    ],\n    \"nextCursor\": \"next-page-cursor\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Resource Reading via Template in MCP Client\nDESCRIPTION: Test that verifies a client can read a resource accessed via a resource template. The server provides a template with a parametrized URI, and the client requests a resource using a concrete URI that matches the template pattern.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_36\n\nLANGUAGE: JavaScript\nCODE:\n```\ntest(\"clients reads a resource accessed via a resource template\", async () => {\n  const loadSpy = vi.fn((_args) => {\n    return {\n      text: \"Example log content\",\n    };\n  });\n\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      server.addResourceTemplate({\n        uriTemplate: \"file:///logs/{name}.log\",\n        name: \"Application Logs\",\n        mimeType: \"text/plain\",\n        arguments: [\n          {\n            name: \"name\",\n            description: \"Name of the log\",\n          },\n        ],\n        async load(args) {\n          return loadSpy(args);\n        },\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      expect(\n        await client.readResource({\n          uri: \"file:///logs/app.log\",\n        }),\n      ).toEqual({\n        contents: [\n          {\n            uri: \"file:///logs/app.log\",\n            name: \"Application Logs\",\n            text: \"Example log content\",\n            mimeType: \"text/plain\",\n          },\n        ],\n      });\n\n      expect(loadSpy).toHaveBeenCalledWith({\n        name: \"app\",\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Message Flow Diagram in Mermaid\nDESCRIPTION: A sequence diagram showing the typical message flow between client and server for prompt discovery, usage, and list change notifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_46\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: Discovery\n    Client->>Server: prompts/list\n    Server-->>Client: List of prompts\n\n    Note over Client,Server: Usage\n    Client->>Server: prompts/get\n    Server-->>Client: Prompt content\n\n    opt listChanged\n      Note over Client,Server: Changes\n      Server--)Client: prompts/list_changed\n      Client->>Server: prompts/list\n      Server-->>Client: Updated prompts\n    end\n```\n\n----------------------------------------\n\nTITLE: Registering Resource Template Handlers - TypeScript\nDESCRIPTION: Declares a method to register a handler for listing available resource templates using a dedicated schema. This handler returns an array of resource templates with their names and URI templates, supporting introspection or dynamic usage. Inputs are the resourceTemplates array; output is an object listing resource template metadata. Dependencies are request schemas and resource template definitions.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_10\n\nLANGUAGE: TypeScript\nCODE:\n```\nprivate setupResourceTemplateHandlers(resourceTemplates: ResourceTemplate[]) {\n  this.#server.setRequestHandler(\n    ListResourceTemplatesRequestSchema,\n    async () => {\n      return {\n        resourceTemplates: resourceTemplates.map((resourceTemplate) => {\n          return {\n            name: resourceTemplate.name,\n            uriTemplate: resourceTemplate.uriTemplate,\n          };\n        }),\n      };\n    },\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Asynchronous Resource in Java MCP SDK\nDESCRIPTION: Implements an asynchronous resource registration with the same parameters as the sync version. Returns a Mono for reactive processing, making it suitable for non-blocking operations when accessing potentially slow external resources.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_147\n\nLANGUAGE: java\nCODE:\n```\n// Async resource registration\nvar asyncResourceRegistration = new McpServerFeatures.AsyncResourceRegistration(\n    new Resource(\"custom://resource\", \"name\", \"description\", \"mime-type\", null),\n    request -> {\n        // Resource read implementation\n        return Mono.just(new ReadResourceResult(contents));\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Resource-Related Interfaces in TypeScript\nDESCRIPTION: TypeScript interfaces for resource-related operations including listing templates, reading resources, subscribing to updates, and handling resource contents. These interfaces define the structure of requests, responses, and notifications between client and server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_147\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * The server's response to a resources/templates/list request from the client.\n */\nexport interface ListResourceTemplatesResult extends PaginatedResult {\n  resourceTemplates: ResourceTemplate[];\n}\n\n/**\n * Sent from the client to the server, to read a specific resource URI.\n */\nexport interface ReadResourceRequest extends Request {\n  method: \"resources/read\";\n  params: {\n    /**\n     * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.\n     *\n     * @format uri\n     */\n    uri: string;\n  };\n}\n\n/**\n * The server's response to a resources/read request from the client.\n */\nexport interface ReadResourceResult extends Result {\n  contents: (TextResourceContents | BlobResourceContents)[];\n}\n\n/**\n * An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport interface ResourceListChangedNotification extends Notification {\n  method: \"notifications/resources/list_changed\";\n}\n\n/**\n * Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.\n */\nexport interface SubscribeRequest extends Request {\n  method: \"resources/subscribe\";\n  params: {\n    /**\n     * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.\n     *\n     * @format uri\n     */\n    uri: string;\n  };\n}\n\n/**\n * Sent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.\n */\nexport interface UnsubscribeRequest extends Request {\n  method: \"resources/unsubscribe\";\n  params: {\n    /**\n     * The URI of the resource to unsubscribe from.\n     *\n     * @format uri\n     */\n    uri: string;\n  };\n}\n\n/**\n * A notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.\n */\nexport interface ResourceUpdatedNotification extends Notification {\n  method: \"notifications/resources/updated\";\n  params: {\n    /**\n     * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.\n     *\n     * @format uri\n     */\n    uri: string;\n  };\n}\n\n/**\n * A known resource that the server is capable of reading.\n */\nexport interface Resource extends Annotated {\n  /**\n   * The URI of this resource.\n   *\n   * @format uri\n   */\n  uri: string;\n\n  /**\n   * A human-readable name for this resource.\n   *\n   * This can be used by clients to populate UI elements.\n   */\n  name: string;\n\n  /**\n   * A description of what this resource represents.\n   *\n   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model.\n   */\n  description?: string;\n\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType?: string;\n\n  /**\n   * The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.\n   *\n   * This can be used by Hosts to display file sizes and estimate context window usage.\n   */\n  size?: number;\n}\n\n/**\n * A template description for resources available on the server.\n */\nexport interface ResourceTemplate extends Annotated {\n  /**\n   * A URI template (according to RFC 6570) that can be used to construct resource URIs.\n   *\n   * @format uri-template\n   */\n  uriTemplate: string;\n\n  /**\n   * A human-readable name for the type of resource this template refers to.\n   *\n   * This can be used by clients to populate UI elements.\n   */\n  name: string;\n\n  /**\n   * A description of what this template is for.\n   *\n   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a \"hint\" to the model.\n   */\n  description?: string;\n\n  /**\n   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.\n   */\n  mimeType?: string;\n}\n\n/**\n * The contents of a specific resource or sub-resource.\n */\nexport interface ResourceContents {\n  /**\n   * The URI of this resource.\n   *\n   * @format uri\n   */\n  uri: string;\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType?: string;\n}\n\nexport interface TextResourceContents extends ResourceContents {\n  /**\n   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).\n   */\n  text: string;\n}\n\nexport interface BlobResourceContents extends ResourceContents {\n  /**\n   * A base64-encoded string representing the binary data of the item.\n   *\n   * @format byte\n   */\n  blob: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Content Schema Types for LLM Interactions\nDESCRIPTION: Defines schemas for different types of content that can be exchanged with LLMs, including text, images, and embedded resources. These schemas validate the structure of message content.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_210\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Text provided to or from an LLM.\n */\nexport const TextContentSchema = z\n  .object({\n    type: z.literal(\"text\"),\n    /**\n     * The text content of the message.\n     */\n    text: z.string(),\n  })\n  .passthrough();\n\n/**\n * An image provided to or from an LLM.\n */\nexport const ImageContentSchema = z\n  .object({\n    type: z.literal(\"image\"),\n    /**\n     * The base64-encoded image data.\n     */\n    data: z.string().base64(),\n    /**\n     * The MIME type of the image. Different providers may support different image types.\n     */\n    mimeType: z.string(),\n  })\n  .passthrough();\n\n/**\n * The contents of a resource, embedded into a prompt or tool call result.\n */\nexport const EmbeddedResourceSchema = z\n  .object({\n    type: z.literal(\"resource\"),\n    resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  })\n  .passthrough();\n```\n\n----------------------------------------\n\nTITLE: Resource Content Data Types\nDESCRIPTION: Examples of the JSON structure for text and binary resource contents.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_57\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"uri\": \"file:///example.txt\",\n  \"mimeType\": \"text/plain\",\n  \"text\": \"Resource content\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"uri\": \"file:///example.png\",\n  \"mimeType\": \"image/png\",\n  \"blob\": \"base64-encoded-data\"\n}\n```\n\n----------------------------------------\n\nTITLE: Testing MCP Weather Server with Java Client\nDESCRIPTION: Java code snippet demonstrating how to create an MCP client, connect to the weather server, initialize it, list available tools, and make tool calls for weather forecast and alerts.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_111\n\nLANGUAGE: java\nCODE:\n```\nvar stdioParams = ServerParameters.builder(\"java\")\n  .args(\"-jar\", \"/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar\")\n  .build();\n\nvar stdioTransport = new StdioClientTransport(stdioParams);\n\nvar mcpClient = McpClient.sync(stdioTransport).build();\n\nmcpClient.initialize();\n\nListToolsResult toolsList = mcpClient.listTools();\n\nCallToolResult weather = mcpClient.callTool(\n  new CallToolRequest(\"getWeatherForecastByLocation\",\n      Map.of(\"latitude\", \"47.6062\", \"longitude\", \"-122.3321\")));\n\nCallToolResult alert = mcpClient.callTool(\n  new CallToolRequest(\"getAlerts\", Map.of(\"state\", \"NY\")));\n\nmcpClient.closeGracefully();\n```\n\n----------------------------------------\n\nTITLE: Example MCP Root Configuration in JSON\nDESCRIPTION: Illustrates how an MCP client might expose roots to a server. It defines two roots: a local filesystem path for a frontend repository and an API endpoint.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_25\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"roots\": [\n    {\n      \"uri\": \"file:///home/user/projects/frontend\",\n      \"name\": \"Frontend Repository\"\n    },\n    {\n      \"uri\": \"https://api.example.com/v1\",\n      \"name\": \"API Endpoint\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Resource Templates Request/Response\nDESCRIPTION: Example of resources/templates/list request and response messages for discovering parameterized resource templates.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_130\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"method\": \"resources/templates/list\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"result\": {\n    \"resourceTemplates\": [\n      {\n        \"uriTemplate\": \"file:///{path}\",\n        \"name\": \"Project Files\",\n        \"description\": \"Access files in the project directory\",\n        \"mimeType\": \"application/octet-stream\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Cleaning Up Timeout Resources\nDESCRIPTION: Function to clean up timeout resources when they are no longer needed. It clears the timeout and removes the associated info from the internal map.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_165\n\nLANGUAGE: typescript\nCODE:\n```\nprivate _cleanupTimeout(messageId: number) {\n  const info = this._timeoutInfo.get(messageId);\n  if (info) {\n    clearTimeout(info.timeoutId);\n    this._timeoutInfo.delete(messageId);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Pagination Schemas for Model Context Protocol\nDESCRIPTION: Schemas for paginated requests and results. The request schema allows for an optional cursor parameter, while the result schema includes an optional nextCursor to support pagination through large result sets.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_199\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Pagination */\nexport const PaginatedRequestSchema = RequestSchema.extend({\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * An opaque token representing the current pagination position.\n     * If provided, the server should return results starting after this cursor.\n     */\n    cursor: z.optional(CursorSchema),\n  }).optional(),\n});\n\nexport const PaginatedResultSchema = ResultSchema.extend({\n  /**\n   * An opaque token representing the pagination position after the last returned result.\n   * If present, there may be more results available.\n   */\n  nextCursor: z.optional(CursorSchema),\n});\n```\n\n----------------------------------------\n\nTITLE: Listing Prompts Request in JSON\nDESCRIPTION: Shows the JSON-RPC request format for retrieving available prompts. The request supports pagination through an optional cursor parameter.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_41\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"prompts/list\",\n  \"params\": {\n    \"cursor\": \"optional-cursor-value\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Resource Contents\nDESCRIPTION: JSON-RPC request and response for retrieving the contents of a specific resource by URI.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_53\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"resources/read\",\n  \"params\": {\n    \"uri\": \"file:///project/src/main.rs\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"contents\": [\n      {\n        \"uri\": \"file:///project/src/main.rs\",\n        \"mimeType\": \"text/x-rust\",\n        \"text\": \"fn main() {\\n    println!(\\\"Hello world!\\\");\\n}\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PingRequest Interface in TypeScript\nDESCRIPTION: Defines a PingRequest interface extending the Request type, used for checking if the other party is still alive in a client-server communication.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_163\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PingRequest extends Request {\n  method: \"ping\";\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuth Token Handler in Express\nDESCRIPTION: This function creates an Express request handler for the OAuth token endpoint. It configures middleware for CORS, method restrictions, rate limiting, and client authentication, then handles authorization code and refresh token grant types according to the OAuth 2.0 specification.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nexport function tokenHandler({ provider, rateLimit: rateLimitConfig }: TokenHandlerOptions): RequestHandler {\n  // Nested router so we can configure middleware and restrict HTTP method\n  const router = express.Router();\n\n  // Configure CORS to allow any origin, to make accessible to web-based MCP clients\n  router.use(cors());\n\n  router.use(allowedMethods([\"POST\"]));\n  router.use(express.urlencoded({ extended: false }));\n\n  // Apply rate limiting unless explicitly disabled\n  if (rateLimitConfig !== false) {\n    router.use(rateLimit({\n      windowMs: 15 * 60 * 1000, // 15 minutes\n      max: 50, // 50 requests per windowMs \n      standardHeaders: true,\n      legacyHeaders: false,\n      message: new TooManyRequestsError('You have exceeded the rate limit for token requests').toResponseObject(),\n      ...rateLimitConfig\n    }));\n  }\n\n  // Authenticate and extract client details\n  router.use(authenticateClient({ clientsStore: provider.clientsStore }));\n\n  router.post(\"/\", async (req, res) => {\n    res.setHeader('Cache-Control', 'no-store');\n\n    try {\n      const parseResult = TokenRequestSchema.safeParse(req.body);\n      if (!parseResult.success) {\n        throw new InvalidRequestError(parseResult.error.message);\n      }\n\n      const { grant_type } = parseResult.data;\n\n      const client = req.client;\n      if (!client) {\n        // This should never happen\n        console.error(\"Missing client information after authentication\");\n        throw new ServerError(\"Internal Server Error\");\n      }\n\n      switch (grant_type) {\n        case \"authorization_code\": {\n          const parseResult = AuthorizationCodeGrantSchema.safeParse(req.body);\n          if (!parseResult.success) {\n            throw new InvalidRequestError(parseResult.error.message);\n          }\n\n          const { code, code_verifier } = parseResult.data;\n\n          // Verify PKCE challenge\n          const codeChallenge = await provider.challengeForAuthorizationCode(client, code);\n          if (!(await verifyChallenge(code_verifier, codeChallenge))) {\n            throw new InvalidGrantError(\"code_verifier does not match the challenge\");\n          }\n\n          const tokens = await provider.exchangeAuthorizationCode(client, code);\n          res.status(200).json(tokens);\n          break;\n        }\n\n        case \"refresh_token\": {\n          const parseResult = RefreshTokenGrantSchema.safeParse(req.body);\n          if (!parseResult.success) {\n            throw new InvalidRequestError(parseResult.error.message);\n          }\n\n          const { refresh_token, scope } = parseResult.data;\n\n          const scopes = scope?.split(\" \");\n          const tokens = await provider.exchangeRefreshToken(client, refresh_token, scopes);\n          res.status(200).json(tokens);\n          break;\n        }\n\n        // Not supported right now\n        //case \"client_credentials\":\n\n        default:\n          throw new UnsupportedGrantTypeError(\n            \"The grant type is not supported by this authorization server.\"\n          );\n      }\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400;\n        res.status(status).json(error.toResponseObject());\n      } else {\n        console.error(\"Unexpected error exchanging token:\", error);\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.status(500).json(serverError.toResponseObject());\n      }\n    }\n  });\n\n  return router;\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding Tasks with Meta-Development Script\nDESCRIPTION: This snippet demonstrates how to use the 'expand' command to break down tasks into subtasks. It includes examples of expanding specific tasks, all pending tasks, and using AI-powered research for subtask generation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Expand a specific task with 3 subtasks (default)\ntask-master expand --id=3\n\n# Expand a specific task with 5 subtasks\ntask-master expand --id=3 --num=5\n\n# Expand a task with additional context\ntask-master expand --id=3 --prompt=\"Focus on security aspects\"\n\n# Expand all pending tasks that don't have subtasks\ntask-master expand --all\n\n# Force regeneration of subtasks for all pending tasks\ntask-master expand --all --force\n\n# Use Perplexity AI for research-backed subtask generation\ntask-master expand --id=3 --research\n\n# Use Perplexity AI for research-backed generation on all pending tasks\ntask-master expand --all --research\n```\n\n----------------------------------------\n\nTITLE: Defining Prompt-related Interfaces in TypeScript\nDESCRIPTION: Defines interfaces for listing, getting, and representing prompts and prompt templates, including arguments and messages.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_169\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ListPromptsRequest extends PaginatedRequest {\n  method: \"prompts/list\";\n}\n\nexport interface ListPromptsResult extends PaginatedResult {\n  prompts: Prompt[];\n}\n\nexport interface GetPromptRequest extends Request {\n  method: \"prompts/get\";\n  params: {\n    name: string;\n    arguments?: { [key: string]: string };\n  };\n}\n\nexport interface GetPromptResult extends Result {\n  description?: string;\n  messages: PromptMessage[];\n}\n\nexport interface Prompt {\n  name: string;\n  description?: string;\n  arguments?: PromptArgument[];\n}\n\nexport interface PromptArgument {\n  name: string;\n  description?: string;\n  required?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Discovering OAuth Metadata from Authorization Server in TypeScript\nDESCRIPTION: Implements RFC 8414 OAuth 2.0 Authorization Server Metadata discovery. It attempts to fetch metadata from the well-known endpoint and handles CORS errors by retrying without custom headers. Returns undefined if the endpoint is not found (404).\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Looks up RFC 8414 OAuth 2.0 Authorization Server Metadata.\n *\n * If the server returns a 404 for the well-known endpoint, this function will\n * return `undefined`. Any other errors will be thrown as exceptions.\n */\nexport async function discoverOAuthMetadata(\n  serverUrl: string | URL,\n  opts?: { protocolVersion?: string },\n): Promise<OAuthMetadata | undefined> {\n  const url = new URL(\"/.well-known/oauth-authorization-server\", serverUrl);\n  let response: Response;\n  try {\n    response = await fetch(url, {\n      headers: {\n        \"MCP-Protocol-Version\": opts?.protocolVersion ?? LATEST_PROTOCOL_VERSION\n      }\n    });\n  } catch (error) {\n    // CORS errors come back as TypeError\n    if (error instanceof TypeError) {\n      response = await fetch(url);\n    } else {\n      throw error;\n    }\n  }\n\n  if (response.status === 404) {\n    return undefined;\n  }\n\n  if (!response.ok) {\n    throw new Error(\n      `HTTP ${response.status} trying to load well-known OAuth metadata`,\n    );\n  }\n\n  return OAuthMetadataSchema.parse(await response.json());\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Third-Party OAuth Authorization Flow with Mermaid\nDESCRIPTION: A sequence diagram illustrating the steps in the third-party authorization flow between User-Agent, MCP Client, MCP Server, and Third-Party Auth Server. Shows the complete OAuth flow including redirects, authorization code exchanges, and token generation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_89\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant B as User-Agent (Browser)\n    participant C as MCP Client\n    participant M as MCP Server\n    participant T as Third-Party Auth Server\n\n    C->>M: Initial OAuth Request\n    M->>B: Redirect to Third-Party /authorize\n    B->>T: Authorization Request\n    Note over T: User authorizes\n    T->>B: Redirect to MCP Server callback\n    B->>M: Authorization code\n    M->>T: Exchange code for token\n    T->>M: Third-party access token\n    Note over M: Generate bound MCP token\n    M->>B: Redirect to MCP Client callback\n    B->>C: MCP authorization code\n    C->>M: Exchange code for token\n    M->>C: MCP access token\n```\n\n----------------------------------------\n\nTITLE: Centralizing Prompts with Index Export\nDESCRIPTION: Shows the structure of the index.js file that will provide a clean interface for importing prompts\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_048.txt#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// prompts/index.js\nexport { taskSuggestionPrompt } from './task_suggestion_prompt';\nexport { featureActionPrompt } from './feature_action_prompt';\n```\n\n----------------------------------------\n\nTITLE: Registering Multiple Tools in MCP Server\nDESCRIPTION: Tests the ability to register multiple distinct tools to the same MCP server. This verifies that as long as the tool names are different, multiple tools can be registered without conflicts.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_119\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should allow registering multiple tools\", () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    // This should succeed\n    mcpServer.tool(\"tool1\", () => ({ content: [] }));\n    \n    // This should also succeed and not throw about request handlers\n    mcpServer.tool(\"tool2\", () => ({ content: [] }));\n  });\n```\n\n----------------------------------------\n\nTITLE: Testing JSON-RPC Message Buffer in TypeScript\nDESCRIPTION: Test suite for the ReadBuffer class that handles buffering and parsing of JSON-RPC messages from a continuous stream. Tests initialization, message parsing, and buffer reuse.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_179\n\nLANGUAGE: typescript\nCODE:\n```\nimport { JSONRPCMessage } from \"../types.js\";\nimport { ReadBuffer } from \"./stdio.js\";\n\nconst testMessage: JSONRPCMessage = {\n  jsonrpc: \"2.0\",\n  method: \"foobar\",\n};\n\ntest(\"should have no messages after initialization\", () => {\n  const readBuffer = new ReadBuffer();\n  expect(readBuffer.readMessage()).toBeNull();\n});\n\ntest(\"should only yield a message after a newline\", () => {\n  const readBuffer = new ReadBuffer();\n\n  readBuffer.append(Buffer.from(JSON.stringify(testMessage)));\n  expect(readBuffer.readMessage()).toBeNull();\n\n  readBuffer.append(Buffer.from(\"\\n\"));\n  expect(readBuffer.readMessage()).toEqual(testMessage);\n  expect(readBuffer.readMessage()).toBeNull();\n});\n\ntest(\"should be reusable after clearing\", () => {\n  const readBuffer = new ReadBuffer();\n\n  readBuffer.append(Buffer.from(\"foobar\"));\n  readBuffer.clear();\n  expect(readBuffer.readMessage()).toBeNull();\n\n  readBuffer.append(Buffer.from(JSON.stringify(testMessage)));\n  readBuffer.append(Buffer.from(\"\\n\"));\n  expect(readBuffer.readMessage()).toEqual(testMessage);\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Image Return in FastMCP\nDESCRIPTION: This test case verifies that FastMCP can correctly handle and return image content from a tool. It adds a tool that returns an image buffer and checks if the client receives the correct image data structure.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"returns an image\", async () => {\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      server.addTool({\n        name: \"add\",\n        description: \"Add two numbers\",\n        parameters: z.object({\n          a: z.number(),\n          b: z.number(),\n        }),\n        execute: async () => {\n          return imageContent({\n            buffer: Buffer.from(\n              \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\",\n              \"base64\",\n            ),\n          });\n        },\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      expect(\n        await client.callTool({\n          name: \"add\",\n          arguments: {\n            a: 1,\n            b: 2,\n          },\n        }),\n      ).toEqual({\n        content: [\n          {\n            type: \"image\",\n            data: \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=\",\n            mimeType: \"image/png\",\n          },\n        ],\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: List Changed Notification in JSON-RPC\nDESCRIPTION: Example of the notification format sent when the available tools list changes for servers that support the listChanged capability.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_135\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/tools/list_changed\"\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Client Notification Capability Enforcement\nDESCRIPTION: Tests that client notification capabilities are properly respected. A client with the roots.listChanged capability should be able to send that notification, while a client without that capability should be prevented from doing so when strict capability enforcement is enabled.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should respect client notification capabilities\", async () => {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {},\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        roots: {\n          listChanged: true,\n        },\n      },\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // This should work because the client has the roots.listChanged capability\n  await expect(client.sendRootsListChanged()).resolves.not.toThrow();\n\n  // Create a new client without the roots.listChanged capability\n  const clientWithoutCapability = new Client(\n    {\n      name: \"test client without capability\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {},\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  await clientWithoutCapability.connect(clientTransport);\n\n  // This should throw because the client doesn't have the roots.listChanged capability\n  await expect(clientWithoutCapability.sendRootsListChanged()).rejects.toThrow(\n    /^Client does not support/,\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Python for MCP Tools\nDESCRIPTION: Demonstrates proper error handling pattern for MCP tools in Python. The code shows how to structure tool responses with error reporting using the types.CallToolResult class that allows the LLM to see and handle errors appropriately.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_34\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    # Tool operation\n    result = perform_operation()\n    return types.CallToolResult(\n        content=[\n            types.TextContent(\n                type=\"text\",\n                text=f\"Operation successful: {result}\"\n            )\n        ]\n    )\nexcept Exception as error:\n    return types.CallToolResult(\n        isError=True,\n        content=[\n            types.TextContent(\n                type=\"text\",\n                text=f\"Error: {str(error)}\"\n            )\n        ]\n    )\n```\n\n----------------------------------------\n\nTITLE: Listing Resources Request/Response\nDESCRIPTION: JSON-RPC request and response for listing available resources with support for pagination.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_52\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"resources/list\",\n  \"params\": {\n    \"cursor\": \"optional-cursor-value\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"resources\": [\n      {\n        \"uri\": \"file:///project/src/main.rs\",\n        \"name\": \"main.rs\",\n        \"description\": \"Primary application entry point\",\n        \"mimeType\": \"text/x-rust\"\n      }\n    ],\n    \"nextCursor\": \"next-page-cursor\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Logging Interface in TypeScript\nDESCRIPTION: TypeScript interface for logging configuration, allowing a client to set the logging level on the server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_150\n\nLANGUAGE: typescript\nCODE:\n```\n/* Logging */\n/**\n * A request from the client to the server, to enable or adjust logging.\n */\nexport interface SetLevelRequest extends Request {\n  method: \"logging/setLevel\";\n  params: {\n    /**\n\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC 2.0 Notification Format in TypeScript\nDESCRIPTION: Definition of the notification message format in the MCP protocol following JSON-RPC 2.0. Notifications must not include an ID and do not expect a response.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\";\n  method: string;\n  params?: {\n    [key: string]: unknown;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource and Prompt Type Definitions in TypeScript\nDESCRIPTION: Type definitions for resource handling and prompt callbacks, including metadata types, callback functions, and utility methods for handling prompt arguments and completion results.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_150\n\nLANGUAGE: typescript\nCODE:\n```\nexport type ResourceMetadata = Omit<Resource, \"uri\" | \"name\">;\n\nexport type ListResourcesCallback = (\n  extra: RequestHandlerExtra,\n) => ListResourcesResult | Promise<ListResourcesResult>;\n\nexport type ReadResourceCallback = (\n  uri: URL,\n  extra: RequestHandlerExtra,\n) => ReadResourceResult | Promise<ReadResourceResult>;\n\ntype RegisteredResource = {\n  name: string;\n  metadata?: ResourceMetadata;\n  readCallback: ReadResourceCallback;\n};\n```\n\n----------------------------------------\n\nTITLE: Roots List Response in JSON-RPC 2.0\nDESCRIPTION: Example of a client response to a roots/list request, providing information about available filesystem roots including their URIs and display names.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_20\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"roots\": [\n      {\n        \"uri\": \"file:///home/user/projects/myproject\",\n        \"name\": \"My Project\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Grok3 API Client - TypeScript\nDESCRIPTION: A planned implementation detail indicating the creation of a new API client for Grok3 in TypeScript, to be placed in src/api/grok3.ts. The module will handle authentication, request formatting, and response parsing.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_035.txt#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nsrc/api/grok3.ts\n```\n\n----------------------------------------\n\nTITLE: URI Template Implementation Class\nDESCRIPTION: Core implementation of the UriTemplate class with RFC 6570 compliant parsing and expansion capabilities. Includes validation and security measures.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_184\n\nLANGUAGE: typescript\nCODE:\n```\nexport type Variables = Record<string, string | string[]>;\n\nconst MAX_TEMPLATE_LENGTH = 1000000; // 1MB\nconst MAX_VARIABLE_LENGTH = 1000000; // 1MB\nconst MAX_TEMPLATE_EXPRESSIONS = 10000;\nconst MAX_REGEX_LENGTH = 1000000; // 1MB\n\nexport class UriTemplate {\n  static isTemplate(str: string): boolean {\n    return /\\{[^}\\s]+\\}/.test(str);\n  }\n\n  private static validateLength(str: string, max: number, context: string): void {\n    if (str.length > max) {\n      throw new Error(`${context} exceeds maximum length of ${max} characters (got ${str.length})`);\n    }\n  }\n\n  private readonly template: string;\n  private readonly parts: Array<string | { name: string; operator: string; names: string[]; exploded: boolean }>;\n\n  constructor(template: string) {\n    UriTemplate.validateLength(template, MAX_TEMPLATE_LENGTH, \"Template\");\n    this.template = template;\n    this.parts = this.parse(template);\n  }\n\n  toString(): string {\n    return this.template;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Testing Basic Tool in MCP Server\nDESCRIPTION: Demonstrates registering a simple tool with the McpServer class and verifying it works correctly. The test creates a tool that returns a text response and ensures duplicate tools cannot be registered.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_118\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should allow registering a tool\", () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    expect(() => {\n      mcpServer.tool(\"test\", async () => ({\n        content: [\n          {\n            type: \"text\",\n            text: \"Test response\",\n          },\n        ],\n      }));\n    }).not.toThrow();\n\n    expect(() => {\n      mcpServer.tool(\"test\", async () => ({\n        content: [\n          {\n            type: \"text\",\n            text: \"Test response 2\",\n          },\n        ],\n      }));\n    }).toThrow(/already registered/);\n  });\n```\n\n----------------------------------------\n\nTITLE: Defining Tool-related Interfaces in TypeScript\nDESCRIPTION: Defines interfaces for listing tools available on the server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_171\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ListToolsRequest extends PaginatedRequest {\n  method: \"tools/list\";\n}\n\nexport interface ListToolsResult extends PaginatedResult {\n  tools: Tool[];\n}\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Endpoint Routing with Supertest\nDESCRIPTION: Test suite for verifying proper routing to OAuth endpoints. Tests check that authorization and token endpoints correctly handle requests and return appropriate responses, including valid redirection for authorization and token generation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_102\n\nLANGUAGE: TypeScript\nCODE:\n```\ndescribe('Endpoint routing', () => {\n  let app: express.Express;\n\n  beforeEach(() => {\n    // Setup full-featured router\n    app = express();\n    const options: AuthRouterOptions = {\n      provider: mockProvider,\n      issuerUrl: new URL('https://auth.example.com')\n    };\n    app.use(mcpAuthRouter(options));\n  });\n\n  it('routes to authorization endpoint', async () => {\n    const response = await supertest(app)\n      .get('/authorize')\n      .query({\n        client_id: 'valid-client',\n        response_type: 'code',\n        code_challenge: 'challenge123',\n        code_challenge_method: 'S256'\n      });\n\n    expect(response.status).toBe(302);\n    const location = new URL(response.header.location);\n    expect(location.searchParams.has('code')).toBe(true);\n  });\n\n  it('routes to token endpoint', async () => {\n    // Setup verifyChallenge mock for token handler\n    jest.mock('pkce-challenge', () => ({\n      verifyChallenge: jest.fn().mockResolvedValue(true)\n    }));\n\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'authorization_code',\n        code: 'valid_code',\n        code_verifier: 'valid_verifier'\n      });\n\n    // The request will fail in testing due to mocking limitations,\n    // but we can verify the route was matched\n    expect(response.status).not.toBe(404);\n  });\n\n  it('routes to registration endpoint', async () => {\n    const response = await supertest(app)\n      .post('/register')\n      .send({\n        redirect_uris: ['https://example.com/callback']\n      });\n\n    // The request will fail in testing due to mocking limitations,\n    // but we can verify the route was matched\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Creating and Connecting the First Client in Multi-Client Test (TypeScript)\nDESCRIPTION: Initializes the first FastMCP `Client` instance (`client1`) with specific metadata and capabilities. It then creates an `SSEClientTransport` pointing to the server's SSE endpoint and connects this first client to the server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nconst client1 = new Client(\n  {\n    name: \"example-client\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {},\n  },\n);\n\nconst transport1 = new SSEClientTransport(\n  new URL(`http://localhost:${port}/sse`),\n);\n\nawait client1.connect(transport1);\n```\n\n----------------------------------------\n\nTITLE: Task Dependency Management Commands in Task Master CLI\nDESCRIPTION: Commands for managing task dependencies, including adding, removing, and validating dependencies.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n# Add a dependency to a task\ntask-master add-dependency --id=<id> --depends-on=<id>\n\n# Remove a dependency from a task\ntask-master remove-dependency --id=<id> --depends-on=<id>\n\n# Validate dependencies without fixing them\ntask-master validate-dependencies\n\n# Find and fix invalid dependencies automatically\ntask-master fix-dependencies\n```\n\n----------------------------------------\n\nTITLE: Query Processing Implementation\nDESCRIPTION: Core logic for processing queries and handling tool calls with Claude AI.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_76\n\nLANGUAGE: typescript\nCODE:\n```\nasync processQuery(query: string) {\n  const messages: MessageParam[] = [\n    {\n      role: \"user\",\n      content: query,\n    },\n  ];\n\n  const response = await this.anthropic.messages.create({\n    model: \"claude-3-5-sonnet-20241022\",\n    max_tokens: 1000,\n    messages,\n    tools: this.tools,\n  });\n\n  const finalText = [];\n  const toolResults = [];\n\n  for (const content of response.content) {\n    if (content.type === \"text\") {\n      finalText.push(content.text);\n    } else if (content.type === \"tool_use\") {\n      const toolName = content.name;\n      const toolArgs = content.input as { [x: string]: unknown } | undefined;\n\n      const result = await this.mcp.callTool({\n        name: toolName,\n        arguments: toolArgs,\n      });\n      toolResults.push(result);\n      finalText.push(\n        `[Calling tool ${toolName} with args ${JSON.stringify(toolArgs)}]`\n      );\n\n      messages.push({\n        role: \"user\",\n        content: result.content as string,\n      });\n\n      const response = await this.anthropic.messages.create({\n        model: \"claude-3-5-sonnet-20241022\",\n        max_tokens: 1000,\n        messages,\n      });\n\n      finalText.push(\n        response.content[0].type === \"text\" ? response.content[0].text : \"\"\n      );\n    }\n  }\n\n  return finalText.join(\"\\n\");\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Image Content Handler in TypeScript\nDESCRIPTION: Function that generates an image content object from a URL, file path, or buffer. Supports multiple input types and returns base64 encoded image data with MIME type.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const imageContent = async (\n  input: { url: string } | { path: string } | { buffer: Buffer },\n): Promise<ImageContent> => {\n  let rawData: Buffer;\n\n  if (\"url\" in input) {\n    const response = await fetch(input.url);\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch image from URL: ${response.statusText}`);\n    }\n\n    rawData = Buffer.from(await response.arrayBuffer());\n  } else if (\"path\" in input) {\n    rawData = await readFile(input.path);\n  } else if (\"buffer\" in input) {\n    rawData = input.buffer;\n  } else {\n    throw new Error(\n      \"Invalid input: Provide a valid 'url', 'path', or 'buffer'\",\n    );\n  }\n\n  const mimeType = await fileTypeFromBuffer(rawData);\n\n  const base64Data = rawData.toString(\"base64\");\n\n  return {\n    type: \"image\",\n    data: base64Data,\n    mimeType: mimeType?.mime ?? \"image/png\",\n  } as const;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Weather Alert and Forecast Tools in Python\nDESCRIPTION: Python functions decorated as MCP tools to fetch weather alerts for a US state and weather forecasts for a specific location.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_90\n\nLANGUAGE: python\nCODE:\n```\n@mcp.tool()\nasync def get_alerts(state: str) -> str:\n    \"\"\"Get weather alerts for a US state.\n\n    Args:\n        state: Two-letter US state code (e.g. CA, NY)\n    \"\"\"\n    url = f\"{NWS_API_BASE}/alerts/active/area/{state}\"\n    data = await make_nws_request(url)\n\n    if not data or \"features\" not in data:\n        return \"Unable to fetch alerts or no alerts found.\"\n\n    if not data[\"features\"]:\n        return \"No active alerts for this state.\"\n\n    alerts = [format_alert(feature) for feature in data[\"features\"]]\n    return \"\\n---\\n\".join(alerts)\n\n@mcp.tool()\nasync def get_forecast(latitude: float, longitude: float) -> str:\n    \"\"\"Get weather forecast for a location.\n\n    Args:\n        latitude: Latitude of the location\n        longitude: Longitude of the location\n    \"\"\"\n    # First get the forecast grid endpoint\n    points_url = f\"{NWS_API_BASE}/points/{latitude},{longitude}\"\n    points_data = await make_nws_request(points_url)\n\n    if not points_data:\n        return \"Unable to fetch forecast data for this location.\"\n\n    # Get the forecast URL from the points response\n    forecast_url = points_data[\"properties\"][\"forecast\"]\n    forecast_data = await make_nws_request(forecast_url)\n\n    if not forecast_data:\n        return \"Unable to fetch detailed forecast.\"\n\n    # Format the periods into a readable forecast\n    periods = forecast_data[\"properties\"][\"periods\"]\n    forecasts = []\n    for period in periods[:5]:  # Only show next 5 periods\n        forecast = f\"\"\"\n{period['name']}:\nTemperature: {period['temperature']}°{period['temperatureUnit']}\nWind: {period['windSpeed']} {period['windDirection']}\nForecast: {period['detailedForecast']}\n\"\"\"\n        forecasts.append(forecast)\n\n    return \"\\n---\\n\".join(forecasts)\n```\n\n----------------------------------------\n\nTITLE: Testing POST Request Handling in SSE Transport\nDESCRIPTION: Tests the sending of messages via POST requests in the SSEClientTransport. Verifies that the correct headers are set and the message body is properly formatted.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"handles messages via POST requests\", async () => {\n  transport = new SSEClientTransport(baseUrl);\n  await transport.start();\n\n  const testMessage: JSONRPCMessage = {\n    jsonrpc: \"2.0\",\n    id: \"test-1\",\n    method: \"test\",\n    params: { foo: \"bar\" },\n  };\n\n  await transport.send(testMessage);\n\n  // Wait for request processing\n  await new Promise((resolve) => setTimeout(resolve, 50));\n\n  expect(lastServerRequest.method).toBe(\"POST\");\n  expect(lastServerRequest.headers[\"content-type\"]).toBe(\n    \"application/json\",\n  );\n  expect(\n    JSON.parse(\n      (lastServerRequest as IncomingMessage & { body: string }).body,\n    ),\n  ).toEqual(testMessage);\n});\n```\n\n----------------------------------------\n\nTITLE: Multiple Repositories Roots Example in JSON\nDESCRIPTION: Example of multiple root definitions for different repositories, each with its own file URI and display name, suitable for use in the roots/list response.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_23\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"uri\": \"file:///home/user/repos/frontend\",\n    \"name\": \"Frontend Repository\"\n  },\n  {\n    \"uri\": \"file:///home/user/repos/backend\",\n    \"name\": \"Backend Repository\"\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Listing Prompts Response in JSON\nDESCRIPTION: Illustrates the JSON-RPC response format for the prompts/list request. It includes an array of available prompts with their details and a nextCursor for pagination.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_42\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"prompts\": [\n      {\n        \"name\": \"code_review\",\n        \"description\": \"Asks the LLM to analyze code quality and suggest improvements\",\n        \"arguments\": [\n          {\n            \"name\": \"code\",\n            \"description\": \"The code to review\",\n            \"required\": true\n          }\n        ]\n      }\n    ],\n    \"nextCursor\": \"next-page-cursor\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Weather Service for MCP Server\nDESCRIPTION: Java implementation of a WeatherService class that provides weather forecast and alerts functionality. It uses Spring's @Service and @Tool annotations for automatic registration and MCP tool creation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_107\n\nLANGUAGE: java\nCODE:\n```\n@Service\npublic class WeatherService {\n\n\tprivate final RestClient restClient;\n\n\tpublic WeatherService() {\n\t\tthis.restClient = RestClient.builder()\n\t\t\t.baseUrl(\"https://api.weather.gov\")\n\t\t\t.defaultHeader(\"Accept\", \"application/geo+json\")\n\t\t\t.defaultHeader(\"User-Agent\", \"WeatherApiClient/1.0 (your@email.com)\")\n\t\t\t.build();\n\t}\n\n  @Tool(description = \"Get weather forecast for a specific latitude/longitude\")\n  public String getWeatherForecastByLocation(\n      double latitude,   // Latitude coordinate\n      double longitude   // Longitude coordinate\n  ) {\n      // Returns detailed forecast including:\n      // - Temperature and unit\n      // - Wind speed and direction\n      // - Detailed forecast description\n  }\n\t\n  @Tool(description = \"Get weather alerts for a US state\")\n  public String getAlerts(\n      @ToolParam(description = \"Two-letter US state code (e.g. CA, NY\") String state)\n  ) {\n      // Returns active alerts including:\n      // - Event type\n      // - Affected area\n      // - Severity\n      // - Description\n      // - Safety instructions\n  }\n\n  // ......\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Token Refresh Handling in SSE Transport\nDESCRIPTION: Test case that verifies the SSE client transport can automatically refresh expired tokens and continue operation with the new tokens.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"handles token refresh on 401\", async () => {\n  // Mock tokens() to return expired token until saveTokens is called\n  let currentTokens: OAuthTokens = {\n    access_token: \"expired-token\",\n    token_type: \"Bearer\",\n    refresh_token: \"refresh-token\"\n  };\n  mockAuthProvider.tokens.mockImplementation(() => currentTokens);\n  mockAuthProvider.saveTokens.mockImplementation((tokens) => {\n    currentTokens = tokens;\n  });\n\n  // Create server that accepts SSE but returns 401 on POST with expired token\n  await server.close();\n\n  let postAttempts = 0;\n  server = createServer((req, res) => {\n    lastServerRequest = req;\n\n    if (req.url === \"/token\" && req.method === \"POST\") {\n      // Handle token refresh request\n      let body = \"\";\n      req.on(\"data\", chunk => { body += chunk; });\n      req.on(\"end\", () => {\n        const params = new URLSearchParams(body);\n        if (params.get(\"grant_type\") === \"refresh_token\" &&\n          params.get(\"refresh_token\") === \"refresh-token\" &&\n          params.get(\"client_id\") === \"test-client-id\" &&\n          params.get(\"client_secret\") === \"test-client-secret\") {\n          res.writeHead(200, { \"Content-Type\": \"application/json\" });\n          res.end(JSON.stringify({\n            access_token: \"new-token\",\n            token_type: \"Bearer\",\n            refresh_token: \"new-refresh-token\"\n          }));\n        } else {\n          res.writeHead(400).end();\n        }\n      });\n      return;\n    }\n\n    switch (req.method) {\n      case \"GET\":\n        if (req.url !== \"/\") {\n          res.writeHead(404).end();\n          return;\n        }\n\n        res.writeHead(200, {\n          \"Content-Type\": \"text/event-stream\",\n          \"Cache-Control\": \"no-cache\",\n          Connection: \"keep-alive\",\n        });\n        res.write(\"event: endpoint\\n\");\n        res.write(`data: ${baseUrl.href}\\n\\n`);\n        break;\n\n      case \"POST\": {\n        if (req.url !== \"/\") {\n          res.writeHead(404).end();\n          return;\n        }\n\n        const auth = req.headers.authorization;\n        if (auth === \"Bearer expired-token\") {\n          res.writeHead(401).end();\n          return;\n        }\n\n        if (auth === \"Bearer new-token\") {\n          res.writeHead(200).end();\n          postAttempts++;\n          return;\n        }\n\n        res.writeHead(401).end();\n        break;\n      }\n    }\n  });\n\n  await new Promise<void>(resolve => {\n    server.listen(0, \"127.0.0.1\", () => {\n      const addr = server.address() as AddressInfo;\n      baseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n      resolve();\n    });\n  });\n\n  transport = new SSEClientTransport(baseUrl, {\n    authProvider: mockAuthProvider,\n  });\n\n  await transport.start();\n\n  const message: JSONRPCMessage = {\n    jsonrpc: \"2.0\",\n    id: \"1\",\n    method: \"test\",\n    params: {},\n  };\n\n  await transport.send(message);\n\n  expect(mockAuthProvider.saveTokens).toHaveBeenCalledWith({\n    access_token: \"new-token\",\n    token_type: \"Bearer\",\n    refresh_token: \"new-refresh-token\"\n  });\n  expect(postAttempts).toBe(1);\n  expect(lastServerRequest.headers.authorization).toBe(\"Bearer new-token\");\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring Completion Capability in JSON\nDESCRIPTION: Servers supporting completions must declare the 'completions' capability during initialization.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_105\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"completions\": {}\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Resource Templates in MCP Server\nDESCRIPTION: Tests the registration of resource templates with URI patterns. Resource templates allow for dynamic resource access patterns with parameterized URIs, enabling more flexible resource handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_126\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should register resource template\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{id}\", { list: undefined }),\n      async () => ({\n        contents: [\n          {\n            uri: \"test://resource/123\",\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/templates/list\",\n      },\n      ListResourceTemplatesResultSchema,\n    );\n\n    expect(result.resourceTemplates).toHaveLength(1);\n    expect(result.resourceTemplates[0].name).toBe(\"test\");\n    expect(result.resourceTemplates[0].uriTemplate).toBe(\n      \"test://resource/{id}\",\n    );\n  });\n```\n\n----------------------------------------\n\nTITLE: Configuring STDIO Transport for MCP Client in Java\nDESCRIPTION: Creates an in-process based communication transport using STDIO for the MCP client. This approach is useful for communicating with local MCP servers launched as subprocesses.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_120\n\nLANGUAGE: java\nCODE:\n```\nServerParameters params = ServerParameters.builder(\"npx\")\n    .args(\"-y\", \"@modelcontextprotocol/server-everything\", \"dir\")\n    .build();\nMcpTransport transport = new StdioClientTransport(params);\n```\n\n----------------------------------------\n\nTITLE: Implementing Tools in MCP Server\nDESCRIPTION: Examples of creating simple and async tools in an MCP server, allowing LLMs to perform actions and computations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_229\n\nLANGUAGE: typescript\nCODE:\n```\n// Simple tool with parameters\nserver.tool(\n  \"calculate-bmi\",\n  {\n    weightKg: z.number(),\n    heightM: z.number()\n  },\n  async ({ weightKg, heightM }) => ({\n    content: [{\n      type: \"text\",\n      text: String(weightKg / (heightM * heightM))\n    }]\n  })\n);\n\n// Async tool with external API call\nserver.tool(\n  \"fetch-weather\",\n  { city: z.string() },\n  async ({ city }) => {\n    const response = await fetch(`https://api.weather.com/${city}`);\n    const data = await response.text();\n    return {\n      content: [{ type: \"text\", text: data }]\n    };\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Registering Synchronous Prompt in Java MCP SDK\nDESCRIPTION: Creates a synchronous prompt registration with an ID, description, and a list of prompt arguments. The implementation function processes the request and returns a prompt result containing a description and message list when invoked by an MCP client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_148\n\nLANGUAGE: java\nCODE:\n```\n// Sync prompt registration\nvar syncPromptRegistration = new McpServerFeatures.SyncPromptRegistration(\n    new Prompt(\"greeting\", \"description\", List.of(\n        new PromptArgument(\"name\", \"description\", true)\n    )),\n    request -> {\n        // Prompt implementation\n        return new GetPromptResult(description, messages);\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Server Capabilities and Prompt Handlers\nDESCRIPTION: Sets up server capabilities and implements handlers for listing and getting prompts with argument validation and error handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_146\n\nLANGUAGE: typescript\nCODE:\n```\nthis.server.registerCapabilities({\n      prompts: {},\n    });\n\n    this.server.setRequestHandler(\n      ListPromptsRequestSchema,\n      (): ListPromptsResult => ({\n        prompts: Object.entries(this._registeredPrompts).map(\n          ([name, prompt]): Prompt => {\n            return {\n              name,\n              description: prompt.description,\n              arguments: prompt.argsSchema\n                ? promptArgumentsFromSchema(prompt.argsSchema)\n                : undefined,\n            };\n          },\n        ),\n      }),\n    );\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuth Error Classes in TypeScript\nDESCRIPTION: This snippet defines a base OAuthError class and various specific OAuth error types. Each error class corresponds to a standard OAuth error response and includes methods for generating response objects.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_95\n\nLANGUAGE: typescript\nCODE:\n```\nexport class OAuthError extends Error {\n  constructor(\n    public readonly errorCode: string,\n    message: string,\n    public readonly errorUri?: string\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n\n  toResponseObject(): OAuthErrorResponse {\n    const response: OAuthErrorResponse = {\n      error: this.errorCode,\n      error_description: this.message\n    };\n\n    if (this.errorUri) {\n      response.error_uri = this.errorUri;\n    }\n\n    return response;\n  }\n}\n\n// Additional error classes (InvalidRequestError, InvalidClientError, etc.) follow the same pattern\n```\n\n----------------------------------------\n\nTITLE: Defining OAuth 2.0 Authorization Validation Schemas with Zod\nDESCRIPTION: Schema definitions using Zod for validating OAuth 2.0 authorization request parameters. This includes separate schemas for client validation parameters and request validation parameters, enforcing proper format and required fields.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_58\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Parameters that must be validated in order to issue redirects.\nconst ClientAuthorizationParamsSchema = z.object({\n  client_id: z.string(),\n  redirect_uri: z.string().optional().refine((value) => value === undefined || URL.canParse(value), { message: \"redirect_uri must be a valid URL\" }),\n});\n\n// Parameters that must be validated for a successful authorization request. Failure can be reported to the redirect URI.\nconst RequestAuthorizationParamsSchema = z.object({\n  response_type: z.literal(\"code\"),\n  code_challenge: z.string(),\n  code_challenge_method: z.literal(\"S256\"),\n  scope: z.string().optional(),\n  state: z.string().optional(),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Tool Structure in TypeScript\nDESCRIPTION: Demonstrates the structure of a tool definition in the Model Context Protocol. It includes the tool's name, description, and input schema.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  name: string;          // Unique identifier for the tool\n  description?: string;  // Human-readable description\n  inputSchema: {         // JSON Schema for the tool's parameters\n    type: \"object\",\n    properties: { ... }  // Tool-specific parameters\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Main Execution Logic for MCP Client\nDESCRIPTION: Entry point for the MCP client, handling command-line arguments, initializing the client, and running the chat loop.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_69\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n    if len(sys.argv) < 2:\n        print(\"Usage: python client.py <path_to_server_script>\")\n        sys.exit(1)\n\n    client = MCPClient()\n    try:\n        await client.connect_to_server(sys.argv[1])\n        await client.chat_loop()\n    finally:\n        await client.cleanup()\n\nif __name__ == \"__main__\":\n    import sys\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Registering Asynchronous Calculator Tool in Java MCP SDK\nDESCRIPTION: Implements an asynchronous tool registration for a calculator with the same JSON schema as the sync version. This version returns a Mono for reactive processing, making it suitable for non-blocking operations in high-concurrency environments.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_145\n\nLANGUAGE: java\nCODE:\n```\n// Async tool registration\nvar schema = \"\"\"\n            {\n              \"type\" : \"object\",\n              \"id\" : \"urn:jsonschema:Operation\",\n              \"properties\" : {\n                \"operation\" : {\n                  \"type\" : \"string\"\n                },\n                \"a\" : {\n                  \"type\" : \"number\"\n                },\n                \"b\" : {\n                  \"type\" : \"number\"\n                }\n              }\n            }\n            \"\"\";\nvar asyncToolRegistration = new McpServerFeatures.AsyncToolRegistration(\n    new Tool(\"calculator\", \"Basic calculator\", schema),\n    arguments -> {\n        // Tool implementation\n        return Mono.just(new CallToolResult(result, false));\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Testing Message Sampling Request in MCP Client-Server\nDESCRIPTION: Test that verifies a client can request message sampling from the server. The client sets up a handler for message creation requests and the session makes a sampling request with a user message.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_37\n\nLANGUAGE: JavaScript\nCODE:\n```\ntest(\"makes a sampling request\", async () => {\n  const onMessageRequest = vi.fn(() => {\n    return {\n      model: \"gpt-3.5-turbo\",\n      role: \"assistant\",\n      content: {\n        type: \"text\",\n        text: \"The files are in the current directory.\",\n      },\n    };\n  });\n\n  await runWithTestServer({\n    client: async () => {\n      const client = new Client(\n        {\n          name: \"example-client\",\n          version: \"1.0.0\",\n        },\n        {\n          capabilities: {\n            sampling: {},\n          },\n        },\n      );\n      return client;\n    },\n    run: async ({ client, session }) => {\n      client.setRequestHandler(CreateMessageRequestSchema, onMessageRequest);\n\n      const response = await session.requestSampling({\n        messages: [\n          {\n            role: \"user\",\n            content: {\n              type: \"text\",\n              text: \"What files are in the current directory?\",\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up FastMCP Server Event Listeners for Connect/Disconnect in TypeScript\nDESCRIPTION: Initializes a FastMCP server instance. It then sets up event listeners using `server.on` for the 'connect' and 'disconnect' events, associating them with `vitest` mock functions (`onConnect`, `onDisconnect`) to track when these events occur.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst port = await getRandomPort();\n\nconst server = new FastMCP({\n  name: \"Test\",\n  version: \"1.0.0\",\n});\n\nconst onConnect = vi.fn();\nconst onDisconnect = vi.fn();\n\nserver.on(\"connect\", onConnect);\nserver.on(\"disconnect\", onDisconnect);\n```\n\n----------------------------------------\n\nTITLE: Defining ProgressNotification Interface in TypeScript\nDESCRIPTION: Defines a ProgressNotification interface extending the Notification type, used for informing the receiver of progress updates for long-running requests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_164\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ProgressNotification extends Notification {\n  method: \"notifications/progress\";\n  params: {\n    progressToken: ProgressToken;\n    progress: number;\n    total?: number;\n    message?: string;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Available Prompts with Pagination\nDESCRIPTION: JSON-RPC request for listing available prompts. This operation supports pagination through an optional cursor parameter for retrieving large sets of prompts.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_116\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"prompts/list\",\n  \"params\": {\n    \"cursor\": \"optional-cursor-value\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Tasks with Various Options\nDESCRIPTION: Shows different ways to list tasks using the task management script, including filtering by status and including subtasks in the output.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# List all tasks\nnode scripts/dev.js list\n\n# List tasks with a specific status\nnode scripts/dev.js list --status=pending\n\n# List tasks and include their subtasks\nnode scripts/dev.js list --with-subtasks\n\n# List tasks with a specific status and include their subtasks\nnode scripts/dev.js list --status=pending --with-subtasks\n```\n\n----------------------------------------\n\nTITLE: Defining MCP Error Class in TypeScript\nDESCRIPTION: This snippet defines a custom error class for MCP errors, extending the built-in Error class. It includes a code, message, and optional data.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_223\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class McpError extends Error {\n  constructor(\n    public readonly code: number,\n    message: string,\n    public readonly data?: unknown,\n  ) {\n    super(`MCP error ${code}: ${message}`);\n    this.name = \"McpError\";\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Class Implementations for Fast MCP in TypeScript\nDESCRIPTION: Defines a hierarchy of error classes for the Fast MCP SDK, including a base abstract FastMCPError class, UnexpectedStateError with extras support, and UserError for user-facing errors. These provide structured error handling within the MCP framework.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nabstract class FastMCPError extends Error {\n  public constructor(message?: string) {\n    super(message);\n    this.name = new.target.name;\n  }\n}\n\ntype Extra = unknown;\n\ntype Extras = Record<string, Extra>;\n\nexport class UnexpectedStateError extends FastMCPError {\n  public extras?: Extras;\n\n  public constructor(message: string, extras?: Extras) {\n    super(message);\n    this.name = new.target.name;\n    this.extras = extras;\n  }\n}\n\n/**\n * An error that is meant to be surfaced to the user.\n */\nexport class UserError extends UnexpectedStateError {}\n```\n\n----------------------------------------\n\nTITLE: Sending Progress Update Notification (JSON-RPC) - JSON\nDESCRIPTION: A JSON-RPC notification for reporting progress on an ongoing operation, referencing the original progressToken. The notification includes current progress and optionally the total, both of which may be floating point values. Used by either party to communicate operation status. Inputs: progressToken, progress value, optional total. Outputs: real-time progress updates to the requester. Constraint: Progress must monotonically increase for the token.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_8\n\nLANGUAGE: JSON\nCODE:\n```\n{\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"method\\\": \\\"notifications/progress\\\",\\n  \\\"params\\\": {\\n    \\\"progressToken\\\": \\\"abc123\\\",\\n    \\\"progress\\\": 50,\\n    \\\"total\\\": 100\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Latest Version from NPM Registry\nDESCRIPTION: Code snippet for fetching the latest version of the package from the npm registry API. The endpoint URL points to the 'task-master-ai' package's latest version information.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_038.txt#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nhttps://registry.npmjs.org/task-master-ai/latest\n```\n\n----------------------------------------\n\nTITLE: Creating Prompts in MCP Server\nDESCRIPTION: Example of defining a reusable prompt template in an MCP server to guide LLM interactions.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_230\n\nLANGUAGE: typescript\nCODE:\n```\nserver.prompt(\n  \"review-code\",\n  { code: z.string() },\n  ({ code }) => ({\n    messages: [{\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: `Please review this code:\\n\\n${code}`\n      }\n    }]\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Receiving Prompt Content via MCP 'prompts/get' Response in TypeScript/JSON\nDESCRIPTION: This snippet shows the JSON-RPC response received from the server after a `prompts/get` request. It includes the potentially updated `description` and a `messages` array. This array contains the sequence of messages (user, assistant, etc.) that constitute the prompt's interaction, ready to be used, for example, in an LLM conversation. The content can include text or resource data.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// Response\n{\n  description: \"Analyze Python code for potential improvements\",\n  messages: [\n    {\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: \"Please analyze the following Python code for potential improvements:\\n\\n```python\\ndef calculate_sum(numbers):\\n    total = 0\\n    for num in numbers:\\n        total = total + num\\n    return total\\n\\nresult = calculate_sum([1, 2, 3, 4, 5])\\nprint(result)\\n```\"\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining API Integration Tool in TypeScript\nDESCRIPTION: Demonstrates a tool definition for creating a GitHub issue. It includes the tool's name, description, and input schema for issue creation parameters.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  name: \"github_create_issue\",\n  description: \"Create a GitHub issue\",\n  inputSchema: {\n    type: \"object\",\n    properties: {\n      title: { type: \"string\" },\n      body: { type: \"string\" },\n      labels: { type: \"array\", items: { type: \"string\" } }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Embedded Resource Content Format in JSON\nDESCRIPTION: JSON format for embedded resource content in tool results. This allows tools to return content as a resource that can be referenced and accessed later via a URI.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_68\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"resource\",\n  \"resource\": {\n    \"uri\": \"resource://example\",\n    \"mimeType\": \"text/plain\",\n    \"text\": \"Resource content\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Server with stdio Transport in TypeScript\nDESCRIPTION: Demonstrates how to set up an MCP server using the stdio transport in TypeScript. The code initializes a server with name and version, then connects it with the standard input/output transport.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new Server({\n  name: \"example-server\",\n  version: \"1.0.0\"\n}, {\n  capabilities: {}\n});\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Testing Custom Fetch Implementation for Auth Headers\nDESCRIPTION: Tests the use of a custom fetch implementation to add authentication headers to SSE requests. This demonstrates how to integrate authentication with the SSEClientTransport.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"uses custom fetch implementation from EventSourceInit to add auth headers\", async () => {\n  const authToken = \"Bearer test-token\";\n\n  // Create a fetch wrapper that adds auth header\n  const fetchWithAuth = (url: string | URL, init?: RequestInit) => {\n    const headers = new Headers(init?.headers);\n    headers.set(\"Authorization\", authToken);\n    return fetch(url.toString(), { ...init, headers });\n  };\n\n  transport = new SSEClientTransport(baseUrl, {\n    eventSourceInit: {\n      // Custom fetch implementation\n    }\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Processing JSON-RPC Responses\nDESCRIPTION: Handles incoming JSON-RPC responses by finding the corresponding handler and delivering either the result or error. Cleans up associated resources after processing.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_172\n\nLANGUAGE: typescript\nCODE:\n```\nprivate _onresponse(response: JSONRPCResponse | JSONRPCError): void {\n  const messageId = Number(response.id);\n  const handler = this._responseHandlers.get(messageId);\n  if (handler === undefined) {\n    this._onerror(\n      new Error(\n        `Received a response for an unknown message ID: ${JSON.stringify(response)}`,\n      ),\n    );\n    return;\n  }\n\n  this._responseHandlers.delete(messageId);\n  this._progressHandlers.delete(messageId);\n  this._cleanupTimeout(messageId);\n\n  if (\"result\" in response) {\n    handler(response);\n  } else {\n    const error = new McpError(\n      response.error.code,\n      response.error.message,\n      response.error.data,\n    );\n    handler(error);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing McpServer Initialization and Notifications in TypeScript\nDESCRIPTION: This snippet tests the initialization of an McpServer instance and sending notifications through the underlying Server. It verifies that the server exposes the correct instance and can send logging messages.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_115\n\nLANGUAGE: typescript\nCODE:\n```\ndescribe(\"McpServer\", () => {\n  test(\"should expose underlying Server instance\", () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    expect(mcpServer.server).toBeDefined();\n  });\n\n  test(\"should allow sending notifications via Server\", async () => {\n    const mcpServer = new McpServer(\n      {\n        name: \"test server\",\n        version: \"1.0\",\n      },\n      { capabilities: { logging: {} } },\n    );\n\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    // This should work because we're using the underlying server\n    await expect(\n      mcpServer.server.sendLoggingMessage({\n        level: \"info\",\n        data: \"Test log message\",\n      }),\n    ).resolves.not.toThrow();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for FastMCP Server in TypeScript\nDESCRIPTION: This snippet shows the import statements for the FastMCP server implementation. It includes imports from the MCP SDK, zod for schema validation, and various utility libraries.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ClientCapabilities,\n  CompleteRequestSchema,\n  CreateMessageRequestSchema,\n  ErrorCode,\n  GetPromptRequestSchema,\n  ListPromptsRequestSchema,\n  ListResourcesRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n  Root,\n  RootsListChangedNotificationSchema,\n  ServerCapabilities,\n  SetLevelRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { z } from \"zod\";\nimport { setTimeout as delay } from \"timers/promises\";\nimport { readFile } from \"fs/promises\";\nimport { fileTypeFromBuffer } from \"file-type\";\nimport { StrictEventEmitter } from \"strict-event-emitter-types\";\nimport { EventEmitter } from \"events\";\nimport Fuse from \"fuse.js\";\nimport { startSSEServer } from \"mcp-proxy\";\nimport { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport parseURITemplate from \"uri-templates\";\nimport http from \"http\";\nimport {\n  fetch\n} from \"undici\";\n```\n\n----------------------------------------\n\nTITLE: Registering Resource Templates with List Callback\nDESCRIPTION: Tests resource templates with list callback functionality. The list callback enables dynamic enumeration of resources matching a template pattern, allowing clients to discover available resources.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_127\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should register resource template with listCallback\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      new ResourceTemplate(\"test://resource/{id}\", {\n        list: async () => ({\n          resources: [\n            {\n              name: \"Resource 1\",\n              uri: \"test://resource/1\",\n            },\n            {\n              name: \"Resource 2\",\n              uri: \"test://resource/2\",\n            },\n          ],\n        }),\n      }),\n      async (uri) => ({\n        contents: [\n          {\n            uri: uri.href,\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/list\",\n      },\n      ListResourcesResultSchema,\n    );\n\n    expect(result.resources).toHaveLength(2);\n    expect(result.resources[0].name).toBe(\"Resource 1\");\n    expect(result.resources[0].uri).toBe(\"test://resource/1\");\n    expect(result.resources[1].name).toBe(\"Resource 2\");\n    expect(result.resources[1].uri).toBe(\"test://resource/2\");\n  });\n```\n\n----------------------------------------\n\nTITLE: Testing Insufficient Scope Error Handling in Bearer Authentication\nDESCRIPTION: Test case that verifies the middleware correctly handles InsufficientScopeError exceptions. It simulates a scope validation failure and checks that a 403 error response is returned with the proper scope-related error message.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_87\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should return 403 when access token has insufficient scopes\", async () => {\n  mockRequest.headers = {\n    authorization: \"Bearer valid-token\",\n  };\n\n  mockVerifyAccessToken.mockRejectedValue(new InsufficientScopeError(\"Required scopes: read, write\"));\n\n  const middleware = requireBearerAuth({ provider: mockProvider });\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n  expect(mockResponse.status).toHaveBeenCalledWith(403);\n  expect(mockResponse.set).toHaveBeenCalledWith(\n    \"WWW-Authenticate\",\n    expect.stringContaining('Bearer error=\"insufficient_scope\"')\n  );\n  expect(mockResponse.json).toHaveBeenCalledWith(\n    expect.objectContaining({ error: \"insufficient_scope\", error_description: \"Required scopes: read, write\" })\n  );\n  expect(nextFunction).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Testing URI Template Parameter Extraction in Resource Registration\nDESCRIPTION: Tests that a resource template can extract parameters from a URI when handling a resource read request. The test configures a templated resource and verifies that category and ID parameters are correctly extracted from the URI.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_128\n\nLANGUAGE: JavaScript\nCODE:\n```\nnew ResourceTemplate(\"test://resource/{category}/{id}\", {\n  list: undefined,\n}),\nasync (uri, { category, id }) => ({\n  contents: [\n    {\n      uri: uri.href,\n      text: `Category: ${category}, ID: ${id}`,\n    },\n  ],\n}),\n);\n\nconst [clientTransport, serverTransport] =\n  InMemoryTransport.createLinkedPair();\n\nawait Promise.all([\n  client.connect(clientTransport),\n  mcpServer.server.connect(serverTransport),\n]);\n\nconst result = await client.request(\n  {\n    method: \"resources/read\",\n    params: {\n      uri: \"test://resource/books/123\",\n    },\n  },\n  ReadResourceResultSchema,\n);\n\nexpect(result.contents[0].text).toBe(\"Category: books, ID: 123\");\n```\n\n----------------------------------------\n\nTITLE: Prompt List Changed Notification\nDESCRIPTION: JSON-RPC notification sent by servers when the list of available prompts changes. Clients should request an updated prompt list upon receiving this notification.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_120\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/prompts/list_changed\"\n}\n```\n\n----------------------------------------\n\nTITLE: Progress Request with Token\nDESCRIPTION: JSON-RPC request format for long-running operations with progress tracking token in metadata.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_78\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"some_method\",\n  \"params\": {\n    \"_meta\": {\n      \"progressToken\": \"abc123\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Available Prompts via MCP 'prompts/list' in TypeScript/JSON\nDESCRIPTION: This code shows the JSON-RPC request format for discovering available prompts from an MCP server. A client sends this request object with the `method` property set to `\"prompts/list\"`. No parameters are required for this specific method.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// Request\n{\n  method: \"prompts/list\"\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Server and Client Capabilities in TypeScript\nDESCRIPTION: Utility function for merging capability objects in a JSON-RPC protocol implementation. Preserves nested objects and merges them properly.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_178\n\nLANGUAGE: typescript\nCODE:\n```\nexport function mergeCapabilities<\n  T extends ServerCapabilities | ClientCapabilities,\n>(base: T, additional: T): T {\n  return Object.entries(additional).reduce(\n    (acc, [key, value]) => {\n      if (value && typeof value === \"object\") {\n        acc[key] = acc[key] ? { ...acc[key], ...value } : value;\n      } else {\n        acc[key] = value;\n      }\n      return acc;\n    },\n    { ...base },\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initialized Notification in MCP Protocol\nDESCRIPTION: JSON-RPC notification sent by the client after successful initialization to indicate readiness to begin normal operations. This is a required step in the MCP lifecycle before regular communication can begin.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_93\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/initialized\"\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Coverage Report\nDESCRIPTION: Command to execute tests and generate coverage reports, aiming for 80% test coverage across all code paths\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tests/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run test:coverage\n```\n\n----------------------------------------\n\nTITLE: Initializing and Starting FastMCP Server for Multi-Client Test in TypeScript\nDESCRIPTION: Initializes a FastMCP server instance and starts it using Server-Sent Events (SSE) transport on a randomly assigned port. This setup prepares the server to accept multiple client connections for testing purposes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nconst port = await getRandomPort();\n\nconst server = new FastMCP({\n  name: \"Test\",\n  version: \"1.0.0\",\n});\n\nawait server.start({\n  transportType: \"sse\",\n  sse: {\n    endpoint: \"/sse\",\n    port,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple Progress Notifications in Protocol with Jest\nDESCRIPTION: Tests how the Protocol class handles multiple progress notifications for a single request. The test simulates progress updates, verifies the callback is called correctly with each update, and confirms the request completes successfully.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_158\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should handle multiple progress notifications correctly\", async () => {\n  await protocol.connect(transport);\n  const request = { method: \"example\", params: {} };\n  const mockSchema: ZodType<{ result: string }> = z.object({\n    result: z.string(),\n  });\n  const onProgressMock = jest.fn();\n  const requestPromise = protocol.request(request, mockSchema, {\n    timeout: 1000,\n    resetTimeoutOnProgress: true,\n    onprogress: onProgressMock,\n  });\n\n  // Simulate multiple progress updates\n  for (let i = 1; i <= 3; i++) {\n    jest.advanceTimersByTime(800);\n    if (transport.onmessage) {\n      transport.onmessage({\n        jsonrpc: \"2.0\",\n        method: \"notifications/progress\",\n        params: {\n          progressToken: 0,\n          progress: i * 25,\n          total: 100,\n        },\n      });\n    }\n    await Promise.resolve();\n    expect(onProgressMock).toHaveBeenNthCalledWith(i, {\n      progress: i * 25,\n      total: 100,\n    });\n  }\n  if (transport.onmessage) {\n    transport.onmessage({\n      jsonrpc: \"2.0\",\n      id: 0,\n      result: { result: \"success\" },\n    });\n  }\n  await Promise.resolve();\n  await expect(requestPromise).resolves.toEqual({ result: \"success\" });\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Resources and Templates in FastMCP\nDESCRIPTION: These methods add resources and resource templates to the FastMCP instance. They handle argument completions for resource templates.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nprivate addResource(inputResource: Resource) {\n    this.#resources.push(inputResource);\n  }\n\n  private addResourceTemplate(inputResourceTemplate: InputResourceTemplate) {\n    const completers: Record<string, ArgumentValueCompleter> = {};\n\n    for (const argument of inputResourceTemplate.arguments ?? []) {\n      if (argument.complete) {\n        completers[argument.name] = argument.complete;\n      }\n    }\n\n    const resourceTemplate = {\n      ...inputResourceTemplate,\n      complete: async (name: string, value: string) => {\n        if (completers[name]) {\n          return await completers[name](value);\n        }\n\n        return {\n          values: [],\n        };\n      },\n    };\n\n    this.#resourceTemplates.push(resourceTemplate);\n  }\n```\n\n----------------------------------------\n\nTITLE: Embedded Resource Content Type Format\nDESCRIPTION: JSON format for referencing server-side resources in prompt messages. Resources must include a valid URI, MIME type, and either text or binary data, allowing prompts to incorporate server-managed content.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_125\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"resource\",\n  \"resource\": {\n    \"uri\": \"resource://example\",\n    \"mimeType\": \"text/plain\",\n    \"text\": \"Resource content\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Text Content Format in JSON\nDESCRIPTION: JSON format for text content in tool results. This represents the simplest form of content that a tool can return to the client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_66\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"text\",\n  \"text\": \"Tool result text\"\n}\n```\n\n----------------------------------------\n\nTITLE: Updating the Command Map for MCP Tools in JavaScript\nDESCRIPTION: Shows how to update the `commandMap` object in `mcp-server/src/tools/utils.js`. This map links the command-line/tool name (e.g., 'new-feature') to the corresponding function name exposed in `task-master-core.js` ('newFeature').\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/MCP_INTEGRATION.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// In mcp-server/src/tools/utils.js\nconst commandMap = {\n\t// ... existing mappings\n\t'new-feature': 'newFeature'\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Resource List Request and Result Schemas\nDESCRIPTION: Schemas for listing resources available on the server. The request extends PaginatedRequestSchema for paginated results, and the result includes an array of ResourceSchema objects representing available resources.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_202\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Sent from the client to request a list of resources the server has.\n */\nexport const ListResourcesRequestSchema = PaginatedRequestSchema.extend({\n  method: z.literal(\"resources/list\"),\n});\n\n/**\n * The server's response to a resources/list request from the client.\n */\nexport const ListResourcesResultSchema = PaginatedResultSchema.extend({\n  resources: z.array(ResourceSchema),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Prompt-Related Schemas in TypeScript with Zod\nDESCRIPTION: Defines Zod schemas for prompt-related functionality including prompt listing, retrieval, and notification of prompt list changes. These schemas validate the structure of data exchanged between client and server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_209\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Sent from the client to request a list of prompts and prompt templates the server has.\n */\nexport const ListPromptsRequestSchema = PaginatedRequestSchema.extend({\n  method: z.literal(\"prompts/list\"),\n});\n\n/**\n * The server's response to a prompts/list request from the client.\n */\nexport const ListPromptsResultSchema = PaginatedResultSchema.extend({\n  prompts: z.array(PromptSchema),\n});\n\n/**\n * Used by the client to get a prompt provided by the server.\n */\nexport const GetPromptRequestSchema = RequestSchema.extend({\n  method: z.literal(\"prompts/get\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The name of the prompt or prompt template.\n     */\n    name: z.string(),\n    /**\n     * Arguments to use for templating the prompt.\n     */\n    arguments: z.optional(z.record(z.string())),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Template Resource Argument Completion in MCP\nDESCRIPTION: Test that verifies resource template argument completion. The server provides completion suggestions for partial argument values in a resource template URI.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_34\n\nLANGUAGE: JavaScript\nCODE:\n```\ntest(\"completes template resource arguments\", async () => {\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      server.addResourceTemplate({\n        uriTemplate: \"issue:///{issueId}\",\n        name: \"Issue\",\n        mimeType: \"text/plain\",\n        arguments: [\n          {\n            name: \"issueId\",\n            description: \"ID of the issue\",\n            complete: async (value) => {\n              if (value === \"123\") {\n                return {\n                  values: [\"123456\"],\n                };\n              }\n\n              return {\n                values: [],\n              };\n            },\n          },\n        ],\n        load: async ({ issueId }) => {\n          return {\n            text: `Issue ${issueId}`,\n          };\n        },\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      const response = await client.complete({\n        ref: {\n          type: \"ref/resource\",\n          uri: \"issue:///{issueId}\",\n        },\n        argument: {\n          name: \"issueId\",\n          value: \"123\",\n        },\n      });\n\n      expect(response).toEqual({\n        completion: {\n          values: [\"123456\"],\n        },\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Inspecting Locally Developed MCP Servers in Bash\nDESCRIPTION: Shows how to use MCP Inspector with locally developed or downloaded servers, providing commands for both TypeScript and Python implementations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_58\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modelcontextprotocol/inspector node path/to/server/index.js args...\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modelcontextprotocol/inspector \\\n  uv \\\n  --directory path/to/server \\\n  run \\\n  package-name \\\n  args...\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Client SSE Transport for MCP Client in Java\nDESCRIPTION: Creates a framework-agnostic Server-Sent Events (SSE) client transport using Java's HttpClient. This transport is included in the core MCP module and provides a pure Java API approach for connecting to remote MCP servers.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_121\n\nLANGUAGE: java\nCODE:\n```\nMcpTransport transport = new HttpClientSseClientTransport(\"http://your-mcp-server\");\n```\n\n----------------------------------------\n\nTITLE: Implementing SSE Server Transport in TypeScript\nDESCRIPTION: Server-side implementation of Server-Sent Events (SSE) transport layer for JSON-RPC communication, handling connection establishment, message posting, and event streaming.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_151\n\nLANGUAGE: typescript\nCODE:\n```\nexport class SSEServerTransport implements Transport {\n  private _sseResponse?: ServerResponse;\n  private _sessionId: string;\n\n  constructor(\n    private _endpoint: string,\n    private res: ServerResponse,\n  ) {\n    this._sessionId = randomUUID();\n  }\n\n  async start(): Promise<void> {\n    if (this._sseResponse) {\n      throw new Error(\n        \"SSEServerTransport already started! If using Server class, note that connect() calls start() automatically.\",\n      );\n    }\n\n    this.res.writeHead(200, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      Connection: \"keep-alive\",\n    });\n\n    this.res.write(\n      `event: endpoint\\ndata: ${encodeURI(this._endpoint)}?sessionId=${this._sessionId}\\n\\n`,\n    );\n\n    this._sseResponse = this.res;\n    this.res.on(\"close\", () => {\n      this._sseResponse = undefined;\n      this.onclose?.();\n    });\n  }\n```\n\n----------------------------------------\n\nTITLE: Configuring Client Capabilities for MCP Client in Java\nDESCRIPTION: Configures client capabilities including roots support for filesystem access and sampling support for LLM interactions. These capabilities determine what features the client can use when communicating with MCP servers.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_123\n\nLANGUAGE: java\nCODE:\n```\nvar capabilities = ClientCapabilities.builder()\n    .roots(true)      // Enable filesystem roots support with list changes notifications\n    .sampling()       // Enable LLM sampling support\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Matching URIs Against Templates for Variable Extraction in TypeScript\nDESCRIPTION: This method matches a URI against the template pattern and extracts variables from the matching parts. It builds a regex pattern from the template parts and returns extracted values as a Variables object.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_189\n\nLANGUAGE: typescript\nCODE:\n```\n  match(uri: string): Variables | null {\n    UriTemplate.validateLength(uri, MAX_TEMPLATE_LENGTH, \"URI\");\n    let pattern = \"^\";\n    const names: Array<{ name: string; exploded: boolean }> = [];\n\n    for (const part of this.parts) {\n      if (typeof part === \"string\") {\n        pattern += this.escapeRegExp(part);\n      } else {\n        const patterns = this.partToRegExp(part);\n        for (const { pattern: partPattern, name } of patterns) {\n          pattern += partPattern;\n          names.push({ name, exploded: part.exploded });\n        }\n      }\n    }\n\n    pattern += \"$\";\n    UriTemplate.validateLength(\n      pattern,\n      MAX_REGEX_LENGTH,\n      \"Generated regex pattern\",\n    );\n    const regex = new RegExp(pattern);\n    const match = uri.match(regex);\n\n    if (!match) return null;\n\n    const result: Variables = {};\n    for (let i = 0; i < names.length; i++) {\n      const { name, exploded } = names[i];\n      const value = match[i + 1];\n      const cleanName = name.replace(\"*\", \"\");\n\n      if (exploded && value.includes(\",\")) {\n        result[cleanName] = value.split(\",\");\n      } else {\n        result[cleanName] = value;\n      }\n    }\n\n    return result;\n  }\n```\n\n----------------------------------------\n\nTITLE: Declaring Resources Capabilities in MCP\nDESCRIPTION: Example JSON showing how servers declare support for the resources capability with optional features like subscribe and listChanged.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_48\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"resources\": {\n      \"subscribe\": true,\n      \"listChanged\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing JSON-RPC Message Handling in SSE Transport\nDESCRIPTION: Tests the receiving and parsing of JSON-RPC messages through the SSE connection. Verifies that messages are correctly parsed and passed to the onmessage handler.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"receives and parses JSON-RPC messages\", async () => {\n  const receivedMessages: JSONRPCMessage[] = [];\n  transport = new SSEClientTransport(baseUrl);\n  transport.onmessage = (msg) => receivedMessages.push(msg);\n\n  await transport.start();\n\n  const testMessage: JSONRPCMessage = {\n    jsonrpc: \"2.0\",\n    id: \"test-1\",\n    method: \"test\",\n    params: { foo: \"bar\" },\n  };\n\n  sendServerMessage!(JSON.stringify(testMessage));\n\n  // Wait for message processing\n  await new Promise((resolve) => setTimeout(resolve, 50));\n\n  expect(receivedMessages).toHaveLength(1);\n  expect(receivedMessages[0]).toEqual(testMessage);\n});\n```\n\n----------------------------------------\n\nTITLE: Robust Project Root Resolution Algorithm in JavaScript\nDESCRIPTION: Implements a recursive algorithm to detect project root by searching for common project marker files like package.json, .git, or tasks.json. The function traverses up the directory tree until it finds a marker or reaches the filesystem root.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nfunction resolveProjectRoot(startDir) {\n  const projectMarkers = ['package.json', '.git', 'tasks.json'];\n  let currentDir = startDir;\n  while (currentDir !== path.parse(currentDir).root) {\n    if (projectMarkers.some(marker => fs.existsSync(path.join(currentDir, marker)))) {\n      return currentDir;\n    }\n    currentDir = path.dirname(currentDir);\n  }\n  return startDir; // Fallback to original directory\n}\n```\n\n----------------------------------------\n\nTITLE: Environment Setup Commands - MacOS/Linux and Windows\nDESCRIPTION: Shell commands for setting up the project directory, initializing npm, and installing required dependencies.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_71\n\nLANGUAGE: bash\nCODE:\n```\n# Create project directory\nmkdir mcp-client-typescript\ncd mcp-client-typescript\n\n# Initialize npm project\nnpm init -y\n\n# Install dependencies\nnpm install @anthropic-ai/sdk @modelcontextprotocol/sdk dotenv\n\n# Install dev dependencies\nnpm install -D @types/node typescript\n\n# Create source file\ntouch index.ts\n```\n\nLANGUAGE: powershell\nCODE:\n```\n# Create project directory\nmd mcp-client-typescript\ncd mcp-client-typescript\n\n# Initialize npm project\nnpm init -y\n\n# Install dependencies\nnpm install @anthropic-ai/sdk @modelcontextprotocol/sdk dotenv\n\n# Install dev dependencies\nnpm install -D @types/node typescript\n\n# Create source file\nnew-item index.ts\n```\n\n----------------------------------------\n\nTITLE: Testing JWT Token Expiration Verification in Express Middleware\nDESCRIPTION: Test case that verifies the middleware correctly rejects expired tokens. It creates an AuthInfo object with an expired timestamp and checks that the appropriate 401 error is returned.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_80\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should reject expired tokens\", async () => {\n  const expiredAuthInfo: AuthInfo = {\n    token: \"expired-token\",\n    clientId: \"client-123\",\n    scopes: [\"read\", \"write\"],\n    expiresAt: Math.floor(Date.now() / 1000) - 100, // Token expired 100 seconds ago\n  };\n  mockVerifyAccessToken.mockResolvedValue(expiredAuthInfo);\n\n  mockRequest.headers = {\n    authorization: \"Bearer expired-token\",\n  };\n\n  const middleware = requireBearerAuth({ provider: mockProvider });\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"expired-token\");\n  expect(mockResponse.status).toHaveBeenCalledWith(401);\n  expect(mockResponse.set).toHaveBeenCalledWith(\n    \"WWW-Authenticate\",\n    expect.stringContaining('Bearer error=\"invalid_token\"')\n  );\n  expect(mockResponse.json).toHaveBeenCalledWith(\n    expect.objectContaining({ error: \"invalid_token\", error_description: \"Token has expired\" })\n  );\n  expect(nextFunction).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining ResourceContents Interfaces in TypeScript\nDESCRIPTION: Defines interfaces for representing the contents of resources, including text and binary blob data.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_168\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ResourceContents {\n  uri: string;\n  mimeType?: string;\n}\n\nexport interface TextResourceContents extends ResourceContents {\n  text: string;\n}\n\nexport interface BlobResourceContents extends ResourceContents {\n  blob: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Token Refresh in SSE Client Transport\nDESCRIPTION: This test case verifies the token refresh mechanism in SSE Client Transport. It simulates an expired token scenario, expects a 401 response, and then checks if the transport successfully refreshes the token and establishes a connection.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_31\n\nLANGUAGE: javascript\nCODE:\n```\nit(\"refreshes expired token during SSE connection\", async () => {\n  // Mock tokens() to return expired token until saveTokens is called\n  let currentTokens: OAuthTokens = {\n    access_token: \"expired-token\",\n    token_type: \"Bearer\",\n    refresh_token: \"refresh-token\"\n  };\n  mockAuthProvider.tokens.mockImplementation(() => currentTokens);\n  mockAuthProvider.saveTokens.mockImplementation((tokens) => {\n    currentTokens = tokens;\n  });\n\n  // Create server that returns 401 for expired token, then accepts new token\n  await server.close();\n\n  let connectionAttempts = 0;\n  server = createServer((req, res) => {\n    lastServerRequest = req;\n\n    if (req.url === \"/token\" && req.method === \"POST\") {\n      // Handle token refresh request\n      let body = \"\";\n      req.on(\"data\", chunk => { body += chunk; });\n      req.on(\"end\", () => {\n        const params = new URLSearchParams(body);\n        if (params.get(\"grant_type\") === \"refresh_token\" &&\n          params.get(\"refresh_token\") === \"refresh-token\" &&\n          params.get(\"client_id\") === \"test-client-id\" &&\n          params.get(\"client_secret\") === \"test-client-secret\") {\n          res.writeHead(200, { \"Content-Type\": \"application/json\" });\n          res.end(JSON.stringify({\n            access_token: \"new-token\",\n            token_type: \"Bearer\",\n            refresh_token: \"new-refresh-token\"\n          }));\n        } else {\n          res.writeHead(400).end();\n        }\n      });\n      return;\n    }\n\n    if (req.url !== \"/\") {\n      res.writeHead(404).end();\n      return;\n    }\n\n    const auth = req.headers.authorization;\n    if (auth === \"Bearer expired-token\") {\n      res.writeHead(401).end();\n      return;\n    }\n\n    if (auth === \"Bearer new-token\") {\n      res.writeHead(200, {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        Connection: \"keep-alive\",\n      });\n      res.write(\"event: endpoint\\n\");\n      res.write(`data: ${baseUrl.href}\\n\\n`);\n      connectionAttempts++;\n      return;\n    }\n\n    res.writeHead(401).end();\n  });\n\n  await new Promise<void>(resolve => {\n    server.listen(0, \"127.0.0.1\", () => {\n      const addr = server.address() as AddressInfo;\n      baseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n      resolve();\n    });\n  });\n\n  transport = new SSEClientTransport(baseUrl, {\n    authProvider: mockAuthProvider,\n  });\n\n  await transport.start();\n\n  expect(mockAuthProvider.saveTokens).toHaveBeenCalledWith({\n    access_token: \"new-token\",\n    token_type: \"Bearer\",\n    refresh_token: \"new-refresh-token\"\n  });\n  expect(connectionAttempts).toBe(1);\n  expect(lastServerRequest.headers.authorization).toBe(\"Bearer new-token\");\n});\n```\n\n----------------------------------------\n\nTITLE: Exporting Type Definitions in TypeScript\nDESCRIPTION: This code exports several TypeScript interface types from their respective modules. The exported types appear to be related to input prompts, server configuration, logging, and event handling for what seems to be a FastMCP system.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nexport type { InputPrompt, InputPromptArgument };\nexport type { ServerOptions, LoggingLevel };\nexport type { FastMCPEvents, FastMCPSessionEvents };\n```\n\n----------------------------------------\n\nTITLE: Declaring Prompts Capability in JSON\nDESCRIPTION: Demonstrates how servers declare support for prompts during initialization. The 'listChanged' property indicates whether the server will emit notifications when the list of available prompts changes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_40\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"prompts\": {\n      \"listChanged\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Resources Capability in MCP\nDESCRIPTION: Shows how to declare resources capability support with optional subscribe and listChanged features.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_127\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"resources\": {\n      \"subscribe\": true,\n      \"listChanged\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing MCP TypeScript SDK via npm\nDESCRIPTION: Command to install the MCP TypeScript SDK using npm package manager.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_226\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @modelcontextprotocol/sdk\n```\n\n----------------------------------------\n\nTITLE: Testing Tool Registration and Validation in McpServer with TypeScript\nDESCRIPTION: This snippet tests the registration of tools in McpServer, including zero-argument tools, tools with argument schemas, and tools with descriptions. It also tests argument validation for registered tools.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_117\n\nLANGUAGE: typescript\nCODE:\n```\ndescribe(\"tool()\", () => {\n  test(\"should register zero-argument tool\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\"test\", async () => ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/list\",\n      },\n      ListToolsResultSchema,\n    );\n\n    expect(result.tools).toHaveLength(1);\n    expect(result.tools[0].name).toBe(\"test\");\n    expect(result.tools[0].inputSchema).toEqual({\n      type: \"object\",\n    });\n  });\n\n  test(\"should register tool with args schema\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\n      \"test\",\n      {\n        name: z.string(),\n        value: z.number(),\n      },\n      async ({ name, value }) => ({\n        content: [\n          {\n            type: \"text\",\n            text: `${name}: ${value}`,\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/list\",\n      },\n      ListToolsResultSchema,\n    );\n\n    expect(result.tools).toHaveLength(1);\n    expect(result.tools[0].name).toBe(\"test\");\n    expect(result.tools[0].inputSchema).toMatchObject({\n      type: \"object\",\n      properties: {\n        name: { type: \"string\" },\n        value: { type: \"number\" },\n      },\n    });\n  });\n\n  test(\"should register tool with description\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\"test\", \"Test description\", async () => ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"tools/list\",\n      },\n      ListToolsResultSchema,\n    );\n\n    expect(result.tools).toHaveLength(1);\n    expect(result.tools[0].name).toBe(\"test\");\n    expect(result.tools[0].description).toBe(\"Test description\");\n  });\n\n  test(\"should validate tool args\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client(\n      {\n        name: \"test client\",\n        version: \"1.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      },\n    );\n\n    mcpServer.tool(\n      \"test\",\n      {\n        name: z.string(),\n        value: z.number(),\n      },\n      async ({ name, value }) => ({\n        content: [\n          {\n            type: \"text\",\n            text: `${name}: ${value}`,\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await expect(\n      client.request(\n        {\n          method: \"tools/call\",\n          params: {\n            name: \"test\",\n            arguments: {\n              name: \"test\",\n              value: \"not a number\",\n            },\n          },\n        },\n        CallToolResultSchema,\n      ),\n    ).rejects.toThrow(/Invalid arguments/);\n  });\n\n  test(\"should prevent duplicate tool registration\", () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    mcpServer.tool(\"test\", async () => ({\n      content: [\n        {\n          type: \"text\",\n```\n\n----------------------------------------\n\nTITLE: Testing Resource Template Listing in MCP Server\nDESCRIPTION: Test that verifies the ability to list available resource templates. The server registers a resource template and the client requests a list of available templates.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_35\n\nLANGUAGE: JavaScript\nCODE:\n```\ntest(\"lists resource templates\", async () => {\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      server.addResourceTemplate({\n        uriTemplate: \"file:///logs/{name}.log\",\n        name: \"Application Logs\",\n        mimeType: \"text/plain\",\n        arguments: [\n          {\n            name: \"name\",\n            description: \"Name of the log\",\n            required: true,\n          },\n        ],\n        load: async ({ name }) => {\n          return {\n            text: `Example log content for ${name}`,\n          };\n        },\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      expect(await client.listResourceTemplates()).toEqual({\n        resourceTemplates: [\n          {\n            name: \"Application Logs\",\n            uriTemplate: \"file:///logs/{name}.log\",\n          },\n        ],\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Task Data Model Schema Update\nDESCRIPTION: Defines the updated task data structure with parent-child relationship fields including parentId and subtasks array. This modification enables hierarchical task relationships.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_025.txt#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n{\n  parentId: String,  // Reference to parent task\n  subtasks: Array,   // Array of child task references\n  // ... existing task fields\n}\n```\n\n----------------------------------------\n\nTITLE: Completion Response in JSON\nDESCRIPTION: Example of a server response to a completion request, providing completion suggestions.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_107\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"completion\": {\n      \"values\": [\"python\", \"pytorch\", \"pyside\"],\n      \"total\": 10,\n      \"hasMore\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Processing in MCP Client\nDESCRIPTION: Core functionality for processing queries using Claude AI, handling tool calls, and managing the conversation flow between the AI and available tools.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_67\n\nLANGUAGE: python\nCODE:\n```\nasync def process_query(self, query: str) -> str:\n    \"\"\"Process a query using Claude and available tools\"\"\"\n    messages = [\n        {\n            \"role\": \"user\",\n            \"content\": query\n        }\n    ]\n\n    response = await self.session.list_tools()\n    available_tools = [{\n        \"name\": tool.name,\n        \"description\": tool.description,\n        \"input_schema\": tool.inputSchema\n    } for tool in response.tools]\n\n    # Initial Claude API call\n    response = self.anthropic.messages.create(\n        model=\"claude-3-5-sonnet-20241022\",\n        max_tokens=1000,\n        messages=messages,\n        tools=available_tools\n    )\n\n    # Process response and handle tool calls\n    final_text = []\n\n    assistant_message_content = []\n    for content in response.content:\n        if content.type == 'text':\n            final_text.append(content.text)\n            assistant_message_content.append(content)\n        elif content.type == 'tool_use':\n            tool_name = content.name\n            tool_args = content.input\n\n            # Execute tool call\n            result = await self.session.call_tool(tool_name, tool_args)\n            final_text.append(f\"[Calling tool {tool_name} with args {tool_args}]\")\n\n            assistant_message_content.append(content)\n            messages.append({\n                \"role\": \"assistant\",\n                \"content\": assistant_message_content\n            })\n            messages.append({\n                \"role\": \"user\",\n                \"content\": [\n                    {\n                        \"type\": \"tool_result\",\n                        \"tool_use_id\": content.id,\n                        \"content\": result.content\n                    }\n                ]\n            })\n\n            # Get next response from Claude\n            response = self.anthropic.messages.create(\n                model=\"claude-3-5-sonnet-20241022\",\n                max_tokens=1000,\n                messages=messages,\n                tools=available_tools\n            )\n\n            final_text.append(response.content[0].text)\n\n    return \"\\n\".join(final_text)\n```\n\n----------------------------------------\n\nTITLE: Listing and Selecting Next Tasks via Task Master AI - Bash\nDESCRIPTION: This snippet provides CLI commands for enumerating all tasks and querying the next task to work on. These commands use Task Master AI's logic to account for dependencies and prioritization. Outputs include lists of task metadata for use by agents or developers.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ntask-master list\n\ntask-master next\n```\n\n----------------------------------------\n\nTITLE: Exchanging OAuth Authorization Code for Tokens in TypeScript\nDESCRIPTION: Exchanges an authorization code for an access token using the token endpoint. Validates the server supports the required grant type, builds the token request with PKCE verifier, and parses the response into a structured token object.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Exchanges an authorization code for an access token with the given server.\n */\nexport async function exchangeAuthorization(\n  serverUrl: string | URL,\n  {\n    metadata,\n    clientInformation,\n    authorizationCode,\n    codeVerifier,\n  }: {\n    metadata?: OAuthMetadata;\n    clientInformation: OAuthClientInformation;\n    authorizationCode: string;\n    codeVerifier: string;\n  },\n): Promise<OAuthTokens> {\n  const grantType = \"authorization_code\";\n\n  let tokenUrl: URL;\n  if (metadata) {\n    tokenUrl = new URL(metadata.token_endpoint);\n\n    if (\n      metadata.grant_types_supported &&\n      !metadata.grant_types_supported.includes(grantType)\n    ) {\n      throw new Error(\n        `Incompatible auth server: does not support grant type ${grantType}`,\n      );\n    }\n  } else {\n    tokenUrl = new URL(\"/token\", serverUrl);\n  }\n\n  // Exchange code for tokens\n  const params = new URLSearchParams({\n    grant_type: grantType,\n    client_id: clientInformation.client_id,\n    code: authorizationCode,\n    code_verifier: codeVerifier,\n  });\n\n  if (clientInformation.client_secret) {\n    params.set(\"client_secret\", clientInformation.client_secret);\n  }\n\n  const response = await fetch(tokenUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n    body: params,\n  });\n\n  if (!response.ok) {\n    throw new Error(`Token exchange failed: HTTP ${response.status}`);\n  }\n\n  return OAuthTokensSchema.parse(await response.json());\n}\n```\n\n----------------------------------------\n\nTITLE: Roots Capability Declaration in JSON\nDESCRIPTION: JSON format for declaring support for the roots capability during initialization. The listChanged property indicates whether the client will send notifications when the list of roots changes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"roots\": {\n      \"listChanged\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Base JSON-RPC Notification Type\nDESCRIPTION: TypeScript interface definition for JSON-RPC notification messages without response requirement.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_83\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\";\n  method: string;\n  params?: {\n    [key: string]: unknown;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Authorization Header Format in Bearer Authentication\nDESCRIPTION: Test case that verifies the middleware correctly rejects malformed Authorization headers. It checks that a 401 error is returned when the header doesn't follow the 'Bearer TOKEN' format.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_85\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should return 401 when Authorization header format is invalid\", async () => {\n  mockRequest.headers = {\n    authorization: \"InvalidFormat\",\n  };\n\n  const middleware = requireBearerAuth({ provider: mockProvider });\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).not.toHaveBeenCalled();\n  expect(mockResponse.status).toHaveBeenCalledWith(401);\n  expect(mockResponse.set).toHaveBeenCalledWith(\n    \"WWW-Authenticate\",\n    expect.stringContaining('Bearer error=\"invalid_token\"')\n  );\n  expect(mockResponse.json).toHaveBeenCalledWith(\n    expect.objectContaining({\n      error: \"invalid_token\",\n      error_description: \"Invalid Authorization header format, expected 'Bearer TOKEN'\"\n    })\n  );\n  expect(nextFunction).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Logging Notification Interface\nDESCRIPTION: TypeScript interface for log message notifications sent from server to client. This follows a standard request-response pattern with severity levels and optional logger identification.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_157\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface LoggingMessageNotification extends Notification {\n  method: \"notifications/message\";\n  params: {\n    /**\n     * The severity of this log message.\n     */\n    level: LoggingLevel;\n    /**\n     * An optional name of the logger issuing this message.\n     */\n    logger?: string;\n    /**\n     * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.\n     */\n    data: unknown;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Duplicate Resource Registration Prevention\nDESCRIPTION: Verifies that McpServer prevents duplicate resource registration by attempting to register the same resource URI twice. The second registration attempt should throw an error indicating the resource is already registered.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_129\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mcpServer = new McpServer({\n  name: \"test server\",\n  version: \"1.0\",\n});\n\nmcpServer.resource(\"test\", \"test://resource\", async () => ({\n  contents: [\n    {\n      uri: \"test://resource\",\n      text: \"Test content\",\n    },\n  ],\n}));\n\nexpect(() => {\n  mcpServer.resource(\"test2\", \"test://resource\", async () => ({\n    contents: [\n      {\n        uri: \"test://resource\",\n        text: \"Test content 2\",\n      },\n    ],\n  }));\n}).toThrow(/already registered/);\n```\n\n----------------------------------------\n\nTITLE: Converting URI Template Parts to Regular Expressions for Matching\nDESCRIPTION: This method transforms URI template parts into regular expression patterns for matching URLs. It handles different operators like '?', '&', '+', '#', '.', and '/' with their unique pattern requirements.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_188\n\nLANGUAGE: typescript\nCODE:\n```\n  private partToRegExp(part: {\n    name: string;\n    operator: string;\n    names: string[];\n    exploded: boolean;\n  }): Array<{ pattern: string; name: string }> {\n    const patterns: Array<{ pattern: string; name: string }> = [];\n\n    // Validate variable name length for matching\n    for (const name of part.names) {\n      UriTemplate.validateLength(name, MAX_VARIABLE_LENGTH, \"Variable name\");\n    }\n\n    if (part.operator === \"?\" || part.operator === \"&\") {\n      for (let i = 0; i < part.names.length; i++) {\n        const name = part.names[i];\n        const prefix = i === 0 ? \"\\\\\" + part.operator : \"&\";\n        patterns.push({\n          pattern: prefix + this.escapeRegExp(name) + \"=([^&]+)\",\n          name,\n        });\n      }\n      return patterns;\n    }\n\n    let pattern: string;\n    const name = part.name;\n\n    switch (part.operator) {\n      case \"\":\n        pattern = part.exploded ? \"([^/]+(?:,[^/]+)*)\" : \"([^/,]+)\";\n        break;\n      case \"+\":\n      case \"#\":\n        pattern = \"(.+)\";\n        break;\n      case \".\":\n        pattern = \"\\\\.([^/,]+)\";\n        break;\n      case \"/\":\n        pattern = \"/\" + (part.exploded ? \"([^/]+(?:,[^/]+)*)\" : \"([^/,]+)\");\n        break;\n      default:\n        pattern = \"([^/]+)\";\n    }\n\n    patterns.push({ pattern, name });\n    return patterns;\n  }\n```\n\n----------------------------------------\n\nTITLE: Getting a Specific Prompt Request in JSON\nDESCRIPTION: Demonstrates the JSON-RPC request format for retrieving a specific prompt. It includes the prompt name and any required arguments.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_43\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"prompts/get\",\n  \"params\": {\n    \"name\": \"code_review\",\n    \"arguments\": {\n      \"code\": \"def hello():\\n    print('world')\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running MCP Server with stdio Transport\nDESCRIPTION: Example of setting up and running an MCP server using the stdio transport for command-line tools and direct integrations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_231\n\nLANGUAGE: typescript\nCODE:\n```\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n\nconst server = new McpServer({\n  name: \"example-server\",\n  version: \"1.0.0\"\n});\n\n// ... set up server resources, tools, and prompts ...\n\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Defining Ping Request Schema for Model Context Protocol\nDESCRIPTION: Schema for ping requests that can be issued by either client or server to check if the other party is still alive. The receiver must respond promptly or risk disconnection.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_197\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Ping */\n/**\n * A ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.\n */\nexport const PingRequestSchema = RequestSchema.extend({\n  method: z.literal(\"ping\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Requesting Completions in JSON\nDESCRIPTION: Example of a client sending a completion/complete request to get completion suggestions for a prompt argument.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_106\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"completion/complete\",\n  \"params\": {\n    \"ref\": {\n      \"type\": \"ref/prompt\",\n      \"name\": \"code_review\"\n    },\n    \"argument\": {\n      \"name\": \"language\",\n      \"value\": \"py\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WebMvc SSE Server Transport in Java\nDESCRIPTION: Configures a WebMvc-based Server-Sent Events (SSE) transport for MCP. It requires the 'mcp-spring-webmvc' dependency and implements the MCP HTTP with SSE transport specification, integrating with Spring WebMVC for traditional web applications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_140\n\nLANGUAGE: java\nCODE:\n```\n@Configuration\n@EnableWebMvc\nclass McpConfig {\n    @Bean\n    WebMvcSseServerTransport webMvcSseServerTransport(ObjectMapper mapper) {\n        return new WebMvcSseServerTransport(mapper, \"/mcp/message\");\n    }\n\n    @Bean\n    RouterFunction<ServerResponse> mcpRouterFunction(WebMvcSseServerTransport transport) {\n        return transport.getRouterFunction();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Filtered Completion of Resource Template Parameters\nDESCRIPTION: Tests that parameter completion for resource templates supports filtering based on user input. The test registers a resource template with a completion function that filters values based on a prefix and verifies the filtered results.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_135\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mcpServer = new McpServer({\n  name: \"test server\",\n  version: \"1.0\",\n});\n\nconst client = new Client(\n  {\n    name: \"test client\",\n    version: \"1.0\",\n  },\n  {\n    capabilities: {\n      resources: {},\n    },\n  },\n);\n\nmcpServer.resource(\n  \"test\",\n  new ResourceTemplate(\"test://resource/{category}\", {\n    list: undefined,\n    complete: {\n      category: (test: string) =>\n        [\"books\", \"movies\", \"music\"].filter((value) =>\n          value.startsWith(test),\n        ),\n    },\n  }),\n  async () => ({\n    contents: [\n      {\n        uri: \"test://resource/test\",\n        text: \"Test content\",\n      },\n    ],\n  }),\n);\n\nconst [clientTransport, serverTransport] =\n  InMemoryTransport.createLinkedPair();\n\nawait Promise.all([\n  client.connect(clientTransport),\n  mcpServer.server.connect(serverTransport),\n]);\n\nconst result = await client.request(\n  {\n    method: \"completion/complete\",\n    params: {\n      ref: {\n        type: \"ref/resource\",\n        uri: \"test://resource/{category}\",\n      },\n      argument: {\n        name: \"category\",\n        value: \"m\",\n      },\n    },\n  },\n  CompleteResultSchema,\n);\n\nexpect(result.completion.values).toEqual([\"movies\", \"music\"]);\nexpect(result.completion.total).toBe(2);\n```\n\n----------------------------------------\n\nTITLE: Implementing Prompt Argument Auto-completion\nDESCRIPTION: Shows how to add auto-completion functionality to prompt arguments using an async complete function.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_55\n\nLANGUAGE: javascript\nCODE:\n```\nserver.addPrompt({\n  name: \"countryPoem\",\n  description: \"Writes a poem about a country\",\n  load: async ({ name }) => {\n    return `Hello, ${name}!`;\n  },\n  arguments: [\n    {\n      name: \"name\",\n      description: \"Name of the country\",\n      required: true,\n      complete: async (value) => {\n        if (value === \"Germ\") {\n          return {\n            values: [\"Germany\"],\n          };\n        }\n\n        return {\n          values: [],\n        };\n      },\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Change Notification Schema\nDESCRIPTION: Schema for server notifications about changes to the resource list. This optional notification can be sent without prior subscription from the client to inform it that the available resources have changed.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_205\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * An optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.\n */\nexport const ResourceListChangedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/resources/list_changed\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Servers with Claude\nDESCRIPTION: This JSON configuration example shows how to set up multiple MCP servers (memory, filesystem, and github) for use with Claude. It includes command, arguments, and environment variable settings.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_61\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"memory\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-memory\"]\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n    },\n    \"github\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-github\"],\n      \"env\": {\n        \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"<YOUR_TOKEN>\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Package Path Resolution Using ESM Import Meta URL in JavaScript\nDESCRIPTION: Shows how to resolve package paths in ECMAScript modules using import.meta.url with the fileURLToPath utility. This technique allows for reliable package root detection regardless of installation method.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nimport { fileURLToPath } from 'url';\nimport path from 'path';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst packageRoot = path.resolve(__dirname, '..');\n```\n\n----------------------------------------\n\nTITLE: Testing Request Timeout Handling in MCP\nDESCRIPTION: Tests the client's handling of request timeouts. Creates a server with a delayed response and verifies that a client request with a zero timeout immediately fails with a RequestTimeout error.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should handle request timeout\", async () => {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        resources: {},\n      },\n    },\n  );\n\n  // Set up server with a delayed response\n  server.setRequestHandler(\n    ListResourcesRequestSchema,\n    async (_request, extra) => {\n      const timer = new Promise((resolve) => {\n        const timeout = setTimeout(resolve, 100);\n        extra.signal.addEventListener(\"abort\", () => clearTimeout(timeout));\n      });\n\n      await timer;\n      return {\n        resources: [],\n      };\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {},\n    },\n  );\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // Request with 0 msec timeout should fail immediately\n  await expect(\n    client.listResources(undefined, { timeout: 0 }),\n  ).rejects.toMatchObject({\n    code: ErrorCode.RequestTimeout,\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing MCP Session with Streamable HTTP Transport\nDESCRIPTION: Example of server response during initialization, including a session ID in the Mcp-Session-Id header.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_96\n\nLANGUAGE: http\nCODE:\n```\nHTTP/1.1 200 OK\nMcp-Session-Id: 1868a90c...\nContent-Type: application/json\n\n{\"jsonrpc\": \"2.0\", \"result\": {...}}\n```\n\n----------------------------------------\n\nTITLE: Progress Notification Format\nDESCRIPTION: JSON-RPC notification format for progress updates including token, progress value, total and message.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_79\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/progress\",\n  \"params\": {\n    \"progressToken\": \"abc123\",\n    \"progress\": 50,\n    \"total\": 100,\n    \"message\": \"Reticulating splines...\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Server Error Handling in Bearer Authentication\nDESCRIPTION: Test case that verifies the middleware correctly handles ServerError exceptions. It simulates a server-side error during token verification and checks that a 500 error response is returned.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_88\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should return 500 when a ServerError occurs\", async () => {\n  mockRequest.headers = {\n    authorization: \"Bearer valid-token\",\n  };\n\n  mockVerifyAccessToken.mockRejectedValue(new ServerError(\"Internal server issue\"));\n\n  const middleware = requireBearerAuth({ provider: mockProvider });\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n  expect(mockResponse.status).toHaveBeenCalledWith(500);\n  expect(mockResponse.json).toHaveBeenCalledWith(\n    expect.objectContaining({ error: \"server_error\", error_description: \"Internal server issue\" })\n  );\n  expect(nextFunction).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Resource-related Requests in TypeScript\nDESCRIPTION: Defines interfaces for listing resources and resource templates, extending the paginated request and result interfaces.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_146\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ListResourcesRequest extends PaginatedRequest {\n  method: \"resources/list\";\n}\n\nexport interface ListResourcesResult extends PaginatedResult {\n  resources: Resource[];\n}\n\nexport interface ListResourceTemplatesRequest extends PaginatedRequest {\n  method: \"resources/templates/list\";\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Enum-based Argument Completion in MCP Server\nDESCRIPTION: Test that verifies automatic argument completion when an enum list is provided. The server automatically filters and suggests values from the enum list that match the partial input.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_33\n\nLANGUAGE: JavaScript\nCODE:\n```\ntest(\"adds automatic prompt argument completion when enum is provided\", async () => {\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      server.addPrompt({\n        name: \"countryPoem\",\n        description: \"Writes a poem about a country\",\n        load: async ({ name }) => {\n          return `Hello, ${name}!`;\n        },\n        arguments: [\n          {\n            name: \"name\",\n            description: \"Name of the country\",\n            required: true,\n            enum: [\"Germany\", \"France\", \"Italy\"],\n          },\n        ],\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      const response = await client.complete({\n        ref: {\n          type: \"ref/prompt\",\n          name: \"countryPoem\",\n        },\n        argument: {\n          name: \"name\",\n          value: \"Germ\",\n        },\n      });\n\n      expect(response).toEqual({\n        completion: {\n          values: [\"Germany\"],\n          total: 1,\n        },\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Weather Server Test Setup\nDESCRIPTION: Sets up a weather server with type checking for handling weather-related requests and notifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_111\n\nLANGUAGE: typescript\nCODE:\n```\nweatherServer.setRequestHandler(GetWeatherRequestSchema, (request) => {\n  return {\n    temperature: 72,\n    conditions: \"sunny\",\n  };\n});\n\nweatherServer.setNotificationHandler(\n  WeatherForecastNotificationSchema,\n  (notification) => {\n    console.log(`Weather alert: ${notification.params.message}`);\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in TypeScript MCP Transport\nDESCRIPTION: Example of error handling implementation in a TypeScript MCP transport class. It shows how to handle errors during connection and message sending operations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nclass ExampleTransport implements Transport {\n  async start() {\n    try {\n      // Connection logic\n    } catch (error) {\n      this.onerror?.(new Error(`Failed to connect: ${error}`));\n      throw error;\n    }\n  }\n\n  async send(message: JSONRPCMessage) {\n    try {\n      // Sending logic\n    } catch (error) {\n      this.onerror?.(new Error(`Failed to send message: ${error}`));\n      throw error;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Server Transport Processing - TypeScript\nDESCRIPTION: Implementation of server-side transport processing including buffer handling and message processing.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_156\n\nLANGUAGE: typescript\nCODE:\n```\nprivate processReadBuffer() {\n  while (true) {\n    try {\n      const message = this._readBuffer.readMessage();\n      if (message === null) {\n        break;\n      }\n      this.onmessage?.(message);\n    } catch (error) {\n      this.onerror?.(error as Error);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Log Message Notification in JSON-RPC\nDESCRIPTION: Shows the format of a log message notification sent by the server. It includes the log level, logger name, and arbitrary JSON-serializable data.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_37\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/message\",\n  \"params\": {\n    \"level\": \"error\",\n    \"logger\": \"database\",\n    \"data\": {\n      \"error\": \"Connection failed\",\n      \"details\": {\n        \"host\": \"localhost\",\n        \"port\": 5432\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Session Root Management in MCP Client-Server Implementation\nDESCRIPTION: Test that verifies a session's ability to track roots and handle root change events. The client initializes with capabilities for tracking root changes and provides root information when requested.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_29\n\nLANGUAGE: JavaScript\nCODE:\n```\ntest(\"session knows about roots\", async () => {\n  await runWithTestServer({\n    client: async () => {\n      const client = new Client(\n        {\n          name: \"example-client\",\n          version: \"1.0.0\",\n        },\n        {\n          capabilities: {\n            roots: {\n              listChanged: true,\n            },\n          },\n        },\n      );\n\n      client.setRequestHandler(ListRootsRequestSchema, () => {\n        return {\n          roots: [\n            {\n              uri: \"file:///home/user/projects/frontend\",\n              name: \"Frontend Repository\",\n            },\n          ],\n        };\n      });\n\n      return client;\n    },\n    run: async ({ session }) => {\n      expect(session.roots).toEqual([\n        {\n          uri: \"file:///home/user/projects/frontend\",\n          name: \"Frontend Repository\",\n        },\n      ]);\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Root Change Notifications in MCP Session\nDESCRIPTION: Test that verifies a session properly listens to root changes from the client. When the client sends a roots list changed notification, the session updates its roots and emits a rootsChanged event.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_30\n\nLANGUAGE: JavaScript\nCODE:\n```\ntest(\"session listens to roots changes\", async () => {\n  let clientRoots: Root[] = [\n    {\n      uri: \"file:///home/user/projects/frontend\",\n      name: \"Frontend Repository\",\n    },\n  ];\n\n  await runWithTestServer({\n    client: async () => {\n      const client = new Client(\n        {\n          name: \"example-client\",\n          version: \"1.0.0\",\n        },\n        {\n          capabilities: {\n            roots: {\n              listChanged: true,\n            },\n          },\n        },\n      );\n\n      client.setRequestHandler(ListRootsRequestSchema, () => {\n        return {\n          roots: clientRoots,\n        };\n      });\n\n      return client;\n    },\n    run: async ({ session, client }) => {\n      expect(session.roots).toEqual([\n        {\n          uri: \"file:///home/user/projects/frontend\",\n          name: \"Frontend Repository\",\n        },\n      ]);\n\n      clientRoots.push({\n        uri: \"file:///home/user/projects/backend\",\n        name: \"Backend Repository\",\n      });\n\n      await client.sendRootsListChanged();\n\n      const onRootsChanged = vi.fn();\n\n      session.on(\"rootsChanged\", onRootsChanged);\n\n      await delay(100);\n\n      expect(session.roots).toEqual([\n        {\n          uri: \"file:///home/user/projects/frontend\",\n          name: \"Frontend Repository\",\n        },\n        {\n          uri: \"file:///home/user/projects/backend\",\n          name: \"Backend Repository\",\n        },\n      ]);\n\n      expect(onRootsChanged).toHaveBeenCalledTimes(1);\n      expect(onRootsChanged).toHaveBeenCalledWith({\n        roots: [\n          {\n            uri: \"file:///home/user/projects/frontend\",\n            name: \"Frontend Repository\",\n          },\n          {\n            uri: \"file:///home/user/projects/backend\",\n            name: \"Backend Repository\",\n          },\n        ],\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Completable Type Implementation\nDESCRIPTION: Implementation of a Zod type wrapper that adds autocompletion capabilities to schema types.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_107\n\nLANGUAGE: typescript\nCODE:\n```\nexport class Completable<T extends ZodTypeAny> extends ZodType<\n  T[\"_output\"],\n  CompletableDef<T>,\n  T[\"_input\"]\n> {\n  _parse(input: ParseInput): ParseReturnType<this[\"_output\"]> {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx,\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Interface Definitions in TypeScript\nDESCRIPTION: Interfaces for logging configuration and message handling, including severity levels and message formatting. Defines structures for log level settings and message notifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_173\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SetLevelRequest extends Request {\n  method: \"logging/setLevel\";\n  params: {\n    level: LoggingLevel;\n  };\n}\n\nexport interface LoggingMessageNotification extends Notification {\n  method: \"notifications/message\";\n  params: {\n    level: LoggingLevel;\n    logger?: string;\n    data: unknown;\n  };\n}\n\nexport type LoggingLevel =\n  | \"debug\"\n  | \"info\"\n  | \"notice\"\n  | \"warning\"\n  | \"error\"\n  | \"critical\"\n  | \"alert\"\n  | \"emergency\";\n```\n\n----------------------------------------\n\nTITLE: Defining Cancellation Notification in TypeScript\nDESCRIPTION: Defines the structure for a cancellation notification, which can be sent by either side to cancel a previously issued request. It includes the request ID to cancel and an optional reason.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_141\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface CancelledNotification extends Notification {\n  method: \"notifications/cancelled\";\n  params: {\n    requestId: RequestId;\n    reason?: string;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Utility Types for Flattening and Inferring Zod Schemas in TypeScript\nDESCRIPTION: These snippets define utility types for flattening complex types and inferring types from Zod schemas. They're used to create TypeScript types from the defined Zod schemas.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_224\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype Primitive = string | number | boolean | bigint | null | undefined;\ntype Flatten<T> = T extends Primitive\n  ? T\n  : T extends Array<infer U>\n  ? Array<Flatten<U>>\n  : T extends Set<infer U>\n  ? Set<Flatten<U>>\n  : T extends Map<infer K, infer V>\n  ? Map<Flatten<K>, Flatten<V>>\n  : T extends object\n  ? { [K in keyof T]: Flatten<T[K]> }\n  : T;\n\ntype Infer<Schema extends ZodTypeAny> = Flatten<z.infer<Schema>>;\n```\n\n----------------------------------------\n\nTITLE: Implementing Complete OAuth Server Provider in TypeScript\nDESCRIPTION: A mock OAuth server provider implementation with full functionality including client store, authorization, token exchange, verification, and revocation. This provider supports all standard OAuth endpoints and operations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_98\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst mockProvider: OAuthServerProvider = {\n  clientsStore: mockClientStore,\n\n  async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise<void> {\n    const redirectUrl = new URL(params.redirectUri);\n    redirectUrl.searchParams.set('code', 'mock_auth_code');\n    if (params.state) {\n      redirectUrl.searchParams.set('state', params.state);\n    }\n    res.redirect(302, redirectUrl.toString());\n  },\n\n  async challengeForAuthorizationCode(): Promise<string> {\n    return 'mock_challenge';\n  },\n\n  async exchangeAuthorizationCode(): Promise<OAuthTokens> {\n    return {\n      access_token: 'mock_access_token',\n      token_type: 'bearer',\n      expires_in: 3600,\n      refresh_token: 'mock_refresh_token'\n    };\n  },\n\n  async exchangeRefreshToken(): Promise<OAuthTokens> {\n    return {\n      access_token: 'new_mock_access_token',\n      token_type: 'bearer',\n      expires_in: 3600,\n      refresh_token: 'new_mock_refresh_token'\n    };\n  },\n\n  async verifyAccessToken(token: string): Promise<AuthInfo> {\n    if (token === 'valid_token') {\n      return {\n        token,\n        clientId: 'valid-client',\n        scopes: ['read', 'write'],\n        expiresAt: Date.now() / 1000 + 3600\n      };\n    }\n    throw new InvalidTokenError('Token is invalid or expired');\n  },\n\n  async revokeToken(_client: OAuthClientInformationFull, _request: OAuthTokenRevocationRequest): Promise<void> {\n    // Success - do nothing in mock\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Logging-Related Schemas\nDESCRIPTION: Defines schemas for setting logging levels and sending log messages between server and client. These schemas validate the structure of logging-related commands and notifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_213\n\nLANGUAGE: typescript\nCODE:\n```\n/* Logging */\n/**\n * The severity of a log message.\n */\nexport const LoggingLevelSchema = z.enum([\n  \"debug\",\n  \"info\",\n  \"notice\",\n  \"warning\",\n  \"error\",\n  \"critical\",\n  \"alert\",\n  \"emergency\",\n]);\n\n/**\n * A request from the client to the server, to enable or adjust logging.\n */\nexport const SetLevelRequestSchema = RequestSchema.extend({\n  method: z.literal(\"logging/setLevel\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.\n     */\n    level: LoggingLevelSchema,\n  }),\n});\n\n/**\n * Notification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.\n */\nexport const LoggingMessageNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/message\"),\n  params: BaseNotificationParamsSchema.extend({\n    /**\n     * The severity of this log message.\n     */\n    level: LoggingLevelSchema,\n    /**\n     * An optional name of the logger issuing this message.\n     */\n    logger: z.optional(z.string()),\n    /**\n     * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.\n     */\n    data: z.unknown(),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Protocol Message Flow Diagram\nDESCRIPTION: Mermaid sequence diagram illustrating the message flow between client and server. Shows the discovery phase with prompts/list, usage with prompts/get, and the optional change notification flow.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_121\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: Discovery\n    Client->>Server: prompts/list\n    Server-->>Client: List of prompts\n\n    Note over Client,Server: Usage\n    Client->>Server: prompts/get\n    Server-->>Client: Prompt content\n\n    opt listChanged\n      Note over Client,Server: Changes\n      Server--)Client: prompts/list_changed\n      Client->>Server: prompts/list\n      Server-->>Client: Updated prompts\n    end\n```\n\n----------------------------------------\n\nTITLE: Expanding Tasks Based on Complexity Report - task-master CLI - Bash\nDESCRIPTION: Demonstrates the expand command for generating subtasks and tailored prompts, using recommendations from a previously generated complexity report. The CLI prioritizes expansion by complexity and carries over research configuration when available. Users can override counts and prompts as needed. This workflow streamlines subtask expansion by making use of AI-generated suggestions and supporting explicit overrides for advanced customization.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n# Expand a task, using complexity report recommendations if available\\ntask-master expand --id=8\\n\\n# Expand all tasks, prioritizing by complexity score if a report exists\\ntask-master expand --all\\n\\n# Override recommendations with explicit values\\ntask-master expand --id=8 --num=5 --prompt=\\\"Custom prompt\\\"\n```\n\n----------------------------------------\n\nTITLE: Testing CORS Support for OAuth Token Endpoint\nDESCRIPTION: Test case for CORS support in the OAuth token endpoint. This test verifies that the token endpoint includes the necessary CORS headers in its responses for cross-origin requests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_74\n\nLANGUAGE: JavaScript\nCODE:\n```\ndescribe('CORS support', () => {\n  it('includes CORS headers in response', async () => {\n\n\n```\n\n----------------------------------------\n\nTITLE: Defining Progress Schema and Notification for Long-Running Requests\nDESCRIPTION: Schemas for tracking progress of long-running operations. The Progress schema tracks current progress and optional total, while the notification schema extends this with a progress token to associate with specific requests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_198\n\nLANGUAGE: TypeScript\nCODE:\n```\n/* Progress notifications */\nexport const ProgressSchema = z\n  .object({\n    /**\n     * The progress thus far. This should increase every time progress is made, even if the total is unknown.\n     */\n    progress: z.number(),\n    /**\n     * Total number of items to process (or total progress required), if known.\n     */\n    total: z.optional(z.number()),\n  })\n  .passthrough();\n\n/**\n * An out-of-band notification used to inform the receiver of a progress update for a long-running request.\n */\nexport const ProgressNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/progress\"),\n  params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({\n    /**\n     * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.\n     */\n    progressToken: ProgressTokenSchema,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Prompt Argument Validation Testing\nDESCRIPTION: Validates that prompt arguments are properly checked against schema definitions using Zod validation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_139\n\nLANGUAGE: typescript\nCODE:\n```\nmcpServer.prompt(\n  \"test\",\n  {\n    name: z.string(),\n    value: z.string().min(3),\n  },\n  async ({ name, value }) => ({\n    messages: [\n      {\n        role: \"assistant\",\n        content: {\n          type: \"text\",\n          text: `${name}: ${value}`,\n        },\n      },\n    ],\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Enum-based Prompt Auto-completion\nDESCRIPTION: Example of implementing auto-completion using a predefined enum array of values.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_56\n\nLANGUAGE: javascript\nCODE:\n```\nserver.addPrompt({\n  name: \"countryPoem\",\n  description: \"Writes a poem about a country\",\n  load: async ({ name }) => {\n    return `Hello, ${name}!`;\n  },\n  arguments: [\n    {\n      name: \"name\",\n      description: \"Name of the country\",\n      required: true,\n      enum: [\"Germany\", \"France\", \"Italy\"],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Base JSON-RPC Request Type\nDESCRIPTION: TypeScript interface definition for JSON-RPC request messages with required and optional fields.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_81\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\";\n  id: string | number;\n  method: string;\n  params?: {\n    [key: string]: unknown;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Testing UserError Handling in FastMCP\nDESCRIPTION: This test case verifies that FastMCP correctly handles UserError exceptions thrown by tools. It adds a tool that throws a UserError and checks if the client receives the error message in the expected format.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"handles UserError errors\", async () => {\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      server.addTool({\n        name: \"add\",\n        description: \"Add two numbers\",\n        parameters: z.object({\n          a: z.number(),\n          b: z.number(),\n        }),\n        execute: async () => {\n          throw new UserError(\"Something went wrong\");\n        },\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      expect(\n        await client.callTool({\n          name: \"add\",\n          arguments: {\n            a: 1,\n            b: 2,\n          },\n        }),\n      ).toEqual({\n        content: [{ type: \"text\", text: \"Something went wrong\" }],\n        isError: true,\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Creating updateTaskById Function in task-manager.js\nDESCRIPTION: Function to update a single task by ID with AI-driven refinement while preserving completed subtasks. Includes error handling and support for various update options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_034.txt#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction updateTaskById(taskId, options) {\n  // Find specific task by ID\n  const task = tasks.find(t => t.id === taskId);\n  \n  if (!task) {\n    throw new TaskNotFoundError(`Task with ID ${taskId} not found`);\n  }\n  \n  // Preserve completion status\n  const completedSubtasks = task.subtasks.filter(st => st.completed);\n  \n  // Update task using AI refinement\n  const updatedTask = await refineTaskWithAI(task, options);\n  \n  // Restore completion status\n  updatedTask.subtasks = mergeCompletedSubtasks(updatedTask.subtasks, completedSubtasks);\n  \n  return updatedTask;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Client with Specific Capabilities in TypeScript\nDESCRIPTION: This snippet shows the initialization of a FastMCP `Client` instance. Crucially, it defines specific client capabilities during instantiation, indicating that this client supports certain features related to 'roots', specifically `listChanged: true`.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = new Client(\n  {\n    name: \"example-client\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      roots: {\n        listChanged: true,\n      },\n    },\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Testing Server Notification Capability Enforcement\nDESCRIPTION: Tests that server notification capabilities are properly enforced. The server should be able to send notifications for capabilities it declares (logging and resource list changes) but should be prevented from sending notifications for capabilities it doesn't have (tool list changes).\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should respect server notification capabilities\", async () => {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        logging: {},\n        resources: {\n          listChanged: true,\n        },\n      },\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {},\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  // These should work because the server has the corresponding capabilities\n  await expect(\n    server.sendLoggingMessage({ level: \"info\", data: \"Test\" }),\n  ).resolves.not.toThrow();\n  await expect(server.sendResourceListChanged()).resolves.not.toThrow();\n\n  // This should throw because the server doesn't have the tools capability\n  await expect(server.sendToolListChanged()).rejects.toThrow(\n    \"Server does not support notifying of tool list changes\",\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Roots List Request in JSON-RPC 2.0\nDESCRIPTION: Example of a server request to retrieve the list of roots from a client, following the JSON-RPC 2.0 format with method 'roots/list'.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"roots/list\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Root Schema in TypeScript with Zod\nDESCRIPTION: This snippet defines a Zod schema for a root directory or file that the server can operate on. It includes a URI and an optional name.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_219\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const RootSchema = z\n  .object({\n    /**\n     * The URI identifying the root. This *must* start with file:// for now.\n     */\n    uri: z.string().startsWith(\"file://\"),\n    /**\n     * An optional name for the root.\n     */\n    name: z.optional(z.string()),\n  })\n  .passthrough();\n```\n\n----------------------------------------\n\nTITLE: Setting Up Handlers in FastMCP\nDESCRIPTION: These methods set up various handlers for the FastMCP instance, including error handling, logging, roots, and completions.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nprivate setupErrorHandling() {\n    this.#server.onerror = (error) => {\n      console.error(\"[MCP Error]\", error);\n    };\n  }\n\n  private setupCompleteHandlers() {\n    this.#server.setRequestHandler(CompleteRequestSchema, async (request) => {\n      if (request.params.ref.type === \"ref/prompt\") {\n        const prompt = this.#prompts.find(\n          (prompt) => prompt.name === request.params.ref.name,\n        );\n\n        if (!prompt) {\n          throw new UnexpectedStateError(\"Unknown prompt\", {\n            request,\n          });\n        }\n\n        if (!prompt.complete) {\n          throw new UnexpectedStateError(\"Prompt does not support completion\", {\n            request,\n          });\n        }\n\n        const completion = CompletionZodSchema.parse(\n          await prompt.complete(\n            request.params.argument.name,\n            request.params.argument.value,\n          ),\n        );\n\n        return {\n          completion,\n        };\n      }\n\n      if (request.params.ref.type === \"ref/resource\") {\n        const resource = this.#resourceTemplates.find(\n          (resource) => resource.uriTemplate === request.params.ref.uri,\n        );\n\n        if (!resource) {\n          throw new UnexpectedStateError(\"Unknown resource\", {\n            request,\n          });\n        }\n\n        if (!(\"uriTemplate\" in resource)) {\n          throw new UnexpectedStateError(\"Unexpected resource\");\n        }\n\n        if (!resource.complete) {\n          throw new UnexpectedStateError(\n            \"Resource does not support completion\",\n            {\n              request,\n            },\n          );\n        }\n\n        const completion = CompletionZodSchema.parse(\n          await resource.complete(\n            request.params.argument.name,\n            request.params.argument.value,\n          ),\n        );\n\n        return {\n          completion,\n        };\n      }\n\n      throw new UnexpectedStateError(\"Unexpected completion request\", {\n        request,\n      });\n    });\n  }\n\n  private setupRootsHandlers() {\n    this.#server.setNotificationHandler(\n      RootsListChangedNotificationSchema,\n      () => {\n        this.#server.listRoots().then((roots) => {\n          this.#roots = roots.roots;\n\n          this.emit(\"rootsChanged\", {\n            roots: roots.roots,\n          });\n        });\n      },\n    );\n  }\n\n  private setupLoggingHandlers() {\n    this.#server.setRequestHandler(SetLevelRequestSchema, (request) => {\n      this.#loggingLevel = request.params.level;\n\n      return {};\n    });\n  }\n```\n\n----------------------------------------\n\nTITLE: Implementing In-Memory Transport in TypeScript\nDESCRIPTION: Defines an InMemoryTransport class that implements the Transport interface for creating clients and servers that communicate within the same process. It includes methods for starting, closing, and sending messages.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_192\n\nLANGUAGE: typescript\nCODE:\n```\nexport class InMemoryTransport implements Transport {\n  private _otherTransport?: InMemoryTransport;\n  private _messageQueue: JSONRPCMessage[] = [];\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n  sessionId?: string;\n\n  static createLinkedPair(): [InMemoryTransport, InMemoryTransport] {\n    const clientTransport = new InMemoryTransport();\n    const serverTransport = new InMemoryTransport();\n    clientTransport._otherTransport = serverTransport;\n    serverTransport._otherTransport = clientTransport;\n    return [clientTransport, serverTransport];\n  }\n\n  async start(): Promise<void> {\n    while (this._messageQueue.length > 0) {\n      const message = this._messageQueue.shift();\n      if (message) {\n        this.onmessage?.(message);\n      }\n    }\n  }\n\n  async close(): Promise<void> {\n    const other = this._otherTransport;\n    this._otherTransport = undefined;\n    await other?.close();\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    if (!this._otherTransport) {\n      throw new Error(\"Not connected\");\n    }\n\n    if (this._otherTransport.onmessage) {\n      this._otherTransport.onmessage(message);\n    } else {\n      this._otherTransport._messageQueue.push(message);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Unknown Tool Error Handling in FastMCP\nDESCRIPTION: This test case verifies that FastMCP correctly handles attempts to call unknown tools. It tries to call a non-existent tool and checks if the client receives the appropriate McpError with MethodNotFound code.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"calling an unknown tool throws McpError with MethodNotFound code\", async () => {\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      try {\n        await client.callTool({\n          name: \"add\",\n          arguments: {\n            a: 1,\n            b: 2,\n          },\n        });\n      } catch (error) {\n        expect(error).toBeInstanceOf(McpError);\n\n        // @ts-expect-error - we know that error is an McpError\n        expect(error.code).toBe(ErrorCode.MethodNotFound);\n      }\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Defining SSE Client Transport Options Interface in TypeScript\nDESCRIPTION: Defines the configuration options interface for the SSE client transport, including OAuth provider, EventSource initialization, and request configuration options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Configuration options for the `SSEClientTransport`.\n */\nexport type SSEClientTransportOptions = {\n  /**\n   * An OAuth client provider to use for authentication.\n   * \n   * When an `authProvider` is specified and the SSE connection is started:\n   * 1. The connection is attempted with any existing access token from the `authProvider`.\n   * 2. If the access token has expired, the `authProvider` is used to refresh the token.\n   * 3. If token refresh fails or no access token exists, and auth is required, `OAuthClientProvider.redirectToAuthorization` is called, and an `UnauthorizedError` will be thrown from `connect`/`start`.\n   * \n   * After the user has finished authorizing via their user agent, and is redirected back to the MCP client application, call `SSEClientTransport.finishAuth` with the authorization code before retrying the connection.\n   * \n   * If an `authProvider` is not provided, and auth is required, an `UnauthorizedError` will be thrown.\n   * \n   * `UnauthorizedError` might also be thrown when sending any message over the SSE transport, indicating that the session has expired, and needs to be re-authed and reconnected.\n   */\n  authProvider?: OAuthClientProvider;\n\n  /**\n   * Customizes the initial SSE request to the server (the request that begins the stream).\n   * \n   * NOTE: Setting this property will prevent an `Authorization` header from\n   * being automatically attached to the SSE request, if an `authProvider` is\n   * also given. This can be worked around by setting the `Authorization` header\n   * manually.\n   */\n  eventSourceInit?: EventSourceInit;\n\n  /**\n   * Customizes recurring POST requests to the server.\n   */\n  requestInit?: RequestInit;\n};\n```\n\n----------------------------------------\n\nTITLE: Logging Message Flow in Mermaid\nDESCRIPTION: Sequence diagram showing the flow of logging messages between client and server, including log level configuration and message filtering based on severity level.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_111\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: Configure Logging\n    Client->>Server: logging/setLevel (info)\n    Server-->>Client: Empty Result\n\n    Note over Client,Server: Server Activity\n    Server--)Client: notifications/message (info)\n    Server--)Client: notifications/message (warning)\n    Server--)Client: notifications/message (error)\n\n    Note over Client,Server: Level Change\n    Client->>Server: logging/setLevel (error)\n    Server-->>Client: Empty Result\n    Note over Server: Only sends error level<br/>and above\n```\n\n----------------------------------------\n\nTITLE: Configuring Servlet SSE Server Transport in Java\nDESCRIPTION: Sets up a Servlet-based Server-Sent Events (SSE) transport for MCP. It can be used with any Servlet container and implements the MCP HTTP with SSE transport specification using the traditional Servlet API, providing asynchronous message handling and session management.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_141\n\nLANGUAGE: java\nCODE:\n```\n@Configuration\n@EnableWebMvc\npublic class McpServerConfig implements WebMvcConfigurer {\n\n    @Bean\n    public HttpServletSseServerTransport servletSseServerTransport() {\n        return new HttpServletSseServerTransport(new ObjectMapper(), \"/mcp/message\");\n    }\n\n    @Bean\n    public ServletRegistrationBean customServletBean(HttpServletSseServerTransport servlet) {\n        return new ServletRegistrationBean(servlet);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Progress Notification in TypeScript\nDESCRIPTION: Defines the structure for a progress notification, which is used to inform the receiver of a progress update for a long-running request.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_144\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface ProgressNotification extends Notification {\n  method: \"notifications/progress\";\n  params: {\n    progressToken: ProgressToken;\n    progress: number;\n    total?: number;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment Variables in Python with FastMCP\nDESCRIPTION: Demonstrates how to create a Config instance and retrieve environment variables from the mcp.json file in Python. The Config class automatically loads the configuration from the file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nconfig = Config()\nenv_var = config.env.get(\"VARIABLE_NAME\")\n```\n\n----------------------------------------\n\nTITLE: Base JSON-RPC Response Type\nDESCRIPTION: TypeScript interface definition for JSON-RPC response messages including both success and error cases.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_82\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\";\n  id: string | number;\n  result?: {\n    [key: string]: unknown;\n  }\n  error?: {\n    code: number;\n    message: string;\n    data?: unknown;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Context File Reading Utility Function\nDESCRIPTION: Utility function in utils.js for reading and validating context from files with error handling and size limits\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_026.txt#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst readContextFile = async (filePath) => {\n  try {\n    const content = await fs.readFile(filePath, 'utf8');\n    if (content.length > MAX_CONTEXT_SIZE) {\n      return content.substring(0, MAX_CONTEXT_SIZE);\n    }\n    return content;\n  } catch (err) {\n    throw new Error(`Failed to read context file: ${err.message}`);\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Cancellation Flow Example\nDESCRIPTION: JSON example showing the structure of a cancellation notification in the Model Context Protocol.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_73\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/cancelled\",\n  \"params\": {\n    \"requestId\": \"123\",\n    \"reason\": \"User requested cancellation\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Server in Claude Desktop\nDESCRIPTION: JSON configuration example for specifying an MCP server command with absolute path in Claude Desktop's claude_desktop_config.json file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_52\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"command\": \"npx\",\n  \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/Users/username/data\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Listing Prompts from FastMCP Client in TypeScript\nDESCRIPTION: This client-side test snippet first retrieves a specific prompt ('git-commit') using `client.getPrompt`, providing the required 'changes' argument. It asserts using `vitest`'s `expect` that the returned prompt message matches the expected structure and content generated by the server's `load` function. It then calls `client.listPrompts()` and asserts that the 'git-commit' prompt definition is correctly listed among the available prompts.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nexpect(\n  await client.getPrompt({\n    name: \"git-commit\",\n    arguments: {\n      changes: \"foo\",\n    },\n  }),\n).toEqual({\n  description: \"Generate a Git commit message\",\n  messages: [\n    {\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: \"Generate a concise but descriptive commit message for these changes:\\n\\nfoo\",\n      },\n    },\n  ],\n});\n\nexpect(await client.listPrompts()).toEqual({\n  prompts: [\n    {\n      name: \"git-commit\",\n      description: \"Generate a Git commit message\",\n      arguments: [\n        {\n          name: \"changes\",\n          description: \"Git diff or description of changes\",\n          required: true,\n        },\n      ],\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Prompts with Completion Support in FastMCP\nDESCRIPTION: This method adds prompts to the FastMCP instance, handling argument completions and enumerations using Fuse.js for fuzzy searching.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nprivate addPrompt(inputPrompt: InputPrompt) {\n    const completers: Record<string, ArgumentValueCompleter> = {};\n    const enums: Record<string, string[]> = {};\n\n    for (const argument of inputPrompt.arguments ?? []) {\n      if (argument.complete) {\n        completers[argument.name] = argument.complete;\n      }\n\n      if (argument.enum) {\n        enums[argument.name] = argument.enum;\n      }\n    }\n\n    const prompt = {\n      ...inputPrompt,\n      complete: async (name: string, value: string) => {\n        if (completers[name]) {\n          return await completers[name](value);\n        }\n\n        if (enums[name]) {\n          const fuse = new Fuse(enums[name], {\n            keys: [\"value\"],\n          });\n\n          const result = fuse.search(value);\n\n          return {\n            values: result.map((item) => item.item),\n            total: result.length,\n          };\n        }\n\n        return {\n          values: [],\n        };\n      },\n    };\n\n    this.#prompts.push(prompt);\n  }\n```\n\n----------------------------------------\n\nTITLE: Roots List Changed Notification in JSON-RPC 2.0\nDESCRIPTION: Example of a notification sent by clients when the list of roots changes, following the JSON-RPC 2.0 notification format with method 'notifications/roots/list_changed'.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/roots/list_changed\"\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Multiple Environment Variables in JavaScript with FastMCP\nDESCRIPTION: Shows how to access multiple environment variables from the mcp.json file in JavaScript, including setting default values for optional variables.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nconst dbUrl = config.env.get('DATABASE_URL');\nconst apiKey = config.env.get('API_KEY');\nconst debugMode = config.env.get('DEBUG_MODE', false); // With a default value\n```\n\n----------------------------------------\n\nTITLE: Testing ResourceTemplate Creation and Functionality in TypeScript\nDESCRIPTION: This snippet tests the creation and functionality of ResourceTemplate instances. It covers scenarios with string patterns, UriTemplates, and list callbacks.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_116\n\nLANGUAGE: typescript\nCODE:\n```\ndescribe(\"ResourceTemplate\", () => {\n  test(\"should create ResourceTemplate with string pattern\", () => {\n    const template = new ResourceTemplate(\"test://{category}/{id}\", {\n      list: undefined,\n    });\n    expect(template.uriTemplate.toString()).toBe(\"test://{category}/{id}\");\n    expect(template.listCallback).toBeUndefined();\n  });\n\n  test(\"should create ResourceTemplate with UriTemplate\", () => {\n    const uriTemplate = new UriTemplate(\"test://{category}/{id}\");\n    const template = new ResourceTemplate(uriTemplate, { list: undefined });\n    expect(template.uriTemplate).toBe(uriTemplate);\n    expect(template.listCallback).toBeUndefined();\n  });\n\n  test(\"should create ResourceTemplate with list callback\", async () => {\n    const list = jest.fn().mockResolvedValue({\n      resources: [{ name: \"Test\", uri: \"test://example\" }],\n    });\n\n    const template = new ResourceTemplate(\"test://{id}\", { list });\n    expect(template.listCallback).toBe(list);\n\n    const abortController = new AbortController();\n    const result = await template.listCallback?.({\n      signal: abortController.signal,\n    });\n    expect(result?.resources).toHaveLength(1);\n    expect(list).toHaveBeenCalled();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Updating a Single Task\nDESCRIPTION: Shows how to update a specific task with new information, including the option for research-backed updates using Perplexity AI.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Update a specific task with new information\nnode scripts/dev.js update-task --id=4 --prompt=\"Use JWT for authentication\"\n\n# With research-backed updates using Perplexity AI\nnode scripts/dev.js update-task --id=4 --prompt=\"Use JWT for authentication\" --research\n```\n\n----------------------------------------\n\nTITLE: Configuring WebFlux SSE Transport for MCP Client in Java\nDESCRIPTION: Creates a WebFlux-based Server-Sent Events (SSE) client transport. This approach requires the mcp-webflux-sse-transport dependency and is designed for applications using Spring WebFlux.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_122\n\nLANGUAGE: java\nCODE:\n```\nWebClient.Builder webClientBuilder = WebClient.builder()\n    .baseUrl(\"http://your-mcp-server\");\nMcpTransport transport = new WebFluxSseClientTransport(webClientBuilder);\n```\n\n----------------------------------------\n\nTITLE: Running MCP Inspector with Basic Command Syntax in Bash\nDESCRIPTION: Shows how to run the MCP Inspector directly through npx without requiring installation, with basic command syntax patterns.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_56\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modelcontextprotocol/inspector <command>\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modelcontextprotocol/inspector <command> <arg1> <arg2>\n```\n\n----------------------------------------\n\nTITLE: Testing URI Template Basic Operations\nDESCRIPTION: Test cases for basic URI template operations including empty variables, undefined variables, and special characters in variable names\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_183\n\nLANGUAGE: typescript\nCODE:\n```\ndescribe(\"edge cases\", () => {\n  it(\"should handle empty variables\", () => {\n    const template = new UriTemplate(\"{empty}\");\n    expect(template.expand({})).toBe(\"\");\n    expect(template.expand({ empty: \"\" })).toBe(\"\");\n  });\n\n  it(\"should handle undefined variables\", () => {\n    const template = new UriTemplate(\"{a}{b}{c}\");\n    expect(template.expand({ b: \"2\" })).toBe(\"2\");\n  });\n\n  it(\"should handle special characters in variable names\", () => {\n    const template = new UriTemplate(\"{$var_name}\");\n    expect(template.expand({ \"$var_name\": \"value\" })).toBe(\"value\");\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Getting a Specific Prompt Response in JSON\nDESCRIPTION: Shows the JSON-RPC response format for the prompts/get request. It includes the prompt description and a list of messages that form the prompt content.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_44\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"description\": \"Code review prompt\",\n    \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": {\n          \"type\": \"text\",\n          \"text\": \"Please review this Python code:\\ndef hello():\\n    print('world')\"\n        }\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Node.js MCP Client with TypeScript\nDESCRIPTION: Code snippet showing how to run the MCP client by building TypeScript code and executing it with a path to a server script. The client connects to the specified server, starts a chat loop, and performs cleanup on exit.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_78\n\nLANGUAGE: javascript\nCODE:\n```\nconsole.log(\"Usage: node index.ts <path_to_server_script>\");\nreturn;\n}\nconst mcpClient = new MCPClient();\ntry {\n  await mcpClient.connectToServer(process.argv[2]);\n  await mcpClient.chatLoop();\n} finally {\n  await mcpClient.cleanup();\n  process.exit(0);\n}\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Sending JSON-RPC Notifications\nDESCRIPTION: Sends a one-way JSON-RPC notification that doesn't expect a response after verifying notification capabilities.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_176\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Emits a notification, which is a one-way message that does not expect a response.\n */\nasync notification(notification: SendNotificationT): Promise<void> {\n  if (!this._transport) {\n    throw new Error(\"Not connected\");\n  }\n\n  this.assertNotificationCapability(notification.method);\n\n  const jsonrpcNotification: JSONRPCNotification = {\n    ...notification,\n    jsonrpc: \"2.0\",\n  };\n\n  await this._transport.send(jsonrpcNotification);\n}\n```\n\n----------------------------------------\n\nTITLE: Testing SSE Connection Establishment in TypeScript\nDESCRIPTION: Tests the establishment of an SSE connection using the SSEClientTransport class. Verifies that the correct headers are sent and the connection is made via GET request.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"establishes SSE connection and receives endpoint\", async () => {\n  transport = new SSEClientTransport(baseUrl);\n  await transport.start();\n\n  expect(lastServerRequest.headers.accept).toBe(\"text/event-stream\");\n  expect(lastServerRequest.method).toBe(\"GET\");\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Resource Template Parameter Completion\nDESCRIPTION: Tests the parameter completion functionality for resource templates. The test registers a resource with a template that has a completion function for the 'category' parameter and verifies that the correct completion values are returned.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_134\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mcpServer = new McpServer({\n  name: \"test server\",\n  version: \"1.0\",\n});\n\nconst client = new Client(\n  {\n    name: \"test client\",\n    version: \"1.0\",\n  },\n  {\n    capabilities: {\n      resources: {},\n    },\n  },\n);\n\nmcpServer.resource(\n  \"test\",\n  new ResourceTemplate(\"test://resource/{category}\", {\n    list: undefined,\n    complete: {\n      category: () => [\"books\", \"movies\", \"music\"],\n    },\n  }),\n  async () => ({\n    contents: [\n      {\n        uri: \"test://resource/test\",\n        text: \"Test content\",\n      },\n    ],\n  }),\n);\n\nconst [clientTransport, serverTransport] =\n  InMemoryTransport.createLinkedPair();\n\nawait Promise.all([\n  client.connect(clientTransport),\n  mcpServer.server.connect(serverTransport),\n]);\n\nconst result = await client.request(\n  {\n    method: \"completion/complete\",\n    params: {\n      ref: {\n        type: \"ref/resource\",\n        uri: \"test://resource/{category}\",\n      },\n      argument: {\n        name: \"category\",\n        value: \"\",\n      },\n    },\n  },\n  CompleteResultSchema,\n);\n\nexpect(result.completion.values).toEqual([\"books\", \"movies\", \"music\"]);\nexpect(result.completion.total).toBe(3);\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Weather Server in Claude for Desktop (Windows)\nDESCRIPTION: JSON configuration for adding the MCP weather server to Claude for Desktop on Windows. It specifies the command and arguments to run the Java-based server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_103\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"weather\": {\n      \"command\": \"node\",\n      \"args\": [\n          \"C:\\\\PATH\\\\TO\\\\PARENT\\\\FOLDER\\\\weather\\\\build\\\\index.js\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Specific Prompt Content via MCP 'prompts/get' in TypeScript/JSON\nDESCRIPTION: This code illustrates the JSON-RPC request format used by a client to retrieve the content (messages) of a specific, predefined prompt. The `method` is `\"prompts/get\"`, and the `params` object includes the `name` of the desired prompt and an `arguments` object containing key-value pairs for any required arguments defined in the prompt's structure.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// Request\n{\n  method: \"prompts/get\",\n  params: {\n    name: \"analyze-code\",\n    arguments: {\n      language: \"python\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-step Workflow Prompt Logic in TypeScript\nDESCRIPTION: This TypeScript snippet defines an object (`debugWorkflow`) representing a prompt that implements a multi-step conversational workflow. It includes a `name` and an asynchronous `getMessages` function. This function takes an input (e.g., an error string) and returns a predefined sequence of `user` and `assistant` messages, guiding the user through a debugging process.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst debugWorkflow = {\n  name: \"debug-error\",\n  async getMessages(error: string) {\n    return [\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: `Here's an error I'm seeing: ${error}`\n        }\n      },\n      {\n        role: \"assistant\",\n        content: {\n          type: \"text\",\n          text: \"I'll help analyze this error. What have you tried so far?\"\n        }\n      },\n      {\n        role: \"user\",\n        content: {\n          type: \"text\",\n          text: \"I've tried restarting the service, but the error persists.\"\n        }\n      }\n    ];\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Roots Not Supported Error in JSON-RPC 2.0\nDESCRIPTION: Example of an error response when the client does not support the roots capability, following the JSON-RPC 2.0 error format with code -32601 (Method not found).\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_24\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"error\": {\n    \"code\": -32601,\n    \"message\": \"Roots not supported\",\n    \"data\": {\n      \"reason\": \"Client does not have roots capability\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth 2.0 Scope Validation with Supertest\nDESCRIPTION: Test cases that verify the scope validation functionality of the OAuth authorization endpoint. These tests check if the server correctly validates requested scopes against registered client scopes and accepts valid scope subsets.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_55\n\nLANGUAGE: JavaScript\nCODE:\n```\ndescribe('Scope validation', () => {\n    it('validates requested scopes against client registered scopes', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256',\n          scope: 'profile email admin' // 'admin' not in client scopes\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.get('error')).toBe('invalid_scope');\n    });\n\n    it('accepts valid scopes subset', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256',\n          scope: 'profile' // subset of client scopes\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.has('code')).toBe(true);\n    });\n  });\n```\n\n----------------------------------------\n\nTITLE: Running Task Management Script Commands\nDESCRIPTION: Demonstrates how to execute various commands of the task management script, including parsing PRDs, listing tasks, updating tasks, and managing task statuses.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnode scripts/dev.js parse-prd\nnode scripts/dev.js list\nnode scripts/dev.js update\nnode scripts/dev.js generate\nnode scripts/dev.js set-status\nnode scripts/dev.js expand\nnode scripts/dev.js clear-subtasks\nnode scripts/dev.js next\nnode scripts/dev.js show\n```\n\n----------------------------------------\n\nTITLE: Visualizing Cancellation Race Condition (Mermaid) - Mermaid\nDESCRIPTION: A Mermaid sequence diagram illustrating timing and race condition considerations in the cancellation flow of in-progress requests. Depicts a JSON-RPC request, a cancellation attempt, and possible outcomes depending on server processing state. The diagram helps implementers plan robust cancellation strategies and UI feedback for asynchronous network scenarios. No inputs/outputs; Mermaid rendering required.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_3\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\\n   participant Client\\n   participant Server\\n\\n   Client->>Server: Request (ID: 123)\\n   Note over Server: Processing starts\\n   Client--)Server: notifications/cancelled (ID: 123)\\n   alt\\n      Note over Server: Processing may have<br/>completed before<br/>cancellation arrives\\n   else If not completed\\n      Note over Server: Stop processing\\n   end\n```\n\n----------------------------------------\n\nTITLE: Task Master List Commands\nDESCRIPTION: Commands for listing tasks with various filtering options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README-task-master.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# List all tasks\ntask-master list\n\n# List tasks with a specific status\ntask-master list --status=<status>\n\n# List tasks with subtasks\ntask-master list --with-subtasks\n\n# List tasks with a specific status and include subtasks\ntask-master list --status=<status> --with-subtasks\n```\n\n----------------------------------------\n\nTITLE: Testing Duplicate Resource Template Registration Prevention\nDESCRIPTION: Verifies that McpServer prevents duplicate resource template registration by attempting to register the same template pattern twice. The second registration attempt should throw an error.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_131\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mcpServer = new McpServer({\n  name: \"test server\",\n  version: \"1.0\",\n});\n\nmcpServer.resource(\n  \"test\",\n  new ResourceTemplate(\"test://resource/{id}\", { list: undefined }),\n  async () => ({\n    contents: [\n      {\n        uri: \"test://resource/123\",\n        text: \"Test content\",\n      },\n    ],\n  }),\n);\n\nexpect(() => {\n  mcpServer.resource(\n    \"test\",\n    new ResourceTemplate(\"test://resource/{id}\", { list: undefined }),\n    async () => ({\n      contents: [\n        {\n          uri: \"test://resource/123\",\n          text: \"Test content 2\",\n        },\n      ],\n    }),\n  );\n}).toThrow(/already registered/);\n```\n\n----------------------------------------\n\nTITLE: Paginated Response Format in JSON-RPC\nDESCRIPTION: Illustrates the response format for paginated results. It includes the current page of results and an optional nextCursor field for continuing pagination.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_38\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"123\",\n  \"result\": {\n    \"resources\": [...],\n    \"nextCursor\": \"eyJwYWdlIjogM30=\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing MCP Client in Java\nDESCRIPTION: Create an instance of the MCP client by specifying the server URL and optional configuration. This snippet demonstrates how to initialize the client with default settings.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_116\n\nLANGUAGE: java\nCODE:\n```\nimport io.modelcontextprotocol.client.MCPClient;\n\nMCPClient client = new MCPClient(\"http://localhost:3000\");\n```\n\n----------------------------------------\n\nTITLE: Custom Weather Schema Implementation\nDESCRIPTION: Demonstrates implementation of custom request/notification/result schemas for weather data using Zod schema validation\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_110\n\nLANGUAGE: typescript\nCODE:\n```\nconst GetWeatherRequestSchema = RequestSchema.extend({\n  method: z.literal(\"weather/get\"),\n  params: z.object({\n    city: z.string(),\n  }),\n});\n\nconst GetForecastRequestSchema = RequestSchema.extend({\n  method: z.literal(\"weather/forecast\"),\n  params: z.object({\n    city: z.string(),\n    days: z.number(),\n  }),\n});\n\nconst WeatherForecastNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"weather/alert\"),\n  params: z.object({\n    severity: z.enum([\"warning\", \"watch\"]),\n    message: z.string(),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Removing a Task Dependency using CLI (Bash)\nDESCRIPTION: This command removes an existing dependency relationship between two tasks. It requires the ID of the task (`--id`) and the ID of the task it depends on (`--depends-on`). The script automatically validates the removal request and updates task files.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n# Remove a dependency from a task\nnode scripts/dev.js remove-dependency --id=<id> --depends-on=<id>\n```\n\n----------------------------------------\n\nTITLE: Initializing HTTP Server for SSE Testing in TypeScript\nDESCRIPTION: Sets up an HTTP server to simulate SSE connections for testing. The server sends SSE headers, an initial endpoint event, and allows sending custom messages during tests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nserver = createServer((req, res) => {\n  lastServerRequest = req;\n\n  // Send SSE headers\n  res.writeHead(200, {\n    \"Content-Type\": \"text/event-stream\",\n    \"Cache-Control\": \"no-cache\",\n    Connection: \"keep-alive\",\n  });\n\n  // Send the endpoint event\n  res.write(\"event: endpoint\\n\");\n  res.write(`data: ${baseUrl.href}\\n\\n`);\n\n  // Store reference to send function for tests\n  sendServerMessage = (message: string) => {\n    res.write(`data: ${message}\\n\\n`);\n  };\n\n  // Handle request body for POST endpoints\n  if (req.method === \"POST\") {\n    let body = \"\";\n    req.on(\"data\", (chunk) => {\n      body += chunk;\n    });\n    req.on(\"end\", () => {\n      (req as IncomingMessage & { body: string }).body = body;\n      res.end();\n    });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Resource Read Error Handling\nDESCRIPTION: Tests that errors in resource handlers are properly propagated to clients. The resource handler throws an error, and the test verifies that the client receives and rejects with that error.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_132\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst mcpServer = new McpServer({\n  name: \"test server\",\n  version: \"1.0\",\n});\nconst client = new Client({\n  name: \"test client\",\n  version: \"1.0\",\n});\n\nmcpServer.resource(\"error-test\", \"test://error\", async () => {\n  throw new Error(\"Resource read failed\");\n});\n\nconst [clientTransport, serverTransport] =\n  InMemoryTransport.createLinkedPair();\n\nawait Promise.all([\n  client.connect(clientTransport),\n  mcpServer.server.connect(serverTransport),\n]);\n\nawait expect(\n  client.request(\n    {\n      method: \"resources/read\",\n      params: {\n        uri: \"test://error\",\n      },\n    },\n    ReadResourceResultSchema,\n  ),\n).rejects.toThrow(/Resource read failed/);\n```\n\n----------------------------------------\n\nTITLE: Executing Research Operations Using Perplexity Integration - JavaScript\nDESCRIPTION: Demonstrates invoking research-oriented AI operations that can dynamically select Perplexity or Claude clients based on runtime needs via getBestAvailableAIModel. Requires getPerplexityClientForMCP and getBestAvailableAIModel helpers from ai-client-utils. Handles model selection, progress reporting, and provides fallback logic if Perplexity is not chosen. Accepts research queries and returns AI-generated content or standardized errors.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/ai-client-utils-example.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// In your direct function:\nimport {\n\tgetPerplexityClientForMCP,\n\tgetBestAvailableAIModel\n} from '../utils/ai-client-utils.js';\n\nexport async function researchOperationDirect(args, log, context) {\n\ttry {\n\t\t// Get the best AI model for this operation based on needs\n\t\tconst { type, client } = await getBestAvailableAIModel(\n\t\t\tcontext.session,\n\t\t\t{ requiresResearch: true },\n\t\t\tlog\n\t\t);\n\n\t\t// Report which model we're using\n\t\tif (context.reportProgress) {\n\t\t\tawait context.reportProgress({\n\t\t\t\tprogress: 10,\n\t\t\t\tstatus: `Using ${type} model for research...`\n\t\t\t});\n\t\t}\n\n\t\t// Make API call based on the model type\n\t\tif (type === 'perplexity') {\n\t\t\t// Call Perplexity\n\t\t\tconst response = await client.chat.completions.create({\n\t\t\t\tmodel: context.session?.env?.PERPLEXITY_MODEL || 'sonar-medium-online',\n\t\t\t\tmessages: [{ role: 'user', content: args.researchQuery }],\n\t\t\t\ttemperature: 0.1\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tsuccess: true,\n\t\t\t\tdata: response.choices[0].message.content\n\t\t\t};\n\t\t} else {\n\t\t\t// Call Claude as fallback\n\t\t\t// (Implementation depends on specific needs)\n\t\t\t// ...\n\t\t}\n\t} catch (error) {\n\t\t// Handle errors\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\terror: {\n\t\t\t\tcode: 'RESEARCH_ERROR',\n\t\t\t\tmessage: error.message\n\t\t\t}\n\t\t};\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MCP Result Message Structure in TypeScript\nDESCRIPTION: TypeScript interface defining the structure of a successful MCP Result message, sent in response to a Request. It uses an index signature `[key: string]: unknown;` to allow for arbitrary key-value pairs representing the result data.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\ninterface Result {\n  [key: string]: unknown;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Resource and Prompt Management Methods\nDESCRIPTION: Class methods for managing resources, resource templates and prompts. Includes functionality for adding new items and setting up completers for arguments.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nprivate addResource(inputResource: Resource) {\n    this.#resources.push(inputResource);\n  }\n\n  private addResourceTemplate(inputResourceTemplate: InputResourceTemplate) {\n    const completers: Record<string, ArgumentValueCompleter> = {};\n\n    for (const argument of inputResourceTemplate.arguments ?? []) {\n      if (argument.complete) {\n        completers[argument.name] = argument.complete;\n      }\n    }\n\n    const resourceTemplate = {\n      ...inputResourceTemplate,\n      complete: async (name: string, value: string) => {\n        if (completers[name]) {\n          return await completers[name](value);\n        }\n\n        return {\n          values: [],\n        };\n      },\n    };\n\n    this.#resourceTemplates.push(resourceTemplate);\n  }\n```\n\n----------------------------------------\n\nTITLE: Language Model Generation Response in JSON\nDESCRIPTION: JSON response containing the generated message from the language model.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_27\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"role\": \"assistant\",\n    \"content\": {\n      \"type\": \"text\",\n      \"text\": \"The capital of France is Paris.\"\n    },\n    \"model\": \"claude-3-sonnet-20240307\",\n    \"stopReason\": \"endTurn\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Task Status\nDESCRIPTION: Demonstrates how to change the status of tasks and subtasks, including marking multiple tasks at once and handling dependencies.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Mark a task as done\nnode scripts/dev.js set-status --id=3 --status=done\n\n# Mark a task as pending\nnode scripts/dev.js set-status --id=4 --status=pending\n\n# Mark a specific subtask as done\nnode scripts/dev.js set-status --id=3.1 --status=done\n\n# Mark multiple tasks at once\nnode scripts/dev.js set-status --id=1,2,3 --status=done\n```\n\n----------------------------------------\n\nTITLE: Documenting Version 0.12.0 Changes in Markdown\nDESCRIPTION: Details minor changes and patch changes for version 0.12.0, including new features like npx command support and improvements to PRD parsing.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n## 0.12.0\n\n### Minor Changes\n\n- [#253](https://github.com/eyaltoledano/claude-task-master/pull/253) [`b2ccd60`](https://github.com/eyaltoledano/claude-task-master/commit/b2ccd605264e47a61451b4c012030ee29011bb40) Thanks [@Crunchyman-ralph](https://github.com/Crunchyman-ralph)! - Add `npx task-master-ai` that runs mcp instead of using `task-master-mcp``\n\n- [#267](https://github.com/eyaltoledano/claude-task-master/pull/267) [`c17d912`](https://github.com/eyaltoledano/claude-task-master/commit/c17d912237e6caaa2445e934fc48cd4841abf056) Thanks [@Crunchyman-ralph](https://github.com/Crunchyman-ralph)! - Improve PRD parsing prompt with structured analysis and clearer task generation guidelines. We are testing a new prompt - please provide feedback on your experience.\n\n### Patch Changes\n\n- [#243](https://github.com/eyaltoledano/claude-task-master/pull/243) [`454a1d9`](https://github.com/eyaltoledano/claude-task-master/commit/454a1d9d37439c702656eedc0702c2f7a4451517) Thanks [@Crunchyman-ralph](https://github.com/Crunchyman-ralph)! - - Fixes shebang issue not allowing task-master to run on certain windows operating systems\n\n  - Resolves #241 #211 #184 #193\n\n- [#268](https://github.com/eyaltoledano/claude-task-master/pull/268) [`3e872f8`](https://github.com/eyaltoledano/claude-task-master/commit/3e872f8afbb46cd3978f3852b858c233450b9f33) Thanks [@Crunchyman-ralph](https://github.com/Crunchyman-ralph)! - Fix remove-task command to handle multiple comma-separated task IDs\n\n- [#239](https://github.com/eyaltoledano/claude-task-master/pull/239) [`6599cb0`](https://github.com/eyaltoledano/claude-task-master/commit/6599cb0bf9eccecab528207836e9d45b8536e5c2) Thanks [@eyaltoledano](https://github.com/eyaltoledano)! - Updates the parameter descriptions for update, update-task and update-subtask to ensure the MCP server correctly reaches for the right update command based on what is being updated -- all tasks, one task, or a subtask.\n\n- [#272](https://github.com/eyaltoledano/claude-task-master/pull/272) [`3aee9bc`](https://github.com/eyaltoledano/claude-task-master/commit/3aee9bc840eb8f31230bd1b761ed156b261cabc4) Thanks [@Crunchyman-ralph](https://github.com/Crunchyman-ralph)! - Enhance the `parsePRD` to include `--append` flag. This flag allows users to append the parsed PRD to an existing file, making it easier to manage multiple PRD files without overwriting existing content.\n\n- [#264](https://github.com/eyaltoledano/claude-task-master/pull/264) [`ff8e75c`](https://github.com/eyaltoledano/claude-task-master/commit/ff8e75cded91fb677903040002626f7a82fd5f88) Thanks [@joedanz](https://github.com/joedanz)! - Add quotes around numeric env vars in mcp.json (Windsurf, etc.)\n\n- [#248](https://github.com/eyaltoledano/claude-task-master/pull/248) [`d99fa00`](https://github.com/eyaltoledano/claude-task-master/commit/d99fa00980fc61695195949b33dcda7781006f90) Thanks [@Crunchyman-ralph](https://github.com/Crunchyman-ralph)! - - Fix `task-master init` polluting codebase with new packages inside `package.json` and modifying project `README`\n\n  - Now only initializes with cursor rules, windsurf rules, mcp.json, scripts/example_prd.txt, .gitignore modifications, and `README-task-master.md`\n\n- [#266](https://github.com/eyaltoledano/claude-task-master/pull/266) [`41b979c`](https://github.com/eyaltoledano/claude-task-master/commit/41b979c23963483e54331015a86e7c5079f657e4) Thanks [@Crunchyman-ralph](https://github.com/Crunchyman-ralph)! - Fixed a bug that prevented the task-master from running in a Linux container\n\n- [#265](https://github.com/eyaltoledano/claude-task-master/pull/265) [`0eb16d5`](https://github.com/eyaltoledano/claude-task-master/commit/0eb16d5ecbb8402d1318ca9509e9d4087b27fb25) Thanks [@Crunchyman-ralph](https://github.com/Crunchyman-ralph)! - Remove the need for project name, description, and version. Since we no longer create a package.json for you\n```\n\n----------------------------------------\n\nTITLE: Testing Process Cleanup with Jest in TypeScript\nDESCRIPTION: A Jest test that verifies servers properly clean up resources after transport closure. The test creates a server instance with a StdioServerTransport, closes the transport, and ensures the process exits cleanly without hanging.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_53\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Server } from \"../server/index.js\";\nimport { StdioServerTransport } from \"../server/stdio.js\";\n\ndescribe(\"Process cleanup\", () => {\n  jest.setTimeout(5000); // 5 second timeout\n\n  it(\"should exit cleanly after closing transport\", async () => {\n    const server = new Server(\n      {\n        name: \"test-server\",\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {},\n      }\n    );\n\n    const transport = new StdioServerTransport();\n    await server.connect(transport);\n\n    // Close the transport\n    await transport.close();\n\n    // If we reach here without hanging, the test passes\n    // The test runner will fail if the process hangs\n    expect(true).toBe(true);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Escaping Regular Expression Special Characters in TypeScript\nDESCRIPTION: A utility method for escaping special characters in regular expressions to ensure they're treated as literal characters when used in pattern matching.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_187\n\nLANGUAGE: typescript\nCODE:\n```\n  private escapeRegExp(str: string): string {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  }\n```\n\n----------------------------------------\n\nTITLE: MCP Client Feature Support Matrix in Markdown\nDESCRIPTION: A markdown table showing feature support status across different MCP client applications. Uses checkmarks, crosses and warning symbols to indicate support levels for different MCP features.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Client                               | [Resources] | [Prompts] | [Tools] | [Sampling] | Roots | Notes                                                              |\n| ------------------------------------ | ----------- | --------- | ------- | ---------- | ----- | ------------------------------------------------------------------ |\n| [Claude Desktop App][Claude]         | ✅           | ✅         | ✅       | ❌          | ❌     | Full support for all MCP features                                  |\n```\n\n----------------------------------------\n\nTITLE: Defining Prompt Reference Schema in TypeScript with Zod\nDESCRIPTION: This snippet defines a Zod schema for a prompt reference, which includes a type and name. It's used to identify prompts within the MCP system.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_216\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const PromptReferenceSchema = z\n  .object({\n    type: z.literal(\"ref/prompt\"),\n    /**\n     * The name of the prompt or prompt template\n     */\n    name: z.string(),\n  })\n  .passthrough();\n```\n\n----------------------------------------\n\nTITLE: Defining Ping Request in TypeScript\nDESCRIPTION: Defines the structure for a ping request, which can be sent by either the server or the client to check if the other party is still alive.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_143\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PingRequest extends Request {\n  method: \"ping\";\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Packages and Setting Up MCP Server Instance\nDESCRIPTION: Imports necessary packages, defines constants, and creates an instance of the MCP server for the weather application.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_98\n\nLANGUAGE: typescript\nCODE:\n```\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { z } from \"zod\";\n\nconst NWS_API_BASE = \"https://api.weather.gov\";\nconst USER_AGENT = \"weather-app/1.0\";\n\n// Create server instance\nconst server = new McpServer({\n  name: \"weather\",\n  version: \"1.0.0\",\n});\n```\n\n----------------------------------------\n\nTITLE: Removing Subtasks via Node.js Script (Shell)\nDESCRIPTION: Illustrates shell commands for removing subtasks using the `scripts/dev.js` Node.js script. Covers removing a single subtask by ID (5.2), removing multiple subtasks specified by comma-separated IDs, converting a subtask (5.2) into a standalone task during removal, and removing a subtask while skipping the task file regeneration. Requires Node.js, the script, and existing subtasks corresponding to the IDs.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n# Remove a subtask\nnode scripts/dev.js remove-subtask --id=5.2\n\n# Remove multiple subtasks\nnode scripts/dev.js remove-subtask --id=5.2,5.3,5.4\n\n# Convert a subtask to a standalone task\nnode scripts/dev.js remove-subtask --id=5.2 --convert\n\n# Skip regenerating task files\nnode scripts/dev.js remove-subtask --id=5.2 --skip-generate\n```\n\n----------------------------------------\n\nTITLE: MCP JSON-RPC Message Format - Requests\nDESCRIPTION: Defines the structure of JSON-RPC 2.0 request messages used by MCP transports. The structure includes the JSON-RPC version, an ID, a method name, and optional parameters.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\",\n  id: number | string,\n  method: string,\n  params?: object\n}\n```\n\n----------------------------------------\n\nTITLE: Gradle Dependencies Configuration for MCP SDK\nDESCRIPTION: Gradle dependency configuration demonstrating how to include core MCP functionality and HTTP SSE transport implementations using Spring WebFlux and WebMVC.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_133\n\nLANGUAGE: groovy\nCODE:\n```\ndependencies {\n  implementation platform(\"io.modelcontextprotocol.sdk:mcp\")\n  //...\n}\n\n// Spring WebFlux-based SSE client and server transport\ndependencies {\n  implementation platform(\"io.modelcontextprotocol.sdk:mcp-spring-webflux\")\n}\n\n// Spring WebMVC-based SSE server transport\ndependencies {\n  implementation platform(\"io.modelcontextprotocol.sdk:mcp-spring-webmvc\")\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Tasks with Meta-Development Script\nDESCRIPTION: This snippet demonstrates how to use the 'update' command to modify existing tasks based on new information or implementation changes. It includes examples of updating specific tasks, all tasks, and using custom task files.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Update tasks starting from ID 4 with a new prompt\ntask-master update --from=4 --prompt=\"Refactor tasks from ID 4 onward to use Express instead of Fastify\"\n\n# Update all tasks (default from=1)\ntask-master update --prompt=\"Add authentication to all relevant tasks\"\n\n# Specify a different tasks file\ntask-master update --file=custom-tasks.json --from=5 --prompt=\"Change database from MongoDB to PostgreSQL\"\n```\n\n----------------------------------------\n\nTITLE: Defining PromptMessage and EmbeddedResource Interfaces in TypeScript\nDESCRIPTION: Defines interfaces for representing prompt messages and embedded resources within prompts or tool call results.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_170\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type Role = \"user\" | \"assistant\";\n\nexport interface PromptMessage {\n  role: Role;\n  content: TextContent | ImageContent | AudioContent | EmbeddedResource;\n}\n\nexport interface EmbeddedResource {\n  type: \"resource\";\n  resource: TextResourceContents | BlobResourceContents;\n  annotations?: Annotations;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MCP Protocol Layer Interface in TypeScript\nDESCRIPTION: TypeScript class definition for the `Protocol` layer in MCP. It outlines methods for setting request (`setRequestHandler`) and notification (`setNotificationHandler`) handlers, sending requests (`request`), and sending notifications (`notification`), defining the core communication interface.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```typescript\nclass Protocol<Request, Notification, Result> {\n    // Handle incoming requests\n    setRequestHandler<T>(schema: T, handler: (request: T, extra: RequestHandlerExtra) => Promise<Result>): void\n\n    // Handle incoming notifications\n    setNotificationHandler<T>(schema: T, handler: (notification: T) => Promise<void>): void\n\n    // Send requests and await responses\n    request<T>(request: Request, schema: T, options?: RequestOptions): Promise<T>\n\n    // Send one-way notifications\n    notification(notification: Notification): Promise<void>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a Resource That Loads Multiple Content Parts in TypeScript\nDESCRIPTION: Initializes a FastMCP server and adds a resource using `server.addResource`. This resource's asynchronous `load` function is designed to return an array of objects, each representing a part of the resource content (in this case, two parts with text 'a' and 'b').\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new FastMCP({\n  name: \"Test\",\n  version: \"1.0.0\",\n});\n\nserver.addResource({\n  uri: \"file:///logs/app.log\",\n  name: \"Application Logs\",\n  mimeType: \"text/plain\",\n  async load() {\n    return [\n      {\n        text: \"a\",\n      },\n      {\n        text: \"b\",\n      },\n    ];\n  },\n});\n\nreturn server;\n```\n\n----------------------------------------\n\nTITLE: Subscription-Only Resources Capability\nDESCRIPTION: JSON example showing how to declare resources capability with only subscription support enabled.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_50\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"resources\": {\n      \"subscribe\": true // Only subscriptions supported\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding Tasks using CLI (Bash)\nDESCRIPTION: These commands expand a specific task (`--id`) or all tasks (`--all`) into subtasks. If a complexity analysis report exists, it automatically uses the recommended subtask count and prompt unless overridden by `--num` or `--prompt`. When using `--all` with a report, tasks are prioritized by complexity.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n# Expand a task, using complexity report recommendations if available\nnode scripts/dev.js expand --id=8\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Expand all tasks, prioritizing by complexity score if a report exists\nnode scripts/dev.js expand --all\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Override recommendations with explicit values\nnode scripts/dev.js expand --id=8 --num=5 --prompt=\"Custom prompt\"\n```\n\n----------------------------------------\n\nTITLE: Notifying Root List Changes in MCP\nDESCRIPTION: JSON-RPC notification from client to server when the list of roots has changed.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_101\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/roots/list_changed\"\n}\n```\n\n----------------------------------------\n\nTITLE: OAuth Router Implementation with Express\nDESCRIPTION: Express router setup for OAuth endpoints including authorization, token, registration and revocation handlers with metadata support.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_104\n\nLANGUAGE: typescript\nCODE:\n```\nexport function mcpAuthRouter(options: AuthRouterOptions): RequestHandler {\n  const issuer = options.issuerUrl;\n\n  if (issuer.protocol !== \"https:\" && issuer.hostname !== \"localhost\" && issuer.hostname !== \"127.0.0.1\") {\n    throw new Error(\"Issuer URL must be HTTPS\");\n  }\n  if (issuer.hash) {\n    throw new Error(\"Issuer URL must not have a fragment\");\n  }\n  if (issuer.search) {\n    throw new Error(\"Issuer URL must not have a query string\");\n  }\n\n  const authorization_endpoint = \"/authorize\";\n  const token_endpoint = \"/token\";\n  const registration_endpoint = options.provider.clientsStore.registerClient ? \"/register\" : undefined;\n  const revocation_endpoint = options.provider.revokeToken ? \"/revoke\" : undefined;\n\n  const router = express.Router();\n\n  router.use(\n    authorization_endpoint,\n    authorizationHandler({ provider: options.provider, ...options.authorizationOptions })\n  );\n\n  return router;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PRD Parsing Prompt Template - Markdown\nDESCRIPTION: This Markdown code block provides a reusable AI prompt for transforming Product Requirements Documents (PRDs) into structured development task lists. It establishes the required format for task breakdowns, including title, description, dependencies, priority, implementation notes, and a test strategy. The template expects the consuming system or user to supply actual PRD content. This structure supports consistent, detailed task extraction using LLMs, and prescribes a logical order of implementation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/prd.txt#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n```\nYou are assisting with transforming a Product Requirements Document (PRD) into a structured set of development tasks.\n\nGiven the following PRD, create a comprehensive list of development tasks that would be needed to implement the described product.\n\nFor each task:\n1. Assign a short, descriptive title\n2. Write a concise description\n3. Identify dependencies (which tasks must be completed before this one)\n4. Assign a priority (high, medium, low)\n5. Include detailed implementation notes\n6. Describe a test strategy to verify completion\n\nStructure the tasks in a logical order of implementation.\n\nPRD:\n{prd_content}\n```\n```\n\n----------------------------------------\n\nTITLE: Transport Accessor and Connection Close Method\nDESCRIPTION: Provides access to the current transport and a method to close the connection.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_173\n\nLANGUAGE: typescript\nCODE:\n```\nget transport(): Transport | undefined {\n  return this._transport;\n}\n\n/**\n * Closes the connection.\n */\nasync close(): Promise<void> {\n  await this._transport?.close();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Completion Result Schema in TypeScript with Zod\nDESCRIPTION: This snippet defines a Zod schema for a completion result, extending the base ResultSchema. It includes completion values, total count, and a flag indicating if more results are available.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_218\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const CompleteResultSchema = ResultSchema.extend({\n  completion: z\n    .object({\n      /**\n       * An array of completion values. Must not exceed 100 items.\n       */\n      values: z.array(z.string()).max(100),\n      /**\n       * The total number of completion options available. This can exceed the number of values actually sent in the response.\n       */\n      total: z.optional(z.number().int()),\n      /**\n       * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.\n       */\n      hasMore: z.optional(z.boolean()),\n    })\n    .passthrough(),\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring Logging Capability in JSON\nDESCRIPTION: Shows how servers declare the logging capability in their capabilities object. This is required for servers that emit log message notifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_35\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"logging\": {}\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pagination Flow Sequence in Mermaid\nDESCRIPTION: Sequence diagram illustrating the flow of pagination between client and server, showing how clients can iterate through pages of results using cursors.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_114\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server\n\n    Client->>Server: List Request (no cursor)\n    loop Pagination Loop\n      Server-->>Client: Page of results + nextCursor\n      Client->>Server: List Request (with cursor)\n    end\n```\n\n----------------------------------------\n\nTITLE: Adding Subtasks via Node.js Script (Shell)\nDESCRIPTION: Demonstrates various shell commands to add subtasks using the `scripts/dev.js` Node.js script. Examples include creating a new subtask with title and description, converting an existing task (ID 8) into a subtask of parent 5, adding a subtask with dependencies on other subtasks (5.1, 5.2), and adding a subtask while skipping the task file regeneration step. Requires Node.js and the specified script.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n# Add a subtask to an existing task\nnode scripts/dev.js add-subtask --parent=5 --title=\"Implement login UI\" --description=\"Create login form\"\n\n# Convert an existing task to a subtask\nnode scripts/dev.js add-subtask --parent=5 --task-id=8\n\n# Add a subtask with dependencies\nnode scripts/dev.js add-subtask --parent=5 --title=\"Authentication middleware\" --dependencies=5.1,5.2\n\n# Skip regenerating task files\nnode scripts/dev.js add-subtask --parent=5 --title=\"Login API route\" --skip-generate\n```\n\n----------------------------------------\n\nTITLE: Defining the Task Model Schema - JSON\nDESCRIPTION: This snippet provides the structure for an individual task object as stored in the tasks.json file, detailing fields for status, dependencies, priority, description, details, test strategy, and subtasks. It requires valid JSON and is intended for use with Node.js or similar environments that can read/write JSON data. Each field must be populated according to its intended type and use, with subtasks forming an embedded array following a similar structure. Limitations include fixed enums for status and priority, and that the IDs must be unique within the dataset.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/prd.txt#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": 1,\n  \"title\": \"Task Title\",\n  \"description\": \"Brief task description\",\n  \"status\": \"pending|done|deferred\",\n  \"dependencies\": [0],\n  \"priority\": \"high|medium|low\",\n  \"details\": \"Detailed implementation instructions\",\n  \"testStrategy\": \"Verification approach details\",\n  \"subtasks\": [\n    {\n      \"id\": 1,\n      \"title\": \"Subtask Title\",\n      \"description\": \"Subtask description\",\n      \"status\": \"pending|done|deferred\",\n      \"dependencies\": [],\n      \"acceptanceCriteria\": \"Verification criteria\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PaginatedRequest and PaginatedResult Interfaces in TypeScript\nDESCRIPTION: Defines interfaces for paginated requests and results, including a cursor for pagination position.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_165\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport interface PaginatedRequest extends Request {\n  params?: {\n    cursor?: Cursor;\n  };\n}\n\nexport interface PaginatedResult extends Result {\n  nextCursor?: Cursor;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Log Level Request in JSON-RPC\nDESCRIPTION: JSON-RPC request for configuring the minimum log level. Clients may send this request to control logging verbosity.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_109\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"logging/setLevel\",\n  \"params\": {\n    \"level\": \"info\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Server Connect/Disconnect Events and Cleaning Up in TypeScript\nDESCRIPTION: This snippet, executed after a client connects and potentially disconnects, verifies the server's event handling. It introduces a delay, then asserts using `vitest`'s `expect` that the `onConnect` listener was called once and `onDisconnect` was not called yet. It checks that the server has one active session. It then closes the client connection (`client.close()`), waits again, and asserts that `onDisconnect` has now been called once. Finally, it stops the server (`server.stop()`).\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nawait delay(100);\n\nexpect(onConnect).toHaveBeenCalledTimes(1);\nexpect(onDisconnect).toHaveBeenCalledTimes(0);\n\nexpect(server.sessions).toEqual([expect.any(FastMCPSession)]);\n\nawait client.close();\n\nawait delay(100);\n\nexpect(onConnect).toHaveBeenCalledTimes(1);\nexpect(onDisconnect).toHaveBeenCalledTimes(1);\n\nawait server.stop();\n```\n\n----------------------------------------\n\nTITLE: Basic FastMCP Server Implementation\nDESCRIPTION: Simple example showing how to create a FastMCP server with a basic addition tool using TypeScript.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FastMCP } from \"fastmcp\";\nimport { z } from \"zod\";\n\nconst server = new FastMCP({\n  name: \"My Server\",\n  version: \"1.0.0\",\n});\n\nserver.addTool({\n  name: \"add\",\n  description: \"Add two numbers\",\n  parameters: z.object({\n    a: z.number(),\n    b: z.number(),\n  }),\n  execute: async (args) => {\n    return String(args.a + args.b);\n  },\n});\n\nserver.start({\n  transportType: \"stdio\",\n});\n```\n\n----------------------------------------\n\nTITLE: List Changed Notification in JSON-RPC Format\nDESCRIPTION: Notification format sent when the available tools have changed. Servers that declared the listChanged capability should send this notification to prompt clients to request an updated list of tools.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_64\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/tools/list_changed\"\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Maven Dependencies for Spring AI MCP Server\nDESCRIPTION: XML configuration for adding the necessary Maven dependencies to set up a Spring AI MCP server. It includes the spring-ai-mcp-server-spring-boot-starter and spring-web dependencies.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_104\n\nLANGUAGE: xml\nCODE:\n```\n<dependencies>\n      <dependency>\n          <groupId>org.springframework.ai</groupId>\n          <artifactId>spring-ai-mcp-server-spring-boot-starter</artifactId>\n      </dependency>\n\n      <dependency>\n          <groupId>org.springframework</groupId>\n          <artifactId>spring-web</artifactId>\n      </dependency>\n</dependencies>\n```\n\n----------------------------------------\n\nTITLE: Refactoring Task Listing to Support Direct Imports and Flexible Output - JavaScript\nDESCRIPTION: This snippet demonstrates the refactoring of the 'listTasks' function to enable direct in-process imports (replacing CLI-based task execution using 'child_process.spawnSync') and to support both CLI and JSON output formats via an 'outputFormat' parameter. Dependencies include Node.js and existing task data retrieval utilities. Key parameters are 'tasksPath' (input file path), 'statusFilter' (status criteria), 'withSubtasks' (boolean for subtask inclusion), and 'outputFormat' (output format, defaults to 'cli'). On success, it either returns filtered tasks (JSON mode) or performs CLI-specific output. On error, it throws a standardized object in JSON mode or prints and exits in CLI mode. Limitations include reliance on external data retrieval logic and legacy CLI behavior for backward compatibility.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction listTasks(tasksPath, statusFilter, withSubtasks = false, outputFormat = 'cli') {\n  try {\n    // Existing data retrieval logic\n    const filteredTasks = /* ... */;\n    \n    // Early return for JSON format\n    if (outputFormat === 'json') return filteredTasks;\n    \n    // Existing CLI output logic\n  } catch (error) {\n    if (outputFormat === 'json') {\n      throw {\n        code: 'TASK_LIST_ERROR',\n        message: error.message,\n        details: error.stack\n      };\n    } else {\n      console.error(error);\n      process.exit(1);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Listing Tasks with Meta-Development Script\nDESCRIPTION: This snippet shows various ways to use the 'list' command to view tasks and their statuses. It includes options for filtering by status and including subtasks in the listing.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# List all tasks\ntask-master list\n\n# List tasks with a specific status\ntask-master list --status=pending\n\n# List tasks and include their subtasks\ntask-master list --with-subtasks\n\n# List tasks with a specific status and include their subtasks\ntask-master list --status=pending --with-subtasks\n```\n\n----------------------------------------\n\nTITLE: Adding MCP Client Dependency in Maven\nDESCRIPTION: Add the MCP client dependency to your Maven project's pom.xml file. This snippet shows how to include the dependency with the specified version.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_115\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\n    <groupId>io.modelcontextprotocol</groupId>\n    <artifactId>mcp-client</artifactId>\n    <version>0.1.0</version>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Passing SessionID to Tool Callback\nDESCRIPTION: Tests that the sessionId is correctly passed to tool callbacks via the RequestHandlerExtra parameter. This confirms the tool can access session-specific context when handling requests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_120\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should pass sessionId to tool callback via RequestHandlerExtra\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client(\n      {\n        name: \"test client\",\n        version: \"1.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      },\n    );\n\n    let receivedSessionId: string | undefined;\n    mcpServer.tool(\"test-tool\", async (extra) => {\n      receivedSessionId = extra.sessionId;\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Test response\",\n          },\n        ],\n      };\n    });\n\n    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();\n    // Set a test sessionId on the server transport\n    serverTransport.sessionId = \"test-session-123\";\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await client.request(\n      {\n        method: \"tools/call\",\n        params: {\n          name: \"test-tool\",\n        },\n      },\n      CallToolResultSchema,\n    );\n\n    expect(receivedSessionId).toBe(\"test-session-123\");\n  });\n```\n\n----------------------------------------\n\nTITLE: Running the MCP Client\nDESCRIPTION: Command to run the MCP client, connecting it to either a Python or Node.js server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_70\n\nLANGUAGE: bash\nCODE:\n```\nuv run client.py path/to/server.py # python server\nuv run client.py path/to/build/index.js # node server\n```\n\n----------------------------------------\n\nTITLE: Project Directory Root Example in JSON\nDESCRIPTION: Example of a root definition for a project directory, including a file URI and display name, suitable for use in the roots/list response.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_22\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"uri\": \"file:///home/user/projects/myproject\",\n  \"name\": \"My Project\"\n}\n```\n\n----------------------------------------\n\nTITLE: Model Preferences with Hints in JSON\nDESCRIPTION: JSON structure for specifying model preferences including hints and priorities.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_30\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"hints\": [\n    { \"name\": \"claude-3-sonnet\" },\n    { \"name\": \"claude\" }\n  ],\n  \"costPriority\": 0.3,\n  \"speedPriority\": 0.8,\n  \"intelligencePriority\": 0.5\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing FastMCP Server and Adding Tool with Various Log Levels in TypeScript\nDESCRIPTION: Initializes a FastMCP server instance and adds an 'add' tool. The tool's `execute` function demonstrates logging at different levels (debug, error, info, warn) using the `log` object provided in the execution context. It logs messages with and without additional context data before returning the addition result.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new FastMCP({\n  name: \"Test\",\n  version: \"1.0.0\",\n});\n\nserver.addTool({\n  name: \"add\",\n  description: \"Add two numbers\",\n  parameters: z.object({\n    a: z.number(),\n    b: z.number(),\n  }),\n  execute: async (args, { log }) => {\n    log.debug(\"debug message\", {\n      foo: \"bar\",\n    });\n    log.error(\"error message\");\n    log.info(\"info message\");\n    log.warn(\"warn message\");\n\n    return String(args.a + args.b);\n  },\n});\n\nreturn server;\n```\n\n----------------------------------------\n\nTITLE: Showing Task and Subtask Details - task-master CLI - Bash\nDESCRIPTION: Provides commands to inspect details of a task or subtask using the show command. Supports both numeric and flag-based task referencing, subtask navigation, and custom task file selection. Outputs comprehensive details, including status, dependencies, implementation, test strategies, and parent/child relationships, to the terminal. Useful for both overview and fine-grained investigation of project tasks before and during implementation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n# Show details for a specific task\\ntask-master show 1\\n\\n# Alternative syntax with --id option\\ntask-master show --id=1\\n\\n# Show details for a subtask\\ntask-master show --id=1.2\\n\\n# Specify a different tasks file\\ntask-master show 3 --file=custom-tasks.json\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Tool Name Errors\nDESCRIPTION: Tests the behavior when a client requests a non-existent tool. This verifies that the server correctly rejects requests for tools that aren't registered with appropriate error messages.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_123\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should throw McpError for invalid tool name\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n\n    const client = new Client(\n      {\n        name: \"test client\",\n        version: \"1.0\",\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      },\n    );\n\n    mcpServer.tool(\"test-tool\", async () => ({\n      content: [\n        {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      ],\n    }));\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    await expect(\n      client.request(\n        {\n          method: \"tools/call\",\n          params: {\n            name: \"nonexistent-tool\",\n          },\n        },\n        CallToolResultSchema,\n      ),\n    ).rejects.toThrow(/Tool nonexistent-tool not found/);\n  });\n```\n\n----------------------------------------\n\nTITLE: Jest Test Mock for Client Protocol Version Initialization\nDESCRIPTION: A Jest test that mocks a transport layer to verify client initialization with matching protocol versions. It implements a mock transport.send function that responds to the initialize method with a valid server response.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should initialize with matching protocol version\", async () => {\n  const clientTransport: Transport = {\n    start: jest.fn().mockResolvedValue(undefined),\n    close: jest.fn().mockResolvedValue(undefined),\n    send: jest.fn().mockImplementation((message) => {\n      if (message.method === \"initialize\") {\n        clientTransport.onmessage?.({\n          jsonrpc: \"2.0\",\n          id: message.id,\n          result: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            serverInfo: {\n              name: \"test\",\n              version: \"1.0\",\n            },\n            instructions: \"test instructions\",\n          },\n        });\n      }\n      return Promise.resolve();\n    }),\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Client Capabilities Management\nDESCRIPTION: Validates server's handling of client capabilities, ensuring proper enforcement of capability restrictions and error handling\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_109\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should respect client capabilities\", async () => {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        prompts: {},\n        resources: {},\n        tools: {},\n        logging: {},\n      },\n      enforceStrictCapabilities: true,\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Server Capabilities Merging in TypeScript\nDESCRIPTION: Tests the mergeCapabilities function for correctly merging server capabilities objects. It ensures that nested properties are properly combined and that the structure of both objects is preserved in the merged result.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_160\n\nLANGUAGE: TypeScript\nCODE:\n```\nit(\"should merge server capabilities\", () => {\n  const base: ServerCapabilities = {\n    logging: {},\n    prompts: {\n      listChanged: true,\n    },\n  };\n\n  const additional: ServerCapabilities = {\n    resources: {\n      subscribe: true,\n    },\n    prompts: {\n      newProp: true,\n    },\n  };\n\n  const merged = mergeCapabilities(base, additional);\n  expect(merged).toEqual({\n    logging: {},\n    prompts: {\n      listChanged: true,\n      newProp: true,\n    },\n    resources: {\n      subscribe: true,\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: SSE Server Configuration\nDESCRIPTION: Example showing how to configure and start a FastMCP server with SSE (Server-Sent Events) support.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nserver.start({\n  transportType: \"sse\",\n  sse: {\n    endpoint: \"/sse\",\n    port: 8080,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Tool Execution Error Response in JSON-RPC Format\nDESCRIPTION: Example of a tool execution error response when a tool encounters a problem during execution. This uses the isError flag to indicate that the tool ran but failed with the specified error message.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_70\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 4,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Failed to fetch weather data: API rate limit exceeded\"\n      }\n    ],\n    \"isError\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Expanding Tasks with Subtasks\nDESCRIPTION: Shows various ways to break down tasks into subtasks, including options for specifying the number of subtasks, adding context, and using research-backed generation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Expand a specific task with 3 subtasks (default)\nnode scripts/dev.js expand --id=3\n\n# Expand a specific task with 5 subtasks\nnode scripts/dev.js expand --id=3 --num=5\n\n# Expand a task with additional context\nnode scripts/dev.js expand --id=3 --prompt=\"Focus on security aspects\"\n\n# Expand all pending tasks that don't have subtasks\nnode scripts/dev.js expand --all\n\n# Force regeneration of subtasks for all pending tasks\nnode scripts/dev.js expand --all --force\n\n# Use Perplexity AI for research-backed subtask generation\nnode scripts/dev.js expand --id=3 --research\n\n# Use Perplexity AI for research-backed generation on all pending tasks\nnode scripts/dev.js expand --all --research\n```\n\n----------------------------------------\n\nTITLE: Testing Unexpected Error Handling in Bearer Authentication\nDESCRIPTION: Test case that verifies the middleware correctly handles unexpected errors that don't fit into any specific OAuth error category. It checks that a 500 error response is returned with a generic server error message.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_90\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should return 500 when unexpected error occurs\", async () => {\n  mockRequest.headers = {\n    authorization: \"Bearer valid-token\",\n  };\n\n  mockVerifyAccessToken.mockRejectedValue(new Error(\"Unexpected error\"));\n\n  const middleware = requireBearerAuth({ provider: mockProvider });\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n  expect(mockResponse.status).toHaveBeenCalledWith(500);\n  expect(mockResponse.json).toHaveBeenCalledWith(\n    expect.objectContaining({ error: \"server_error\", error_description: \"Internal Server Error\" })\n  );\n  expect(nextFunction).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing MCP Client with SSE Transport in Python\nDESCRIPTION: Demonstrates how to set up an MCP client using Server-Sent Events (SSE) transport in Python. The code establishes a client session using streams from the sse_client context manager that connects to a server URL.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nasync with sse_client(\"http://localhost:8000/sse\") as streams:\n    async with ClientSession(streams[0], streams[1]) as session:\n        await session.initialize()\n```\n\n----------------------------------------\n\nTITLE: Configuring LLM Sampling Support in MCP Client in Java\nDESCRIPTION: Sets up LLM sampling support in the MCP client, which enables servers to request LLM interactions through the client. This approach allows servers to leverage AI capabilities without requiring direct API access while clients maintain control over model access.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_125\n\nLANGUAGE: java\nCODE:\n```\n// Configure sampling handler\nFunction<CreateMessageRequest, CreateMessageResult> samplingHandler = request -> {\n    // Sampling implementation that interfaces with LLM\n    return new CreateMessageResult(response);\n};\n\n// Create client with sampling support\nvar client = McpClient.sync(transport)\n    .capabilities(ClientCapabilities.builder()\n        .sampling()\n        .build())\n    .sampling(samplingHandler)\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Mocking OAuth Client Provider for SSE Client Transport Tests\nDESCRIPTION: This code sets up a mock OAuth Client Provider for testing authentication scenarios in SSE Client Transport. It defines mock implementations for various OAuth-related methods.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\nlet mockAuthProvider: jest.Mocked<OAuthClientProvider>;\n\nbeforeEach(() => {\n  mockAuthProvider = {\n    get redirectUrl() { return \"http://localhost/callback\"; },\n    get clientMetadata() { return { redirect_uris: [\"http://localhost/callback\"] }; },\n    clientInformation: jest.fn(() => ({ client_id: \"test-client-id\", client_secret: \"test-client-secret\" })),\n    tokens: jest.fn(),\n    saveTokens: jest.fn(),\n    redirectToAuthorization: jest.fn(),\n    saveCodeVerifier: jest.fn(),\n    codeVerifier: jest.fn(),\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting to Transport in JSON-RPC Protocol\nDESCRIPTION: Method to initialize a connection with a transport mechanism. It sets up message handling callbacks and starts the transport connection.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_166\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Attaches to the given transport, starts it, and starts listening for messages.\n *\n * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.\n */\nasync connect(transport: Transport): Promise<void> {\n  this._transport = transport;\n  this._transport.onclose = () => {\n    this._onclose();\n  };\n\n  this._transport.onerror = (error: Error) => {\n    this._onerror(error);\n  };\n\n  this._transport.onmessage = (message) => {\n    if (!(\"method\" in message)) {\n      this._onresponse(message);\n    } else if (\"id\" in message) {\n      this._onrequest(message);\n    } else {\n      this._onnotification(message);\n    }\n  };\n\n  await this._transport.start();\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Tool Addition in FastMCP\nDESCRIPTION: This test case verifies that tools can be added to the FastMCP server and are correctly listed when queried by the client. It adds an 'add' tool and checks if it's properly registered.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"adds tools\", async () => {\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      server.addTool({\n        name: \"add\",\n        description: \"Add two numbers\",\n        parameters: z.object({\n          a: z.number(),\n          b: z.number(),\n        }),\n        execute: async (args) => {\n          return String(args.a + args.b);\n        },\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      expect(await client.listTools()).toEqual({\n        tools: [\n          {\n            name: \"add\",\n            description: \"Add two numbers\",\n            inputSchema: {\n              additionalProperties: false,\n              $schema: \"http://json-schema.org/draft-07/schema#\",\n              type: \"object\",\n              properties: {\n                a: { type: \"number\" },\n                b: { type: \"number\" },\n              },\n              required: [\"a\", \"b\"],\n            },\n          },\n        ],\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Registering MCP Tools in JavaScript\nDESCRIPTION: Demonstrates how to register a newly created MCP tool implementation (like `registerNewFeatureTool` from `newFeature.js`) with the MCP server. This is typically done in a central file (`mcp-server/src/tools/index.js`) that calls the registration functions for all available tools.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/MCP_INTEGRATION.md#2025-04-23_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// In mcp-server/src/tools/index.js\nimport { registerNewFeatureTool } from './newFeature.js';\n\nexport function registerTaskMasterTools(server) {\n\t// ... existing registrations\n\tregisterNewFeatureTool(server);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring package.json for Weather MCP Server\nDESCRIPTION: Updates the package.json file to set the project type as a module, defines the entry point for the weather command, and adds a build script.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_96\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"module\",\n  \"bin\": {\n    \"weather\": \"./build/index.js\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc && chmod 755 build/index.js\"\n  },\n  \"files\": [\n    \"build\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON-RPC Protocol Version Negotiation Error\nDESCRIPTION: Example of a JSON-RPC error response for protocol version mismatch. This shows how the server responds when a client requests an unsupported protocol version, providing information about supported versions.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_94\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Unsupported protocol version\",\n    \"data\": {\n      \"supported\": [\"2024-11-05\"],\n      \"requested\": \"1.0.0\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Property Override in Capabilities Merging\nDESCRIPTION: Tests that the mergeCapabilities function correctly overrides existing properties with values from the additional object when the same property exists in both objects.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_161\n\nLANGUAGE: TypeScript\nCODE:\n```\nit(\"should override existing values with additional values\", () => {\n  const base: ServerCapabilities = {\n    prompts: {\n      listChanged: false,\n    },\n  };\n\n  const additional: ServerCapabilities = {\n    prompts: {\n      listChanged: true,\n    },\n  };\n\n  const merged = mergeCapabilities(base, additional);\n  expect(merged.prompts!.listChanged).toBe(true);\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Initialization Error in JSON-RPC 2.0\nDESCRIPTION: Example of an error response during protocol initialization when there's a version mismatch, following the JSON-RPC 2.0 specification format with error code -32602.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Unsupported protocol version\",\n    \"data\": {\n      \"supported\": [\"2024-11-05\"],\n      \"requested\": \"1.0.0\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Metadata Endpoint with Supertest\nDESCRIPTION: Test suite for the OAuth metadata endpoint. Tests verify that both full-featured and minimal routers correctly expose their capabilities through the well-known discovery endpoint, including supported endpoints and authentication methods.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_101\n\nLANGUAGE: TypeScript\nCODE:\n```\ndescribe('Metadata endpoint', () => {\n  let app: express.Express;\n\n  beforeEach(() => {\n    // Setup full-featured router\n    app = express();\n    const options: AuthRouterOptions = {\n      provider: mockProvider,\n      issuerUrl: new URL('https://auth.example.com'),\n      serviceDocumentationUrl: new URL('https://docs.example.com')\n    };\n    app.use(mcpAuthRouter(options));\n  });\n\n  it('returns complete metadata for full-featured router', async () => {\n    const response = await supertest(app)\n      .get('/.well-known/oauth-authorization-server');\n\n    expect(response.status).toBe(200);\n\n    // Verify essential fields\n    expect(response.body.issuer).toBe('https://auth.example.com/');\n    expect(response.body.authorization_endpoint).toBe('https://auth.example.com/authorize');\n    expect(response.body.token_endpoint).toBe('https://auth.example.com/token');\n    expect(response.body.registration_endpoint).toBe('https://auth.example.com/register');\n    expect(response.body.revocation_endpoint).toBe('https://auth.example.com/revoke');\n\n    // Verify supported features\n    expect(response.body.response_types_supported).toEqual(['code']);\n    expect(response.body.grant_types_supported).toEqual(['authorization_code', 'refresh_token']);\n    expect(response.body.code_challenge_methods_supported).toEqual(['S256']);\n    expect(response.body.token_endpoint_auth_methods_supported).toEqual(['client_secret_post']);\n    expect(response.body.revocation_endpoint_auth_methods_supported).toEqual(['client_secret_post']);\n\n    // Verify optional fields\n    expect(response.body.service_documentation).toBe('https://docs.example.com/');\n  });\n\n  it('returns minimal metadata for minimal router', async () => {\n    // Setup minimal router\n    const minimalApp = express();\n    const options: AuthRouterOptions = {\n      provider: mockProviderMinimal,\n      issuerUrl: new URL('https://auth.example.com')\n    };\n    minimalApp.use(mcpAuthRouter(options));\n\n    const response = await supertest(minimalApp)\n      .get('/.well-known/oauth-authorization-server');\n\n    expect(response.status).toBe(200);\n\n    // Verify essential endpoints\n    expect(response.body.issuer).toBe('https://auth.example.com/');\n    expect(response.body.authorization_endpoint).toBe('https://auth.example.com/authorize');\n    expect(response.body.token_endpoint).toBe('https://auth.example.com/token');\n\n    // Verify missing optional endpoints\n    expect(response.body.registration_endpoint).toBeUndefined();\n    expect(response.body.revocation_endpoint).toBeUndefined();\n    expect(response.body.revocation_endpoint_auth_methods_supported).toBeUndefined();\n    expect(response.body.service_documentation).toBeUndefined();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Client Capabilities Merging in TypeScript\nDESCRIPTION: Tests the mergeCapabilities function for correctly merging client capabilities objects. The test verifies that properties from both objects are combined correctly with properties from the additional object overriding those in the base object.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_159\n\nLANGUAGE: TypeScript\nCODE:\n```\nit(\"should merge client capabilities\", () => {\n  const base: ClientCapabilities = {\n    sampling: {},\n    roots: {\n      listChanged: true,\n    },\n  };\n\n  const additional: ClientCapabilities = {\n    experimental: {\n      feature: true,\n    },\n    roots: {\n      newProp: true,\n    },\n  };\n\n  const merged = mergeCapabilities(base, additional);\n  expect(merged).toEqual({\n    sampling: {},\n    roots: {\n      listChanged: true,\n      newProp: true,\n    },\n    experimental: {\n      feature: true,\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: SSE Client Connection Setup\nDESCRIPTION: Example demonstrating how to set up a client connection to a FastMCP SSE server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\n\nconst client = new Client(\n  {\n    name: \"example-client\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {},\n  },\n);\n\nconst transport = new SSEClientTransport(new URL(`http://localhost:8080/sse`));\n\nawait client.connect(transport);\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Roots in MCP\nDESCRIPTION: JSON example showing how multiple roots can be defined for different repositories.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_103\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"uri\": \"file:///home/user/repos/frontend\",\n    \"name\": \"Frontend Repository\"\n  },\n  {\n    \"uri\": \"file:///home/user/repos/backend\",\n    \"name\": \"Backend Repository\"\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Generating Individual Task Files from Task List - Bash\nDESCRIPTION: This bash command creates one file per task in the 'tasks/' directory based on the generated tasks.json. Each task (e.g., task_001.txt) allows for easier referencing of implementation or tracking progress. Run after PRD parsing and initial task generation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ntask-master generate\n```\n\n----------------------------------------\n\nTITLE: Security Requirements for Prompt Validation in Claude Task Master\nDESCRIPTION: A security directive emphasizing that implementations must carefully validate all prompt inputs and outputs to prevent injection attacks and unauthorized access to system resources.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_126\n\nLANGUAGE: markdown\nCODE:\n```\n## Security\n\nImplementations **MUST** carefully validate all prompt inputs and outputs to prevent\ninjection attacks or unauthorized access to resources.\n```\n\n----------------------------------------\n\nTITLE: Image Content Type Format\nDESCRIPTION: JSON format for including images in prompt messages. The image data must be base64-encoded and include a valid MIME type to enable multi-modal interactions.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_123\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"image\",\n  \"data\": \"base64-encoded-image-data\",\n  \"mimeType\": \"image/png\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing close method for SSEClientTransport in TypeScript\nDESCRIPTION: Implements the close method that terminates the SSE connection by aborting the controller, closing the event source, and triggering the onclose callback.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_42\n\nLANGUAGE: TypeScript\nCODE:\n```\n  async close(): Promise<void> {\n    this._abortController?.abort();\n    this._eventSource?.close();\n    this.onclose?.();\n  }\n```\n\n----------------------------------------\n\nTITLE: Dynamic Task Prioritization System\nDESCRIPTION: System for dynamically adjusting and propagating task priorities based on project progress and dependencies, with background process implementation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_014.txt#2025-04-23_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Handling Errors in JSON-RPC Protocol\nDESCRIPTION: Simple error handler that delegates to the protocol's error callback.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_168\n\nLANGUAGE: typescript\nCODE:\n```\nprivate _onerror(error: Error): void {\n  this.onerror?.(error);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Connecting the Second Client in Multi-Client Test (TypeScript)\nDESCRIPTION: Initializes a second FastMCP `Client` instance (`client2`) with the same metadata and capabilities as the first. It creates a new `SSEClientTransport` instance pointing to the same server SSE endpoint and connects this second client to the server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nconst client2 = new Client(\n  {\n    name: \"example-client\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {},\n  },\n);\n\nconst transport2 = new SSEClientTransport(\n  new URL(`http://localhost:${port}/sse`),\n);\n\nawait client2.connect(transport2);\n```\n\n----------------------------------------\n\nTITLE: Defining OAuth Registered Clients Store Interface in TypeScript\nDESCRIPTION: This interface defines methods for storing and retrieving OAuth client information. It includes functions for getting client details and optionally registering new clients.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_94\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface OAuthRegisteredClientsStore {\n  getClient(clientId: string): OAuthClientInformationFull | undefined | Promise<OAuthClientInformationFull | undefined>;\n\n  registerClient?(client: OAuthClientInformationFull): OAuthClientInformationFull | Promise<OAuthClientInformationFull>;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Strategy and Verification Steps\nDESCRIPTION: Comprehensive testing approach for verifying the correct implementation of the dual license structure across all project components.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_039.txt#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n1. File verification:\n   - Confirm the MIT license file has been removed\n   - Verify LICENSE.md exists and contains both BSL and Apache 2.0 license texts\n   - Confirm README.md includes the license section with clear explanation\n   - Verify CONTRIBUTING.md exists with proper contributor guidelines\n   - Check package.json for updated license field\n\n2. Content verification:\n   - Review LICENSE.md to ensure it properly describes the dual license structure with clear terms\n   - Verify README.md license section is concise yet complete\n   - Check that commercial rights are explicitly reserved for Ralph & Eyal in all relevant documents\n```\n\n----------------------------------------\n\nTITLE: Handling Roots Error in MCP\nDESCRIPTION: JSON-RPC error response when the client does not support the roots feature.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_104\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"error\": {\n    \"code\": -32601,\n    \"message\": \"Roots not supported\",\n    \"data\": {\n      \"reason\": \"Client does not have roots capability\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Initialized Notification Schema for Model Context Protocol\nDESCRIPTION: Schema for a notification sent from client to server after initialization is complete. Extends the base notification schema with a specific method identifier.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_196\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * This notification is sent from the client to the server after initialization has finished.\n */\nexport const InitializedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/initialized\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Gradle Dependencies for Spring AI MCP Server\nDESCRIPTION: Groovy configuration for adding the necessary Gradle dependencies to set up a Spring AI MCP server. It includes the spring-ai-mcp-server-spring-boot-starter and spring-web dependencies.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_105\n\nLANGUAGE: groovy\nCODE:\n```\ndependencies {\n  implementation platform(\"org.springframework.ai:spring-ai-mcp-server-spring-boot-starter\")\n  implementation platform(\"org.springframework:spring-web\")   \n}\n```\n\n----------------------------------------\n\nTITLE: Overriding AI Model Configuration for Custom Operations - JavaScript\nDESCRIPTION: Illustrates how to override model configuration (model, maxTokens, temperature) for a specific operation using getModelConfig. Shows merging session data with operation-scoped defaults for optimized AI behavior. The code is intended for use within a direct AI function and creates a config that can be directly provided to client API calls.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/ai-client-utils-example.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// In your direct function:\nimport { getModelConfig } from '../utils/ai-client-utils.js';\n\n// Using custom defaults for a specific operation\nconst operationDefaults = {\n\tmodel: 'claude-3-haiku-20240307', // Faster, smaller model\n\tmaxTokens: 1000, // Lower token limit\n\ttemperature: 0.2 // Lower temperature for more deterministic output\n};\n\n// Get model config with operation-specific defaults\nconst modelConfig = getModelConfig(context.session, operationDefaults);\n\n// Now use modelConfig in your API calls\nconst response = await client.messages.create({\n\tmodel: modelConfig.model,\n\tmax_tokens: modelConfig.maxTokens,\n\ttemperature: modelConfig.temperature\n\t// Other parameters...\n});\n```\n\n----------------------------------------\n\nTITLE: Resource Template Implementation\nDESCRIPTION: Example showing how to implement a resource template with argument auto-completion in FastMCP.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nserver.addResourceTemplate({\n  uriTemplate: \"file:///logs/{name}.log\",\n  name: \"Application Logs\",\n  mimeType: \"text/plain\",\n  arguments: [\n    {\n      name: \"name\",\n      description: \"Name of the log\",\n      required: true,\n      complete: async (value) => {\n        if (value === \"Example\") {\n          return {\n            values: [\"Example Log\"],\n          };\n        }\n        return {\n          values: [],\n        };\n      },\n    },\n  ],\n  async load({ name }) {\n    return {\n      text: `Example log content for ${name}`,\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Markdown Task Definition\nDESCRIPTION: Definition of a documentation task with dependencies, priority, and breakdown of required documentation components.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_018.txt#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Task ID: 18\n# Title: Create Comprehensive User Documentation\n# Status: done\n# Dependencies: 1, 3, 4, 5, 6, 7, 11, 12, 16\n# Priority: medium\n# Description: Develop complete user documentation including README, examples, and troubleshooting guides.\n```\n\n----------------------------------------\n\nTITLE: Demonstrating CLI Command Usage with Positional and Flag-based Arguments\nDESCRIPTION: Examples showing how the CLI commands should work with both positional and flag-based argument styles after implementation. These examples illustrate the desired equivalence between the two syntax styles.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_055.txt#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `task-master set-status 25 done` should be equivalent to `task-master set-status --id=25 --status=done`\n- `task-master add-task \"New task name\" \"Task description\"` should be equivalent to `task-master add-task --name=\"New task name\" --description=\"Task description\"`\n```\n\n----------------------------------------\n\nTITLE: Audio Content Type Format\nDESCRIPTION: JSON format for including audio in prompt messages. The audio data must be base64-encoded and include a valid MIME type to enable multi-modal interactions with audio context.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_124\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"audio\",\n  \"data\": \"base64-encoded-audio-data\",\n  \"mimeType\": \"audio/wav\"\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Multiple Client Sessions and Cleaning Up in TypeScript\nDESCRIPTION: After connecting two clients to the server, this snippet introduces a delay to allow connections to establish. It then uses `vitest`'s `expect` to assert that the `server.sessions` array contains exactly two session objects (using `expect.any(FastMCPSession)`). Finally, it stops the server using `server.stop()` for cleanup.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nawait delay(100);\n\nexpect(server.sessions).toEqual([\n  expect.any(FastMCPSession),\n  expect.any(FastMCPSession),\n]);\n\nawait server.stop();\n```\n\n----------------------------------------\n\nTITLE: Testing Basic OAuth Request Validation with Jest and Supertest\nDESCRIPTION: Test cases for basic request validation in the OAuth token endpoint. These tests verify proper HTTP method enforcement, required parameter validation, and unsupported grant type handling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_70\n\nLANGUAGE: JavaScript\nCODE:\n```\ndescribe('Basic request validation', () => {\n  it('requires POST method', async () => {\n    const response = await supertest(app)\n      .get('/token')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'authorization_code'\n      });\n\n    expect(response.status).toBe(405);\n    expect(response.headers.allow).toBe('POST');\n    expect(response.body).toEqual({\n      error: \"method_not_allowed\",\n      error_description: \"The method GET is not allowed for this endpoint\"\n    });\n  });\n\n  it('requires grant_type parameter', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret'\n        // Missing grant_type\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_request');\n  });\n\n  it('rejects unsupported grant types', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'password' // Unsupported grant type\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('unsupported_grant_type');\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Refresh Token Grant Flow with Jest and Supertest\nDESCRIPTION: Test cases for the OAuth refresh token grant flow. These tests verify parameter requirements, token validity checks, and successful token refresh operations, including scope handling for refresh token grants.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_73\n\nLANGUAGE: JavaScript\nCODE:\n```\ndescribe('Refresh token grant', () => {\n  it('requires refresh_token parameter', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'refresh_token'\n        // Missing refresh_token\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_request');\n  });\n\n  it('rejects invalid refresh tokens', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'refresh_token',\n        refresh_token: 'invalid_refresh_token'\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_grant');\n  });\n\n  it('returns new tokens for valid refresh token', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'refresh_token',\n        refresh_token: 'valid_refresh_token'\n      });\n\n    expect(response.status).toBe(200);\n    expect(response.body.access_token).toBe('new_mock_access_token');\n    expect(response.body.token_type).toBe('bearer');\n    expect(response.body.expires_in).toBe(3600);\n    expect(response.body.refresh_token).toBe('new_mock_refresh_token');\n  });\n\n  it('respects requested scopes on refresh', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'refresh_token',\n        refresh_token: 'valid_refresh_token',\n        scope: 'profile email'\n      });\n\n    expect(response.status).toBe(200);\n    expect(response.body.scope).toBe('profile email');\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Token with All Required Scopes in Bearer Authentication\nDESCRIPTION: Test case that verifies the middleware correctly accepts tokens with all required scopes. It checks that the request processing continues when the token contains all the scopes required by the middleware.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_83\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should accept token with all required scopes\", async () => {\n  const authInfo: AuthInfo = {\n    token: \"valid-token\",\n    clientId: \"client-123\",\n    scopes: [\"read\", \"write\", \"admin\"],\n  };\n  mockVerifyAccessToken.mockResolvedValue(authInfo);\n\n  mockRequest.headers = {\n    authorization: \"Bearer valid-token\",\n  };\n\n  const middleware = requireBearerAuth({\n    provider: mockProvider,\n    requiredScopes: [\"read\", \"write\"]\n  });\n\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n  expect(mockRequest.auth).toEqual(authInfo);\n  expect(nextFunction).toHaveBeenCalled();\n  expect(mockResponse.status).not.toHaveBeenCalled();\n  expect(mockResponse.json).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Multiple Environment Variables in Python with FastMCP\nDESCRIPTION: Shows how to access multiple environment variables from the mcp.json file in Python, including setting default values for optional variables.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndb_url = config.env.get(\"DATABASE_URL\")\napi_key = config.env.get(\"API_KEY\")\ndebug_mode = config.env.get(\"DEBUG_MODE\", False)  # With a default value\n```\n\n----------------------------------------\n\nTITLE: Testing List Return in FastMCP\nDESCRIPTION: This test case verifies that FastMCP can correctly handle and return list content from a tool. It adds a tool that returns a list of text items and checks if the client receives the correct list structure.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"returns a list\", async () => {\n  await runWithTestServer({\n    server: async () => {\n      const server = new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n      server.addTool({\n        name: \"add\",\n        description: \"Add two numbers\",\n        parameters: z.object({\n          a: z.number(),\n          b: z.number(),\n        }),\n        execute: async () => {\n          return {\n            content: [\n              { type: \"text\", text: \"a\" },\n              { type: \"text\", text: \"b\" },\n            ],\n          };\n        },\n      });\n\n      return server;\n    },\n    run: async ({ client }) => {\n      expect(\n        await client.callTool({\n          name: \"add\",\n          arguments: {\n            a: 1,\n            b: 2,\n          },\n        }),\n      ).toEqual({\n        content: [\n          { type: \"text\", text: \"a\" },\n          { type: \"text\", text: \"b\" },\n        ],\n      });\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuth Provider Mock Methods for Authorization in TypeScript\nDESCRIPTION: A collection of mock OAuth provider methods for authorization, token exchange, verification and revocation. These methods simulate successful and error responses for various OAuth authentication flows.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_68\n\nLANGUAGE: TypeScript\nCODE:\n```\nasync authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise<void> {\n  res.redirect('https://example.com/callback?code=mock_auth_code');\n},\n\nasync challengeForAuthorizationCode(client: OAuthClientInformationFull, authorizationCode: string): Promise<string> {\n  if (authorizationCode === 'valid_code') {\n    return 'mock_challenge';\n  } else if (authorizationCode === 'expired_code') {\n    throw new InvalidGrantError('The authorization code has expired');\n  }\n  throw new InvalidGrantError('The authorization code is invalid');\n},\n\nasync exchangeAuthorizationCode(client: OAuthClientInformationFull, authorizationCode: string): Promise<OAuthTokens> {\n  if (authorizationCode === 'valid_code') {\n    return {\n      access_token: 'mock_access_token',\n      token_type: 'bearer',\n      expires_in: 3600,\n      refresh_token: 'mock_refresh_token'\n    };\n  }\n  throw new InvalidGrantError('The authorization code is invalid or has expired');\n},\n\nasync exchangeRefreshToken(client: OAuthClientInformationFull, refreshToken: string, scopes?: string[]): Promise<OAuthTokens> {\n  if (refreshToken === 'valid_refresh_token') {\n    const response: OAuthTokens = {\n      access_token: 'new_mock_access_token',\n      token_type: 'bearer',\n      expires_in: 3600,\n      refresh_token: 'new_mock_refresh_token'\n    };\n\n    if (scopes) {\n      response.scope = scopes.join(' ');\n    }\n\n    return response;\n  }\n  throw new InvalidGrantError('The refresh token is invalid or has expired');\n},\n\nasync verifyAccessToken(token: string): Promise<AuthInfo> {\n  if (token === 'valid_token') {\n    return {\n      token,\n      clientId: 'valid-client',\n      scopes: ['read', 'write'],\n      expiresAt: Date.now() / 1000 + 3600\n    };\n  }\n  throw new InvalidTokenError('Token is invalid or expired');\n},\n\nasync revokeToken(_client: OAuthClientInformationFull, _request: OAuthTokenRevocationRequest): Promise<void> {\n  // Do nothing in mock\n}\n```\n\n----------------------------------------\n\nTITLE: Protocol Testing Implementation - TypeScript\nDESCRIPTION: Test suite for protocol handling including mock transport class, timeout behaviors, and progress notification tests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_155\n\nLANGUAGE: typescript\nCODE:\n```\nclass MockTransport implements Transport {\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: unknown) => void;\n\n  async start(): Promise<void> {}\n  async close(): Promise<void> {\n    this.onclose?.();\n  }\n  async send(_message: unknown): Promise<void> {}\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Roots Capability in MCP Initialization\nDESCRIPTION: JSON snippet showing how a client declares support for the roots feature during MCP initialization.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_98\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"roots\": {\n      \"listChanged\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Server Event Listeners\nDESCRIPTION: Demonstrates how to handle server connection and disconnection events.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\nserver.on(\"connect\", (event) => {\n  console.log(\"Client connected:\", event.session);\n});\n\nserver.on(\"disconnect\", (event) => {\n  console.log(\"Client disconnected:\", event.session);\n});\n```\n\n----------------------------------------\n\nTITLE: Spring Boot Configuration for MCP Client\nDESCRIPTION: YAML configuration for setting up a Spring AI MCP client with Anthropic integration, including timeout settings and stdio configuration options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_82\n\nLANGUAGE: yml\nCODE:\n```\nspring:\n  ai:\n    mcp:\n      client:\n        enabled: true\n        name: brave-search-client\n        version: 1.0.0\n        type: SYNC\n        request-timeout: 20s\n        stdio:\n          root-change-notification: true\n          servers-configuration: classpath:/mcp-servers-config.json\n    anthropic:\n      api-key: ${ANTHROPIC_API_KEY}\n```\n\n----------------------------------------\n\nTITLE: Reading a Multi-Part Resource from FastMCP Client and Verifying Content in TypeScript\nDESCRIPTION: This client-side test snippet calls `client.readResource()` for a resource known to return multiple content parts from its `load` function. It uses `vitest`'s `expect` to assert that the `contents` array in the response includes separate entries for each part ('a' and 'b'), each correctly associated with the original resource's URI, name, and MIME type.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nexpect(\n  await client.readResource({\n    uri: \"file:///logs/app.log\",\n  }),\n).toEqual({\n  contents: [\n    {\n      uri: \"file:///logs/app.log\",\n      name: \"Application Logs\",\n      text: \"a\",\n      mimeType: \"text/plain\",\n    },\n    {\n      uri: \"file:///logs/app.log\",\n      name: \"Application Logs\",\n      text: \"b\",\n      mimeType: \"text/plain\",\n    },\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Interactive Chat Interface for MCP Client\nDESCRIPTION: Methods for running an interactive chat loop and cleaning up resources, providing a command-line interface for user interaction.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_68\n\nLANGUAGE: python\nCODE:\n```\nasync def chat_loop(self):\n    \"\"\"Run an interactive chat loop\"\"\"\n    print(\"\\nMCP Client Started!\")\n    print(\"Type your queries or 'quit' to exit.\")\n\n    while True:\n        try:\n            query = input(\"\\nQuery: \").strip()\n\n            if query.lower() == 'quit':\n                break\n\n            response = await self.process_query(query)\n            print(\"\\n\" + response)\n\n        except Exception as e:\n            print(f\"\\nError: {str(e)}\")\n\nasync def cleanup(self):\n    \"\"\"Clean up resources\"\"\"\n    await self.exit_stack.aclose()\n```\n\n----------------------------------------\n\nTITLE: Single Task Update Commands in Task Master CLI\nDESCRIPTION: Commands for updating individual tasks with new information, including research-backed updates using Perplexity AI.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Update a single task by ID with new information\ntask-master update-task --id=<id> --prompt=\"<prompt>\"\n\n# Use research-backed updates with Perplexity AI\ntask-master update-task --id=<id> --prompt=\"<prompt>\" --research\n```\n\n----------------------------------------\n\nTITLE: Reference System Implementation Task Definition\nDESCRIPTION: Markdown specification for implementing a system to include and validate resource references within generated subtasks.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_010.txt#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n## 6. Implement Reference and Resource Inclusion [done]\n### Dependencies: 10.3, 10.5\n### Description: Create a system to include references to relevant libraries, tools, documentation, and other resources in generated subtasks. This should extract specific references from research results, validate their relevance, and format them as actionable links or citations within subtasks. Implement a verification step to ensure referenced resources are current and applicable.\n```\n\n----------------------------------------\n\nTITLE: Initializing MCP Client Class in Python\nDESCRIPTION: Basic structure of the MCPClient class including imports, initialization of session, and Anthropic client setup.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_65\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom typing import Optional\nfrom contextlib import AsyncExitStack\n\nfrom mcp import ClientSession, StdioServerParameters\nfrom mcp.client.stdio import stdio_client\n\nfrom anthropic import Anthropic\nfrom dotenv import load_dotenv\n\nload_dotenv()  # load environment variables from .env\n\nclass MCPClient:\n    def __init__(self):\n        # Initialize session and client objects\n        self.session: Optional[ClientSession] = None\n        self.exit_stack = AsyncExitStack()\n        self.anthropic = Anthropic()\n    # methods will go here\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuth Client Authentication Middleware in TypeScript\nDESCRIPTION: This function creates middleware to authenticate OAuth clients. It validates client credentials against a store, checks for expired secrets, and attaches the authenticated client to the request object.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_92\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport function authenticateClient({ clientsStore }: ClientAuthenticationMiddlewareOptions): RequestHandler {\n  return async (req, res, next) => {\n    try {\n      const result = ClientAuthenticatedRequestSchema.safeParse(req.body);\n      if (!result.success) {\n        throw new InvalidRequestError(String(result.error));\n      }\n\n      const { client_id, client_secret } = result.data;\n      const client = await clientsStore.getClient(client_id);\n      if (!client) {\n        throw new InvalidClientError(\"Invalid client_id\");\n      }\n\n      // If client has a secret, validate it\n      if (client.client_secret) {\n        // Check if client_secret is required but not provided\n        if (!client_secret) {\n          throw new InvalidClientError(\"Client secret is required\");\n        }\n\n        // Check if client_secret matches\n        if (client.client_secret !== client_secret) {\n          throw new InvalidClientError(\"Invalid client_secret\");\n        }\n\n        // Check if client_secret has expired\n        if (client.client_secret_expires_at && client.client_secret_expires_at < Math.floor(Date.now() / 1000)) {\n          throw new InvalidClientError(\"Client secret has expired\");\n        }\n      }\n\n      req.client = client;\n      next();\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400;\n        res.status(status).json(error.toResponseObject());\n      } else {\n        console.error(\"Unexpected error authenticating client:\", error);\n      }\n    }\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Setting and Verifying Client Logging Levels with Vitest in TypeScript\nDESCRIPTION: This test snippet, executed within `runWithTestServer`, interacts with the client instance to set logging levels. It first calls `client.setLoggingLevel('debug')` and asserts that the corresponding `session.loggingLevel` property is updated to 'debug'. It then repeats the process for the 'info' level, verifying the session state accordingly using `vitest`'s `expect`.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nawait client.setLoggingLevel(\"debug\");\n\nexpect(session.loggingLevel).toBe(\"debug\");\n\nawait client.setLoggingLevel(\"info\");\n\nexpect(session.loggingLevel).toBe(\"info\");\n```\n\n----------------------------------------\n\nTITLE: Enhanced Subtask Generation Task Definition\nDESCRIPTION: Markdown specification for extending subtask generation with research findings and technical details.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_010.txt#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n## 5. Enhance Subtask Generation with Technical Details [done]\n### Dependencies: 10.3, 10.4\n### Description: Extend the existing subtask generation functionality to incorporate research findings and produce more technically detailed subtasks. This includes modifying the Claude prompt templates to leverage the enriched context, implementing specific sections for technical approach, implementation notes, and potential challenges. Ensure generated subtasks include concrete technical details rather than generic steps.\n```\n\n----------------------------------------\n\nTITLE: Importing Config Class in JavaScript for FastMCP Environment Variables\nDESCRIPTION: Shows how to import the Config class from the fastmcp module in JavaScript to access environment variables defined in the mcp.json file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_21\n\nLANGUAGE: javascript\nCODE:\n```\nconst { Config } = require('fastmcp');\n```\n\n----------------------------------------\n\nTITLE: Common Task Master Commands\nDESCRIPTION: Bash commands demonstrating common Task Master operations such as initializing a project, parsing a PRD, listing tasks, showing the next task, and generating task files.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Initialize a new project\ntask-master init\n\n# Parse a PRD and generate tasks\ntask-master parse-prd your-prd.txt\n\n# List all tasks\ntask-master list\n\n# Show the next task to work on\ntask-master next\n\n# Generate task files\ntask-master generate\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Metadata Handler (TypeScript)\nDESCRIPTION: This test suite validates the OAuth metadata handler functionality, including HTTP method restrictions, metadata object response, CORS headers, and support for minimal metadata. It uses supertest to perform HTTP requests against an Express application.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_60\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { metadataHandler } from './metadata.js';\nimport { OAuthMetadata } from '../../../shared/auth.js';\nimport express from 'express';\nimport supertest from 'supertest';\n\ndescribe('Metadata Handler', () => {\n  const exampleMetadata: OAuthMetadata = {\n    issuer: 'https://auth.example.com',\n    authorization_endpoint: 'https://auth.example.com/authorize',\n    token_endpoint: 'https://auth.example.com/token',\n    registration_endpoint: 'https://auth.example.com/register',\n    revocation_endpoint: 'https://auth.example.com/revoke',\n    scopes_supported: ['profile', 'email'],\n    response_types_supported: ['code'],\n    grant_types_supported: ['authorization_code', 'refresh_token'],\n    token_endpoint_auth_methods_supported: ['client_secret_basic'],\n    code_challenge_methods_supported: ['S256']\n  };\n\n  let app: express.Express;\n\n  beforeEach(() => {\n    // Setup express app with metadata handler\n    app = express();\n    app.use('/.well-known/oauth-authorization-server', metadataHandler(exampleMetadata));\n  });\n\n  it('requires GET method', async () => {\n    const response = await supertest(app)\n      .post('/.well-known/oauth-authorization-server')\n      .send({});\n\n    expect(response.status).toBe(405);\n    expect(response.headers.allow).toBe('GET');\n    expect(response.body).toEqual({\n      error: \"method_not_allowed\",\n      error_description: \"The method POST is not allowed for this endpoint\"\n    });\n  });\n\n  it('returns the metadata object', async () => {\n    const response = await supertest(app)\n      .get('/.well-known/oauth-authorization-server');\n\n    expect(response.status).toBe(200);\n    expect(response.body).toEqual(exampleMetadata);\n  });\n\n  it('includes CORS headers in response', async () => {\n    const response = await supertest(app)\n      .get('/.well-known/oauth-authorization-server')\n      .set('Origin', 'https://example.com');\n\n    expect(response.header['access-control-allow-origin']).toBe('*');\n  });\n\n  it('supports OPTIONS preflight requests', async () => {\n    const response = await supertest(app)\n      .options('/.well-known/oauth-authorization-server')\n      .set('Origin', 'https://example.com')\n      .set('Access-Control-Request-Method', 'GET');\n\n    expect(response.status).toBe(204);\n    expect(response.header['access-control-allow-origin']).toBe('*');\n  });\n\n  it('works with minimal metadata', async () => {\n    // Setup a new express app with minimal metadata\n    const minimalApp = express();\n    const minimalMetadata: OAuthMetadata = {\n      issuer: 'https://auth.example.com',\n      authorization_endpoint: 'https://auth.example.com/authorize',\n      token_endpoint: 'https://auth.example.com/token',\n      response_types_supported: ['code']\n    };\n    minimalApp.use('/.well-known/oauth-authorization-server', metadataHandler(minimalMetadata));\n\n    const response = await supertest(minimalApp)\n      .get('/.well-known/oauth-authorization-server');\n\n    expect(response.status).toBe(200);\n    expect(response.body).toEqual(minimalMetadata);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Empty Objects in Capabilities Merging\nDESCRIPTION: Tests that the mergeCapabilities function handles empty objects correctly, returning an empty object when both inputs are empty.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_162\n\nLANGUAGE: TypeScript\nCODE:\n```\nit(\"should handle empty objects\", () => {\n  const base = {};\n  const additional = {};\n  const merged = mergeCapabilities(base, additional);\n  expect(merged).toEqual({});\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Protocol Timeout Behaviors with Jest in TypeScript\nDESCRIPTION: Tests the Protocol class's timeout handling when no progress is received within the timeout period. The test verifies that the request rejects with a timeout error after the specified timeout period elapses.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_157\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should timeout if no progress received within timeout period\", async () => {\n  await protocol.connect(transport);\n  const request = { method: \"example\", params: {} };\n  const mockSchema: ZodType<{ result: string }> = z.object({\n    result: z.string(),\n  });\n  const requestPromise = protocol.request(request, mockSchema, {\n    timeout: 100,\n    resetTimeoutOnProgress: true,\n  });\n  jest.advanceTimersByTime(101);\n  await expect(requestPromise).rejects.toThrow(\"Request timed out\");\n});\n```\n\n----------------------------------------\n\nTITLE: Responding to Ping Request (JSON-RPC) - JSON\nDESCRIPTION: This snippet shows the expected empty result response to a ping request within the Model Context Protocol's ping utility. The response echoes the original id and includes an empty result object, enabling the sender to verify connection health and latency. Dependency: JSON-RPC 2.0. Inputs: id must match the ping request id. Output: confirmation of aliveness; no actual data is returned.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_5\n\nLANGUAGE: JSON\nCODE:\n```\n{\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"id\\\": \\\"123\\\",\\n  \\\"result\\\": {}\\n}\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Token Revocation Request Handling\nDESCRIPTION: This test suite verifies the functionality of the revocation handler by testing HTTP method restrictions, required parameter validation, client authentication, token revocation, support for token type hints, and CORS headers. It uses supertest to simulate HTTP requests to an Express app with the handler mounted.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_67\n\nLANGUAGE: jest\nCODE:\n```\ndescribe('Request handling', () => {\n  let app: express.Express;\n  let spyRevokeToken: jest.SpyInstance;\n\n  beforeEach(() => {\n    // Setup express app with revocation handler\n    app = express();\n    const options: RevocationHandlerOptions = { provider: mockProviderWithRevocation };\n    app.use('/revoke', revocationHandler(options));\n\n    // Spy on the revokeToken method\n    spyRevokeToken = jest.spyOn(mockProviderWithRevocation, 'revokeToken');\n  });\n\n  afterEach(() => {\n    spyRevokeToken.mockRestore();\n  });\n\n  it('requires POST method', async () => {\n    const response = await supertest(app)\n      .get('/revoke')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        token: 'token_to_revoke'\n      });\n\n    expect(response.status).toBe(405);\n    expect(response.headers.allow).toBe('POST');\n    expect(response.body).toEqual({\n      error: \"method_not_allowed\",\n      error_description: \"The method GET is not allowed for this endpoint\"\n    });\n    expect(spyRevokeToken).not.toHaveBeenCalled();\n  });\n\n  it('requires token parameter', async () => {\n    const response = await supertest(app)\n      .post('/revoke')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret'\n        // Missing token\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_request');\n    expect(spyRevokeToken).not.toHaveBeenCalled();\n  });\n\n  it('authenticates client before revoking token', async () => {\n    const response = await supertest(app)\n      .post('/revoke')\n      .type('form')\n      .send({\n        client_id: 'invalid-client',\n        client_secret: 'wrong-secret',\n        token: 'token_to_revoke'\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_client');\n    expect(spyRevokeToken).not.toHaveBeenCalled();\n  });\n\n  it('successfully revokes token', async () => {\n    const response = await supertest(app)\n      .post('/revoke')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        token: 'token_to_revoke'\n      });\n\n    expect(response.status).toBe(200);\n    expect(response.body).toEqual({}); // Empty response on success\n    expect(spyRevokeToken).toHaveBeenCalledTimes(1);\n    expect(spyRevokeToken).toHaveBeenCalledWith(validClient, {\n      token: 'token_to_revoke'\n    });\n  });\n\n  it('accepts optional token_type_hint', async () => {\n    const response = await supertest(app)\n      .post('/revoke')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        token: 'token_to_revoke',\n        token_type_hint: 'refresh_token'\n      });\n\n    expect(response.status).toBe(200);\n    expect(spyRevokeToken).toHaveBeenCalledWith(validClient, {\n      token: 'token_to_revoke',\n      token_type_hint: 'refresh_token'\n    });\n  });\n\n  it('includes CORS headers in response', async () => {\n    const response = await supertest(app)\n      .post('/revoke')\n      .type('form')\n      .set('Origin', 'https://example.com')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        token: 'token_to_revoke'\n      });\n\n    expect(response.header['access-control-allow-origin']).toBe('*');\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Prompt Completion Handler Implementation\nDESCRIPTION: Tests the implementation of completion handlers for prompt arguments with filtered results.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_142\n\nLANGUAGE: typescript\nCODE:\n```\nmcpServer.prompt(\n  \"test-prompt\",\n  {\n    name: completable(z.string(), (test) =>\n      [\"Alice\", \"Bob\", \"Charlie\"].filter((value) => value.startsWith(test)),\n    ),\n  },\n  async ({ name }) => ({\n    messages: [\n      {\n        role: \"assistant\",\n        content: {\n          type: \"text\",\n          text: `Hello ${name}`,\n        },\n      },\n    ],\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Importing Packages and Initializing MCP Server in Python\nDESCRIPTION: Python code to import necessary packages and initialize the FastMCP server for the weather application.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_88\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nimport httpx\nfrom mcp.server.fastmcp import FastMCP\n\n# Initialize FastMCP server\nmcp = FastMCP(\"weather\")\n\n# Constants\nNWS_API_BASE = \"https://api.weather.gov\"\nUSER_AGENT = \"weather-app/1.0\"\n```\n\n----------------------------------------\n\nTITLE: Implementing async start method for SSEClientTransport in TypeScript\nDESCRIPTION: Implements the start method for the SSEClientTransport class which initializes the connection. It throws an error if the transport is already started and returns the result of _startOrAuth method.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_40\n\nLANGUAGE: TypeScript\nCODE:\n```\n  async start() {\n    if (this._eventSource) {\n      throw new Error(\n        \"SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.\",\n      );\n    }\n\n    return await this._startOrAuth();\n  }\n```\n\n----------------------------------------\n\nTITLE: Clearing Subtasks with Meta-Development Script\nDESCRIPTION: This snippet shows how to use the 'clear-subtasks' command to remove subtasks from specified tasks. It includes examples of clearing subtasks from specific tasks, multiple tasks, and all tasks.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Clear subtasks from a specific task\ntask-master clear-subtasks --id=3\n\n# Clear subtasks from multiple tasks\ntask-master clear-subtasks --id=1,2,3\n\n# Clear subtasks from all tasks\ntask-master clear-subtasks --all\n```\n\n----------------------------------------\n\nTITLE: Defining analyze-code-quality Command Structure in Markdown\nDESCRIPTION: Markdown structure outlining the main functions of the analyze-code-quality command, including pattern recognition, best practice verification, improvement recommendations, and task integration.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_049.txt#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n1. **Pattern Recognition**:\n   - Scan the codebase to identify recurring patterns in code structure, function design, and architecture\n   - Categorize patterns by frequency and impact on maintainability\n   - Generate a report of common patterns with examples from the codebase\n\n2. **Best Practice Verification**:\n   - For each function in specified files, extract its purpose, parameters, and implementation details\n   - Create a verification checklist for each function that includes:\n     - Function naming conventions\n     - Parameter handling\n     - Error handling\n     - Return value consistency\n     - Documentation quality\n     - Complexity metrics\n   - Use an API integration with Perplexity or similar AI service to evaluate each function against current best practices\n\n3. **Improvement Recommendations**:\n   - Generate specific refactoring suggestions for functions that don't align with best practices\n   - Include code examples of the recommended improvements\n   - Estimate the effort required for each refactoring suggestion\n\n4. **Task Integration**:\n   - Create a mechanism to convert high-value improvement recommendations into Taskmaster tasks\n   - Allow users to select which recommendations to convert to tasks\n   - Generate properly formatted task descriptions that include the current implementation, recommended changes, and justification\n```\n\n----------------------------------------\n\nTITLE: Showing Task Details using CLI (Bash)\nDESCRIPTION: These commands display comprehensive information about a specific task or subtask, identified by its ID (provided either as an argument or via `--id`). It shows basic details, description, implementation, tests, subtasks (for regular tasks), parent task relationship (for subtasks), and provides contextual suggested action commands. The `--file` option allows specifying a custom task file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n# Show details for a specific task\nnode scripts/dev.js show 1\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Alternative syntax with --id option\nnode scripts/dev.js show --id=1\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Show details for a subtask\nnode scripts/dev.js show --id=1.2\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Specify a different tasks file\nnode scripts/dev.js show 3 --file=custom-tasks.json\n```\n\n----------------------------------------\n\nTITLE: Setting Up Resource Request Handlers with Schema Validation - TypeScript\nDESCRIPTION: Defines methods to register handlers for listing resources and reading resources using pre-defined request schemas. These handlers map URIs to resource objects, resolve resource templates if not found, call asynchronous resource loaders, assemble results, and throw or handle errors with custom error types. Dependencies include handler schemas (e.g., ListResourcesRequestSchema), resource implementations, error classes, and URI template parsing utilities. Inputs include request schemas and resources, outputs are structured responses for resources or structured errors.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nprivate setupResourceHandlers(resources: Resource[]) {\n  this.#server.setRequestHandler(ListResourcesRequestSchema, async () => {\n    return {\n      resources: resources.map((resource) => {\n        return {\n          uri: resource.uri,\n          name: resource.name,\n          mimeType: resource.mimeType,\n        };\n      }),\n    };\n  });\n\n  this.#server.setRequestHandler(\n    ReadResourceRequestSchema,\n    async (request) => {\n      if (\"uri\" in request.params) {\n        const resource = resources.find(\n          (resource) =>\n            \"uri\" in resource && resource.uri === request.params.uri,\n        );\n\n        if (!resource) {\n          for (const resourceTemplate of this.#resourceTemplates) {\n            const uriTemplate = parseURITemplate(\n              resourceTemplate.uriTemplate,\n            );\n\n            const match = uriTemplate.fromUri(request.params.uri);\n\n            if (!match) {\n              continue;\n            }\n\n            const uri = uriTemplate.fill(match);\n\n            const result = await resourceTemplate.load(match);\n\n            return {\n              contents: [\n                {\n                  uri: uri,\n                  mimeType: resourceTemplate.mimeType,\n                  name: resourceTemplate.name,\n                  ...result,\n                },\n              ],\n            };\n          }\n\n          throw new McpError(\n            ErrorCode.MethodNotFound,\n            `Unknown resource: ${request.params.uri}`,\n          );\n        }\n\n        if (!(\"uri\" in resource)) {\n          throw new UnexpectedStateError(\"Resource does not support reading\");\n        }\n\n        let maybeArrayResult: Awaited<ReturnType<Resource[\"load\"]>>;\n\n        try {\n          maybeArrayResult = await resource.load();\n        } catch (error) {\n          throw new McpError(\n            ErrorCode.InternalError,\n            `Error reading resource: ${error}`,\n            {\n              uri: resource.uri,\n            },\n          );\n        }\n\n        if (Array.isArray(maybeArrayResult)) {\n          return {\n            contents: maybeArrayResult.map((result) => ({\n              uri: resource.uri,\n              mimeType: resource.mimeType,\n              name: resource.name,\n              ...result,\n            })),\n          };\n        } else {\n          return {\n            contents: [\n              {\n                uri: resource.uri,\n                mimeType: resource.mimeType,\n                name: resource.name,\n                ...maybeArrayResult,\n              },\n            ],\n          };\n        }\n      }\n\n      throw new UnexpectedStateError(\"Unknown resource request\", {\n        request,\n      });\n    },\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Testing POST Request with CORS Headers in Supertest\nDESCRIPTION: This snippet demonstrates how to send a POST request to the '/token' endpoint with form data including OAuth client credentials and authorization code details using Supertest. It also checks that the CORS headers are properly set in the response.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_75\n\nLANGUAGE: typescript\nCODE:\n```\nconst response = await supertest(app)\n  .post('/token')\n  .type('form')\n  .set('Origin', 'https://example.com')\n  .send({\n    client_id: 'valid-client',\n    client_secret: 'valid-secret',\n    grant_type: 'authorization_code',\n    code: 'valid_code',\n    code_verifier: 'valid_verifier'\n  });\n\nexpect(response.header['access-control-allow-origin']).toBe('*');\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting Task Master Initialization\nDESCRIPTION: Alternative methods to initialize Task Master if the standard command fails.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README-task-master.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnode node_modules/claude-task-master/scripts/init.js\n\n# Or clone the repository and run:\ngit clone https://github.com/eyaltoledano/claude-task-master.git\ncd claude-task-master\nnode scripts/init.js\n```\n\n----------------------------------------\n\nTITLE: Testing Successful OAuth 2.0 Authorization Flow\nDESCRIPTION: Test cases that verify successful authorization flow scenarios including handling of all parameters, preservation of state parameter, and processing both GET and POST requests. These tests ensure the authorization endpoint redirects properly with the expected parameters.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_56\n\nLANGUAGE: JavaScript\nCODE:\n```\ndescribe('Successful authorization', () => {\n    it('handles successful authorization with all parameters', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256',\n          scope: 'profile email',\n          state: 'xyz789'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.origin + location.pathname).toBe('https://example.com/callback');\n      expect(location.searchParams.get('code')).toBe('mock_auth_code');\n      expect(location.searchParams.get('state')).toBe('xyz789');\n    });\n\n    it('preserves state parameter in response', async () => {\n      const response = await supertest(app)\n        .get('/authorize')\n        .query({\n          client_id: 'valid-client',\n          redirect_uri: 'https://example.com/callback',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256',\n          state: 'state-value-123'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.get('state')).toBe('state-value-123');\n    });\n\n    it('handles POST requests the same as GET', async () => {\n      const response = await supertest(app)\n        .post('/authorize')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          response_type: 'code',\n          code_challenge: 'challenge123',\n          code_challenge_method: 'S256'\n        });\n\n      expect(response.status).toBe(302);\n      const location = new URL(response.header.location);\n      expect(location.searchParams.has('code')).toBe(true);\n    });\n  });\n```\n\n----------------------------------------\n\nTITLE: Installing FastMCP Package in JavaScript\nDESCRIPTION: Shows the npm command to install the fastmcp package, which is required to access environment variables in a JavaScript environment.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nnpm install fastmcp\n```\n\n----------------------------------------\n\nTITLE: Expanding URI Templates with Variable Substitution in TypeScript\nDESCRIPTION: This code handles the expansion of URI templates by substituting variables based on different operators. It transforms template patterns into URLs, handling various prefix operators and encoding schemes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_186\n\nLANGUAGE: typescript\nCODE:\n```\n  expand(variables: Variables): string {\n    let result = \"\";\n    let hasQueryParam = false;\n\n    for (const part of this.parts) {\n      if (typeof part === \"string\") {\n        result += part;\n        continue;\n      }\n\n      const expanded = this.expandPart(part, variables);\n      if (!expanded) continue;\n\n      // Convert ? to & if we already have a query parameter\n      if ((part.operator === \"?\" || part.operator === \"&\") && hasQueryParam) {\n        result += expanded.replace(\"?\", \"&\");\n      } else {\n        result += expanded;\n      }\n\n      if (part.operator === \"?\" || part.operator === \"&\") {\n        hasQueryParam = true;\n      }\n    }\n\n    return result;\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating Authorization Headers for SSE Transport in TypeScript\nDESCRIPTION: Generates common headers with authorization information from the auth provider for use in requests made by the SSE transport.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nprivate async _commonHeaders(): Promise<HeadersInit> {\n  const headers: HeadersInit = {};\n  if (this._authProvider) {\n    const tokens = await this._authProvider.tokens();\n    if (tokens) {\n      headers[\"Authorization\"] = `Bearer ${tokens.access_token}`;\n    }\n  }\n\n  return headers;\n}\n```\n\n----------------------------------------\n\nTITLE: Example of HTTP Request with Access Token in MCP\nDESCRIPTION: This code snippet demonstrates the correct format for including an access token in an HTTP request header for MCP API calls, as per OAuth 2.1 specifications.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_88\n\nLANGUAGE: http\nCODE:\n```\nGET /v1/contexts HTTP/1.1\nHost: mcp.example.com\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIs...\n```\n\n----------------------------------------\n\nTITLE: Testing Request Timeout Handling\nDESCRIPTION: Tests the server's timeout handling capabilities for requests, verifying that requests with zero timeout fail immediately.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_113\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should handle request timeout\", async () => {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  client.setRequestHandler(\n    CreateMessageRequestSchema,\n    async (_request, extra) => {\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(resolve, 100);\n        extra.signal.addEventListener(\"abort\", () => {\n          clearTimeout(timeout);\n          reject(extra.signal.reason);\n        });\n      });\n\n      return {\n        model: \"test\",\n        role: \"assistant\",\n        content: {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      };\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  await expect(\n    server.createMessage(\n      {\n        messages: [],\n        maxTokens: 10,\n      },\n      { timeout: 0 },\n    ),\n  ).rejects.toMatchObject({\n    code: ErrorCode.RequestTimeout,\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Documenting Version 0.12.1 Changes in Markdown\nDESCRIPTION: Documents a patch change for version 0.12.1, fixing an issue with the add_dependency tool in the MCP Server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n## 0.12.1\n\n### Patch Changes\n\n- [#307](https://github.com/eyaltoledano/claude-task-master/pull/307) [`2829194`](https://github.com/eyaltoledano/claude-task-master/commit/2829194d3c1dd5373d3bf40275cf4f63b12d49a7) Thanks [@Crunchyman-ralph](https://github.com/Crunchyman-ralph)! - Fix add_dependency tool crashing the MCP Server\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Token Error Handling in Bearer Authentication\nDESCRIPTION: Test case that verifies the middleware correctly handles InvalidTokenError exceptions. It simulates a token verification failure and checks that a 401 error response is returned with the proper error message.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_86\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should return 401 when token verification fails with InvalidTokenError\", async () => {\n  mockRequest.headers = {\n    authorization: \"Bearer invalid-token\",\n  };\n\n  mockVerifyAccessToken.mockRejectedValue(new InvalidTokenError(\"Token expired\"));\n\n  const middleware = requireBearerAuth({ provider: mockProvider });\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"invalid-token\");\n  expect(mockResponse.status).toHaveBeenCalledWith(401);\n  expect(mockResponse.set).toHaveBeenCalledWith(\n    \"WWW-Authenticate\",\n    expect.stringContaining('Bearer error=\"invalid_token\"')\n  );\n  expect(mockResponse.json).toHaveBeenCalledWith(\n    expect.objectContaining({ error: \"invalid_token\", error_description: \"Token expired\" })\n  );\n  expect(nextFunction).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Generic OAuth Error Handling in Bearer Authentication\nDESCRIPTION: Test case that verifies the middleware correctly handles generic OAuthError exceptions. It simulates a custom OAuth error and checks that a 400 error response is returned with the appropriate error code and message.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_89\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should return 400 for generic OAuthError\", async () => {\n  mockRequest.headers = {\n    authorization: \"Bearer valid-token\",\n  };\n\n  mockVerifyAccessToken.mockRejectedValue(new OAuthError(\"custom_error\", \"Some OAuth error\"));\n\n  const middleware = requireBearerAuth({ provider: mockProvider });\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n  expect(mockResponse.status).toHaveBeenCalledWith(400);\n  expect(mockResponse.json).toHaveBeenCalledWith(\n    expect.objectContaining({ error: \"custom_error\", error_description: \"Some OAuth error\" })\n  );\n  expect(nextFunction).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Testing Authorization Redirection on Token Refresh Failure\nDESCRIPTION: Test case that verifies the SSE transport redirects to authorization when token refresh fails, throwing an UnauthorizedError and calling the appropriate auth provider method.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"redirects to authorization if refresh token flow fails\", async () => {\n  // Mock tokens() to return expired token until saveTokens is called\n  let currentTokens: OAuthTokens = {\n    access_token: \"expired-token\",\n    token_type: \"Bearer\",\n    refresh_token: \"refresh-token\"\n  };\n  mockAuthProvider.tokens.mockImplementation(() => currentTokens);\n  mockAuthProvider.saveTokens.mockImplementation((tokens) => {\n    currentTokens = tokens;\n  });\n\n  // Create server that returns 401 for all tokens\n  await server.close();\n\n  server = createServer((req, res) => {\n    lastServerRequest = req;\n\n    if (req.url === \"/token\" && req.method === \"POST\") {\n      // Handle token refresh request - always fail\n      res.writeHead(400).end();\n      return;\n    }\n\n    if (req.url !== \"/\") {\n      res.writeHead(404).end();\n      return;\n    }\n    res.writeHead(401).end();\n  });\n\n  await new Promise<void>(resolve => {\n    server.listen(0, \"127.0.0.1\", () => {\n      const addr = server.address() as AddressInfo;\n      baseUrl = new URL(`http://127.0.0.1:${addr.port}`);\n      resolve();\n    });\n  });\n\n  transport = new SSEClientTransport(baseUrl, {\n    authProvider: mockAuthProvider,\n  });\n\n  await expect(() => transport.start()).rejects.toThrow(UnauthorizedError);\n  expect(mockAuthProvider.redirectToAuthorization).toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Override for Project Root in JavaScript\nDESCRIPTION: Shows how to implement environment variable overrides for project root path resolution. This allows users to explicitly set paths when the automatic detection might not work as expected.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nconst projectRoot = process.env.TASK_MASTER_PROJECT_ROOT || resolveProjectRoot(process.cwd());\n```\n\n----------------------------------------\n\nTITLE: Verifying Node.js Installation for TypeScript MCP Server\nDESCRIPTION: Bash commands to verify the installation of Node.js and npm for the TypeScript implementation of the MCP weather server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_93\n\nLANGUAGE: bash\nCODE:\n```\nnode --version\nnpm --version\n```\n\n----------------------------------------\n\nTITLE: Text Content Type Format\nDESCRIPTION: JSON format for plain text content in prompt messages. This is the most common content type used for natural language interactions.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_122\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"text\",\n  \"text\": \"The text content of the message\"\n}\n```\n\n----------------------------------------\n\nTITLE: Tool Result Content Types in JSON\nDESCRIPTION: Examples of different content type formats that can be returned in tool results, including text, image, audio and embedded resources.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_137\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"text\",\n  \"text\": \"Tool result text\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"image\",\n  \"data\": \"base64-encoded-data\",\n  \"mimeType\": \"image/png\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"audio\",\n  \"data\": \"base64-encoded-audio-data\",\n  \"mimeType\": \"audio/wav\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"resource\",\n  \"resource\": {\n    \"uri\": \"resource://example\",\n    \"mimeType\": \"text/plain\",\n    \"text\": \"Resource content\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Helper function for Electron detection in TypeScript\nDESCRIPTION: Implements a helper function to detect if the code is running in an Electron environment by checking for the 'type' property in the process object.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_51\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction isElectron() {\n  return \"type\" in process;\n}\n```\n\n----------------------------------------\n\nTITLE: Detecting Yarn Workspace Root in JavaScript\nDESCRIPTION: Demonstrates how to detect the root of a Yarn workspace using the find-yarn-workspace-root package. This is useful for handling monorepo structures and workspaces.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nconst findWorkspaceRoot = require('find-yarn-workspace-root');\nconst workspaceRoot = findWorkspaceRoot(process.cwd());\n```\n\n----------------------------------------\n\nTITLE: Defining Resource Read Request and Result Schemas\nDESCRIPTION: Schemas for reading specific resources by URI. The request specifies the resource URI to read, and the result contains an array of resource contents (either text or binary blob formats).\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_204\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Sent from the client to the server, to read a specific resource URI.\n */\nexport const ReadResourceRequestSchema = RequestSchema.extend({\n  method: z.literal(\"resources/read\"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.\n     */\n    uri: z.string(),\n  }),\n});\n\n/**\n * The server's response to a resources/read request from the client.\n */\nexport const ReadResourceResultSchema = ResultSchema.extend({\n  contents: z.array(\n    z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Research-Backed Expansion Prompt Template - Markdown\nDESCRIPTION: This Markdown code block outlines a prompt template for LLM-driven, research-backed subtask creation. It guides an AI assistant to partition a development task using best practices, technical research, and technology recommendations. Subtasks generated should include detailed descriptions, dependencies, acceptance criteria, and references to tools or libraries. Considerations such as security, performance, maintainability, and UX are required, aiming for actionable and high-quality task breakdowns suitable for rigorous software projects.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/prd.txt#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n```\nYou are a technical researcher and developer helping to break down a software development task into detailed, well-researched subtasks.\n\nMain task:\nTitle: {task_title}\nDescription: {task_description}\nDetails: {task_details}\n\nResearch the latest best practices, technologies, and implementation patterns for this type of task. Then create {num_subtasks} specific, actionable subtasks that together would accomplish the main task.\n\nFor each subtask:\n1. Provide a clear, specific title\n2. Write a detailed description including technical approach\n3. Identify dependencies on other subtasks\n4. Include specific acceptance criteria\n5. Reference any relevant libraries, tools, or resources that should be used\n\nConsider security, performance, maintainability, and user experience in your recommendations.\n```\n```\n\n----------------------------------------\n\nTITLE: Minimal Resources Capability Declaration\nDESCRIPTION: JSON example showing a server declaring resources capability without supporting any optional features.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_49\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"resources\": {} // Neither feature supported\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Task Discovery Workflow in Node.js\nDESCRIPTION: Guidelines for AI agents to discover and interpret tasks from the tasks.json file, including parsing metadata and understanding task relationships.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_014.txt#2025-04-23_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Updating Technology Stack Changes\nDESCRIPTION: Command to update future tasks when making technology stack changes in the project.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/examples.md#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\nWe've decided to use MongoDB instead of PostgreSQL. Can you update all future tasks to reflect this change?\n```\n\n----------------------------------------\n\nTITLE: Maven Dependencies Configuration for MCP SDK\nDESCRIPTION: Maven dependency configuration showing how to include core MCP functionality and optional HTTP SSE transport implementations using Spring WebFlux and WebMVC.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_132\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\n    <groupId>io.modelcontextprotocol.sdk</groupId>\n    <artifactId>mcp</artifactId>\n</dependency>\n\n<!-- Spring WebFlux-based SSE client and server transport -->\n<dependency>\n    <groupId>io.modelcontextprotocol.sdk</groupId>\n    <artifactId>mcp-spring-webflux</artifactId>\n</dependency>\n\n<!-- Spring WebMVC-based SSE server transport -->\n<dependency>\n    <groupId>io.modelcontextprotocol.sdk</groupId>\n    <artifactId>mcp-spring-webmvc</artifactId>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Testing Required Scope Validation in Bearer Authentication\nDESCRIPTION: Test case that verifies the middleware correctly rejects tokens without sufficient scopes. It checks that a 403 response is returned when the token's scopes don't match all the required scopes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_82\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should require specific scopes when configured\", async () => {\n  const authInfo: AuthInfo = {\n    token: \"valid-token\",\n    clientId: \"client-123\",\n    scopes: [\"read\"],\n  };\n  mockVerifyAccessToken.mockResolvedValue(authInfo);\n\n  mockRequest.headers = {\n    authorization: \"Bearer valid-token\",\n  };\n\n  const middleware = requireBearerAuth({\n    provider: mockProvider,\n    requiredScopes: [\"read\", \"write\"]\n  });\n\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n  expect(mockResponse.status).toHaveBeenCalledWith(403);\n  expect(mockResponse.set).toHaveBeenCalledWith(\n    \"WWW-Authenticate\",\n    expect.stringContaining('Bearer error=\"insufficient_scope\"')\n  );\n  expect(mockResponse.json).toHaveBeenCalledWith(\n    expect.objectContaining({ error: \"insufficient_scope\", error_description: \"Insufficient scope\" })\n  );\n  expect(nextFunction).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Client Authorization Functions in TypeScript with Jest\nDESCRIPTION: This TypeScript code snippet sets up Jest tests for OAuth client authorization functions (`discoverOAuthMetadata`, `startAuthorization`, `exchangeAuthorization`, etc.). It imports the necessary functions, mocks the global `fetch` API using `jest.fn()`, and defines a test suite (`describe`) for 'OAuth Authorization'. The `beforeEach` hook resets the fetch mock before each test, ensuring isolation. The tests specifically validate the `discoverOAuthMetadata` function under various conditions, including successful discovery with and without MCP headers, handling fetch errors (like CORS simulation with TypeError), 404 responses, other HTTP errors, and schema validation of the received metadata.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  discoverOAuthMetadata,\n  startAuthorization,\n  exchangeAuthorization,\n  refreshAuthorization,\n  registerClient,\n} from \"./auth.js\";\n\n// Mock fetch globally\nconst mockFetch = jest.fn();\nglobal.fetch = mockFetch;\n\ndescribe(\"OAuth Authorization\", () => {\n  beforeEach(() => {\n    mockFetch.mockReset();\n  });\n\n  describe(\"discoverOAuthMetadata\", () => {\n    const validMetadata = {\n      issuer: \"https://auth.example.com\",\n      authorization_endpoint: \"https://auth.example.com/authorize\",\n      token_endpoint: \"https://auth.example.com/token\",\n      registration_endpoint: \"https://auth.example.com/register\",\n      response_types_supported: [\"code\"],\n      code_challenge_methods_supported: [\"S256\"],\n    };\n\n    it(\"returns metadata when discovery succeeds\", async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () => validMetadata,\n      });\n\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com\");\n      expect(metadata).toEqual(validMetadata);\n      const calls = mockFetch.mock.calls;\n      expect(calls.length).toBe(1);\n      const [url, options] = calls[0];\n      expect(url.toString()).toBe(\"https://auth.example.com/.well-known/oauth-authorization-server\");\n      expect(options.headers).toEqual({\n        \"MCP-Protocol-Version\": \"2024-11-05\"\n      });\n    });\n\n    it(\"returns metadata when first fetch fails but second without MCP header succeeds\", async () => {\n      // Set up a counter to control behavior\n      let callCount = 0;\n      \n      // Mock implementation that changes behavior based on call count\n      mockFetch.mockImplementation((_url, _options) => {\n        callCount++;\n        \n        if (callCount === 1) {\n          // First call with MCP header - fail with TypeError (simulating CORS error)\n          // We need to use TypeError specifically because that's what the implementation checks for\n          return Promise.reject(new TypeError(\"Network error\"));\n        } else {\n          // Second call without header - succeed\n          return Promise.resolve({\n            ok: true,\n            status: 200,\n            json: async () => validMetadata\n          });\n        }\n      });\n\n      // Should succeed with the second call\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com\");\n      expect(metadata).toEqual(validMetadata);\n      \n      // Verify both calls were made\n      expect(mockFetch).toHaveBeenCalledTimes(2);\n      \n      // Verify first call had MCP header\n      expect(mockFetch.mock.calls[0][1]?.headers).toHaveProperty(\"MCP-Protocol-Version\");\n    });\n\n    it(\"throws an error when all fetch attempts fail\", async () => {\n      // Set up a counter to control behavior\n      let callCount = 0;\n      \n      // Mock implementation that changes behavior based on call count\n      mockFetch.mockImplementation((_url, _options) => {\n        callCount++;\n        \n        if (callCount === 1) {\n          // First call - fail with TypeError\n          return Promise.reject(new TypeError(\"First failure\"));\n        } else {\n          // Second call - fail with different error\n          return Promise.reject(new Error(\"Second failure\"));\n        }\n      });\n\n      // Should fail with the second error\n      await expect(discoverOAuthMetadata(\"https://auth.example.com\"))\n        .rejects.toThrow(\"Second failure\");\n        \n      // Verify both calls were made\n      expect(mockFetch).toHaveBeenCalledTimes(2);\n    });\n\n    it(\"returns undefined when discovery endpoint returns 404\", async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 404,\n      });\n\n      const metadata = await discoverOAuthMetadata(\"https://auth.example.com\");\n      expect(metadata).toBeUndefined();\n    });\n\n    it(\"throws on non-404 errors\", async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: false,\n        status: 500,\n      });\n\n      await expect(\n        discoverOAuthMetadata(\"https://auth.example.com\")\n      ).rejects.toThrow(\"HTTP 500\");\n    });\n\n    it(\"validates metadata schema\", async () => {\n      mockFetch.mockResolvedValueOnce({\n        ok: true,\n        status: 200,\n        json: async () => ({\n          // Missing required fields\n          issuer: \"https://auth.example.com\",\n        }),\n      });\n\n      await expect(\n        discoverOAuthMetadata(\"https://auth.example.com\")\n      ).rejects.toThrow();\n    });\n  });\n\n  describe(\"startAuthorization\", () => {\n    const validMetadata = {\n      issuer: \"https://auth.example.com\",\n      authorization_endpoint: \"https://auth.example.com/auth\",\n      token_endpoint: \"https://auth.example.com/tkn\",\n      response_types_supported: [\"code\"],\n      code_challenge_methods_supported: [\"S256\"],\n    };\n\n    const validClientInfo = {\n      client_id: \"client123\",\n      client_secret: \"secret123\",\n      redirect_uris: [\"http://localhost:3000/callback\"],\n      client_name: \"Test Client\",\n    };\n\n    it(\"generates authorization URL with PKCE challenge\", async () => {\n      const { authorizationUrl, codeVerifier } = await startAuthorization(\n        \"https://auth.example.com\",\n        {\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n        }\n      );\n\n      expect(authorizationUrl.toString()).toMatch(\n        /^https:\\/\\/auth\\.example\\.com\\/authorize\\?/\n      );\n      expect(authorizationUrl.searchParams.get(\"response_type\")).toBe(\"code\");\n      expect(authorizationUrl.searchParams.get(\"code_challenge\")).toBe(\"test_challenge\");\n      expect(authorizationUrl.searchParams.get(\"code_challenge_method\")).toBe(\n        \"S256\"\n      );\n      expect(authorizationUrl.searchParams.get(\"redirect_uri\")).toBe(\n        \"http://localhost:3000/callback\"\n      );\n      expect(codeVerifier).toBe(\"test_verifier\");\n    });\n\n    it(\"uses metadata authorization_endpoint when provided\", async () => {\n      const { authorizationUrl } = await startAuthorization(\n        \"https://auth.example.com\",\n        {\n          metadata: validMetadata,\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n        }\n      );\n\n      expect(authorizationUrl.toString()).toMatch(\n        /^https:\\/\\/auth\\.example\\.com\\/auth\\?/\n      );\n    });\n\n    it(\"validates response type support\", async () => {\n      const metadata = {\n        ...validMetadata,\n        response_types_supported: [\"token\"], // Does not support 'code'\n      };\n\n      await expect(\n        startAuthorization(\"https://auth.example.com\", {\n          metadata,\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n        })\n      ).rejects.toThrow(/does not support response type/);\n    });\n\n    it(\"validates PKCE support\", async () => {\n      const metadata = {\n        ...validMetadata,\n        response_types_supported: [\"code\"],\n        code_challenge_methods_supported: [\"plain\"], // Does not support 'S256'\n      };\n\n      await expect(\n        startAuthorization(\"https://auth.example.com\", {\n          metadata,\n          clientInformation: validClientInfo,\n          redirectUrl: \"http://localhost:3000/callback\",\n        })\n      ).rejects.toThrow(/does not support code challenge method/);\n    });\n  });\n\n  describe(\"exchangeAuthorization\", () => {\n    const validTokens = {\n      access_token: \"access123\",\n      token_type: \"Bearer\",\n      expires_in: 3600,\n      refresh_token: \"refresh123\",\n    };\n\n    const validClientInfo = {\n      client_id: \"client123\",\n      client_secret: \"secret123\",\n      redirect_uris: [\"http://localhost:3000/callback\"],\n      client_name: \"Test Client\",\n    };\n\n    it(\"exchanges code for tokens\", async () => {\n      mockFetch.mockResolvedValueOnce({\n\n```\n\n----------------------------------------\n\nTITLE: Importing Config Class in Python for FastMCP Environment Variables\nDESCRIPTION: Shows how to import the Config class from the fastmcp module in Python to access environment variables defined in the mcp.json file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom fastmcp import Config\n```\n\n----------------------------------------\n\nTITLE: Task Update Commands in Task Master CLI\nDESCRIPTION: Commands for updating tasks from a specific ID with context information.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Update tasks from a specific ID and provide context\ntask-master update --from=<id> --prompt=\"<prompt>\"\n```\n\n----------------------------------------\n\nTITLE: Implementing message sending for SSEClientTransport in TypeScript\nDESCRIPTION: Implements the send method for SSEClientTransport which sends a JSON-RPC message to the server endpoint. It handles authentication errors and retries when needed.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_43\n\nLANGUAGE: TypeScript\nCODE:\n```\n  async send(message: JSONRPCMessage): Promise<void> {\n    if (!this._endpoint) {\n      throw new Error(\"Not connected\");\n    }\n\n    try {\n      const commonHeaders = await this._commonHeaders();\n      const headers = new Headers({ ...commonHeaders, ...this._requestInit?.headers });\n      headers.set(\"content-type\", \"application/json\");\n      const init = {\n        ...this._requestInit,\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(message),\n        signal: this._abortController?.signal,\n      };\n\n      const response = await fetch(this._endpoint, init);\n      if (!response.ok) {\n        if (response.status === 401 && this._authProvider) {\n          const result = await auth(this._authProvider, { serverUrl: this._url });\n          if (result !== \"AUTHORIZED\") {\n            throw new UnauthorizedError();\n          }\n\n          // Purposely _not_ awaited, so we don't call onerror twice\n          return this.send(message);\n        }\n\n        const text = await response.text().catch(() => null);\n        throw new Error(\n          `Error POSTing to endpoint (HTTP ${response.status}): ${text}`,\n        );\n      }\n    } catch (error) {\n      this.onerror?.(error as Error);\n      throw error;\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Accessing Resources with Synchronous MCP Client in Java\nDESCRIPTION: Demonstrates how to list and retrieve resources using the synchronous MCP client API. Resources represent server-side data sources that clients can access using URI templates for standardized interface interaction.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_128\n\nLANGUAGE: java\nCODE:\n```\n// List available resources and their names\nvar resources = client.listResources();\nresources.forEach(resource -> System.out.println(resource.getName()));\n\n// Retrieve resource content using a URI template\nvar content = client.getResource(\"file\", Map.of(\n    \"path\", \"/path/to/file.txt\"\n));\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Weather Server in Claude for Desktop (Windows)\nDESCRIPTION: JSON configuration for adding the Java-based MCP weather server to Claude for Desktop on Windows. It specifies the command and arguments to run the server JAR file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_110\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"spring-ai-mcp-weather\": {\n      \"command\": \"java\",\n      \"args\": [\n        \"-Dspring.ai.mcp.server.transport=STDIO\",\n        \"-jar\",\n        \"C:\\\\ABSOLUTE\\\\PATH\\\\TO\\\\PARENT\\\\FOLDER\\\\weather\\\\mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Resource Templates with FastMCP Decorators in Python\nDESCRIPTION: These Python examples show how to declare dynamic, parameterized resource templates using FastMCP's @mcp.resource decorator, enabling the server to generate custom data views (such as task creation templates, user-specific workflows, and dashboards) based on path parameters. Each function signature matches the resource URI pattern, supporting dynamic generation according to the user's identity or request type. Dependencies include FastMCP and support for type-annotated handler functions. Inputs are typically URI components, while outputs are serialized dictionaries representing resource views. Constraints involve proper parameter naming in both URI and function arguments.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@mcp.resource(\"tasks://create/{task_type}\")\ndef get_task_creation_template(task_type: str) -> dict:\n    # Generate and return a task creation template based on task_type\n    ...\n\n```\n\nLANGUAGE: python\nCODE:\n```\n@mcp.resource(\"workflows://custom/{user_id}/{workflow_name}\")\ndef get_custom_workflow_template(user_id: str, workflow_name: str) -> dict:\n    # Generate and return a custom workflow template for the user\n    ...\n\n```\n\nLANGUAGE: python\nCODE:\n```\n@mcp.resource(\"users://{user_id}/dashboard\")\ndef get_user_dashboard(user_id: str) -> dict:\n    # Generate and return a personalized dashboard view for the user\n    ...\n\n```\n\n----------------------------------------\n\nTITLE: Illustrating Capability Negotiation Sequence (Mermaid) - Mermaid\nDESCRIPTION: This snippet provides a sequence diagram in Mermaid to visualize the capability negotiation and session flow process within the Model Context Protocol. It describes how the host initializes the client and the client negotiates with the server, including capability queries and handling of both client- and server-initiated requests. It illustrates various communication loops (requests and notifications) and shutdown steps. No external dependencies are required beyond Mermaid support. The diagram requires Mermaid-compatible Markdown rendering for visualization.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_1\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\\n    participant Host\\n    participant Client\\n    participant Server\\n\\n    Host->>+Client: Initialize client\\n    Client->>+Server: Initialize session with capabilities\\n    Server-->>Client: Respond with supported capabilities\\n\\n    Note over Host,Server: Active Session with Negotiated Features\\n\\n    loop Client Requests\\n        Host->>Client: User- or model-initiated action\\n        Client->>Server: Request (tools/resources)\\n        Server-->>Client: Response\\n        Client-->>Host: Update UI or respond to model\\n    end\\n\\n    loop Server Requests\\n        Server->>Client: Request (sampling)\\n        Client->>Host: Forward to AI\\n        Host-->>Client: AI response\\n        Client-->>Server: Response\\n    end\\n\\n    loop Notifications\\n        Server--)Client: Resource updates\\n        Client--)Server: Status changes\\n    end\\n\\n    Host->>Client: Terminate\\n    Client->>-Server: End session\\n    deactivate Server\n```\n\n----------------------------------------\n\nTITLE: Jest Test File Structure - TypeScript\nDESCRIPTION: Example structure for generated Jest test files following project naming conventions.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_024.txt#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// task_001.test.ts\n\ndescribe('Task 001', () => {\n  beforeEach(() => {\n    // Setup test environment\n  });\n\n  test('should implement required functionality', () => {\n    // Test implementation\n  });\n\n  test('should handle error conditions', () => {\n    // Error handling tests\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Managing Request Timeouts in TypeScript\nDESCRIPTION: Code that handles request timeout management including checking total elapsed time, resetting timeouts, and cleaning up timeout resources when done.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_164\n\nLANGUAGE: typescript\nCODE:\n```\nconst totalElapsed = Date.now() - info.startTime;\nif (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {\n  this._timeoutInfo.delete(messageId);\n  throw new McpError(\n    ErrorCode.RequestTimeout,\n    \"Maximum total timeout exceeded\",\n    { maxTotalTimeout: info.maxTotalTimeout, totalElapsed }\n  );\n}\n\nclearTimeout(info.timeoutId);\ninfo.timeoutId = setTimeout(info.onTimeout, info.timeout);\nreturn true;\n```\n\n----------------------------------------\n\nTITLE: Formatting Individual Task Files - Plaintext\nDESCRIPTION: This snippet sets the template for creating per-task documentation files. Each file contains metadata fields (task ID, title, status, dependencies, priority), along with sections for detailed implementation, test strategy, and a plain list of subtasks. The template is to be filled with real values when generating files programmatically from tasks.json. Inputs are extracted task objects and outputs are Markdown/plaintext files for developer reference; there are no enforced validation constraints, so consistency relies on correct file generation code.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/prd.txt#2025-04-23_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n# Task ID: <id>\n# Title: <title>\n# Status: <status>\n# Dependencies: <comma-separated list of dependency IDs>\n# Priority: <priority>\n# Description: <brief description>\n# Details:\n<detailed implementation notes>\n\n# Test Strategy:\n<verification approach>\n\n# Subtasks:\n1. <subtask title> - <subtask description>\n```\n\n----------------------------------------\n\nTITLE: Querying Next Task to Work On\nDESCRIPTION: Command to get guidance on which task to tackle next based on dependencies and priorities.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/examples.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nWhat's the next task I should work on? Please consider dependencies and priorities.\n```\n\n----------------------------------------\n\nTITLE: Verification Procedure Framework\nDESCRIPTION: Framework for defining and executing task verification procedures, including DSL for acceptance criteria and testing framework integration.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_014.txt#2025-04-23_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Clearing Subtasks from Tasks\nDESCRIPTION: Demonstrates how to remove subtasks from specified tasks or all tasks, which is useful for regenerating subtasks with a different approach.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Clear subtasks from a specific task\nnode scripts/dev.js clear-subtasks --id=3\n\n# Clear subtasks from multiple tasks\nnode scripts/dev.js clear-subtasks --id=1,2,3\n\n# Clear subtasks from all tasks\nnode scripts/dev.js clear-subtasks --all\n```\n\n----------------------------------------\n\nTITLE: Image Content Message in JSON\nDESCRIPTION: JSON structure for an image content message in sampling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_29\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"image\",\n  \"data\": \"base64-encoded-image-data\",\n  \"mimeType\": \"image/jpeg\"\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Rejection of Unsupported Protocol Versions\nDESCRIPTION: Tests the client's behavior when encountering an unsupported protocol version. The client should reject the connection attempt with an appropriate error message and close the transport connection.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should reject unsupported protocol version\", async () => {\n  const clientTransport: Transport = {\n    start: jest.fn().mockResolvedValue(undefined),\n    close: jest.fn().mockResolvedValue(undefined),\n    send: jest.fn().mockImplementation((message) => {\n      if (message.method === \"initialize\") {\n        clientTransport.onmessage?.({\n          jsonrpc: \"2.0\",\n          id: message.id,\n          result: {\n            protocolVersion: \"invalid-version\",\n            capabilities: {},\n            serverInfo: {\n              name: \"test\",\n              version: \"1.0\",\n            },\n          },\n        });\n      }\n      return Promise.resolve();\n    }),\n  };\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  await expect(client.connect(clientTransport)).rejects.toThrow(\n    \"Server's protocol version is not supported: invalid-version\",\n  );\n\n  expect(clientTransport.close).toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Client Registration Handler (TypeScript)\nDESCRIPTION: This test suite validates the client registration handler for an OAuth server. It tests handler creation with and without registration support, method restrictions, metadata validation, and successful client registration with different configurations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_61\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { clientRegistrationHandler, ClientRegistrationHandlerOptions } from './register.js';\nimport { OAuthRegisteredClientsStore } from '../clients.js';\nimport { OAuthClientInformationFull, OAuthClientMetadata } from '../../../shared/auth.js';\nimport express from 'express';\nimport supertest from 'supertest';\n\ndescribe('Client Registration Handler', () => {\n  // Mock client store with registration support\n  const mockClientStoreWithRegistration: OAuthRegisteredClientsStore = {\n    async getClient(_clientId: string): Promise<OAuthClientInformationFull | undefined> {\n      return undefined;\n    },\n\n    async registerClient(client: OAuthClientInformationFull): Promise<OAuthClientInformationFull> {\n      // Return the client info as-is in the mock\n      return client;\n    }\n  };\n\n  // Mock client store without registration support\n  const mockClientStoreWithoutRegistration: OAuthRegisteredClientsStore = {\n    async getClient(_clientId: string): Promise<OAuthClientInformationFull | undefined> {\n      return undefined;\n    }\n    // No registerClient method\n  };\n\n  describe('Handler creation', () => {\n    it('throws error if client store does not support registration', () => {\n      const options: ClientRegistrationHandlerOptions = {\n        clientsStore: mockClientStoreWithoutRegistration\n      };\n\n      expect(() => clientRegistrationHandler(options)).toThrow('does not support registering clients');\n    });\n\n    it('creates handler if client store supports registration', () => {\n      const options: ClientRegistrationHandlerOptions = {\n        clientsStore: mockClientStoreWithRegistration\n      };\n\n      expect(() => clientRegistrationHandler(options)).not.toThrow();\n    });\n  });\n\n  describe('Request handling', () => {\n    let app: express.Express;\n    let spyRegisterClient: jest.SpyInstance;\n\n    beforeEach(() => {\n      // Setup express app with registration handler\n      app = express();\n      const options: ClientRegistrationHandlerOptions = {\n        clientsStore: mockClientStoreWithRegistration,\n        clientSecretExpirySeconds: 86400 // 1 day for testing\n      };\n\n      app.use('/register', clientRegistrationHandler(options));\n\n      // Spy on the registerClient method\n      spyRegisterClient = jest.spyOn(mockClientStoreWithRegistration, 'registerClient');\n    });\n\n    afterEach(() => {\n      spyRegisterClient.mockRestore();\n    });\n\n    it('requires POST method', async () => {\n      const response = await supertest(app)\n        .get('/register')\n        .send({\n          redirect_uris: ['https://example.com/callback']\n        });\n\n      expect(response.status).toBe(405);\n      expect(response.headers.allow).toBe('POST');\n      expect(response.body).toEqual({\n        error: \"method_not_allowed\",\n        error_description: \"The method GET is not allowed for this endpoint\"\n      });\n      expect(spyRegisterClient).not.toHaveBeenCalled();\n    });\n\n    it('validates required client metadata', async () => {\n      const response = await supertest(app)\n        .post('/register')\n        .send({\n          // Missing redirect_uris (required)\n          client_name: 'Test Client'\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_client_metadata');\n      expect(spyRegisterClient).not.toHaveBeenCalled();\n    });\n\n    it('validates redirect URIs format', async () => {\n      const response = await supertest(app)\n        .post('/register')\n        .send({\n          redirect_uris: ['invalid-url'] // Invalid URL format\n        });\n\n      expect(response.status).toBe(400);\n      expect(response.body.error).toBe('invalid_client_metadata');\n      expect(response.body.error_description).toContain('redirect_uris');\n      expect(spyRegisterClient).not.toHaveBeenCalled();\n    });\n\n    it('successfully registers client with minimal metadata', async () => {\n      const clientMetadata: OAuthClientMetadata = {\n        redirect_uris: ['https://example.com/callback']\n      };\n\n      const response = await supertest(app)\n        .post('/register')\n        .send(clientMetadata);\n\n      expect(response.status).toBe(201);\n\n      // Verify the generated client information\n      expect(response.body.client_id).toBeDefined();\n      expect(response.body.client_secret).toBeDefined();\n      expect(response.body.client_id_issued_at).toBeDefined();\n      expect(response.body.client_secret_expires_at).toBeDefined();\n      expect(response.body.redirect_uris).toEqual(['https://example.com/callback']);\n\n      // Verify client was registered\n      expect(spyRegisterClient).toHaveBeenCalledTimes(1);\n    });\n\n    it('sets client_secret to undefined for token_endpoint_auth_method=none', async () => {\n      const clientMetadata: OAuthClientMetadata = {\n        redirect_uris: ['https://example.com/callback'],\n        token_endpoint_auth_method: 'none'\n      };\n\n      const response = await supertest(app)\n        .post('/register')\n        .send(clientMetadata);\n\n      expect(response.status).toBe(201);\n      expect(response.body.client_secret).toBeUndefined();\n      expect(response.body.client_secret_expires_at).toBeUndefined();\n    });\n    \n    it('sets client_secret_expires_at for public clients only', async () => {\n      // Test for public client (token_endpoint_auth_method not 'none')\n      const publicClientMetadata: OAuthClientMetadata = {\n        redirect_uris: ['https://example.com/callback'],\n        token_endpoint_auth_method: 'client_secret_basic'\n      };\n\n      const publicResponse = await supertest(app)\n        .post('/register')\n        .send(publicClientMetadata);\n\n      expect(publicResponse.status).toBe(201);\n      expect(publicResponse.body.client_secret).toBeDefined();\n      expect(publicResponse.body.client_secret_expires_at).toBeDefined();\n      \n      // Test for non-public client (token_endpoint_auth_method is 'none')\n      const nonPublicClientMetadata: OAuthClientMetadata = {\n        redirect_uris: ['https://example.com/callback'],\n        token_endpoint_auth_method: 'none'\n      };\n\n      const nonPublicResponse = await supertest(app)\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Meta-Development Script\nDESCRIPTION: This snippet shows the required and optional environment variables used to configure the meta-development script. It includes API keys, model settings, and default values for various script behaviors.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Required Configuration\nANTHROPIC_API_KEY=your_anthropic_api_key\n\n# Optional Configuration\nMODEL=\"claude-3-7-sonnet-20250219\"\nMAX_TOKENS=4000\nTEMPERATURE=0.7\nPERPLEXITY_API_KEY=your_perplexity_api_key\nPERPLEXITY_MODEL=\"sonar-medium-online\"\nDEBUG=false\nLOG_LEVEL=info\nDEFAULT_SUBTASKS=3\nDEFAULT_PRIORITY=medium\nPROJECT_NAME=your_project_name\nPROJECT_VERSION=your_project_version\n```\n\n----------------------------------------\n\nTITLE: Project Initialization Command in Task Master CLI\nDESCRIPTION: Command for initializing a new project with Task Master structure.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# Initialize a new project with Task Master structure\ntask-master init\n```\n\n----------------------------------------\n\nTITLE: JSON Data Structure Design for tests.json\nDESCRIPTION: Proposed schema design for tests.json file that maps tests to tasks/subtasks and tracks coverage metrics. The structure includes test IDs, coverage percentages, test types, and bidirectional relationships with tasks.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_050.txt#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"tests\": {\n    \"testId\": {\n      \"taskId\": \"string\",\n      \"subtaskId\": \"string\",\n      \"type\": \"unit|integration|e2e\",\n      \"coverage\": {\n        \"statements\": \"number\",\n        \"branches\": \"number\",\n        \"functions\": \"number\"\n      },\n      \"filePath\": \"string\",\n      \"timestamp\": \"string\",\n      \"qualityMetrics\": {\n        \"complexity\": \"number\",\n        \"mutationScore\": \"number\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Responding with Root List in MCP\nDESCRIPTION: JSON-RPC response from client to server with the list of available roots.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_100\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"roots\": [\n      {\n        \"uri\": \"file:///home/user/projects/myproject\",\n        \"name\": \"My Project\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vitest Test Environment\nDESCRIPTION: Configuration file for Vitest testing framework with experimental EventSource support.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_60\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from \"vitest/config\";\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      forks: { execArgv: [\"--experimental-eventsource\"] },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Remove Subtask Command Implementation\nDESCRIPTION: Command interface for removing subtasks, showing the structure for either deleting a subtask or converting it to a standalone task.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_025.txt#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// removeSubtask function signature\nfunction removeSubtask(subtaskId, options = { convertToStandalone: false }) {\n  // Validation\n  // Update parent task's subtasks array\n  // Clear parentId if converting to standalone\n}\n```\n\n----------------------------------------\n\nTITLE: Image Content Format in JSON\nDESCRIPTION: JSON format for image content in tool results. This allows tools to return binary image data encoded as base64 along with the appropriate MIME type.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_67\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"image\",\n  \"data\": \"base64-encoded-data\",\n  \"mimeType\": \"image/png\"\n}\n```\n\n----------------------------------------\n\nTITLE: Gradle BOM Configuration for MCP SDK\nDESCRIPTION: Gradle Bill of Materials (BOM) configuration showing how to declare dependency constraints using Maven BOM for version management.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_135\n\nLANGUAGE: groovy\nCODE:\n```\ndependencies {\n  implementation platform(\"io.modelcontextprotocol.sdk:mcp-bom:0.7.0\")\n  //...\n}\n```\n\n----------------------------------------\n\nTITLE: Subtask Update Commands in Task Master CLI\nDESCRIPTION: Commands for appending information to specific subtasks, including research-backed updates using Perplexity AI.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Append additional information to a specific subtask\ntask-master update-subtask --id=<parentId.subtaskId> --prompt=\"<prompt>\"\n\n# Example: Add details about API rate limiting to subtask 2 of task 5\ntask-master update-subtask --id=5.2 --prompt=\"Add rate limiting of 100 requests per minute\"\n\n# Use research-backed updates with Perplexity AI\ntask-master update-subtask --id=<parentId.subtaskId> --prompt=\"<prompt>\" --research\n```\n\n----------------------------------------\n\nTITLE: Log Message Notification in JSON-RPC\nDESCRIPTION: JSON-RPC notification for sending log messages. Servers use this format to send structured log messages with severity levels and contextual data.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_110\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/message\",\n  \"params\": {\n    \"level\": \"error\",\n    \"logger\": \"database\",\n    \"data\": {\n      \"error\": \"Connection failed\",\n      \"details\": {\n        \"host\": \"localhost\",\n        \"port\": 5432\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC Ping Response Format\nDESCRIPTION: Required empty response format for ping requests, with matching request ID.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_76\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"123\",\n  \"result\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Claude for Desktop with MCP Weather Server\nDESCRIPTION: JSON configuration for adding the MCP weather server to Claude for Desktop on MacOS/Linux and Windows.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_92\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"mcpServers\": {\n        \"weather\": {\n            \"command\": \"uv\",\n            \"args\": [\n                \"--directory\",\n                \"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather\",\n                \"run\",\n                \"weather.py\"\n            ]\n        }\n    }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"mcpServers\": {\n        \"weather\": {\n            \"command\": \"uv\",\n            \"args\": [\n                \"--directory\",\n                \"C:\\\\ABSOLUTE\\\\PATH\\\\TO\\\\PARENT\\\\FOLDER\\\\weather\",\n                \"run\",\n                \"weather.py\"\n            ]\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling Classes in TypeScript\nDESCRIPTION: Custom error classes for handling unexpected states and user errors in the MCP implementation. Includes base FastMCPError class and specialized UnexpectedStateError and UserError classes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nabstract class FastMCPError extends Error {\n  public constructor(message?: string) {\n    super(message);\n    this.name = new.target.name;\n  }\n}\n\ntype Extra = unknown;\n\ntype Extras = Record<string, Extra>;\n\nexport class UnexpectedStateError extends FastMCPError {\n  public extras?: Extras;\n\n  public constructor(message: string, extras?: Extras) {\n    super(message);\n    this.name = new.target.name;\n    this.extras = extras;\n  }\n}\n\nexport class UserError extends UnexpectedStateError {}\n```\n\n----------------------------------------\n\nTITLE: Testing Valid Non-Expired Bearer Token Acceptance\nDESCRIPTION: Test case that verifies the middleware correctly accepts valid, non-expired tokens. It creates an AuthInfo object with a future expiration timestamp and verifies the request processing continues.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_81\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should accept non-expired tokens\", async () => {\n  const nonExpiredAuthInfo: AuthInfo = {\n    token: \"valid-token\",\n    clientId: \"client-123\",\n    scopes: [\"read\", \"write\"],\n    expiresAt: Math.floor(Date.now() / 1000) + 3600, // Token expires in an hour\n  };\n  mockVerifyAccessToken.mockResolvedValue(nonExpiredAuthInfo);\n\n  mockRequest.headers = {\n    authorization: \"Bearer valid-token\",\n  };\n\n  const middleware = requireBearerAuth({ provider: mockProvider });\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).toHaveBeenCalledWith(\"valid-token\");\n  expect(mockRequest.auth).toEqual(nonExpiredAuthInfo);\n  expect(nextFunction).toHaveBeenCalled();\n  expect(mockResponse.status).not.toHaveBeenCalled();\n  expect(mockResponse.json).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Weather Project and Installing Dependencies (Windows)\nDESCRIPTION: Creates a new directory for the weather project, initializes an npm project, installs required dependencies, and sets up the initial file structure on Windows.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_95\n\nLANGUAGE: powershell\nCODE:\n```\n# Create a new directory for our project\nmd weather\ncd weather\n\n# Initialize a new npm project\nnpm init -y\n\n# Install dependencies\nnpm install @modelcontextprotocol/sdk zod\nnpm install -D @types/node typescript\n\n# Create our files\nmd src\nnew-item src\\index.ts\n```\n\n----------------------------------------\n\nTITLE: Task File Generation Command in Task Master CLI\nDESCRIPTION: Command for generating individual task files from tasks.json.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Generate individual task files from tasks.json\ntask-master generate\n```\n\n----------------------------------------\n\nTITLE: Viewing MCP Logs in Claude Desktop\nDESCRIPTION: Bash command to view and follow MCP logs in real-time using the tail command on macOS.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_50\n\nLANGUAGE: bash\nCODE:\n```\ntail -n 20 -F ~/Library/Logs/Claude/mcp*.log\n```\n\n----------------------------------------\n\nTITLE: Declaring Logging Capability in JSON\nDESCRIPTION: JSON configuration for declaring the logging capability in a server. Servers that emit log message notifications must declare this capability.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_108\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"logging\": {}\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Session Data in Tools\nDESCRIPTION: Example of using authenticated session data within tool execution context.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\nserver.addTool({\n  name: \"sayHello\",\n  execute: async (args, { session }) => {\n    return `Hello, ${session.id}!`;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuth Client Registration Handler in TypeScript\nDESCRIPTION: A complete implementation of an OAuth 2.0 dynamic client registration endpoint. Handles client metadata validation, generates client credentials, supports public and confidential clients, and includes rate limiting and CORS configuration.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nexport function clientRegistrationHandler({\n  clientsStore,\n  clientSecretExpirySeconds = DEFAULT_CLIENT_SECRET_EXPIRY_SECONDS,\n  rateLimit: rateLimitConfig\n}: ClientRegistrationHandlerOptions): RequestHandler {\n  if (!clientsStore.registerClient) {\n    throw new Error(\"Client registration store does not support registering clients\");\n  }\n\n  const router = express.Router();\n  router.use(cors());\n  router.use(allowedMethods([\"POST\"]));\n  router.use(express.json());\n\n  if (rateLimitConfig !== false) {\n    router.use(rateLimit({\n      windowMs: 60 * 60 * 1000,\n      max: 20,\n      standardHeaders: true,\n      legacyHeaders: false,\n      message: new TooManyRequestsError('You have exceeded the rate limit for client registration requests').toResponseObject(),\n      ...rateLimitConfig\n    }));\n  }\n\n  router.post(\"/\", async (req, res) => {\n    res.setHeader('Cache-Control', 'no-store');\n    try {\n      const parseResult = OAuthClientMetadataSchema.safeParse(req.body);\n      if (!parseResult.success) {\n        throw new InvalidClientMetadataError(parseResult.error.message);\n      }\n      const clientMetadata = parseResult.data;\n      const isPublicClient = clientMetadata.token_endpoint_auth_method === 'none'\n      const clientId = crypto.randomUUID();\n      const clientSecret = isPublicClient ? undefined : crypto.randomBytes(32).toString('hex');\n      const clientIdIssuedAt = Math.floor(Date.now() / 1000);\n      const clientsDoExpire = clientSecretExpirySeconds > 0\n      const secretExpiryTime = clientsDoExpire ? clientIdIssuedAt + clientSecretExpirySeconds : 0\n      const clientSecretExpiresAt = isPublicClient ? undefined : secretExpiryTime\n      let clientInfo: OAuthClientInformationFull = {\n        ...clientMetadata,\n        client_id: clientId,\n        client_secret: clientSecret,\n        client_id_issued_at: clientIdIssuedAt,\n        client_secret_expires_at: clientSecretExpiresAt,\n      };\n      clientInfo = await clientsStore.registerClient!(clientInfo);\n      res.status(201).json(clientInfo);\n    } catch (error) {\n      if (error instanceof OAuthError) {\n        const status = error instanceof ServerError ? 500 : 400;\n        res.status(status).json(error.toResponseObject());\n      } else {\n        console.error(\"Unexpected error registering client:\", error);\n        const serverError = new ServerError(\"Internal Server Error\");\n        res.status(500).json(serverError.toResponseObject());\n      }\n    }\n  });\n  return router;\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Command Options in commands.js\nDESCRIPTION: Update to add the --context-file option to the contextOptions array in commands.js, enabling file-based context support for AI commands\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_026.txt#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ncontextOptions.push({\n  name: '--context-file',\n  description: 'Specify a file to use as context for AI operations',\n  requiresValue: true\n});\n```\n\n----------------------------------------\n\nTITLE: Paginated Request Format in JSON-RPC\nDESCRIPTION: Shows the request format for continuing pagination. The client includes the cursor received from the previous response to fetch the next page of results.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_39\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"resources/list\",\n  \"params\": {\n    \"cursor\": \"eyJwYWdlIjogMn0=\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Sampling Capability in JSON\nDESCRIPTION: JSON snippet showing how clients declare support for the sampling capability during initialization.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_25\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"sampling\": {}\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updated Import Pattern for Prompts\nDESCRIPTION: Demonstrates how functions should import prompts from the centralized location after refactoring\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_048.txt#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { taskSuggestionPrompt } from '../prompts';\n\nfunction suggestTask() {\n  // Use imported prompt\n  return taskSuggestionPrompt;\n}\n```\n\n----------------------------------------\n\nTITLE: Paginated Response Format in JSON-RPC\nDESCRIPTION: JSON-RPC response containing paginated results with a cursor for retrieving the next page. Used for operations that may return large result sets.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_112\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"123\",\n  \"result\": {\n    \"resources\": [...],\n    \"nextCursor\": \"eyJwYWdlIjogM30=\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sampling Error Response in JSON\nDESCRIPTION: JSON structure for an error response in sampling requests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_31\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"error\": {\n    \"code\": -1,\n    \"message\": \"User rejected sampling request\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying the Tasks Collection Model - JSON\nDESCRIPTION: This snippet defines the overall structure of the tasks.json file, including project-level metadata and an array of task objects. It is foundational for the system, requiring valid JSON structure, and should be kept up to date as tasks and project status evolve. Dependencies include the individual Task Model schema, and parameters such as meta information (projectName, version, timestamps) are required for proper context. Tasks array is intended to contain zero or more Task Model objects.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/prd.txt#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"meta\": {\n    \"projectName\": \"Project Name\",\n    \"version\": \"1.0.0\",\n    \"prdSource\": \"path/to/prd.txt\",\n    \"createdAt\": \"ISO-8601 timestamp\",\n    \"updatedAt\": \"ISO-8601 timestamp\"\n  },\n  \"tasks\": [\n    // Array of Task objects\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Java MCP Client Dependencies\nDESCRIPTION: XML configuration in pom.xml for Spring AI MCP client and Anthropic integration, showing the required dependencies for implementing a Java-based MCP client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_81\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\n    <groupId>org.springframework.ai</groupId>\n    <artifactId>spring-ai-mcp-client-spring-boot-starter</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.ai</groupId>\n    <artifactId>spring-ai-anthropic-spring-boot-starter</artifactId>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Markdown PRD Template Structure\nDESCRIPTION: A markdown template outlining the structure for a comprehensive product requirements document, including sections for overview, core features, user experience, technical architecture, development roadmap, dependency chains, risks, and appendix.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/example_prd.txt#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Overview  \n[Provide a high-level overview of your product here. Explain what problem it solves, who it's for, and why it's valuable.]\n\n# Core Features  \n[List and describe the main features of your product. For each feature, include:\n- What it does\n- Why it's important\n- How it works at a high level]\n\n# User Experience  \n[Describe the user journey and experience. Include:\n- User personas\n- Key user flows\n- UI/UX considerations]\n\n# Technical Architecture  \n[Outline the technical implementation details:\n- System components\n- Data models\n- APIs and integrations\n- Infrastructure requirements]\n\n# Development Roadmap  \n[Break down the development process into phases:\n- MVP requirements\n- Future enhancements\n- Do not think about timelines whatsoever -- all that matters is scope and detailing exactly what needs to be build in each phase so it can later be cut up into tasks]\n\n# Logical Dependency Chain\n[Define the logical order of development:\n- Which features need to be built first (foundation)\n- Getting as quickly as possible to something usable/visible front end that works\n- Properly pacing and scoping each feature so it is atomic but can also be built upon and improved as development approaches]\n\n# Risks and Mitigations  \n[Identify potential risks and how they'll be addressed:\n- Technical challenges\n- Figuring out the MVP that we can build upon\n- Resource constraints]\n\n# Appendix  \n[Include any additional information:\n- Research findings\n- Technical specifications]\n```\n\n----------------------------------------\n\nTITLE: Initializing New Project with Claude Task Master\nDESCRIPTION: Command to start a new project by having Claude parse a PRD and set up initial tasks.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/examples.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nI've just initialized a new project with Claude Task Master. I have a PRD at scripts/prd.txt.\nCan you help me parse it and set up the initial tasks?\n```\n\n----------------------------------------\n\nTITLE: Resource Registration Method Overloads\nDESCRIPTION: Multiple method signatures for registering resources with different parameter combinations including name, URI, template patterns, and metadata.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_147\n\nLANGUAGE: typescript\nCODE:\n```\nresource(name: string, uri: string, readCallback: ReadResourceCallback): void;\n\n  resource(\n    name: string,\n    uri: string,\n    metadata: ResourceMetadata,\n    readCallback: ReadResourceCallback,\n  ): void;\n\n  resource(\n    name: string,\n    template: ResourceTemplate,\n    readCallback: ReadResourceTemplateCallback,\n  ): void;\n\n  resource(\n    name: string,\n    template: ResourceTemplate,\n    metadata: ResourceMetadata,\n    readCallback: ReadResourceTemplateCallback,\n  ): void;\n```\n\n----------------------------------------\n\nTITLE: List Changed Notification\nDESCRIPTION: JSON-RPC notification sent by servers when the list of available resources changes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_55\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/resources/list_changed\"\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Server Request Cancellation\nDESCRIPTION: Tests the server's ability to handle request cancellation using AbortController, specifically for message creation requests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_112\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should handle server cancelling a request\", async () => {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  client.setRequestHandler(\n    CreateMessageRequestSchema,\n    async (_request, extra) => {\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n      return {\n        model: \"test\",\n        role: \"assistant\",\n        content: {\n          type: \"text\",\n          text: \"Test response\",\n        },\n      };\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n\n  await Promise.all([\n    client.connect(clientTransport),\n    server.connect(serverTransport),\n  ]);\n\n  const controller = new AbortController();\n\n  const createMessagePromise = server.createMessage(\n    {\n      messages: [],\n      maxTokens: 10,\n    },\n    {\n      signal: controller.signal,\n    },\n  );\n  controller.abort(\"Cancelled by test\");\n\n  await expect(createMessagePromise).rejects.toBe(\"Cancelled by test\");\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Weather Tools for MCP Server\nDESCRIPTION: Registers two tools with the MCP server: 'get-alerts' for retrieving weather alerts for a state, and 'get-forecast' for obtaining weather forecasts for a specific location.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_100\n\nLANGUAGE: typescript\nCODE:\n```\nserver.tool(\n  \"get-alerts\",\n  \"Get weather alerts for a state\",\n  {\n    state: z.string().length(2).describe(\"Two-letter state code (e.g. CA, NY)\"),\n  },\n  async ({ state }) => {\n    const stateCode = state.toUpperCase();\n    const alertsUrl = `${NWS_API_BASE}/alerts?area=${stateCode}`;\n    const alertsData = await makeNWSRequest<AlertsResponse>(alertsUrl);\n\n    if (!alertsData) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Failed to retrieve alerts data\",\n          },\n        ],\n      };\n    }\n\n    const features = alertsData.features || [];\n    if (features.length === 0) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `No active alerts for ${stateCode}`,\n          },\n        ],\n      };\n    }\n\n    const formattedAlerts = features.map(formatAlert);\n    const alertsText = `Active alerts for ${stateCode}:\\n\\n${formattedAlerts.join(\"\\n\")}`;\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: alertsText,\n        },\n      ],\n    };\n  },\n);\n\nserver.tool(\n  \"get-forecast\",\n  \"Get weather forecast for a location\",\n  {\n    latitude: z.number().min(-90).max(90).describe(\"Latitude of the location\"),\n    longitude: z.number().min(-180).max(180).describe(\"Longitude of the location\"),\n  },\n  async ({ latitude, longitude }) => {\n    // Get grid point data\n    const pointsUrl = `${NWS_API_BASE}/points/${latitude.toFixed(4)},${longitude.toFixed(4)}`;\n    const pointsData = await makeNWSRequest<PointsResponse>(pointsUrl);\n\n    if (!pointsData) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: `Failed to retrieve grid point data for coordinates: ${latitude}, ${longitude}. This location may not be supported by the NWS API (only US locations are supported).`,\n          },\n        ],\n      };\n    }\n\n    const forecastUrl = pointsData.properties?.forecast;\n    if (!forecastUrl) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Failed to get forecast URL from grid point data\",\n          },\n        ],\n      };\n    }\n\n    // Get forecast data\n    const forecastData = await makeNWSRequest<ForecastResponse>(forecastUrl);\n    if (!forecastData) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"Failed to retrieve forecast data\",\n          },\n        ],\n      };\n    }\n\n    const periods = forecastData.properties?.periods || [];\n    if (periods.length === 0) {\n      return {\n        content: [\n          {\n            type: \"text\",\n            text: \"No forecast periods available\",\n          },\n        ],\n      };\n    }\n\n    // Format forecast periods\n    const formattedForecast = periods.map((period: ForecastPeriod) =>\n      [\n        `${period.name || \"Unknown\"}:`,\n        `Temperature: ${period.temperature || \"Unknown\"}°${period.temperatureUnit || \"F\"}`,\n        `Wind: ${period.windSpeed || \"Unknown\"} ${period.windDirection || \"\"}`,\n        `${period.shortForecast || \"No forecast available\"}`,\n        \"---\",\n      ].join(\"\\n\"),\n    );\n\n    const forecastText = `Forecast for ${latitude}, ${longitude}:\\n\\n${formattedForecast.join(\"\\n\")}`;\n\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: forecastText,\n        },\n      ],\n    };\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: License Structure Implementation Steps\nDESCRIPTION: Markdown document outlining the detailed steps required to implement a dual license structure, including removal of MIT license, creation of new license files, and source code updates.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_039.txt#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n1. Remove all instances of the MIT license from the codebase, including any MIT license files, headers in source files, and references in documentation.\n\n2. Create a dual license structure with:\n   - Business Source License (BSL) 1.1 or similar for commercial use, explicitly stating that commercial rights are exclusively reserved for Ralph & Eyal\n   - Apache 2.0 for non-commercial use, allowing the community to use, modify, and distribute the code for non-commercial purposes\n\n3. Update the license field in package.json to reflect the dual license structure (e.g., \"BSL 1.1 / Apache 2.0\")\n```\n\n----------------------------------------\n\nTITLE: Completion Response in JSON\nDESCRIPTION: JSON response containing completion suggestions for the requested argument.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_33\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"completion\": {\n      \"values\": [\"python\", \"pytorch\", \"pyside\"],\n      \"total\": 10,\n      \"hasMore\": true\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Ping Request/Response Sequence Diagram (Mermaid) - Mermaid\nDESCRIPTION: A Mermaid sequence diagram visualizing a ping request/response interaction between a sender and receiver. Illustrates the typical flow: a ping message is sent and an empty response is returned, confirming liveness. Intended to clarify implementation and troubleshooting for protocol designers. Inputs/outputs are not depicted as data, but rather as message flow in the diagram. Mermaid rendering required.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_6\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\\n    participant Sender\\n    participant Receiver\\n\\n    Sender->>Receiver: ping request\\n    Receiver->>Sender: empty response\n```\n\n----------------------------------------\n\nTITLE: Testing StdioClientTransport in TypeScript\nDESCRIPTION: Unit test that verifies the StdioClientTransport can start and close cleanly. It creates a transport instance, sets up error handling, and checks that close callback is called.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_44\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should start then close cleanly\", async () => {\n  const client = new StdioClientTransport(serverParameters);\n  client.onerror = (error) => {\n    throw error;\n  };\n\n  let didClose = false;\n  client.onclose = () => {\n    didClose = true;\n  };\n\n  await client.start();\n  expect(didClose).toBeFalsy();\n  await client.close();\n  expect(didClose).toBeTruthy();\n});\n```\n\n----------------------------------------\n\nTITLE: Generating Card Links for Protocol Components in Hugo\nDESCRIPTION: This snippet uses Hugo shortcodes to create a card-based navigation for different components of the Model Context Protocol specification. Each card links to a specific section of the documentation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_139\n\nLANGUAGE: markdown\nCODE:\n```\n{{< cards >}}\n{{< card link=\"architecture\" title=\"Architecture\" icon=\"template\" >}}\n{{< card link=\"basic\" title=\"Base Protocol\" icon=\"code\" >}}\n{{< card link=\"server\" title=\"Server Features\" icon=\"server\" >}}\n{{< card link=\"client\" title=\"Client Features\" icon=\"user\" >}}\n{{< card link=\"contributing\" title=\"Contributing\" icon=\"pencil\" >}}\n{{< /cards >}}\n```\n\n----------------------------------------\n\nTITLE: Validating Task Dependencies - task-master CLI - Bash\nDESCRIPTION: Demonstrates how to use the task-master CLI to audit existing dependencies within the tasks.json or a custom task file. The commands check for invalid dependencies, self-dependencies, and provide a diagnostic report without modifying any files. The optional --file flag allows analysis on alternate task configurations. Requires task-master installed in the system PATH and a properly formatted tasks JSON file as input. Outputs the validation summary to the terminal; no file output is produced.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Check for invalid dependencies in tasks.json\\ntask-master validate-dependencies\\n\\n# Specify a different tasks file\\ntask-master validate-dependencies --file=custom-tasks.json\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for MCP Server\nDESCRIPTION: JSON configuration example for specifying environment variables for an MCP server in Claude Desktop's claude_desktop_config.json file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_53\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"myserver\": {\n    \"command\": \"mcp-server-myapp\",\n    \"env\": {\n      \"MYAPP_API_KEY\": \"some_key\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Task Master Show Commands\nDESCRIPTION: Commands for displaying specific task or subtask details.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README-task-master.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Show details of a specific task\ntask-master show <id>\n# or\ntask-master show --id=<id>\n\n# View a specific subtask (e.g., subtask 2 of task 1)\ntask-master show 1.2\n```\n\n----------------------------------------\n\nTITLE: Installing FastMCP Package\nDESCRIPTION: Command to install the FastMCP package using npm package manager.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_49\n\nLANGUAGE: bash\nCODE:\n```\nnpm install fastmcp\n```\n\n----------------------------------------\n\nTITLE: Registering Resources with Metadata in MCP Server\nDESCRIPTION: Tests resource registration with additional metadata like description and MIME type. This demonstrates how resources can include richer metadata for better client discovery and display.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_125\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should register resource with metadata\", async () => {\n    const mcpServer = new McpServer({\n      name: \"test server\",\n      version: \"1.0\",\n    });\n    const client = new Client({\n      name: \"test client\",\n      version: \"1.0\",\n    });\n\n    mcpServer.resource(\n      \"test\",\n      \"test://resource\",\n      {\n        description: \"Test resource\",\n        mimeType: \"text/plain\",\n      },\n      async () => ({\n        contents: [\n          {\n            uri: \"test://resource\",\n            text: \"Test content\",\n          },\n        ],\n      }),\n    );\n\n    const [clientTransport, serverTransport] =\n      InMemoryTransport.createLinkedPair();\n\n    await Promise.all([\n      client.connect(clientTransport),\n      mcpServer.server.connect(serverTransport),\n    ]);\n\n    const result = await client.request(\n      {\n        method: \"resources/list\",\n      },\n      ListResourcesResultSchema,\n    );\n\n    expect(result.resources).toHaveLength(1);\n    expect(result.resources[0].description).toBe(\"Test resource\");\n    expect(result.resources[0].mimeType).toBe(\"text/plain\");\n  });\n```\n\n----------------------------------------\n\nTITLE: Registering Synchronous Calculator Tool in Java MCP SDK\nDESCRIPTION: Creates a synchronous tool registration for a basic calculator with a JSON schema defining operations and numeric parameters. The tool is registered with a name, description, schema, and implementation function that returns calculation results.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_144\n\nLANGUAGE: java\nCODE:\n```\n// Sync tool registration\nvar schema = \"\"\"\n            {\n              \"type\" : \"object\",\n              \"id\" : \"urn:jsonschema:Operation\",\n              \"properties\" : {\n                \"operation\" : {\n                  \"type\" : \"string\"\n                },\n                \"a\" : {\n                  \"type\" : \"number\"\n                },\n                \"b\" : {\n                  \"type\" : \"number\"\n                }\n              }\n            }\n            \"\"\";\nvar syncToolRegistration = new McpServerFeatures.SyncToolRegistration(\n    new Tool(\"calculator\", \"Basic calculator\", schema),\n    arguments -> {\n        // Tool implementation\n        return new CallToolResult(result, false);\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Python MCP Weather Project\nDESCRIPTION: Commands to create a new project directory, set up a virtual environment, install dependencies, and create the main Python file for the MCP weather server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_87\n\nLANGUAGE: bash\nCODE:\n```\n# Create a new directory for our project\nuv init weather\ncd weather\n\n# Create virtual environment and activate it\nuv venv\nsource .venv/bin/activate\n\n# Install dependencies\nuv add \"mcp[cli]\" httpx\n\n# Create our server file\ntouch weather.py\n```\n\nLANGUAGE: powershell\nCODE:\n```\n# Create a new directory for our project\nuv init weather\ncd weather\n\n# Create virtual environment and activate it\nuv venv\n.venv\\Scripts\\activate\n\n# Install dependencies\nuv add mcp[cli] httpx\n\n# Create our server file\nnew-item weather.py\n```\n\n----------------------------------------\n\nTITLE: CLI Command Format\nDESCRIPTION: The command format for the new subtask suggestion feature that takes a task ID as a parameter.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_053.txt#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsuggest-subtask <task-id>\n```\n\n----------------------------------------\n\nTITLE: Research Cache Management Structure - JavaScript\nDESCRIPTION: Database and caching system structure for managing research results and history.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_051.txt#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// Research results database\n// Cache retrieval and validation\n// History management commands\n// Task association functionality\n```\n\n----------------------------------------\n\nTITLE: MCP Server Configuration for Brave Search\nDESCRIPTION: JSON configuration for MCP server setup, specifying the command, arguments, and environment variables needed to run the Brave Search MCP server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_83\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"brave-search\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"@modelcontextprotocol/server-brave-search\"\n      ],\n      \"env\": {\n        \"BRAVE_API_KEY\": \"<PUT YOUR BRAVE API KEY>\"\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Package Update Command for User Notification\nDESCRIPTION: The command that should be displayed to users in the upgrade notification, allowing them to easily update to the latest version of the package.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_038.txt#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nnpm i task-master-ai@latest\n```\n\n----------------------------------------\n\nTITLE: Implementing SSE Error Class for SSE Client Transport in TypeScript\nDESCRIPTION: Defines a custom error class for SSE transport errors that captures the error code, message, and original event object.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nexport class SseError extends Error {\n  constructor(\n    public readonly code: number | undefined,\n    message: string | undefined,\n    public readonly event: ErrorEvent,\n  ) {\n    super(`SSE error: ${message}`);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Abstract Capability Check Methods\nDESCRIPTION: Abstract methods that must be implemented by subclasses to check if capabilities are supported for various operations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_174\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * A method to check if a capability is supported by the remote side, for the given method to be called.\n *\n * This should be implemented by subclasses.\n */\nprotected abstract assertCapabilityForMethod(\n  method: SendRequestT[\"method\"],\n): void;\n\n/**\n * A method to check if a notification is supported by the local side, for the given method to be sent.\n *\n * This should be implemented by subclasses.\n */\nprotected abstract assertNotificationCapability(\n  method: SendNotificationT[\"method\"],\n): void;\n\n/**\n * A method to check if a request handler is supported by the local side, for the given method to be handled.\n *\n * This should be implemented by subclasses.\n */\nprotected abstract assertRequestHandlerCapability(method: string): void;\n```\n\n----------------------------------------\n\nTITLE: Running CLI Commands for Meta-Development Script\nDESCRIPTION: This snippet demonstrates how to run various CLI commands using the meta-development script. It shows both global and local usage patterns for executing commands like initializing a project, parsing PRDs, listing tasks, and more.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# If installed globally\ntask-master [command] [options]\n\n# If using locally within the project\nnode scripts/dev.js [command] [options]\n```\n\n----------------------------------------\n\nTITLE: Standardizing Naming Conventions for MCP Server - Node.js JavaScript\nDESCRIPTION: Outlines a linting/documentation/code refactor approach for naming conventions in a Node.js MCP server, including converting all file names to kebab-case, function names to camelCase with Direct or Tool suffixes, and MCP tool names to snake_case. Also integrates linting rules, registration consistency, and update procedures in test and documentation files.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Example: Standard naming pattern\ndefineTool('analyze_task', /* camelCase in code, snake_case externally */)\nfunction addSubtaskDirect() { /* ... */ }\nfunction registerAddSubtaskTool(server) { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: TypeScript Configuration - tsconfig.json\nDESCRIPTION: TypeScript compiler configuration for the project.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_73\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./build\",\n    \"rootDir\": \"./\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"index.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Domain-Specific Research Templates Task Definition\nDESCRIPTION: Markdown specification for creating specialized prompt templates for different software development domains, including template selection mechanism based on context.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_010.txt#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## 1. Design Domain-Specific Research Prompt Templates [done]\n### Dependencies: None\n### Description: Create a set of specialized prompt templates for different software development domains (e.g., web development, mobile, data science, DevOps). Each template should be structured to extract relevant best practices, libraries, tools, and implementation patterns from Perplexity API. Implement a prompt template selection mechanism based on the task context and domain.\n```\n\n----------------------------------------\n\nTITLE: Implementing Tools in Python MCP Server\nDESCRIPTION: Demonstrates how to implement tools in a Python MCP server. It includes defining available tools and handling tool execution.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_29\n\nLANGUAGE: python\nCODE:\n```\napp = Server(\"example-server\")\n\n@app.list_tools()\nasync def list_tools() -> list[types.Tool]:\n    return [\n        types.Tool(\n            name=\"calculate_sum\",\n            description=\"Add two numbers together\",\n            inputSchema={\n                \"type\": \"object\",\n                \"properties\": {\n                    \"a\": {\"type\": \"number\"},\n                    \"b\": {\"type\": \"number\"}\n                },\n                \"required\": [\"a\", \"b\"]\n            }\n        )\n    ]\n\n@app.call_tool()\nasync def call_tool(\n    name: str,\n    arguments: dict\n) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:\n    if name == \"calculate_sum\":\n        a = arguments[\"a\"]\n        b = arguments[\"b\"]\n        result = a + b\n        return [types.TextContent(type=\"text\", text=str(result))]\n    raise ValueError(f\"Tool not found: {name}\")\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting Task Master Initialization\nDESCRIPTION: Bash commands for troubleshooting when 'task-master init' doesn't respond. Provides alternative methods to run the initialization script directly using Node.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnode node_modules/claude-task-master/scripts/init.js\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/eyaltoledano/claude-task-master.git\ncd claude-task-master\nnode scripts/init.js\n```\n\n----------------------------------------\n\nTITLE: Testing CLI and MCP Feature Usage via Shell Commands\nDESCRIPTION: Provides example shell commands for testing a new feature ('new-feature') through both the command-line interface (using `node scripts/dev.js`) and the MCP interface (using a test script `node mcp-server/tests/test-command.js`). This ensures the feature works correctly in both contexts.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/MCP_INTEGRATION.md#2025-04-23_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n// Test CLI usage\nnode scripts/dev.js new-feature --param1=test --param2=123\n\n// Test MCP usage\nnode mcp-server/tests/test-command.js newFeature\n```\n\n----------------------------------------\n\nTITLE: Round-Table Discussion Output Format\nDESCRIPTION: Template for round-table.txt output file containing discussion transcript and insights\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_060.txt#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"prompt\": \"string\",\n  \"taskIds\": [\"string\"],\n  \"discussion\": [\n    {\n      \"mentor\": \"string\",\n      \"message\": \"string\"\n    }\n  ],\n  \"recommendations\": [\"string\"],\n  \"insights\": [\"string\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Context Extraction Utility Structure - JavaScript\nDESCRIPTION: File structure and core functions for extracting context from tasks and subtasks to enhance research queries.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_051.txt#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nutils/contextExtractor.js\n\nextractTaskContext(taskId)\n```\n\n----------------------------------------\n\nTITLE: Complexity Report Viewing Commands in Task Master CLI\nDESCRIPTION: Commands for viewing task complexity analysis reports.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n# Display the task complexity analysis report\ntask-master complexity-report\n\n# View a report at a custom location\ntask-master complexity-report --file=my-report.json\n```\n\n----------------------------------------\n\nTITLE: Testing TypeScript Type Checking for Custom Schemas\nDESCRIPTION: Tests the TypeScript type system support for custom request, notification, and result schemas. This test defines custom weather-related schemas and verifies that they can be used with the Client class for type safety.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should typecheck\", () => {\n  const GetWeatherRequestSchema = RequestSchema.extend({\n    method: z.literal(\"weather/get\"),\n    params: z.object({\n      city: z.string(),\n    }),\n  });\n\n  const GetForecastRequestSchema = RequestSchema.extend({\n    method: z.literal(\"weather/forecast\"),\n    params: z.object({\n      city: z.string(),\n      days: z.number(),\n    }),\n  });\n\n  const WeatherForecastNotificationSchema = NotificationSchema.extend({\n    method: z.literal(\"weather/alert\"),\n    params: z.object({\n      severity: z.enum([\"warning\", \"watch\"]),\n      message: z.string(),\n    }),\n  });\n\n  const WeatherRequestSchema = GetWeatherRequestSchema.or(\n    GetForecastRequestSchema,\n  );\n  const WeatherNotificationSchema = WeatherForecastNotificationSchema;\n  const WeatherResultSchema = ResultSchema.extend({\n    temperature: z.number(),\n    conditions: z.string(),\n  });\n\n  type WeatherRequest = z.infer<typeof WeatherRequestSchema>;\n  type WeatherNotification = z.infer<typeof WeatherNotificationSchema>;\n  type WeatherResult = z.infer<typeof WeatherResultSchema>;\n\n  // Create a typed Client for weather data\n  const weatherClient = new Client<\n    WeatherRequest,\n    WeatherNotification,\n    WeatherResult\n  >(\n    {\n      name: \"WeatherClient\",\n      version: \"1.0.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  // Typecheck that only valid weather requests/notifications/results are allowed\n  false &&\n    weatherClient.request(\n      {\n        method: \"weather/get\",\n        params: {\n          city: \"Seattle\",\n        },\n      },\n      WeatherResultSchema,\n    );\n\n  false &&\n    weatherClient.notification({\n      method: \"weather/alert\",\n      params: {\n        severity: \"warning\",\n        message: \"Storm approaching\",\n      },\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Helper Functions for Weather API in Python\nDESCRIPTION: Python functions to make requests to the National Weather Service API and format alert data.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_89\n\nLANGUAGE: python\nCODE:\n```\nasync def make_nws_request(url: str) -> dict[str, Any] | None:\n    \"\"\"Make a request to the NWS API with proper error handling.\"\"\"\n    headers = {\n        \"User-Agent\": USER_AGENT,\n        \"Accept\": \"application/geo+json\"\n    }\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url, headers=headers, timeout=30.0)\n            response.raise_for_status()\n            return response.json()\n        except Exception:\n            return None\n\ndef format_alert(feature: dict) -> str:\n    \"\"\"Format an alert feature into a readable string.\"\"\"\n    props = feature[\"properties\"]\n    return f\"\"\"\nEvent: {props.get('event', 'Unknown')}\nArea: {props.get('areaDesc', 'Unknown')}\nSeverity: {props.get('severity', 'Unknown')}\nDescription: {props.get('description', 'No description available')}\nInstructions: {props.get('instruction', 'No specific instructions provided')}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Progress Sequence Diagram\nDESCRIPTION: Mermaid sequence diagram showing the complete progress notification flow including updates.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_80\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Sender\n    participant Receiver\n\n    Note over Sender,Receiver: Request with progress token\n    Sender->>Receiver: Method request with progressToken\n\n    Note over Sender,Receiver: Progress updates\n    loop Progress Updates\n        Receiver-->>Sender: Progress notification (0.2/1.0)\n        Receiver-->>Sender: Progress notification (0.6/1.0)\n        Receiver-->>Sender: Progress notification (1.0/1.0)\n    end\n\n    Note over Sender,Receiver: Operation complete\n    Receiver->>Sender: Method response\n```\n\n----------------------------------------\n\nTITLE: Finding Project Root Using find-up Package in JavaScript\nDESCRIPTION: Demonstrates how to use the find-up package to efficiently detect a project root directory by searching for package.json files. This approach is recommended for handling npm package path resolution.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst findUp = require('find-up');\nconst projectRoot = await findUp(dir => findUp.sync('package.json', { cwd: dir }));\n```\n\n----------------------------------------\n\nTITLE: Initializing a New Task Master AI Project - Bash\nDESCRIPTION: This snippet demonstrates project initialization with Task Master AI after npm installation. Depending on whether the package is installed globally or locally, either the global command (task-master init) or the local npx variant (npx task-master-init) is used. Execution prompts for project configuration and creates the necessary directory structure and config files.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# If installed globally\ntask-master init\n\n# If installed locally\nnpx task-master-init\n```\n\n----------------------------------------\n\nTITLE: Testing message reading with StdioClientTransport in TypeScript\nDESCRIPTION: Unit test that verifies the StdioClientTransport can correctly send and receive JSON-RPC messages. It sets up the transport, sends test messages, and verifies they are received correctly.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_45\n\nLANGUAGE: TypeScript\nCODE:\n```\ntest(\"should read messages\", async () => {\n  const client = new StdioClientTransport(serverParameters);\n  client.onerror = (error) => {\n    throw error;\n  };\n\n  const messages: JSONRPCMessage[] = [\n    {\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"ping\",\n    },\n    {\n      jsonrpc: \"2.0\",\n      method: \"notifications/initialized\",\n    },\n  ];\n\n  const readMessages: JSONRPCMessage[] = [];\n  const finished = new Promise<void>((resolve) => {\n    client.onmessage = (message) => {\n      readMessages.push(message);\n\n      if (JSON.stringify(message) === JSON.stringify(messages[1])) {\n        resolve();\n      }\n    };\n  });\n\n  await client.start();\n  await client.send(messages[0]);\n  await client.send(messages[1]);\n  await finished;\n  expect(readMessages).toEqual(messages);\n\n  await client.close();\n});\n```\n\n----------------------------------------\n\nTITLE: JSON Error Response Example in MCP\nDESCRIPTION: Example JSON-RPC error response format for resource not found errors, showing standard error code -32002 with a message and additional data payload.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_58\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 5,\n  \"error\": {\n    \"code\": -32002,\n    \"message\": \"Resource not found\",\n    \"data\": {\n      \"uri\": \"file:///nonexistent.txt\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Router Creation in Jest\nDESCRIPTION: Test suite for validating router creation with different configuration options. Tests ensure that the router enforces HTTPS for production URLs and proper URL format with no fragments or query strings.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_100\n\nLANGUAGE: TypeScript\nCODE:\n```\ndescribe('Router creation', () => {\n  it('throws error for non-HTTPS issuer URL', () => {\n    const options: AuthRouterOptions = {\n      provider: mockProvider,\n      issuerUrl: new URL('http://auth.example.com')\n    };\n\n    expect(() => mcpAuthRouter(options)).toThrow('Issuer URL must be HTTPS');\n  });\n\n  it('allows localhost HTTP for development', () => {\n    const options: AuthRouterOptions = {\n      provider: mockProvider,\n      issuerUrl: new URL('http://localhost:3000')\n    };\n\n    expect(() => mcpAuthRouter(options)).not.toThrow();\n  });\n\n  it('throws error for issuer URL with fragment', () => {\n    const options: AuthRouterOptions = {\n      provider: mockProvider,\n      issuerUrl: new URL('https://auth.example.com#fragment')\n    };\n\n    expect(() => mcpAuthRouter(options)).toThrow('Issuer URL must not have a fragment');\n  });\n\n  it('throws error for issuer URL with query string', () => {\n    const options: AuthRouterOptions = {\n      provider: mockProvider,\n      issuerUrl: new URL('https://auth.example.com?param=value')\n    };\n\n    expect(() => mcpAuthRouter(options)).toThrow('Issuer URL must not have a query string');\n  });\n\n  it('successfully creates router with valid options', () => {\n    const options: AuthRouterOptions = {\n      provider: mockProvider,\n      issuerUrl: new URL('https://auth.example.com')\n    };\n\n    expect(() => mcpAuthRouter(options)).not.toThrow();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Task Master via NPM\nDESCRIPTION: Commands for installing the Task Master package either globally or locally within a project.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README-task-master.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Install globally\nnpm install -g task-master-ai\n\n# OR install locally within your project\nnpm install task-master-ai\n```\n\n----------------------------------------\n\nTITLE: Research Query Implementation Task Definition\nDESCRIPTION: Markdown specification for implementing Perplexity API integration, including query execution, response processing, and error handling mechanisms.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_010.txt#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n## 2. Implement Research Query Execution and Response Processing [done]\n### Dependencies: None\n### Description: Build a module that executes research queries using the Perplexity API integration. This should include sending the domain-specific prompts, handling the API responses, and parsing the results into a structured format that can be used for context enrichment. Implement error handling, rate limiting, and fallback to Claude when Perplexity is unavailable.\n```\n\n----------------------------------------\n\nTITLE: Completable Type Tests\nDESCRIPTION: Test suite for the completable type wrapper functionality, verifying type preservation, completion function access and async support.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_106\n\nLANGUAGE: typescript\nCODE:\n```\ndescribe(\"completable\", () => {\n  it(\"preserves types and values of underlying schema\", () => {\n    const baseSchema = z.string();\n    const schema = completable(baseSchema, () => []);\n\n    expect(schema.parse(\"test\")).toBe(\"test\");\n    expect(() => schema.parse(123)).toThrow();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: JSON Configuration for Mentor Data Storage\nDESCRIPTION: Structure for storing mentor data including name, personality, and expertise attributes in mentors.json file\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_060.txt#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mentors\": [\n    {\n      \"name\": \"string\",\n      \"personality\": \"string\",\n      \"expertise\": \"string\",\n      \"attributes\": {}\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Request Handler Capability Restrictions\nDESCRIPTION: Tests that request handlers can only be registered for capabilities that were declared during client initialization. This prevents handlers from being registered for capabilities the client doesn't support.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should only allow setRequestHandler for declared capabilities\", () => {\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  // This should work because sampling is a declared capability\n  expect(() => {\n    client.setRequestHandler(CreateMessageRequestSchema, () => ({\n      model: \"test-model\",\n      role: \"assistant\",\n      content: {\n        type: \"text\",\n        text: \"Test response\",\n      },\n    }));\n  }).not.toThrow();\n\n  // This should throw because roots listing is not a declared capability\n  expect(() => {\n    client.setRequestHandler(ListRootsRequestSchema, () => ({}));\n  }).toThrow(\"Client does not support roots capability\");\n});\n```\n\n----------------------------------------\n\nTITLE: Mocking PKCE Challenge Generation in TypeScript\nDESCRIPTION: This TypeScript function provides a mock implementation for generating PKCE (Proof Key for Code Exchange) challenges. It returns a static object containing predefined 'code_verifier' and 'code_challenge' strings, intended for use in testing environments to simulate the PKCE generation process without actual cryptographic operations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport default function pkceChallenge() {\n  return {\n    code_verifier: \"test_verifier\",\n    code_challenge: \"test_challenge\",\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Task Management Script\nDESCRIPTION: Sets up required and optional environment variables in a .env file to configure the task management script, including API keys, model settings, and default values.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nANTHROPIC_API_KEY=your_anthropic_api_key\nMODEL=\"claude-3-7-sonnet-20250219\"\nMAX_TOKENS=4000\nTEMPERATURE=0.7\nPERPLEXITY_API_KEY=your_perplexity_api_key\nPERPLEXITY_MODEL=\"sonar-medium-online\"\nDEBUG=false\nLOG_LEVEL=info\nDEFAULT_SUBTASKS=3\nDEFAULT_PRIORITY=medium\nPROJECT_NAME=your_project_name\nPROJECT_VERSION=your_project_version\n```\n\n----------------------------------------\n\nTITLE: Defining Filesystem Root Access Interfaces\nDESCRIPTION: TypeScript interfaces for requesting and providing filesystem root directories or files that the server can operate on. This allows servers to understand file system structure and access specific locations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_156\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ListRootsRequest extends Request {\n  method: \"roots/list\";\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface ListRootsResult extends Result {\n  roots: Root[];\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Root {\n  /**\n   * The URI identifying the root. This *must* start with file:// for now.\n   * This restriction may be relaxed in future versions of the protocol to allow\n   * other URI schemes.\n   */\n}\n```\n\n----------------------------------------\n\nTITLE: Task Master Parse PRD Commands\nDESCRIPTION: Commands for parsing PRD files and generating tasks with optional limitations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README-task-master.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Parse a PRD file and generate tasks\ntask-master parse-prd <prd-file.txt>\n\n# Limit the number of tasks generated\ntask-master parse-prd <prd-file.txt> --num-tasks=10\n```\n\n----------------------------------------\n\nTITLE: Setting Up Express App with Mock PKCE Challenge Verification in Jest\nDESCRIPTION: Jest mock implementation for PKCE (Proof Key for Code Exchange) challenge verification and Express app setup with a token handler. This configures the Express application with OAuth token handling middleware for testing.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_69\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Mock PKCE verification\n(pkceChallenge.verifyChallenge as jest.Mock).mockImplementation(\n  async (verifier: string, challenge: string) => {\n    return verifier === 'valid_verifier' && challenge === 'mock_challenge';\n  }\n);\n\n// Setup express app with token handler\napp = express();\nconst options: TokenHandlerOptions = { provider: mockProvider };\napp.use('/token', tokenHandler(options));\n```\n\n----------------------------------------\n\nTITLE: Protocol Error Response in JSON-RPC Format\nDESCRIPTION: Example of a protocol error response when an unknown tool is requested. This uses the standard JSON-RPC error object format to report issues at the protocol level.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_69\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Unknown tool: invalid_tool_name\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing STDIO Server Transport in TypeScript\nDESCRIPTION: Implementation of a STDIO-based transport layer for server-side JSON-RPC communication, handling stdin/stdout streams and message processing.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_153\n\nLANGUAGE: typescript\nCODE:\n```\nexport class StdioServerTransport implements Transport {\n  private _readBuffer: ReadBuffer = new ReadBuffer();\n  private _started = false;\n\n  constructor(\n    private _stdin: Readable = process.stdin,\n    private _stdout: Writable = process.stdout,\n  ) {}\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  _ondata = (chunk: Buffer) => {\n    this._readBuffer.append(chunk);\n    this.processReadBuffer();\n  };\n  _onerror = (error: Error) => {\n    this.onerror?.(error);\n  };\n```\n\n----------------------------------------\n\nTITLE: Managing Task Dependencies with Meta-Development Script\nDESCRIPTION: This snippet demonstrates how to use the 'add-dependency' and 'remove-dependency' commands to manage task dependencies. It shows how to add and remove dependencies between tasks with automatic validation and file updates.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Add a dependency to a task\ntask-master add-dependency --id=<id> --depends-on=<id>\n\n# Remove a dependency from a task\ntask-master remove-dependency --id=<id> --depends-on=<id>\n```\n\n----------------------------------------\n\nTITLE: Registering Asynchronous Prompt in Java MCP SDK\nDESCRIPTION: Implements an asynchronous prompt registration with the same parameters as the sync version. Returns a Mono for reactive processing, suitable for high-concurrency environments or when generating prompt responses involves external API calls.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_149\n\nLANGUAGE: java\nCODE:\n```\n// Async prompt registration\nvar asyncPromptRegistration = new McpServerFeatures.AsyncPromptRegistration(\n    new Prompt(\"greeting\", \"description\", List.of(\n        new PromptArgument(\"name\", \"description\", true)\n    )),\n    request -> {\n        // Prompt implementation\n        return Mono.just(new GetPromptResult(description, messages));\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Removing Subtasks Directly via MCP - Node.js JavaScript\nDESCRIPTION: This snippet provides a direct function and MCP tool for removing a subtask from a parent task, using Node.js and zod-based validation. The implementation ensures parameter validation, error handling, and integration into MCP, requiring parentTaskId and subtaskId as inputs, and returns a standardized result indicating success or error.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n// removeSubtaskDirect.js\nconst { removeSubtask } = require('../task-manager');\nconst { findTasksJsonPath } = require('../utils');\n\nmodule.exports = async function removeSubtaskDirect({ parentTaskId, subtaskId }) {\n  try {\n    const tasksPath = findTasksJsonPath();\n    const result = await removeSubtask({ tasksPath, parentTaskId, subtaskId });\n    return { success: true, data: result };\n  } catch (error) {\n    return { success: false, error };\n  }\n};\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// remove-subtask.js (MCP tool)\nconst z = require('zod');\nconst { executeMCPToolAction } = require('./utils');\nconst { removeSubtaskDirect } = require('../core/task-master-core');\n\nconst removeSubtaskSchema = z.object({\n  parentTaskId: z.string(),\n  subtaskId: z.string(),\n});\n\nfunction registerRemoveSubtaskTool(server) {\n  server.addTool({\n    name: 'remove_subtask',\n    params: removeSubtaskSchema,\n    execute: (params) => executeMCPToolAction(() => removeSubtaskDirect(params)),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Future Tasks Based on Changing Requirements - Bash\nDESCRIPTION: This bash snippet demonstrates how to use Task Master AI to update tasks.json starting from a given task ID, with a prompt describing new requirements or context (e.g., switching frameworks). This allows for re-writing or re-scoping pending tasks while leaving completed work unchanged. Usage requires specifying the update start point and prompt message.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ntask-master update --from=4 --prompt=\"Now we are using Express instead of Fastify.\"\n```\n\n----------------------------------------\n\nTITLE: Setting Up Bearer Authentication Tests in Express\nDESCRIPTION: This snippet demonstrates the setup for testing the requireBearerAuth middleware. It creates mock objects for the Request, Response, and next function, as well as a mock OAuth provider that simulates token verification for testing OAuth authentication flows.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_79\n\nLANGUAGE: typescript\nCODE:\n```\n// Mock provider\nconst mockVerifyAccessToken = jest.fn();\nconst mockProvider: OAuthServerProvider = {\n  clientsStore: {} as OAuthRegisteredClientsStore,\n  authorize: jest.fn(),\n  challengeForAuthorizationCode: jest.fn(),\n  exchangeAuthorizationCode: jest.fn(),\n  exchangeRefreshToken: jest.fn(),\n  verifyAccessToken: mockVerifyAccessToken,\n};\n\ndescribe(\"requireBearerAuth middleware\", () => {\n  let mockRequest: Partial<Request>;\n  let mockResponse: Partial<Response>;\n  let nextFunction: jest.Mock;\n\n  beforeEach(() => {\n    mockRequest = {\n      headers: {},\n    };\n    mockResponse = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn(),\n      set: jest.fn().mockReturnThis(),\n    };\n    nextFunction = jest.fn();\n    jest.clearAllMocks();\n  });\n\n  it(\"should call next when token is valid\", async () => {\n    const validAuthInfo: AuthInfo = {\n      token: \"valid-token\",\n      clientId: \"client-123\",\n      scopes: [\"read\", \"write\"],\n    };\n    mockVerifyAccessToken.mockResolvedValue(validAuthInfo);\n\n    mockRequest.headers = {\n      authorization: \"Bearer valid-token\",\n    };\n\n    const middleware = requireBearerAuth({ provider: mockProvider });\n```\n\n----------------------------------------\n\nTITLE: Running the MCP Weather Server in Python\nDESCRIPTION: Python code to initialize and run the MCP server using stdio transport.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_91\n\nLANGUAGE: python\nCODE:\n```\nif __name__ == \"__main__\":\n    # Initialize and run the server\n    mcp.run(transport='stdio')\n```\n\n----------------------------------------\n\nTITLE: Task Expansion Commands in Task Master CLI\nDESCRIPTION: Commands for expanding tasks with subtasks, including research-backed generation options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n# Expand a specific task with subtasks\ntask-master expand --id=<id> --num=<number>\n\n# Expand with additional context\ntask-master expand --id=<id> --prompt=\"<context>\"\n\n# Expand all pending tasks\ntask-master expand --all\n\n# Force regeneration of subtasks for tasks that already have them\ntask-master expand --all --force\n\n# Research-backed subtask generation for a specific task\ntask-master expand --id=<id> --research\n\n# Research-backed generation for all tasks\ntask-master expand --all --research\n```\n\n----------------------------------------\n\nTITLE: Initiating Progress-Tracked Request (JSON-RPC) - JSON\nDESCRIPTION: This JSON-RPC request includes a progressToken in the _meta field of the params object, enabling progress notifications for long-running operations under the protocol. Dependencies: supporting progressToken in both client and server implementations; JSON-RPC 2.0. Inputs: unique progressToken, method, and relevant parameters. Outputs: may include progress updates if supported. Limitation: progressToken must be unique for concurrent requests.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_7\n\nLANGUAGE: JSON\nCODE:\n```\n{\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"id\\\": 1,\\n  \\\"method\\\": \\\"some_method\\\",\\n  \\\"params\\\": {\\n    \\\"_meta\\\": {\\n      \\\"progressToken\\\": \\\"abc123\\\"\\n    }\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Task Listing Commands in Task Master CLI\nDESCRIPTION: Commands for listing tasks with various filtering options including status and subtask inclusion.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# List all tasks\ntask-master list\n\n# List tasks with a specific status\ntask-master list --status=<status>\n\n# List tasks with subtasks\ntask-master list --with-subtasks\n\n# List tasks with a specific status and include subtasks\ntask-master list --status=<status> --with-subtasks\n```\n\n----------------------------------------\n\nTITLE: Parsing PRD Commands in Task Master CLI\nDESCRIPTION: Commands for parsing Product Requirements Documents (PRD) and generating tasks, with options to limit the number of tasks generated.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Parse a PRD file and generate tasks\ntask-master parse-prd <prd-file.txt>\n\n# Limit the number of tasks generated\ntask-master parse-prd <prd-file.txt> --num-tasks=10\n```\n\n----------------------------------------\n\nTITLE: Add Subtask Command Definition\nDESCRIPTION: CLI command syntax definition for the add-subtask functionality, showing parameter structure and options for adding new subtasks or converting existing tasks.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_025.txt#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n'add-subtask <parentId> [--task-id=<taskId> | --title=<title>]'\n```\n\n----------------------------------------\n\nTITLE: Sending MCP Initialized Notification (JSON)\nDESCRIPTION: Example of a JSON-RPC 2.0 notification message sent by the client after receiving the server's 'initialize' response. The 'notifications/initialized' method signals that the client has completed its side of the initialization and is ready for normal protocol operations. As per JSON-RPC notification rules, it does not include an 'id' field.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/initialized\"\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Finding the Next Task to Work On - task-master CLI - Bash\nDESCRIPTION: Shows how to use the next command to automatically determine and display the most actionable task based on dependencies, priorities, and status. The CLI can analyze either the default or a custom tasks file. The result outputs prioritized task selection and provides recommended next actions for updating task status or navigating subtasks. This helps maintain productivity and ensure proper workflow sequencing within a project.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n# Show the next task to work on\\ntask-master next\\n\\n# Specify a different tasks file\\ntask-master next --file=custom-tasks.json\n```\n\n----------------------------------------\n\nTITLE: Implementing Helper Functions for NWS API Requests\nDESCRIPTION: Defines helper functions for making requests to the National Weather Service API, formatting alert data, and interfaces for API responses.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_99\n\nLANGUAGE: typescript\nCODE:\n```\nasync function makeNWSRequest<T>(url: string): Promise<T | null> {\n  const headers = {\n    \"User-Agent\": USER_AGENT,\n    Accept: \"application/geo+json\",\n  };\n\n  try {\n    const response = await fetch(url, { headers });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return (await response.json()) as T;\n  } catch (error) {\n    console.error(\"Error making NWS request:\", error);\n    return null;\n  }\n}\n\ninterface AlertFeature {\n  properties: {\n    event?: string;\n    areaDesc?: string;\n    severity?: string;\n    status?: string;\n    headline?: string;\n  };\n}\n\nfunction formatAlert(feature: AlertFeature): string {\n  const props = feature.properties;\n  return [\n    `Event: ${props.event || \"Unknown\"}`,\n    `Area: ${props.areaDesc || \"Unknown\"}`,\n    `Severity: ${props.severity || \"Unknown\"}`,\n    `Status: ${props.status || \"Unknown\"}`,\n    `Headline: ${props.headline || \"No headline\"}`,\n    \"---\",\n  ].join(\"\\n\");\n}\n\ninterface ForecastPeriod {\n  name?: string;\n  temperature?: number;\n  temperatureUnit?: string;\n  windSpeed?: string;\n  windDirection?: string;\n  shortForecast?: string;\n}\n\ninterface AlertsResponse {\n  features: AlertFeature[];\n}\n\ninterface PointsResponse {\n  properties: {\n    forecast?: string;\n  };\n}\n\ninterface ForecastResponse {\n  properties: {\n    periods: ForecastPeriod[];\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SSEServer Type in TypeScript\nDESCRIPTION: This snippet defines the SSEServer type, which represents a server with a close method that returns a Promise.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nexport type SSEServer = {\n  close: () => Promise<void>;\n};\n```\n\n----------------------------------------\n\nTITLE: Package Configuration\nDESCRIPTION: NPM package configuration with dependencies and build scripts for the FastMCP framework\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_48\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"fastmcp\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/FastMCP.js\",\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"test\": \"vitest run && tsc && jsr publish --dry-run\",\n    \"format\": \"prettier --write . && eslint --fix .\"\n  },\n  \"bin\": {\n    \"fastmcp\": \"dist/bin/fastmcp.js\"\n  },\n  \"keywords\": [\n    \"MCP\",\n    \"SSE\"\n  ],\n  \"type\": \"module\",\n  \"author\": \"Frank Fiegel <frank@glama.ai>\",\n  \"license\": \"MIT\",\n  \"description\": \"A TypeScript framework for building MCP servers.\"\n}\n```\n\n----------------------------------------\n\nTITLE: Running Basic Test Suite in Bash\nDESCRIPTION: Command to execute all test suites in the project\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tests/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Testing HTTP Method Restrictions in Express Middleware\nDESCRIPTION: This test suite verifies the allowedMethods middleware for Express that restricts endpoints to specific HTTP methods. It confirms that allowed methods pass through, unallowed methods return 405 errors, and that proper Allow headers are included in responses.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_77\n\nLANGUAGE: typescript\nCODE:\n```\ndescribe(\"allowedMethods\", () => {\n  let app: express.Express;\n\n  beforeEach(() => {\n    app = express();\n\n    // Set up a test router with a GET handler and 405 middleware\n    const router = express.Router();\n\n    router.get(\"/test\", (req, res) => {\n      res.status(200).send(\"GET success\");\n    });\n\n    // Add method not allowed middleware for all other methods\n    router.all(\"/test\", allowedMethods([\"GET\"]));\n\n    app.use(router);\n  });\n\n  test(\"allows specified HTTP method\", async () => {\n    const response = await request(app).get(\"/test\");\n    expect(response.status).toBe(200);\n    expect(response.text).toBe(\"GET success\");\n  });\n\n  test(\"returns 405 for unspecified HTTP methods\", async () => {\n    const methods = [\"post\", \"put\", \"delete\", \"patch\"];\n\n    for (const method of methods) {\n      // @ts-expect-error - dynamic method call\n      const response = await request(app)[method](\"/test\");\n      expect(response.status).toBe(405);\n      expect(response.body).toEqual({\n        error: \"method_not_allowed\",\n        error_description: `The method ${method.toUpperCase()} is not allowed for this endpoint`\n      });\n    }\n  });\n\n  test(\"includes Allow header with specified methods\", async () => {\n    const response = await request(app).post(\"/test\");\n    expect(response.headers.allow).toBe(\"GET\");\n  });\n\n  test(\"works with multiple allowed methods\", async () => {\n    const multiMethodApp = express();\n    const router = express.Router();\n\n    router.get(\"/multi\", (req: Request, res: Response) => {\n      res.status(200).send(\"GET\");\n    });\n    router.post(\"/multi\", (req: Request, res: Response) => {\n      res.status(200).send(\"POST\");\n    });\n    router.all(\"/multi\", allowedMethods([\"GET\", \"POST\"]));\n\n    multiMethodApp.use(router);\n\n    // Allowed methods should work\n    const getResponse = await request(multiMethodApp).get(\"/multi\");\n    expect(getResponse.status).toBe(200);\n\n    const postResponse = await request(multiMethodApp).post(\"/multi\");\n    expect(postResponse.status).toBe(200);\n\n    // Unallowed methods should return 405\n    const putResponse = await request(multiMethodApp).put(\"/multi\");\n    expect(putResponse.status).toBe(405);\n    expect(putResponse.headers.allow).toBe(\"GET, POST\");\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: ESLint Configuration\nDESCRIPTION: ESLint configuration file using perfectionist plugin with alphabetical ordering recommendations\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_47\n\nLANGUAGE: javascript\nCODE:\n```\nimport perfectionist from \"eslint-plugin-perfectionist\";\n\nexport default [perfectionist.configs[\"recommended-alphabetical\"]];\n```\n\n----------------------------------------\n\nTITLE: Subtask Clearing Commands in Task Master CLI\nDESCRIPTION: Commands for clearing subtasks from specific tasks or all tasks.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# Clear subtasks from a specific task\ntask-master clear-subtasks --id=<id>\n\n# Clear subtasks from multiple tasks\ntask-master clear-subtasks --id=1,2,3\n\n# Clear subtasks from all tasks\ntask-master clear-subtasks --all\n```\n\n----------------------------------------\n\nTITLE: Creating Perplexity Service Module Structure - JavaScript\nDESCRIPTION: File structure and core functionality for the Perplexity API client service, including authentication handling and API interaction methods.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_051.txt#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nservices/perplexityService.js\n\nqueryPerplexity(searchQuery, options)\nhandleRateLimiting(response)\n```\n\n----------------------------------------\n\nTITLE: Updating Tasks with New Information\nDESCRIPTION: Demonstrates how to update tasks based on new information or implementation changes, including options for research-backed updates and specifying custom task files.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Update tasks starting from ID 4 with a new prompt\nnode scripts/dev.js update --from=4 --prompt=\"Refactor tasks from ID 4 onward to use Express instead of Fastify\"\n\n# Update all tasks (default from=1)\nnode scripts/dev.js update --prompt=\"Add authentication to all relevant tasks\"\n\n# With research-backed updates using Perplexity AI\nnode scripts/dev.js update --from=4 --prompt=\"Integrate OAuth 2.0\" --research\n\n# Specify a different tasks file\nnode scripts/dev.js update --file=custom-tasks.json --from=5 --prompt=\"Change database from MongoDB to PostgreSQL\"\n```\n\n----------------------------------------\n\nTITLE: Defining Product Overview and Core Features in Markdown - Markdown\nDESCRIPTION: This snippet serves as a template for capturing the product overview, core features, and user experience aspects of a software project. It uses Markdown headers and bracketed instructional text to prompt detailed descriptions from writers. No external dependencies are required, but familiarity with Markdown formatting is assumed. Inputs are section details filled in by writers; output is a structured requirements document section. This foundational layout is intended as the starting point for more detailed project planning.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/example_prd.txt#2025-04-23_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# Overview  \n[Provide a high-level overview of your product here. Explain what problem it solves, who it's for, and why it's valuable.]\n\n# Core Features  \n[List and describe the main features of your product. For each feature, include:\n- What it does\n- Why it's important\n- How it works at a high level]\n\n# User Experience  \n[Describe the user journey and experience. Include:\n- User personas\n- Key user flows\n- UI/UX considerations]\n```\n\n----------------------------------------\n\nTITLE: Testing Protocol Version Acceptance\nDESCRIPTION: Tests server's handling of the latest protocol version during initialization, verifying correct response format and capabilities\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_108\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should accept latest protocol version\", async () => {\n  let sendPromiseResolve: (value: unknown) => void;\n  const sendPromise = new Promise((resolve) => {\n    sendPromiseResolve = resolve;\n  });\n\n  const serverTransport: Transport = {\n    start: jest.fn().mockResolvedValue(undefined),\n    close: jest.fn().mockResolvedValue(undefined),\n    send: jest.fn().mockImplementation((message) => {\n      if (message.id === 1 && message.result) {\n        expect(message.result).toEqual({\n          protocolVersion: LATEST_PROTOCOL_VERSION,\n          capabilities: expect.any(Object),\n          serverInfo: {\n            name: \"test server\",\n            version: \"1.0\",\n          },\n          instructions: \"Test instructions\",\n        });\n        sendPromiseResolve(undefined);\n      }\n      return Promise.resolve();\n    }),\n  };\n});\n```\n\n----------------------------------------\n\nTITLE: Task Complexity Analysis Commands in Task Master CLI\nDESCRIPTION: Commands for analyzing task complexity with various options for output, models, and thresholds.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n# Analyze complexity of all tasks\ntask-master analyze-complexity\n\n# Save report to a custom location\ntask-master analyze-complexity --output=my-report.json\n\n# Use a specific LLM model\ntask-master analyze-complexity --model=claude-3-opus-20240229\n\n# Set a custom complexity threshold (1-10)\ntask-master analyze-complexity --threshold=6\n\n# Use an alternative tasks file\ntask-master analyze-complexity --file=custom-tasks.json\n\n# Use Perplexity AI for research-backed complexity analysis\ntask-master analyze-complexity --research\n```\n\n----------------------------------------\n\nTITLE: Task Master Update Commands\nDESCRIPTION: Commands for updating tasks starting from a specific ID with context.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README-task-master.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Update tasks from a specific ID and provide context\ntask-master update --from=<id> --prompt=\"<prompt>\"\n```\n\n----------------------------------------\n\nTITLE: Defining Roots List Changed Notification Schema in TypeScript with Zod\nDESCRIPTION: This snippet defines a Zod schema for a notification from the client to the server, informing it that the list of roots has changed. It extends the base NotificationSchema.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_221\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const RootsListChangedNotificationSchema = NotificationSchema.extend({\n  method: z.literal(\"notifications/roots/list_changed\"),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in Python MCP Transport\nDESCRIPTION: Example of error handling implementation in a Python MCP transport using anyio. It demonstrates how to handle errors during initialization, message handling, and resource cleanup.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_49\n\nLANGUAGE: python\nCODE:\n```\n@contextmanager\nasync def example_transport(scope: Scope, receive: Receive, send: Send):\n    try:\n        # Create streams for bidirectional communication\n        read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n        write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n        async def message_handler():\n            try:\n                async with read_stream_writer:\n                    # Message handling logic\n                    pass\n            except Exception as exc:\n                logger.error(f\"Failed to handle message: {exc}\")\n                raise exc\n\n        async with anyio.create_task_group() as tg:\n            tg.start_soon(message_handler)\n            try:\n                # Yield streams for communication\n                yield read_stream, write_stream\n            except Exception as exc:\n                logger.error(f\"Transport error: {exc}\")\n                raise exc\n            finally:\n                tg.cancel_scope.cancel()\n                await write_stream.aclose()\n                await read_stream.aclose()\n    except Exception as exc:\n        logger.error(f\"Failed to initialize transport: {exc}\")\n        raise exc\n```\n\n----------------------------------------\n\nTITLE: Initializing Weather Project and Installing Dependencies (MacOS/Linux)\nDESCRIPTION: Creates a new directory for the weather project, initializes an npm project, installs required dependencies, and sets up the initial file structure.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_94\n\nLANGUAGE: bash\nCODE:\n```\n# Create a new directory for our project\nmkdir weather\ncd weather\n\n# Initialize a new npm project\nnpm init -y\n\n# Install dependencies\nnpm install @modelcontextprotocol/sdk zod\nnpm install -D @types/node typescript\n\n# Create our files\nmkdir src\ntouch src/index.ts\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Token Revocation Handler Creation\nDESCRIPTION: These tests verify that the revocation handler correctly validates provider compatibility by checking if it supports token revocation. It should throw an error when a provider without revocation capability is supplied and not throw when a compatible provider is used.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_66\n\nLANGUAGE: jest\nCODE:\n```\ndescribe('Handler creation', () => {\n  it('throws error if provider does not support token revocation', () => {\n    const options: RevocationHandlerOptions = { provider: mockProviderWithoutRevocation };\n    expect(() => revocationHandler(options)).toThrow('does not support revoking tokens');\n  });\n\n  it('creates handler if provider supports token revocation', () => {\n    const options: RevocationHandlerOptions = { provider: mockProviderWithRevocation };\n    expect(() => revocationHandler(options)).not.toThrow();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Weather Server in Claude for Desktop (MacOS/Linux)\nDESCRIPTION: JSON configuration for adding the MCP weather server to Claude for Desktop on MacOS/Linux. It specifies the command and arguments to run the Java-based server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_102\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"weather\": {\n      \"command\": \"node\",\n      \"args\": [\n          \"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Context Enrichment Pipeline Task Definition\nDESCRIPTION: Markdown specification for creating a pipeline to process and organize research results, including filtering and scoring mechanisms.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_010.txt#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n## 3. Develop Context Enrichment Pipeline [done]\n### Dependencies: 10.2\n### Description: Create a pipeline that processes research results and enriches the task context with relevant information. This should include filtering irrelevant information, organizing research findings by category (tools, libraries, best practices, etc.), and formatting the enriched context for use in subtask generation. Implement a scoring mechanism to prioritize the most relevant research findings.\n```\n\n----------------------------------------\n\nTITLE: Fixing Task Dependencies using CLI (Bash)\nDESCRIPTION: These commands automatically find and remove invalid dependencies, such as references to non-existent tasks/subtasks or self-dependencies. It modifies the task data structure (`tasks.json` by default, or specified via `--file`) and regenerates individual task files. A detailed report of fixes is provided.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n# Find and fix all invalid dependencies\nnode scripts/dev.js fix-dependencies\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Specify a different tasks file\nnode scripts/dev.js fix-dependencies --file=custom-tasks.json\n```\n\n----------------------------------------\n\nTITLE: Duplicate Prompt Prevention Test\nDESCRIPTION: Ensures that the server prevents registration of duplicate prompts with the same name.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_140\n\nLANGUAGE: typescript\nCODE:\n```\nmcpServer.prompt(\"test\", async () => ({\n  messages: [\n    {\n      role: \"assistant\",\n      content: {\n        type: \"text\",\n        text: \"Test response\",\n      },\n    },\n  ],\n}));\n```\n\n----------------------------------------\n\nTITLE: Enabling Chrome DevTools in Claude Desktop\nDESCRIPTION: Bash command to create a developer_settings.json file that enables Chrome DevTools in Claude Desktop.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\necho '{\"allowDevTools\": true}' > ~/Library/Application\\ Support/Claude/developer_settings.json\n```\n\n----------------------------------------\n\nTITLE: Analyzing Task Complexity using CLI (Bash)\nDESCRIPTION: These commands assess the complexity of tasks using an AI model (Claude by default, or Perplexity with `--research`). It generates recommendations for task expansion, scores tasks (1-10), and outputs a report (default: `scripts/task-complexity-report.json`). Options allow customizing the output file (`--output`), AI model (`--model`), complexity threshold (`--threshold`), and enabling research-backed analysis (`--research`).\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n# Analyze all tasks and generate expansion recommendations\nnode scripts/dev.js analyze-complexity\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Specify a custom output file\nnode scripts/dev.js analyze-complexity --output=custom-report.json\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Override the model used for analysis\nnode scripts/dev.js analyze-complexity --model=claude-3-opus-20240229\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Set a custom complexity threshold (1-10)\nnode scripts/dev.js analyze-complexity --threshold=6\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Use Perplexity AI for research-backed complexity analysis\nnode scripts/dev.js analyze-complexity --research\n```\n\n----------------------------------------\n\nTITLE: Auth Info Type Definition\nDESCRIPTION: TypeScript interface defining the structure of validated access token information including token, client ID, scopes and expiration.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_105\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface AuthInfo {\n  token: string;\n  clientId: string;\n  scopes: string[];\n  expiresAt?: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Command File Structure - TypeScript\nDESCRIPTION: Initial file structure and command definition for generate-test command in Task Master CLI.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_024.txt#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// src/commands/generate-test.ts\n\ninterface GenerateTestOptions {\n  id: string;\n}\n\nexport const generateTest = async (options: GenerateTestOptions) => {\n  // 1. Validate task ID\n  // 2. Retrieve task from store\n  // 3. Generate AI prompt\n  // 4. Call Claude API\n  // 5. Process response\n  // 6. Generate test file\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running Java MCP Client\nDESCRIPTION: Bash commands for building and running the Java-based MCP client application using Maven, showing two alternative methods to start the application.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_85\n\nLANGUAGE: bash\nCODE:\n```\n./mvnw clean install\njava -jar ./target/ai-mcp-brave-chatbot-0.0.1-SNAPSHOT.jar\n```\n\nLANGUAGE: bash\nCODE:\n```\n./mvnw spring-boot:run\n```\n\n----------------------------------------\n\nTITLE: Inspecting MCP Servers from Package Repositories in Bash\nDESCRIPTION: Demonstrates how to use MCP Inspector to test servers installed from NPM or PyPi package repositories, showing the syntax for both package types.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_57\n\nLANGUAGE: bash\nCODE:\n```\nnpx -y @modelcontextprotocol/inspector npx <package-name> <args>\n# For example\nnpx -y @modelcontextprotocol/inspector npx server-postgres postgres://127.0.0.1/testdb\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpx @modelcontextprotocol/inspector uvx <package-name> <args>\n# For example\nnpx @modelcontextprotocol/inspector uvx mcp-server-git --repository ~/code/mcp/servers.git\n```\n\n----------------------------------------\n\nTITLE: Defining WebSocket subprotocol constant for MCP in TypeScript\nDESCRIPTION: Defines the WebSocket subprotocol constant used for MCP (Message Communication Protocol) communication.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_49\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst SUBPROTOCOL = \"mcp\";\n```\n\n----------------------------------------\n\nTITLE: Markdown Test Strategy\nDESCRIPTION: Testing approach for documentation involving user review and validation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_018.txt#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n# Test Strategy:\nReview documentation for clarity and completeness. Have users unfamiliar with the system attempt to follow the documentation and note any confusion or issues.\n```\n\n----------------------------------------\n\nTITLE: Example Prompt File Structure in JavaScript\nDESCRIPTION: Demonstrates the proposed file naming convention and structure for prompt files in the new system\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_048.txt#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// example: task_suggestion_prompt.js\nexport const taskSuggestionPrompt = {\n  // prompt content\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Task File Format for Task Master\nDESCRIPTION: Template structure for individual task files in the Task Master system, showing how task metadata and details are organized including ID, title, status, dependencies, priority, description, implementation details, and test strategy.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/task-structure.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Task ID: <id>\n# Title: <title>\n# Status: <status>\n# Dependencies: <comma-separated list of dependency IDs>\n# Priority: <priority>\n# Description: <brief description>\n# Details:\n<detailed implementation notes>\n\n# Test Strategy:\n<verification approach>\n```\n\n----------------------------------------\n\nTITLE: List-Change-Only Resources Capability\nDESCRIPTION: JSON example showing how to declare resources capability with only list change notifications supported.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_51\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"capabilities\": {\n    \"resources\": {\n      \"listChanged\": true // Only list change notifications supported\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Securing .env File for API Key\nDESCRIPTION: Steps to create a .env file for storing the Anthropic API key securely, and adding it to .gitignore to prevent accidental exposure.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_64\n\nLANGUAGE: bash\nCODE:\n```\n# Create .env file\ntouch .env\n```\n\nLANGUAGE: bash\nCODE:\n```\necho \".env\" >> .gitignore\n```\n\n----------------------------------------\n\nTITLE: Implementing updateTask Command in commands.js\nDESCRIPTION: Command handler implementation that processes user input, validates parameters, and calls the updateTaskById function with appropriate options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_034.txt#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst updateTaskCommand = {\n  name: 'updateTask',\n  description: 'Update a single task by ID',\n  options: {\n    taskId: {\n      type: 'string',\n      required: true,\n      description: 'ID of task to update'\n    },\n    research: {\n      type: 'boolean',\n      default: false,\n      description: 'Enable Perplexity research integration'\n    }\n  },\n  handler: async (args) => {\n    try {\n      const result = await taskManager.updateTaskById(args.taskId, args);\n      console.log('Task updated successfully');\n      return result;\n    } catch (error) {\n      console.error(`Failed to update task: ${error.message}`);\n      throw error;\n    }\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Testing Custom Headers in SSE Client Transport\nDESCRIPTION: This test verifies that custom headers are correctly passed to fetch requests when using SSE Client Transport. It mocks the global fetch function and checks if the custom headers are present in the request.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_29\n\nLANGUAGE: javascript\nCODE:\n```\nit(\"passes custom headers to fetch requests\", async () => {\n  const customHeaders = {\n    Authorization: \"Bearer test-token\",\n    \"X-Custom-Header\": \"custom-value\",\n  };\n\n  transport = new SSEClientTransport(baseUrl, {\n    requestInit: {\n      headers: customHeaders,\n    },\n  });\n\n  await transport.start();\n\n  // Store original fetch\n  const originalFetch = global.fetch;\n\n  try {\n    // Mock fetch for the message sending test\n    global.fetch = jest.fn().mockResolvedValue({\n      ok: true,\n    });\n\n    const message: JSONRPCMessage = {\n      jsonrpc: \"2.0\",\n      id: \"1\",\n      method: \"test\",\n      params: {},\n    };\n\n    await transport.send(message);\n\n    // Verify fetch was called with correct headers\n    expect(global.fetch).toHaveBeenCalledWith(\n      expect.any(URL),\n      expect.objectContaining({\n        headers: expect.any(Headers),\n      }),\n    );\n\n    const calledHeaders = (global.fetch as jest.Mock).mock.calls[0][1]\n      .headers;\n    expect(calledHeaders.get(\"Authorization\")).toBe(\n      customHeaders.Authorization,\n    );\n    expect(calledHeaders.get(\"X-Custom-Header\")).toBe(\n      customHeaders[\"X-Custom-Header\"],\n    );\n    expect(calledHeaders.get(\"content-type\")).toBe(\"application/json\");\n  } finally {\n    // Restore original fetch\n    global.fetch = originalFetch;\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Subtasks using CLI (Bash - Incomplete)\nDESCRIPTION: This section introduces commands for adding subtasks, part of the enhanced subtask management features. The specific command syntax is not fully shown in the provided text snippet.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n```\n\n----------------------------------------\n\nTITLE: Running Python-based MCP Servers with uvx or pip\nDESCRIPTION: These commands show how to run a Python-based MCP server using either uvx (recommended) or pip. The example uses the git server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_60\n\nLANGUAGE: bash\nCODE:\n```\n# Using uvx\nuvx mcp-server-git\n\n# Using pip\npip install mcp-server-git\npython -m mcp_server_git\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Client Properties\nDESCRIPTION: Spring Boot property configuration to specify the location of Claude Desktop configuration file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_113\n\nLANGUAGE: properties\nCODE:\n```\nspring.ai.mcp.client.stdio.servers-configuration=file:PATH/TO/claude_desktop_config.json\n```\n\n----------------------------------------\n\nTITLE: Running TypeScript-based MCP Servers with npx\nDESCRIPTION: This command demonstrates how to run a TypeScript-based MCP server using npx. It specifically shows how to start the memory server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_59\n\nLANGUAGE: bash\nCODE:\n```\nnpx -y @modelcontextprotocol/server-memory\n```\n\n----------------------------------------\n\nTITLE: Prompt List Changed Notification in JSON\nDESCRIPTION: Illustrates the JSON-RPC notification format sent by servers when the list of available prompts changes. This is only applicable for servers that declared the 'listChanged' capability.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_45\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/prompts/list_changed\"\n}\n```\n\n----------------------------------------\n\nTITLE: Cancellation Timing Sequence\nDESCRIPTION: Mermaid sequence diagram showing the timing considerations for request cancellation between client and server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_74\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n   participant Client\n   participant Server\n\n   Client->>Server: Request (ID: 123)\n   Note over Server: Processing starts\n   Client--)Server: notifications/cancelled (ID: 123)\n   alt\n      Note over Server: Processing may have<br/>completed before<br/>cancellation arrives\n   else If not completed\n      Note over Server: Stop processing\n   end\n```\n\n----------------------------------------\n\nTITLE: Setting Up Python Environment with uv for MCP Client\nDESCRIPTION: Commands to set up a new Python project using uv, create a virtual environment, install required packages, and prepare the main file for the MCP client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_63\n\nLANGUAGE: bash\nCODE:\n```\n# Create project directory\nuv init mcp-client\ncd mcp-client\n\n# Create virtual environment\nuv venv\n\n# Activate virtual environment\n# On Windows:\n.venv\\Scripts\\activate\n# On Unix or MacOS:\nsource .venv/bin/activate\n\n# Install required packages\nuv add mcp anthropic python-dotenv\n\n# Remove boilerplate files\nrm hello.py\n\n# Create our main file\ntouch client.py\n```\n\n----------------------------------------\n\nTITLE: Defining Task Expansion Prompt Template - Markdown\nDESCRIPTION: This Markdown code block specifies an AI prompt template for breaking down a single development task into smaller, more actionable subtasks. Inputs are parameterized to accept the main task description, desired subtask count, and any additional context. Each generated subtask should include a title, description, dependencies, and acceptance criteria, supporting modularization and verification of complex tasks. This format is suitable for prompt-based LLM workflows that automate detailed task breakdowns.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/prd.txt#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n```\nYou are helping to break down a development task into more manageable subtasks.\n\nMain task:\nTitle: {task_title}\nDescription: {task_description}\nDetails: {task_details}\n\nPlease create {num_subtasks} specific subtasks that together would accomplish this main task.\n\nFor each subtask, provide:\n1. A clear, actionable title\n2. A concise description\n3. Any dependencies on other subtasks\n4. Specific acceptance criteria to verify completion\n\nAdditional context:\n{additional_context}\n```\n```\n\n----------------------------------------\n\nTITLE: Viewing Complexity Analysis Report Structure (JSON)\nDESCRIPTION: Example structure of the JSON report generated by the `analyze-complexity` command. It includes metadata about the analysis (timestamp, tasks analyzed, threshold, project name, research flag) and a sorted list of tasks with their ID, title, complexity score, recommended subtasks, expansion prompt, reasoning, and a ready-to-use expansion command.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n\t\"meta\": {\n\t\t\"generatedAt\": \"2023-06-15T12:34:56.789Z\",\n\t\t\"tasksAnalyzed\": 20,\n\t\t\"thresholdScore\": 5,\n\t\t\"projectName\": \"Your Project Name\",\n\t\t\"usedResearch\": true\n\t},\n\t\"complexityAnalysis\": [\n\t\t{\n\t\t\t\"taskId\": 8,\n\t\t\t\"taskTitle\": \"Develop Implementation Drift Handling\",\n\t\t\t\"complexityScore\": 9.5,\n\t\t\t\"recommendedSubtasks\": 6,\n\t\t\t\"expansionPrompt\": \"Create subtasks that handle detecting...\",\n\t\t\t\"reasoning\": \"This task requires sophisticated logic...\",\n\t\t\t\"expansionCommand\": \"node scripts/dev.js expand --id=8 --num=6 --prompt=\\\"Create subtasks...\\\" --research\"\n\t\t}\n\t\t// More tasks sorted by complexity score (highest first)\n\t]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Echo Server with MCP Resources, Tools, and Prompts\nDESCRIPTION: Demonstrates how to create a simple echo server using the MCP SDK. Implements three functionalities: a resource that returns messages from a URL pattern, a tool that echoes messages, and a prompt template that processes user messages.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_233\n\nLANGUAGE: typescript\nCODE:\n```\nimport { McpServer, ResourceTemplate } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { z } from \"zod\";\n\nconst server = new McpServer({\n  name: \"Echo\",\n  version: \"1.0.0\"\n});\n\nserver.resource(\n  \"echo\",\n  new ResourceTemplate(\"echo://{message}\", { list: undefined }),\n  async (uri, { message }) => ({\n    contents: [{\n      uri: uri.href,\n      text: `Resource echo: ${message}`\n    }]\n  })\n);\n\nserver.tool(\n  \"echo\",\n  { message: z.string() },\n  async ({ message }) => ({\n    content: [{ type: \"text\", text: `Tool echo: ${message}` }]\n  })\n);\n\nserver.prompt(\n  \"echo\",\n  { message: z.string() },\n  ({ message }) => ({\n    messages: [{\n      role: \"user\",\n      content: {\n        type: \"text\",\n        text: `Please process this message: ${message}`\n      }\n    }]\n  })\n);\n```\n\n----------------------------------------\n\nTITLE: Testing Client Backwards Compatibility with Older Protocol Versions\nDESCRIPTION: This test verifies that the client can successfully connect to a server using an older but supported protocol version. It mocks the transport layer to return a response with an older version and checks that the connection succeeds.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should initialize with supported older protocol version\", async () => {\n  const OLD_VERSION = SUPPORTED_PROTOCOL_VERSIONS[1];\n  const clientTransport: Transport = {\n    start: jest.fn().mockResolvedValue(undefined),\n    close: jest.fn().mockResolvedValue(undefined),\n    send: jest.fn().mockImplementation((message) => {\n      if (message.method === \"initialize\") {\n        clientTransport.onmessage?.({\n          jsonrpc: \"2.0\",\n          id: message.id,\n          result: {\n            protocolVersion: OLD_VERSION,\n            capabilities: {},\n            serverInfo: {\n              name: \"test\",\n              version: \"1.0\",\n            },\n          },\n        });\n      }\n      return Promise.resolve();\n    }),\n  };\n\n  const client = new Client(\n    {\n      name: \"test client\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        sampling: {},\n      },\n    },\n  );\n\n  await client.connect(clientTransport);\n\n  // Connection should succeed with the older version\n  expect(client.getServerVersion()).toEqual({\n    name: \"test\",\n    version: \"1.0\",\n  });\n\n  // Expect no instructions\n  expect(client.getInstructions()).toBeUndefined();\n});\n```\n\n----------------------------------------\n\nTITLE: Managing Task Dependencies\nDESCRIPTION: Shows how to add and remove dependencies between tasks using the task management script.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Add a dependency to a task\nnode scripts/dev.js add-dependency --id=<id> --depends-on=<id>\n```\n\n----------------------------------------\n\nTITLE: Response to Prompt Get Request\nDESCRIPTION: JSON-RPC response containing the processed prompt with messages formatted for an AI assistant. The response includes the prompt description and a message with the user's code for review.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_119\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"description\": \"Code review prompt\",\n    \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": {\n          \"type\": \"text\",\n          \"text\": \"Please review this Python code:\\ndef hello():\\n    print('world')\"\n        }\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Spring AI MCP Client Dependency\nDESCRIPTION: Maven dependency configuration for including the Spring AI MCP client boot starter in a Spring Boot project.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_112\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\n    <groupId>org.springframework.ai</groupId>\n    <artifactId>spring-ai-mcp-client-spring-boot-starter</artifactId>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Ping Sequence Diagram\nDESCRIPTION: Mermaid sequence diagram showing ping request-response flow between sender and receiver.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_77\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Sender\n    participant Receiver\n\n    Sender->>Receiver: ping request\n    Receiver->>Sender: empty response\n```\n\n----------------------------------------\n\nTITLE: Task Complexity Analysis Output Structure - JSON\nDESCRIPTION: Provides the structure of the JSON output generated by the analyze-complexity command. The output includes generation metadata, complexity scoring, recommended subtasks, prompts, reasoning, and ready-to-use expansion shell commands for each task. The schema contains a top-level meta section, a sorted complexityAnalysis array, and supports extensibility for additional tasks. This report serves as machine- and human-readable input to other processes or for automated task generation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\\n\\t\\\"meta\\\": {\\n\\t\\t\\\"generatedAt\\\": \\\"2023-06-15T12:34:56.789Z\\\",\\n\\t\\t\\\"tasksAnalyzed\\\": 20,\\n\\t\\t\\\"thresholdScore\\\": 5,\\n\\t\\t\\\"projectName\\\": \\\"Your Project Name\\\",\\n\\t\\t\\\"usedResearch\\\": true\\n\\t},\\n\\t\\\"complexityAnalysis\\\": [\\n\\t\\t{\\n\\t\\t\\t\\\"taskId\\\": 8,\\n\\t\\t\\t\\\"taskTitle\\\": \\\"Develop Implementation Drift Handling\\\",\\n\\t\\t\\t\\\"complexityScore\\\": 9.5,\\n\\t\\t\\t\\\"recommendedSubtasks\\\": 6,\\n\\t\\t\\t\\\"expansionPrompt\\\": \\\"Create subtasks that handle detecting...\\\",\\n\\t\\t\\t\\\"reasoning\\\": \\\"This task requires sophisticated logic...\\\",\\n\\t\\t\\t\\\"expansionCommand\\\": \\\"task-master expand --id=8 --num=6 --prompt=\\\\\\\"Create subtasks...\\\\\\\" --research\\\"\\n\\t\\t}\\n\\t\\t// More tasks sorted by complexity score (highest first)\\n\\t]\\n}\n```\n\n----------------------------------------\n\nTITLE: Installing uv Package Manager\nDESCRIPTION: Commands to install the uv package manager on MacOS/Linux and Windows.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_86\n\nLANGUAGE: bash\nCODE:\n```\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n```\n\nLANGUAGE: powershell\nCODE:\n```\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n```\n\n----------------------------------------\n\nTITLE: Defining Client and Server Message Schemas in TypeScript with Zod\nDESCRIPTION: These snippets define Zod schemas for various client and server messages, including requests, notifications, and results. They use z.union to combine multiple schema types.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_222\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const ClientRequestSchema = z.union([\n  PingRequestSchema,\n  InitializeRequestSchema,\n  CompleteRequestSchema,\n  SetLevelRequestSchema,\n  GetPromptRequestSchema,\n  ListPromptsRequestSchema,\n  ListResourcesRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ReadResourceRequestSchema,\n  SubscribeRequestSchema,\n  UnsubscribeRequestSchema,\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n]);\n\nexport const ClientNotificationSchema = z.union([\n  CancelledNotificationSchema,\n  ProgressNotificationSchema,\n  InitializedNotificationSchema,\n  RootsListChangedNotificationSchema,\n]);\n\nexport const ClientResultSchema = z.union([\n  EmptyResultSchema,\n  CreateMessageResultSchema,\n  ListRootsResultSchema,\n]);\n\nexport const ServerRequestSchema = z.union([\n  PingRequestSchema,\n  CreateMessageRequestSchema,\n  ListRootsRequestSchema,\n]);\n\nexport const ServerNotificationSchema = z.union([\n  CancelledNotificationSchema,\n  ProgressNotificationSchema,\n  LoggingMessageNotificationSchema,\n  ResourceUpdatedNotificationSchema,\n  ResourceListChangedNotificationSchema,\n  ToolListChangedNotificationSchema,\n  PromptListChangedNotificationSchema,\n]);\n\nexport const ServerResultSchema = z.union([\n  EmptyResultSchema,\n  InitializeResultSchema,\n  CompleteResultSchema,\n  GetPromptResultSchema,\n  ListPromptsResultSchema,\n  ListResourcesResultSchema,\n  ListResourceTemplatesResultSchema,\n  ReadResourceResultSchema,\n  CallToolResultSchema,\n  ListToolsResultSchema,\n]);\n```\n\n----------------------------------------\n\nTITLE: Text Content Message in JSON\nDESCRIPTION: JSON structure for a text content message in sampling.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_28\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"text\",\n  \"text\": \"The message content\"\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Connection Closure in JSON-RPC Protocol\nDESCRIPTION: Method that handles connection closure by cleaning up resources and notifying handlers with a ConnectionClosed error.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_167\n\nLANGUAGE: typescript\nCODE:\n```\nprivate _onclose(): void {\n  const responseHandlers = this._responseHandlers;\n  this._responseHandlers = new Map();\n  this._progressHandlers.clear();\n  this._transport = undefined;\n  this.onclose?.();\n\n  const error = new McpError(ErrorCode.ConnectionClosed, \"Connection closed\");\n  for (const handler of responseHandlers.values()) {\n    handler(error);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Application Properties for Spring AI MCP Server\nDESCRIPTION: Application properties configuration for the Spring AI MCP server. It disables the Spring banner and configures logging patterns.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_106\n\nLANGUAGE: bash\nCODE:\n```\nspring.main.bannerMode=off\nlogging.pattern.console=\n```\n\n----------------------------------------\n\nTITLE: Setting Task Status in Task Master AI - Bash\nDESCRIPTION: This single command updates the status of a task by its unique ID, marking it as done ('--status=done'). Used after task implementation and verification, this operation mutates tasks.json and other workflow artifacts to reflect completion.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntask-master set-status --id=3 --status=done\n```\n\n----------------------------------------\n\nTITLE: Outlining Test Strategy for Code Quality Analysis Command in Markdown\nDESCRIPTION: Markdown structure detailing the test strategy for the analyze-code-quality command, covering functionality, integration, performance, user experience testing, and validation criteria.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_049.txt#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n1. **Functionality Testing**:\n   - Create a test codebase with known patterns and anti-patterns\n   - Verify the command correctly identifies all patterns in the test codebase\n   - Check that function verification correctly flags issues in deliberately non-compliant functions\n   - Confirm recommendations are relevant and implementable\n\n2. **Integration Testing**:\n   - Test the AI service integration with mock responses to ensure proper handling of API calls\n   - Verify the task creation workflow correctly generates well-formed tasks\n   - Test integration with existing Taskmaster commands and workflows\n\n3. **Performance Testing**:\n   - Measure execution time on codebases of various sizes\n   - Ensure memory usage remains reasonable even on large codebases\n   - Test with rate limiting on API calls to ensure graceful handling\n\n4. **User Experience Testing**:\n   - Have developers use the command on real projects and provide feedback\n   - Verify the output is actionable and clear\n   - Test the command with different parameter combinations\n\n5. **Validation Criteria**:\n   - Command successfully analyzes at least 95% of functions in the codebase\n   - Generated recommendations are specific and actionable\n   - Created tasks follow the project's task format standards\n   - Analysis results are consistent across multiple runs on the same codebase\n```\n\n----------------------------------------\n\nTITLE: Analyzing Task Complexity\nDESCRIPTION: Command to request analysis of task complexity for better task breakdown.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/examples.md#2025-04-23_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\nCan you analyze the complexity of our tasks to help me understand which ones need to be broken down further?\n```\n\n----------------------------------------\n\nTITLE: URI Template Parsing Methods\nDESCRIPTION: Helper methods for parsing URI templates, extracting operators and variable names, and handling value encoding\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_185\n\nLANGUAGE: typescript\nCODE:\n```\nprivate parse(template: string): Array<string | { name: string; operator: string; names: string[]; exploded: boolean }> {\n  const parts: Array<string | { name: string; operator: string; names: string[]; exploded: boolean }> = [];\n  let currentText = \"\";\n  let i = 0;\n  let expressionCount = 0;\n\n  while (i < template.length) {\n    if (template[i] === \"{\") {\n      if (currentText) {\n        parts.push(currentText);\n        currentText = \"\";\n      }\n      const end = template.indexOf(\"}\", i);\n      if (end === -1) throw new Error(\"Unclosed template expression\");\n\n      expressionCount++;\n      if (expressionCount > MAX_TEMPLATE_EXPRESSIONS) {\n        throw new Error(`Template contains too many expressions (max ${MAX_TEMPLATE_EXPRESSIONS})`);\n      }\n\n      const expr = template.slice(i + 1, end);\n      const operator = this.getOperator(expr);\n      const exploded = expr.includes(\"*\");\n      const names = this.getNames(expr);\n      const name = names[0];\n\n      for (const name of names) {\n        UriTemplate.validateLength(name, MAX_VARIABLE_LENGTH, \"Variable name\");\n      }\n\n      parts.push({ name, operator, names, exploded });\n      i = end + 1;\n    } else {\n      currentText += template[i];\n      i++;\n    }\n  }\n\n  if (currentText) {\n    parts.push(currentText);\n  }\n\n  return parts;\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing Task Complexity - task-master CLI - Bash\nDESCRIPTION: Illustrates the usage of the analyze-complexity command to assess and report task complexity using Claude or Perplexity AI models. Allows output customization, model selection, dynamic threshold setting, and AI-backed research with flags such as --output, --model, --threshold, and --research. Requires access to Claude or enables Perplexity for advanced assessments. Generates a structured JSON report with scoring, recommendations, and auto-generated expansion commands for every task.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# Analyze all tasks and generate expansion recommendations\\ntask-master analyze-complexity\\n\\n# Specify a custom output file\\ntask-master analyze-complexity --output=custom-report.json\\n\\n# Override the model used for analysis\\ntask-master analyze-complexity --model=claude-3-opus-20240229\\n\\n# Set a custom complexity threshold (1-10)\\ntask-master analyze-complexity --threshold=6\\n\\n# Use Perplexity AI for research-backed complexity analysis\\ntask-master analyze-complexity --research\n```\n\n----------------------------------------\n\nTITLE: Sending Cancellation Notification (JSON-RPC) - JSON\nDESCRIPTION: This snippet demonstrates a JSON-RPC notification used for cancelling in-progress requests within the Model Context Protocol. The notification uses method 'notifications/cancelled' and carries the ID of the request to cancel and an optional human-readable reason. Dependencies: JSON-RPC 2.0 compliance and proper propagation of notification IDs. Inputs include the requestId to cancel. No response is expected. Limitations: Cancellation is best-effort and may not always succeed if the operation has already completed.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"method\\\": \\\"notifications/cancelled\\\",\\n  \\\"params\\\": {\\n    \\\"requestId\\\": \\\"123\\\",\\n    \\\"reason\\\": \\\"User requested cancellation\\\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Client and Server Message Types in TypeScript for MCP\nDESCRIPTION: Defines the various message types that can be exchanged between clients and servers in the Model Context Protocol, including requests, notifications, and results for both client-to-server and server-to-client communication.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_159\n\nLANGUAGE: typescript\nCODE:\n```\n/* Client messages */\nexport type ClientRequest =\n  | PingRequest\n  | InitializeRequest\n  | CompleteRequest\n  | SetLevelRequest\n  | GetPromptRequest\n  | ListPromptsRequest\n  | ListResourcesRequest\n  | ListResourceTemplatesRequest\n  | ReadResourceRequest\n  | SubscribeRequest\n  | UnsubscribeRequest\n  | CallToolRequest\n  | ListToolsRequest;\n\nexport type ClientNotification =\n  | CancelledNotification\n  | ProgressNotification\n  | InitializedNotification\n  | RootsListChangedNotification;\n\nexport type ClientResult = EmptyResult | CreateMessageResult | ListRootsResult;\n\n/* Server messages */\nexport type ServerRequest =\n  | PingRequest\n  | CreateMessageRequest\n  | ListRootsRequest;\n\nexport type ServerNotification =\n  | CancelledNotification\n  | ProgressNotification\n  | LoggingMessageNotification\n  | ResourceUpdatedNotification\n  | ResourceListChangedNotification\n  | ToolListChangedNotification\n  | PromptListChangedNotification;\n\nexport type ServerResult =\n  | EmptyResult\n  | InitializeResult\n  | CompleteResult\n  | GetPromptResult\n  | ListPromptsResult\n  | ListResourcesResult\n  | ListResourceTemplatesResult\n  | ReadResourceResult\n  | CallToolResult\n  | ListToolsResult;\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation Requirements\nDESCRIPTION: List of required documentation components including README, command reference, configuration guides, and workflows.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_018.txt#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nCreate user documentation including:\n- Detailed README with installation and usage instructions\n- Command reference documentation\n- Configuration guide\n- Example workflows\n- Troubleshooting guides\n- API integration documentation\n- Best practices\n- Advanced usage scenarios\n```\n\n----------------------------------------\n\nTITLE: Regenerating Task Subtasks\nDESCRIPTION: Command to clear and regenerate subtasks for a specific task with a different approach.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/examples.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\nI need to regenerate the subtasks for task 3 with a different approach. Can you help me clear and regenerate them?\n```\n\n----------------------------------------\n\nTITLE: Installing Task Master via NPM\nDESCRIPTION: Bash commands to install Task Master globally or locally using npm. Provides options for different installation scenarios.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install globally\nnpm install -g task-master-ai\n\n# OR install locally within your project\nnpm install task-master-ai\n```\n\n----------------------------------------\n\nTITLE: Next Task Display Command in Task Master CLI\nDESCRIPTION: Command to show the next task to work on based on dependencies and status.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Show the next task to work on based on dependencies and status\ntask-master next\n```\n\n----------------------------------------\n\nTITLE: Validating Task Dependencies using CLI (Bash)\nDESCRIPTION: These commands check for invalid dependencies within the project's task structure without making any modifications. It scans tasks and subtasks for non-existent dependencies and self-references. The `--file` option allows specifying a custom task file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# Check for invalid dependencies in tasks.json\nnode scripts/dev.js validate-dependencies\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Specify a different tasks file\nnode scripts/dev.js validate-dependencies --file=custom-tasks.json\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Watch Mode\nDESCRIPTION: Command to run tests in watch mode for development purposes, allowing automatic test reruns on file changes\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tests/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run test:watch\n```\n\n----------------------------------------\n\nTITLE: Initializing Task Master Project\nDESCRIPTION: Commands for initializing a new Task Master project based on installation type.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README-task-master.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# If installed globally\ntask-master init\n\n# If installed locally\nnpx task-master-init\n```\n\n----------------------------------------\n\nTITLE: Expanding All Tasks to Subtasks Directly via MCP - Node.js JavaScript\nDESCRIPTION: Provides a pattern for expanding all tasks into their subtasks programmatically and registering the functionality as an MCP tool, with inputs validated using zod. The implementation supports parameters prompt, num, force, and research; it ensures results/data or standardized errors are returned for automation and integration use cases.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n// expandAllTasksDirect.js\nconst { expandAllTasks } = require('../task-manager');\nconst { findTasksJsonPath } = require('../utils');\n\nmodule.exports = async function expandAllTasksDirect({ prompt, num, force, research }) {\n  try {\n    const tasksPath = findTasksJsonPath();\n    const result = await expandAllTasks({ tasksPath, prompt, num, force, research });\n    return { success: true, data: result };\n  } catch (error) {\n    return { success: false, error };\n  }\n};\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// expand-all.js (MCP tool)\nconst z = require('zod');\nconst { executeMCPToolAction } = require('./utils');\nconst { expandAllTasksDirect } = require('../core/task-master-core');\n\nconst expandAllSchema = z.object({\n  prompt: z.string(),\n  num: z.number().optional(),\n  force: z.boolean().optional(),\n  research: z.boolean().optional(),\n});\n\nfunction registerExpandAllTool(server) {\n  server.addTool({\n    name: 'expand_all',\n    params: expandAllSchema,\n    execute: (params) => executeMCPToolAction(() => expandAllTasksDirect(params)),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Test Environment for FastMCP\nDESCRIPTION: This function sets up a test environment with a FastMCP server and client, allowing for easy testing of server-client interactions. It handles server creation, client connection, and test execution.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst runWithTestServer = async ({\n  run,\n  client: createClient,\n  server: createServer,\n}: {\n  server?: () => Promise<FastMCP>;\n  client?: () => Promise<Client>;\n  run: ({\n    client,\n    server,\n  }: {\n    client: Client;\n    server: FastMCP;\n    session: FastMCPSession;\n  }) => Promise<void>;\n}) => {\n  const port = await getRandomPort();\n\n  const server = createServer\n    ? await createServer()\n    : new FastMCP({\n        name: \"Test\",\n        version: \"1.0.0\",\n      });\n\n  await server.start({\n    transportType: \"sse\",\n    sse: {\n      endpoint: \"/sse\",\n      port,\n    },\n  });\n\n  try {\n    const client = createClient\n      ? await createClient()\n      : new Client(\n          {\n            name: \"example-client\",\n            version: \"1.0.0\",\n          },\n          {\n            capabilities: {},\n          },\n        );\n\n    const transport = new SSEClientTransport(\n      new URL(`http://localhost:${port}/sse`),\n    );\n\n    const session = await new Promise<FastMCPSession>((resolve) => {\n      server.on(\"connect\", (event) => {\n        \n        resolve(event.session);\n      });\n\n      client.connect(transport);\n    });\n\n    await run({ client, server, session });\n  } finally {\n    await server.stop();\n  }\n\n  return port;\n};\n```\n\n----------------------------------------\n\nTITLE: Mocking OAuth Provider with Token Revocation in TypeScript\nDESCRIPTION: Test implementation of an OAuth provider that supports token revocation. Includes mock implementations for authorization, token exchange, and token verification operations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\nconst mockProviderWithRevocation: OAuthServerProvider = {\n  clientsStore: mockClientStore,\n\n  async authorize(client: OAuthClientInformationFull, params: AuthorizationParams, res: Response): Promise<void> {\n    res.redirect('https://example.com/callback?code=mock_auth_code');\n  },\n\n  async challengeForAuthorizationCode(): Promise<string> {\n    return 'mock_challenge';\n  },\n\n  async exchangeAuthorizationCode(): Promise<OAuthTokens> {\n    return {\n      access_token: 'mock_access_token',\n      token_type: 'bearer',\n      expires_in: 3600,\n      refresh_token: 'mock_refresh_token'\n    };\n  },\n\n  async exchangeRefreshToken(): Promise<OAuthTokens> {\n    return {\n      access_token: 'new_mock_access_token',\n      token_type: 'bearer',\n      expires_in: 3600,\n      refresh_token: 'new_mock_refresh_token'\n    };\n  },\n\n  async verifyAccessToken(token: string): Promise<AuthInfo> {\n    if (token === 'valid_token') {\n      return {\n        token,\n        clientId: 'valid-client',\n        scopes: ['read', 'write'],\n        expiresAt: Date.now() / 1000 + 3600\n      };\n    }\n    throw new InvalidTokenError('Token is invalid or expired');\n  },\n\n  async revokeToken(_client: OAuthClientInformationFull, _request: OAuthTokenRevocationRequest): Promise<void> {\n    // Success - do nothing in mock\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Task Detail Display Commands in Task Master CLI\nDESCRIPTION: Commands for showing details of specific tasks and subtasks using various identifier formats.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Show details of a specific task\ntask-master show <id>\n# or\ntask-master show --id=<id>\n\n# View a specific subtask (e.g., subtask 2 of task 1)\ntask-master show 1.2\n```\n\n----------------------------------------\n\nTITLE: Implementing default environment variable handling for StdioClientTransport\nDESCRIPTION: Implements functions to define and retrieve safe environment variables to pass to child processes. It includes platform-specific lists of variables and filtering logic for security.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_47\n\nLANGUAGE: TypeScript\nCODE:\n```\n/**\n * Environment variables to inherit by default, if an environment is not explicitly given.\n */\nexport const DEFAULT_INHERITED_ENV_VARS =\n  process.platform === \"win32\"\n    ? [\n        \"APPDATA\",\n        \"HOMEDRIVE\",\n        \"HOMEPATH\",\n        \"LOCALAPPDATA\",\n        \"PATH\",\n        \"PROCESSOR_ARCHITECTURE\",\n        \"SYSTEMDRIVE\",\n        \"SYSTEMROOT\",\n        \"TEMP\",\n        \"USERNAME\",\n        \"USERPROFILE\",\n      ]\n    : /* list inspired by the default env inheritance of sudo */\n      [\"HOME\", \"LOGNAME\", \"PATH\", \"SHELL\", \"TERM\", \"USER\"];\n\n/**\n * Returns a default environment object including only environment variables deemed safe to inherit.\n */\nexport function getDefaultEnvironment(): Record<string, string> {\n  const env: Record<string, string> = {};\n\n  for (const key of DEFAULT_INHERITED_ENV_VARS) {\n    const value = process.env[key];\n    if (value === undefined) {\n      continue;\n    }\n\n    if (value.startsWith(\"()\")) {\n      // Skip functions, which are a security risk.\n      continue;\n    }\n\n    env[key] = value;\n  }\n\n  return env;\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Task Dependencies - task-master CLI - Bash\nDESCRIPTION: Shows automated correction of dependency errors using the task-master CLI. These commands detect and remove references to non-existent and self-dependent tasks in the tasks.json or specified task file. All changes are applied directly to the file system, and detailed reports enumerate the modifications. Input files are overwritten with corrected structures, so backup is recommended. Only valid JSON task files are supported.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n# Find and fix all invalid dependencies\\ntask-master fix-dependencies\\n\\n# Specify a different tasks file\\ntask-master fix-dependencies --file=custom-tasks.json\n```\n\n----------------------------------------\n\nTITLE: Initializing Task Master Project\nDESCRIPTION: Bash commands to initialize a new Task Master project. Shows how to run the init command for both global and local installations.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# If installed globally\ntask-master init\n\n# If installed locally\nnpx task-master-init\n```\n\n----------------------------------------\n\nTITLE: Structuring Task Master Documentation in Markdown\nDESCRIPTION: This Markdown snippet outlines the structure of the Task Master documentation, including sections for Getting Started, Reference, Examples & Licensing, and additional help resources. It provides links to various markdown files containing detailed information on each topic.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Task Master Documentation\n\nWelcome to the Task Master documentation. Use the links below to navigate to the information you need:\n\n## Getting Started\n\n- [Configuration Guide](configuration.md) - Set up environment variables and customize Task Master\n- [Tutorial](tutorial.md) - Step-by-step guide to getting started with Task Master\n\n## Reference\n\n- [Command Reference](command-reference.md) - Complete list of all available commands\n- [Task Structure](task-structure.md) - Understanding the task format and features\n\n## Examples & Licensing\n\n- [Example Interactions](examples.md) - Common Cursor AI interaction examples\n- [Licensing Information](licensing.md) - Detailed information about the license\n\n## Need More Help?\n\nIf you can't find what you're looking for in these docs, please check the [main README](../README.md) or visit our [GitHub repository](https://github.com/eyaltoledano/claude-task-master).\n```\n\n----------------------------------------\n\nTITLE: Sending MCP Initialization Request (JSON)\nDESCRIPTION: Example of a JSON-RPC 2.0 request message sent by the client to initiate the MCP connection lifecycle. The 'initialize' method includes parameters specifying the requested 'protocolVersion', client 'capabilities' (e.g., support for 'roots' and 'sampling'), and 'clientInfo'. An 'id' is included to correlate the server's response.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"initialize\",\n  \"params\": {\n    \"protocolVersion\": \"2024-11-05\",\n    \"capabilities\": {\n      \"roots\": {\n        \"listChanged\": true\n      },\n      \"sampling\": {}\n    },\n    \"clientInfo\": {\n      \"name\": \"ExampleClient\",\n      \"version\": \"1.0.0\"\n    }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Client Authentication with Jest and Supertest\nDESCRIPTION: Test cases for OAuth client authentication validation. These tests verify that the token endpoint properly validates client credentials and responds appropriately to both valid and invalid authentication attempts.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_71\n\nLANGUAGE: JavaScript\nCODE:\n```\ndescribe('Client authentication', () => {\n  it('requires valid client credentials', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'invalid-client',\n        client_secret: 'wrong-secret',\n        grant_type: 'authorization_code'\n      });\n\n    expect(response.status).toBe(400);\n    expect(response.body.error).toBe('invalid_client');\n  });\n\n  it('accepts valid client credentials', async () => {\n    const response = await supertest(app)\n      .post('/token')\n      .type('form')\n      .send({\n        client_id: 'valid-client',\n        client_secret: 'valid-secret',\n        grant_type: 'authorization_code',\n        code: 'valid_code',\n        code_verifier: 'valid_verifier'\n      });\n\n    expect(response.status).toBe(200);\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Finding the Next Task using CLI (Bash)\nDESCRIPTION: These commands determine the next task to work on based on dependencies and status. It identifies pending or in-progress tasks whose dependencies are met, prioritizes them (by priority, dependency count, ID), and displays details along with suggested action commands. The `--file` option allows specifying a custom task file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/scripts/README.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# Show the next task to work on\nnode scripts/dev.js next\n```\n\nLANGUAGE: bash\nCODE:\n```\n# Specify a different tasks file\nnode scripts/dev.js next --file=custom-tasks.json\n```\n\n----------------------------------------\n\nTITLE: Custom Transport Implementation for MCP in Python\nDESCRIPTION: Demonstrates a pattern for implementing custom MCP transports in Python using anyio for wider compatibility. The code shows a context manager function that processes messages, handles errors, and ensures proper cleanup.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_47\n\nLANGUAGE: python\nCODE:\n```\n@contextmanager\nasync def create_transport(\n    read_stream: MemoryObjectReceiveStream[JSONRPCMessage | Exception],\n    write_stream: MemoryObjectSendStream[JSONRPCMessage]\n):\n    \"\"\"\n    Transport interface for MCP.\n\n    Args:\n        read_stream: Stream to read incoming messages from\n        write_stream: Stream to write outgoing messages to\n    \"\"\"\n    async with anyio.create_task_group() as tg:\n        try:\n            # Start processing messages\n            tg.start_soon(lambda: process_messages(read_stream))\n\n            # Send messages\n            async with write_stream:\n                yield write_stream\n\n        except Exception as exc:\n            # Handle errors\n            raise exc\n        finally:\n            # Clean up\n            tg.cancel_scope.cancel()\n            await write_stream.aclose()\n            await read_stream.aclose()\n```\n\n----------------------------------------\n\nTITLE: Defining StdioServerParameters interface in TypeScript\nDESCRIPTION: Defines the configuration interface for StdioClientTransport that specifies how to spawn and communicate with a child process. It includes command, arguments, environment, and other process options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_46\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport type StdioServerParameters = {\n  /**\n   * The executable to run to start the server.\n   */\n  command: string;\n\n  /**\n   * Command line arguments to pass to the executable.\n   */\n  args?: string[];\n\n  /**\n   * The environment to use when spawning the process.\n   *\n   * If not specified, the result of getDefaultEnvironment() will be used.\n   */\n  env?: Record<string, string>;\n\n  /**\n   * How to handle stderr of the child process. This matches the semantics of Node's `child_process.spawn`.\n   *\n   * The default is \"inherit\", meaning messages to stderr will be printed to the parent process's stderr.\n   */\n  stderr?: IOType | Stream | number;\n\n  /**\n   * The working directory to use when spawning the process.\n   *\n   * If not specified, the current working directory will be inherited.\n   */\n  cwd?: string;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing SSE Client Transport Class in TypeScript\nDESCRIPTION: Main implementation of the SSE client transport class that handles server-sent events for receiving messages and makes POST requests for sending messages, with authentication support.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Client transport for SSE: this will connect to a server using Server-Sent Events for receiving\n * messages and make separate POST requests for sending messages.\n */\nexport class SSEClientTransport implements Transport {\n  private _eventSource?: EventSource;\n  private _endpoint?: URL;\n  private _abortController?: AbortController;\n  private _url: URL;\n  private _eventSourceInit?: EventSourceInit;\n  private _requestInit?: RequestInit;\n  private _authProvider?: OAuthClientProvider;\n\n  onclose?: () => void;\n  onerror?: (error: Error) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor(\n    url: URL,\n    opts?: SSEClientTransportOptions,\n  ) {\n    this._url = url;\n    this._eventSourceInit = opts?.eventSourceInit;\n    this._requestInit = opts?.requestInit;\n    this._authProvider = opts?.authProvider;\n  }\n```\n\n----------------------------------------\n\nTITLE: Adding a Prompt Definition with Arguments to FastMCP Server in TypeScript\nDESCRIPTION: Initializes a FastMCP server and adds a prompt definition named 'git-commit' using `server.addPrompt`. The prompt is described as generating Git commit messages, takes a required argument 'changes', and has an asynchronous `load` function that constructs the final prompt text using the provided 'changes' argument.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new FastMCP({\n  name: \"Test\",\n  version: \"1.0.0\",\n});\n\nserver.addPrompt({\n  name: \"git-commit\",\n  description: \"Generate a Git commit message\",\n  arguments: [\n    {\n      name: \"changes\",\n      description: \"Git diff or description of changes\",\n      required: true,\n    },\n  ],\n  load: async (args) => {\n    return `Generate a concise but descriptive commit message for these changes:\\n\\n${args.changes}`;\n  },\n});\n\nreturn server;\n```\n\n----------------------------------------\n\nTITLE: Analyzing Task Complexity via MCP - Node.js JavaScript\nDESCRIPTION: Defines a direct function and MCP tool to analyze the complexity of a given task, leveraging Node.js and the zod schema validator for parameter enforcement. It expects the taskId parameter and integrates with the analysis logic, returning a standardized object with analysis data or error details.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n// analyzeTaskComplexityDirect.js\nconst { analyzeTaskComplexity } = require('../task-manager');\nconst { findTasksJsonPath } = require('../utils');\n\nmodule.exports = async function analyzeTaskComplexityDirect({ taskId }) {\n  try {\n    const tasksPath = findTasksJsonPath();\n    const analysis = await analyzeTaskComplexity({ tasksPath, taskId });\n    return { success: true, data: analysis };\n  } catch (error) {\n    return { success: false, error };\n  }\n};\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// analyze.js (MCP tool)\nconst z = require('zod');\nconst { executeMCPToolAction } = require('./utils');\nconst { analyzeTaskComplexityDirect } = require('../core/task-master-core');\n\nconst analyzeSchema = z.object({\n  taskId: z.string(),\n});\n\nfunction registerAnalyzeTool(server) {\n  server.addTool({\n    name: 'analyze',\n    params: analyzeSchema,\n    execute: (params) => executeMCPToolAction(() => analyzeTaskComplexityDirect(params)),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MCP Weather Server in Claude for Desktop (MacOS/Linux)\nDESCRIPTION: JSON configuration for adding the Java-based MCP weather server to Claude for Desktop on MacOS/Linux. It specifies the command and arguments to run the server JAR file.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_109\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"mcpServers\": {\n    \"spring-ai-mcp-weather\": {\n      \"command\": \"java\",\n      \"args\": [\n        \"-Dspring.ai.mcp.server.stdio=true\",\n        \"-jar\",\n        \"/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Task Master AI via npm - Bash\nDESCRIPTION: This bash snippet outlines two alternative npm-based installations: global installation for project-independent command access and local installation for project-specific usage. Users can select either command as appropriate for their workflow. Dependency: Node.js and npm must be installed before running these commands.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/tutorial.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install globally\nnpm install -g task-master-ai\n\n# OR install locally within your project\nnpm install task-master-ai\n```\n\n----------------------------------------\n\nTITLE: Implementing Notification Capability Assertions in MCP\nDESCRIPTION: Defines methods for asserting whether specific notification types can be sent based on the client's registered capabilities. This ensures notifications are only sent when supported.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nprotected assertNotificationCapability(\n  method: NotificationT[\"method\"],\n): void {\n  switch (method as ClientNotification[\"method\"]) {\n    case \"notifications/roots/list_changed\":\n      if (!this._capabilities.roots?.listChanged) {\n        throw new Error(\n          `Client does not support roots list changed notifications (required for ${method})`,\n        );\n      }\n      break;\n\n    case \"notifications/initialized\":\n      // No specific capability required for initialized\n      break;\n\n    case \"notifications/cancelled\":\n      // Cancellation notifications are always allowed\n      break;\n\n    case \"notifications/progress\":\n      // Progress notifications are always allowed\n      break;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Resource with Asynchronous Loading to FastMCP Server in TypeScript\nDESCRIPTION: Initializes a FastMCP server and adds a resource definition using `server.addResource`. The resource represents application logs located at 'file:///logs/app.log', has a name 'Application Logs', MIME type 'text/plain', and an asynchronous `load` function that returns the resource content ('Example log content') as text.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst server = new FastMCP({\n  name: \"Test\",\n  version: \"1.0.0\",\n});\n\nserver.addResource({\n  uri: \"file:///logs/app.log\",\n  name: \"Application Logs\",\n  mimeType: \"text/plain\",\n  async load() {\n    return {\n      text: \"Example log content\",\n    };\n  },\n});\n\nreturn server;\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuth Metadata Handler in Express (TypeScript)\nDESCRIPTION: This function creates an Express middleware for serving OAuth server metadata at a well-known endpoint. It configures CORS to allow any origin and restricts requests to the GET method only.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_59\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport express, { RequestHandler } from \"express\";\nimport { OAuthMetadata } from \"../../../shared/auth.js\";\nimport cors from 'cors';\nimport { allowedMethods } from \"../middleware/allowedMethods.js\";\n\nexport function metadataHandler(metadata: OAuthMetadata): RequestHandler {\n  // Nested router so we can configure middleware and restrict HTTP method\n  const router = express.Router();\n\n  // Configure CORS to allow any origin, to make accessible to web-based MCP clients\n  router.use(cors());\n\n  router.use(allowedMethods(['GET']));\n  router.get(\"/\", (req, res) => {\n    res.status(200).json(metadata);\n  });\n\n  return router;\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Client Request Cancellation Handling\nDESCRIPTION: Tests the behavior when a client cancels a request that's in progress. This test sets up a server that delays responding to a request, allowing time for the request to be cancelled by the client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ntest(\"should handle client cancelling a request\", async () => {\n  const server = new Server(\n    {\n      name: \"test server\",\n      version: \"1.0\",\n    },\n    {\n      capabilities: {\n        resources: {},\n      },\n    },\n  );\n\n  // Set up server to delay responding to listResources\n  server.setRequestHandler(\n    ListResourcesRequestSchema,\n    async (request, extra) => {\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n      return {\n        resources: [],\n      };\n    },\n  );\n\n  const [clientTransport, serverTransport] =\n    InMemoryTransport.createLinkedPair();\n```\n\n----------------------------------------\n\nTITLE: Testing Missing Authorization Header in Bearer Authentication\nDESCRIPTION: Test case that verifies the middleware correctly handles missing Authorization headers. It checks that a 401 error is returned when no Authorization header is present in the request.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_84\n\nLANGUAGE: typescript\nCODE:\n```\nit(\"should return 401 when no Authorization header is present\", async () => {\n  const middleware = requireBearerAuth({ provider: mockProvider });\n  await middleware(mockRequest as Request, mockResponse as Response, nextFunction);\n\n  expect(mockVerifyAccessToken).not.toHaveBeenCalled();\n  expect(mockResponse.status).toHaveBeenCalledWith(401);\n  expect(mockResponse.set).toHaveBeenCalledWith(\n    \"WWW-Authenticate\",\n    expect.stringContaining('Bearer error=\"invalid_token\"')\n  );\n  expect(mockResponse.json).toHaveBeenCalledWith(\n    expect.objectContaining({ error: \"invalid_token\", error_description: \"Missing Authorization header\" })\n  );\n  expect(nextFunction).not.toHaveBeenCalled();\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Task Status with Meta-Development Script\nDESCRIPTION: This snippet shows how to use the 'set-status' command to change the status of tasks and subtasks. It includes examples of marking tasks as done or pending, updating specific subtasks, and modifying multiple tasks at once.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/assets/scripts_README.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Mark a task as done\ntask-master set-status --id=3 --status=done\n\n# Mark a task as pending\ntask-master set-status --id=4 --status=pending\n\n# Mark a specific subtask as done\ntask-master set-status --id=3.1 --status=done\n\n# Mark multiple tasks at once\ntask-master set-status --id=1,2,3 --status=done\n```\n\n----------------------------------------\n\nTITLE: Checking Client-Side Request Handler Capabilities in MCP\nDESCRIPTION: Implements a method to check if the client has necessary capabilities to handle specific server requests. This ensures the client only receives requests it can process based on its registered capabilities.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nprotected assertRequestHandlerCapability(method: string): void {\n  switch (method) {\n    case \"sampling/createMessage\":\n      if (!this._capabilities.sampling) {\n        throw new Error(\n          `Client does not support sampling capability (required for ${method})`,\n        );\n      }\n      break;\n\n    case \"roots/list\":\n      if (!this._capabilities.roots) {\n\n\n```\n\n----------------------------------------\n\nTITLE: Defining Completion Request Schema in TypeScript with Zod\nDESCRIPTION: This snippet defines a Zod schema for a completion request, extending the base RequestSchema. It includes method, parameters, and argument information for requesting completion options.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_217\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport const CompleteRequestSchema = RequestSchema.extend({\n  method: z.literal(\"completion/complete\"),\n  params: BaseRequestParamsSchema.extend({\n    ref: z.union([PromptReferenceSchema, ResourceReferenceSchema]),\n    /**\n     * The argument's information\n     */\n    argument: z\n      .object({\n        /**\n         * The name of the argument\n         */\n        name: z.string(),\n        /**\n         * The value of the argument to use for completion matching.\n         */\n        value: z.string(),\n      })\n      .passthrough(),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Mocking FastMCP SDK Components with Jest\nDESCRIPTION: Jest mock implementation for FastMCP SDK components including MCPServer and MCPError. Sets up mock functions for server operations like registerTool, registerResource, start, and stop.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_023.txt#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Mock the FastMCP SDK\njest.mock('@model-context-protocol/sdk', () => ({\n  MCPServer: jest.fn().mockImplementation(() => ({\n    registerTool: jest.fn(),\n    registerResource: jest.fn(),\n    start: jest.fn().mockResolvedValue(undefined),\n    stop: jest.fn().mockResolvedValue(undefined)\n  })),\n  MCPError: jest.fn().mockImplementation(function(message, code) {\n    this.message = message;\n    this.code = code;\n  })\n}));\n\n// Import modules after mocks\nimport { MCPServer, MCPError } from '@model-context-protocol/sdk';\nimport { initMCPServer } from '../../scripts/mcp-server.js';\n```\n\n----------------------------------------\n\nTITLE: Implementing OAuth authorization for SSEClientTransport in TypeScript\nDESCRIPTION: Implements the finishAuth method that processes OAuth authorization code exchange. It throws an error if no auth provider is available or if authorization fails.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_41\n\nLANGUAGE: TypeScript\nCODE:\n```\n  /**\n   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.\n   */\n  async finishAuth(authorizationCode: string): Promise<void> {\n    if (!this._authProvider) {\n      throw new UnauthorizedError(\"No auth provider\");\n    }\n\n    const result = await auth(this._authProvider, { serverUrl: this._url, authorizationCode });\n    if (result !== \"AUTHORIZED\") {\n      throw new UnauthorizedError(\"Failed to authorize\");\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Registering Synchronous Resource in Java MCP SDK\nDESCRIPTION: Creates a synchronous resource registration with a custom URI, name, description, and MIME type. The implementation function handles resource read requests and returns the resource contents when accessed by an MCP client.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_146\n\nLANGUAGE: java\nCODE:\n```\n// Sync resource registration\nvar syncResourceRegistration = new McpServerFeatures.SyncResourceRegistration(\n    new Resource(\"custom://resource\", \"name\", \"description\", \"mime-type\", null),\n    request -> {\n        // Resource read implementation\n        return new ReadResourceResult(contents);\n    }\n);\n```\n\n----------------------------------------\n\nTITLE: Task Status Management Commands in Task Master CLI\nDESCRIPTION: Commands for setting status of single or multiple tasks and subtasks.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/command-reference.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Set status of a single task\ntask-master set-status --id=<id> --status=<status>\n\n# Set status for multiple tasks\ntask-master set-status --id=1,2,3 --status=<status>\n\n# Set status for subtasks\ntask-master set-status --id=1.1,1.2 --status=<status>\n```\n\n----------------------------------------\n\nTITLE: FastMCPSession Class Implementation\nDESCRIPTION: Main session class for handling MCP protocol communication with capabilities, logging, and resource management. Includes type definitions for prompts, resources, and tools.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/fastmcp-core.txt#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport class FastMCPSession<T extends FastMCPSessionAuth = FastMCPSessionAuth> extends FastMCPSessionEventEmitter {\n  #capabilities: ServerCapabilities = {};\n  #clientCapabilities?: ClientCapabilities;\n  #loggingLevel: LoggingLevel = \"info\";\n  #prompts: Prompt[] = [];\n  #resources: Resource[] = [];\n  #resourceTemplates: ResourceTemplate[] = [];\n  #roots: Root[] = [];\n  #server: Server;\n  #auth: T | undefined;\n\n  constructor({\n    auth,\n    name,\n    version,\n    tools,\n    resources,\n    resourcesTemplates,\n    prompts,\n  }: {\n    auth?: T;\n    name: string;\n    version: string;\n\n```\n\n----------------------------------------\n\nTITLE: Managing Filesystem Roots in MCP Client in Java\nDESCRIPTION: Demonstrates how to manage filesystem roots with the MCP client. Roots define the boundaries of where servers can operate within the filesystem, and this snippet shows how to add, remove, and notify the server of changes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_124\n\nLANGUAGE: java\nCODE:\n```\n// Add a root dynamically\nclient.addRoot(new Root(\"file:///path\", \"description\"));\n\n// Remove a root\nclient.removeRoot(\"file:///path\");\n\n// Notify server of roots changes\nclient.rootsListChangedNotification();\n```\n\n----------------------------------------\n\nTITLE: Using Task Master CLI Commands for Complexity Analysis and Task Expansion\nDESCRIPTION: Example CLI commands demonstrating the workflow for analyzing task complexity, reviewing the complexity report, and expanding tasks based on recommendations. Shows how to use the analyze-complexity, complexity-report, and expand commands.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/task-structure.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Generate the complexity analysis report with research capabilities\ntask-master analyze-complexity --research\n\n# Review the report in a readable format\ntask-master complexity-report\n\n# Expand tasks using the optimized recommendations\ntask-master expand --id=8\n# or expand all tasks\ntask-master expand --all\n```\n\n----------------------------------------\n\nTITLE: Handling Server Path Issues in MCP Client\nDESCRIPTION: Examples of correct path usage for the MCP client, showing relative, absolute, and Windows path formats to avoid common connection issues.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_80\n\nLANGUAGE: bash\nCODE:\n```\n# Relative path\nnode build/index.js ./server/build/index.js\n\n# Absolute path\nnode build/index.js /Users/username/projects/mcp-server/build/index.js\n\n# Windows path (either format works)\nnode build/index.js C:/projects/mcp-server/build/index.js\nnode build/index.js C:\\\\projects\\\\mcp-server\\\\build\\\\index.js\n```\n\n----------------------------------------\n\nTITLE: Marking Task Completion\nDESCRIPTION: Command to mark a task as complete and get guidance on next steps.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/examples.md#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nI've finished implementing the authentication system described in task 2. All tests are passing.\nPlease mark it as complete and tell me what I should work on next.\n```\n\n----------------------------------------\n\nTITLE: Testing OAuth Router Endpoints with Supertest\nDESCRIPTION: Test suite verifying route handling for revocation endpoint and excluding unsupported features in the OAuth router.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_103\n\nLANGUAGE: typescript\nCODE:\n```\nit('routes to revocation endpoint', async () => {\n      const response = await supertest(app)\n        .post('/revoke')\n        .type('form')\n        .send({\n          client_id: 'valid-client',\n          client_secret: 'valid-secret',\n          token: 'token_to_revoke'\n        });\n\n      expect(response.status).not.toBe(404);\n    });\n```\n\n----------------------------------------\n\nTITLE: Starting FastMCP Server with SSE Transport in TypeScript\nDESCRIPTION: Starts the previously configured FastMCP server. It specifies 'sse' (Server-Sent Events) as the transport type and provides configuration for the SSE endpoint ('/sse') and the port number (obtained from `getRandomPort`).\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nawait server.start({\n  transportType: \"sse\",\n  sse: {\n    endpoint: \"/sse\",\n    port,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: MCP JSON-RPC Message Format - Notifications\nDESCRIPTION: Defines the structure of JSON-RPC 2.0 notification messages used by MCP transports. These are similar to requests but do not include an ID as they don't expect a response.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  jsonrpc: \"2.0\",\n  method: string,\n  params?: object\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Ping Request Handling in MCP Client\nDESCRIPTION: Test that verifies the server sends ping requests to the client. The test sets up a mock handler for ping requests and verifies it gets called after a delay.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/fastmcp-docs.txt#2025-04-23_snippet_31\n\nLANGUAGE: JavaScript\nCODE:\n```\ntest(\"session sends pings to the client\", async () => {\n  await runWithTestServer({\n    run: async ({ client }) => {\n      const onPing = vi.fn().mockReturnValue({});\n\n      client.setRequestHandler(PingRequestSchema, onPing);\n\n      await delay(2000);\n\n      expect(onPing).toHaveBeenCalledTimes(1);\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Compiler Options\nDESCRIPTION: Sets up the TypeScript configuration file (tsconfig.json) with compiler options for the weather MCP server project.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_97\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"Node16\",\n    \"moduleResolution\": \"Node16\",\n    \"outDir\": \"./build\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Maven BOM Configuration for MCP SDK\nDESCRIPTION: Maven Bill of Materials (BOM) configuration that declares recommended versions of all MCP SDK dependencies to ensure version compatibility.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_134\n\nLANGUAGE: xml\nCODE:\n```\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>io.modelcontextprotocol.sdk</groupId>\n            <artifactId>mcp-bom</artifactId>\n            <version>0.7.0</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n----------------------------------------\n\nTITLE: Running MCP Client from Command Line\nDESCRIPTION: Bash commands for building TypeScript code and running the client with different server types. Shows examples for both Python and Node.js servers.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_79\n\nLANGUAGE: bash\nCODE:\n```\n# Build TypeScript\nnpm run build\n\n# Run the client\nnode build/index.js path/to/server.py # python server\nnode build/index.js path/to/build/index.js # node server\n```\n\n----------------------------------------\n\nTITLE: Getting Implementation Guidance\nDESCRIPTION: Command to request help understanding and approaching a specific task implementation.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/examples.md#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nI'd like to implement task 4. Can you help me understand what needs to be done and how to approach it?\n```\n\n----------------------------------------\n\nTITLE: Requesting a Specific Prompt with Arguments\nDESCRIPTION: JSON-RPC request for retrieving a specific prompt with provided arguments. This example requests the code_review prompt with Python code to analyze.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_118\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"prompts/get\",\n  \"params\": {\n    \"name\": \"code_review\",\n    \"arguments\": {\n      \"code\": \"def hello():\\n    print('world')\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Prompts Capability in Server Initialization\nDESCRIPTION: JSON snippet showing how servers must declare the prompts capability during initialization. The listChanged flag indicates whether the server will emit notifications when available prompts change.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_115\n\nLANGUAGE: json\nCODE:\n```\n{ \"capabilities\": { \"prompts\": { \"listChanged\": true } } }\n```\n\n----------------------------------------\n\nTITLE: License Documentation Requirements\nDESCRIPTION: Markdown specifications for the required license documentation updates, including README.md, LICENSE.md, and CONTRIBUTING.md files.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_039.txt#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n4. Add a clear, concise explanation of the licensing terms in the README.md, including:\n   - A summary of what users can and cannot do with the code\n   - Who holds commercial rights\n   - How to obtain commercial use permission if needed\n   - Links to the full license texts\n\n5. Create a detailed LICENSE.md file that includes:\n   - Full text of both licenses\n   - Clear delineation between commercial and non-commercial use\n   - Specific definitions of what constitutes commercial use\n   - Any additional terms or clarifications specific to this project\n```\n\n----------------------------------------\n\nTITLE: Setting Log Level Request in JSON-RPC\nDESCRIPTION: Demonstrates the JSON-RPC request format for setting the minimum log level. Clients can use this to configure the logging verbosity on the server.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_36\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"logging/setLevel\",\n  \"params\": {\n    \"level\": \"info\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Domain Knowledge Integration Task Definition\nDESCRIPTION: Markdown specification for implementing domain-specific knowledge incorporation system and knowledge base structure.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_010.txt#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n## 4. Implement Domain-Specific Knowledge Incorporation [done]\n### Dependencies: 10.3\n### Description: Develop a system to incorporate domain-specific knowledge into the subtask generation process. This should include identifying key domain concepts, technical requirements, and industry standards from the research results. Create a knowledge base structure that organizes domain information and can be referenced during subtask generation.\n```\n\n----------------------------------------\n\nTITLE: Importing Express RequestHandler in Bearer Authentication Middleware\nDESCRIPTION: Import statement for the Express RequestHandler type used in the bearer authentication middleware implementation. This defines the function signature for Express middleware.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_91\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RequestHandler } from \"express\";\n```\n\n----------------------------------------\n\nTITLE: Multiple Prompt Registration Test\nDESCRIPTION: Demonstrates successful registration of multiple unique prompts in the same server instance.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-js-sdk-docs.txt#2025-04-23_snippet_141\n\nLANGUAGE: typescript\nCODE:\n```\nmcpServer.prompt(\"prompt1\", async () => ({\n  messages: [\n    {\n      role: \"assistant\",\n      content: {\n        type: \"text\",\n        text: \"Test response 1\",\n      },\n    },\n  ],\n}));\n```\n\n----------------------------------------\n\nTITLE: Viewing Claude Desktop MCP Logs\nDESCRIPTION: Bash command to monitor MCP-related log files from Claude Desktop for troubleshooting purposes.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_114\n\nLANGUAGE: bash\nCODE:\n```\n# Check Claude's logs for errors\ntail -n 20 -f ~/Library/Logs/Claude/mcp*.log\n```\n\n----------------------------------------\n\nTITLE: Package Configuration - package.json\nDESCRIPTION: JSON configuration for the npm package, setting module type and build script.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-repo.txt#2025-04-23_snippet_72\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"tsc && chmod 755 build/index.js\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resources Read Request/Response\nDESCRIPTION: Example of resources/read request and response messages for retrieving resource contents.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_129\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"resources/read\",\n  \"params\": {\n    \"uri\": \"file:///project/src/main.rs\"\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"contents\": [\n      {\n        \"uri\": \"file:///project/src/main.rs\",\n        \"mimeType\": \"text/x-rust\",\n        \"text\": \"fn main() {\\n    println!(\\\"Hello world!\\\");\\n}\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Troubleshooting Task Master Initialization\nDESCRIPTION: Commands for troubleshooting task-master initialization issues by running the init script directly through Node.js or by cloning the repository.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/configuration.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnode node_modules/claude-task-master/scripts/init.js\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/eyaltoledano/claude-task-master.git\ncd claude-task-master\nnode scripts/init.js\n```\n\n----------------------------------------\n\nTITLE: JSON-RPC Ping Request Format\nDESCRIPTION: Standard JSON-RPC ping request format with no parameters, used for connection health checks.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/context/mcp-protocol-spec.txt#2025-04-23_snippet_75\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"123\",\n  \"method\": \"ping\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementation Guidance Generator\nDESCRIPTION: System utilizing Anthropic Claude API to generate detailed implementation guidance with caching mechanisms for performance optimization.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/tasks/task_014.txt#2025-04-23_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Viewing Complexity Report\nDESCRIPTION: Command to request a more readable format of the complexity report.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/docs/examples.md#2025-04-23_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\nCan you show me the complexity report in a more readable format?\n```\n\n----------------------------------------\n\nTITLE: Documenting Version 0.11.0 in Markdown\nDESCRIPTION: Placeholder for version 0.11.0 changes, which are not detailed in the provided changelog excerpt.\nSOURCE: https://github.com/eyaltoledano/claude-task-master/blob/main/CHANGELOG.md#2025-04-23_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n## 0.11.0\n```"
  }
]