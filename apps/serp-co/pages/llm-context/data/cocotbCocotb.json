[
  {
    "owner": "cocotb",
    "repo": "cocotb",
    "content": "TITLE: Assigning Values to DUT Signals in Python\nDESCRIPTION: Demonstrates assigning values to signals in the DUT using the `.value` attribute of a signal handle. It shows direct assignment to a toplevel signal and assignment to a signal deeper in the hierarchy, including indexing into a memory array. These assignments are scheduled and applied in the next simulator write cycle.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Get a reference to the \"clk\" signal and assign a value\nclk = dut.clk\nclk.value = 1\n\n# Direct assignment through the hierarchy\ndut.input_signal.value = 12\n\n# Assign a value to a memory deeper in the hierarchy\n# (\"inst_sub_block\" and \"inst_memory\" are instance names of the\n# respective Verilog modules or VHDL entity/components in the DUT)\ndut.inst_sub_block.inst_memory.mem_array[4].value = 2\n```\n\n----------------------------------------\n\nTITLE: Generating Clock Signal in Testbench - Cocotb Python\nDESCRIPTION: Create and start a clock process for a DUT clock signal. Requires Clock imported from cocotb and a signal handle attached to 'dut.clk'. Inputs are signal handle, period, and units; output is a running clock in simulation.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nclk = Clock(dut.clk, 12, \"ns\").start()\n```\n\n----------------------------------------\n\nTITLE: Awaiting cocotb RisingEdge Trigger in Python Coroutine\nDESCRIPTION: This snippet demonstrates how to pause a cocotb coroutine until a `RisingEdge` trigger fires on a signal named `clk`. The coroutine's execution will pause at the `await` statement and resume immediately after the rising edge occurs, allowing actions to be performed precisely relative to simulation events.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/triggers.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def coro():\n    print(\"Some time before a clock edge\")\n    await RisingEdge(clk)\n    print(\"Immediately after the rising clock edge\")\n```\n\n----------------------------------------\n\nTITLE: Marking Test Coroutines with cocotb.test Decorator - Python\nDESCRIPTION: Declare a Python coroutine as a cocotb test using the @cocotb.test decorator. Can apply options such as skipping, expecting failure, or imposing timeouts with keyword arguments. Valid only in testbench contexts; target is a coroutine. Output is cocotb recognizing the function as a regression test.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_18\n\nLANGUAGE: Python\nCODE:\n```\n@cocotb.test(skip, expect_fail, timeout_time, timeout_unit)\n```\n\n----------------------------------------\n\nTITLE: Concurrent Coroutine Execution and Task Management - Cocotb Python\nDESCRIPTION: Launch and manage multiple cocotb coroutines concurrently, including immediate or deferred task start and result retrieval. Requires cocotb and coroutine functions to be defined. Inputs are coroutine objects; outputs are task handles and coroutine return values.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\ntask_0 = await cocotb.start(coro_0())\n```\n\nLANGUAGE: Python\nCODE:\n```\ntask_1 = cocotb.start_soon(coro)\n```\n\nLANGUAGE: Python\nCODE:\n```\nresult = await task_0\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Cocotb Tests in Python\nDESCRIPTION: Shows the fundamental way to define a Cocotb test using the `@cocotb.test` decorator above an `async` function. The decorated function automatically receives the DUT handle (`dut`) as an argument. Both `@cocotb.test` and `@cocotb.test()` syntaxes are valid for defining a test.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# A valid cocotb test\n@cocotb.test\nasync def test(dut):\n    pass\n\n# Also a valid cocotb test\n@cocotb.test()\nasync def test(dut):\n    pass\n```\n\n----------------------------------------\n\nTITLE: Managing Concurrent and Sequential Coroutine Execution in Python\nDESCRIPTION: Demonstrates controlling the execution flow of asynchronous coroutines in Cocotb. Using `await` runs a coroutine (`reset_dut`) sequentially, blocking the current context until it completes. Using `cocotb.start_soon` runs the coroutine concurrently, allowing the main test flow to continue. The example shows awaiting the completion of the concurrently started task later using `await reset_thread`. Requires `cocotb` and `cocotb.triggers.Timer`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# A coroutine\nasync def reset_dut(reset_n, duration_ns):\n    reset_n.value = 0\n    await Timer(duration_ns, unit=\"ns\")\n    reset_n.value = 1\n    cocotb.log.debug(\"Reset complete\")\n\n@cocotb.test()\nasync def parallel_example(dut):\n    reset_n = dut.reset\n\n    # Execution will block until reset_dut has completed\n    await reset_dut(reset_n, 500)\n    cocotb.log.debug(\"After reset\")\n\n    # Run reset_dut concurrently\n    reset_thread = cocotb.start_soon(reset_dut(reset_n, duration_ns=500))\n\n    # This timer will complete before the timer in the concurrently executing \"reset_thread\"\n    await Timer(250, unit=\"ns\")\n    cocotb.log.debug(\"During reset (reset_n = %s)\" % reset_n.value)\n\n    # Wait for the other thread to complete\n    await reset_thread\n    cocotb.log.debug(\"After reset\")\n```\n\n----------------------------------------\n\nTITLE: Waiting for Time or Edges - Cocotb Python\nDESCRIPTION: Pause coroutine execution for a specified simulation time or for a signal edge (rising, falling, or any). Requires cocotb.triggers to be imported. Inputs are time values and signal objects; outputs are resumption of coroutine.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nawait cocotb.triggers.Timer(12, \"ns\")\n```\n\nLANGUAGE: Python\nCODE:\n```\nawait cocotb.triggers.RisingEdge(dut.mysignal)\n```\n\nLANGUAGE: Python\nCODE:\n```\nawait cocotb.triggers.FallingEdge(dut.mysignal)\n```\n\nLANGUAGE: Python\nCODE:\n```\nawait cocotb.triggers.Edge(dut.mysignal)\n```\n\n----------------------------------------\n\nTITLE: Waiting on Multiple Tasks or Triggers - First and Combine - Cocotb Python\nDESCRIPTION: Wait until one or all of a set of coroutines or triggers completes, using First (any) or Combine (all). Prerequisite: cocotb.triggers imported, relevant tasks or triggers defined. Inputs are tasks or trigger objects; output is synchronization of coroutine resumption.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nawait cocotb.triggers.First(task_0, trigger_1)\n```\n\nLANGUAGE: Python\nCODE:\n```\nawait cocotb.triggers.Combine(task_0, trigger_1)\n```\n\n----------------------------------------\n\nTITLE: Cleaning Up Resources in Concurrent Tasks (Python)\nDESCRIPTION: Demonstrates a pattern for resource cleanup within a cocotb task started using `cocotb.start_soon`. By placing cleanup code (e.g., setting a signal back to a default value) within a `finally` block, it ensures execution whether the task completes normally, is explicitly cancelled, or the test ends.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test()\nasync def test(dut):\n\n    async def drive_data_valid(intf, sequence):\n        try:\n            intf.valid.value = 1\n            for data in sequence:\n                intf.data.value = data\n        finally:\n            # Ensure that valid is brought back to 0 when the test ends,\n            # the Task is explicitly cancelled, or if the Task ends normally.\n            intf.valid.value = 0\n\n    # Generate sequence\n    sequence = ...\n\n    # Run driver Task concurrently\n    cocotb.start_soon(drive_data_valid(dut.data_in, sequence))\n\n    # Do other stuff\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout with First Trigger in cocotb (Python)\nDESCRIPTION: This cocotb test coroutine drives stimulus and then uses the `First` trigger to wait for either a concurrent task (`quiesce_task`) representing the DUT becoming idle, or a timeout `Timer`. It starts the `quiesce` coroutine as a task using `start_soon` and asserts if the timeout trigger fired first, indicating the design may have hung. Requires a DUT object, `generate_transactions`, `drive`, `quiesce` coroutines, `Timer`, `First`, and `start_soon`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test\nasync def test_quiesce_or_timeout(dut):\n\n    # generate stimulus and drive it to the design\n    for trans in generate_transactions():\n        await drive(dut.intf, trans)\n\n    # wait for the design to quiesce or timeout\n    timeout = Timer(10, \"us\")\n    quiesce_task = cocotb.start_soon(quiesce())\n    result = await First(timeout, quiesce_task)\n    assert result is not timeout, \"Design has hung!\"\n```\n\n----------------------------------------\n\nTITLE: Waiting for First Task Completion with Task.complete (Python)\nDESCRIPTION: This cocotb test coroutine starts two concurrent tasks (`drive_A` and `drive_B`) using `cocotb.start_soon`. It then uses the `First` trigger, passing the `.complete` attribute of each task, to wait for the first task to finish. After one task completes, it checks which task's `.complete` object was returned by `First` to identify which task finished first and logs the result. Requires `drive_A` and `drive_B` coroutines, `First`, and `start_soon`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test\nasync def test_which_finished_first(dut):\n\n    task_A = cocotb.start_soon(drive_A())\n    task_B = cocotb.start_soon(drive_B())\n\n    # Pass Task.complete rather than the Task directly.\n    result = await First(task_A.complete, task_B.complete)\n\n    # Compare the result against the Task's \"complete\" object.\n    if result is task_A.complete:\n        cocotb.log.info(\"Input A finished first\")\n    else:\n        cocotb.log.info(\"Input B finished first\")\n```\n\n----------------------------------------\n\nTITLE: Accessing DUT Signals and Sub-modules in Python\nDESCRIPTION: Illustrates accessing signals and sub-modules within the Design Under Test (DUT) hierarchy using Python's dot notation. It shows how to get a handle to a toplevel signal (`dut.clk`) and a signal within a nested instance (`dut.inst_sub_block.count`). Assumes `dut` is the handle to the toplevel instance provided by Cocotb.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Get a reference to the \"clk\" signal on the toplevel\nclk = dut.clk\n\n# Get a reference to a register \"count\"\n# in a sub-block \"inst_sub_block\"\n# (the instance name of a Verilog module or VHDL entity/component)\ncount = dut.inst_sub_block.count\n```\n\n----------------------------------------\n\nTITLE: Awaiting Timer Trigger in cocotb (Python)\nDESCRIPTION: This asynchronous function (cocotb coroutine) demonstrates pausing simulation execution using a `Timer` trigger. It logs a message before and after awaiting the trigger, which waits for 10 nanoseconds of simulation time to pass, allowing simulation time to advance. Requires cocotb and the `Timer` class.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def wait_10ns():\n    cocotb.log.info(\"About to wait for 10 ns\")\n    await Timer(10, unit='ns')\n    cocotb.log.info(\"Simulation time has advanced by 10 ns\")\n```\n\n----------------------------------------\n\nTITLE: Waiting for Multiple Tasks with Combine Trigger (Python)\nDESCRIPTION: This cocotb test coroutine defines an inner asynchronous function `drive_transactions` and then uses the `Combine` trigger to wait for the completion of two concurrent tasks: driving transactions and the design becoming quiescent. Both tasks are scheduled using `cocotb.start_soon`, and the test waits until both have finished before proceeding, demonstrating synchronization of multiple independent activities. Requires a DUT object, `generate_transactions`, `drive`, `quiesce` coroutines, `Combine`, and `start_soon`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test\nasync def test_wait_for_both(dut):\n\n    # generate stimulus and drive it to the design\n    async def drive_transactions():\n        for trans in generate_transactions():\n            await drive(dut.intf, trans)\n\n    # wait for both the driving and quiescing to complete before continuing\n    await Combine(\n        cocotb.start_soon(drive_transactions()),\n        cocotb.start_soon(quiesce())\n    )\n```\n\n----------------------------------------\n\nTITLE: Using Python Logging in Cocotb Tests\nDESCRIPTION: Demonstrates using Python's standard `logging` library within a Cocotb test. It shows how to get a logger instance using `logging.getLogger` and log messages at different severity levels (debug, info, warning, error, critical). This is the recommended way to output messages instead of `print`. Requires importing `logging` and `cocotb`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nimport cocotb\n\n@cocotb.test()\nasync def test(dut):\n    # Create a logger for this testbench\n    logger = logging.getLogger(\"my_testbench\")\n\n    logger.debug(\"This is a debug message\")\n    logger.info(\"This is an info message\")\n    logger.warning(\"This is a warning message\")\n    logger.error(\"This is an error message\")\n    logger.critical(\"This is a critical message\")\n```\n\n----------------------------------------\n\nTITLE: Using Cocotb Python Runner with Pytest (Python)\nDESCRIPTION: Demonstrates how to integrate the cocotb Python runner into a pytest test function. It shows importing `get_runner`, getting the runner instance based on environment variables (SIM, HDL_TOPLEVEL_LANG), and executing the simulation test using the `runner.test` method with parameters like `hdl_toplevel` and `test_module`. The environment variables are read by the Python script itself.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/runner.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef test_simple_dff_runner():\n    \"\"\"Test the DFF example using the Python runner.\"\"\"\n    sim = os.getenv(\"SIM\", \"questa\")\n    hdl_toplevel_lang = os.getenv(\"HDL_TOPLEVEL_LANG\", \"vhdl\")\n\n    runner = get_runner(sim)\n\n    runner.test(hdl_toplevel=\"dff\", test_module=\"test_dff,\")\n```\n\n----------------------------------------\n\nTITLE: Forcing and Freezing DUT Signals in Python\nDESCRIPTION: Illustrates advanced signal control methods beyond simple value assignment (deposit). It shows how to use `Deposit` (standard assignment), `Force` (overrides signal value until released), `Freeze` (holds the signal's current value until released), and `Release` (removes any active force or freeze). Requires importing these actions from `cocotb.handle`. Note that simulator support for these features may vary.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Deposit action\ndut.my_signal.value = 12\ndut.my_signal.value = Deposit(12)  # equivalent syntax\n\n# Force action\ndut.my_signal.value = Force(12)    # my_signal stays 12 until released\n\n# Release action\ndut.my_signal.value = Release()    # Reverts any force/freeze assignments\n\n# Freeze action\ndut.my_signal.value = Freeze()     # my_signal stays at current value until released\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Clocks in cocotb Test (Python)\nDESCRIPTION: This cocotb test coroutine demonstrates how to create, start, and stop multiple `Clock` objects driving the same DUT clock pin with different frequencies. It verifies the period of each clock by waiting for a rising edge using `RisingEdge` and checking the simulation time elapsed using `get_sim_time`. Requires a DUT object with a `clk` attribute, `Clock`, `Timer`, `RisingEdge`, `get_sim_time`, and `isclose`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test()\nasync def test_different_clocks(dut):\n    clk_1mhz   = Clock(dut.clk, 1.0, unit='us')\n    clk_250mhz = Clock(dut.clk, 4.0, unit='ns')\n\n    clk_1mhz.start()\n    start_time_ns = get_sim_time(unit='ns')\n    await Timer(1, unit='ns')\n    await RisingEdge(dut.clk)\n    edge_time_ns = get_sim_time(unit='ns')\n    assert isclose(edge_time_ns, start_time_ns + 1000.0), \"Expected a period of 1 us\"\n\n    clk_1mhz.stop()  # stop 1MHz clock here\n\n    clk_250mhz.start()\n    start_time_ns = get_sim_time(unit='ns')\n    await Timer(1, unit='ns')\n    await RisingEdge(dut.clk)\n    edge_time_ns = get_sim_time(unit='ns')\n    assert isclose(edge_time_ns, start_time_ns + 4.0), \"Expected a period of 4 ns\"\n```\n\n----------------------------------------\n\nTITLE: Using Async Generators with async for (Python)\nDESCRIPTION: This snippet defines an async generator function `ten_samples_of` that yields a signal's value after each rising edge of a clock for 10 cycles using `RisingEdge`. The cocotb test coroutine `test_samples_are_even` demonstrates consuming this async generator using `async for`, iterating through the sampled values and asserting that each sample is even. Requires a DUT object with `clk` and `signal` attributes, and `RisingEdge`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nasync def ten_samples_of(clk, signal):\n    for i in range(10):\n        await RisingEdge(clk)\n        yield signal.value  # this means \"send back to the for loop\"\n\n@cocotb.test()\nasync def test_samples_are_even(dut):\n    async for sample in ten_samples_of(dut.clk, dut.signal):\n        assert sample % 2 == 0\n```\n\n----------------------------------------\n\nTITLE: Converting Signal Values to Standard Types - Cocotb Python\nDESCRIPTION: Convert DUT signal values to unsigned, signed integers, or byte arrays, and to strings for logging or external use. Each method is suitable for a particular data interpretation; ensure correct context and signal width. Input is the signal value, outputs are Python primitives.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nval = dut.mysignal.value.to_unsigned()\n```\n\nLANGUAGE: Python\nCODE:\n```\nval = dut.mysignal.value.to_signed()\n```\n\nLANGUAGE: Python\nCODE:\n```\nval = dut.mysignal.value.to_bytes(byteorder=\"little\")\n```\n\nLANGUAGE: Python\nCODE:\n```\nval = str(dut.mysignal.value)\n```\n\n----------------------------------------\n\nTITLE: Passing a cocotb Test (Python)\nDESCRIPTION: Provides examples of cocotb tests that result in a 'passed' status. A test passes if its coroutine completes without failing or erroring (e.g., containing only correct assertions). Alternatively, a test can be explicitly passed early by calling `cocotb.pass_test()`, either directly or from within a concurrent task started via `cocotb.start_soon`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test()\nasync def test(dut):\n    assert 2 > 1  # assertion is correct, then the coroutine ends\n\n@cocotb.test()\nasync def test(dut):\n    cocotb.pass_test(\"Reason\")  # ends test with success early\n    assert 1 > 2  # this would fail, but it isn't run because the test was ended early\n\n@cocotb.test()\nasync def test(dut):\n    async def ends_test_with_pass():\n        cocotb.pass_test(\"Reason\")\n    cocotb.start_soon(ends_test_with_pass())\n    await Timer(10, 'ns')\n```\n\n----------------------------------------\n\nTITLE: Assigning Signed/Unsigned Integers to Signals in Python\nDESCRIPTION: Illustrates assigning Python integers (both positive and negative) to a DUT signal (`dut.data_in`). Cocotb handles the assignment based on the signal's width, allowing values from -2**(N-1) to 2**N - 1. Assigning out-of-range values (-5 or 8 for a 3-bit signal) raises a `ValueError`. This example assumes a DUT based on the preceding Verilog snippet.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# assignment of negative value\ndut.data_in.value = -4\n\n# assignment of positive value\ndut.data_in.value = 7\n\n# assignment of out-of-range values\ndut.data_in.value = 8   # raises ValueError\ndut.data_in.value = -5  # raises ValueError\n```\n\n----------------------------------------\n\nTITLE: Discovering DUT Elements using dir() in Python\nDESCRIPTION: Shows how to use the Python built-in `dir()` function on Cocotb handles to list available elements like instances, signals, constants, or packages at different hierarchy levels. Examples demonstrate listing elements of the toplevel (`dut`), a sub-block (`dut.inst_sub_block`), and Cocotb packages (`cocotb.packages`). Output is shown using `cocotb.log.info`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Print the instances and signals (which includes the ports) of the design's toplevel\ncocotb.log.info(dir(dut))\n\n# Print the instances and signals of \"inst_sub_block\" under the toplevel\n# which is the instance name of a Verilog module or VHDL entity/component\ncocotb.log.info(dir(dut.inst_sub_block))\n\n# Print the packages\ncocotb.log.info(dir(cocotb.packages))\n```\n\n----------------------------------------\n\nTITLE: Failing a cocotb Test using Assertions (Python)\nDESCRIPTION: Illustrates two scenarios where a cocotb test will be marked as 'failed'. The first uses an `assert` statement directly within the test coroutine. The second shows an `assert` failing within a concurrent task started using `cocotb.start_soon`. Both result in an `AssertionError` and test failure.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test()\nasync def test(dut):\n    assert 1 > 2, \"Testing the obvious\"\n\n@cocotb.test()\nasync def test(dut):\n    async def fails_test():\n        assert 1 > 2\n    cocotb.start_soon(fails_test())\n    await Timer(10, 'ns')\n```\n\n----------------------------------------\n\nTITLE: Assigning Signal Value in Cocotb - Python\nDESCRIPTION: Assign a hexadecimal value directly to a signal's value in the Device Under Test (DUT) using cocotb. Requires the DUT to be initialized and accessible as 'dut'. 'mysignal' should reference a signal defined in the design. The assignment immediately updates the value in simulation. The input is a numeric value; output is the signal set in the simulation.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndut.mysignal.value = 0xFF00\n```\n\n----------------------------------------\n\nTITLE: Queue Operations for Thread-Safe Communication - Cocotb Python\nDESCRIPTION: Provide asynchronous and synchronous write/read access to queues between cocotb coroutines. Supports put (awaited or immediate), get (awaited or immediate), and query operations on queue state (maxsize, qsize, empty, full). Specialized queues like PriorityQueue and LifoQueue are available. Inputs are queue objects and items; outputs are data transfer or attribute access.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\nawait cocotb.queue.Queue.put(item)\n```\n\nLANGUAGE: Python\nCODE:\n```\ncocotb.queue.Queue.put_nowait(item)\n```\n\nLANGUAGE: Python\nCODE:\n```\nitem = await cocotb.queue.Queue.get()\n```\n\nLANGUAGE: Python\nCODE:\n```\nitem = cocotb.queue.Queue.get_nowait()\n```\n\nLANGUAGE: Python\nCODE:\n```\nqueue.maxsize\n```\n\nLANGUAGE: Python\nCODE:\n```\nqueue.qsize()\n```\n\nLANGUAGE: Python\nCODE:\n```\nqueue.empty()\n```\n\nLANGUAGE: Python\nCODE:\n```\nqueue.full()\n```\n\nLANGUAGE: Python\nCODE:\n```\n.PriorityQueue\n```\n\nLANGUAGE: Python\nCODE:\n```\n.LifoQueue\n```\n\n----------------------------------------\n\nTITLE: Erroring a cocotb Test with Exceptions (Python)\nDESCRIPTION: Demonstrates two ways a cocotb test can terminate with an 'error' status. This occurs when an exception other than `AssertionError` is raised and not caught. Examples show a `NameError` (undefined coroutine) and an `AttributeError` (accessing non-existent signal) occurring directly in the test or within a task started by `cocotb.start_soon`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test()\nasync def test(dut):\n    await coro_that_does_not_exist()  # NameError\n\n@cocotb.test()\nasync def test(dut):\n    async def coro_with_an_error():\n        dut.signal_that_does_not_exist.value = 1  # AttributeError\n    cocotb.start_soon(coro_with_an_error())\n    await Timer(10, 'ns')\n```\n\n----------------------------------------\n\nTITLE: Forking an async coroutine in cocotb (Python)\nDESCRIPTION: This example demonstrates how to fork a non-decorated async coroutine in cocotb. It defines an asynchronous function `example` that uses `cocotb.triggers.Timer` and then forks this function using `cocotb.fork`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/release_notes.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def example():\n    for i in range(10):\n        await cocotb.triggers.Timer(10, \"ns\")\n\ncocotb.fork(example())\n```\n\n----------------------------------------\n\nTITLE: Reading and Aliasing Signal Values - Cocotb Python\nDESCRIPTION: Read the current value from a DUT signal and optionally create an alias/reference for repeated access or brevity. Assumes 'dut' is connected to the simulation scope. No dependencies beyond cocotb and signal initialization. Returns the current signal value or reference; input is the target signal.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nval = dut.mysignal.value\n```\n\nLANGUAGE: Python\nCODE:\n```\nmysig = dut.mysignal\n```\n\n----------------------------------------\n\nTITLE: Accessing Extended or Escaped Identifiers - Cocotb Python\nDESCRIPTION: Refer to signals or nodes with extended or special-character identifiers using dictionary-style notation and escaping. Useful for accessing VHDL/Verilog signals with unusual names. Input is string identifier; output is signal handle.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\ndut[\"\\\\!Hello!\\\\\"]\n```\n\n----------------------------------------\n\nTITLE: Immediate Signal Assignment Using Immediate - Cocotb Python\nDESCRIPTION: Force an immediate assignment of a value to a DUT signal using the Immediate wrapper, ensuring the assignment isn't subject to any scheduling delays. Requires cocotb and the Immediate helper to be imported and 'dut' initialized. Input is the value to assign; output is the signal set instantly within the simulation timestep.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndut.mysignal.value = Immediate(0xFF00)\n```\n\n----------------------------------------\n\nTITLE: Executing Testbench Coroutine with Clock and Reset (Python)\nDESCRIPTION: This cocotb test coroutine sets up a clock signal using `cocotb.Clock` and starts it. It then awaits a user-defined coroutine (`tb.reset_dut`) to perform a reset sequence. Finally, it waits for specific time durations using `Timer` triggers and prints the state of the reset signal, demonstrating a basic testbench setup and flow control. Requires a DUT object, a `uart_tb` class instance, and `reset_dut` coroutine.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test()\nasync def test_act_during_reset(dut):\n    \"\"\"While reset is active, toggle signals\"\"\"\n    tb = uart_tb(dut)\n    # \"Clock\" is a built in class for toggling a clock signal\n    Clock(dut.clk, 1, unit='ns').start()\n    # reset_dut is a function -\n    # part of the user-generated \"uart_tb\" class\n    # run reset_dut immediately before continuing\n    await tb.reset_dut(dut.rstn, 20)\n\n    await Timer(10, unit='ns')\n    print(\"Reset is still active: %d\" % dut.rstn)\n    await Timer(15, unit='ns')\n    print(\"Reset has gone inactive: %d\" % dut.rstn)\n```\n\n----------------------------------------\n\nTITLE: Checking Signal Value with Assertion - Cocotb Python\nDESCRIPTION: Assert that a signal meets an expected value, raising an error if not. The assertion provides a custom error message. Input is the signal and expected value; output is exception raised on mismatch.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nassert dut.mysignal.value == exp, \"Not as expected!\"\n```\n\n----------------------------------------\n\nTITLE: Concatenating Iterables in cocotb using itertools.chain\nDESCRIPTION: Demonstrates the recommended method for concatenating two iterables (`a` and `b`) in cocotb after the removal of `cocotb.types.concat`. It uses `itertools.chain` to combine the iterables and wraps the result in `cocotb.types.Array`. Requires importing `itertools` and having `cocotb.types.Array` available.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/3705.removal.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom cocotb.types import Array\nimport itertools\n\n# Assuming 'a' and 'b' are iterables you want to concatenate\nresult = Array(itertools.chain(a, b))\n```\n\n----------------------------------------\n\nTITLE: Accessing DUT Signals with Special Names using Index Syntax (Python)\nDESCRIPTION: Demonstrates accessing signals or other objects within the design under test (DUT) using Python's index syntax (`[]`). This method is necessary for identifiers that are not valid Python attributes, such as those starting with underscores or containing special characters (escaped/extended identifiers).\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndut[\"_some_signal\"]  # begins with underscore\ndut[\"\\\\!WOOOOW!\\\\\"]  # escaped identifier (Verilog), extended identifier (VHDL)\n```\n\n----------------------------------------\n\nTITLE: Returning Values from Coroutines in cocotb (Python)\nDESCRIPTION: Defines two coroutines: `get_signal` which waits for a clock rising edge using `RisingEdge` and returns a signal's value, and `check_signal_changes` which uses `get_signal` twice to sample a signal on two consecutive clock edges. It then asserts that the signal value changed between the two samples. Requires a DUT object with `clk` and `signal` attributes, and the `RisingEdge` trigger.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def get_signal(clk, signal):\n    await RisingEdge(clk)\n    return signal.value\n\nasync def check_signal_changes(dut):\n    first = await get_signal(dut.clk, dut.signal)\n    second = await get_signal(dut.clk, dut.signal)\n    assert first != second, \"Signal did not change\"\n```\n\n----------------------------------------\n\nTITLE: Installing cocotb Using pip Package Manager in Stable Release\nDESCRIPTION: Installs the latest stable version of the cocotb Python package via pip. This command should be run in a terminal with an appropriate Python environment where pip is available. Users without administrative privileges may append the --user option. It requires prior installation of Python and pip.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npip install cocotb\n```\n\n----------------------------------------\n\nTITLE: Cocotb Parameterize Decorator Example 2\nDESCRIPTION: This example demonstrates an alternative way to use `@cocotb.parametrize` where the parameter names are provided as a tuple and the values are provided as a list of tuples. Each tuple in the list corresponds to a set of values for the specified parameters. No external dependencies beyond cocotb are needed.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n``@cocotb.parametrize((\"arg1\", \"arg2\"), [(1, \"a\"), (3, \"b\")])``\n```\n\n----------------------------------------\n\nTITLE: Retrieving Vector Length of a Signal - Cocotb Python\nDESCRIPTION: Obtain the bitwidth (number of bits) of a signal for bounds checking or dynamic interfacing. No external dependencies; input is signal reference, output is integer length.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nnum_bits = len(dut.mysignal)\n```\n\n----------------------------------------\n\nTITLE: Setting Random Seed via Make Variable\nDESCRIPTION: Illustrates how to pass the COCOTB_RANDOM_SEED environment variable to the `make` command. This forces a specific random seed for a cocotb test run, enabling reproducibility of test stimuli based on a previously reported seed.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/building.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake COCOTB_RANDOM_SEED=1377424946\n```\n\n----------------------------------------\n\nTITLE: Setting Simulator to Cadence Incisive\nDESCRIPTION: This code snippet shows how to set the simulator to Cadence Incisive using the `make` command.  This allows cocotb to be used with the Cadence Incisive simulator (ius).\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=ius\n```\n\n----------------------------------------\n\nTITLE: Enabling FST Waveform Tracing with Verilator\nDESCRIPTION: This snippet shows how to enable FST waveform tracing in Verilator by appending the trace options to the `EXTRA_ARGS` make variable. This generates an FST file which is smaller than VCD.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_5\n\nLANGUAGE: make\nCODE:\n```\nEXTRA_ARGS += --trace --trace-fst --trace-structs\n```\n\n----------------------------------------\n\nTITLE: Awaiting Another Coroutine in cocotb (Python)\nDESCRIPTION: This asynchronous function demonstrates awaiting another coroutine (`wait_10ns`) multiple times within a loop. It effectively waits for a total of 100 nanoseconds by repeatedly calling and awaiting the simpler coroutine, showcasing how coroutines can be composed. Requires the `wait_10ns` coroutine to be defined.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def wait_100ns():\n    for i in range(10):\n        await wait_10ns()\n```\n\n----------------------------------------\n\nTITLE: Extracting Bit Slices from Signal Values - Cocotb Python\nDESCRIPTION: Access specific bits or slices of a signal's value for granular inspection or manipulation. Assumes signal width supports slicing. Returns integer or subvector; input is the value property of the signal.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nmybit = dut.mysignal.value[0]\n```\n\nLANGUAGE: Python\nCODE:\n```\nmybits = dut.mysignal.value[3:1]\n```\n\n----------------------------------------\n\nTITLE: Exercising Analog and Digital Submodules in a cocotb Testbench (Python)\nDESCRIPTION: The test_analog_model.py example provides a cocotb-based testbench for verifying the integrated behavior of the analog and digital components. It initializes the simulation, stimulates inputs to the AFE, and verifies correct digital response and PGA gain switching. Dependencies include cocotb, the analog and digital module models, and correct Makefile configuration for simulation. Key parameters include input voltages, expected digital output, and assertion thresholds. Usable in CI pipelines for regression testing.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/analog_model.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/analog_model/test_analog_model.py\n   :language: python\n```\n\n----------------------------------------\n\nTITLE: Example Verilog Module for Signal Assignments\nDESCRIPTION: Defines a simple Verilog module `my_module` with clock, reset, a 3-bit logic input `data_in`, and a 3-bit logic output `data_out`. This module serves as context for the subsequent Python snippet demonstrating signed and unsigned value assignments to `data_in`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_4\n\nLANGUAGE: verilog\nCODE:\n```\nmodule my_module (\n    input   logic       clk,\n    input   logic       rst,\n    input   logic [2:0] data_in,\n    output  logic [2:0] data_out\n    );\n```\n\n----------------------------------------\n\nTITLE: Setting the value of a cocotb.handle.NonHierarchyIndexableObject (HDL arrays) (Python)\nDESCRIPTION: This code shows how to set the value of a `cocotb.handle.NonHierarchyIndexableObject` which represents an HDL array. It demonstrates setting values for both one-dimensional and two-dimensional arrays.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/release_notes.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Now supported\ndut.some_array <= [0xAA, 0xBB, 0xCC]\ndut.some_array.value = [0xAA, 0xBB, 0xCC]\n\n# For simulators that support n-dimensional arrays\ndut.some_2d_array <= [[0xAA, 0xBB], [0xCC, 0xDD]]\ndut.some_2d_array.value = [[0xAA, 0xBB], [0xCC, 0xDD]]\n```\n\n----------------------------------------\n\nTITLE: Installing Prerequisites on Debian-based Linux Using apt-get\nDESCRIPTION: Installs essential build tools and Python development libraries required for running cocotb on Debian-based Linux distributions. The command installs make, Python3, pip for Python3, and Python development headers. This snippet depends on having sudo privileges and apt package manager.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install make python3 python3-pip libpython3-dev\n```\n\n----------------------------------------\n\nTITLE: Running GHDL Simulation with VCD Waveform Output (Bash)\nDESCRIPTION: Demonstrates how to invoke the make command from a shell to run the GHDL simulator with waveform dumping enabled. By specifying the SIM_ARGS environment variable inline with '--vcd=anyname.vcd', the generated VCD file will be named 'anyname.vcd'. This approach allows flexibility for passing extra simulator arguments at runtime. Requires a functional GHDL installation and a compatible Makefile.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_16\n\nLANGUAGE: Bash\nCODE:\n```\nSIM_ARGS=--vcd=anyname.vcd make SIM=ghdl\n```\n\n----------------------------------------\n\nTITLE: Assigning Metavalues to Signals with Logic and LogicArray - Cocotb Python\nDESCRIPTION: Assign logic metavalues such as 'X', 'Z', '0', '1' to a signal in the DUT for advanced simulation scenarios. Utilizes cocotb's Logic and LogicArray wrappers. Prerequisite: cocotb initialized and appropriate imports. Inputs are logic/metavalue strings; outputs are the signal assuming 'unknown' or multiple states in the simulator.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndut.mysignal.value = Logic(\"X\")\n```\n\nLANGUAGE: Python\nCODE:\n```\ndut.mysignal.value = LogicArray(\"01XZ\")\n```\n\n----------------------------------------\n\nTITLE: Setting Simulator to Cadence Xcelium\nDESCRIPTION: This code snippet shows how to set the simulator to Cadence Xcelium using the `make` command. This configures the simulation environment to use the Cadence Xcelium simulator.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=xcelium\n```\n\n----------------------------------------\n\nTITLE: Accessing Verilog Package Parameters in cocotb (Python)\nDESCRIPTION: Shows how to access parameters defined within a Verilog package (like the `foo` parameter in `my_package` from the previous example) from a cocotb Python testbench. It uses `cocotb.packages` to navigate to the package and parameter, accessing its value via the `.value` attribute.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# prints \"7\"\ncocotb.log.info(cocotb.packages.my_package.foo.value)\n```\n\n----------------------------------------\n\nTITLE: Setting Simulator to Mentor/Siemens EDA ModelSim\nDESCRIPTION: This code snippet shows how to set the simulator to Mentor/Siemens EDA ModelSim using the `make` command. This allows cocotb to run simulations with ModelSim. ModelSim PE or ModelSim PE derivatives do not support VHDL FLI.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=modelsim\n```\n\n----------------------------------------\n\nTITLE: Example Output for a Passed cocotb Test\nDESCRIPTION: Shows the standard console output indicating that a cocotb test has completed successfully.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_17\n\nLANGUAGE: text\nCODE:\n```\n0.00ns INFO     Test Passed: test\n```\n\n----------------------------------------\n\nTITLE: Starting Concurrent Task and Waiting with First (Python)\nDESCRIPTION: This cocotb test coroutine starts a clock, waits for a rising edge, then concurrently schedules another coroutine (`count_edges_cycles`) as a task using `cocotb.start_soon`. It enters a loop awaiting the first completion of either a `Timer` or the scheduled task using the `First` trigger. The loop continues until the task finishes, using the timer check to ensure the task completes within an expected timeframe. Requires a DUT object, `count_edges_cycles` coroutine, `Timer`, `First`, and `start_soon`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test()\nasync def test_count_edge_cycles(dut, period_ns=1, clocks=6):\n    Clock(dut.clk, period_ns, unit='ns').start()\n    await RisingEdge(dut.clk)\n\n    timer = Timer(period_ns + 10, 'ns')\n    task = cocotb.start_soon(count_edges_cycles(dut.clk, clocks))\n    count = 0\n    expect = clocks - 1\n\n    while True:\n        result = await First(timer, task)\n        assert count <= expect, \"Task didn't complete in expected time\"\n        if result is timer:\n            cocotb.log.info(\"Count %d: Task still running\", count)\n            count += 1\n        else:\n            break\n```\n\n----------------------------------------\n\nTITLE: Setting Simulator to GHDL\nDESCRIPTION: This code snippet configures the simulator to use GHDL by setting the `SIM` variable to `ghdl` in the `make` command.  This is necessary for running cocotb simulations with the GHDL simulator.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=ghdl\n```\n\n----------------------------------------\n\nTITLE: Configuring cocotb Simulation with a Makefile\nDESCRIPTION: This Makefile sets up the build, simulation, and test environment for running the analog_model cocotb example. It includes rules for launching simulation (with appropriate tool invocation), variable definitions for source files and simulation options, and stub targets for cleaning up generated files. Inputs include Python sources, SystemVerilog files, and test names; outputs are build artifacts and test logs. Prerequisites include GNU make and a supported HDL simulator (such as Icarus Verilog or ModelSim).\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/analog_model.rst#_snippet_3\n\nLANGUAGE: make\nCODE:\n```\n.. literalinclude:: ../../examples/analog_model/Makefile\n   :language: make\n```\n\n----------------------------------------\n\nTITLE: Testing Simulator Inertial Write Behavior\nDESCRIPTION: Provides shell commands to navigate to the relevant cocotb test directory and execute a specific test using `make`. This test verifies if a particular simulator (`SIM`) correctly handles inertial writes for a given hardware description language (`TOPLEVEL_LANG`), which is important before enabling the COCOTB_TRUST_INERTIAL_WRITES optimization.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/building.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd tests/test_cases/test_inertial_writes\nmake simulator_test SIM=<your simulator here> TOPLEVEL_LANG=<vhdl or verilog>\n```\n\n----------------------------------------\n\nTITLE: Getting cocotb Logger using logging.getLogger - Python\nDESCRIPTION: This snippet demonstrates the recommended way to obtain a logger for cocotb components using Python's standard `logging` module. It replaces the deprecated `cocotb.logging.SimLog` class. The logger name is formatted using an f-string incorporating a `name` and a hexadecimal `ident`. Requires the standard `logging` module.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/4423.removal.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nlogging.getLogger(f\"{name}.0x{ident:x}\")\n```\n\n----------------------------------------\n\nTITLE: Generating FST Waveform Output with NVC Simulator via Makefile (Makefile)\nDESCRIPTION: Configures waveform dump location and format for NVC simulator by adding '--wave=anyname.fst' to SIM_ARGS in a Makefile. Optionally, the waveform format can be changed to VCD by adding '--format=vcd'. These options control the simulator's native waveform generation functionality useful for post-simulation waveform analysis.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_19\n\nLANGUAGE: Makefile\nCODE:\n```\nSIM_ARGS += --wave=anyname.fst\n```\n\n----------------------------------------\n\nTITLE: Example Output Showing Random Seed Initialization\nDESCRIPTION: Demonstrates the INFO log message displayed by cocotb at the start of a test, indicating the Python random seed used for that execution. This seed can be captured and reused via the COCOTB_RANDOM_SEED environment variable for reproducible test runs.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/building.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nINFO     cocotb.gpi                                  __init__.py:89   in _initialise_testbench           Seeding Python random module with 1377424946\n```\n\n----------------------------------------\n\nTITLE: Event Synchronization with Event, set, wait, clear - Cocotb Python\nDESCRIPTION: Set up event-based synchronization by creating a cocotb Event, waking waiters, awaiting until set, and clearing the event for reuse. Requires cocotb.triggers imported. Used for inter-coroutine signaling. Inputs are event objects; outputs are wait and notification behavior.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\ne = cocotb.triggers.Event()\n```\n\nLANGUAGE: Python\nCODE:\n```\ne.set()\n```\n\nLANGUAGE: Python\nCODE:\n```\nawait e.wait()\n```\n\nLANGUAGE: Python\nCODE:\n```\ne.clear()\n```\n\n----------------------------------------\n\nTITLE: Enabling VCD Waveform Generation with GHDL Simulator Using Makefile (Makefile)\nDESCRIPTION: Shows how to enable VCD waveform output by setting the SIM_ARGS makefile variable in a Makefile for the GHDL simulator. The SIM_ARGS variable is appended with '--vcd=anyname.vcd', where 'anyname.vcd' is the desired output filename. This instructs GHDL to produce a VCD waveform file in the current directory after simulation. This snippet depends on GHDL simulator being invoked via make with SIM=ghdl. It must be invoked from a shell supporting make.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_15\n\nLANGUAGE: Makefile\nCODE:\n```\nSIM_ARGS+=--vcd=anyname.vcd\n```\n\n----------------------------------------\n\nTITLE: Installing Prerequisites - Debian/Ubuntu Linux\nDESCRIPTION: Command to install the required development tools and libraries for cocotb on Debian/Ubuntu Linux distributions using apt-get package manager.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install_devel.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install make gcc g++ python3 python3-dev python3-pip\n```\n\n----------------------------------------\n\nTITLE: Task Cancellation and Completion Wait - Cocotb Python\nDESCRIPTION: Cancel a running cocotb task and await its completion before proceeding to ensure coordinated shutdown. Assumes a valid task handle. Useful for cleanup or early completion logic.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\ntask_0.cancel()\n```\n\nLANGUAGE: Python\nCODE:\n```\nawait task_0.complete\n```\n\n----------------------------------------\n\nTITLE: Packaging Extensions: Minimal setup.py\nDESCRIPTION: This code snippet defines a minimal `setup.py` file for packaging a cocotb extension. It uses `setuptools` to define the extension's metadata, including its name, version, dependencies (cocotb), and Python version requirements. This `setup.py` file is essential for building and distributing the extension as a Python package, allowing it to be installed using pip.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/extensions.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom setuptools import setup, find_namespace_packages\n\nsetup(name = 'cocotbext-EXTNAME',\n      version = '0.1',\n      packages = find_namespace_packages(include=['cocotbext.*']),\n      install_requires = ['cocotb'],\n      python_requires = '>=3.6.2',\n      classifiers = [\n        \"Programming Language :: Python :: 3\",\n        \"Operating System :: OS Independent\",\n        \"Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)\",\n        \"Framework :: cocotb\"])\n```\n\n----------------------------------------\n\nTITLE: Setting Simulator to Icarus Verilog\nDESCRIPTION: This code snippet shows how to set the simulator to Icarus Verilog using the `make` command. This configuration is necessary for running cocotb simulations with Icarus Verilog.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=icarus\n```\n\n----------------------------------------\n\nTITLE: Applying Timeout to Coroutine Execution - Cocotb Python\nDESCRIPTION: Limit execution of a coroutine with a timeout, raising an error if not complete within the specified period. Depends on cocotb.triggers.with_timeout and a running simulation timebase. Inputs are coroutines and time specs; output is normal coroutine completion or timeout exception.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\nawait cocotb.triggers.with_timeout(coro, 1, \"us\")\n```\n\n----------------------------------------\n\nTITLE: Importing Cocotb Extension Modules\nDESCRIPTION: This Python snippet demonstrates various methods for importing parts of an extension into a testbench to use the functionality.  It shows importing the entire extension, importing a module, and importing a specific verification class.  This demonstrates the usage and access to the extensions' functionality once installed.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/extensions.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Examples for importing (parts of) the extension\nimport cocotbext.EXTNAME\nfrom cocotbext import EXTNAME\nfrom cocotbext.EXTNAME import MyVerificationClass\n```\n\n----------------------------------------\n\nTITLE: Forcing and Freezing Signal Values - Cocotb Python\nDESCRIPTION: Drive a signal with force or freeze semantics using cocotb.handle.Force, cocotb.handle.Freeze, or release these constraints. Requires cocotb and the target signal to be initialized. Input is the force/freeze/release command; output is simulation signal override.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\ndut.mysignal.value = cocotb.handle.Force(0xFF00)\n```\n\nLANGUAGE: Python\nCODE:\n```\ndut.mysignal.value = cocotb.handle.Freeze()\n```\n\nLANGUAGE: Python\nCODE:\n```\ndut.mysignal.value = cocotb.handle.Release()\n```\n\n----------------------------------------\n\nTITLE: Simulating Memory and Callback Leak Prevention using Python (Python)\nDESCRIPTION: This Python snippet illustrates best practices for managing callbacks in Cocotb by explicitly removing or dereferencing callbacks to avoid memory leaks during simulation runs. It depends on the Cocotb framework and Python's garbage collection.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/4392.bugfix.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef cleanup_callbacks(callback_list):\n    for callback in callback_list:\n        callback.cancel()  # Ensure callbacks are deregistered or canceled\n    callback_list.clear()  # Remove references to callbacks for garbage collection\n```\n\n----------------------------------------\n\nTITLE: Run simulator-agnostic tests\nDESCRIPTION: This command runs all simulator-agnostic tests using nox.  These tests do not depend on a specific simulator and are a good starting point for verifying the core functionality of cocotb.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnox -s dev_test_nosim\n```\n\n----------------------------------------\n\nTITLE: Combining Tasks with Individual Timeouts (Python)\nDESCRIPTION: This cocotb test coroutine demonstrates using the `Combine` trigger to wait for two concurrent tasks (`drive_transactions` and `quiesce`), each wrapped individually with `with_timeout`. This structure ensures that the test waits for both tasks to complete, but if either task exceeds its specific timeout (1 us for driving, 10 us for quiescing), the `Combine` trigger will fail, preventing the test from hanging indefinitely on a single problematic task. Requires `drive_transactions`, `quiesce` coroutines, `Combine`, `start_soon`, and `with_timeout`.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/coroutines.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n@cocotb.test\nasync def test_wait_for_both_with_timeout(dut):\n\n    # wait for both the driving and quiescing to complete before continuing\n    # but timeout if *either* the driving or settling take too long\n    await Combine(\n        cocotb.start_soon(with_timeout(drive_transactions(), 1, \"us\")),\n        cocotb.start_soon(with_timeout(quiesce(), 10, \"us\")),\n    )\n```\n\n----------------------------------------\n\nTITLE: Overriding default cocotb logging behavior (Python)\nDESCRIPTION: This code snippet shows how to override the default cocotb logging configuration. It removes the existing cocotb log handlers and formatting from the root logger and adds a basic configuration.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/release_notes.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# remove the cocotb log handler and formatting\nroot = logging.getLogger()\nfor h in root.handlers[:]:\n    root.remove_handler(h)\n    h.close()\n\n# add your own\nlogging.basicConfig()\n```\n\n----------------------------------------\n\nTITLE: Running Tests with nox\nDESCRIPTION: This command executes the \"dev_test\" nox session, which runs a suite of tests. These tests check the cocotb functionality across different simulators and languages. The tests are managed by nox which also uses pytest and makefiles.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnox -s dev_test\n```\n\n----------------------------------------\n\nTITLE: Installing cocotb Development Version Using pip\nDESCRIPTION: Demonstrates how to install a specific cocotb version or any later compatible version by specifying the version with the pip install command. This snippet is conditionally shown to users building from a release and requires a Python environment with pip configured correctly.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install \"cocotb~=|version|\"\n```\n\n----------------------------------------\n\nTITLE: SystemVerilog RC Circuit Design\nDESCRIPTION: The design consists of a resistor and capacitor model (both written in Verilog-AMS) connected in series in a SystemVerilog module. This is the design-under-test (DUT) for the testbench.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/rescap.rst#_snippet_0\n\nLANGUAGE: systemverilog\nCODE:\n```\n// the design-under-test\n```\n\n----------------------------------------\n\nTITLE: Running Pytest with Cocotb Runner (Bash)\nDESCRIPTION: Provides the bash command to execute a pytest test file that utilizes the cocotb Python runner. It demonstrates setting the required `SIM` and `HDL_TOPLEVEL_LANG` environment variables before invoking the `pytest` command on the specified test file (`examples/simple_dff/test_dff.py`).\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/runner.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nSIM=questa HDL_TOPLEVEL_LANG=vhdl pytest examples/simple_dff/test_dff.py\n```\n\n----------------------------------------\n\nTITLE: Running Pytest with Detailed Output (Bash)\nDESCRIPTION: Shows the bash command to run the pytest test file with the additional `-s` flag. This flag disables pytest's output capturing, allowing the user to see the detailed simulation output generated by cocotb directly in the terminal during the test execution. Environment variables are set as in the standard pytest run.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/runner.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nSIM=questa HDL_TOPLEVEL_LANG=vhdl pytest examples/simple_dff/test_dff.py -s\n```\n\n----------------------------------------\n\nTITLE: Running Cocotb Test File Directly (Bash)\nDESCRIPTION: Illustrates the bash command to execute the Python test file (`examples/simple_dff/test_dff.py`) directly as a standard Python script, bypassing the pytest framework. This requires the test file to contain the necessary `if __name__ == \"__main__\":` block to initiate the test run when executed this way.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/runner.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython examples/simple_dff/test_dff.py\n```\n\n----------------------------------------\n\nTITLE: Using remote_pdb to Debug Python Code in cocotb\nDESCRIPTION: This Python snippet illustrates how to use the 'remote_pdb' package to facilitate debugging Python code within a cocotb simulation, which normally prevents direct debugging due to simulator interference with standard input. The first code block imports and initializes a remote pdb instance listening on localhost and port 4000. The second code block shows inserting a breakpoint that stops execution and allows a remote debugger to connect via TCP (e.g., via telnet). This approach enables remote introspection and step-by-step debugging.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/troubleshooting.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom remote_pdb import RemotePdb; rpdb = RemotePdb(\"127.0.0.1\", 4000)\n```\n\nLANGUAGE: python\nCODE:\n```\nrpdb.set_trace()  # <-- debugger stops execution after this line\n<your code line>  # <-- next statement being evaluated by the interpreter\n```\n\n----------------------------------------\n\nTITLE: Invoking NVC Simulator via Makefile (Bash)\nDESCRIPTION: Basic usage example to run the NVC simulator with cocotb by setting the SIM makefile variable to 'nvc'. Requires NVC version 1.11.0 or later. Assumes a Makefile is present that respects the SIM variable to invoke the correct simulator driver.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_17\n\nLANGUAGE: Bash\nCODE:\n```\nmake SIM=nvc\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Verilog Package\nDESCRIPTION: Provides an example of a basic Verilog package named `my_package`. This package defines an integer parameter `foo` with a value of 7. Such packages can be accessed from cocotb tests.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_10\n\nLANGUAGE: verilog\nCODE:\n```\npackage my_package;\n    parameter int foo = 7\nendpackage\n```\n\n----------------------------------------\n\nTITLE: Installing Prerequisites on Red Hat-based Linux Using yum\nDESCRIPTION: Sets up the build environment for cocotb on Red Hat-based Linux systems by installing GNU Make, Python3 interpreter, pip, and Python3 libraries using the yum package manager. Root or equivalent permissions are required to execute this command successfully.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo yum install make python3 python3-pip python3-libs\n```\n\n----------------------------------------\n\nTITLE: SystemVerilog Testbench with Analog Probe\nDESCRIPTION: SystemVerilog testbench that instantiates the RC circuit design and includes an analog probe module for measuring voltage and current at specific nodes. The probe module acts like a multimeter that can be connected to different nodes in the design.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/rescap.rst#_snippet_1\n\nLANGUAGE: systemverilog\nCODE:\n```\nimport nettypes_pkg\n```\n\n----------------------------------------\n\nTITLE: TestFactory Setup for Parametric Test Generation - Cocotb Python\nDESCRIPTION: Enable regression testing with parametric variations using TestFactory: set up the factory, add test options, and generate tests automatically. Requires cocotb.regression imported and a test coroutine. Inputs are the test function and option names/values; output is dynamically generated test instances.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\ntf = cocotb.regression.TestFactory(coro)\n```\n\nLANGUAGE: Python\nCODE:\n```\ntf.add_option(\"arg\", [\"val0\", \"val1\"])\n```\n\nLANGUAGE: Python\nCODE:\n```\ntf.generate_tests()\n```\n\n----------------------------------------\n\nTITLE: Cocotb Parameterize Decorator Example 1\nDESCRIPTION: This example demonstrates how to use `@cocotb.parametrize` to define parameters `arg1` and `arg2` with specified lists of values. The test function will be executed for each combination of values from the respective lists. No external dependencies beyond cocotb are needed.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/refcard.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n``@cocotb.parametrize(arg1=[1, 2], arg2=[\"yes\", \"no\"])``\n```\n\n----------------------------------------\n\nTITLE: Example Output for an Errored cocotb Test\nDESCRIPTION: Shows the typical console output when a cocotb test ends in an 'error' state due to an unhandled exception (e.g., `NameError`). The output includes an error message, the test name, the exception type, and a traceback indicating the source of the error.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\n0.00ns ERROR    Test Failed: test (result was NameError)\n                Traceback (most recent call last):\n                  File \"test.py\", line 3, in test\n                    await coro_that_does_not_exist()  # NameError\n                NameError: name 'coro_that_does_not_exist' is not defined\n```\n\n----------------------------------------\n\nTITLE: SystemVerilog Analog Probe Implementation\nDESCRIPTION: An implementation of the analog probe module for capturing voltage and current from a specified node. This module uses a string parameter to identify the hierarchical path of the node and provides toggle signals to trigger measurements.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/rescap.rst#_snippet_2\n\nLANGUAGE: systemverilog\nCODE:\n```\nvar string node_to_probe\nvar event probe_voltage_toggle\nvar real voltage\nvar event probe_current_toggle\nvar real current\n\nalways @(probe_voltage_toggle) begin : probe_voltage\n  voltage = $cangetvalue(node_to_probe, \"v\");\nend  // probe_voltage\n```\n\n----------------------------------------\n\nTITLE: Connecting to remote_pdb Debugger Using Telnet (Shell)\nDESCRIPTION: This shell snippet shows how to connect to the remote_pdb debugger via telnet on IP 127.0.0.1 and port 4000. After the cocotb simulator hits the breakpoint set with remote_pdb, this command lets a developer remotely inspect and control the Python debugger session.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/troubleshooting.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ntelnet 127.0.0.1 4000\n```\n\n----------------------------------------\n\nTITLE: Testbench Top-Level Module in SystemVerilog\nDESCRIPTION: This SystemVerilog snippet imports the nettypes_pkg package, which is essential for defining and using user-defined nettypes within the testbench. This package is likely used for modeling analog signals and connecting the analog and digital parts of the simulation.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/regulator.rst#_snippet_2\n\nLANGUAGE: systemverilog\nCODE:\n```\nimport nettypes_pkg\n```\n\n----------------------------------------\n\nTITLE: Using Deposit, Force, Release, and Freeze actions on simulator handles (Python)\nDESCRIPTION: This example illustrates how to use the `Deposit`, `Force`, `Release`, and `Freeze` classes from `cocotb.handle` to interact with simulator handles. It demonstrates different ways to deposit a value, force a value, release a force, and freeze the current value on a signal.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/release_notes.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom cocotb.handle import Deposit, Force, Release, Freeze\n\ndut.q <= 1            # A regular value deposit\ndut.q <= Deposit(1)   # The same, higher verbosity\ndut.q <= Force(1)     # Force value of q to 1\ndut.q <= Release()    # Release q from a Force\ndut.q <= Freeze()     # Freeze the current value of q\n```\n\n----------------------------------------\n\nTITLE: Installing Prerequisites with pip\nDESCRIPTION: This snippet installs the nox and pre-commit Python packages using pip. These tools are essential for building documentation, running regression tests, and ensuring code quality before committing changes to the cocotb repository.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install nox pre-commit\n```\n\n----------------------------------------\n\nTITLE: Implementing Fair Lock Acquisition in cocotb\nDESCRIPTION: This code snippet illustrates the implementation of a Lock class in cocotb that ensures fairness in lock acquisition. It manages a queue of waiters and enforces FIFO order to prevent starvation of threads or coroutines. Dependencies include cocotb's coroutine mechanisms and synchronization primitives.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/4473.feature.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass Lock:\n    def __init__(self):\n        self._queue = []\n        self._locked = False\n    async def acquire(self):\n        waiter = cocotb.coroutine.CoRoutine()\n        self._queue.append(waiter)\n        while self._queue[0] is not waiter or self._locked:\n            await waiter\n        self._locked = True\n        self._queue.pop(0)\n    def release(self):\n        self._locked = False\n        if self._queue:\n            self._queue[0].send(None)\n```\n\n----------------------------------------\n\nTITLE: Configuring Rotating File Logs with Python Logging and Cocotb Formatter\nDESCRIPTION: This snippet shows how to replace existing Cocotb logging handlers with a RotatingFileHandler that limits log files to 5 MiB each and retains up to 3 files (1 active and 2 backups). It uses the SimLogFormatter specific to Cocotb for formatting the log messages. Dependencies include the Python logging.handlers module and the cocotb.logging SimLogFormatter class. The example first removes any handlers that Cocotb has already installed to avoid duplicate or conflicting logs, then adds the rotating file handler. Expected inputs are the default log stream, and output is rotated log files named \"rotating.log\" with controlled size and rotation behavior. This approach helps manage disk space and maintain recent logs for debugging.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/rotating_logger.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom logging.handlers import RotatingFileHandler\nfrom cocotb.logging import SimLogFormatter\n\nroot_logger = logging.getLogger()\n\n# undo the setup cocotb did\nfor handler in root_logger.handlers:\n    root_logger.removeHandler(handler)\n    handler.close()\n\n# do whatever configuration you want instead\nfile_handler = RotatingFileHandler(\"rotating.log\", maxBytes=(5 * 1024 * 1024), backupCount=2)\nfile_handler.setFormatter(SimLogFormatter())\nroot_logger.addHandler(file_handler)\n```\n\n----------------------------------------\n\nTITLE: Installing cocotb via Guix Package Manager\nDESCRIPTION: Guide to install cocotb using the Guix package manager after setting up the Guix-science channel repository. This command focuses on a functional package management approach popular in some Linux distributions and requires Guix installed and configured.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nguix install python-cocotb\n```\n\n----------------------------------------\n\nTITLE: Enabling HDL Code Coverage with Verilator\nDESCRIPTION: This snippet shows how to enable HDL code coverage in Verilator by appending the coverage option to the `EXTRA_ARGS` make variable. This allows for collecting coverage data during simulation.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_3\n\nLANGUAGE: make\nCODE:\n```\nEXTRA_ARGS += --coverage\n```\n\n----------------------------------------\n\nTITLE: Installing Cocotb Extensions from PyPi\nDESCRIPTION: This command demonstrates how to install a cocotb extension after it has been uploaded to PyPi. This utilizes `pip install` followed by the extension's name, cocotbext-EXTNAME in this example.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/extensions.rst#_snippet_2\n\nLANGUAGE: command\nCODE:\n```\n$ python3 -m pip install cocotbext-EXTNAME\n```\n\n----------------------------------------\n\nTITLE: Implementing Programmable Gain Amplifier and ADC with cocotb Queues in Python\nDESCRIPTION: This code snippet (afe.py) implements an Analog Front-End (AFE) in Python using cocotb for mixed-signal simulation. It features a Programmable Gain Amplifier with selectable gain values (5.0 or 10.0) and a 13-bit Analog-to-Digital Converter (ADC) with a 2.0V reference. It passes converted measurement data to the digital domain using cocotb.queue.Queue. Requires cocotb as a dependency, expected inputs are voltage levels and gain selection flags, outputting digital values that are consumed by the digital controller. Limitations include being a functional simulation model, not a hardware-accurate SPICE simulation.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/analog_model.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/analog_model/afe.py\n   :language: python\n```\n\n----------------------------------------\n\nTITLE: Installing git hooks with pre-commit\nDESCRIPTION: This command installs pre-commit hooks at the root of the cloned project. Pre-commit runs checks on your changes before committing, such as formatting and style checks.  The initial run may take longer as it builds an environment.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Setting Simulator to Synopsys VCS\nDESCRIPTION: This code snippet shows how to set the simulator to Synopsys VCS using the `make` command. This is necessary for using cocotb with the Synopsys VCS simulator. Only VPI is supported.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=vcs\n```\n\n----------------------------------------\n\nTITLE: Listing nox sessions\nDESCRIPTION: This command lists all available nox sessions.  This is useful to discover the available configurations for running tests against different simulators, languages, and GPI interfaces.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnox -l\n```\n\n----------------------------------------\n\nTITLE: Setting Simulator to Aldec Riviera-PRO\nDESCRIPTION: This code snippet demonstrates how to configure the simulator to use Aldec Riviera-PRO by setting the `SIM` variable to `riviera` in the `make` command.  This allows cocotb simulations to be executed using Riviera-PRO.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=riviera\n```\n\n----------------------------------------\n\nTITLE: Accessing Cocotb Sub-handles (Recommended)\nDESCRIPTION: Illustrates the recommended Python syntax for accessing sub-handles within a Cocotb hierarchy object using dictionary-style indexing. This method replaces the deprecated `_id()` function.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/3655.removal.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nhandle[\"sub_handle_name\"]\n```\n\n----------------------------------------\n\nTITLE: Build Documentation Locally\nDESCRIPTION: This command builds the cocotb documentation locally using nox.  The documentation will be generated in the same location on your hard drive for each run, allowing you to simply refresh the page in your browser to view the changes. \nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnox -e docs\n```\n\n----------------------------------------\n\nTITLE: Setting Simulator to Aldec Active-HDL\nDESCRIPTION: This code snippet demonstrates how to configure the simulator to use Aldec Active-HDL by setting the `SIM` variable to `activehdl` in the `make` command.  This allows cocotb simulations to be executed using Active-HDL. Note that some versions of Active-HDL are not supported.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=activehdl\n```\n\n----------------------------------------\n\nTITLE: Running Minimalist RC Circuit Test with cocotb\nDESCRIPTION: Command to run a minimalist testcase for the RC circuit using cocotb with the Xcelium simulator. This test supplies a voltage, measures voltage and current, and prints the measured values at defined intervals.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/rescap.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=xcelium COCOTB_TOPLEVEL=tb_rescap COCOTB_TEST_MODULES=test_rescap_minimalist\n```\n\n----------------------------------------\n\nTITLE: Setting Simulator to Mentor/Siemens EDA Questa\nDESCRIPTION: This code snippet shows how to set the simulator to Mentor/Siemens EDA Questa using the `make` command. This allows cocotb to run simulations with Questa. Starting with Questa 2022.3 and cocotb 1.7, users with VHDL toplevels can choose between FLI and VHPI.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=questa\n```\n\n----------------------------------------\n\nTITLE: Monitoring AFE Output and Switching PGA Gain in SystemVerilog\nDESCRIPTION: This SystemVerilog snippet (digital.sv) acts as the digital controller, monitoring the output of the ADC and dynamically selecting the PGA gain based on measured values. It implements logic to switch the gain if the measurement value is below 30% or above 70% of the ADC's full scale. This module interacts with the Python-modeled analog subsystem via cocotb co-simulation interfaces. Key parameters include the measurement digital value input, gain control output, and ADC range constants. Constraints involve requiring a compatible co-sim environment and proper value mapping.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/analog_model.rst#_snippet_1\n\nLANGUAGE: systemverilog\nCODE:\n```\n.. literalinclude:: ../../examples/analog_model/digital.sv\n   :language: systemverilog\n```\n\n----------------------------------------\n\nTITLE: Running Advanced RC Circuit Test with cocotb\nDESCRIPTION: Command to run a more advanced testcase for the RC circuit using cocotb with the Xcelium simulator. This test requires matplotlib and provides functions for sampling and plotting voltage and current data.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/rescap.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=xcelium COCOTB_TOPLEVEL=tb_rescap COCOTB_TEST_MODULES=test_rescap\n```\n\n----------------------------------------\n\nTITLE: Attaching GDB Debugger to Running cocotb Simulation (Shell)\nDESCRIPTION: This snippet demonstrates using environment variables to run a cocotb test with the debugger attachment enabled by setting COCOTB_ATTACH to a timeout in seconds and then attaching GDB to the running simulator process using the PID displayed. It includes an example make command to start the simulation and GDB commands to attach, debug, continue the process, and exit. This allows debugging of cocotb C code and simulator interactions via GDB.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/troubleshooting.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ make -C tests/test_cases/test_array_simple SIM=questa TOPLEVEL_LANG=vhdl VHDL_GPI_INTERFACE=vhpi COCOTB_ATTACH=300 COCOTB_LOG_LEVEL=trace\n...\n#      -.--ns ERROR    gpi                                ..mbed/gpi_embed.cpp:154  in _embed_init_python              Waiting for 300 seconds - attach to PID 9583 with your debugger\n```\n\nLANGUAGE: shell\nCODE:\n```\n$ gdb -p 9583\n...\n48        r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, clock_id, flags, req,\n(gdb) # Set breakpoints or do anything else you'd like to do. Finally, let the simulation run:\n(gdb) continue\nContinuing.\n[Inferior 1 (process 9583) exited normally]\n(gdb) quit\n```\n\n----------------------------------------\n\nTITLE: Sample Analog Measurement Output\nDESCRIPTION: Example output from the minimalist test showing voltage and current measurements at the vout terminal (same as the p terminal of the capacitor) at 50ns intervals. Note that current is effectively zero as expected.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/rescap.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    50.00ns INFO     tb_hdl.i_analog_probe@tb_rescap.i_rescap.vout=2.03e-14 V  -2.996e-07 A\n   100.00ns INFO     tb_hdl.i_analog_probe@tb_rescap.i_rescap.vout=3.029 V  2.67e-18 A\n   150.00ns INFO     tb_hdl.i_analog_probe@tb_rescap.i_rescap.vout=4.862 V  3.574e-18 A\n   200.00ns INFO     tb_hdl.i_analog_probe@tb_rescap.i_rescap.vout=5.975 V  6.285e-18 A\n   250.00ns INFO     tb_hdl.i_analog_probe@tb_rescap.i_rescap.vout=6.652 V  6.171e-18 A\n   300.01ns INFO     tb_hdl.i_analog_probe@tb_rescap.i_rescap.vout=7.063 V  6.033e-18 A\n```\n\n----------------------------------------\n\nTITLE: Checking and Modifying LD_LIBRARY_PATH Environment Variable (Shell)\nDESCRIPTION: These shell commands help troubleshoot 'GLIBCXX_3.4.XX' version not found errors by inspecting and modifying the LD_LIBRARY_PATH environment variable. The echo command prints the current LD_LIBRARY_PATH to verify the active library paths. If an older libstdc++ is loaded first, the export command prepends a directory containing a newer compatible library to prioritize it during loading.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/troubleshooting.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\necho $LD_LIBRARY_PATH\n```\n\nLANGUAGE: shell\nCODE:\n```\nexport LD_LIBRARY_PATH=/path/to/newer/libraries/:$LD_LIBRARY_PATH\n```\n\n----------------------------------------\n\nTITLE: Enabling Direct Python Execution of Test (Python)\nDESCRIPTION: Provides a Python code snippet that should be added to the test file. This standard Python construct (`if __name__ == \"__main__\":`) ensures that the main test function (`test_simple_dff_runner()`) is called only when the script is executed directly, making the file runnable without requiring pytest.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/runner.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nif __name__ == \"__main__\":\n    test_simple_dff_runner()\n```\n\n----------------------------------------\n\nTITLE: Running test_regulator_trim with make\nDESCRIPTION: This bash command shows how to run the test_regulator_trim testcase using the make utility.  It sets the simulator to xcelium and specifies the top-level module and test modules.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/regulator.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=xcelium COCOTB_TOPLEVEL=tb_regulator COCOTB_TEST_MODULES=test_regulator_trim\n```\n\n----------------------------------------\n\nTITLE: Running test_regulator_plot with make\nDESCRIPTION: This bash command shows how to run the test_regulator_plot testcase using the make utility. It sets the simulator to xcelium and specifies the top-level module and test modules.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/regulator.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=xcelium COCOTB_TOPLEVEL=tb_regulator COCOTB_TEST_MODULES=test_regulator_plot\n```\n\n----------------------------------------\n\nTITLE: Building cocotb in Development Mode Using Shell Commands\nDESCRIPTION: This shell snippet shows the steps to clone the cocotb repository from GitHub, build it in debug mode, and start a development shell environment. It enables recompilation with debug symbols to facilitate debugging of cocotb internals. The commands assume a Linux environment, the presence of build dependencies, and the use of 'nox' for orchestrating the build and shell.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/troubleshooting.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ # Obtain the latest development version of cocotb through git\n$ git clone https://github.com/cocotb/cocotb.git\n$ # Build cocotb in debug mode, and enter a bash shell\n$ cd cocotb\n$ nox -s dev -- /bin/bash\n```\n\n----------------------------------------\n\nTITLE: Python Documentation Header for New Files\nDESCRIPTION: Standard copyright and license header to include at the top of new non-example Python files in the Cocotb project. This establishes the Revised BSD License terms for the code.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/contributing.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Copyright cocotb contributors\n# Licensed under the Revised BSD License, see LICENSE for details.\n# SPDX-License-Identifier: BSD-3-Clause\n```\n\n----------------------------------------\n\nTITLE: Enabling Code Coverage in NVC Simulator via Makefile (Makefile)\nDESCRIPTION: Shows how to enable code coverage data collection by appending '--cover' to the SIM_ARGS makefile variable for NVC simulator runs. This generates coverage database files (*.covdb) under the RTL_LIBRARY subdirectory within SIM_BUILD. Specifying coverage types is possible by providing a comma separated list, such as 'statement,branch'. This snippet is useful for tracking functional coverage during simulation cycles.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_18\n\nLANGUAGE: Makefile\nCODE:\n```\nSIM_ARGS += --cover\n```\n\nLANGUAGE: Makefile\nCODE:\n```\nSIM_ARGS += --cover=statement,branch\n```\n\n----------------------------------------\n\nTITLE: Replacing cocotb.argc with len(cocotb.argv) in Python\nDESCRIPTION: Shows the replacement of the deprecated cocotb.argc attribute with the recommended len(cocotb.argv) method for counting command line arguments.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/3779.removal.2.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Before (deprecated)\n# arg_count = cocotb.argc\n\n# After (recommended)\narg_count = len(cocotb.argv)\n```\n\n----------------------------------------\n\nTITLE: Installing cocotb-bus with pip (Recommended)\nDESCRIPTION: This command line snippet shows the current recommended method for installing the `cocotb-bus` package. It should be installed as a separate package directly using pip.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/3436.change.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\npip install cocotb-bus\n```\n\n----------------------------------------\n\nTITLE: Installing cocotb[bus] with pip (Deprecated)\nDESCRIPTION: This command line snippet shows a previously supported method for installing the `cocotb-bus` package alongside `cocotb` by using an extra dependency. This method is now deprecated and should not be used.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/3436.change.rst#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npip install cocotb[bus]\n```\n\n----------------------------------------\n\nTITLE: Simulating in GUI Mode with ModelSim/Questa\nDESCRIPTION: This makefile command enables the graphical interface for ModelSim or Questa and keeps the simulator active after the tests are done. This is useful for interactive debugging and waveform analysis. Requires deleting the `SIM_BUILD` directory if previously run without this setting.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nmake GUI=1\n```\n\n----------------------------------------\n\nTITLE: Installing Cocotb Development Version - Windows with Conda\nDESCRIPTION: Command to install the required build tools for cocotb on Windows using Conda package manager. This installs MSYS2 base system and GNU Make.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install_devel.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c msys2 m2-base m2-make\n```\n\n----------------------------------------\n\nTITLE: Example Verilog Delay Timing Statement\nDESCRIPTION: This Verilog snippet exemplifies an HDL timing statement using a delay (`#(10)`). Such statements control simulation time and require specific handling (e.g., the `--timing` flag) in Verilator version 5 and newer, especially when integrated with cocotb. The code shows an initial block that toggles the `clk` signal after 10 time units.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/tests/test_cases/test_3316/README.md#_snippet_0\n\nLANGUAGE: Verilog\nCODE:\n```\ninitial begin: proc_delay\n    #(10)\n        clk = ~clk;\nend\n```\n\n----------------------------------------\n\nTITLE: Installing Prerequisites - macOS\nDESCRIPTION: Command to install Python on macOS using Homebrew package manager, which is required for installing the cocotb development version.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install_devel.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbrew install python\n```\n\n----------------------------------------\n\nTITLE: Analog Probe Voltage Capture in SystemVerilog\nDESCRIPTION: This code snippet shows the SystemVerilog code used to capture voltage from a specified node. It defines the node to be probed using a string and captures the voltage when `probe_voltage_toggle` is asserted. The emphasized lines show the user interface to the probe.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/regulator.rst#_snippet_3\n\nLANGUAGE: systemverilog\nCODE:\n```\nvar string node_to_probe;\n\nalways @(posedge probe_voltage_toggle) begin\n  voltage = V(node_to_probe.s());\nend  // probe_voltage\n```\n\n----------------------------------------\n\nTITLE: Fixing Memory Leaks in GPI Callback Management (C)\nDESCRIPTION: This C code snippet demonstrates the correction of memory leaks arising from callback handling in GPI by ensuring proper allocation and deallocation of callback structures. It requires existing callback management infrastructure and is crucial for preventing memory bloat during simulations.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/4392.bugfix.rst#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n/* Corrected callback registration to prevent memory leaks */\nvoid register_callback(GPICallback *callback) {\n  GPICallback *new_callback = malloc(sizeof(GPICallback));\n  if (!new_callback) return; // Handle allocation failure\n  memcpy(new_callback, callback, sizeof(GPICallback));\n  // Add to callback list and manage deallocation appropriately\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Cocotb Development Version from GitHub\nDESCRIPTION: Command to install the development version of cocotb directly from the GitHub repository using pip. This installs the latest code from the master branch.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install_devel.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install git+https://github.com/cocotb/cocotb@master\n```\n\n----------------------------------------\n\nTITLE: Adding 'sources' option in cocotb Runner.build() method (Python)\nDESCRIPTION: This snippet illustrates the modification to the cocotb Runner class's build() method to include the 'sources' option. It enables users to specify additional source files required for building mixed-language HDL designs, improving flexibility and configuration management during the build process.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/3796.feature.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef build(self, sources=None, ...):\n    '''\n    Build the simulation environment, optionally including extra source files.\n\n    :param sources: list of additional source file paths for mixed-language support\n    '''\n    # existing build logic\n    if sources:\n        # integrate sources into build process\n        self.sources = sources\n    # continue with build steps\n```\n\n----------------------------------------\n\nTITLE: Example Output for a Failed cocotb Test\nDESCRIPTION: Shows the typical console output when a cocotb test fails due to an `AssertionError`. It includes an error message, the test name, the exception type, a traceback pointing to the failing assertion, and the assertion message.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/writing_testbenches.rst#_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n0.00ns ERROR    Test Failed: test (result was AssertionError)\n                Traceback (most recent call last):\n                  File \"test.py\", line 3, in test\n                    assert 1 > 2, \"Testing the obvious\"\n                AssertionError: Testing the obvious\n```\n\n----------------------------------------\n\nTITLE: Configuring Simulator Output Redirection in Makefile\nDESCRIPTION: This Makefile snippet demonstrates how to use the SIM_CMD_SUFFIX variable to redirect the simulator's standard output and standard error streams. The example redirects both streams to the terminal using '2>&1' and simultaneously pipes the output to the 'tee' command to save it to a 'sim.log' file.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/building.rst#_snippet_3\n\nLANGUAGE: Makefile\nCODE:\n```\n# Prints simulator stdout and stderr to the terminal\n# as well as capture it all in a log file \"sim.log\".\nSIM_CMD_SUFFIX := 2>&1 | tee sim.log\n```\n\n----------------------------------------\n\nTITLE: Regulator Module Definition in Verilog-AMS\nDESCRIPTION: This Verilog-AMS module defines a trimmable regulator model. It's the core design under test in the mixed-signal simulation. The module includes parameters for voltage and trim settings.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/regulator.rst#_snippet_0\n\nLANGUAGE: systemverilog\nCODE:\n```\nmodule regulator\n```\n\n----------------------------------------\n\nTITLE: Enabling FST Waveform Tracing in Icarus Verilog\nDESCRIPTION: This code snippet demonstrates how to enable FST waveform tracing in Icarus Verilog by setting the `WAVES` variable to `1` in the `make` command.  This generates smaller and more efficient waveform traces compared to VCD.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=icarus WAVES=1\n```\n\n----------------------------------------\n\nTITLE: Enabling VCD Waveform Tracing with Verilator\nDESCRIPTION: This snippet shows how to enable VCD waveform tracing in Verilator by appending the trace options to the `EXTRA_ARGS` make variable. This generates a VCD file containing waveform data.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_4\n\nLANGUAGE: make\nCODE:\n```\nEXTRA_ARGS += --trace --trace-structs\n```\n\n----------------------------------------\n\nTITLE: Setting Simulator to Verilator\nDESCRIPTION: This code snippet shows how to set the simulator to Verilator using the `make` command.  This configuration is required to use cocotb with Verilator. Verilator 5.026+ is required.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=verilator\n```\n\n----------------------------------------\n\nTITLE: Running make command for individual tests\nDESCRIPTION: This `make` command is used to execute a single test with Icarus Verilog and Verilog sources. The `SIM` and `TOPLEVEL_LANG` environment variables specify the simulator and toplevel language respectively.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nmake SIM=icarus TOPLEVEL_LANG=verilog\n```\n\n----------------------------------------\n\nTITLE: Installing Prerequisites Using Conda on Windows Bash\nDESCRIPTION: Installs compiler tools and GNU Make on Windows systems using the Conda package manager, targeted at users running Windows who prefer a Unix-like shell environment or maintain legacy Makefile-based projects. Dependencies include Conda and MSYS2 environment components. The snippet is a single command to be run from an Anaconda Prompt.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nconda install -c msys2 m2-base m2-make\n```\n\n----------------------------------------\n\nTITLE: Run simulator specific tests with multiple simulators\nDESCRIPTION: This command runs simulator-specific tests against Icarus Verilog and GHDL. It uses the -k option to select sessions matching the provided filters and ensures both simulators are installed.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnox -k \"dev_test_sim and (icarus or ghdl)\"\n```\n\n----------------------------------------\n\nTITLE: Install cocotb from Source\nDESCRIPTION: This command installs cocotb from the project source using pip.  This is necessary to run individual tests or make modifications to the source code. The command must be run from the project root directory.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install .\n```\n\n----------------------------------------\n\nTITLE: Install cocotb from Source on Windows\nDESCRIPTION: This command installs cocotb from the project source on Windows using pip.  The --global-option build_ext --global-option --compiler=mingw32 arguments are used to specify the compiler and build extension options.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npython -m pip install --global-option build_ext --global-option --compiler=mingw32 .\n```\n\n----------------------------------------\n\nTITLE: Run simulator specific tests\nDESCRIPTION: This command runs simulator-specific tests against Xcelium, using VHDL and VHPI. It selects a specific session based on the desired simulator, toplevel language, and GPI interface.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/developing.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnox -s \"dev_test_sim(sim='xcelium', toplevel_lang='vhdl', gpi_interface='vhpi')\"\n```\n\n----------------------------------------\n\nTITLE: Installing Cocotb Extensions using pip\nDESCRIPTION: This command demonstrates how to install a cocotb extension in development mode, where `-e` enables editable install. Then, it explains how to install a cocotb extension directly by name, after it has been uploaded to PyPi or a similar package repository, using pip.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/extensions.rst#_snippet_1\n\nLANGUAGE: command\nCODE:\n```\n$ python3 -m pip install -e .\n```\n\n----------------------------------------\n\nTITLE: Running Siemens DSim Simulator with VCD Waveform Output Enabled (Bash)\nDESCRIPTION: Shows how to run the DSim simulator with the WAVES environment variable set to '1' to enable VCD waveform trace generation. The command requires DSim version 2025 or later and a valid DSim installation. VCD waveform files produced can be viewed with GTKWave or Surfer. The SIM environment variable is set to 'dsim' to select the simulator.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_21\n\nLANGUAGE: Bash\nCODE:\n```\nmake SIM=dsim WAVES=1\n```\n\n----------------------------------------\n\nTITLE: Running CVC Simulator with Cocotb via Makefile (Bash)\nDESCRIPTION: Example command to run the Tachyon DA CVC simulator with cocotb by setting the SIM variable to 'cvc'. Specifies that cocotb uses CVC in interpreted mode. Requires CVC simulator installed and configured properly.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/simulator_support.rst#_snippet_20\n\nLANGUAGE: Bash\nCODE:\n```\nmake SIM=cvc\n```\n\n----------------------------------------\n\nTITLE: Installing Python on macOS Using Homebrew\nDESCRIPTION: Provides the command to install the Python interpreter on macOS systems using the Homebrew package manager, which is recommended for obtaining the required Python version for cocotb. This snippet assumes Homebrew is already installed on the system.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbrew install python\n```\n\n----------------------------------------\n\nTITLE: Installing Prerequisites - Red Hat Linux\nDESCRIPTION: Command to install the required development tools and libraries for cocotb on Red Hat based Linux distributions using yum package manager.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install_devel.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo yum install make gcc gcc-c++ libstdc++-devel libstdc++-static python3 python3-devel python3-pip\n```\n\n----------------------------------------\n\nTITLE: Adding CodeReady Builder Repository - RHEL9\nDESCRIPTION: Command to enable the CodeReady Linux Builder repository on RHEL9, which is needed to install the libstdc++-static package required by cocotb development version.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/install_devel.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo subscription-manager repos --enable codeready-builder-for-rhel-9-$(arch)-rpms\n```\n\n----------------------------------------\n\nTITLE: Memory Leak Fix in GPI Initialization Function (C)\nDESCRIPTION: This snippet shows an improved version of a GPI initialization function written in C, emphasizing proper allocation and cleanup of resources to prevent memory leaks during multiple initializations or error states.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/4392.bugfix.rst#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nvoid gpi_initialize() {\n  static int initialized = 0;\n  if (initialized) return;\n  gpi_cleanup(); // Free resources if previously allocated\n  // Initialization code...\n  initialized = 1;\n}\n\nvoid gpi_cleanup() {\n  // Free allocated resources to prevent leaks\n}\n```\n\n----------------------------------------\n\nTITLE: Regulator Block Definition in Verilog-AMS\nDESCRIPTION: This snippet shows the inclusion of disciplines.vams. It sets up the environment for mixed-signal simulations by incorporating necessary discipline definitions.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/regulator.rst#_snippet_1\n\nLANGUAGE: systemverilog\nCODE:\n```\n`include \"disciplines.vams\"\n```\n\n----------------------------------------\n\nTITLE: Specifying VHDL Sources for a Library in Make\nDESCRIPTION: Illustrates the make variable pattern used to assign VHDL source files to a specific library (denoted by `<lib>`) for compilation with Riviera-PRO within a Cocotb Makefile.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/3922.feature.rst#_snippet_0\n\nLANGUAGE: Make\nCODE:\n```\nVHDL_SOURCES_<lib>\n```\n\n----------------------------------------\n\nTITLE: Referencing Deprecated _id() Method (reStructuredText)\nDESCRIPTION: reStructuredText markup referencing the deprecated `_id()` method within the `cocotb.handle.HierarchyObject` class. This method should no longer be used.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/newsfragments/3655.removal.rst#_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n:meth:`HierarchyObject._id() <cocotb.handle.HierarchyObject._id>`\n```\n\n----------------------------------------\n\nTITLE: Creating a custom GNU Make domain in Sphinx\nDESCRIPTION: Example Python code demonstrating how to create a simple domain for GNU Make using the custom_domain function. It defines targets and variables as domain elements.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/_vendor/domaintools/README.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sphinxcontrib.domaintools import custom_domain\n\ndef setup(app):\n    app.add_domain(custom_domain('GnuMakeDomain',\n        name  = 'make',\n        label = \"GNU Make\", \n\n        elements = dict(\n            target = dict(\n                objname      = \"Make Target\",\n                indextemplate = \"pair: %s; Make Target\",\n            ),\n            var   = dict(\n                objname = \"Make Variable\",\n                indextemplate = \"pair: %s; Make Variable\"\n            ),\n        )))\n```\n\n----------------------------------------\n\nTITLE: Building Cocotb Documentation with nox\nDESCRIPTION: This snippet shows how to build the Cocotb documentation using the `nox` command-line tool. It creates a virtual environment and invokes `sphinx-build` to generate the HTML documentation.  Dependencies include `nox`, `sphinx-build`, and the Python dependencies managed by nox.  The generated HTML docs are usually output to a directory specified in the Sphinx configuration.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnox -e docs\n```\n\n----------------------------------------\n\nTITLE: Installing sphinxcontrib-domaintools with pip\nDESCRIPTION: Command to install the sphinxcontrib-domaintools package using pip package manager.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/_vendor/domaintools/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install sphinxcontrib-domaintools\n```\n\n----------------------------------------\n\nTITLE: Python Documentation Header for Example Files\nDESCRIPTION: Standard header to include at the top of new example files in the Cocotb project. This establishes that example code is in the public domain and can be freely copied.\nSOURCE: https://github.com/cocotb/cocotb/blob/master/docs/source/contributing.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n# This file is public domain, it can be freely copied without restrictions.\n# SPDX-License-Identifier: CC0-1.0\n```"
  }
]