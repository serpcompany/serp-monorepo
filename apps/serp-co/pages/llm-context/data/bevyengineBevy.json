[
  {
    "owner": "bevyengine",
    "repo": "bevy",
    "content": "TITLE: Complete Example of Bevy ECS Usage\nDESCRIPTION: A comprehensive example showing how to use Bevy ECS, including defining Components, creating a World, spawning Entities, defining Systems, and running a Schedule.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Component)]\nstruct Position { x: f32, y: f32 }\n#[derive(Component)]\nstruct Velocity { x: f32, y: f32 }\n\n// This system moves each entity with a Position and Velocity component\nfn movement(mut query: Query<(&mut Position, &Velocity)>) {\n    for (mut position, velocity) in &mut query {\n        position.x += velocity.x;\n        position.y += velocity.y;\n    }\n}\n\nfn main() {\n    // Create a new empty World to hold our Entities and Components\n    let mut world = World::new();\n\n    // Spawn an entity with Position and Velocity components\n    world.spawn((\n        Position { x: 0.0, y: 0.0 },\n        Velocity { x: 1.0, y: 0.0 },\n    ));\n\n    // Create a new Schedule, which defines an execution strategy for Systems\n    let mut schedule = Schedule::default();\n\n    // Add our system to the schedule\n    schedule.add_systems(movement);\n\n    // Run the schedule once. If your app has a \"loop\", you would run this once per loop\n    schedule.run(&mut world);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Bevy Application with Default Plugins\nDESCRIPTION: A minimal Bevy application setup that creates a window with standard functionality. This snippet demonstrates how to initialize a Bevy app with default plugins and run it.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy::prelude::*;\n\nfn main(){\n  App::new()\n    .add_plugins(DefaultPlugins)\n    .run();\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning Entities with Components in Bevy ECS\nDESCRIPTION: Illustrates how to create Entities and associate them with Components in a World.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Component)]\nstruct Position { x: f32, y: f32 }\n#[derive(Component)]\nstruct Velocity { x: f32, y: f32 }\n\nlet mut world = World::new();\n\nlet entity = world\n    .spawn((Position { x: 0.0, y: 0.0 }, Velocity { x: 1.0, y: 0.0 }))\n    .id();\n\nlet entity_ref = world.entity(entity);\nlet position = entity_ref.get::<Position>().unwrap();\nlet velocity = entity_ref.get::<Velocity>().unwrap();\n```\n\n----------------------------------------\n\nTITLE: Defining Components in Rust for Bevy ECS\nDESCRIPTION: Demonstrates how to define Components as normal Rust structs using the #[derive(Component)] attribute.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Component)]\nstruct Position { x: f32, y: f32 }\n```\n\n----------------------------------------\n\nTITLE: Events in Bevy ECS\nDESCRIPTION: Illustrates how to define, send, and receive Events for communication between systems.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Event)]\nstruct MyEvent {\n    message: String,\n}\n\nfn writer(mut writer: EventWriter<MyEvent>) {\n    writer.send(MyEvent {\n        message: \"hello!\".to_string(),\n    });\n}\n\nfn reader(mut reader: EventReader<MyEvent>) {\n    for event in reader.read() {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Systems in Bevy ECS\nDESCRIPTION: Shows how to create a System as a Rust function that operates on Components.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Component)]\nstruct Position { x: f32, y: f32 }\n\nfn print_position(query: Query<(Entity, &Position)>) {\n    for (entity, position) in &query {\n        println!(\"Entity {} is at position: x {}, y {}\", entity, position.x, position.y);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Change Detection in Bevy ECS\nDESCRIPTION: Shows how to use Change Detection to query for components that have changed or been added since the last system run.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Component)]\nstruct Position { x: f32, y: f32 }\n#[derive(Component)]\nstruct Velocity { x: f32, y: f32 }\n\n// Gets the Position component of all Entities whose Velocity has changed since the last run of the System\nfn system_changed(query: Query<&Position, Changed<Velocity>>) {\n    for position in &query {\n    }\n}\n\n// Gets the Position component of all Entities that had a Velocity component added since the last run of the System\nfn system_added(query: Query<&Position, Added<Velocity>>) {\n    for position in &query {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bevy Picking Plugin in Rust\nDESCRIPTION: This code snippet defines the PickingPlugin struct and implements the Plugin trait for it. The plugin adds systems for handling mouse input, raycasting, and managing pick sources and targets in a Bevy application.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_picking/README.md#2025-04-22_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nuse bevy::prelude::*;\n\npub struct PickingPlugin;\n\nimpl Plugin for PickingPlugin {\n    fn build(&self, app: &mut App) {\n        app.add_systems(\n            Update,\n            (\n                update_pick_source_transform,\n                update_pick_target_transform,\n                perform_picking,\n            ),\n        );\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Correctly Spawning Entities with Hierarchy Components in Bevy\nDESCRIPTION: This code snippet shows the correct way to spawn entities with hierarchy-inherited components in Bevy. It adds the Visibility component to the parent entity, which automatically adds other relevant visibility components.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/errors/B0004.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy::prelude::*;\n\nfn setup_cube(\n    mut commands: Commands,\n    mut meshes: ResMut<Assets<Mesh>>,\n    mut materials: ResMut<Assets<StandardMaterial>>,\n) {\n    commands\n        .spawn((Transform::default(), Visibility::default()))\n        .with_children(|parent| {\n            // cube\n            parent.spawn((\n                Mesh3d(meshes.add(Cuboid::default())),\n                MeshMaterial3d(materials.add(Color::srgb(0.8, 0.7, 0.6))),\n                Transform::from_xyz(0.0, 0.5, 0.0),\n            ));\n        });\n\n    // camera\n    commands.spawn((\n        Camera3d::default(),\n        Transform::from_xyz(-2.0, 2.5, 5.0).looking_at(Vec3::ZERO, Vec3::Y),\n     ));\n}\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_systems(Startup, setup_cube)\n        .run();\n}\n```\n\n----------------------------------------\n\nTITLE: Running Bevy Examples Using Cargo\nDESCRIPTION: Commands to checkout the latest release branch and run the 'breakout' example game using cargo. This allows users to quickly try out Bevy's examples after cloning the repository.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# Switch to the correct version (latest release, default is main development branch)\ngit checkout latest\n# Runs the \"breakout\" example\ncargo run --example breakout\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing Resources in Bevy ECS\nDESCRIPTION: Demonstrates how to define, insert, and access Resources, which are unique components not associated with any entity.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Resource, Default)]\nstruct Time {\n    seconds: f32,\n}\n\nlet mut world = World::new();\n\nworld.insert_resource(Time::default());\n\nlet time = world.get_resource::<Time>().unwrap();\n\n// You can also access resources from Systems\nfn print_time(time: Res<Time>) {\n    println!(\"{}\", time.seconds);\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Reflect for Structs and Tuple Structs in Rust\nDESCRIPTION: Shows how to derive the Reflect trait for regular structs and tuple structs, enabling runtime reflection capabilities on these types.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/README.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// this will automatically implement the `Reflect` trait and the `Struct` trait (because the type is a struct)\n#[derive(Reflect)]\nstruct Foo {\n    a: u32,\n    b: Bar,\n    c: Vec<i32>,\n    d: Vec<Baz>,\n}\n\n// this will automatically implement the `Reflect` trait and the `TupleStruct` trait (because the type is a tuple struct)\n#[derive(Reflect)]\nstruct Bar(String);\n\n#[derive(Reflect)]\nstruct Baz {\n    value: f32,\n}\n\n// We will use this value to illustrate `bevy_reflect` features\nlet mut foo = Foo {\n    a: 1,\n    b: Bar(\"hello\".to_string()),\n    c: vec![1, 2],\n    d: vec![Baz { value: 3.14 }],\n};\n```\n\n----------------------------------------\n\nTITLE: Query Filters in Bevy ECS\nDESCRIPTION: Demonstrates how to use Query Filters to selectively query entities based on their components.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Component)]\nstruct Position { x: f32, y: f32 }\n#[derive(Component)]\nstruct Player;\n#[derive(Component)]\nstruct Alive;\n\n// Gets the Position component of all Entities with Player component and without the Alive\n// component.\nfn system(query: Query<&Position, (With<Player>, Without<Alive>)>) {\n    for position in &query {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Fields by Name with Bevy Reflect\nDESCRIPTION: Demonstrates how to get and modify struct fields at runtime using their string names with the Reflect API.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/README.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nassert_eq!(*foo.get_field::<u32>(\"a\").unwrap(), 1);\n\n*foo.get_field_mut::<u32>(\"a\").unwrap() = 2;\n\nassert_eq!(foo.a, 2);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Event Observers with Bevy\nDESCRIPTION: This Rust snippet demonstrates setting up an observer for a custom event using Bevy's ECS. The observer 'listens' for the occurrence of the MyEvent and immediately executes upon a trigger, illustrating a reactive programming pattern. Dependencies include Bevy ECS (bevy_ecs::prelude), and the snippet outlines creating a custom event, adding an observer, and triggering events.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Event)]\nstruct MyEvent {\n    message: String\n}\n\nlet mut world = World::new();\n\nworld.add_observer(|trigger: Trigger<MyEvent>| {\n    println!(\"{}\", trigger.event().message);\n});\n\nworld.flush();\n\nworld.trigger(MyEvent {\n    message: \"hello!\".to_string(),\n});\n```\n\n----------------------------------------\n\nTITLE: Component Storage Types in Bevy ECS\nDESCRIPTION: Shows how to specify different storage types (Table or SparseSet) for components.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Component)]\nstruct TableStoredComponent;\n\n#[derive(Component)]\n#[component(storage = \"SparseSet\")]\nstruct SparseStoredComponent;\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Tracing Spans in Bevy Rust Applications\nDESCRIPTION: Demonstrates how to add custom timing spans to Bevy application code using the `info_span!` macro from `bevy::log`. Shows two methods: automatic timing using scope and RAII via `.entered()`, and manual timing control using `my_span.enter()` which returns a guard that stops the timer when dropped. These spans integrate with Bevy's tracing infrastructure when enabled (e.g., via the `trace` feature). Requires `bevy::prelude::*` or `bevy::log::*` to be in scope.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/profiling.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{\n  // creates a span and starts the timer\n  let my_span = info_span!(\"span_name\", name = \"span_name\").entered();\n  do_something_here();\n} // my_span is dropped here ... this stops the timer\n\n\n// You can also \"manually\" enter the span if you need more control over when the timer starts\n// Prefer the previous, simpler syntax unless you need the extra control.\nlet my_span = info_span!(\"span_name\", name = \"span_name\");\n{\n  // starts the span's timer\n  let guard = my_span.enter();\n  do_something_here();\n} // guard is dropped here ... this stops the timer\n```\n\n----------------------------------------\n\nTITLE: Defining PickTarget Component in Rust for Bevy\nDESCRIPTION: This code defines the PickTarget component, which represents an object that can be picked. It includes fields for the bounding volume and the picking method to be used.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_picking/README.md#2025-04-22_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Component)]\npub struct PickTarget {\n    pub bounding_volume: BoundingVolume,\n    pub method: PickMethod,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Target-Specific Event Triggers in Bevy\nDESCRIPTION: This Rust snippet showcases how to handle target-specific events using Bevy ECS. Observers not only react to triggers but can manipulate targeted entities directly. The snippet involves setting up an entity, defining an Explode event, and observing this event to despawn the targeted entity upon trigger. This pattern emphasizes reactive interactions with entities based on specific conditions.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Event)]\nstruct Explode;\n\nlet mut world = World::new();\nlet entity = world.spawn_empty().id();\n\nworld.add_observer(|trigger: Trigger<Explode>, mut commands: Commands| {\n    println!(\"Entity {} goes BOOM!\", trigger.target());\n    commands.entity(trigger.target()).despawn();\n});\n\nworld.flush();\n\nworld.trigger_targets(Explode, entity);\n```\n\n----------------------------------------\n\nTITLE: Implementing Trait Reflection in Bevy\nDESCRIPTION: Shows how to define and use trait reflection, allowing trait methods to be called on reflected values without knowing the concrete type at compile time.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/README.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Reflect)]\n#[reflect(DoThing)]\nstruct MyType {\n    value: String,\n}\n\nimpl DoThing for MyType {\n    fn do_thing(&self) -> String {\n        format!(\"{} World!\", self.value)\n    }\n}\n\n#[reflect_trait]\npub trait DoThing {\n    fn do_thing(&self) -> String;\n}\n\n// First, lets box our type as a Box<dyn Reflect>\nlet reflect_value: Box<dyn Reflect> = Box::new(MyType {\n    value: \"Hello\".to_string(),\n});\n\n// This means we no longer have direct access to MyType or its methods. We can only call Reflect methods on reflect_value.\n// What if we want to call `do_thing` on our type? We could downcast using reflect_value.downcast_ref::<MyType>(), but what if we\n// don't know the type at compile time?\n\n// Normally in rust we would be out of luck at this point. Lets use our new reflection powers to do something cool!\nlet mut type_registry = TypeRegistry::default();\ntype_registry.register::<MyType>();\n\n// The #[reflect] attribute we put on our DoThing trait generated a new `ReflectDoThing` struct, which implements TypeData.\n// This was added to MyType's TypeRegistration.\nlet reflect_do_thing = type_registry\n    .get_type_data::<ReflectDoThing>(reflect_value.type_id())\n    .unwrap();\n\n// We can use this generated type to convert our `&dyn Reflect` reference to a `&dyn DoThing` reference\nlet my_trait: &dyn DoThing = reflect_do_thing.get(&*reflect_value).unwrap();\n\n// Which means we can now call do_thing(). Magic!\nprintln!(\"{}\", my_trait.do_thing());\n\n// This works because the #[reflect(MyTrait)] we put on MyType informed the Reflect derive to insert a new instance\n// of ReflectDoThing into MyType's registration. The instance knows how to cast &dyn Reflect to &dyn DoThing, because it\n// knows that &dyn Reflect should first be downcasted to &MyType, which can then be safely casted to &dyn DoThing\n```\n\n----------------------------------------\n\nTITLE: Resource Change Detection in Bevy ECS\nDESCRIPTION: Demonstrates how to detect changes in Resources using the is_changed() method.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Resource)]\nstruct Time(f32);\n\n// Prints \"time changed!\" if the Time resource has changed since the last run of the System\nfn system(time: Res<Time>) {\n    if time.is_changed() {\n        println!(\"time changed!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Patching Structs with DynamicStruct\nDESCRIPTION: Shows how to create a dynamic structure with new values and apply it to patch an existing struct instance, updating multiple fields at once.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/README.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet mut dynamic_struct = DynamicStruct::default();\ndynamic_struct.insert(\"a\", 42u32);\ndynamic_struct.insert(\"c\", vec![3, 4, 5]);\n\nfoo.apply(&dynamic_struct);\n\nassert_eq!(foo.a, 42);\nassert_eq!(foo.c, vec![3, 4, 5]);\n```\n\n----------------------------------------\n\nTITLE: Creating a World in Bevy ECS\nDESCRIPTION: Shows how to create a new World instance to store Entities, Components, and Resources.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::world::World;\n\nlet world = World::default();\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Struct Fields\nDESCRIPTION: Shows how to iterate through all fields in a struct, getting both the field names and their reflected values for dynamic processing.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/README.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfor (i, value: &Reflect) in foo.iter_fields().enumerate() {\n    let field_name = foo.name_at(i).unwrap();\n    if let Some(value) = value.downcast_ref::<u32>() {\n        println!(\"{} is a u32 with the value: {}\", field_name, *value);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Bevy RenderPlugin to Use OpenGL Backend in Rust\nDESCRIPTION: This Rust code demonstrates how to initialize a Bevy application while configuring the `RenderPlugin` to explicitly use the OpenGL backend (`Backends::GL`). This involves modifying the `DefaultPlugins` set, specifically targeting the `RenderPlugin` to override its `render_creation` settings with `WgpuSettings` that specify `Backends::GL`. This approach can be used to potentially resolve issues related to hardware acceleration or specific driver problems indicated by warning B0006.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/errors/B0006.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    App::new()\n        .add_plugins(\n            DefaultPlugins.set(RenderPlugin {\n                render_creation: WgpuSettings {\n                    backends: Some(Backends::GL),\n                    ..default()\n                }\n                .into(),\n                ..default()\n            }),\n        )\n        .run();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PickSource Component in Rust for Bevy\nDESCRIPTION: This code defines the PickSource component, which represents a source for picking operations. It includes fields for the picking method, cursor position, and intersection data.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_picking/README.md#2025-04-22_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Component)]\npub struct PickSource {\n    pub method: PickMethod,\n    pub cursor_pos: Option<Vec2>,\n    pub intersect_pos: Option<Vec3>,\n    pub intersect_normal: Option<Vec3>,\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 2: Using ParamSet for Managing Conflicting Queries in Bevy\nDESCRIPTION: This solution uses a ParamSet to handle conflicting queries. ParamSet allows the system to have potentially conflicting queries as parameters, but requires the developer to ensure they are not used simultaneously within the system's execution.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/errors/B0001.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy::prelude::*;\n\n#[derive(Component)]\nstruct Player;\n\n#[derive(Component)]\nstruct Enemy;\n\nfn move_enemies_to_player(\n    mut transforms: ParamSet<(\n        Query<&mut Transform, With<Enemy>>,\n        Query<&Transform, With<Player>>,\n    )>,\n) {\n    // ...\n}\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_systems(Update, move_enemies_to_player)\n        .run();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PickMethod Enum in Rust for Bevy Picking\nDESCRIPTION: This code defines the PickMethod enum, which specifies different methods for picking objects in a 3D scene. It includes options for camera-based picking and transform-based picking.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_picking/README.md#2025-04-22_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Clone, Copy)]\npub enum PickMethod {\n    CameraCursor,\n    CameraRay(Ray),\n    Transform,\n}\n```\n\n----------------------------------------\n\nTITLE: Solution 1: Using Disjoint Queries with Without Filter in Bevy\nDESCRIPTION: This solution fixes the conflicting queries issue by using the Without filter to make the queries disjoint. It explicitly tells the compiler that Player entities never overlap with Enemy entities, allowing both queries to coexist.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/errors/B0001.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy::prelude::*;\n\n#[derive(Component)]\nstruct Player;\n\n#[derive(Component)]\nstruct Enemy;\n\nfn move_enemies_to_player(\n    mut enemies: Query<&mut Transform, With<Enemy>>,\n    player: Query<&Transform, (With<Player>, Without<Enemy>)>,\n) {\n    // ...\n}\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_systems(Update, move_enemies_to_player)\n        .run();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BoundingVolume Enum in Rust for Bevy Picking\nDESCRIPTION: This code defines the BoundingVolume enum, which specifies different types of bounding volumes that can be used for picking calculations. It includes options for spheres and axis-aligned bounding boxes (AABB).\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_picking/README.md#2025-04-22_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Clone, Copy)]\npub enum BoundingVolume {\n    Sphere { radius: f32 },\n    AABB { half_extents: Vec3 },\n}\n```\n\n----------------------------------------\n\nTITLE: Component Bundles in Bevy ECS\nDESCRIPTION: Demonstrates how to define and use Component Bundles to group related components together.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/README.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy_ecs::prelude::*;\n\n#[derive(Default, Component)]\nstruct Player;\n#[derive(Default, Component)]\nstruct Position { x: f32, y: f32 }\n#[derive(Default, Component)]\nstruct Velocity { x: f32, y: f32 }\n\n#[derive(Bundle, Default)]\nstruct PlayerBundle {\n    player: Player,\n    position: Position,\n    velocity: Velocity,\n}\n\nlet mut world = World::new();\n\n// Spawn a new entity and insert the default PlayerBundle\nworld.spawn(PlayerBundle::default());\n\n// Bundles play well with Rust's struct update syntax\nworld.spawn(PlayerBundle {\n    position: Position { x: 1.0, y: 1.0 },\n    ..Default::default()\n});\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Fields with Path Strings\nDESCRIPTION: Demonstrates how to access deeply nested fields in complex data structures using path string notation with array indices and field names.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/README.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet value = *foo.get_path::<f32>(\"d[0].value\").unwrap();\nassert_eq!(value, 3.14);\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing with Reflect\nDESCRIPTION: Demonstrates how to serialize and deserialize reflected types using a TypeRegistry without requiring explicit serde implementations for each type.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_reflect/README.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet mut registry = TypeRegistry::default();\nregistry.register::<u32>();\nregistry.register::<i32>();\nregistry.register::<f32>();\nregistry.register::<String>();\nregistry.register::<Bar>();\nregistry.register::<Baz>();\n\nlet serializer = ReflectSerializer::new(&foo, &registry);\nlet serialized = ron::ser::to_string_pretty(&serializer, ron::ser::PrettyConfig::default()).unwrap();\n\nlet mut deserializer = ron::de::Deserializer::from_str(&serialized).unwrap();\nlet reflect_deserializer = ReflectDeserializer::new(&registry);\nlet value = reflect_deserializer.deserialize(&mut deserializer).unwrap();\nlet dynamic_struct = value.take::<DynamicStruct>().unwrap();\n\nassert!(foo.reflect_partial_eq(&dynamic_struct).unwrap());\n```\n\n----------------------------------------\n\nTITLE: Correct Resource Access in Bevy System (Rust)\nDESCRIPTION: This code snippet shows the correct way to access a resource in a Bevy system. It uses only a mutable reference (ResMut) to Assets<StandardMaterial>, which provides both read and write access to the resource, eliminating the need for a separate immutable reference.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/errors/B0002.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy::prelude::*;\n\nfn update_materials(\n    mut material_updater: ResMut<Assets<StandardMaterial>>,\n) {\n    // ...\n}\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_systems(Update, update_materials)\n        .run();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Ubuntu\nDESCRIPTION: This command installs the necessary packages for building Bevy projects on Ubuntu. It includes development libraries for X11, ALSA, udev, and xkbcommon.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install g++ pkg-config libx11-dev libasound2-dev libudev-dev libxkbcommon-x11-0\n```\n\n----------------------------------------\n\nTITLE: Executing Asynchronous Commands in Bevy (Rust)\nDESCRIPTION: This Rust snippet demonstrates an error-prone setup in Bevy where entities are used and despawned in separate systems. Since these commands are executed asynchronously, this can lead to a panic when a system tries to use an entity that has already been despawned by another system. Dependencies include the Bevy engine with appropriate additions of plugins and systems. The snippet illustrates the spawning and despawning of entities, showcasing a common error scenario when these operations are not managed correctly.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/errors/B0003.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Resource)]\nstruct MyEntities(Entity, Entity);\n\n#[derive(Component)]\nstruct Hello;\n\nfn setup(mut commands: Commands) {\n    let entity1 = commands.spawn_empty().id();\n    let entity2 = commands.spawn_empty().id();\n    commands.insert_resource(MyEntities(entity1, entity2));\n}\n\nfn use_0_and_despawn_1(mut commands: Commands, my_entities: Res<MyEntities>) {\n    commands.entity(my_entities.0).insert(Hello);\n    commands.entity(my_entities.1).despawn();\n}\n\nfn use_1_and_despawn_0(mut commands: Commands, my_entities: Res<MyEntities>) {\n    commands.entity(my_entities.1).insert(Hello);\n    commands.entity(my_entities.0).despawn();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running Bevy App with Tracy Profiling Enabled (Shell)\nDESCRIPTION: Command to run a Bevy application in release mode with Tracy CPU profiling enabled. It requires the `bevy/trace_tracy` feature flag to be specified. This allows the application to connect to a running Tracy capture tool or GUI for performance analysis. Requires Cargo and a Bevy project setup.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/profiling.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --release --features bevy/trace_tracy\n```\n\n----------------------------------------\n\nTITLE: Converting Between Srgba and LinearRgba Color Spaces in Rust\nDESCRIPTION: This snippet demonstrates how to convert colors between Srgba and LinearRgba color spaces using Rust's From trait and the Into trait. It shows both explicit and implicit conversion methods.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_color/docs/conversion.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# use bevy_color::{Srgba, LinearRgba};\nlet color = Srgba::rgb(0.5, 0.5, 0.5);\n\n// Using From explicitly\nlet linear_color = LinearRgba::from(color);\n\n// Using Into\nlet linear_color: LinearRgba = color.into();\n```\n\n----------------------------------------\n\nTITLE: Spawning Entities with Missing Hierarchy Components in Bevy\nDESCRIPTION: This code snippet demonstrates a common mistake where a parent entity is spawned without the necessary visibility components, causing child entities to be invisible. It will trigger the B0004 warning.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/errors/B0004.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy::prelude::*;\n\n// WARNING: this code is buggy\nfn setup_cube(\n    mut commands: Commands,\n    mut meshes: ResMut<Assets<Mesh>>,\n    mut materials: ResMut<Assets<StandardMaterial>>,\n) {\n    commands\n        .spawn(Transform::default())\n        .with_children(|parent| {\n            // cube\n            parent.spawn((\n                Mesh3d(meshes.add(Cuboid::default())),\n                MeshMaterial3d(materials.add(Color::srgb(0.8, 0.7, 0.6))),\n                Transform::from_xyz(0.0, 0.5, 0.0),\n            ));\n        });\n\n    // camera\n    commands.spawn((\n        Camera3d::default(),\n        Transform::from_xyz(-2.0, 2.5, 5.0).looking_at(Vec3::ZERO, Vec3::Y),\n     ));\n}\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_systems(Startup, setup_cube)\n        .run();\n}\n```\n\n----------------------------------------\n\nTITLE: Erroneous Bevy System with Conflicting Queries in Rust\nDESCRIPTION: This code demonstrates an invalid Bevy system that will panic at runtime because it attempts to have both a mutable query and an immutable query on the Transform component simultaneously, violating Rust's borrowing rules.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/errors/B0001.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy::prelude::*;\n\n#[derive(Component)]\nstruct Player;\n\n#[derive(Component)]\nstruct Enemy;\n\nfn move_enemies_to_player(\n    mut enemies: Query<&mut Transform, With<Enemy>>,\n    player: Query<&Transform, With<Player>>,\n) {\n    // ...\n}\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_systems(Update, move_enemies_to_player)\n        .run();\n}\n```\n\n----------------------------------------\n\nTITLE: Running Bevy App with Tracy Memory Profiling Enabled (Shell)\nDESCRIPTION: Command to run a Bevy application in release mode with Tracy CPU and memory allocation profiling enabled. It uses the `bevy/trace_tracy_memory` feature flag, which provides memory allocation tracking at the cost of increased runtime overhead compared to `bevy/trace_tracy`. Requires Cargo and a Bevy project setup.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/profiling.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --release --features bevy/trace_tracy_memory\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Fedora\nDESCRIPTION: This command installs the necessary packages for building Bevy projects on Fedora. It includes development libraries for X11, ALSA, and systemd.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo dnf install gcc-c++ libX11-devel alsa-lib-devel systemd-devel\n```\n\n----------------------------------------\n\nTITLE: Running Bevy App with Chrome Tracing Output (Shell)\nDESCRIPTION: Command to run a Bevy application in release mode, enabling the output of profiling data in the Chrome tracing JSON format. It uses the `bevy/trace_chrome` feature flag. After the application runs, a JSON file is produced, which can be loaded into tools like Perfetto UI (<https://ui.perfetto.dev>) for visualization. Requires Cargo and a Bevy project setup.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/profiling.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo run --release --features bevy/trace_chrome\n```\n\n----------------------------------------\n\nTITLE: Configuring bevy_platform for no_std support in Cargo.toml\nDESCRIPTION: TOML configuration to use bevy_platform in a no_std environment by disabling default features. This is necessary for using the crate on platforms without the standard library.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_platform/README.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\nbevy_platform = { version = \"x.y.z\", default-features = false }\n```\n\n----------------------------------------\n\nTITLE: Erroneous Resource Access in Bevy System (Rust)\nDESCRIPTION: This code snippet demonstrates an incorrect way of accessing both mutable and immutable references to the same resource type (Assets<StandardMaterial>) in a Bevy system. This approach violates Rust's borrowing rules and will cause a panic at runtime.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/errors/B0002.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse bevy::prelude::*;\n\nfn update_materials(\n    mut material_updater: ResMut<Assets<StandardMaterial>>,\n    current_materials: Res<Assets<StandardMaterial>>,\n) {\n    // ...\n}\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .add_systems(Update, update_materials)\n        .run();\n}\n```\n\n----------------------------------------\n\nTITLE: Running Bevy Benchmarks with Cargo\nDESCRIPTION: Collection of Cargo commands for running and managing Bevy benchmarks. Includes options for running all benchmarks, specific crates, filtering by name, listing available benchmarks, and managing baseline comparisons.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/benches/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# Run all benchmarks. (This will take a while!)\ncargo bench -p benches\n\n# Just compile the benchmarks, do not run them.\ncargo bench -p benches --no-run\n\n# Run the benchmarks for a specific crate. (See `Cargo.toml` for a complete list of crates\n# tracked.)\ncargo bench -p benches --bench ecs\n\n# Filter which benchmarks are run based on the name. This will only run benchmarks whose name\n# contains \"name_fragment\".\ncargo bench -p benches -- name_fragment\n\n# List all available benchmarks.\ncargo bench -p benches -- --list\n\n# Save a baseline to be compared against later.\ncargo bench -p benches -- --save-baseline before\n\n# Compare the current benchmarks against a baseline to find performance gains and regressions.\ncargo bench -p benches -- --baseline before\n```\n\n----------------------------------------\n\nTITLE: Running Tracy Capture Tool (Shell)\nDESCRIPTION: Shell command to start the Tracy command-line capture tool. It waits for a Tracy-instrumented application to start, connects automatically, and saves the captured profile data to the specified output file (`my_capture.tracy`). The executable name (`capture-release`, `tracy`, `capture.exe`) varies by operating system (Linux, macOS, Windows).\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/profiling.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./capture-release -o my_capture.tracy\n```\n\n----------------------------------------\n\nTITLE: Generating Graph-Like Flame Graph with cargo-flamegraph (Shell)\nDESCRIPTION: Command to generate a detailed, graph-like flame graph for a Bevy application example using `cargo-flamegraph`. It runs the application in release mode, sets `RUSTFLAGS` to force frame pointers for better stack traces, and uses `record -g` for call graph recording. Replace `EXAMPLE_NAME` with the actual example name or remove `--example` to run the main application binary. Requires `cargo-flamegraph` to be installed and debug symbols enabled in the release build.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/profiling.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nRUSTFLAGS='-C force-frame-pointers=y' cargo flamegraph -c \"record -g\" --example EXAMPLE_NAME\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for Android NDK Dummy Library\nDESCRIPTION: Sets up a CMake project to create a dummy shared library. This configuration is used to trick Gradle into including libc++_shared.so in an Android project. It defines the minimum CMake version, project name, source directory, and adds a shared library target.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/mobile/android_example_native/app/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# This is part of a hack to convince gradle to insert libc++_shared.so\ncmake_minimum_required(VERSION 3.4.1)\nproject(cppshared_dummy)\nset (SRC_DIR ./src/main/cpp)\nadd_library (dummy SHARED ${SRC_DIR}/dummy.cpp)\n```\n\n----------------------------------------\n\nTITLE: Adding Android-specific metadata to Cargo.toml\nDESCRIPTION: Additional Cargo.toml configurations for specifying Android build targets and SDK version. These fields are necessary for building Android applications.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/mobile/android_basic/readme.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[package.metadata.android]\nbuild_targets = [\"aarch64-linux-android\", \"armv7-linux-androideabi\"]\n\n[package.metadata.android.sdk]\ntarget_sdk_version = 33\n```\n\n----------------------------------------\n\nTITLE: Configuring Dummy Shared Library with CMake for Gradle Workaround (CMake)\nDESCRIPTION: Configures a CMake build system for an Android project to create a dummy shared library, thus prompting Gradle to insert libc++_shared.so automatically. Requires CMake 3.4.1 or later and expects a source directory at ./src/main/cpp with a dummy.cpp file within it. The snippet establishes the minimum CMake version, names the project, defines the source directory, and adds a shared library target named 'dummy'. Inputs are the file path for dummy.cpp, and the main output is the dummy shared library that triggers Gradle's expected shared object behavior. This is primarily for build tooling compatibility and does not execute app logic.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/mobile/android_example/app/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\n# This is part of a hack to convince gradle to insert libc++_shared.so\\ncmake_minimum_required(VERSION 3.4.1)\\nproject(cppshared_dummy)\\nset (SRC_DIR ./src/main/cpp)\\nadd_library (dummy SHARED ${SRC_DIR}/dummy.cpp)\n```\n\n----------------------------------------\n\nTITLE: Installing Wayland Dependencies for Ubuntu\nDESCRIPTION: This command installs additional dependencies required for Wayland support in Bevy projects on Ubuntu.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install libwayland-dev libxkbcommon-dev\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Rustdoc Extensions in TOML\nDESCRIPTION: This snippet shows how to configure Cargo.toml to enable Rustdoc extensions for a crate. It sets up rustc and rustdoc arguments, and configures linting for unexpected cfg flags.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs-rs/README.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[package.metadata.docs.rs]\nrustc-args = [\"--cfg\", \"docsrs_dep\"]\nrustdoc-args = [\n    \"--cfg\", \"docsrs_dep\",\n    \"--html-after-content\", \"docs-rs/trait-tags.html\",\n]\n\n[lints.rust]\nunexpected_cfgs = { check-cfg = ['cfg(docsrs_dep)'] }\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Alpine Linux\nDESCRIPTION: This command installs the necessary packages for building Bevy projects on Alpine Linux. It includes development libraries for X11, ALSA, and udev, as well as the C compiler and standard libraries.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nsudo apk add gcc libc-dev pkgconf libx11-dev alsa-lib-dev eudev-dev\n```\n\n----------------------------------------\n\nTITLE: Building Local Documentation with Rustdoc Extensions in Bash\nDESCRIPTION: This bash command demonstrates how to build documentation locally with Rustdoc extensions enabled. It sets RUSTDOCFLAGS and RUSTFLAGS environment variables to include the necessary configuration and HTML content.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs-rs/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nRUSTDOCFLAGS=\"--html-after-content docs-rs/trait-tags.html --cfg docsrs_dep\" RUSTFLAGS=\"--cfg docsrs_dep\" cargo doc --no-deps --package <package_name>\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for OpenSUSE\nDESCRIPTION: This command installs the necessary packages for building Bevy projects on OpenSUSE. It includes development libraries for udev and ALSA, as well as the C++ compiler.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo zypper install libudev-devel gcc-c++ alsa-lib-devel\n```\n\n----------------------------------------\n\nTITLE: Creating Nix Shell for Bevy Development\nDESCRIPTION: This Nix expression creates a development shell with all necessary dependencies for building Bevy projects on NixOS or systems using Nix package manager.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_6\n\nLANGUAGE: nix\nCODE:\n```\n{ pkgs ? import <nixpkgs> { } }:\n\nwith pkgs;\n\nmkShell rec {\n  nativeBuildInputs = [\n    pkg-config\n  ];\n  buildInputs = [\n    udev alsa-lib-with-plugins vulkan-loader\n    xorg.libX11 xorg.libXcursor xorg.libXi xorg.libXrandr # To use the x11 feature\n    libxkbcommon wayland # To use the wayland feature\n  ];\n  LD_LIBRARY_PATH = lib.makeLibraryPath buildInputs;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Bevy for Android native activity in Cargo.toml\nDESCRIPTION: Cargo.toml configuration to enable Android native activity support in Bevy engine. This is required when using cargo-apk.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/mobile/android_basic/readme.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\nbevy = { version = \"0.14\", default-features = false, features = [\"android-native-activity\", ...] }\n```\n\n----------------------------------------\n\nTITLE: Example migration code comparison between Bevy versions\nDESCRIPTION: A code example demonstrating how to show migration steps by presenting code from the old version alongside the updated code for the new version. Shows a system function that needs to use a new method.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/release-content/migration_guides.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// 0.15\nfn my_system(world: &mut World) {\n    world.old_method();\n}\n\n// 0.16\nfn my_system(world: &mut World) {\n    // Use `new_method()` instead.\n    world.new_method();\n}\n```\n\n----------------------------------------\n\nTITLE: Using the deprecated attribute in Rust for Bevy migration\nDESCRIPTION: Example of using the #[deprecated] attribute in Rust to mark code as obsolete in Bevy. This helps ease migrations by providing warnings with helpful messages directly in the user's IDE.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/release-content/migration_guides.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[deprecated(since = \"0.17.0\", note = \"This message will appear in the deprecation warning.\")]\nstruct MyStruct;\n```\n\n----------------------------------------\n\nTITLE: WGPU Dependency Configuration for Tracing\nDESCRIPTION: Cargo.toml configuration entry to enable WGPU tracing functionality by adding the trace feature flag.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/debugging.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\nwgpu = { version = \"*\", features = [\"trace\"]}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for older Android API levels\nDESCRIPTION: Cargo.toml configuration to specify target and minimum SDK versions for compatibility with older Android devices.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/mobile/android_basic/readme.md#2025-04-22_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[package.metadata.android.sdk]\ntarget_sdk_version = >>API<<\nmin_sdk_version = >>API or less<<\n```\n\n----------------------------------------\n\nTITLE: Generating Specular IBL Cubemap using glTF-IBL-Sampler\nDESCRIPTION: Command for generating a specular environment map cubemap in KTX2 format from an HDR image using GGX distribution with a resolution of 512.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/assets/environment_maps/info.txt#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./cli -inputPath pisa.hdr -outCubeMap pisa_specular.ktx2 -distribution GGX -cubeMapResolution 512\n```\n\n----------------------------------------\n\nTITLE: Generating Flat-ish Flame Graph with cargo-flamegraph (Shell)\nDESCRIPTION: Command to generate a standard, flat-ish flame graph for a Bevy application example using `cargo-flamegraph`. It runs the application in release mode and sets `RUSTFLAGS` to force frame pointers for improved stack trace quality. Replace `EXAMPLE_NAME` with the actual example name or remove `--example` to run the main application binary. Requires `cargo-flamegraph` to be installed and debug symbols enabled in the release build.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/profiling.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nRUSTFLAGS='-C force-frame-pointers=y' cargo flamegraph --example EXAMPLE_NAME\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Arch/Manjaro\nDESCRIPTION: This command installs the necessary packages for building Bevy projects on Arch or Manjaro Linux distributions.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo pacman -S libx11 pkgconf alsa-lib\n```\n\n----------------------------------------\n\nTITLE: Profile Bevy Render Crate with Rustc\nDESCRIPTION: This snippet shows how to generate a self-profile for the `bevy_render` crate using the `RUSTC_BOOTSTRAP` environment variable. This command is useful for analyzing performance with the unstable feature of Rustc. The procedure generates a profiling data file, which is then convertible to a Chrome profiler trace through `crox` for visualization in Perfetto.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/profiling.md#2025-04-22_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nRUSTC_BOOTSTRAP=1 cargo rustc --package bevy_render --  -Z self-profile -Z self-profile-events=default,args\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Void Linux\nDESCRIPTION: This command installs the necessary packages for building Bevy projects on Void Linux. It includes development libraries for X11, ALSA, and udev.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsudo xbps-install -S pkgconf alsa-lib-devel libX11-devel eudev-libudev-devel\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Target for no_std Compilation\nDESCRIPTION: This command installs the x86_64-unknown-none target using rustup, which is necessary for compiling Rust code without the standard library.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/no_std/library/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustup target add x86_64-unknown-none\n```\n\n----------------------------------------\n\nTITLE: Setting up Rust targets and cargo-apk for Android development\nDESCRIPTION: Commands to add Android-specific Rust targets and install cargo-apk tool for building Android applications.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/mobile/android_basic/readme.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nrustup target add aarch64-linux-android armv7-linux-androideabi\ncargo install cargo-apk\n```\n\n----------------------------------------\n\nTITLE: Installing Wayland Dependencies for Fedora\nDESCRIPTION: This command installs additional dependencies required for Wayland support in Bevy projects on Fedora.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo dnf install wayland-devel libxkbcommon-devel\n```\n\n----------------------------------------\n\nTITLE: Checking no_std Compatibility with Cargo\nDESCRIPTION: This command checks the library's compatibility with no_std by compiling it with specific features and target. It disables default features and enables libm and critical-section features.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/no_std/library/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo check --no-default-features --features libm,critical-section --target x86_64-unknown-none\n```\n\n----------------------------------------\n\nTITLE: Running the Android app using cargo-apk\nDESCRIPTION: Command to build and run the Android application on a connected device using cargo-apk.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/mobile/android_basic/readme.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ncargo apk run -p bevy_mobile_example\n```\n\n----------------------------------------\n\nTITLE: Cargo Expand with Color Output Piping\nDESCRIPTION: Command to expand macros with syntax highlighting and pipe the output to a pager for better readability on Unix systems.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/debugging.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo expand --color always | less -R\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Solus\nDESCRIPTION: These commands install the necessary packages for building Bevy projects on Solus. It includes the system development tools, C++ compiler, and development libraries for X11 and ALSA.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nsudo eopkg it -c system.devel\nsudo eopkg it g++ libx11-devel alsa-lib-devel\n```\n\n----------------------------------------\n\nTITLE: Running Clippy for Rust Code Linting\nDESCRIPTION: Command to run Clippy linter on the entire workspace with all targets and features enabled, treating warnings as errors.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linters.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo clippy --workspace --all-targets --all-features -- -D warnings\n```\n\n----------------------------------------\n\nTITLE: Running Bevy Stress Test Examples with Cargo\nDESCRIPTION: This command demonstrates how to run a stress test example for the Bevy engine using Cargo. It specifies the 'stress-test' profile to ensure accurate performance representation in production-like conditions.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/stress_tests/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --profile stress-test --example <EXAMPLE>\n```\n\n----------------------------------------\n\nTITLE: Running rustfmt for Code Formatting in Rust\nDESCRIPTION: Command to automatically format Rust code using rustfmt across all project files.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linters.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo fmt --all\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Gentoo\nDESCRIPTION: This command installs the necessary packages for building Bevy projects on Gentoo Linux. It includes X11, pkgconf, and ALSA libraries.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsudo emerge --ask libX11 pkgconf alsa-lib\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Clear Linux OS\nDESCRIPTION: These commands install the necessary bundles for building Bevy projects on Clear Linux OS. It includes ALSA and udev development libraries.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nsudo swupd bundle-add devpkg-alsa-lib\nsudo swupd bundle-add devpkg-libgudev\n```\n\n----------------------------------------\n\nTITLE: Generating Color Test Data for Bevy Engine\nDESCRIPTION: Shell command to run the test data generator and save the output to a test_colors.rs file in the src directory. This command should be executed by developers working on the Bevy engine to update the color conversion test data.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_color/crates/gen_tests/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run > ../../src/test_colors.rs\n```\n\n----------------------------------------\n\nTITLE: GitHub Action for Checking no_std Compatibility\nDESCRIPTION: This YAML configuration sets up a GitHub Action to automatically check no_std compatibility across multiple targets. It uses a matrix strategy to test against x86_64-unknown-none, wasm32v1-none, and thumbv6m-none-eabi targets.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/no_std/library/README.md#2025-04-22_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\njobs:\n  check-compiles-no-std:\n    runs-on: ubuntu-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        target:\n          - \"x86_64-unknown-none\"\n          - \"wasm32v1-none\"\n          - \"thumbv6m-none-eabi\"\n    steps:\n      - uses: actions/checkout@v4\n      - uses: dtolnay/rust-toolchain@stable\n        with:\n          targets: ${{ matrix.target }}\n      - name: Check Compile\n        run: cargo check --no-default-features --features libm,critical-section --target ${{ matrix.target }}\n```\n\n----------------------------------------\n\nTITLE: Installing Wayland Dependencies for Solus\nDESCRIPTION: This command installs additional dependencies required for Wayland support in Bevy projects on Solus.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linux_dependencies.md#2025-04-22_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nsudo eopkg it wayland-devel libxkbcommon-devel\n```\n\n----------------------------------------\n\nTITLE: Rust Library References in Documentation\nDESCRIPTION: Code references to Rust's core libraries (std, core, and alloc) that are relevant for no_std development in Bevy. Shows the relationship between standard library components for embedded systems.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/examples/no_std/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`no_std`\n[`std`](https://doc.rust-lang.org/stable/std/)\n[`core`](https://doc.rust-lang.org/stable/core/)\n[`alloc`](https://doc.rust-lang.org/stable/alloc/)\n[global allocator](https://doc.rust-lang.org/stable/std/alloc/trait.GlobalAlloc.html)\n```\n\n----------------------------------------\n\nTITLE: Expanding Rust Macros Using Cargo Command\nDESCRIPTION: Command to print the final expanded output of a macro using cargo rustc with unstable options for debugging purposes.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/debugging.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo rustc --profile=check -- -Zunstable-options --pretty=expanded\n```\n\n----------------------------------------\n\nTITLE: Installing bevy_platform using Cargo\nDESCRIPTION: Command to add bevy_platform as a dependency to a Rust project using Cargo. This allows developers to use bevy_platform in their projects.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_platform/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo add bevy_platform\n```\n\n----------------------------------------\n\nTITLE: Referencing Release Notes Template in Markdown\nDESCRIPTION: This snippet shows how to reference the release notes template file using a markdown link. It's used to guide contributors on where to find the template for creating new release notes.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/release-content/release_notes.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[the template](./release_notes_template.md)\n```\n\n----------------------------------------\n\nTITLE: Running Generate Example in Bevy Mikktspace\nDESCRIPTION: Command to run the example that demonstrates generating tangents for a cube with 4 triangular faces per side using the Mikktspace implementation.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_mikktspace/README.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncargo run --example generate\n```\n\n----------------------------------------\n\nTITLE: File Path References in Markdown\nDESCRIPTION: References to key paths and files related to the compile fail tests implementation and documentation.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/crates/bevy_ecs/compile_fail/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\ntools/ci/src/main.rs\ncompile_fail_utils/README.md\n```\n\n----------------------------------------\n\nTITLE: Generating Diffuse IBL Cubemap using glTF-IBL-Sampler\nDESCRIPTION: Command for generating a diffuse environment map cubemap in KTX2 format from an HDR image using Lambertian distribution with a resolution of 32.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/assets/environment_maps/info.txt#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./cli -inputPath pisa.hdr -outCubeMap pisa_diffuse.ktx2 -distribution Lambertian -cubeMapResolution 32\n```\n\n----------------------------------------\n\nTITLE: Converting KTX2 Files to RGB9E5 Format with ZSTD Compression\nDESCRIPTION: Command for converting the diffuse and specular KTX2 files to RGB9E5 format with ZSTD supercompression using bevy_mod_environment_map_tools.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/assets/environment_maps/info.txt#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --release -- --inputs pisa_diffuse.ktx2,pisa_specular.ktx2 --outputs pisa_diffuse_rgb9e5_zstd.ktx2,pisa_specular_rgb9e5_zstd.ktx2\n```\n\n----------------------------------------\n\nTITLE: Documenting Bevy Error Codes in Markdown\nDESCRIPTION: This markdown snippet provides an overview of the Bevy error codes documentation, including its purpose and where to find the rendered version of the error code descriptions.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/errors/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Bevy Error Codes\n\nThis crate lists and tests explanations and examples of Bevy's error codes.\n\nFor the latest Bevy release, you can find a rendered version of the error code descriptions at\n[bevyengine.org/learn/errors].\n\n[bevyengine.org/learn/errors]: https://bevyengine.org/learn/errors\n```\n\n----------------------------------------\n\nTITLE: Configuring VS Code markdownlint Extension\nDESCRIPTION: JSON configuration to extend the VS Code markdownlint extension with custom rules defined in the project's .markdown-lint.yml file.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/docs/linters.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"extends\": \".github/linters/.markdown-lint.yml\"\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Skybox Images with ImageMagick in Bash\nDESCRIPTION: Commands used to process skybox textures. The first command resizes all JPG images to 256x256 and converts them to PNG format. The second command combines six cube map faces into a single vertically stacked image.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/assets/textures/Ryfjallet_cubemap_readme.txt#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmogrify -resize 256x256 -format png *.jpg\nconvert posx.png negx.png posy.png negy.png posz.png negz.png -gravity center -append cubemap.png\n```\n\n----------------------------------------\n\nTITLE: Copying Template for Release Notes in Markdown\nDESCRIPTION: This snippet provides the exact line contributors should use to duplicate the release note template to the correct location within the repository. There are no code-level dependencies since this is a basic file operation instruction intended to ensure consistency in the documentation process. Input is the path to the new release note file; output is a copy placed in the ./release-notes directory.\nSOURCE: https://github.com/bevyengine/bevy/blob/main/release-content/release_notes_template.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\nCopy the contents of this file into `./release-notes`, update the metadata, and add release note content here.\n```"
  }
]