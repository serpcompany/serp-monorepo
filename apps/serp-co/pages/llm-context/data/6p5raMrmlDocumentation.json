[
  {
    "owner": "6p5ra",
    "repo": "mrml-documentation",
    "content": "TITLE: Parsing and Rendering MJML in Rust\nDESCRIPTION: This Rust code snippet demonstrates the complete process of parsing MJML input and rendering it to HTML using the `mrml` crate. It showcases the use of the `parse` and `render` methods, including error handling for both parsing and rendering. Dependencies include the `mrml` crate, and the input is a valid MJML string.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse mrml::prelude::render::RenderOptions; // Needed for default render options\n\nlet mjml_input = r#\"\n<mjml>\n  <mj-body>\n    <mj-section>\n      <mj-column>\n        <mj-text>Hello World!</mj-text>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n\"#;\n\n// 1. Parse the MJML (from Chapter 1)\nmatch mrml::parse(mjml_input) {\n    Ok(parsed_mjml) => {\n        println!(\"MJML parsed successfully!\");\n\n        // 2. Define rendering options (we'll use defaults for now)\n        let render_options = RenderOptions::default();\n\n        // 3. Call the render method\n        match parsed_mjml.render(&render_options) {\n            Ok(final_html) => {\n                // If rendering is successful, we get the final HTML string!\n                println!(\"MJML rendered successfully!\");\n                println!(\"--- Output HTML (simplified) ---\");\n                // The actual output is much longer due to email client compatibility HTML\n                println!(\"{}\", final_html);\n            }\n            Err(e) => {\n                // Handle potential rendering errors (less common than parse errors)\n                println!(\"Oops, couldn't render the MJML: {:?}\", e);\n            }\n        }\n    }\n    Err(e) => {\n        println!(\"Oops, couldn't parse the MJML: {:?}\", e);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering MJML to HTML using MRML CLI\nDESCRIPTION: These commands use the `mrml-cli` tool to render an MJML file (`welcome.mjml`) into HTML.  The first command prints the generated HTML to the console, while the second command saves the HTML to a file named `welcome.html`. Requires `mrml-cli` to be installed.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Render welcome.mjml and print HTML to the console\nmrml-cli welcome.mjml render\n\n# Render welcome.mjml and save HTML to welcome.html\nmrml-cli welcome.mjml render -o welcome.html\n```\n\n----------------------------------------\n\nTITLE: Rendering MJML in Python using mrml-python\nDESCRIPTION: This Python code snippet demonstrates how to use the `mrml-python` package to render an MJML string into HTML. It imports the `mrml` library, defines an MJML string, and then calls the `mrml.to_html()` function to render it. The resulting HTML and any warnings are then printed to the console.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport mrml\n\nmjml_string = \"\"\"\n<mjml>\n  <mj-body>\n    <mj-text>Hello from Python!</mj-text>\n  </mj-body>\n</mjml>\n\"\"\"\n\n# Render the MJML string to HTML\nresult = mrml.to_html(mjml_string)\n\n# Check for warnings (more on warnings later)\nif result.warnings:\n    print(\"Warnings:\", result.warnings)\n\n# Access the rendered HTML content\nhtml_output = result.content\nprint(html_output[:100] + \"...\") # Print the first 100 chars\n```\n\n----------------------------------------\n\nTITLE: Rendering MJML in Node.js using mrml-wasm\nDESCRIPTION: This JavaScript code snippet demonstrates how to use the `mrml-wasm` package in a Node.js environment to render an MJML string into HTML. It imports the `Engine` class from the `mrml-wasm/node/mrml` module, creates an instance of the engine, and then calls the `toHtmlAsync()` method to render the MJML string asynchronously. The resulting HTML and any warnings are then printed to the console.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n// Use the Node.js-specific entry point\nconst { Engine } = require(\"mrml-wasm/node/mrml\");\n\nconst mjmlString = `\n<mjml>\n  <mj-body>\n    <mj-text>Hello from WASM!</mj-text>\n  </mj-body>\n</mjml>\n`;\n\n// Create an engine instance\nconst engine = new Engine();\n\n// Render the MJML string to HTML\n// Note: In WASM, rendering might be async depending on features used\nengine.toHtmlAsync(mjmlString).then(result => {\n  if (result.warnings && result.warnings.length > 0) {\n    console.warn(\"Warnings:\", result.warnings);\n  }\n  const htmlOutput = result.content;\n  console.log(htmlOutput.substring(0, 100) + \"...\"); // Print start of HTML\n}).catch(error => {\n  console.error(\"Rendering failed:\", error);\n});\n```\n\n----------------------------------------\n\nTITLE: Parsing and Rendering MJML with LocalIncludeLoader Using Python\nDESCRIPTION: Demonstrates configuring mrml's Python binding to use a LocalIncludeLoader that loads included MJML files from the local filesystem. It sets up ParserOptions with the loader pointing to a base directory and invokes the to_html function with MJML content containing <mj-include> tags. The output is rendered HTML with included partials injected. Prerequisites include having your MJML partials present in the filesystem relative to the base directory.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport mrml\nimport os # Needed for file paths\n\n# Assume main_email.mjml, partials/header.mjml, partials/footer.mjml\n# exist in the current directory structure.\n\nmain_mjml_content = \"\"\"\n<mjml>\n  <mj-body>\n    <mj-include path=\"./partials/header.mjml\" />\n    <mj-section>\n      <mj-column>\n        <mj-text>Welcome to our service!</mj-text>\n      </mj-column>\n    </mj-section>\n    <mj-include path=\"./partials/footer.mjml\" />\n  </mj-body>\n</mjml>\n\"\"\"\n\n# Tell the loader where to look for files (e.g., the current directory)\n# Paths in <mj-include> will be relative to this directory.\nbase_dir = os.getcwd()\nloader_options = mrml.local_loader(base_dir)\n\n# Configure the parser to use this loader\nparser_opts = mrml.ParserOptions(include_loader=loader_options)\n\n# Parse and render\nresult = mrml.to_html(main_mjml_content, parser_options=parser_opts)\n\nprint(\"Rendered HTML (includes header and footer):\")\nprint(result.content[:200] + \"...\") # Show the beginning of the HTML\n```\n\n----------------------------------------\n\nTITLE: Configuring ParserOptions with Include Loader in Python\nDESCRIPTION: This snippet shows how to instantiate `mrml.ParserOptions` and assign a configured `include_loader` (specifically a `local_loader`). This object is then used when calling `mrml.to_html` to control how the parser resolves `<mj-include>` directives during the MJML parsing phase.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nimport mrml\nimport os\n\n# Example: Setting up a local include loader (like in Chapter 5)\nbase_dir = os.getcwd()\nloader_opts = mrml.local_loader(base_dir)\n\n# Create ParserOptions and specify the include_loader\nparser_options = mrml.ParserOptions(\n    include_loader=loader_opts\n)\n\n# We would pass 'parser_options' when calling mrml.to_html()\n# mjml_input = \"<mjml>...</mjml>\"\n# result = mrml.to_html(mjml_input, parser_options=parser_options)\n# print(\"Parser configured!\")\n```\n\n----------------------------------------\n\nTITLE: Configuring RenderOptions and Rendering MJML in Python\nDESCRIPTION: This code demonstrates creating and configuring `mrml.RenderOptions` by setting `disable_comments` to `True` and defining a custom font (`MyCustomFont`) via the `fonts` dictionary. The configured `render_options` object is then passed to `mrml.to_html` alongside the MJML input, influencing the structure and content of the generated HTML.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nimport mrml\n\nmjml_input = \"\"\"\n<mjml>\n  <mj-head>\n    <!-- This is a comment we might want to remove -->\n    <mj-title>My Configured Email</mj-title>\n  </mj-head>\n  <mj-body>\n    <mj-section>\n      <mj-column>\n        <mj-text font-family=\"MyCustomFont, Arial, sans-serif\">Hello!</mj-text>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n\"\"\"\n\n# Create RenderOptions\nrender_options = mrml.RenderOptions(\n    # Switch 1: Remove HTML comments from the output\n    disable_comments=True,\n\n    # Switch 2: Define default fonts to include in the <head>\n    # (Keys are font names, values are URLs to the font file)\n    fonts={\n        \"MyCustomFont\": \"url-to-your-custom-font.woff2\"\n        # Default fonts like 'Ubuntu' are usually included unless overridden\n    }\n    # Another option: social_icon_origin=\"https://custom.icons/url/\"\n)\n\n# Render the MJML using these options\n# (We'll use default parser options here for simplicity)\nresult = mrml.to_html(mjml_input, render_options=render_options)\n\nprint(\"Rendered HTML (with comments disabled and custom font defined):\")\n# Check the output HTML: the comment should be gone,\n# and the <head> should include a @font-face for MyCustomFont.\nprint(result.content[:500] + \"...\") # Show the beginning of the HTML\n```\n\n----------------------------------------\n\nTITLE: Example MJML Template Using <mj-include> for File-Based Partial Templates\nDESCRIPTION: This MJML markup demonstrates how to use the <mj-include> tag to modularize email templates by referencing external header and footer partials. The main template references header and footer mjml files stored under a filesystem path, promoting reusability and maintainability of template components.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_12\n\nLANGUAGE: mjml\nCODE:\n```\n<!-- main_email.mjml -->\n<mjml>\n  <mj-body>\n    <!-- Include the header -->\n    <mj-include path=\"./partials/header.mjml\" />\n\n    <!-- Email specific content goes here -->\n    <mj-section>\n      <mj-column>\n        <mj-text>Welcome to our service!</mj-text>\n      </mj-column>\n    </mj-section>\n\n    <!-- Include the footer -->\n    <mj-include path=\"./partials/footer.mjml\" />\n  </mj-body>\n</mjml>\n```\n\n----------------------------------------\n\nTITLE: Parsing MJML Example\nDESCRIPTION: This Rust code snippet demonstrates how to use the `mrml::parse()` function to parse an MJML string. It takes an MJML template as input, calls the parse function, and handles potential parsing errors using a `match` statement. The primary output is a success or error message.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// The MJML template we want to parse\nlet mjml_input = r#\"\n<mjml>\n  <mj-body>\n    <mj-section>\n      <mj-column>\n        <mj-text>Hello World!</mj-text>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n\"#;\n\n// Call the parse function\nmatch mrml::parse(mjml_input) {\n    Ok(parsed_mjml) => {\n        // If parsing is successful, we get the structured representation back.\n        // We don't need to look inside `parsed_mjml` just yet,\n        // just know that mrml now understands the template!\n        println!(\"MJML parsed successfully!\");\n        // Next step would be rendering (covered later)\n    }\n    Err(e) => {\n        // If there's an error in the MJML syntax...\n        println!(\"Oops, couldn't parse the MJML: {:?}\", e);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing and Rendering MJML with MemoryIncludeLoader Using Python\nDESCRIPTION: Shows how to use mrml's MemoryIncludeLoader in Python to supply MJML partials directly from in-memory strings rather than filesystem files. It configures ParserOptions with a dictionary mapping file keys to MJML content and parses a main MJML template that includes these keys. This approach suits scenarios where templates come from a database or configuration rather than disk storage.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport mrml\n\nmain_mjml_content = \"\"\"\n<mjml>\n  <mj-body>\n    <mj-include path=\"my_header\" />\n    <mj-section><mj-column><mj-text>Main content.</mj-text></mj-column></mj-section>\n    <mj-include path=\"my_footer\" />\n  </mj-body>\n</mjml>\n\"\"\"\n\n# Store the content of our \"files\" in a dictionary\nin_memory_files = {\n    \"my_header\": \"<mj-section><mj-column><mj-text>Memory Header</mj-text></mj-column></mj-section>\",\n    \"my_footer\": \"<mj-section><mj-column><mj-text>Memory Footer</mj-text></mj-column></mj-section>\"\n}\n\n# Create a memory loader with this data\nloader_options = mrml.memory_loader(in_memory_files)\n\n# Configure the parser\nparser_opts = mrml.ParserOptions(include_loader=loader_options)\n```\n\n----------------------------------------\n\nTITLE: Example MJML template\nDESCRIPTION: This is a simple MJML template that defines a basic email structure with a section, column, and text element. It's used as input for the `mrml-cli` tool to generate HTML.  The root element is `<mjml>`, and it contains `<mj-body>` with nested components.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_5\n\nLANGUAGE: mjml\nCODE:\n```\n<!-- welcome.mjml -->\n<mjml>\n  <mj-body>\n    <mj-section>\n      <mj-column>\n        <mj-text>Welcome to mrml!</mj-text>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n```\n\n----------------------------------------\n\nTITLE: Example MJML Input for Render Options Demonstration\nDESCRIPTION: This MJML snippet serves as input for the subsequent Python code demonstrating `RenderOptions`. It includes an HTML comment and a reference to a custom font family (`MyCustomFont`), which are used to show the effects of setting `disable_comments` and `fonts` in `RenderOptions`.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_18\n\nLANGUAGE: mjml\nCODE:\n```\n<mjml>\n  <mj-head>\n    <!-- This is a comment we might want to remove -->\n    <mj-title>My Configured Email</mj-title>\n  </mj-head>\n  <mj-body>\n    <mj-section>\n      <mj-column>\n        <mj-text font-family=\"MyCustomFont, Arial, sans-serif\">Hello!</mj-text>\n      </mj-column>\n    </mj-section>\n  </mj-body>\n</mjml>\n```\n\n----------------------------------------\n\nTITLE: Conceptual RenderOptions Structure and Default in Rust\nDESCRIPTION: This conceptual Rust snippet shows the basic structure of `RenderOptions`, including fields for `disable_comments`, `social_icon_origin`, and `fonts`. It also illustrates the `impl Default for RenderOptions` block, indicating how sensible default values are provided for these rendering settings when the options are not explicitly configured.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n// Simplified concept - Not the actual mrml code!\nuse std::collections::HashMap;\n\n// Options for the rendering phase\n#[derive(Debug, Clone)] // Allows copying the options\npub struct RenderOptions {\n    // Should HTML comments be stripped out?\n    pub disable_comments: bool,\n    // Custom URL prefix for social icons\n    pub social_icon_origin: Option<String>,\n    // Map of font-family names to their CSS src URLs\n    pub fonts: HashMap<String, String>,\n    // Other rendering settings...\n}\n\n// Function to provide sensible defaults\nimpl Default for RenderOptions {\n    fn default() -> Self {\n        // Sets default values like keeping comments, default fonts map, etc.\n        Self {\n            disable_comments: false,\n            social_icon_origin: None,\n            fonts: default_fonts(), // A helper function to get default fonts\n            // ...\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conceptual ParserOptions Structure Definition in Rust\nDESCRIPTION: This conceptual Rust snippet illustrates the basic structure of `ParserOptions` within the `mrml-core` library. It shows that the primary component is a `Box<dyn IncludeLoader>`, which is used by the parser to handle `<mj-include>` directives during the parsing process.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n// Simplified concept - Not the actual mrml code!\nuse crate::prelude::parser::loader::IncludeLoader; // Link to IncludeLoader trait\n\n// Options for the parsing phase\npub struct ParserOptions {\n    // The configured assistant for handling <mj-include>\n    pub include_loader: Box<dyn IncludeLoader>,\n    // Potentially other parser-specific options in the future...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing MRML Python package with pip\nDESCRIPTION: This command installs the mrml-python package using pip, Python's package installer. It fetches the package from PyPI and installs it into your Python environment, allowing you to import and use the `mrml` library in your Python scripts.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npip install mrml-python\n```\n\n----------------------------------------\n\nTITLE: Installing MRML CLI tool with Cargo\nDESCRIPTION: This command installs the mrml-cli tool using Cargo, Rust's package manager.  It downloads and compiles the mrml-cli crate and places the executable in your Cargo bin directory, allowing you to use the `mrml-cli` command in your terminal.  Requires Rust and Cargo to be installed.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncargo install --locked mrml-cli\n```\n\n----------------------------------------\n\nTITLE: Installing MRML WASM package with npm\nDESCRIPTION: This command installs the mrml-wasm package using npm, the Node.js package manager. It downloads the package and its dependencies from the npm registry and installs them into your project's `node_modules` directory.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpm install mrml-wasm\n# or\nyarn add mrml-wasm\n```\n\n----------------------------------------\n\nTITLE: Simplified MjText Component Structure in Rust\nDESCRIPTION: Demonstrates a conceptual representation of how an MJML <mj-text> component is stored as a Rust struct in mrml. The struct contains fields for attributes and content, along with a rendering method that transforms the component data into HTML output.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Simplified concept - Not the actual mrml code!\nstruct MjText {\n    // Attributes are stored as fields\n    attributes: MjTextAttributes, // Holds things like color, font-size, padding\n    content: String, // The actual text, e.g., \"Hello World!\"\n\n    // ... other necessary internal data ...\n}\n\n// A helper struct to hold the attributes specifically\nstruct MjTextAttributes {\n    color: Option<String>, // Optional, might not be set\n    font_size: Option<String>,\n    padding: Option<String>,\n    // ... many more attributes ...\n}\n\n// Each component struct also has associated functions (methods)\n// that contain the logic for rendering.\nimpl MjText {\n    // Simplified idea of the rendering function\n    // (We'll cover rendering properly in the next chapter!)\n    fn render(&self /* , other context info */) -> String {\n        // Logic to generate HTML for mj-text using\n        // self.attributes.color, self.content, etc.\n        // This involves creating <div>s or <td>s with specific inline CSS.\n        let html_output = format!(\n            \"<div style=\\\"color: {}; padding: {};\\\">{}</div>\",\n            self.attributes.color.as_deref().unwrap_or(\"#000000\"), // Use default if not set\n            self.attributes.padding.as_deref().unwrap_or(\"10px 25px\"),\n            self.content\n        );\n        // The real logic is much more complex!\n        return html_output;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MJML to Internal Representation Mapping Flow Diagram\nDESCRIPTION: A Mermaid diagram visualizing how MJML input is parsed and transformed into internal component representations. It shows the flow from raw MJML text to the creation of specific Rust struct instances with their attributes, content, and rendering logic.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n    A[\"MJML Input:<br/><mj-text color='red'>Hi</mj-text>\"] -- Parsing (Chapter 1) --> B(Internal Representation);\n    subgraph B [Internal Representation]\n        direction LR\n        C[Specific Rust Struct:<br/>MjText Instance]\n        C --> D{Attributes:<br/>color: \"red\"<br/>padding: *default*}\n        C --> E[Content:<br/>\"Hi\"]\n        C --> F[Rendering Logic:<br/>Defined in MjText struct]\n    end\n\n    style B fill:#eee,stroke:#333,stroke-width:1px\n```\n\n----------------------------------------\n\nTITLE: Header Partial MJML Template for Inclusion\nDESCRIPTION: Defines a reusable header partial used with the <mj-include> tag, containing a section with a logo image. This snippet is intended to be stored separately and referenced from other templates for consistent branding.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_13\n\nLANGUAGE: mjml\nCODE:\n```\n<!-- partials/header.mjml -->\n<mj-section background-color=\"#f0f0f0\">\n  <mj-column>\n    <mj-image width=\"100px\" src=\"logo.png\"></mj-image>\n  </mj-column>\n</mj-section>\n```\n\n----------------------------------------\n\nTITLE: Footer Partial MJML Template for Inclusion\nDESCRIPTION: Defines a reusable footer partial with company copyright and unsubscribe links, designed to be included in other MJML templates for uniformity across emails.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_14\n\nLANGUAGE: mjml\nCODE:\n```\n<!-- partials/footer.mjml -->\n<mj-section>\n  <mj-column>\n    <mj-text align=\"center\">© 2023 Your Company</mj-text>\n    <mj-text align=\"center\"><a href=\"#\">Unsubscribe</a></mj-text>\n  </mj-column>\n</mj-section>\n```\n\n----------------------------------------\n\nTITLE: Visualizing mrml Binding Flow with Mermaid Sequence Diagram\nDESCRIPTION: This mermaid sequence diagram illustrates the cross-platform bindings workflow for the mrml engine. It shows how user input (from CLI, Python, or JavaScript) passes through the binding interfaces to the Rust core engine where MJML parsing and rendering occurs, and the results propagate back to the user. This visualization serves to clarify the interactions and data conversions between different layers of the mrml ecosystem.\nSOURCE: https://github.com/6p5ra/mrml-documentation/blob/main/files/mrml.md#_snippet_11\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant User as User (CLI/Python/JS)\n    participant Binding as Binding (mrml-cli / mrml-python / mrml-wasm)\n    participant MrmlCore as mrml-core (Rust Engine)\n\n    User->>Binding: Provides MJML input & calls function (e.g., render)\n    Binding->>MrmlCore: Calls parse() with MJML string\n    MrmlCore->>MrmlCore: Parses MJML into internal structure\n    MrmlCore-->>Binding: Returns parsed structure (or error)\n    alt Parsing Successful\n        Binding->>MrmlCore: Calls render() on parsed structure\n        MrmlCore->>MrmlCore: Generates HTML based on structure\n        MrmlCore-->>Binding: Returns HTML string (or error)\n        Binding-->>User: Returns final HTML (or error)\n    else Parsing Failed\n        Binding-->>User: Returns parse error\n    end\n```"
  }
]