[
  {
    "owner": "tokio-rs",
    "repo": "tokio",
    "content": "TITLE: Implementing a Basic TCP Echo Server with Tokio\nDESCRIPTION: This example demonstrates how to create a TCP echo server using Tokio's asynchronous networking capabilities. It binds to a local address, accepts connections, and spawns a task for each connection to read and write data asynchronously.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/README.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tokio::net::TcpListener;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let listener = TcpListener::bind(\"127.0.0.1:8080\").await?;\n\n    loop {\n        let (mut socket, _) = listener.accept().await?;\n\n        tokio::spawn(async move {\n            let mut buf = [0; 1024];\n\n            // In a loop, read data from the socket and write the data back.\n            loop {\n                let n = match socket.read(&mut buf).await {\n                    // socket closed\n                    Ok(0) => return,\n                    Ok(n) => n,\n                    Err(e) => {\n                        eprintln!(\"failed to read from socket; err = {:?}\", e);\n                        return;\n                    }\n                };\n\n                // Write the data back\n                if let Err(e) = socket.write_all(&buf[0..n]).await {\n                    eprintln!(\"failed to write to socket; err = {:?}\", e);\n                    return;\n                }\n            }\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a TCP Echo Server with Tokio\nDESCRIPTION: This example demonstrates how to create a basic TCP echo server using Tokio. It shows how to bind a listener to a specific port, accept incoming connections, read data from clients, and write it back in an asynchronous manner.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/README.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse tokio::net::TcpListener;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let listener = TcpListener::bind(\"127.0.0.1:8080\").await?;\n\n    loop {\n        let (mut socket, _) = listener.accept().await?;\n\n        tokio::spawn(async move {\n            let mut buf = [0; 1024];\n\n            // In a loop, read data from the socket and write the data back.\n            loop {\n                let n = match socket.read(&mut buf).await {\n                    // socket closed\n                    Ok(0) => return,\n                    Ok(n) => n,\n                    Err(e) => {\n                        eprintln!(\"failed to read from socket; err = {:?}\", e);\n                        return;\n                    }\n                };\n\n                // Write the data back\n                if let Err(e) = socket.write_all(&buf[0..n]).await {\n                    eprintln!(\"failed to write to socket; err = {:?}\", e);\n                    return;\n                }\n            }\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Tokio Dependencies in Cargo.toml\nDESCRIPTION: This snippet shows how to configure the Tokio dependency in a Rust project's Cargo.toml file, enabling the full feature set. It specifies version 1.44.2 with the \"full\" feature flag enabled.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/README.md#2025-04-23_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntokio = { version = \"1.44.2\", features = [\"full\"] }\n```\n\n----------------------------------------\n\nTITLE: Adding Tokio Dependency with Full Features in Cargo.toml\nDESCRIPTION: This snippet shows how to add the Tokio dependency to your Cargo.toml file with the 'full' feature flag enabled, which activates all available Tokio functionality.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/README.md#2025-04-23_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ntokio = { version = \"1.44.2\", features = [\"full\"] }\n```\n\n----------------------------------------\n\nTITLE: Redesigned Registration API for Tokio I/O in Rust\nDESCRIPTION: Defines the updated Registration API which supports waiting for arbitrary interest sets with `&self`, enabling concurrent waiters with different readiness interests. It includes methods for creating registrations, awaiting readiness events, and clearing resource-level readiness.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/docs/reactor-refactor.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nstruct Registration { ... }\n\n// TODO: naming\nstruct ReadyEvent {\n    tick: u32,\n    ready: mio::Ready,\n}\n\nimpl Registration {\n    /// `interest` must be a super set of **all** interest sets specified in\n    /// the other methods. This is the interest set passed to `mio`.\n    pub fn new<T>(io: &T, interest: mio::Ready) -> io::Result<Registration>\n        where T: mio::Evented;\n\n    /// Awaits for any readiness event included in `interest`. Returns a\n    /// `ReadyEvent` representing the received readiness event.\n    async fn readiness(&self, interest: mio::Ready) -> io::Result<ReadyEvent>;\n\n    /// Clears resource level readiness represented by the specified `ReadyEvent`\n    async fn clear_readiness(&self, ready_event: ReadyEvent);\n\n```\n\n----------------------------------------\n\nTITLE: Pseudocode for TCP Read Operation Using New Registration API in Rust\nDESCRIPTION: Demonstrates how a TCP read operation would be implemented using the new Registration API. It shows the pattern of awaiting readiness, attempting I/O, and clearing readiness when a WouldBlock error is encountered, which allows for proper edge-triggered notification handling.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/docs/reactor-refactor.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nasync fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n    loop {\n        // Await readiness\n        let event = self.readiness(interest).await?;\n\n        match self.mio_socket.read(buf) {\n            Ok(v) => return Ok(v),\n            Err(ref e) if e.kind() == WouldBlock => {\n                self.clear_readiness(event);\n            }\n            Err(e) => return Err(e),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Redesigned ScheduledIo Type with Intrusive Waker List in Rust\nDESCRIPTION: Defines the new ScheduledIo type that uses an intrusive waker linked list to track multiple concurrent waiters. Each waiter entry includes the interest set and waker, allowing the I/O driver to notify only waiters interested in specific readiness events.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/docs/reactor-refactor.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Debug)]\npub(crate) struct ScheduledIo {\n    /// Resource's known state packed with other state that must be\n    /// atomically updated.\n    readiness: AtomicUsize,\n\n    /// Tracks tasks waiting on the resource\n    waiters: Mutex<Waiters>,\n}\n\n#[derive(Debug)]\nstruct Waiters {\n    // List of intrusive waiters.\n    list: LinkedList<Waiter>,\n\n    /// Waiter used by `AsyncRead` implementations.\n    reader: Option<Waker>,\n\n    /// Waiter used by `AsyncWrite` implementations.\n    writer: Option<Waker>,\n}\n\n// This struct is contained by the **future** returned by `readiness()`.\n#[derive(Debug)]\nstruct Waiter {\n    /// Intrusive linked-list pointers\n    pointers: linked_list::Pointers<Waiter>,\n\n    /// Waker for task waiting on I/O resource\n    waiter: Option<Waker>,\n\n    /// Readiness events being waited on. This is\n    /// the value passed to `readiness()`\n    interest: mio::Ready,\n\n    /// Should not be `Unpin`.\n    _p: PhantomPinned,\n}\n```\n\n----------------------------------------\n\nTITLE: TcpStream Reference Handling API in Rust\nDESCRIPTION: Introduces a new approach for enabling operations on shared references to TcpStream without implementing AsyncRead/AsyncWrite for reference types. This allows for concurrent operations on a shared TcpStream instance while properly managing waker resources.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/docs/reactor-refactor.md#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl TcpStream {\n    /// Naming TBD\n    fn by_ref(&self) -> TcpStreamRef<'_>;\n}\n\nstruct TcpStreamRef<'a> {\n    stream: &'a TcpStream,\n\n    // `Waiter` is the node in the intrusive waiter linked-list\n    read_waiter: Waiter,\n    write_waiter: Waiter,\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of TcpStream Reference API in Rust\nDESCRIPTION: Demonstrates how the new TcpStream::by_ref() method can be used to perform concurrent operations on a shared TcpStream. The examples show using it with select! for concurrent reads and writes, and with Arc for shared ownership.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/docs/reactor-refactor.md#2025-04-23_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet rd = my_stream.by_ref();\nlet wr = my_stream.by_ref();\n\nselect! {\n    // use `rd` and `wr` in separate branches.\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet arc_stream = Arc::new(my_tcp_stream);\nlet n = arc_stream.by_ref().read(buf).await?;\n```\n\n----------------------------------------\n\nTITLE: Initializing LocalSet for !Send Tasks in Tokio\nDESCRIPTION: Added tokio::task::LocalSet to provide a strategy for spawning !Send tasks in Tokio. This allows running tasks that are not thread-safe within a single-threaded context.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/CHANGELOG.md#2025-04-23_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\ntokio::task::LocalSet\n```\n\n----------------------------------------\n\nTITLE: Exporting Elapsed Time Structure in Tokio\nDESCRIPTION: Exported tokio::time::Elapsed structure, which represents a duration that has elapsed. This can be used for handling timeout scenarios in asynchronous operations.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/CHANGELOG.md#2025-04-23_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\ntokio::time::Elapsed\n```\n\n----------------------------------------\n\nTITLE: Implementing File Descriptor Traits for Tokio File\nDESCRIPTION: Implemented AsRawFd and AsRawHandle traits for tokio::fs::File. This allows obtaining the raw file descriptor or handle from a Tokio file object, enabling interoperability with other APIs.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/CHANGELOG.md#2025-04-23_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\nimpl AsRawFd, AsRawHandle for tokio::fs::File\n```\n\n----------------------------------------\n\nTITLE: Running Common Cargo Commands with All Features in Tokio\nDESCRIPTION: Basic cargo commands that require the --all-features flag when working with Tokio due to its extensive use of feature flags.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo build --all-features\ncargo check --all-features\ncargo test --all-features\n```\n\n----------------------------------------\n\nTITLE: Running Clippy with Specific Rust Version in Tokio\nDESCRIPTION: Command to run Clippy with a specific Rust version (1.77) to ensure consistency with CI checks, covering all tests and features.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo +1.77 clippy --all --tests --all-features\n```\n\n----------------------------------------\n\nTITLE: Building Tokio Documentation with Feature Indicators\nDESCRIPTION: Command to build documentation equivalent to docs.rs, enabling feature indicators and unstable features documentation using environment variables.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nRUSTDOCFLAGS=\"--cfg docsrs --cfg tokio_unstable\" RUSTFLAGS=\"--cfg docsrs --cfg tokio_unstable\" cargo +nightly doc --all-features [--open]\n```\n\n----------------------------------------\n\nTITLE: Building Tokio Documentation with cargo-docs-rs\nDESCRIPTION: Alternative command for building docs.rs-equivalent documentation using the cargo-docs-rs tool, which reads configuration from Cargo.toml.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo install --locked cargo-docs-rs\ncargo +nightly docs-rs [--open]\n```\n\n----------------------------------------\n\nTITLE: Running rustfmt on Tokio Codebase\nDESCRIPTION: Commands to run rustfmt on the Tokio codebase, with variants for Mac/Linux and PowerShell, since standard cargo fmt doesn't work with Tokio.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Mac or Linux\nrustfmt --check --edition 2021 $(git ls-files '*.rs')\n```\n\nLANGUAGE: powershell\nCODE:\n```\n# Powershell\nGet-ChildItem . -Filter \"*.rs\" -Recurse | foreach { rustfmt --check --edition 2021 $_.FullName }\n```\n\n----------------------------------------\n\nTITLE: Running Loom Tests in Tokio\nDESCRIPTION: Command to run Loom tests for concurrency testing in Tokio, with configuration for preemptions, branches, and threading settings.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncd tokio # tokio crate in workspace\nLOOM_MAX_PREEMPTIONS=1 LOOM_MAX_BRANCHES=10000 RUSTFLAGS=\"--cfg loom -C debug_assertions\" \\\n    cargo test --lib --release --features full -- --test-threads=1 --nocapture\n```\n\n----------------------------------------\n\nTITLE: Running Miri Tests in Tokio\nDESCRIPTION: Command to run Miri tests for detecting undefined behavior in Tokio, with specific flags for isolation, provenance, and field retagging.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nMIRIFLAGS=\"-Zmiri-disable-isolation -Zmiri-strict-provenance -Zmiri-retag-fields\" \\\n    cargo +nightly miri test --features full --lib --tests\n```\n\n----------------------------------------\n\nTITLE: Running Spellcheck on Tokio Codebase\nDESCRIPTION: Commands to install and run the spellcheck tool on the Tokio codebase, which helps maintain code quality by checking for spelling errors.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n# First install the spell-check plugin\ncargo install --locked cargo-spellcheck\n\n# Then run the cargo spell check command\ncargo spellcheck check\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Conditional Compilation Flags in Tokio\nDESCRIPTION: Example of running tests with conditional compilation flags, specifically for code marked with 'tokio_unstable' configuration option.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ RUSTFLAGS=\"--cfg tokio_unstable\" cargo test -p tokio --all-features --test rt_metrics\n```\n\n----------------------------------------\n\nTITLE: Running Fuzz Tests with Cargo Fuzz in Tokio\nDESCRIPTION: Instructions for installing cargo-fuzz, listing available fuzz harnesses, and running a fuzz test for the Tokio project.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ cd tokio\n$ cargo fuzz list\nfuzz_linked_list\n\ncargo fuzz run fuzz_linked_list\n```\n\n----------------------------------------\n\nTITLE: Writing Documentation Tests for Tokio API\nDESCRIPTION: Example of a documentation test for the tokio_timer::Timeout type, demonstrating how to use the API and structure the test.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n/// // import the `timeout` function, usually this is done\n/// // with `use tokio::prelude::*`\n/// use tokio::prelude::FutureExt;\n/// use futures::Stream;\n/// use futures::sync::mpsc;\n/// use std::time::Duration;\n///\n/// # fn main() {\n/// let (tx, rx) = mpsc::unbounded();\n/// # tx.unbounded_send(()).unwrap();\n/// # drop(tx);\n///\n/// let process = rx.for_each(|item| {\n///     // do something with `item`\n/// # drop(item);\n/// # Ok(())\n/// });\n///\n/// # tokio::runtime::current_thread::block_on_all(\n/// // Wrap the future with a `Timeout` set to expire in 10 milliseconds.\n/// process.timeout(Duration::from_millis(10))\n/// # ).unwrap();\n/// # }\n```\n\n----------------------------------------\n\nTITLE: Writing Documentation Tests for Tokio::Timer::Timeout\nDESCRIPTION: Example of a documentation test specifically for the Timeout::new function in Tokio, showing how to structure the test for this particular API.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n/// use tokio::timer::Timeout;\n/// use futures::Future;\n/// use futures::sync::oneshot;\n/// use std::time::Duration;\n///\n/// # fn main() {\n/// let (tx, rx) = oneshot::channel();\n/// # tx.send(()).unwrap();\n///\n/// # tokio::runtime::current_thread::block_on_all(\n/// // Wrap the future with a `Timeout` set to expire in 10 milliseconds.\n/// Timeout::new(rx, Duration::from_millis(10))\n/// # ).unwrap();\n/// # }\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks for Tokio Project\nDESCRIPTION: Instructions for running benchmarks using Criterion in the Tokio project, including examples of running all benchmarks, specific benchmark files, or individual benchmarks.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncd benches\n\n# Run all benchmarks.\ncargo bench\n\n# Run all tests in the `benches/fs.rs` file\ncargo bench --bench fs\n\n# Run the `async_read_buf` benchmark in `benches/fs.rs` specifically.\ncargo bench async_read_buf\n\n# After running benches, you can check the statistics under `tokio/target/criterion/`\n```\n\n----------------------------------------\n\nTITLE: Verifying Crate Readiness for Publishing in Tokio\nDESCRIPTION: Command to perform a dry run verification that a crate is ready to be published to crates.io. It checks for any issues that might prevent successful publication.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nbin/publish --dry-run <CRATE NAME> <CRATE VERSION>\n```\n\n----------------------------------------\n\nTITLE: Publishing a Tokio Crate to Crates.io\nDESCRIPTION: Command to release a Tokio crate to crates.io. This will tag the release in Git and prompt for a tag message, which should contain the changelog entry for the release version.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/CONTRIBUTING.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nbin/publish <NAME OF CRATE> <VERSION>\n```\n\n----------------------------------------\n\nTITLE: Running Tokio Feature Tests\nDESCRIPTION: Commands to run tests with different feature flag combinations. The first command tests with all features enabled, while the second tests with only the runtime feature. Test output can be regenerated using the TRYBUILD environment variable.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tests-build/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo test --features full\ncargo test --features rt\n```\n\n----------------------------------------\n\nTITLE: Running Tokio Examples with Cargo\nDESCRIPTION: Command for executing any example in the Tokio examples directory using Cargo. Replace $name with the specific example filename you want to run.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/examples/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo run --example $name\n```\n\n----------------------------------------\n\nTITLE: Generating Target Spec JSON for i686 Linux with Reduced Atomic Width\nDESCRIPTION: Command to generate a modified target specification JSON for i686-unknown-linux-gnu that reduces max-atomic-width from 64 to 32 bits. Uses nightly Rust compiler with unstable options to print target specs, then filters and modifies the output.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/target-specs/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustc +nightly -Z unstable-options --print target-spec-json --target i686-unknown-linux-gnu | grep -v 'is-builtin' | sed 's/\"max-atomic-width\": 64/\"max-atomic-width\": 32/' > target-specs/i686-unknown-linux-gnu.json\n```\n\n----------------------------------------\n\nTITLE: Tokio Release Notes Structure\nDESCRIPTION: Markdown formatted release notes showing version changes, additions, fixes, and modifications to the Tokio runtime. Each version is clearly sectioned with links to relevant pull requests.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# 1.44.2 (April 5th, 2025)\n\nThis release fixes a soundness issue in the broadcast channel. The channel\naccepts values that are `Send` but `!Sync`. Previously, the channel called\n`clone()` on these values without synchronizing. This release fixes the channel\nby synchronizing calls to `.clone()` (Thanks Austin Bonander for finding and\nreporting the issue).\n\n### Fixed\n\n- sync: synchronize `clone()` call in broadcast channel ([#7232])\n\n[#7232]: https://github.com/tokio-rs/tokio/pull/7232\n```\n\n----------------------------------------\n\nTITLE: Example of Unsound AsyncRead Implementation in Buggy Type\nDESCRIPTION: This code demonstrates a unsoundness bug in `io::Take` that was fixed in version 1.16.0. The bug is exposed when an AsyncRead implementation leaks memory and then overwrites the supplied buffer.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl AsyncRead for Buggy {\n    fn poll_read(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>\n    ) -> Poll<Result<()>> {\n      let new_buf = vec![0; 5].leak();\n      *buf = ReadBuf::new(new_buf);\n      buf.put_slice(b\"hello\");\n      Poll::Ready(Ok(()))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dependencies Referenced in Changelog\nDESCRIPTION: Links to pull requests and issues referenced in the changelog, showing connections between changes and their implementations.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/CHANGELOG.md#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n[#2884]: https://github.com/tokio-rs/tokio/pull/2884\n[#2980]: https://github.com/tokio-rs/tokio/pull/2980\n[#2991]: https://github.com/tokio-rs/tokio/pull/2991\n[#3003]: https://github.com/tokio-rs/tokio/pull/3003\n```\n\n----------------------------------------\n\nTITLE: Version Release Headers\nDESCRIPTION: Version numbers and release dates for different Tokio releases\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/CHANGELOG.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n# 0.3.0 (October 15, 2020)\n\n# 0.2.22 (July 21, 2020)\n\n# 0.2.21 (May 13, 2020)\n```\n\n----------------------------------------\n\nTITLE: API Changes Documentation\nDESCRIPTION: List of added features and API changes in release notes format\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio/CHANGELOG.md#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n### Added\n\n- io: `copy_buf()` ([#2884]).\n- io: `AsyncReadExt::read_buf()`, `AsyncReadExt::write_buf()` for working with\n  `Buf`/`BufMut` ([#3003]).\n- rt: `Runtime::spawn_blocking()` ([#2980]).\n- sync: `watch::Sender::is_closed()` ([#2991]).\n```\n\n----------------------------------------\n\nTITLE: Using #[tokio::main] with Clippy Suppression\nDESCRIPTION: The #[tokio::main] macro now suppresses the clippy::needless_return lint, making it more compatible with code quality tools without generating unnecessary warnings.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio-macros/CHANGELOG.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main]\nasync fn main() {\n    // Your async code here\n    // The macro now suppresses clippy::needless_return\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Unhandled Panic Behavior with Tokio Macros\nDESCRIPTION: Configuration for handling panics in #[tokio::main] and #[tokio::test] macros, allowing users to specify custom behavior when unhandled panics occur in async code.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio-macros/CHANGELOG.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main(unhandled_panic = \"abort\")]\nasync fn main() {\n    // This will abort the process if a panic occurs\n}\n\n#[tokio::test(unhandled_panic = \"panic\")]\nasync fn test_something() {\n    // This will use the default panic behavior\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Crate Name with Tokio Macros\nDESCRIPTION: Support for specifying a custom crate name when using #[tokio::main] and #[tokio::test] macros, allowing for more flexibility when the tokio crate is renamed in imports.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio-macros/CHANGELOG.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// When tokio is renamed in your imports\nuse tokio_renamed as my_tokio;\n\n#[my_tokio::main(crate = \"my_tokio\")]\nasync fn main() {\n    // Your async code here\n}\n\n#[my_tokio::test(crate = \"my_tokio\")]\nasync fn test_something() {\n    // Your test code here\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring the Tokio Runtime with Start Paused Option\nDESCRIPTION: The 'start_paused' option for Tokio macros allows starting the runtime in a paused state, which is particularly useful for testing time-dependent code when combined with time mocking features.\nSOURCE: https://github.com/tokio-rs/tokio/blob/master/tokio-macros/CHANGELOG.md#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[tokio::main(start_paused = true)]\nasync fn main() {\n    // Runtime starts paused, useful for time-dependent tests\n}\n\n#[tokio::test(start_paused = true)]\nasync fn test_with_time() {\n    // Time-dependent test code here\n}\n```"
  }
]