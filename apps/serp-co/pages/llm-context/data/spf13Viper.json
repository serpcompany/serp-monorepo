[
  {
    "owner": "spf13",
    "repo": "viper",
    "content": "TITLE: Reading Unencrypted Remote Configuration from NATS (Go)\nDESCRIPTION: Configures Viper to read configuration data published on a NATS subject. `AddRemoteProvider` specifies 'nats', the NATS server URL(s), and the subject name (`myapp.config`) where the configuration is expected. `SetConfigType` indicates the format (e.g., 'json'), and `ReadRemoteConfig` attempts to fetch the configuration from the NATS subject.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_25\n\nLANGUAGE: Go\nCODE:\n```\nviper.AddRemoteProvider(\"nats\", \"nats://127.0.0.1:4222\", \"myapp.config\")\nviper.SetConfigType(\"json\")\nerr := viper.ReadRemoteConfig()\n```\n\n----------------------------------------\n\nTITLE: Reading Unencrypted Remote Configuration from Firestore (Go)\nDESCRIPTION: Configures Viper to read configuration data from Google Cloud Firestore. `AddRemoteProvider` is used with 'firestore', the Google Cloud project ID, and the path to the Firestore document (collection/document). `SetConfigType` specifies the format of the data stored in Firestore (e.g., 'json'). `ReadRemoteConfig` retrieves the configuration.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_24\n\nLANGUAGE: Go\nCODE:\n```\nviper.AddRemoteProvider(\"firestore\", \"google-cloud-project-id\", \"collection/document\")\nviper.SetConfigType(\"json\") // Config's format: \"json\", \"toml\", \"yaml\", \"yml\"\nerr := viper.ReadRemoteConfig()\n```\n\n----------------------------------------\n\nTITLE: Watching Changes in etcd with Viper in Go\nDESCRIPTION: Demonstrates how to set up a remote configuration provider with etcd, read the initial configuration, and continuously watch for changes in the background using goroutines. This allows applications to have dynamic configuration that updates at runtime.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_27\n\nLANGUAGE: go\nCODE:\n```\n// alternatively, you can create a new viper instance.\nvar runtime_viper = viper.New()\n\nruntime_viper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\", \"/config/hugo.yml\")\nruntime_viper.SetConfigType(\"yaml\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\n\n// read from remote config the first time.\nerr := runtime_viper.ReadRemoteConfig()\n\n// unmarshal config\nruntime_viper.Unmarshal(&runtime_conf)\n\n// open a goroutine to watch remote changes forever\ngo func(){\n\tfor {\n\t\ttime.Sleep(time.Second * 5) // delay after each request\n\n\t\t// currently, only tested with etcd support\n\t\terr := runtime_viper.WatchRemoteConfig()\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"unable to read remote config: %v\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// unmarshal new config into our runtime config struct. you can also use channel\n\t\t// to implement a signal to notify the system of the changes\n\t\truntime_viper.Unmarshal(&runtime_conf)\n\t}\n}()\n```\n\n----------------------------------------\n\nTITLE: Example JSON Configuration for Nested Key Access in Viper\nDESCRIPTION: Example JSON configuration format demonstrating a nested structure with host information and datastore configurations. This structure is used to illustrate how Viper can access deeply nested keys.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_29\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"host\": {\n        \"address\": \"localhost\",\n        \"port\": 5799\n    },\n    \"datastore\": {\n        \"metric\": {\n            \"host\": \"127.0.0.1\",\n            \"port\": 3099\n        },\n        \"warehouse\": {\n            \"host\": \"198.0.0.1\",\n            \"port\": 2112\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON Configuration for Consul (JSON)\nDESCRIPTION: Shows an example JSON structure containing configuration key-value pairs. This structure is intended to be stored as the value associated with a key in the Consul Key/Value store when using Viper's Consul remote provider.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_22\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"port\": 8080,\n    \"hostname\": \"myhostname.com\"\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Unencrypted Remote Configuration from Consul (Go)\nDESCRIPTION: Configures Viper to read JSON configuration data from a Consul Key/Value store. It uses `AddRemoteProvider` specifying 'consul', the Consul agent address, and the key (`MY_CONSUL_KEY`) holding the JSON configuration. `SetConfigType` must be explicitly set to 'json'. `ReadRemoteConfig` fetches the data, and `viper.Get` retrieves individual values.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_23\n\nLANGUAGE: Go\nCODE:\n```\nviper.AddRemoteProvider(\"consul\", \"localhost:8500\", \"MY_CONSUL_KEY\")\nviper.SetConfigType(\"json\") // Need to explicitly set this to json\nerr := viper.ReadRemoteConfig()\n\nfmt.Println(viper.Get(\"port\")) // 8080\nfmt.Println(viper.Get(\"hostname\")) // myhostname.com\n```\n\n----------------------------------------\n\nTITLE: Reading Encrypted Remote Configuration from etcd (Go)\nDESCRIPTION: Demonstrates reading encrypted configuration data from etcd using Viper and the 'crypt' library integration. `AddSecureRemoteProvider` is used, specifying the provider ('etcd'), endpoint, key path, and the path to the GPG keyring file (`/etc/secrets/mykeyring.gpg`) needed for decryption. `SetConfigType` specifies the format of the *decrypted* data. `ReadRemoteConfig` fetches and decrypts the configuration.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_26\n\nLANGUAGE: Go\nCODE:\n```\nviper.AddSecureRemoteProvider(\"etcd\",\"http://127.0.0.1:4001\",\"/config/hugo.json\",\"/etc/secrets/mykeyring.gpg\")\nviper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes,  supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\nerr := viper.ReadRemoteConfig()\n```\n\n----------------------------------------\n\nTITLE: Reading Unencrypted Remote Configuration from etcd (Go)\nDESCRIPTION: Configures Viper to read configuration data from an etcd server. It uses `AddRemoteProvider` specifying the provider type ('etcd'), endpoint URL, and the key path in etcd where the configuration is stored. `SetConfigType` is required as the data is streamed, specifying the format (e.g., 'json'). Finally, `ReadRemoteConfig` attempts to fetch and load the configuration.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_20\n\nLANGUAGE: Go\nCODE:\n```\nviper.AddRemoteProvider(\"etcd\", \"http://127.0.0.1:4001\",\"/config/hugo.json\")\nviper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\nerr := viper.ReadRemoteConfig()\n```\n\n----------------------------------------\n\nTITLE: Reading Unencrypted Remote Configuration from etcd3 (Go)\nDESCRIPTION: Configures Viper to read configuration data from an etcd3 server. Similar to the etcd example, it uses `AddRemoteProvider` with 'etcd3' as the provider type, endpoint URL, and key path. `SetConfigType` must be set to indicate the format of the configuration data, and `ReadRemoteConfig` initiates the retrieval.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_21\n\nLANGUAGE: Go\nCODE:\n```\nviper.AddRemoteProvider(\"etcd3\", \"http://127.0.0.1:4001\",\"/config/hugo.json\")\nviper.SetConfigType(\"json\") // because there is no file extension in a stream of bytes, supported extensions are \"json\", \"toml\", \"yaml\", \"yml\", \"properties\", \"props\", \"prop\", \"env\", \"dotenv\"\nerr := viper.ReadRemoteConfig()\n```\n\n----------------------------------------\n\nTITLE: Integrating Standard Go Flags with Viper via Pflag (Go)\nDESCRIPTION: Demonstrates how to use flags defined with the standard Go 'flag' package alongside Viper. It leverages the 'pflag' library's `AddGoFlagSet` function to import the standard library flags into the `pflag.CommandLine` FlagSet. After parsing with `pflag.Parse()`, the combined FlagSet is bound to Viper using `BindPFlags`, allowing retrieval of standard flag values through Viper.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_12\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"flag\"\n\t\"github.com/spf13/pflag\"\n)\n\nfunc main() {\n\n\t// using standard library \"flag\" package\n\tflag.Int(\"flagname\", 1234, \"help message for flagname\")\n\n\tpflag.CommandLine.AddGoFlagSet(flag.CommandLine)\n\tpflag.Parse()\n\tviper.BindPFlags(pflag.CommandLine)\n\n\ti := viper.GetInt(\"flagname\") // retrieve value from viper\n\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Viper with Go Modules\nDESCRIPTION: This snippet shows the command to install the Viper library using Go modules. It is required to use Viper in your Go project.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngo get github.com/spf13/viper\n```\n\n----------------------------------------\n\nTITLE: Binding a Pflag FlagSet in Viper (Go)\nDESCRIPTION: Shows how to bind an entire set of flags (pflag.FlagSet) to Viper using `BindPFlags`. This example defines a pflag, parses the command-line arguments, and then binds the default `pflag.CommandLine` set to Viper. Configuration values corresponding to the flags can then be retrieved directly from Viper using methods like `GetInt`.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_11\n\nLANGUAGE: Go\nCODE:\n```\npflag.Int(\"flagname\", 1234, \"help message for flagname\")\n\npflag.Parse()\nviper.BindPFlags(pflag.CommandLine)\n\ni := viper.GetInt(\"flagname\") // retrieve values from viper instead of pflag\n```\n\n----------------------------------------\n\nTITLE: Importing External Codecs for HCL, Java Properties, and INI in Viper (Go)\nDESCRIPTION: Provides example code for importing HCL, Java properties, and INI codec packages from the external github.com/go-viper/encoding module, registering multiple aliases for each codec with a CodecRegistry, and configuring Viper to utilize these codecs. This accommodates the breaking change where these formats were removed from Viper core.\nSOURCE: https://github.com/spf13/viper/blob/master/UPGRADE.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\nimport (\\n    \"github.com/go-viper/encoding/hcl\"\\n    \"github.com/go-viper/encoding/javaproperties\"\\n    \"github.com/go-viper/encoding/ini\"\\n)\\n\\ncodecRegistry := viper.NewCodecRegistry()\\n\\n{\\n    codec := hcl.Codec{}\\n\\n    codecRegistry.RegisterCodec(\"hcl\", codec)\\n    codecRegistry.RegisterCodec(\"tfvars\", codec)\\n\\n}\\n\\n{\\n    codec := &javaproperties.Codec{}\\n\\n    codecRegistry.RegisterCodec(\"properties\", codec)\\n    codecRegistry.RegisterCodec(\"props\", codec)\\n    codecRegistry.RegisterCodec(\"prop\", codec)\\n}\\n\\ncodecRegistry.RegisterCodec(\"ini\", ini.Codec{})\\n\\nv := viper.NewWithOptions(\\n    viper.WithCodecRegistry(codecRegistry),\\n)\n```\n\n----------------------------------------\n\nTITLE: Enabling Remote Key/Value Store Support in Viper (Go)\nDESCRIPTION: Demonstrates the required blank import statement to enable Viper's remote configuration provider capabilities. Importing `github.com/spf13/viper/remote` makes the remote provider functions available.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_17\n\nLANGUAGE: Go\nCODE:\n```\nimport _ \"github.com/spf13/viper/remote\"\n```\n\n----------------------------------------\n\nTITLE: Defining Encoder, Decoder, and Codec Interfaces for Custom Encoding in Viper (Go)\nDESCRIPTION: Introduces Encoder and Decoder interfaces that define methods for encoding map[string]any data to bytes and decoding bytes back into maps, respectively. The Codec interface composes both. These interfaces allow users to provide custom configuration format serialization and parsing beyond the defaults, enhancing extensibility.\nSOURCE: https://github.com/spf13/viper/blob/master/UPGRADE.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\n// Encoder encodes Viper's internal data structures into a byte representation.\\n// It's primarily used for encoding a map[string]any into a file format.\\ntype Encoder interface {\\n\tEncode(v map[string]any) ([]byte, error)\\n}\\n\\n// Decoder decodes the contents of a byte slice into Viper's internal data structures.\\n// It's primarily used for decoding contents of a file into a map[string]any.\\ntype Decoder interface {\\n\tDecode(b []byte, v map[string]any) error\\n}\\n\\n// Codec combines [Encoder] and [Decoder] interfaces.\\ntype Codec interface {\\n\tEncoder\\n\tDecoder\\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Individual Pflags in Viper (Go)\nDESCRIPTION: Illustrates how to bind a single command-line flag defined using the 'pflag' library (specifically from Cobra) to a Viper configuration key. This allows Viper to retrieve the flag's value using its key ('port' in this case). The binding uses the `BindPFlag` method, associating the Viper key with the flag retrieved via `Flags().Lookup()`. Values are retrieved when accessed, not when bound.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_10\n\nLANGUAGE: Go\nCODE:\n```\nserverCmd.Flags().Int(\"port\", 1138, \"Port to run Application server on\")\nviper.BindPFlag(\"port\", serverCmd.Flags().Lookup(\"port\"))\n```\n\n----------------------------------------\n\nTITLE: Establishing Default Configuration Values in Viper\nDESCRIPTION: This Go snippet demonstrates how to set default values for configuration keys in Viper using `SetDefault`. These values are used if the keys are not found in other configuration sources.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nviper.SetDefault(\"ContentDir\", \"content\")\nviper.SetDefault(\"LayoutDir\", \"layouts\")\nviper.SetDefault(\"Taxonomies\", map[string]string{\"tag\": \"tags\", \"category\": \"categories\"})\n```\n\n----------------------------------------\n\nTITLE: Setting Explicit Configuration Values (Overrides) in Viper\nDESCRIPTION: This Go snippet shows how to explicitly set or override configuration values programmatically using the `viper.Set()` function. This method has the highest precedence among all configuration sources.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_7\n\nLANGUAGE: Go\nCODE:\n```\nviper.Set(\"Verbose\", true)\nviper.Set(\"LogFile\", LogFile)\nviper.Set(\"host.port\", 5899)   // set subset\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom File Finder Interface in Go for Viper\nDESCRIPTION: Defines the Finder interface for customizing file and directory searches within an afero.Fs filesystem. It requires implementing a Find method that returns a slice of file path strings and an error. This interface enables users to override Viper's default config file discovery mechanism with tailored logic.\nSOURCE: https://github.com/spf13/viper/blob/master/UPGRADE.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\n// Finder looks for files and directories in an [afero.Fs] filesystem.\\ntype Finder interface {\\n\tFind(fsys afero.Fs) ([]string, error)\\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Codec and Creating Viper Instance with Codec Registry in Go\nDESCRIPTION: Demonstrates how to create a new CodecRegistry, register a custom Codec implementation named MyCodec with a unique format identifier, and instantiate Viper using NewWithOptions to use this custom codec registry. This allows users to extend Viper's encoding and decoding capabilities with additional or proprietary formats.\nSOURCE: https://github.com/spf13/viper/blob/master/UPGRADE.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\ncodecRegistry := viper.NewCodecRegistry()\\n\\ncodecRegistry.RegisterCodec(\"myformat\", &MyCodec{})\\n\\nv := viper.NewWithOptions(\\n    viper.WithCodecRegistry(codecRegistry),\\n)\n```\n\n----------------------------------------\n\nTITLE: Example of Custom Decoder Config Using Updated Mapstructure Fork in Go\nDESCRIPTION: Illustrates how to unmarshal configuration data into an appConfig struct using Viper with a custom DecoderConfig from the Viper-maintained mapstructure fork. Shows setting the TagName to \"yaml\" to align with YAML struct tags. Import paths must be updated to use the new forked package.\nSOURCE: https://github.com/spf13/viper/blob/master/UPGRADE.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\nerr := viper.Unmarshal(&appConfig, func(config *mapstructure.DecoderConfig) {\\n\tconfig.TagName = \"yaml\"\\n})\n```\n\n----------------------------------------\n\nTITLE: Reading Configuration File with Viper\nDESCRIPTION: This Go snippet shows how to configure Viper to search for and read a configuration file from multiple specified paths. It sets the file name (without extension), the type, adds search paths, and then attempts to read the configuration.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nviper.SetConfigName(\"config\") // name of config file (without extension)\nviper.SetConfigType(\"yaml\") // REQUIRED if the config file does not have the extension in the name\nviper.AddConfigPath(\"/etc/appname/\")   // path to look for the config file in\nviper.AddConfigPath(\"$HOME/.appname\")  // call multiple times to add many search paths\nvaiper.AddConfigPath(\".\")               // optionally look for config in the working directory\nerr := viper.ReadInConfig() // Find and read the config file\nif err != nil { // Handle errors reading the config file\n\tpanic(fmt.Errorf(\"fatal error config file: %w\", err))\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Finder Implementation with Viper in Go\nDESCRIPTION: Shows how to instantiate a new Viper instance using NewWithOptions and supply a user-defined Finder implementation via WithFinder. This snippet demonstrates how Viper's file lookup is replaced with the custom Finder named MyFinder, thus enabling customized config file discovery.\nSOURCE: https://github.com/spf13/viper/blob/master/UPGRADE.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nv := viper.NewWithOptions(\\n    viper.WithFinder(&MyFinder{}),\\n)\n```\n\n----------------------------------------\n\nTITLE: Replacing Legacy Mapstructure Import with Viper Fork in Go\nDESCRIPTION: Shows the required import replacement due to the archival of the original mapstructure package. Users must update their imports from github.com/mitchellh/mapstructure to github.com/go-viper/mapstructure/v2 to maintain compatibility with the Viper project's maintained fork.\nSOURCE: https://github.com/spf13/viper/blob/master/UPGRADE.md#_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\n- import \"github.com/mitchellh/mapstructure\"\\n+ import \"github.com/go-viper/mapstructure/v2\"\n```\n\n----------------------------------------\n\nTITLE: Running Linters Viper Shell\nDESCRIPTION: Executes various code analysis tools (linters) to check for coding standard violations, potential bugs, and style inconsistencies. Running linters helps maintain code quality and consistency across the project. The `-j` option can be passed to run them in parallel.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_39\n\nLANGUAGE: Shell\nCODE:\n```\nmake lint\n```\n\n----------------------------------------\n\nTITLE: Setting Go Modules for Viper Dependency Resolution\nDESCRIPTION: Provides the shell command to explicitly enable Go Modules. This is the recommended approach for managing Viper's dependencies, preventing 'cannot find package' errors often encountered in GOPATH mode, particularly with updated dependency versions. This command should be run in a shell environment.\nSOURCE: https://github.com/spf13/viper/blob/master/TROUBLESHOOTING.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nexport GO111MODULE=on\n```\n\n----------------------------------------\n\nTITLE: Handling ConfigFileNotFoundError in Viper\nDESCRIPTION: This Go snippet demonstrates how to specifically check for and handle the `viper.ConfigFileNotFoundError` when attempting to read a configuration file, allowing the application to potentially continue if the file is optional.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nif err := viper.ReadInConfig(); err != nil {\n\tif _, ok := err.(viper.ConfigFileNotFoundError); ok {\n\t\t// Config file not found; ignore error if desired\n\t} else {\n\t\t// Config file was found but another error was produced\n\t}\n}\n\n// Config file found and successfully parsed\n```\n\n----------------------------------------\n\nTITLE: Accessing Configuration Values in Viper with Go\nDESCRIPTION: Shows how to retrieve values from Viper using type-specific getter methods. The example demonstrates checking if verbose mode is enabled and getting a logfile path. Viper methods are case-insensitive when accessing keys.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_28\n\nLANGUAGE: go\nCODE:\n```\nviper.GetString(\"logfile\") // case-insensitive Setting & Getting\nif viper.GetBool(\"verbose\") {\n\tfmt.Println(\"verbose enabled\")\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Viper Configuration to Files\nDESCRIPTION: This Go snippet illustrates different methods for writing the current state of the Viper configuration back to files. It includes options for writing to a predefined path (`WriteConfig`, `SafeWriteConfig`) and writing to an arbitrary path (`WriteConfigAs`, `SafeWriteConfigAs`), with `Safe` variants preventing overwrites.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\nviper.WriteConfig() // writes current config to predefined path set by 'viper.AddConfigPath()' and 'viper.SetConfigName'\nviper.SafeWriteConfig()\nviper.WriteConfigAs(\"/path/to/my/.config\")\nviper.SafeWriteConfigAs(\"/path/to/my/.config\") // will error since it has already been written\nviper.SafeWriteConfigAs(\"/path/to/my/.other_config\")\n```\n\n----------------------------------------\n\nTITLE: Watching for Configuration File Changes with Viper\nDESCRIPTION: This Go snippet shows how to enable live watching of the configuration file for changes. `OnConfigChange` registers a callback function to be executed whenever the watched file is modified, and `WatchConfig` starts the watching process.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_5\n\nLANGUAGE: Go\nCODE:\n```\nviper.OnConfigChange(func(e fsnotify.Event) {\n\tfmt.Println(\"Config file changed:\", e.Name)\n})\nviper.WatchConfig()\n```\n\n----------------------------------------\n\nTITLE: Reading Configuration from an io.Reader in Viper\nDESCRIPTION: This Go snippet demonstrates how to load configuration data directly from an `io.Reader`, such as a byte buffer containing YAML data. It requires setting the configuration type before reading from the reader.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\nviper.SetConfigType(\"yaml\") // or viper.SetConfigType(\"YAML\")\n\n// any approach to require this configuration into your program.\nvar yamlExample = []byte(`\nHacker: true\nname: steve\nhobbies:\n- skateboarding\n- snowboarding\n- go\nclothing:\n  jacket: leather\n  trousers: denim\nage: 35\neyes : brown\nbeard: true\n`)\n\nviper.ReadConfig(bytes.NewBuffer(yamlExample))\n\nviper.Get(\"name\") // this would be \"steve\"\n```\n\n----------------------------------------\n\nTITLE: Registering and Using Aliases in Viper\nDESCRIPTION: This Go snippet demonstrates how to create and use aliases for configuration keys. `RegisterAlias` links a new key name ('loud') to an existing one ('Verbose'), allowing the same value to be accessed using either name.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\nviper.RegisterAlias(\"loud\", \"Verbose\")\n\nviper.Set(\"verbose\", true) // same result as next line\nviper.Set(\"loud\", true)   // same result as prior line\n\nviper.GetBool(\"loud\") // true\nvaiper.GetBool(\"verbose\") // true\n```\n\n----------------------------------------\n\nTITLE: Implementing Viper FlagValue Interface (Go)\nDESCRIPTION: Provides a minimal example of implementing the `viper.FlagValue` interface. This interface allows integration of custom flag systems with Viper by defining methods to check if a flag has changed, get its name, string value, and type. This is useful when not using the 'pflag' library.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_13\n\nLANGUAGE: Go\nCODE:\n```\ntype myFlag struct {}\nfunc (f myFlag) HasChanged() bool { return false }\nfunc (f myFlag) Name() string { return \"my-flag-name\" }\nfunc (f myFlag) ValueString() string { return \"my-flag-value\" }\nfunc (f myFlag) ValueType() string { return \"string\" }\n```\n\n----------------------------------------\n\nTITLE: Implementing Viper FlagValueSet Interface (Go)\nDESCRIPTION: Provides a minimal example of implementing the `viper.FlagValueSet` interface. This interface allows binding a collection of custom flags (each implementing `FlagValue`) to Viper. It requires implementing the `VisitAll` method which iterates over each flag in the set.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_15\n\nLANGUAGE: Go\nCODE:\n```\ntype myFlagSet struct {\n\tflags []myFlag\n}\n\nfunc (f myFlagSet) VisitAll(fn func(FlagValue)) {\n\tfor _, flag := range flags {\n\t\tfn(flag)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Configuration in K/V Store using Crypt (Bash)\nDESCRIPTION: Example command using the 'crypt' tool to set a configuration value in a Key/Value store (etcd by default). It takes a configuration file (`/Users/hugo/settings/config.json`) and stores its content as plaintext under the specified path (`/config/hugo.json`) in the K/V store.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_18\n\nLANGUAGE: Bash\nCODE:\n```\n$ go get github.com/sagikazarmark/crypt/bin/crypt\n$ crypt set -plaintext /config/hugo.json /Users/hugo/settings/config.json\n```\n\n----------------------------------------\n\nTITLE: Getting Configuration from K/V Store using Crypt (Bash)\nDESCRIPTION: Example command using the 'crypt' tool to retrieve and display a configuration value stored as plaintext under a specific path (`/config/hugo.json`) in the Key/Value store (etcd by default).\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_19\n\nLANGUAGE: Bash\nCODE:\n```\n$ crypt get -plaintext /config/hugo.json\n```\n\n----------------------------------------\n\nTITLE: Accessing Nested Keys and Array Elements in JSON with Viper\nDESCRIPTION: Demonstrates how to access nested configuration keys using dot-delimited paths and array elements using numeric indices. This example uses a JSON configuration with host information and array elements.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_30\n\nLANGUAGE: jsonc\nCODE:\n```\n{\n    \"host\": {\n        \"address\": \"localhost\",\n        \"ports\": [\n            5799,\n            6029\n        ]\n    },\n    \"datastore\": {\n        \"metric\": {\n            \"host\": \"127.0.0.1\",\n            \"port\": 3099\n        },\n        \"warehouse\": {\n            \"host\": \"198.0.0.1\",\n            \"port\": 2112\n        }\n    }\n}\n\nGetInt(\"host.ports.1\") // returns 6029\n```\n\n----------------------------------------\n\nTITLE: Key Path Precedence in Viper with Conflicting Keys\nDESCRIPTION: Illustrates how Viper handles key precedence when there are exact matches for both delimited paths and nested objects with the same effective path. In this case, the exact key match takes precedence.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_31\n\nLANGUAGE: jsonc\nCODE:\n```\n{\n    \"datastore.metric.host\": \"0.0.0.0\",\n    \"host\": {\n        \"address\": \"localhost\",\n        \"port\": 5799\n    },\n    \"datastore\": {\n        \"metric\": {\n            \"host\": \"127.0.0.1\",\n            \"port\": 3099\n        },\n        \"warehouse\": {\n            \"host\": \"198.0.0.1\",\n            \"port\": 2112\n        }\n    }\n}\n\nGetString(\"datastore.metric.host\") // returns \"0.0.0.0\"\n```\n\n----------------------------------------\n\nTITLE: Extracting a Configuration Sub-tree in Viper with Go\nDESCRIPTION: Shows how to extract a subset of configuration using Viper's Sub method, which enables modular configuration and component reuse. The example creates independent cache configurations from a YAML definition.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_32\n\nLANGUAGE: yaml\nCODE:\n```\ncache:\n  cache1:\n    max-items: 100\n    item-size: 64\n  cache2:\n    max-items: 200\n    item-size: 80\n```\n\nLANGUAGE: go\nCODE:\n```\ncache1Config := viper.Sub(\"cache.cache1\")\nif cache1Config == nil { // Sub returns nil if the key cannot be found\n\tpanic(\"cache configuration not found\")\n}\n\ncache1 := NewCache(cache1Config)\n```\n\nLANGUAGE: go\nCODE:\n```\nfunc NewCache(v *Viper) *Cache {\n\treturn &Cache{\n\t\tMaxItems: v.GetInt(\"max-items\"),\n\t\tItemSize: v.GetInt(\"item-size\"),\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Unmarshaling Configuration to Struct in Viper with Go\nDESCRIPTION: Demonstrates how to unmarshal configuration values directly into Go structs. The example shows how to handle custom field mapping with mapstructure tags and error handling during unmarshaling.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_33\n\nLANGUAGE: go\nCODE:\n```\ntype config struct {\n\tPort int\n\tName string\n\tPathMap string `mapstructure:\"path_map\"`\n}\n\nvar C config\n\nerr := viper.Unmarshal(&C)\nif err != nil {\n\tt.Fatalf(\"unable to decode into struct, %v\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Unmarshaling Configuration with Custom Delimiters in Viper\nDESCRIPTION: Shows how to handle configurations where the keys themselves contain dots by changing the key delimiter. This is useful when working with Kubernetes-style configurations or other systems with complex key naming.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_34\n\nLANGUAGE: go\nCODE:\n```\nv := viper.NewWithOptions(viper.KeyDelimiter(\"::\")\n\nv.SetDefault(\"chart::values\", map[string]any{\n\t\"ingress\": map[string]any{\n\t\t\"annotations\": map[string]any{\n\t\t\t\"traefik.frontend.rule.type\":                 \"PathPrefix\",\n\t\t\t\"traefik.ingress.kubernetes.io/ssl-redirect\": \"true\",\n\t\t},\n\t},\n})\n\ntype config struct {\n\tChart struct{\n\t\tValues map[string]any\n\t}\n}\n\nvar C config\n\nv.Unmarshal(&C)\n```\n\n----------------------------------------\n\nTITLE: Unmarshaling into Embedded Structs with Viper\nDESCRIPTION: Demonstrates how to unmarshal configuration into structures with embedded structs using the mapstructure squash tag. This approach is useful for modular configurations that need to be organized across multiple packages.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_35\n\nLANGUAGE: go\nCODE:\n```\n/*\nExample config:\n\nmodule:\n    enabled: true\n    token: 89h3f98hbwf987h3f98wenf89ehf\n*/\ntype config struct {\n\tModule struct {\n\t\tEnabled bool\n\n\t\tmoduleConfig `mapstructure:\",squash\"`\n\t}\n}\n\n// moduleConfig could be in a module specific package\ntype moduleConfig struct {\n\tToken string\n}\n\nvar C config\n\nerr := viper.Unmarshal(&C)\nif err != nil {\n\tt.Fatalf(\"unable to decode into struct, %v\", err)\n}\n```\n\n----------------------------------------\n\nTITLE: Marshalling Viper Configuration to YAML String in Go\nDESCRIPTION: Shows how to marshal all configuration settings held in Viper into a YAML string format. This is useful for debugging, logging, or transferring configuration between systems without writing to files.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_36\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\tyaml \"gopkg.in/yaml.v2\"\n\t// ...\n)\n\nfunc yamlStringSettings() string {\n\tc := viper.AllSettings()\n\tbs, err := yaml.Marshal(c)\n\tif err != nil {\n\t\tlog.Fatalf(\"unable to marshal config to YAML: %v\", err)\n\t}\n\treturn string(bs)\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Code Viper Shell\nDESCRIPTION: Automatically formats the project's source code according to the predefined style guidelines. This command helps fix many common linter violations by standardizing code appearance. It is recommended to run this before submitting changes.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_40\n\nLANGUAGE: Shell\nCODE:\n```\nmake fmt\n```\n\n----------------------------------------\n\nTITLE: Working with Multiple Viper Instances in Go\nDESCRIPTION: Demonstrates how to create and use multiple Viper instances with different configurations. This is the recommended approach over using the global singleton instance, as it provides better testability and isolation.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_37\n\nLANGUAGE: go\nCODE:\n```\nx := viper.New()\ny := viper.New()\n\nx.SetDefault(\"ContentDir\", \"content\")\ny.SetDefault(\"ContentDir\", \"foobar\")\n\n//...\n```\n\n----------------------------------------\n\nTITLE: Running Tests Viper Shell\nDESCRIPTION: Executes the project's automated test suite using the `make` command. This command verifies that the code functions correctly and catches potential regressions. It is a crucial step before submitting changes.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_38\n\nLANGUAGE: Shell\nCODE:\n```\nmake test\n```\n\n----------------------------------------\n\nTITLE: Binding Environment Variables in Viper (Go)\nDESCRIPTION: Demonstrates how to configure Viper to read configuration values from environment variables. It sets a prefix ('spf') which Viper automatically uppercases and uses when looking for environment variables. It then binds the Viper key 'id' to the environment variable 'SPF_ID'. An example environment variable setting (usually done outside the application) and retrieving the value using viper.Get() are shown.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\nSetEnvPrefix(\"spf\") // will be uppercased automatically\nBindEnv(\"id\")\n\nos.Setenv(\"SPF_ID\", \"13\") // typically done outside of the app\n\nid := Get(\"id\") // 13\n```\n\n----------------------------------------\n\nTITLE: Binding Custom FlagValue Implementation (Go)\nDESCRIPTION: Shows how to bind a custom flag implementation (that adheres to the `viper.FlagValue` interface) to a Viper configuration key using the `viper.BindFlagValue` method.\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_14\n\nLANGUAGE: Go\nCODE:\n```\nviper.BindFlagValue(\"my-flag-name\", myFlag{})\n```\n\n----------------------------------------\n\nTITLE: Binding Custom FlagValueSet Implementation (Go)\nDESCRIPTION: Shows how to bind a custom flag set implementation (that adheres to the `viper.FlagValueSet` interface) to Viper using the `viper.BindFlagValues` method. This binds all flags within the custom set under a specified prefix or namespace ('my-flags' in this example).\nSOURCE: https://github.com/spf13/viper/blob/master/README.md#_snippet_16\n\nLANGUAGE: Go\nCODE:\n```\nfSet := myFlagSet{\n\tflags: []myFlag{myFlag{}, myFlag{}},\n}\nviper.BindFlagValues(\"my-flags\", fSet)\n```"
  }
]