[
  {
    "owner": "edmundhung",
    "repo": "conform",
    "content": "TITLE: Implementing a Login Form with Conform, React, and Zod\nDESCRIPTION: This snippet demonstrates how to create a login form using Conform with React and Zod. It includes both server-side action handling and client-side form rendering. The example showcases schema definition, form submission parsing, error handling, and form state management.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/overview.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport { z } from 'zod';\nimport { login } from './your-auth-library';\nimport { useActionResult, redirect } from './your-server-framework';\n\n// Define a schema for your form\nconst schema = z.object({\n  username: z.string(),\n  password: z.string(),\n});\n\n// Optional: Server action handler\nexport async function action({ request }) {\n  const formData = await request.formData();\n  const submission = parseWithZod(formData, { schema });\n\n  // Send the submission back to the client if the status is not successful\n  if (submission.status !== 'success') {\n    return submission.reply();\n  }\n\n  const session = await login(submission.value);\n\n  // Send the submission with addional error message if login fails\n  if (!session) {\n    return submission.reply({\n      formErrors: ['Incorrect username or password'],\n    });\n  }\n\n  return redirect('/dashboard');\n}\n\n// Client form component\nexport default function LoginForm() {\n  // Grab the last submission result if you have defined a server action handler\n  // This could be `useActionData()` or `useFormState()` depending on the framework\n  const lastResult = useActionResult();\n  const [form, fields] = useForm({\n    // Configure when each field should be validated\n    shouldValidate: 'onBlur',\n    // Optional: Required only if you're validating on the server\n    lastResult,\n    // Optional: Client validation. Fallback to server validation if not provided\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n\n  return (\n    <form method=\"post\" id={form.id} onSubmit={form.onSubmit}>\n      <div>{form.errors}</div>\n      <div>\n        <label>Username</label>\n        <input type=\"text\" name={fields.username.name} />\n        <div>{fields.username.errors}</div>\n      </div>\n      <div>\n        <label>Password</label>\n        <input type=\"password\" name={fields.password.name} />\n        <div>{fields.password.errors}</div>\n      </div>\n      <button>Login</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Login Form with Conform and Remix\nDESCRIPTION: A complete example of a login form implementation using Conform with Remix, featuring email and password validation using Zod schema. The form includes client-side validation, server-side processing, and proper type handling with TypeScript.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/integration/remix.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getFormProps, getInputProps, useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport type { ActionArgs } from '@remix-run/node';\nimport { json, redirect } from '@remix-run/node';\nimport { Form, useActionData } from '@remix-run/react';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  email: z.string().email(),\n  password: z.string(),\n  remember: z.boolean().optional(),\n});\n\nexport async function action({ request }: ActionArgs) {\n  const formData = await request.formData();\n  const submission = parseWithZod(formData, { schema });\n\n  if (submission.status !== 'success') {\n    return json(submission.reply());\n  }\n\n  // ...\n}\n\nexport default function Login() {\n  // Last submission returned by the server\n  const lastResult = useActionData<typeof action>();\n  const [form, fields] = useForm({\n    // Sync the result of last submission\n    lastResult,\n\n    // Reuse the validation logic on the client\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n\n    // Validate the form on blur event triggered\n    shouldValidate: 'onBlur',\n    shouldRevalidate: 'onInput',\n  });\n\n  return (\n    <Form method=\"post\" id={form.id} onSubmit={form.onSubmit} noValidate>\n      <div>\n        <label>Email</label>\n        <input\n          type=\"email\"\n          key={fields.email.key}\n          name={fields.email.name}\n          defaultValue={fields.email.initialValue}\n        />\n        <div>{fields.email.errors}</div>\n      </div>\n      <div>\n        <label>Password</label>\n        <input\n          type=\"password\"\n          key={fields.password.key}\n          name={fields.password.name}\n          defaultValue={fields.password.initialValue}\n        />\n        <div>{fields.password.errors}</div>\n      </div>\n      <label>\n        <div>\n          <span>Remember me</span>\n          <input\n            type=\"checkbox\"\n            key={fields.remember.key}\n            name={fields.remember.name}\n            defaultChecked={fields.remember.initialValue === 'on'}\n          />\n        </div>\n      </label>\n      <hr />\n      <button>Login</button>\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-Side Form Validation with Conform and Zod\nDESCRIPTION: This code shows how to reuse validation logic on the client side for instant feedback. By moving the schema definition outside the action and using it in both server and client validation, you can ensure consistent validation while providing immediate user feedback.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/validation.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\n\n// Move the schema definition out of action\nconst schema = z.object({\n  email: z.string().email(),\n  message: z.string().max(100),\n});\n\nexport async function action({ request }: ActionArgs) {\n  const formData = await request.formData();\n  const submission = parseWithZod(formData, { schema });\n\n  // ...\n}\n\nexport default function Signup() {\n  const lastResult = useActionData<typeof action>();\n  const [form] = useForm({\n    lastResult,\n    shouldValidate: 'onBlur',\n    shouldRevalidate: 'onInput',\n\n    // Setup client validation\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of Form Validation with Conform in React\nDESCRIPTION: This snippet provides a complete implementation of a contact form with validation using Conform, including schema definition, action function, and form rendering with minimal boilerplate.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_11\n\nLANGUAGE: TSX\nCODE:\n```\nimport {\n  useForm,\n  getFormProps,\n  getInputProps,\n  getTextareaProps,\n} from '@conform-to/react';\nimport { parseWithZod, getZodConstraint } from '@conform-to/zod';\nimport { type ActionFunctionArgs } from '@remix-run/node';\nimport { Form, useActionData } from '@remix-run/react';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\n\nconst schema = z.object({\n  email: z\n    .string({ required_error: 'Email is required' })\n    .email('Email is invalid'),\n  message: z\n    .string({ required_error: 'Message is required' })\n    .min(10, 'Message is too short')\n    .max(100, 'Message is too long'),\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const formData = await request.formData();\n  const submission = parseWithZod(formData, { schema });\n\n  if (submission.status !== 'success') {\n    return submission.reply();\n  }\n\n  const message = await sendMessage(submission.value);\n\n  if (!message.sent) {\n    return submission.reply({\n      formErrors: ['Failed to send the message. Please try again later.'],\n    });\n  }\n\n  return redirect('/messages');\n}\n\nexport default function ContactUs() {\n  const lastResult = useActionData<typeof action>();\n  const [form, fields] = useForm({\n    lastResult,\n    constraint: getZodConstraint(schema),\n    shouldValidate: 'onBlur',\n    shouldRevalidate: 'onInput',\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n\n  return (\n    <Form method=\"post\" {...getFormProps(form)}>\n      <div>\n        <label htmlFor={fields.email.id}>Email</label>\n        <input {...getInputProps(fields.email, { type: 'email' })} />\n        <div id={fields.email.errorId}>{fields.email.errors}</div>\n      </div>\n      <div>\n        <label htmlFor={fields.message.id}>Message</label>\n        <textarea {...getTextareaProps(fields.message)} />\n        <div id={fields.message.errorId}>{fields.message.errors}</div>\n      </div>\n      <button>Send</button>\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Client-side Login Form Component in Next.js\nDESCRIPTION: React component that implements the login form UI with client-side validation using Conform. Includes email, password, and remember me fields with error handling.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/integration/nextjs.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n'use client';\n\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport { useFormState } from 'react-dom';\nimport { login } from '@/app/actions';\nimport { loginSchema } from '@/app/schema';\n\nexport function LoginForm() {\n  const [lastResult, action] = useFormState(login, undefined);\n  const [form, fields] = useForm({\n    lastResult,\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema: loginSchema });\n    },\n    shouldValidate: 'onBlur',\n    shouldRevalidate: 'onInput',\n  });\n\n  return (\n    <form id={form.id} onSubmit={form.onSubmit} action={action} noValidate>\n      <div>\n        <label>Email</label>\n        <input\n          type=\"email\"\n          key={fields.email.key}\n          name={fields.email.name}\n          defaultValue={fields.email.initialValue}\n        />\n        <div>{fields.email.errors}</div>\n      </div>\n      <div>\n        <label>Password</label>\n        <input\n          type=\"password\"\n          key={fields.password.key}\n          name={fields.password.name}\n          defaultValue={fields.password.initialValue}\n        />\n        <div>{fields.password.errors}</div>\n      </div>\n      <label>\n        <div>\n          <span>Remember me</span>\n          <input\n            type=\"checkbox\"\n            key={fields.remember.key}\n            name={fields.remember.name}\n            defaultChecked={fields.remember.initialValue === 'on'}\n          />\n        </div>\n      </label>\n      <button>Login</button>\n    </form>\n  );\n```\n\n----------------------------------------\n\nTITLE: Contact Form Using Conform's useForm Hook for Streamlined Form Management\nDESCRIPTION: A Remix component implementing a contact form with Conform's useForm hook to manage form state, validation, and accessibility attributes automatically.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod, getZodConstraint } from '@conform-to/zod';\nimport { type ActionFunctionArgs } from '@remix-run/node';\nimport { Form, useActionData } from '@remix-run/react';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\nimport { getUser } from '~/session';\n\nconst schema = z.object({\n\t// ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n\t// ...\n}\n\nexport default function ContactUs() {\n\tconst lastResult = useActionData<typeof action>();\n\t// The useForm hook will return all the metadata we need to render the form\n\t// and put focus on the first invalid field when the form is submitted\n\tconst [form, fields] = useForm({\n\t\t// This not only syncs the error from the server\n\t\t// But is also used as the default value of the form\n\t\t// in case the document is reloaded for progressive enhancement\n\t\tlastResult,\n\n\t\t// To derive all validation attributes\n\t\tconstraint: getZodConstraint(schema),\n\t});\n\n\treturn (\n\t\t<Form\n\t\t\tmethod=\"post\"\n      {/* The only additional attribute you need is the `id` attribute */}\n\t\t\tid={form.id}\n\t\t\taria-invalid={form.errors ? true : undefined}\n\t\t\taria-describedby={form.errors ? form.errorId : undefined}\n\t\t>\n\t\t\t<div id={form.errorId}>{form.errors}</div>\n\t\t\t<div>\n\t\t\t\t<label htmlFor={fields.email.id}>Email</label>\n\t\t\t\t<input\n\t\t\t\t\tid={fields.email.id}\n\t\t\t\t\ttype=\"email\"\n\t\t\t\t\tname={fields.email.name}\n\t\t\t\t\tdefaultValue={fields.email.initialValue}\n\t\t\t\t\trequired={fields.email.required}\n\t\t\t\t\taria-invalid={fields.email.errors ? true : undefined}\n\t\t\t\t\taria-describedby={\n\t\t\t\t\t\tfields.email.errors ? fields.email.errorId : undefined\n\t\t\t\t\t}\n\t\t\t\t/>\n\t\t\t\t<div id={fields.email.errorId}>{fields.email.errors}</div>\n\t\t\t</div>\n\t\t\t<div>\n\t\t\t\t<label htmlFor={fields.message.id}>Message</label>\n\t\t\t\t<textarea\n\t\t\t\t\tid={fields.message.id}\n\t\t\t\t\tname={fields.message.name}\n\t\t\t\t\tdefaultValue={fields.message.initialValue}\n\t\t\t\t\trequired={fields.message.required}\n\t\t\t\t\tminLength={fields.message.minLength}\n\t\t\t\t\tmaxLength={fields.message.maxLength}\n\t\t\t\t\taria-invalid={fields.message.errors ? true : undefined}\n\t\t\t\t\taria-describedby={\n\t\t\t\t\t\tfields.message.errors ? fields.message.errorId : undefined\n\t\t\t\t\t}\n\t\t\t\t/>\n\t\t\t\t<div id={fields.message.errorId}>{fields.message.errors}</div>\n\t\t\t</div>\n\t\t\t<button>Send</button>\n\t\t</Form>\n\t);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-side Login Action in Next.js\nDESCRIPTION: Server action that handles form submission using Conform and Zod for validation. Redirects to dashboard on successful login.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/integration/nextjs.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n'use server';\n\nimport { redirect } from 'next/navigation';\nimport { parseWithZod } from '@conform-to/zod';\nimport { loginSchema } from '@/app/schema';\n\nexport async function login(prevState: unknown, formData: FormData) {\n  const submission = parseWithZod(formData, {\n    schema: loginSchema,\n  });\n\n  if (submission.status !== 'success') {\n    return submission.reply();\n  }\n\n  redirect('/dashboard');\n}\n```\n\n----------------------------------------\n\nTITLE: Accessible Contact Form with ARIA Attributes in Remix\nDESCRIPTION: Enhanced version of the contact form with accessibility improvements including proper labeling, ARIA attributes, and validation attributes.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type ActionFunctionArgs } from '@remix-run/node';\nimport { Form, useActionData } from '@remix-run/react';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  // ...\n}\n\nexport default function ContactUs() {\n  const result = useActionData<typeof action>();\n\n  return (\n    <Form\n      method=\"POST\"\n      aria-invalid={result?.formErrors ? true : undefined}\n      aria-describedby={result?.formErrors ? 'contact-error' : undefined}\n    >\n      <div id=\"contact-error\">{result?.formErrors}</div>\n      <div>\n        <label htmlFor=\"contact-email\">Email</label>\n        <input\n          id=\"contact-email\"\n          type=\"email\"\n          name=\"email\"\n          defaultValue={result?.payload.email}\n          required\n          aria-invalid={result?.fieldErrors.email ? true : undefined}\n          aria-describedby={\n            result?.fieldErrors.email ? 'contact-email-error' : undefined\n          }\n        />\n        <div id=\"contact-email-error\">{result?.fieldErrors.email}</div>\n      </div>\n      <div>\n        <label htmlFor=\"contact-message\">Message</label>\n        <textarea\n          id=\"contact-message\"\n          name=\"message\"\n          defaultValue={result?.payload.message}\n          required\n          minLength={10}\n          maxLength={100}\n          aria-invalid={result?.fieldErrors.message ? true : undefined}\n          aria-describedby={\n            result?.fieldErrors.message ? 'contact-email-message' : undefined\n          }\n        />\n        <div id=\"contact-email-message\">{result?.fieldErrors.message}</div>\n      </div>\n      <button>Send</button>\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Side Form Validation with Conform and Zod\nDESCRIPTION: This example demonstrates how to implement fully server-side form validation using Conform with Zod. The validation works not only on form submission but also during user interactions like typing or leaving a field. This approach keeps validation logic off the client bundle but may introduce latency.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/validation.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport { z } from 'zod';\n\nexport async function action({ request }: ActionArgs) {\n  const formData = await request.formData();\n  const submission = parseWithZod(formData, {\n    schema: z.object({\n      email: z.string().email(),\n      message: z.string().max(100),\n    }),\n  });\n\n  if (submission.status !== 'success') {\n    return submission.reply();\n  }\n\n  return await signup(data);\n}\n\nexport default function Signup() {\n  // Last result returned by the server\n  const lastResult = useActionData<typeof action>();\n  const [form] = useForm({\n    // Sync the result of last submission\n    lastResult,\n\n    // Configure when each field should be validated\n    shouldValidate: 'onBlur',\n    shouldRevalidate: 'onInput',\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Progressive Enhancement with Conform in React Forms\nDESCRIPTION: This snippet illustrates how to use Conform for progressive enhancement in forms. It shows how to manipulate a list of fields with form data and state persistence, even across page refreshes.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/accessibility.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nexport default function Example() {\n  const [form, fields] = useForm();\n\n  return (\n    <form id={form.id}>\n      <ul>\n        {tasks.map((task) => (\n          <li key={task.key}>\n            <input name={task.name} defaultValue={task.initialValue} />\n            <button\n              {...form.remove.getButtonProps({\n                name: fields.tasks.name,\n                index,\n              })}\n            >\n              Delete\n            </button>\n          </li>\n        ))}\n      </ul>\n      <button\n        {...form.insert.getButtonProps({\n          name: fields.tasks.name,\n        })}\n      >\n        Add task\n      </button>\n      <button>Save</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing Form Boilerplate with Conform Helpers in React\nDESCRIPTION: This snippet demonstrates how to use Conform's helper functions like getFormProps, getInputProps, and getTextareaProps to minimize boilerplate code in form setup.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_10\n\nLANGUAGE: TSX\nCODE:\n```\nimport {\n  useForm,\n  getFormProps,\n  getInputProps,\n  getTextareaProps,\n} from '@conform-to/react';\nimport { parseWithZod, getZodConstraint } from '@conform-to/zod';\nimport { type ActionFunctionArgs } from '@remix-run/node';\nimport { Form, useActionData } from '@remix-run/react';\nimport { sendMessage } from '~/message';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  // ...\n}\n\nexport default function ContactUs() {\n  const lastResult = useActionData<typeof action>();\n  const [form, fields] = useForm({\n    // ...\n  });\n\n  return (\n    <Form method=\"post\" {...getFormProps(form)}>\n      <div>\n        <label htmlFor={fields.email.id}>Email</label>\n        <input {...getInputProps(fields.email, { type: 'email' })} />\n        <div id={fields.email.errorId}>{fields.email.errors}</div>\n      </div>\n      <div>\n        <label htmlFor={fields.message.id}>Message</label>\n        <textarea {...getTextareaProps(fields.message)} />\n        <div id={fields.message.errorId}>{fields.message.errors}</div>\n      </div>\n      <button>Send</button>\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Object Form Fields with Conform in React\nDESCRIPTION: This example demonstrates how to set up a form with nested object fields using Conform. It uses the useForm hook and parseWithZod for validation, and shows how to access and render nested form fields.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/complex-structures.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  address: z.object({\n    street: z.string(),\n    zipcode: z.string(),\n    city: z.string(),\n    country: z.string(),\n  }),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n  const address = fields.address.getFieldset();\n\n  return (\n    <form id={form.id}>\n      {/* Set the name to `address.street`, `address.zipcode` etc. */}\n      <input name={address.street.name} />\n      <div>{address.street.errors}</div>\n      <input name={address.zipcode.name} />\n      <div>{address.zipcode.errors}</div>\n      <input name={address.city.name} />\n      <div>{address.city.errors}</div>\n      <input name={address.country.name} />\n      <div>{address.country.errors}</div>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing Boilerplate with Conform Helpers in React Forms\nDESCRIPTION: This example demonstrates how to use Conform's helper functions to reduce boilerplate when setting up accessible form fields. It compares manual attribute setup with the simplified approach using getInputProps.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/accessibility.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { parseWithZod, getZodConstraint } from '@conform-to/zod';\nimport { useForm } from '@conform-to/react';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  message: z\n    .string()\n    .min(10)\n    .max(100)\n    .regex(/^[A-Za-z0-9 ]{10-100}$/),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    constraint: getZodConstraint(schema),\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n\n  return (\n    <form id={form.id}>\n      {/* Before */}\n      <input\n        type=\"text\"\n        id={fields.message.id}\n        name={fields.message.name}\n        required={fields.message.required}\n        minLength={fields.message.minLength}\n        maxLength={fields.message.maxLength}\n        pattern={fields.message.pattern}\n        aria-invalid={!fields.message.valid ? true : undefined}\n        aria-describedby={\n          !fields.message.valid\n            ? `${fields.message.errorId} ${fields.message.descriptionId}`\n            : fields.message.descriptionId\n        }\n      />\n      {/* After */}\n      <input\n        {...getInputProps(fields.message, {\n          type: 'text',\n          ariaDescribedBy: fields.message.descriptionId,\n        })}\n      />\n      <button>Send</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Checkbox Group with Conform\nDESCRIPTION: Example of creating a checkbox group that handles both single and multiple selection scenarios. Includes logic for handling initial values and displaying grouped error messages.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/checkbox-and-radio-group.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return (\n    <form id={form.id}>\n      <fieldset>\n        <legend>Please select the correct answers</legend>\n        {['a', 'b', 'c', 'd'].map((value) => (\n          <div key={value}>\n            <label>{value}</label>\n            <input\n              type=\"checkbox\"\n              name={fields.answer.name}\n              value={value}\n              defaultChecked={\n                fields.answer.initialValue &&\n                Array.isArray(fields.answer.initialValue)\n                  ? fields.answer.initialValue.includes(value)\n                  : fields.answer.initialValue === value\n              }\n            />\n          </div>\n        ))}\n        <div>{Object.values(fields.answer.allErrors).flat()}</div>\n      </fieldset>\n      <button>Submit</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple File Uploads with Conform and Zod\nDESCRIPTION: This snippet shows how to implement multiple file uploads using Conform with React. It demonstrates using the 'multiple' attribute on file inputs and setting up complex validation rules with Zod, including file size restrictions and minimum upload requirements. It also shows how to handle and display array-based validation errors.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/file-upload.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parse } from '@conform-to/zod';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  files: z\n    .array(\n      z\n        .instanceof(File)\n        .refine((file) => file.size < 1024, 'File size must be less than 1kb'),\n    )\n    .min(1, 'At least 1 file is required')\n    .refine(\n      (files) => files.every((file) => file.size < 1024),\n      'File size must be less than 1kb',\n    ),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n\n  return (\n    <form method=\"POST\" encType=\"multipart/form-data\" id={form.id}>\n      <div>\n        <label>Mutliple Files</label>\n        <input type=\"file\" name={fields.files.name} multiple />\n        <div>{Object.values(fields.files.allErrors).flat()}</div>\n      </div>\n      <button>Upload</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing List Field Manipulation\nDESCRIPTION: Demonstrates how to implement list field manipulation using Conform's insert, remove, and reorder intents. Includes validation with Zod schema integration.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/intent-button.md#2025-04-11_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from \"@conform-to/zod\";\nimport { z } from \"zod\";\n\nconst todosSchema = z.object({\n  title: z.string(),\n  tasks: z.array(z.string()),\n});\n\nexport default function Tasks() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema: todosSchema });\n    },\n    shouldValidate: \"onBlur\",\n  });\n  const tasks = fields.tasks.getFieldList();\n\n  return (\n    <form id={form.id} onSubmit={form.onSubmit}>\n      <ul>\n        {tasks.map((task, index) => (\n          <li key={task.key}>\n            <input name={task.name} />\n            <button\n              {...form.reorder.getButtonProps({\n                name: fields.tasks.name,\n                from: index,\n                to: 0,\n              })}\n            >\n              Move to top\n            </button>\n            <button\n              {...form.remove.getButtonProps({\n                name: fields.tasks.name,\n                index,\n              })}\n            >\n              Delete\n            </button>\n          </li>\n        ))}\n      </ul>\n      <button\n        {...form.insert.getButtonProps({\n          name: fields.tasks.name,\n        })}\n      >\n        Add task\n      </button>\n      <button>Save</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Single File Upload with React, Conform, and Zod\nDESCRIPTION: This snippet demonstrates how to set up a form for single file upload using React with Conform for form handling and Zod for schema validation. It includes form configuration, file input setup, and error handling.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/file-upload.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  profile: z.instanceof(File, { message: 'Profile is required' }),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n\n  return (\n    <form method=\"POST\" encType=\"multipart/form-data\" id={form.id}>\n      <div>\n        <label>Profile</label>\n        <input type=\"file\" name={fields.profile.name} />\n        <div>{fields.profile.error}</div>\n      </div>\n      <button>Upload</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Array Form Fields with Conform in React\nDESCRIPTION: This example demonstrates how to handle nested array fields in a form using Conform. It combines getFieldList() for the outer array and getFieldset() for the inner object structure.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/complex-structures.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  todos: z.array(\n    z.object({\n      title: z.string(),\n      notes: z.string(),\n    }),\n  ),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n  const todos = fields.todos.getFieldList();\n\n  return (\n    <form id={form.id}>\n      <ul>\n        {todos.map((todo) => {\n          const todoFields = todo.getFieldset();\n\n          return (\n            <li key={todo.key}>\n              <input name={todoFields.title.name} />\n              <div>{todoFields.title.errors}</div>\n              <input name={todoFields.notes.name} />\n              <div>{todoFields.notes.errors}</div>\n            </li>\n          );\n        })}\n      </ul>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Form Validation with parseWithZod and useForm\nDESCRIPTION: Complete example showing how to use parseWithZod with useForm hook to validate a form with email and password fields using a Zod schema.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/parseWithZod.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { parseWithZod } from '@conform-to/zod';\nimport { useForm } from '@conform-to/react';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  email: z.string().email(),\n  password: z.string(),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple File Upload with React, Conform, and Zod\nDESCRIPTION: This snippet shows how to implement multiple file uploads in a React form using Conform and Zod. It includes advanced validation rules, such as file size checks and minimum file count, and demonstrates how to handle and display multiple errors.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/file-upload.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parse } from '@conform-to/zod';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  files: z\n    .array(\n      z\n        .instanceof(File)\n        .refine((file) => file.size < 1024, 'File size must be less than 1kb'),\n    )\n    .min(1, 'At least 1 file is required')\n    .refine(\n      (files) => files.every((file) => file.size < 1024),\n      'File size must be less than 1kb',\n    ),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n\n  return (\n    <form method=\"POST\" encType=\"multipart/form-data\" id={form.id}>\n      <div>\n        <label>Mutliple Files</label>\n        <input type=\"file\" name={fields.files.name} multiple />\n        <div>{Object.values(fields.files.allErrors).flat()}</div>\n      </div>\n      <button>Upload</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Basic File Upload with Conform and Zod\nDESCRIPTION: This snippet demonstrates how to create a file upload form using Conform with React and Zod validation. It shows the required form attributes (encType and method) and how to validate a single file upload using Zod's instanceof validator.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/file-upload.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  profile: z.instanceof(File, { message: 'Profile is required' }),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n\n  return (\n    <form method=\"POST\" encType=\"multipart/form-data\" id={form.id}>\n      <div>\n        <label>Profile</label>\n        <input type=\"file\" name={fields.profile.name} />\n        <div>{fields.profile.error}</div>\n      </div>\n      <button>Upload</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-Side Validation in React with Conform\nDESCRIPTION: This snippet shows how to add client-side validation to the form using the onValidate option in the useForm hook.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_9\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport { type ActionFunctionArgs, type LoaderFunctionArgs } from '@remix-run/node';\nimport { Form, useActionData, useLoaderData } from '@remix-run/react';\nimport { sendMessage } from '~/message';\nimport { getUser } from '~/session';\n\nconst schema = z.object({\n\t// ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n\t// ...\n}\n\nexport default function ContactUs() {\n\tconst user = useLoaderData<typeof loader>();\n\tconst lastResult = useActionData<typeof action>();\n\tconst [form, fields] = useForm({\n\t\t// ... previous config\n\n\t\t// Run the same validation logic on client\n\t\tonValidate({ formData }) {\n\t\t\treturn parseWithZod(formData, { schema });\n\t\t},\n\t});\n\n\treturn (\n    <Form\n      method=\"post\"\n\t\t\tid={form.id}\n      {/* The `onSubmit` handler is required for client validation */}\n      onSubmit={form.onSubmit}\n\t\t\taria-invalid={form.errors ? true : undefined}\n\t\t\taria-describedby={form.errors ? form.errorId : undefined}\n    >\n      {/* ... */}\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Email Validation with Conform and Zod in TypeScript React\nDESCRIPTION: This snippet demonstrates how to create a signup form with async email validation using Conform and Zod. It includes a schema creator function that handles conditional validation based on the form intent, and showcases the usage of conformZodMessage for controlling validation behavior.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/conformZodMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { Intent } from '@conform-to/react';\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod, conformZodMessage } from '@conform-to/zod';\nimport { z } from 'zod';\n\n// Instead of sharing a schema, prepare a schema creator\nfunction createSchema(\n  // The `intent` will be provided by the `parseWithZod` helper\n  intent: Intent | null,\n  options?: {\n    isEmailUnique: (email: string) => Promise<boolean>;\n  },\n) {\n  return z\n    .object({\n      email: z\n        .string()\n        .email()\n        // Pipe the schema so it runs only if the email is valid\n        .pipe(\n          z.string().superRefine((email, ctx) => {\n            const isValidatingEmail =\n              intent === null ||\n              (intent.type === 'validate' && intent.payload.name === 'email');\n\n            if (!isValidatingEmail) {\n              ctx.addIssue({\n                code: 'custom',\n                message: conformZodMessage.VALIDATION_SKIPPED,\n              });\n              return;\n            }\n\n            if (typeof options?.isEmailUnique !== 'function') {\n              ctx.addIssue({\n                code: 'custom',\n                message: conformZodMessage.VALIDATION_UNDEFINED,\n                fatal: true,\n              });\n              return;\n            }\n\n            return options.isEmailUnique(email).then((isUnique) => {\n              if (!isUnique) {\n                ctx.addIssue({\n                  code: 'custom',\n                  message: 'Email is already used',\n                });\n              }\n            });\n          }),\n        ),\n    })\n    .and(\n      z\n        .object({\n          password: z.string({ required_error: 'Password is required' }),\n          confirmPassword: z.string({\n            required_error: 'Confirm password is required',\n          }),\n        })\n        .refine((data) => data.password === data.confirmPassword, {\n          message: 'Password does not match',\n          path: ['confirmPassword'],\n        }),\n    );\n}\n\nexport async function action({ request }) {\n  const formData = await request.formData();\n  const submission = await parseWithZod(formData, {\n    schema: (intent) =>\n      // create the zod schema based on the intent\n      createSchema(intent, {\n        isEmailUnique(email) {\n          // query from your database\n        },\n      }),\n    async: true,\n  });\n\n  if (submission.status !== 'success') {\n    return submission.reply();\n  }\n\n  // ...\n}\n\nexport default function Signup() {\n  const lastResult = useActionData();\n  const [form, fields] = useForm({\n    lastResult,\n    onValidate({ formData }) {\n      return parseWithZod(formData, {\n        // Create the schema without `isEmailUnique` defined\n        schema: (intent) => createSchema(intent),\n      });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Form Validation with Conform and Zod\nDESCRIPTION: This example demonstrates how to handle async validation by falling back to server validation when needed. It uses a schema creator function that checks if an email is unique, with special handling to ensure client validation remains synchronous while server validation can be asynchronous.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/validation.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { refine } from '@conform-to/zod';\n\n// Instead of sharing a schema, prepare a schema creator\nfunction createSchema(\n  options?: {\n    isEmailUnique: (email: string) => Promise<boolean>;\n  },\n) {\n  return z\n    .object({\n      email: z\n        .string()\n        .email()\n        // Pipe the schema so it runs only if the email is valid\n        .pipe(\n          // Note: The callback cannot be async here\n          // As we run zod validation synchronously on the client\n          z.string().superRefine((email, ctx) => {\n            // This makes Conform to fallback to server validation\n            // by indicating that the validation is not defined\n            if (typeof options?.isEmailUnique !== 'function') {\n              ctx.addIssue({\n                code: 'custom',\n                message: conformZodMessage.VALIDATION_UNDEFINED,\n                fatal: true,\n              });\n              return;\n            }\n\n            // If it reaches here, then it must be validating on the server\n            // Return the result as a promise so Zod knows it's async instead\n            return options.isEmailUnique(email).then((isUnique) => {\n              if (!isUnique) {\n                ctx.addIssue({\n                  code: 'custom',\n                  message: 'Email is already used',\n                });\n              }\n            });\n          }),\n        ),\n    }),\n    // ...\n}\n\nexport function action() {\n\tconst formData = await request.formData();\n\tconst submission = await parseWithZod(formData, {\n\t\t// create the zod schema with `isEmailUnique()` implemented\n\t\tschema: createSchema({\n\t\t\tasync isEmailUnique(email) {\n\t\t\t\t// ...\n\t\t\t},\n\t\t}),\n\n\t\t// Enable async validation on the server\n    // We won't set `async: true` on the client\n    // as client validation must be synchronous\n\t\tasync: true,\n\t});\n\n\t// ...\n}\n\nexport default function Signup() {\n\tconst lastResult = useActionData();\n\tconst [form] = useForm({\n\t\tlastResult,\n\t\tonValidate({ formData }) {\n\t\t\treturn parseWithZod(formData, {\n\t\t\t\t// Create the schema without implementing `isEmailUnique()`\n\t\t\t\tschema: createSchema(),\n\t\t\t});\n\t\t},\n\t});\n\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering contact form with error handling\nDESCRIPTION: Implements a React component to render the contact form, display validation errors, and handle form submission using Remix's Form component.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/tutorial.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type ActionFunctionArgs } from '@remix-run/node';\nimport { Form, useActionData } from '@remix-run/react';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  // ...\n}\n\nexport default function ContactUs() {\n  const result = useActionData<typeof action>();\n\n  return (\n    <Form method=\"POST\">\n      <div>{result?.formErrors}</div>\n      <div>\n        <label>Email</label>\n        <input type=\"email\" name=\"email\" defaultValue={result?.payload.email} />\n        <div>{result?.fieldsErrors.email}</div>\n      </div>\n      <div>\n        <label>Message</label>\n        <textarea name=\"message\" defaultValue={result?.payload.message} />\n        <div>{result?.fieldsErrors.message}</div>\n      </div>\n      <button>Send</button>\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Radix UI Select Component with useInputControl\nDESCRIPTION: A detailed example showing how to integrate the Radix UI Select component with Conform using the useInputControl hook. This approach enables custom components to properly dispatch required form events.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/integration/ui-libraries.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  type FieldMetadata,\n  useForm,\n  useInputControl,\n} from '@conform-to/react';\nimport * as Select from '@radix-ui/react-select';\nimport {\n  CheckIcon,\n  ChevronDownIcon,\n  ChevronUpIcon,\n} from '@radix-ui/react-icons';\n\ntype SelectFieldProps = {\n  // You can use the `FieldMetadata` type to define the `meta` prop\n  // And restrict the type of the field it accepts through its generics\n  meta: FieldMetadata<string>;\n  options: Array<string>;\n};\n\nfunction SelectField({ meta, options }: SelectFieldProps) {\n  const control = useInputControl(meta);\n\n  return (\n    <Select.Root\n      name={meta.name}\n      value={control.value}\n      onValueChange={(value) => {\n        control.change(value);\n      }}\n      onOpenChange={(open) => {\n        if (!open) {\n          control.blur();\n        }\n      }}\n    >\n      <Select.Trigger>\n        <Select.Value />\n        <Select.Icon>\n          <ChevronDownIcon />\n        </Select.Icon>\n      </Select.Trigger>\n      <Select.Portal>\n        <Select.Content>\n          <Select.ScrollUpButton>\n            <ChevronUpIcon />\n          </Select.ScrollUpButton>\n          <Select.Viewport>\n            {options.map((option) => (\n              <Select.Item key={option} value={option}>\n                <Select.ItemText>{option}</Select.ItemText>\n                <Select.ItemIndicator>\n                  <CheckIcon />\n                </Select.ItemIndicator>\n              </Select.Item>\n            ))}\n          </Select.Viewport>\n          <Select.ScrollDownButton>\n            <ChevronDownIcon />\n          </Select.ScrollDownButton>\n        </Select.Content>\n      </Select.Portal>\n    </Select.Root>\n  );\n}\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return (\n    <form id={form.id}>\n      <div>\n        <label>Currency</label>\n        <SelectField meta={fields.color} options={['red', 'green', 'blue']} />\n        <div>{fields.color.errors}</div>\n      </div>\n      <button>Submit</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Array Form Fields with Conform in React\nDESCRIPTION: This snippet shows how to work with array fields in a form using Conform. It utilizes the getFieldList() method to generate dynamic form fields for an array of tasks.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/complex-structures.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  tasks: z.array(z.string()),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n  const tasks = fields.tasks.getFieldList();\n\n  return (\n    <form id={form.id}>\n      <ul>\n        {tasks.map((task) => (\n          <li key={task.key}>\n            {/* Set the name to `task[0]`, `tasks[1]` etc */}\n            <input name={task.name} />\n            <div>{task.errors}</div>\n          </li>\n        ))}\n      </ul>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Form Validation Options in React with Conform\nDESCRIPTION: This snippet demonstrates how to configure the useForm hook with shouldValidate and shouldRevalidate options to improve the validation experience.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_8\n\nLANGUAGE: TSX\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod } from '@conform-to/zod';\nimport {\n  type ActionFunctionArgs,\n  type LoaderFunctionArgs,\n  json,\n} from '@remix-run/node';\nimport { Form, useActionData, useLoaderData } from '@remix-run/react';\nimport { sendMessage } from '~/message';\nimport { getUser } from '~/session';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  // ...\n}\n\nexport async function action({ request }: ActionFunctionArgs) {\n  // ...\n}\n\nexport default function ContactUs() {\n  const user = useLoaderData<typeof loader>();\n  const lastResult = useActionData<typeof action>();\n  const [form, fields] = useForm({\n    // ... previous config\n\n    // Validate field once user leaves the field\n    shouldValidate: 'onBlur',\n    // Then, revalidate field as user types again\n    shouldRevalidate: 'onInput',\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Complete useInputControl Example with Custom Select Component\nDESCRIPTION: Demonstrates how to integrate the useInputControl hook with a custom Select component, showing how to link the control's value and event handlers.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useInputControl.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, useInputControl } from '@conform-to/react';\nimport { Select, Option } from './custom-ui';\n\nfunction Example() {\n  const [form, fields] = useForm();\n  const color = useInputControl(fields.color);\n\n  return (\n    <Select\n      name={fields.color.name}\n      value={color.value}\n      onChange={color.change}\n      onFocus={color.focus}\n      onBlur={color.blur}\n    >\n      <Option value=\"red\">Red</Option>\n      <Option value=\"green\">Green</Option>\n      <Option value=\"blue\">Blue</Option>\n    </Select>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Aria Attributes with Conform in React\nDESCRIPTION: This snippet demonstrates how to use Conform to generate and apply proper aria attributes to form elements. It shows the setup of a form with a text input, including labels, error messages, and descriptions.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/accessibility.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return (\n    <form id={form.id}>\n      <label htmlFor={fields.message.id}>Message</label>\n      <input\n        type=\"text\"\n        id={fields.message.id}\n        name={fields.message.name}\n        aria-invalid={!fields.message.valid ? true : undefined}\n        aria-describedby={\n          !fields.message.valid\n            ? `${fields.message.errorId} ${fields.message.descriptionId}`\n            : fields.message.descriptionId\n        }\n      />\n      <div id={fields.message.descriptionId}>The message you want to send</div>\n      <div id={fields.message.errorId}>{fields.message.errors}</div>\n      <button>Send</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using getCollectionProps for Radio Buttons in React\nDESCRIPTION: Demonstrates how to use the getCollectionProps helper function to create a group of radio buttons with proper accessibility attributes in a React component.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getCollectionProps.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, getCollectionProps } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return (\n    <>\n      {getCollectionProps(fields.color, {\n        type: 'radio',\n        options: ['red', 'green', 'blue'],\n      }).map((props) => (\n        <label key={props.id} htmlFor={props.id}>\n          <input {...props} />\n          <span>{props.value}</span>\n        </label>\n      ))}\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using FormProvider with Form Elements Outside the Form Tag\nDESCRIPTION: Shows how to associate form inputs with a form even when they are not direct children of the form element, using the form attribute and FormProvider context.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/FormProvider.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Example() {\n  const [form, fields] = useForm();\n  return (\n    <FormProvider context={form.context}>\n      <div>\n        <form id={form.id} />\n      </div>\n      <div>\n        <input name={fields.title.name} form={form.id} />\n      </div>\n    </FormProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Validation Attributes with Conform and Zod in React\nDESCRIPTION: This example shows how to use Conform with Zod to derive and apply validation attributes to form fields. It demonstrates setting up a schema and using it to populate validation attributes on an input element.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/accessibility.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { parseWithZod, getZodConstraint } from '@conform-to/zod';\nimport { useForm } from '@conform-to/react';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  message: z\n    .string()\n    .min(10)\n    .max(100)\n    .regex(/^[A-Za-z0-9 ]{10-100}$/),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    constraint: getZodConstraint(schema),\n    onValidate({ formData }) {\n      return parseWithZod(formData, { schema });\n    },\n  });\n\n  return (\n    <form id={form.id}>\n      <input\n        type=\"text\"\n        name={fields.message.name}\n        required={fields.message.required}\n        minLength={fields.message.minLength}\n        maxLength={fields.message.maxLength}\n        pattern={fields.message.pattern}\n      />\n      <button>Send</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Radio Group with Conform\nDESCRIPTION: Example of creating a radio button group using @conform-to/react. Demonstrates how to set up radio inputs with the same name attribute and handle initial values for pre-selection.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/checkbox-and-radio-group.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return (\n    <form id={form.id}>\n      <fieldset>\n        <legend>Please select your favorite color</legend>\n        {['red', 'green', 'blue'].map((value) => (\n          <div key={value}>\n            <label>{value}</label>\n            <input\n              type=\"radio\"\n              name={fields.color.name}\n              value={value}\n              defaultChecked={fields.color.initialValue === value}\n            />\n          </div>\n        ))}\n        <div>{fields.color.errors}</div>\n      </fieldset>\n      <button>Submit</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Remix Action Handler with Zod Validation\nDESCRIPTION: A Remix action function that processes form submissions, validates data using Zod, and returns appropriate errors or redirects.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type ActionFunctionArgs, redirect } from '@remix-run/node';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const formData = await request.formData();\n\n  // Construct an object using `Object.fromEntries`\n  const payload = Object.fromEntries(formData);\n  // Then parse it with zod\n  const result = schema.safeParse(payload);\n\n  // Return the error to the client if the data is not valid\n  if (!result.success) {\n    const error = result.error.flatten();\n\n    return {\n      payload,\n      formErrors: error.formErrors,\n      fieldErrors: error.fieldErrors,\n    };\n  }\n\n  // We will skip the implementation as it is not important to the tutorial\n  const message = await sendMessage(result.data);\n\n  // Return a form error if the message is not sent\n  if (!message.sent) {\n    return {\n      payload,\n      formErrors: ['Failed to send the message. Please try again later.'],\n      fieldErrors: {},\n    };\n  }\n\n  return redirect('/messages');\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Form Validation with Button Click\nDESCRIPTION: Shows how to implement form validation using a dedicated validate button in Conform. The example demonstrates field-specific validation triggering.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/intent-button.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction EmailForm() {\n  const [form, fields] = useForm();\n\n  return (\n    <form id={form.id}>\n      <input name={fields.email.name} />\n      <button {...form.validate.getButtonProps({ name: fields.email.name })}>\n        Validate Email\n      </button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Enhancing form accessibility\nDESCRIPTION: Improves the contact form's accessibility by adding proper labeling, validation attributes, and ARIA attributes for error handling.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/tutorial.md#2025-04-11_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type ActionFunctionArgs } from '@remix-run/node';\nimport { Form, useActionData } from '@remix-run/react';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  // ...\n}\n\nexport default function ContactUs() {\n  const result = useActionData<typeof action>();\n\n  return (\n    <Form\n      method=\"POST\"\n      aria-invalid={result?.formErrors ? true : undefined}\n      aria-describedby={result?.formErrors ? 'contact-error' : undefined}\n    >\n      <div id=\"contact-error\">{result?.formErrors}</div>\n      <div>\n        <label htmlFor=\"contact-email\">Email</label>\n        <input\n          id=\"contact-email\"\n          type=\"email\"\n          name=\"email\"\n          defaultValue={result?.payload.email}\n          required\n          aria-invalid={result?.fieldErrors.email ? true : undefined}\n          aria-describedby={\n            result?.fieldErrors.email ? 'contact-email-error' : undefined\n          }\n        />\n        <div id=\"contact-email-error\">{result?.fieldErrors.email}</div>\n      </div>\n      <div>\n        <label htmlFor=\"contact-message\">Message</label>\n        <textarea\n          id=\"contact-message\"\n          name=\"message\"\n          defaultValue={result?.payload.message}\n          required\n          minLength={10}\n          maxLength={100}\n          aria-invalid={result?.fieldErrors.message ? true : undefined}\n          aria-describedby={\n            result?.fieldErrors.message ? 'contact-email-message' : undefined\n          }\n        />\n        <div id=\"contact-email-message\">{result?.fieldErrors.message}</div>\n      </div>\n      <button>Send</button>\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Article Form Implementation - TypeScript/React\nDESCRIPTION: Shows how to implement a form with automatic reset functionality by changing the form ID when navigating between different articles. Demonstrates form initialization with default values.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useForm.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\ninterface Article {\n  id: string;\n  title: string;\n  content: string;\n}\n\nfunction EditArticleForm({ defaultValue }: { defaultValue: Article }) {\n  const [form, fields] = useForm({\n    id: `article-${defaultValue.id}`,\n    defaultValue,\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Integration Using FormProvider and useField Hook\nDESCRIPTION: An improved approach to custom input integration using FormProvider and useField hook, which simplifies component implementation by abstracting away form context handling and reducing prop passing.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/integration/ui-libraries.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  type FieldName,\n  FormProvider,\n  useForm,\n  useField,\n  useInputControl,\n} from '@conform-to/react';\nimport * as Select from '@radix-ui/react-select';\nimport {\n  CheckIcon,\n  ChevronDownIcon,\n  ChevronUpIcon,\n} from '@radix-ui/react-icons';\n\ntype SelectFieldProps = {\n  // Instead of using the `FieldMetadata` type, we will use the `FieldName` type\n  // We can also restrict the type of the field it accepts through its generics\n  name: FieldName<string>;\n  options: Array<string>;\n};\n\nfunction Select({ name, options }: SelectFieldProps) {\n  const [meta] = useField(name);\n  const control = useInputControl(meta);\n\n  return (\n    <Select.Root\n      name={meta.name}\n      value={control.value}\n      onValueChange={(value) => {\n        control.change(value);\n      }}\n      onOpenChange={(open) => {\n        if (!open) {\n          control.blur();\n        }\n      }}\n    >\n      {/* ... */}\n    </Select.Root>\n  );\n}\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return (\n    <FormProvider context={form.context}>\n      <form id={form.id}>\n        <div>\n          <label>Color</label>\n          <Select name={fields.color.name} options={['red', 'green', 'blue']} />\n          <div>{fields.color.errors}</div>\n        </div>\n        <button>Submit</button>\n      </form>\n    </FormProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing FormData with Validation Constraints\nDESCRIPTION: Demonstrates how to parse form data with type constraints and custom error formatting. Shows handling of email, password and checkbox inputs with validation messages.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/validitystate.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type FormConstraints, type FormatErrorArgs, parse } from '@conform-to/validitystate';\n\nconst constraints = {\n    email: { type: 'email', required: true },\n    password: { type: 'password', required: true },\n    remember: { type: 'checkbox' },\n} satisify FormConstraints;\n\nfunction formatError({ input }: FormatErrorArgs) {\n    switch (input.name) {\n        case 'email': {\n            if (input.validity.valueMissing) {\n                return 'Email is required';\n            } else if (input.validity.typeMismatch) {\n                return 'Email is invalid';\n            }\n            break;\n        }\n        case 'password': {\n            if (input.validity.valueMissing) {\n                return 'Password is required';\n            }\n            break;\n        }\n     }\n\n     return '';\n}\n\nconst submission = parse(formData, {\n  constraints,\n  formatError,\n});\n\nconsole.log(submission.error);\n\nif (!submission.error) {\n    console.log(submission.value);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Form Validation with Yup and Conform in React\nDESCRIPTION: Shows how to use the getYupConstraint function in conjunction with Conform's useForm hook to set up form validation in a React component. It demonstrates creating a Yup schema with various constraints and applying it to a form.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/yup/getYupConstraint.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getYupConstraint } from '@conform-to/yup';\nimport { useForm } from '@conform-to/react';\nimport * as yup from 'yup';\n\nconst schema = yup.object({\n  title: yup.string().required().min(5).max(20),\n  description: yup.string().optional().min(100).max(1000),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    constraint: getYupConstraint(schema),\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Form Implementation with Native Inputs in Conform\nDESCRIPTION: A basic example showing how Conform works with native form elements using event delegation. The form includes text input, textarea, and select elements, demonstrating the minimal setup required.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/integration/ui-libraries.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Example() {\n  const [form, fields] = useForm({\n    // Optional, Conform will generate a random id if not provided\n    id: 'example',\n  });\n\n  return (\n    <form id={form.id}>\n      <div>\n        <label>Title</label>\n        <input type=\"text\" name=\"title\" />\n        <div>{fields.title.errors}</div>\n      </div>\n      <div>\n        <label>Description</label>\n        <textarea name=\"description\" />\n        <div>{fields.description.errors}</div>\n      </div>\n      <div>\n        <label>Color</label>\n        <select name=\"color\">\n          <option>Red</option>\n          <option>Green</option>\n          <option>Blue</option>\n        </select>\n        <div>{fields.color.errors}</div>\n      </div>\n      <button form={form.id}>Submit</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Form Implementation with Coerced Schema\nDESCRIPTION: Complete example showing how to use the coerced schema with form validation\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/coerceFormValue.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseWithValibot, unstable_coerceFormValue as coerceFormValue } from '@conform-to/valibot';\nimport { useForm } from '@conform-to/react';\nimport { object, string, date, number, boolean } from 'valibot';\nimport { jsonSchema } from './jsonSchema';\n\nconst schema = coerceFormValue(\n  object({\n    ref: string()\n    date: date(),\n    amount: number(),\n    confirm: boolean(),\n  }),\n);\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithValibot(formData, {\n        schema,\n        defaultTypeCoercion: false,\n      });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of Form Validation with Coercion\nDESCRIPTION: A full example showing how to integrate coerceFormValue with Conform's useForm hook and parseWithZod for form validation. The schema defines various field types that will be automatically coerced from string form values to their respective types.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/coerceFormValue.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseWithZod, unstable_coerceFormValue as coerceFormValue } from '@conform-to/zod';\nimport { useForm } from '@conform-to/react';\nimport { z } from 'zod';\nimport { jsonSchema } from './jsonSchema';\n\nconst schema = coerceFormValue(\n  z.object({\n    ref: z.string()\n    date: z.date(),\n    amount: z.number(),\n    confirm: z.boolean(),\n  }),\n);\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, {\n        schema,\n        defaultTypeCoercion: false,\n      });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Example Implementation of getFormProps with useForm\nDESCRIPTION: Shows a complete example of how to use getFormProps in conjunction with useForm to create an accessible form element with minimal code.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/getFormProps.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, getFormProps } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return <form {...getFormProps(form)} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing getZodConstraint with useForm in a React Component\nDESCRIPTION: Example of using getZodConstraint with the useForm hook from @conform-to/react. The function extracts validation constraints from a Zod schema that defines rules for title and description fields.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/getZodConstraint.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getZodConstraint } from '@conform-to/zod';\nimport { useForm } from '@conform-to/react';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  title: z.string().min(5).max(20),\n  description: z.string().min(100).max(1000).optional(),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    constraint: getZodConstraint(schema),\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Client-side Form Validation\nDESCRIPTION: Example of client-side form validation using the validate helper with custom constraints and error formatting.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/validitystate.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { validate } from '@conform-to/validitystate';\n\nfunction Example() {\n  return (\n    <form\n      onSubmit={(event) => {\n        const form = event.currentTarget;\n\n        validate(form, {\n          constraints,\n          formatError,\n        });\n\n        if (!form.reportValidity()) {\n          event.preventDefault();\n        }\n      }}\n      noValidate\n    >\n      {/* ... */}\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Integration with Conform and Zod for Form Validation\nDESCRIPTION: Example showing how to use coerceFormValue with Zod schemas in a React component using Conform's useForm hook for form validation.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/zod/coerceFormValue.md#2025-04-11_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { parseWithZod, unstable_coerceFormValue as coerceFormValue } from '@conform-to/zod';\nimport { useForm } from '@conform-to/react';\nimport { z } from 'zod';\nimport { jsonSchema } from './jsonSchema';\n\nconst schema = coerceFormValue(\n  z.object({\n    ref: z.string()\n    date: z.date(),\n    amount: z.number(),\n    confirm: z.boolean(),\n  }),\n);\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, {\n        schema,\n        defaultTypeCoercion: false,\n      });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing action handler for form submission\nDESCRIPTION: Defines an action function to handle form submission, validate data using Zod, and process the message or return errors.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/tutorial.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type ActionFunctionArgs, redirect } from '@remix-run/node';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const formData = await request.formData();\n\n  const payload = Object.fromEntries(formData);\n  const result = schema.safeParse(payload);\n\n  if (!result.success) {\n    const error = result.error.flatten();\n\n    return {\n      payload,\n      formErrors: error.formErrors,\n      fieldErrors: error.fieldErrors,\n    };\n  }\n\n  const message = await sendMessage(result.data);\n\n  if (!message.sent) {\n    return {\n      payload,\n      formErrors: ['Failed to send the message. Please try again later.'],\n      fieldErrors: {},\n    };\n  }\n\n  return redirect('/messages');\n}\n```\n\n----------------------------------------\n\nTITLE: Nesting FormProvider Components for Complex Form Layouts\nDESCRIPTION: Demonstrates how to nest FormProvider components to handle multiple forms in a hierarchical structure, including how to reference a specific form context using formId.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/FormProvider.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { FormProvider, useForm } from '@conform-to/react';\n\nfunction Field({ name, formId }) {\n  //  useField will look for the closest FormContext if no formId is provided\n  const [meta] = useField(name, { formId });\n\n  return <input name={meta.name} form={meta.form} />;\n}\n\nfunction Parent() {\n  const [form, fields] = useForm({ id: 'parent' });\n  return (\n    <FormProvider context={form.context}>\n      <form id={form.id} />\n\n      <Field name={fields.category.name} />\n      <Child />\n    </FormProvider>\n  );\n}\n\nfunction Child() {\n  const [form, fields] = useForm({ id: 'child' });\n\n  return (\n    <FormProvider context={form.context}>\n      <form id={form.id} />\n      <Field name={fields.title.name} />\n\n      {/* This will look for the form context with the id 'parent' instead */}\n      <Field name={fields.bar.name} formId=\"parent\" />\n    </FormProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing parseWithYup with React Form Validation\nDESCRIPTION: Complete example demonstrating how to use parseWithYup with useForm hook from @conform-to/react, including Yup schema definition and form validation setup.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/yup/parseWithYup.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { parseWithYup } from '@conform-to/yup';\nimport { useForm } from '@conform-to/react';\nimport * as yup from 'yup';\n\nconst schema = yup.object({\n  email: yup.string().email(),\n  password: yup.string(),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithYup(formData, { schema });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Form Submission Intent with Multiple Submit Buttons\nDESCRIPTION: Demonstrates how to handle different form submission intents using multiple submit buttons with the Conform library. The example shows handling 'add-to-cart' and 'buy-now' scenarios.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/intent-button.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction Product() {\n  const [form] = useForm({\n    onSubmit(event, { formData }) {\n      event.preventDefault();\n\n      switch (formData.get('intent')) {\n        case 'add-to-cart':\n          // Add to cart\n          break;\n        case 'buy-now':\n          // Buy now\n          break;\n      }\n    },\n  });\n\n  return (\n    <form id={form.id}>\n      <input type=\"hidden\" name=\"productId\" value=\"rf23g43\" />\n      <button type=\"submit\" name=\"intent\" value=\"add-to-cart\">\n        Add to Cart\n      </button>\n      <button type=\"submit\" name=\"intent\" value=\"buy-now\">\n        Buy now\n      </button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Form Reset with Loader Data in Remix\nDESCRIPTION: Example showing how to properly handle form reset when default values come from a loader in Remix. This prevents form state synchronization issues by waiting for navigation state to be idle before updating form state.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/integration/remix.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function Example() {\n  const { defaultValue } = useLoaderData<typeof loader>();\n  const lastResult = useActionData<typeof action>();\n  const navigation = useNavigation();\n  const [form, fields] = useForm({\n    // If the default value comes from loader\n    defaultValue,\n\n    // Sync the result of last submission only when the state is idle\n    lastResult: navigation.state === 'idle' ? lastResult : null,\n\n    // or, if you are using a fetcher:\n    // lastResult: fetcher.state === 'idle' ? lastResult : null,\n\n    // ...\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of getValibotConstraint with React Form Integration\nDESCRIPTION: Comprehensive example showing how to use getValibotConstraint with @conform-to/react's useForm hook. The example demonstrates creating a schema with validation rules and passing the extracted constraints to a form.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/valibot/getValibodConstraint.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getValibotConstraint } from '@conform-to/valibot';\nimport { useForm } from '@conform-to/react';\nimport { object, pipe, string, minLength, optional } from 'valibot';\n\nconst schema = object({\n  title: pipe(string(), minLength(5), maxLength(20)),\n  description: optional(pipe(string(), minLength(100), maxLength(1000))),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    constraint: getValibotConstraint(schema),\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Error Handling with DefaultFormatError\nDESCRIPTION: Demonstrates using the defaultFormatError helper with custom validation logic for password confirmation.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/validitystate.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type FormConstraints, type FormatErrorArgs, defaultFormatError } from '@conform-to/validitystate';\n\nconst constraints = {\n    email: { type: 'email', required: true },\n    password: { type: 'password', required: true },\n    confirmPassowrd: { type: 'password', required: true },\n} satisify FormConstraints;\n\nfunction formatError({ input }: FormatErrorArgs<typeof constraints>) {\n    const error = defaultFormatError({ input });\n\n    if (input.name === 'confirmPassword' && error.length === 0 && value.password !== value.confirmPassword) {\n        error.push('notmatch');\n    }\n\n    return error;\n}\n\nconst submission = parse(formData, {\n    constraints,\n    formatError,\n});\n```\n\n----------------------------------------\n\nTITLE: Complete Form Implementation with getFormProps\nDESCRIPTION: Example showing how to use getFormProps within a React component using the useForm hook.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getFormProps.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, getFormProps } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return <form {...getFormProps(form)} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating getValibotConstraint with @conform-to/react in TypeScript/React\nDESCRIPTION: This example shows how to use getValibotConstraint in conjunction with @conform-to/react's useForm hook. It demonstrates creating a Valibot schema with various string validations and using it to generate form constraints.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/getValibodConstraint.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getValibotConstraint } from '@conform-to/valibot';\nimport { useForm } from '@conform-to/react';\nimport { object, pipe, string, minLength, optional } from 'valibot';\n\nconst schema = object({\n  title: pipe(string(), minLength(5), maxLength(20)),\n  description: optional(pipe(string(), minLength(100), maxLength(1000))),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    constraint: getValibotConstraint(schema),\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Manual Prop Setting with getCollectionProps for Checkboxes\nDESCRIPTION: Illustrates the difference between manually setting props for checkbox inputs and using the getCollectionProps helper function, demonstrating how it reduces boilerplate and improves readability.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getCollectionProps.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// Before\nfunction Example() {\n  return (\n    <form>\n      {['a', 'b', 'c'].map((value) => (\n        <label key={value} htmlFor={`${fields.category.id}-${value}`}>\n          <input\n            type=\"checkbox\"\n            key={`${fields.category.key}-${value}`}\n            id={`${fields.category.id}-${value}`}\n            name={fields.category.name}\n            form={fields.category.formId}\n            value={value}\n            defaultChecked={fields.category.initialValue?.includes(value)}\n            aria-invalid={!fields.category.valid || undefined}\n            aria-describedby={\n              !fields.category.valid ? fields.category.errorId : undefined\n            }\n          />\n          <span>{value}</span>\n        </label>\n      ))}\n      x\n    </form>\n  );\n}\n\n// After\nfunction Example() {\n  return (\n    <form>\n      {getCollectionProps(fields.category, {\n        type: 'checkbox',\n        options: ['a', 'b', 'c'],\n      }).map((props) => (\n        <label key={props.id} htmlFor={props.id}>\n          <input {...props} />\n          <span>{props.value}</span>\n        </label>\n      ))}\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Enhancing form rendering with Conform\nDESCRIPTION: Utilizes Conform's useForm hook and getZodConstraint helper to manage form metadata and derive validation attributes from the Zod schema.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/tutorial.md#2025-04-11_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\nimport { parseWithZod, getZodConstraint } from '@conform-to/zod';\nimport { type ActionFunctionArgs } from '@remix-run/node';\nimport { Form, useActionData } from '@remix-run/react';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\nimport { getUser } from '~/session';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  // ...\n}\n\nexport default function ContactUs() {\n  const lastResult = useActionData<typeof action>();\n  const [form, fields] = useForm({\n    constraint: getZodConstraint(schema),\n  });\n\n  return (\n    <Form\n      method=\"post\"\n      id={form.id}\n      aria-invalid={form.errors ? true : undefined}\n      aria-describedby={form.errors ? form.errorId : undefined}\n    >\n      <div id={form.errorId}>{form.errors}</div>\n      <div>\n        <label htmlFor={fields.email.id}>Email</label>\n        <input\n          id={fields.email.id}\n          type=\"email\"\n          name={fields.email.name}\n          defaultValue={fields.email.initialValue}\n          required={fields.email.required}\n          aria-invalid={fields.email.errors ? true : undefined}\n          aria-describedby={\n            fields.email.errors ? fields.email.errorId : undefined\n          }\n        />\n        <div id={fields.email.errorId}>{fields.email.errors}</div>\n      </div>\n      <div>\n        <label htmlFor={fields.message.id}>Message</label>\n        <textarea\n          id={fields.message.id}\n          name={fields.message.name}\n          defaultValue={fields.message.initialValue}\n          required={fields.message.required}\n          minLength={fields.message.minLength}\n          maxLength={fields.message.maxLength}\n          aria-invalid={fields.message.errors ? true : undefined}\n          aria-describedby={\n            fields.message.errors ? fields.message.errorId : undefined\n          }\n        />\n        <div id={fields.message.errorId}>{fields.message.errors}</div>\n      </div>\n      <button>Send</button>\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Blur-triggered Form Validation\nDESCRIPTION: Demonstrates how to implement form validation that triggers when a user leaves an input field using the Conform library's validation intent.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/intent-button.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction EmailForm() {\n  const [form, fields] = useForm();\n\n  return (\n    <form id={form.id}>\n      <input\n        name={fields.email.name}\n        onBlur={(event) => form.validate({ name: event.target.name })}\n      />\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Improved submission handling with parseWithZod in Conform v1\nDESCRIPTION: Example showing the redesigned submission object with improved status handling, reply method, and integration with form status.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/upgrading-v1.md#2025-04-11_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nexport async function action({ request }: ActionArgs) {\n  const formData = await request.formData();\n  const submission = parseWithZod(formData, { schema });\n\n  /**\n   * The submission status could be either \"success\", \"error\" or undefined\n   * If the status is undefined, it means that the submission is not ready (i.e. `intent` is not `submit`)\n   */\n  if (submission.status !== 'success') {\n    return json(submission.reply(), {\n      // You can also use the status to determine the HTTP status code\n      status: submission.status === 'error' ? 400 : 200,\n    });\n  }\n\n  const result = await save(submission.value);\n\n  if (!result.successful) {\n    return json(\n      submission.reply({\n        // You can also pass additional error to the `reply` method\n        formErrors: ['Submission failed'],\n        fieldErrors: {\n          address: ['Address is invalid'],\n        },\n\n        // or avoid sending the the field value back to client by specifying the field names\n        hideFields: ['password'],\n      }),\n    );\n  }\n\n  // Reply the submission with `resetForm` option\n  return json(submission.reply({ resetForm: true }));\n}\n\nexport default function Example() {\n  const lastResult = useActionData<typeof action>();\n  const [form, fields] = useForm({\n    // `lastSubmission` is renamed to `lastResult` to avoid confusion\n    lastResult,\n  });\n\n  // We can now find out the status of the submission from the form metadata as well\n  console.log(form.status); // \"success\", \"error\" or undefined\n}\n```\n\n----------------------------------------\n\nTITLE: Focus Delegation with Custom Inputs\nDESCRIPTION: Demonstrates how to implement focus delegation for custom inputs to ensure proper form validation behavior when submission fails.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useInputControl.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, useInputControl } from '@conform-to/react';\nimport { Select, Option } from './custom-ui';\n\nfunction Example() {\n  const [form, fields] = useForm();\n  const inputRef = useRef(null);\n  const color = useInputControl(fields.color);\n\n  return (\n    <>\n        <input\n            name={fields.color.name}\n            defaultValue={fields.color.initialValue}\n            className=\"sr-only\"\n            tabIndex={-1}\n            onFocus={() => inputRef.current?.focus()}\n        />\n        <Select\n            ref={inputRef}\n            value={color.value}\n            onChange={color.change}\n            onFocus={color.focus}\n            onBlur={color.blur}\n        >\n            <Option value=\"red\">Red</Option>\n            <Option value=\"green\">Green</Option>\n            <Option value=\"blue\">Blue</Option>\n        </Select>\n    <>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Form Value Coercion with parseWithZod\nDESCRIPTION: Example of disabling automatic type coercion and implementing custom preprocessing for form values, specifically converting a formatted number string to a numeric value.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/parseWithZod.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { parseWithZod } from '@conform-to/zod';\nimport { useForm } from '@conform-to/react';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  // Strip empty value and coerce the number yourself\n  amount: z.preprocess((value) => {\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    if (value === '') {\n      return undefined;\n    }\n\n    return Number(value.trim().replace(/,/g, ''));\n  }, z.number()),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithZod(formData, {\n        schema,\n        disableAutoCoercion: true,\n      });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Form Validation by Selectively Skipping Fields in Conform\nDESCRIPTION: This snippet demonstrates how to optimize validation performance by selectively validating fields based on submission intent. This approach is particularly useful for expensive async validations, allowing the system to only validate specific fields when needed rather than the entire form.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/validation.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { parseWithZod, conformZodMessage } from '@conform-to/zod';\n\nfunction createSchema(\n  // The `intent` will be provieded by the `parseWithZod` helper\n  intent: Intent | null,\n  options?: {\n    isEmailUnique: (email: string) => Promise<boolean>;\n  },\n) {\n  return z\n    .object({\n      email: z\n        .string()\n        .email()\n        .pipe(\n          z.string().superRefine((email, ctx) => {\n            const isValidatingEmail =\n              intent === null ||\n              (intent.type === 'validate' && intent.payload.name === 'email');\n\n            // This make Conform to use the previous result instead\n            // by indicating that the validation is skipped\n            if (!isValidatingEmail) {\n              ctx.addIssue({\n                code: 'custom',\n                message: conformZodMessage.VALIDATION_SKIPPED,\n              });\n              return;\n            }\n\n            if (typeof options?.isEmailUnique !== 'function') {\n              ctx.addIssue({\n                code: 'custom',\n                message: conformZodMessage.VALIDATION_UNDEFINED,\n                fatal: true,\n              });\n              return;\n            }\n\n            return options.isEmailUnique(email).then((isUnique) => {\n              if (!isUnique) {\n                ctx.addIssue({\n                  code: 'custom',\n                  message: 'Email is already used',\n                });\n              }\n            });\n          }),\n        ),\n    }),\n    // ...\n}\n\nexport async function action({ request }: ActionArgs) {\n\tconst formData = await request.formData();\n\tconst submission = await parseWithZod(formData, {\n\t\t// Retrieve the intent by providing a function instead\n\t\tschema: (intent) =>\n\t\t\tcreateSchema(intent, {\n\t\t\t\tasync isEmailUnique(email) {\n\t\t\t\t\t// ...\n\t\t\t\t},\n\t\t\t}),\n\n\t\tasync: true,\n\t});\n\n\t// ...\n}\n\nexport default function Signup() {\n\tconst lastResult = useActionData();\n\tconst [form] = useForm({\n\t\tlastResult,\n\t\tonValidate({ formData }) {\n\t\t\treturn parseWithZod(formData, {\n\t\t\t\t// Similar to the action above\n\t\t\t\tschema: (intent) => createSchema(intent),\n\t\t\t});\n\t\t},\n\t});\n\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Enhanced Action Handler Using Conform with Zod Integration\nDESCRIPTION: A streamlined Remix action function that uses Conform's parseWithZod helper to simplify form data validation and error handling.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseWithZod } from '@conform-to/zod';\nimport { type ActionFunctionArgs } from '@remix-run/node';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const formData = await request.formData();\n\n  // Replace `Object.fromEntries()` with the parseWithZod helper\n  const submission = parseWithZod(formData, { schema });\n\n  // Report the submission to client if it is not successful\n  if (submission.status !== 'success') {\n    return submission.reply();\n  }\n\n  const message = await sendMessage(submission.value);\n\n  // Return a form error if the message is not sent\n  if (!message.sent) {\n    return submission.reply({\n      formErrors: ['Failed to send the message. Please try again later.'],\n    });\n  }\n\n  return redirect('/messages');\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Validation Messages with Conform and Valibot in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use conformValibotMessage to create custom validation schemas for both client-side and server-side validation. It includes async email uniqueness checking and conditional validation based on the form's intent.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/conformValibotMessage.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { Intent } from '@conform-to/react';\nimport { useForm } from '@conform-to/react';\nimport { parseWithValibot, conformValibotMessage } from '@conform-to/valibot';\nimport {\n  check,\n  forward,\n  forwardAsync,\n  object,\n  partialCheck,\n  partialCheckAsync,\n  pipe,\n  pipeAsync,\n  string,\n} from 'valibot';\n\nfunction createBaseSchema(intent: Intent | null) {\n  return object({\n    email: pipe(\n      string('Email is required'),\n      // When not validating email, leave the email error as it is.\n      check(\n        () =>\n          intent === null ||\n          (intent.type === 'validate' && intent.payload.name === 'email'),\n        conformValibotMessage.VALIDATION_SKIPPED,\n      ),\n    ),\n    password: string('Password is required'),\n  });\n}\n\nfunction createServerSchema(\n  intent: Intent | null,\n  options: { isEmailUnique: (email: string) => Promise<boolean> },\n) {\n  return pipeAsync(\n    createBaseSchema(intent),\n    forwardAsync(\n      partialCheckAsync(\n        [['email']],\n        async ({ email }) => options.isEmailUnique(email),\n        'Email is already used',\n      ),\n      ['email'],\n    ),\n  );\n}\n\nfunction createClientSchema(intent: Intent | null) {\n  return pipe(\n    createBaseSchema(intent),\n    forward(\n      // If email is specified, fallback to server validation to check its uniqueness.\n      partialCheck(\n        [['email']],\n        () => false,\n        conformValibotMessage.VALIDATION_UNDEFINED,\n      ),\n      ['email'],\n    ),\n  );\n}\n\nexport async function action({ request }) {\n  const formData = await request.formData();\n  const submission = await parseWithValibot(formData, {\n    schema: (intent) =>\n      createServerSchema(intent, {\n        isEmailUnique: async (email) => {\n          // Query your database to check if the email is unique\n        },\n      }),\n  });\n\n  // Send the submission back to the client if the status is not successful\n  if (submission.status !== 'success') {\n    return submission.reply();\n  }\n\n  // ...\n}\n\nfunction ExampleForm() {\n  const [form, { email, password }] = useForm({\n    onValidate({ formData }) {\n      return parseWithValibot(formData, {\n        schema: (intent) => createClientSchema(intent),\n      });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Type Coercion with parseWithValibot\nDESCRIPTION: Shows how to disable automatic type coercion and implement custom conversion logic for form values, specifically handling a number field with custom formatting.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/parseWithValibot.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { parseWithValibot } from '@conform-to/valibot';\nimport { useForm } from '@conform-to/react';\nimport { pipe, object, transform, unknown, number } from 'valibot';\n\nconst schema = object({\n  // Strip empty value and coerce the number yourself\n  amount: pipe(\n    unknown(),\n    transform((value) => {\n      if (typeof value !== 'string') {\n        return value;\n      }\n\n      if (value === '') {\n        return undefined;\n      }\n\n      return Number(value.trim().replace(/,/g, ''));\n    }),\n    number(),\n  ),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithValibot(formData, {\n        schema,\n        disableAutoCoercion: true,\n      });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of getInputProps in a React Component\nDESCRIPTION: Shows a complete example of using getInputProps within a React functional component to create an accessible password input field.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getInputProps.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, getInputProps } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return <input {...getInputProps(fields.password, { type: 'password' })} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Using FormStateInput Component with FormProvider in React\nDESCRIPTION: This example demonstrates how to implement the FormStateInput component within a React component using FormProvider and useForm from the Conform library. The component helps persist form state information like field validation errors during document reloads.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/FormStateInput.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { FormProvider, FormStateInput, useForm } from '@conform-to/react';\n\nexport default function SomeParent() {\n  const [form, fields] = useForm();\n\n  return (\n    <FormProvider context={form.context}>\n      <FormStateInput />\n    </FormProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Values with Schema Transformations\nDESCRIPTION: Demonstrates how to handle default values when empty form inputs are coerced to undefined. Uses Zod's transform method to provide fallback values for optional fields.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/coerceFormValue.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = z.object({\n  foo: z.string().optional(), // string | undefined\n  bar: z\n    .string()\n    .optional()\n    .transform((value) => value ?? ''), // string\n  baz: z\n    .string()\n    .optional()\n    .transform((value) => value ?? null), // string | null\n});\n```\n\n----------------------------------------\n\nTITLE: Basic FormProvider Usage with useForm in React\nDESCRIPTION: Demonstrates how to use FormProvider together with the useForm hook to create a form context that can be accessed by child components.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/FormProvider.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { FormProvider, useForm } from '@conform-to/react';\n\nexport default function SomeParent() {\n  const [form, fields] = useForm();\n\n  return <FormProvider context={form.context}>{/* ... */}</FormProvider>;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example with React Form Integration\nDESCRIPTION: A comprehensive example showing how to use getYupConstraint with @conform-to/react's useForm hook. The example demonstrates extracting constraints from a Yup schema with string validation rules including required, min, and max length.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/yup/getYupConstraint.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getYupConstraint } from '@conform-to/yup';\nimport { useForm } from '@conform-to/react';\nimport * as yup from 'yup';\n\nconst schema = yup.object({\n  title: yup.string().required().min(5).max(20),\n  description: yup.string().optional().min(100).max(1000),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    constraint: getYupConstraint(schema),\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Form Integration Example\nDESCRIPTION: Demonstration of how to use the typed field name within a form context using useForm hook.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useField.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return <ExampleComponent name={fields.fieldName.name} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Form Reset and Update Operations\nDESCRIPTION: Shows how to implement form reset and update operations using Conform's intent system. Includes examples of resetting entire forms, specific fields, and updating field values.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/intent-button.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nexport default function Tasks() {\n  const [form, fields] = useForm();\n\n  return (\n    <form id={form.id}>\n      <button {...form.reset.getButtonProps()}>Reset form</button>\n      <button\n        {...form.reset.getButtonProps({\n          name: fields.tasks.name,\n        })}\n      >\n        Reset field (including nested / list field)\n      </button>\n      <button\n        {...form.update.getButtonProps({\n          name: fields.agenda.name,\n          value: {\n            title: 'My agenda',\n            description: 'This is my agenda',\n          },\n        })}\n      >\n        Update field (including nested / list field)\n      </button>\n      <button\n        {...form.update.getButtonProps({\n          validated: false,\n        })}\n      >\n        Clear all error\n      </button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Error Formatting\nDESCRIPTION: Shows how to implement an error formatter that returns multiple validation errors for form inputs instead of a single error message.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/validitystate.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction formatError({ input }: FormatErrorArgs) {\n  const error = [];\n\n  switch (input.name) {\n    case 'email': {\n      if (input.validity.valueMissing) {\n        error.push('Email is required');\n      }\n      if (input.validity.typeMismatch) {\n        error.push('Email is invalid');\n      }\n      break;\n    }\n    case 'password': {\n      if (input.validity.valueMissing) {\n        error.push('Password is required');\n      }\n      if (input.validity.tooShort) {\n        error.push('Password is too short');\n      }\n      break;\n    }\n  }\n\n  return error;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example with Form Integration\nDESCRIPTION: Example showing how to use getFieldsetProps within a React component with useForm hook.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getFieldsetProps.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, getFieldsetProps } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return <fieldset {...getFieldsetProps(fields.address)} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of getTextareaProps with useForm\nDESCRIPTION: Shows how to use getTextareaProps with the useForm hook to easily create an accessible textarea.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getTextareaProps.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, getTextareaProps } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return <textarea {...getTextareaProps(fields.content)} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Contact Form Component with Remix and Zod\nDESCRIPTION: A Remix component that displays a contact form with validation error handling using useActionData to receive server-side validation results.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type ActionFunctionArgs } from '@remix-run/node';\nimport { Form, useActionData } from '@remix-run/react';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  // ...\n}\n\nexport default function ContactUs() {\n  const result = useActionData<typeof action>();\n\n  return (\n    <Form method=\"POST\">\n      <div>{result?.formErrors}</div>\n      <div>\n        <label>Email</label>\n        <input type=\"email\" name=\"email\" defaultValue={result?.payload.email} />\n        <div>{result?.fieldErrors.email}</div>\n      </div>\n      <div>\n        <label>Message</label>\n        <textarea name=\"message\" defaultValue={result?.payload.message} />\n        <div>{result?.fieldErrors.message}</div>\n      </div>\n      <button>Send</button>\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using getInputProps Helper Function in React\nDESCRIPTION: Demonstrates how to use the getInputProps function to generate accessibility props for an input element in a React component.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getInputProps.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst props = getInputProps(meta, options);\n```\n\n----------------------------------------\n\nTITLE: Implementing Single Checkbox with Conform\nDESCRIPTION: Example of implementing a single checkbox input using @conform-to/react. Shows how to handle the default 'on' value and initial state handling.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/checkbox-and-radio-group.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return (\n    <form id={form.id}>\n      <div>\n        <label>Terms and conditions</label>\n        <input\n          name={fields.toc}\n          defaultChecked={fields.toc.initialValue === 'on'}\n        />\n        <div>{fields.toc.errors}</div>\n      </div>\n      <button>Submit</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Manual Props vs getInputProps Helper in React Forms\nDESCRIPTION: Illustrates the difference between manually setting input props and using the getInputProps helper for both text and checkbox inputs in a React form.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getInputProps.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Before\nfunction Example() {\n  return (\n    <form>\n      {/* text input */}\n      <input\n        key={fields.task.key}\n        id={fields.task.id}\n        name={fields.task.name}\n        form={fields.task.formId}\n        defaultValue={fields.task.initialValue}\n        aria-invalid={!fields.task.valid || undefined}\n        aria-describedby={!fields.task.valid ? fields.task.errorId : undefined}\n        required={fields.task.required}\n        minLength={fields.task.minLength}\n        maxLength={fields.task.maxLength}\n        min={fields.task.min}\n        max={fields.task.max}\n        step={fields.task.step}\n        pattern={fields.task.pattern}\n        multiple={fields.task.multiple}\n      />\n      {/* checkbox */}\n      <input\n        type=\"checkbox\"\n        key={fields.completed.key}\n        id={fields.completed.id}\n        name={fields.completed.name}\n        form={fields.completed.formId}\n        value=\"yes\"\n        defaultChecked={fields.completed.initialValue === 'yes'}\n        aria-invalid={!fields.completed.valid || undefined}\n        aria-describedby={\n          !fields.completed.valid ? fields.completed.errorId : undefined\n        }\n        required={fields.completed.required}\n      />\n    </form>\n  );\n}\n\n// After\nfunction Example() {\n  return (\n    <form>\n      {/* text input */}\n      <input {...getInputProps(fields.task, { type: 'text' })} />\n      {/* checkbox */}\n      <input\n        {...getInputProps(fields.completed, {\n          type: 'checkbox',\n          value: 'yes',\n        })}\n      />\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Improving Type Inference with FormId Type in React\nDESCRIPTION: Shows how to use the FormId type to improve type inference for form metadata when using the useFormMetadata hook. This approach provides better TypeScript support for form errors and field types.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useFormMetadata.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type FormId, useFormMetadata } from '@conform-to/react';\n\ntype ExampleComponentProps = {\n  formId: FormId<Schema, FormError>;\n};\n\nfunction ExampleComponent({ formId }: ExampleComponentProps) {\n  // Now it recognize the type of `form.errors` and the result of `form.getFieldset()`\n  const form = useFormMetadata(formId);\n\n  return <div>{/* ... */}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of Form Validation with Valibot\nDESCRIPTION: Demonstrates integrating parseWithValibot with useForm from @conform-to/react to validate email and password fields using Valibot schemas.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/parseWithValibot.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { parseWithValibot } from '@conform-to/valibot';\nimport { useForm } from '@conform-to/react';\nimport { pipe, string, email } from 'valibot';\n\nconst schema = object({\n  email: pipe(string(), email()),\n  password: string(),\n});\n\nfunction Example() {\n  const [form, fields] = useForm({\n    onValidate({ formData }) {\n      return parseWithValibot(formData, { schema });\n    },\n  });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Form Properties vs getFormProps Helper\nDESCRIPTION: Compares the verbose way of setting form properties manually with the simplified approach using getFormProps, demonstrating how the helper reduces boilerplate code.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/getFormProps.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Before\nfunction Example() {\n  return (\n    <form\n      id={form.id}\n      onSubmit={form.onSubmit}\n      noValidate={form.noValidate}\n      aria-invalid={!form.valid || undefined}\n      aria-describedby={!form.valid ? form.errorId : undefined}\n    />\n  );\n}\n\n// After\nfunction Example() {\n  return <form {...getFormProps(form)} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic useForm Hook Usage - TypeScript/React\nDESCRIPTION: Demonstrates the basic usage pattern of the useForm hook, which returns form and fields metadata for form handling.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useForm.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst [form, fields] = useForm(options);\n```\n\n----------------------------------------\n\nTITLE: Simplifying action handler with Conform\nDESCRIPTION: Uses Conform's parseWithZod helper to simplify form data parsing and validation in the action handler.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/tutorial.md#2025-04-11_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parseWithZod } from '@conform-to/zod';\nimport { type ActionFunctionArgs } from '@remix-run/node';\nimport { z } from 'zod';\nimport { sendMessage } from '~/message';\n\nconst schema = z.object({\n  // ...\n});\n\nexport async function action({ request }: ActionFunctionArgs) {\n  const formData = await request.formData();\n\n  const submission = parseWithZod(formData, { schema });\n\n  if (submission.status !== 'success') {\n    return submission.reply();\n  }\n\n  const message = await sendMessage(submission.value);\n\n  if (!message.sent) {\n    return submission.reply({\n      formErrors: ['Failed to send the message. Please try again later.'],\n    });\n  }\n\n  return redirect('/messages');\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Props Implementation vs getTextareaProps Helper\nDESCRIPTION: Compares the verbose approach of manually setting textarea props against using the getTextareaProps helper, demonstrating how the helper reduces boilerplate code.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getTextareaProps.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Before\nfunction Example() {\n  return (\n    <form>\n      <textarea\n        key={fields.content.key}\n        id={fields.content.id}\n        name={fields.content.name}\n        form={fields.content.formId}\n        defaultValue={fields.content.initialValue}\n        aria-invalid={!fields.content.valid || undefined}\n        aria-describedby={\n          !fields.content.valid ? fields.content.errorId : undefined\n        }\n        required={fields.content.required}\n        minLength={fields.content.minLength}\n        maxLength={fields.content.maxLength}\n      />\n    </form>\n  );\n}\n\n// After\nfunction Example() {\n  return (\n    <form>\n      <textarea {...getTextareaProps(fields.content)} />\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Props Implementation vs Helper Usage\nDESCRIPTION: Comparison between setting fieldset props manually and using the getFieldsetProps helper, demonstrating how the helper reduces boilerplate code.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getFieldsetProps.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Before\nfunction Example() {\n  return (\n    <fieldset\n      id={fields.address.id}\n      name={fields.address.name}\n      form={fields.address.formId}\n      aria-invalid={!form.valid || undefined}\n      aria-describedby={!form.valid ? form.errorId : undefined}\n    />\n  );\n}\n\n// After\nfunction Example() {\n  return <fieldset {...getFieldsetProps(fields.address)} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Safe Field Component Implementation\nDESCRIPTION: Example of implementing a type-safe component using the FieldName type for better type inference of field and form metadata.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useField.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type FieldName, useField } from '@conform-to/react';\n\ntype ExampleComponentProps = {\n  name: FieldName<FieldSchema, FormSchema, FormError>;\n};\n\nfunction ExampleComponent({ name }: ExampleComponentProps) {\n  // Now it recognize the type of `meta.value`, `meta.errors`, `form.errors` etc\n  const [meta, form] = useField(name);\n\n  return <div>{/* ... */}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Select Props Usage in TypeScript/React\nDESCRIPTION: Basic usage example of getSelectProps helper function to retrieve props for a select element.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getSelectProps.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst props = getSelectProps(meta, options);\n```\n\n----------------------------------------\n\nTITLE: Basic useField Hook Usage in React/TypeScript\nDESCRIPTION: Basic implementation example of the useField hook showing the core syntax for accessing field metadata and form context.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useField.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst [meta, form] = useField(name, options);\n```\n\n----------------------------------------\n\nTITLE: Defining Flexible FieldName Types for React Component Props\nDESCRIPTION: Shows various ways to define the FieldName type for component props, balancing type safety and reusability.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/useField.md#2025-04-11_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\ntype ExampleComponentProps = {\n  // \n  name: string;\n  // \n  name: FieldName<number>;\n  // \n  name: FieldName<number, { fieldName: string }>;\n  // \n  name: FieldName<number, any, CustomFormError>;\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of getFormProps Helper\nDESCRIPTION: Simple example showing the basic usage of getFormProps function to obtain form element props.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getFormProps.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst props = getFormProps(form, options);\n```\n\n----------------------------------------\n\nTITLE: Defining Login Schema with Zod in TypeScript\nDESCRIPTION: Defines the validation schema for login form using Zod. The schema validates email, password, and an optional remember me checkbox.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/integration/nextjs.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod';\n\nexport const loginSchema = z.object({\n  email: z.string().email(),\n  password: z.string(),\n  remember: z.boolean().optional(),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Type-Safe Field Names in React Components\nDESCRIPTION: Shows how to use the FieldName type for improved type safety when defining component props and using the useField hook.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/useField.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type FormName, useFormMetadata } from '@conform-to/react';\n\ntype ExampleComponentProps = {\n  name: FieldName<FieldSchema, FormSchema, FormError>;\n};\n\nfunction ExampleComponent({ name }: ExampleComponentProps) {\n  //  'meta.value', 'meta.errors', 'form.errors' \n  const [meta, form] = useField(name);\n\n  return <div>{/* ... */}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Select Props Implementation\nDESCRIPTION: Comparison between manual prop assignment and using getSelectProps helper, demonstrating how the helper reduces boilerplate code.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getSelectProps.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Before\nfunction Example() {\n  return (\n    <form>\n      <select\n        key={fields.category.key}\n        id={fields.category.id}\n        name={fields.category.name}\n        form={fields.category.formId}\n        defaultValue={fields.category.initialValue}\n        aria-invalid={!fields.category.valid || undefined}\n        aria-describedby={\n          !fields.category.valid ? fields.category.errorId : undefined\n        }\n        required={fields.category.required}\n        multiple={fields.category.multiple}\n      />\n    </form>\n  );\n}\n\n// After\nfunction Example() {\n  return (\n    <form>\n      <select {...getSelectProps(fields.category)} />\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Basic useInputControl Hook Usage\nDESCRIPTION: Shows the basic syntax for using the useInputControl hook with meta data or options object.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useInputControl.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst control = useInputControl(metaOrOptions);\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of coerceFormValue with Zod Schema\nDESCRIPTION: Demonstrates the basic syntax for enhancing a Zod schema with form value coercion. This creates an enhanced schema that will automatically apply type coercion rules to form data.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/coerceFormValue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst enhancedSchema = coerceFormValue(schema, options);\n```\n\n----------------------------------------\n\nTITLE: Simplified Zod Schema for Use with Conform\nDESCRIPTION: A cleaned-up Zod schema that removes the preprocessing step since Conform's Zod integration handles empty strings automatically.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod';\n\nconst schema = z.object({\n  email: z\n    .string({ required_error: 'Email is required' })\n    .email('Email is invalid'),\n  message: z\n    .string({ required_error: 'Message is required' })\n    .min(10, 'Message is too short')\n    .max(100, 'Message is too long'),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Zod schema for form validation\nDESCRIPTION: Creates a Zod schema to validate email and message fields with custom error messages and length constraints.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/tutorial.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod';\n\nconst schema = z.object({\n  email: z.preprocess(\n    (value) => (value === '' ? undefined : value),\n    z.string({ required_error: 'Email is required' }).email('Email is invalid'),\n  ),\n  message: z.preprocess(\n    (value) => (value === '' ? undefined : value),\n    z\n      .string({ required_error: 'Message is required' })\n      .min(10, 'Message is too short')\n      .max(100, 'Message is too long'),\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Schema-Specific Coercion\nDESCRIPTION: Example showing how to implement custom coercion for specific schema instances\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/coerceFormValue.md#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  parseWithValibot,\n  unstable_coerceFormValue as coerceFormValue,\n} from '@conform-to/valibot';\nimport { useForm } from '@conform-to/react';\nimport { object, string, number, boolean } from 'valibot';\nimport { json } from './schema';\n\nconst metadata = object({\n  number: number(),\n  confirmed: boolean(),\n});\n\nconst schema = coerceFormValue(\n  object({\n    ref: string(),\n    metadata,\n  }),\n  {\n    customize(schema) {\n      // Customize how the `metadata` field value is coerced\n      if (schema === metadata) {\n        return (value) => {\n          if (typeof value !== 'string') {\n            return value;\n          }\n\n          // Parse the value as JSON\n          return JSON.parse(value);\n        };\n      }\n\n      // Return `null` to keep the default behavior\n      return null;\n    },\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of getFieldsetProps\nDESCRIPTION: Simple example showing how to use the getFieldsetProps helper function to get fieldset props.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getFieldsetProps.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst props = getFieldsetProps(meta, options);\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Coercion for Specific Schemas\nDESCRIPTION: Shows how to create custom coercion logic for specific schema types using the customize option. This example demonstrates parsing a JSON string field into an object with specific schema validation.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/coerceFormValue.md#2025-04-11_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  parseWithZod,\n  unstable_coerceFormValue as coerceFormValue,\n} from '@conform-to/zod';\nimport { useForm } from '@conform-to/react';\nimport { z } from 'zod';\nimport { json } from './schema';\n\nconst metadata = z.object({\n  number: z.number(),\n  confirmed: z.boolean(),\n});\n\nconst schema = coerceFormValue(\n  z.object({\n    ref: z.string(),\n    metadata,\n  }),\n  {\n    customize(type) {\n      // Customize how the `metadata` field value is coerced\n      if (type === metadata) {\n        return (value) => {\n          if (typeof value !== 'string') {\n            return value;\n          }\n\n          // Parse the value as JSON\n          return JSON.parse(value);\n        };\n      }\n\n      // Return `null` to keep the default behavior\n      return null;\n    },\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of coerceFormValue with Zod Schema\nDESCRIPTION: Shows the basic syntax for enhancing a Zod schema with coerceFormValue to enable automatic type coercion for form values.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/zod/coerceFormValue.md#2025-04-11_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst enhancedSchema = coerceFormValue(schema, options);\n```\n\n----------------------------------------\n\nTITLE: Using getFormProps helper instead of form.props in Conform v1\nDESCRIPTION: Example showing how to use the getFormProps helper function instead of the removed form.props property.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/upgrading-v1.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, getFormProps } from '@conform-to/react';\n\nfunction Example() {\n  const [form] = useForm();\n\n  return <form {...getFormProps(form)} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Validation Messages\nDESCRIPTION: Shows how to retrieve validation messages from form inputs using the getError helper function.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/validitystate.md#2025-04-11_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getError } from '@conform-to/validitystate';\n\nfunction Example() {\n  const [error, setError] = useState({});\n\n  return (\n    <form\n      onInvalid={(event) => {\n        const input = event.target as HTMLInputElement;\n\n        setError((prev) => ({\n          ...prev,\n          [input.name]: getError(input.validationMessage),\n        }));\n\n        event.preventDefault();\n      }}\n    >\n      {/* ... */}\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of getZodConstraint with Zod Schema\nDESCRIPTION: Basic syntax for using the getZodConstraint function to extract validation constraints from a Zod schema.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/getZodConstraint.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst constraint = getZodConstraint(schema);\n```\n\n----------------------------------------\n\nTITLE: Using useFormMetadata Hook in React\nDESCRIPTION: Demonstrates how to use the useFormMetadata hook to retrieve form metadata by subscribing to the context set on the FormProvider.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useFormMetadata.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst form = useFormMetadata(formId);\n```\n\n----------------------------------------\n\nTITLE: Basic parseWithYup Usage with Conform\nDESCRIPTION: Simple example showing the basic usage of parseWithYup function for form data parsing.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/yup/parseWithYup.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst submission = parseWithYup(payload, options);\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of parseWithZod Function\nDESCRIPTION: Demonstrates the basic syntax for using the parseWithZod function to parse form submission data with options.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/parseWithZod.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst submission = parseWithZod(payload, options);\n```\n\n----------------------------------------\n\nTITLE: Default Value Schema Configuration\nDESCRIPTION: Example demonstrating how to configure default values with optional fields\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/coerceFormValue.md#2025-04-11_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = object({\n  foo: optional(string()), // string | undefined\n  bar: optional(string(), ''), // string\n  baz: optional(nullable(optional()), null), // string | null\n});\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of getValibotConstraint in TypeScript/React\nDESCRIPTION: This snippet demonstrates the basic usage of the getValibotConstraint function to generate validation constraints from a Valibot schema.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/getValibodConstraint.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst constraint = getValibotConstraint(schema);\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of parseWithValibot Helper Function\nDESCRIPTION: Shows the basic syntax for using the parseWithValibot function to parse form data with a Valibot schema.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/parseWithValibot.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst submission = parseWithValibot(payload, options);\n```\n\n----------------------------------------\n\nTITLE: Basic Schema Coercion Example\nDESCRIPTION: Simple example showing how to enhance a schema with coerceFormValue\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/coerceFormValue.md#2025-04-11_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst enhancedSchema = coerceFormValue(schema, options);\n```\n\n----------------------------------------\n\nTITLE: Flexible FormId Type Usage in React Components\nDESCRIPTION: Shows different ways to type the formId prop in a component, depending on the level of specificity required. This includes using a simple string type, specifying a particular field, or using a custom error type.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useFormMetadata.md#2025-04-11_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\ntype ExampleComponentProps = {\n  // If you don't care about the type of Schema or FormError\n  formId: string;\n  // If you are accessing a specific field from the form metadata\n  formId: FormId<{ fieldName: string }>;\n  // If you have a custom error type\n  formId: FormId<Record<string, any>, CustomFormError>;\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of getYupConstraint Function\nDESCRIPTION: Simple example showing how to extract constraints from a Yup schema.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/yup/getYupConstraint.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst constraint = getYupConstraint(schema);\n```\n\n----------------------------------------\n\nTITLE: Using Form IDs with Components in Conform\nDESCRIPTION: Demonstrates how to pass form IDs to components when rendering, using the IDs provided by Conform that are already typed as FormId.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/useFormMetadata.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return (\n    <>\n      <ExampleComponent formId={form.id} />\n      <ExampleComponent formId={fields.fieldName.formId} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Improving Type Inference with FormId Type in Conform\nDESCRIPTION: Shows how to use the FormId generic type to improve TypeScript type inference for form metadata with schema and error types.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/useFormMetadata.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { type FormId, useFormMetadata } from '@conform-to/react';\n\ntype ExampleComponentProps = {\n  formId: FormId<Schema, FormError>;\n};\n\nfunction ExampleComponent({ formId }: ExampleComponentProps) {\n  //  `form.errors`  `form.getFieldset()` \n  const form = useFormMetadata(formId);\n\n  return <div>{/* ... */}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using useInputControl hook for custom inputs in Conform v1\nDESCRIPTION: Example showing how to use the new useInputControl hook to integrate custom input components, which replaces the previous useInputEvent hook with improved functionality.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/upgrading-v1.md#2025-04-11_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, useInputControl } from '@conform-to/react';\nimport { CustomSelect } from './some-ui-library';\n\nfunction Example() {\n  const [form, fields] = useForm();\n  const control = useInputControl(fields.title);\n\n  return (\n    <CustomSelect\n      name={fields.title.name}\n      value={control.value}\n      onChange={(e) => control.change(e.target.value)}\n      onFocus={control.focus}\n      onBlur={control.blur}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using FormId with useForm Hook in React\nDESCRIPTION: Demonstrates how to use the FormId type when rendering components that use the useFormMetadata hook. It shows how to pass form.id and fields.fieldName.formId, which are already typed as FormId<Schema, FormError>.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useFormMetadata.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return (\n    <>\n      <ExampleComponent formId={form.id} />\n      <ExampleComponent formId={fields.fieldName.formId} />\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: FieldName Type Variations\nDESCRIPTION: Examples of different ways to use the FieldName type with varying levels of type specificity for different use cases.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useField.md#2025-04-11_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\ntype ExampleComponentProps = {\n  // If you don't care about the type of value or errors etc\n  name: string;\n  // If you are accessing the field value\n  name: FieldName<number>;\n  // If you have a deeply nested form and wanted to access a specific fields at the top\n  name: FieldName<number, { fieldName: string }>;\n  // If you have a custom error type\n  name: FieldName<number, any, CustomFormError>;\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing field metadata with getFieldset and getFieldList in Conform v1\nDESCRIPTION: Example showing how to use the getFieldset() and getFieldList() methods directly on field metadata objects instead of the removed useFieldset and useFieldList hooks.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/upgrading-v1.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Example() {\n  const [form, fields] = useForm();\n\n  // Before: useFieldset(form.ref, fields.address)\n  const address = fields.address.getFieldset();\n  // Before: useFieldList(form.ref, fields.tasks)\n  const tasks = fields.tasks.getFieldList();\n\n  return (\n    <form>\n      <ul>\n        {tasks.map((task) => {\n          // It is no longer necessary to define an additional component\n          // with nested list as you can access the fieldset directly\n          const taskFields = task.getFieldset();\n\n          return <li key={task.key}>{/* ... */}</li>;\n        })};\n      </ul>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Default Values with Transform Method\nDESCRIPTION: Example showing how to add default values when empty strings are converted to undefined by using Zod's transform method.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/zod/coerceFormValue.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst schema = z.object({\n  foo: z.string().optional(), // string | undefined\n  bar: z\n    .string()\n    .optional()\n    .transform((value) => value ?? ''), // string\n  baz: z\n    .string()\n    .optional()\n    .transform((value) => value ?? null), // string | null\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Zod Schema for Form Validation with Preprocessing\nDESCRIPTION: A Zod schema that defines validation rules for email and message fields with preprocessing to handle empty inputs correctly.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod';\n\nconst schema = z.object({\n  // The preprocess step is required for zod to perform the required check properly\n  // as the value of an empty input is usually an empty string\n  email: z.preprocess(\n    (value) => (value === '' ? undefined : value),\n    z.string({ required_error: 'Email is required' }).email('Email is invalid'),\n  ),\n  message: z.preprocess(\n    (value) => (value === '' ? undefined : value),\n    z\n      .string({ required_error: 'Message is required' })\n      .min(10, 'Message is too short')\n      .max(100, 'Message is too long'),\n  ),\n});\n```\n\n----------------------------------------\n\nTITLE: Using getInputProps with required type parameter in Conform v1\nDESCRIPTION: Example showing how to use the getInputProps helper with the now-required type option when working with input elements.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/upgrading-v1.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n<input {...getInputProps(fields.title, { type: 'text' })} />\n```\n\n----------------------------------------\n\nTITLE: Testing Custom Inputs for Event Bubbling\nDESCRIPTION: A simple test component to verify if a custom input correctly dispatches and bubbles form events. This helps identify if additional integration is needed for the input component.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/integration/ui-libraries.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { CustomInput } from 'your-ui-library';\n\nfunction Example() {\n  return (\n    <div onInput={console.log} onBlur={console.log}>\n      <CustomInput />\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Custom CSS for Screen Reader Only Elements\nDESCRIPTION: CSS styles for creating screen reader only elements when not using Tailwind CSS, useful for focus delegation implementation.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/useInputControl.md#2025-04-11_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst style = {\n  position: 'absolute',\n  width: '1px',\n  height: '1px',\n  padding: 0,\n  margin: '-1px',\n  overflow: 'hidden',\n  clip: 'rect(0,0,0,0)',\n  whiteSpace: 'nowrap',\n  border: 0,\n};\n```\n\n----------------------------------------\n\nTITLE: Simplifying Zod schema with Conform\nDESCRIPTION: Removes preprocessing steps from the Zod schema as Conform's Zod integration automatically handles empty string removal.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/tutorial.md#2025-04-11_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod';\n\nconst schema = z.object({\n  email: z\n    .string({ required_error: 'Email is required' })\n    .email('Email is invalid'),\n  message: z\n    .string({ required_error: 'Message is required' })\n    .min(10, 'Message is too short')\n    .max(100, 'Message is too long'),\n});\n```\n\n----------------------------------------\n\nTITLE: FormId Type Configuration Options in Conform\nDESCRIPTION: Shows different ways to type the formId prop based on component needs, from simple string to specific schema and error types.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/useFormMetadata.md#2025-04-11_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\ntype ExampleComponentProps = {\n  // \n  formId: string;\n  // \n  formId: FormId<{ fieldName: string }>;\n  // \n  formId: FormId<Record<string, any>, CustomFormError>;\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Conform with Zod Integration for Remix\nDESCRIPTION: Command to install Conform packages for React and Zod integration in a Remix project.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/tutorial.md#2025-04-11_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @conform-to/react @conform-to/zod --save\n```\n\n----------------------------------------\n\nTITLE: Manual Form Props Implementation vs getFormProps\nDESCRIPTION: Comparison between manual form props implementation and using the getFormProps helper, demonstrating how the helper reduces boilerplate code.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getFormProps.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// Before\nfunction Example() {\n  return (\n    <form\n      id={form.id}\n      onSubmit={form.onSubmit}\n      noValidate={form.noValidate}\n      aria-invalid={!form.valid || undefined}\n      aria-describedby={!form.valid ? form.errorId : undefined}\n    />\n  );\n}\n\n// After\nfunction Example() {\n  return <form {...getFormProps(form)} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Components with Type-Safe Field Names in React\nDESCRIPTION: Demonstrates how to use Conform-provided field names when rendering components to maintain type safety.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/useField.md#2025-04-11_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return <ExampleComponent name={fields.fieldName.name} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Conform dependencies\nDESCRIPTION: Command to install Conform packages for React and Zod integration.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/tutorial.md#2025-04-11_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @conform-to/react @conform-to/zod --save\n```\n\n----------------------------------------\n\nTITLE: Using ariaDescribedBy instead of description in Conform v1\nDESCRIPTION: Example showing how to use the renamed ariaDescribedBy option instead of the previous description option, which now expects a string ID instead of a boolean.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/upgrading-v1.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n<input\n  {...getInputProps(fields.title, {\n    ariaDescribedBy: fields.title.descriptionId,\n  })}\n/>\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of getYupConstraint Function in TypeScript\nDESCRIPTION: Demonstrates the basic usage of the getYupConstraint function to extract validation constraints from a Yup schema.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/yup/getYupConstraint.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst constraint = getYupConstraint(schema);\n```\n\n----------------------------------------\n\nTITLE: Using form metadata methods for list operations in Conform v1\nDESCRIPTION: Example showing how to use the form metadata object's methods for list operations like insert and remove, which were previously available in a separate list export.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/upgrading-v1.md#2025-04-11_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Example() {\n  const [form, fields] = useForm();\n  const tasks = fields.tasks.getFieldList();\n\n  return (\n    <form>\n      <ul>\n        {tasks.map((task) => {\n          return <li key={task.key}>{/* ... */}</li>;\n        })}\n      </ul>\n      <button {...form.insert.getButtonProps({ name: fields.tasks.name })}>\n        Add (Declarative API)\n      </button>\n      <button onClick={() => form.insert({ name: fields.tasks.name })}>\n        Add (Imperative API)\n      </button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Default Coercion Configuration\nDESCRIPTION: Example showing how to override default coercion behavior for specific types\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/valibot/coerceFormValue.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = coerceFormValue(\n  object({\n    // ...\n  }),\n  {\n    defaultCoercion: {\n      // Override the default coercion with `number()`\n      number: (value) => {\n        // Pass the value as is if it's not a string\n        if (typeof value !== 'string') {\n          return value;\n        }\n\n        // Trim and remove commas before casting it to number\n        return Number(value.trim().replace(/,/g, ''));\n      },\n\n      // Disable coercion for `boolean()`\n      boolean: false,\n    },\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Coercion for Specific Schemas\nDESCRIPTION: Demonstrates how to define custom coercion for specific schema types using the customize option.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/zod/coerceFormValue.md#2025-04-11_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  parseWithZod,\n  unstable_coerceFormValue as coerceFormValue,\n} from '@conform-to/zod';\nimport { useForm } from '@conform-to/react';\nimport { z } from 'zod';\nimport { json } from './schema';\n\nconst metadata = z.object({\n  number: z.number(),\n  confirmed: z.boolean(),\n});\n\nconst schema = coerceFormValue(\n  z.object({\n    ref: z.string(),\n    metadata,\n  }),\n  {\n    customize(type) {\n      // Customize how the `metadata` field value is coerced\n      if (type === metadata) {\n        return (value) => {\n          if (typeof value !== 'string') {\n            return value;\n          }\n\n          // Parse the value as JSON\n          return JSON.parse(value);\n        };\n      }\n\n      // Return `null` to keep the default behavior\n      return null;\n    },\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of getTextareaProps Helper in Conform\nDESCRIPTION: Demonstrates the basic syntax for using the getTextareaProps helper function to generate props for a textarea element.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getTextareaProps.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst props = getTextareaProps(meta, options);\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of getFormProps in Conform\nDESCRIPTION: Demonstrates the basic syntax for using the getFormProps helper function to return all necessary properties for making form elements accessible.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/getFormProps.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst props = getFormProps(form, options);\n```\n\n----------------------------------------\n\nTITLE: Basic useFormMetadata Hook Usage in React with Conform\nDESCRIPTION: Demonstrates the basic usage of the useFormMetadata hook to retrieve form metadata by providing a form ID.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/useFormMetadata.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst form = useFormMetadata(formId);\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Coercion Behavior\nDESCRIPTION: Shows how to customize the default coercion behavior by providing a defaultCoercion mapping in the options. This example demonstrates trimming string values, custom number parsing with comma removal, and disabling boolean coercion.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/zod/coerceFormValue.md#2025-04-11_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst schema = coerceFormValue(\n  z.object({\n    // ...\n  }),\n  {\n    defaultCoercion: {\n      // Trim the value for all string-based fields\n      // e.g. `z.string()`, `z.number()` or `z.boolean()`\n      string: (value) => {\n        if (typeof value !== 'string') {\n          return value;\n        }\n\n        const result = value.trim();\n\n        // Treat it as `undefined` if the value is empty\n        if (result === '') {\n          return undefined;\n        }\n\n        return result;\n      },\n\n      // Override the default coercion with `z.number()`\n      number: (value) => {\n        // Pass the value as is if it's not a string\n        if (typeof value !== 'string') {\n          return value;\n        }\n\n        // Trim and remove commas before casting it to number\n        return Number(value.trim().replace(/,/g, ''));\n      },\n\n      // Disable coercion for `z.boolean()`\n      boolean: false,\n    },\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Coercion Behavior\nDESCRIPTION: Shows how to customize the default coercion behavior by providing a defaultCoercion mapping in the options.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/zod/coerceFormValue.md#2025-04-11_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst schema = coerceFormValue(\n  z.object({\n    // ...\n  }),\n  {\n    defaultCoercion: {\n      // Trim the value for all string-based fields\n      // e.g. `z.string()`, `z.number()` or `z.boolean()`\n      string: (value) => {\n        if (typeof value !== 'string') {\n          return value;\n        }\n\n        const result = value.trim();\n\n        // Treat it as `undefined` if the value is empty\n        if (result === '') {\n          return undefined;\n        }\n\n        return result;\n      },\n\n      // Override the default coercion with `z.number()`\n      number: (value) => {\n        // Pass the value as is if it's not a string\n        if (typeof value !== 'string') {\n          return value;\n        }\n\n        // Trim and remove commas before casting it to number\n        return Number(value.trim().replace(/,/g, ''));\n      },\n\n      // Disable coercion for `z.boolean()`\n      boolean: false,\n    },\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Complete Form Select Implementation\nDESCRIPTION: Example showing how to use getSelectProps within a React component with useForm hook.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/api/react/getSelectProps.md#2025-04-11_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm, getSelectProps } from '@conform-to/react';\n\nfunction Example() {\n  const [form, fields] = useForm();\n\n  return <select {...getSelectProps(fields.category)} />;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of getValibotConstraint Function in TypeScript\nDESCRIPTION: Simple example of using the getValibotConstraint function to extract validation constraints from a valibot schema.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/valibot/getValibodConstraint.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst constraint = getValibotConstraint(schema);\n```\n\n----------------------------------------\n\nTITLE: Using useField Hook in React\nDESCRIPTION: Demonstrates the basic usage of the useField hook to access field metadata and form context.\nSOURCE: https://github.com/edmundhung/conform/blob/main/docs/ja/api/react/useField.md#2025-04-11_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst [meta, form] = useField(name, options);\n```"
  }
]