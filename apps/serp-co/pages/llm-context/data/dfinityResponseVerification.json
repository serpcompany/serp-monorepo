[
  {
    "owner": "dfinity",
    "repo": "response-verification",
    "content": "TITLE: Initializing and Upgrading Canister with HTTP Certification in Rust\nDESCRIPTION: Demonstrates lifecycle hooks for canister initialization and upgrades. The init function runs when a canister is first installed, while post_upgrade runs every time a canister is upgraded, both ensuring that all necessary HTTP responses are properly certified.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// run when a canister is first installed\n#[init]\nfn init() {\n    // certify all static responses\n    certify_list_todos_response();\n    certify_not_allowed_todo_responses();\n    certify_not_found_response();\n\n    // prepare query and update handlers\n    prepare_query_handlers();\n    prepare_update_handlers();\n}\n\n// run every time a canister is upgraded\n#[post_upgrade]\nfn post_upgrade() {\n    // run the same initialization logic\n    init();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Canister Lifecycle Hooks in Rust\nDESCRIPTION: This code snippet demonstrates the implementation of init and post_upgrade lifecycle hooks for a canister. These hooks are used to certify all assets when the canister is initialized or upgraded.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[init]\nfn init() {\n    certify_all_assets();\n}\n\n#[post_upgrade]\nfn post_upgrade() {\n    init();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Response Verification in JavaScript\nDESCRIPTION: A JavaScript example demonstrating how to use the @dfinity/response-verification package to verify request-response pairs. It shows the initialization process, verification function call with necessary parameters, and error handling for various verification failure scenarios.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-response-verification-wasm/README.md#2025-04-20_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport initResponseVerification, {\n  verifyRequestResponsePair,\n  ResponseVerificationError,\n  ResponseVerificationErrorCode,\n} from '@dfinity/response-verification';\n\n// this is necessary for web, but not for NodeJS consumers\nawait initResponseVerification();\n\ntry {\n  const result = verifyRequestResponsePair(\n    request,\n    response,\n    canister_id,\n    current_time_ns,\n    max_cert_time_offset_ns,\n    fromHex(IC_ROOT_KEY),\n  );\n\n  // do something with the result\n  // `result.passed` will be true if verification succeeds, false otherwise, and\n  // `result.response` will contain the certified response object if verification was successful.\n} catch (error) {\n  if (error instanceof ResponseVerificationError) {\n    switch (error.code) {\n      case ResponseVerificationErrorCode.MalformedCbor:\n        // the cbor returned from the replica was malformed.\n        // ...\n        break;\n\n      case ResponseVerificationErrorCode.MalformedCertificate:\n        // the certificate returned from the replica was malformed.\n        // ...\n        break;\n\n      // Other error cases...\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fully Certified Request/Response Pair\nDESCRIPTION: Demonstrates how to build a complete CEL expression that fully certifies both request and response, including specific headers, query parameters, and response headers for verification by the HTTP gateway.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::{DefaultCelBuilder, DefaultResponseCertification};\n\nlet cel_expr = DefaultCelBuilder::full_certification()\n    .with_request_headers(vec![\"Accept\", \"Accept-Encoding\", \"If-None-Match\"])\n    .with_request_query_parameters(vec![\"foo\", \"bar\", \"baz\"])\n    .with_response_certification(DefaultResponseCertification::certified_response_headers(vec![\n        \"Cache-Control\",\n        \"ETag\",\n    ]))\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Certifying All Assets in Rust for IC Canister\nDESCRIPTION: This function certifies all assets for the frontend project. It adds certification skips, certifies the index asset, and uses glob patterns to certify different types of assets with appropriate content types.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nfn certify_all_assets() {\n    add_certification_skips();\n\n    certify_index_asset();\n    certify_asset_glob(\"assets/**/*.css\", \"text/css\");\n    certify_asset_glob(\"assets/**/*.js\", \"text/javascript\");\n    certify_asset_glob(\"assets/**/*.ico\", \"image/x-icon\");\n    certify_asset_glob(\"assets/**/*.svg\", \"image/svg+xml\");\n\n    update_certified_data();\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Full HTTP Certification with Request and Response\nDESCRIPTION: Implements a complete HTTP certification that includes both the request and response, with specific headers certified for both. This example demonstrates the practical usage with actual request and response objects.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::{HttpCertification, HttpRequest, HttpResponse, DefaultCelBuilder, DefaultResponseCertification};\n\nlet cel_expr = DefaultCelBuilder::full_certification()\n    .with_request_headers(vec![\"Accept\", \"Accept-Encoding\", \"If-None-Match\"])\n    .with_request_query_parameters(vec![\"foo\", \"bar\", \"baz\"])\n    .with_response_certification(DefaultResponseCertification::certified_response_headers(vec![\n        \"Cache-Control\",\n        \"ETag\",\n    ]))\n    .build();\n\nlet request = HttpRequest {\n    method: \"GET\".to_string(),\n    url: \"/index.html?foo=a&bar=b&baz=c\".to_string(),\n    headers: vec![\n        (\"Accept\".to_string(), \"application/json\".to_string()),\n        (\"Accept-Encoding\".to_string(), \"gzip\".to_string()),\n        (\"If-None-Match\".to_string(), \"987654321\".to_string()),\n    ],\n    body: vec![],\n};\n\nlet response = HttpResponse {\n    status_code: 200,\n    headers: vec![\n        (\"Cache-Control\".to_string(), \"no-cache\".to_string()),\n        (\"ETag\".to_string(), \"123456789\".to_string()),\n        (\"IC-CertificateExpression\".to_string(), cel_expr.to_string()),\n    ],\n    body: vec![1, 2, 3, 4, 5, 6],\n    upgrade: None,\n};\n\nlet certification = HttpCertification::full(&cel_expr, &request, &response, None);\n```\n\n----------------------------------------\n\nTITLE: Certifying Specific HTTP Responses in Rust for Internet Computer\nDESCRIPTION: Demonstrates how to use the certify_response function for specific endpoints, such as listing todos and handling not allowed methods. This shows the practical application of the certification process.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn certify_list_todos_response() {\n    let request = HttpRequest::get(TODOS_PATH).build();\n\n    let body = TODO_ITEMS.with_borrow(|items| {\n        ListTodosResponse::ok(\n            &items\n                .iter()\n                .map(|(_id, item)| item.clone())\n                .collect::<Vec<_>>(),\n        )\n        .encode()\n    });\n    let mut response = create_response(StatusCode::OK, body);\n\n    certify_response(request, &mut response, &TODOS_TREE_PATH);\n}\n\nfn certify_not_allowed_todo_responses() {\n    [\n        Method::HEAD,\n        Method::PUT,\n        Method::PATCH,\n        Method::OPTIONS,\n        Method::TRACE,\n        Method::CONNECT,\n    ]\n    .into_iter()\n    .for_each(|method| {\n        let request = HttpRequest::builder()\n            .with_method(method)\n            .with_url(TODOS_PATH)\n            .build();\n\n        let body = ErrorResponse::not_allowed().encode();\n        let mut response = create_response(StatusCode::METHOD_NOT_ALLOWED, body);\n\n        certify_response(request, &mut response, &TODOS_TREE_PATH);\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Verifying Certificates for Testing on Internet Computer in Rust\nDESCRIPTION: This code demonstrates the complete workflow of creating and verifying a certificate for testing purposes. It creates a hash tree with sample data, builds a certificate with the tree's root hash, and then verifies the certificate. The example shows integration between several IC libraries including ic-certification-testing, ic-cbor, and ic-certificate-verification.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-certification-testing/README.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_certification_testing::{CertificateBuilder, CertificateData};\nuse ic_cbor::CertificateToCbor;\nuse ic_certificate_verification::VerifyCertificate;\nuse ic_certification::{Certificate, AsHashTree, RbTree};\nuse ic_types::CanisterId;\nuse sha2::{Digest, Sha256};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\ntype Hash = [u8; 32];\n\nfn hash<T>(data: T) -> Hash\nwhere\n  T: AsRef<[u8]>,\n{\n  let mut hasher = Sha256::new();\n  hasher.update(data);\n  hasher.finalize().into()\n}\n\nfn get_timestamp() -> u128 {\n  SystemTime::now()\n    .duration_since(UNIX_EPOCH)\n    .unwrap()\n    .as_nanos()\n}\n\nfn usage_example() {\n  let canister_id = CanisterId::from_u64(42);\n  let mut rb_tree = RbTree::<&'static str, Hash>::new();\n\n  let data_key = \"key1\";\n  let data_hash = hash(\"value1\");\n  rb_tree.insert(data_key, data_hash);\n\n  let certified_data = rb_tree.root_hash();\n\n  let current_timestamp = get_timestamp();\n\n  let mut certificate_builder =\n      CertificateBuilder::new(&canister_id.get().0.to_text(), &certified_data)\n          .expect(\"Failed to parse canister id\");\n\n  let CertificateData {\n    cbor_encoded_certificate,\n    root_key,\n    certificate: _,\n  } = certificate_builder\n    .with_time(current_timestamp)\n    .build()\n    .expect(\"Invalid certificate params provided\");\n\n  let certificate = Certificate::from_cbor(&cbor_encoded_certificate)\n    .expect(\"Failed to deserialize certificate\");\n\n  certificate\n    .verify(&canister_id.get().to_vec(), &root_key)\n    .expect(\"Failed to verify certificate\");\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up AssetRouter with Sample Assets in Rust\nDESCRIPTION: A comprehensive example of initializing an AssetRouter with various assets including HTML, JavaScript, and CSS files along with their compressed versions. The example sets up asset configurations with content types, headers, fallback behaviors, and encoding specifications.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::StatusCode;\nuse ic_asset_certification::{Asset, AssetConfig, AssetFallbackConfig, AssetRouter, AssetRedirectKind, AssetEncoding};\n\nlet mut asset_router = AssetRouter::default();\n\nlet assets = vec![\n    Asset::new(\n        \"index.html\",\n        b\"<html><body><h1>Hello World!</h1></body></html>\".as_slice(),\n    ),\n    Asset::new(\n        \"index.html.gz\",\n        &[0, 1, 2, 3, 4, 5]\n    ),\n    Asset::new(\n        \"index.html.br\",\n        &[6, 7, 8, 9, 10, 11]\n    ),\n    Asset::new(\n        \"app.js\",\n        b\"console.log('Hello World!');\".as_slice(),\n    ),\n    Asset::new(\n        \"app.js.gz\",\n        &[12, 13, 14, 15, 16, 17],\n    ),\n    Asset::new(\n        \"app.js.br\",\n        &[18, 19, 20, 21, 22, 23],\n    ),\n    Asset::new(\n        \"css/app-ba74b708.css\",\n        b\"html,body{min-height:100vh;}\".as_slice(),\n    ),\n    Asset::new(\n        \"css/app-ba74b708.css.gz\",\n        &[24, 25, 26, 27, 28, 29],\n    ),\n    Asset::new(\n        \"css/app-ba74b708.css.br\",\n        &[30, 31, 32, 33, 34, 35],\n    ),\n];\n\nlet asset_configs = vec![\n    AssetConfig::File {\n        path: \"index.html\".to_string(),\n        content_type: Some(\"text/html\".to_string()),\n        headers: vec![(\n            \"cache-control\".to_string(),\n            \"public, no-cache, no-store\".to_string(),\n        )],\n        fallback_for: vec![AssetFallbackConfig {\n            scope: \"/\".to_string(),\n            status_code: Some(StatusCode::OK),\n        }],\n        aliased_by: vec![\"/\".to_string()],\n        encodings: vec![\n            AssetEncoding::Brotli.default_config(),\n            AssetEncoding::Gzip.default_config(),\n        ],\n    },\n    AssetConfig::Pattern {\n        pattern: \"**/*.js\".to_string(),\n        content_type: Some(\"text/javascript\".to_string()),\n        headers: vec![(\n            \"cache-control\".to_string(),\n            \"public, max-age=31536000, immutable\".to_string(),\n        )],\n        encodings: vec![\n            AssetEncoding::Brotli.default_config(),\n            AssetEncoding::Gzip.default_config(),\n        ],\n    },\n    AssetConfig::Pattern {\n        pattern: \"**/*.css\".to_string(),\n        content_type: Some(\"text/css\".to_string()),\n        headers: vec![(\n            \"cache-control\".to_string(),\n            \"public, max-age=31536000, immutable\".to_string(),\n        )],\n        encodings: vec![\n            AssetEncoding::Brotli.default_config(),\n            AssetEncoding::Gzip.default_config(),\n        ],\n    },\n    AssetConfig::Redirect {\n        from: \"/old\".to_string(),\n        to: \"/new\".to_string(),\n        kind: AssetRedirectKind::Permanent,\n        headers: vec![(\n            \"content-type\".to_string(),\n            \"text/plain; charset=utf-8\".to_string(),\n        )],\n    },\n];\n\nasset_router.certify_assets(assets, asset_configs).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Handling Asset Requests in Rust for IC Canister\nDESCRIPTION: This function handles HTTP requests for assets. It checks the request path, serves the appropriate asset (including index.html for unmatched paths), handles content encoding preferences, and adds the certificate header for certified responses.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn asset_handler(req: &HttpRequest) -> HttpResponse<'static> {\n    let req_path = req.get_path().expect(\"Failed to get req path\");\n\n    RESPONSES.with_borrow(|responses| {\n        ENCODED_RESPONSES.with_borrow(|encoded_responses| {\n            let (asset_req_path, asset_tree_path, identity_response) =\n            // if the request path matches the metrics path, serve that uncertified\n            if req_path == METRICS_REQ_PATH {\n                (\n                    METRICS_REQ_PATH.to_string(),\n                    HttpCertificationPath::exact(METRICS_REQ_PATH),\n                    CertifiedHttpResponse {\n                        response: create_metrics_response(),\n                        certification: HttpCertification::skip(),\n                    },\n                )\n            }\n            // if the requested path matches a static asset, serve that\n            else if let Some(identity_response) = responses.get(&req_path) {\n                (\n                    req_path.to_string(),\n                    HttpCertificationPath::exact(&req_path),\n                    identity_response.clone(),\n                )\n            // otherwise serve the index.html\n            } else {\n                (\n                    INDEX_REQ_PATH.to_string(),\n                    INDEX_TREE_PATH.to_owned(),\n                    responses.get(*INDEX_REQ_PATH).unwrap().clone(),\n                )\n            };\n\n            // extract the content encoding header\n            let content_encoding = req.headers().iter().find_map(|(name, value)| {\n                if name.to_lowercase() == \"accept-encoding\" {\n                    Some(value)\n                } else {\n                    None\n                }\n            });\n\n            let CertifiedHttpResponse {\n                certification,\n                response,\n            } = content_encoding\n                .and_then(|encoding| {\n                    // if the request asks for Brotli and it's available for this file, serve that version\n                    if encoding.contains(\"br\") {\n                        if let Some(br_response) =\n                            encoded_responses.get(&(asset_req_path.clone(), \"br\".to_string()))\n                        {\n                            return Some(br_response.clone());\n                        }\n                    }\n\n                    // if the request asks for Gzip and it's available for this file, serve that version\n                    if encoding.contains(\"gzip\") {\n                        if let Some(gzip_response) =\n                            encoded_responses.get(&(asset_req_path, \"gzip\".to_string()))\n                        {\n                            return Some(gzip_response.clone());\n                        }\n                    }\n\n                    None\n                })\n                // otherwise serve the identity version\n                .unwrap_or(identity_response);\n\n            let mut response = response.clone();\n\n            HTTP_TREE.with_borrow(|http_tree| {\n                add_v2_certificate_header(\n                    &data_certificate().expect(\"No data certificate available\"),\n                    &mut response,\n                    &http_tree\n                        .witness(\n                            &HttpCertificationTreeEntry::new(&asset_tree_path, certification),\n                            &req_path,\n                        )\n                        .unwrap(),\n                    &asset_tree_path.to_expr_path(),\n                );\n            });\n\n            response\n        })\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using HTTP Certification Tree in Rust\nDESCRIPTION: Demonstrates initialization of HttpCertificationTree with full certification including request headers, query parameters, and response certification. Shows basic operations like inserting, generating witnesses, and deleting entries.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::{HttpCertification, HttpRequest, HttpResponse, DefaultCelBuilder, DefaultResponseCertification, HttpCertificationTree, HttpCertificationTreeEntry, HttpCertificationPath};\n\nlet cel_expr = DefaultCelBuilder::full_certification()\n    .with_request_headers(vec![\"Accept\", \"Accept-Encoding\", \"If-None-Match\"])\n    .with_request_query_parameters(vec![\"foo\", \"bar\", \"baz\"])\n    .with_response_certification(DefaultResponseCertification::certified_response_headers(vec![\n        \"Cache-Control\",\n        \"ETag\",\n    ]))\n    .build();\n\nlet request = HttpRequest {\n    method: \"GET\".to_string(),\n    url: \"/index.html?foo=a&bar=b&baz=c\".to_string(),\n    headers: vec![\n        (\"Accept\".to_string(), \"application/json\".to_string()),\n        (\"Accept-Encoding\".to_string(), \"gzip\".to_string()),\n        (\"If-None-Match\".to_string(), \"987654321\".to_string()),\n    ],\n    body: vec![],\n};\n\nlet response = HttpResponse {\n    status_code: 200,\n    headers: vec![\n        (\"Cache-Control\".to_string(), \"no-cache\".to_string()),\n        (\"ETag\".to_string(), \"123456789\".to_string()),\n        (\"IC-CertificateExpression\".to_string(), cel_expr.to_string()),\n    ],\n    body: vec![1, 2, 3, 4, 5, 6],\n    upgrade: None,\n};\n\nlet request_url = \"/example.json\";\nlet path = HttpCertificationPath::exact(request_url);\nlet certification = HttpCertification::full(&cel_expr, &request, &response, None).unwrap();\n\nlet mut http_certification_tree = HttpCertificationTree::default();\n\nlet entry = HttpCertificationTreeEntry::new(&path, &certification);\n\n// insert the entry into the tree\nhttp_certification_tree.insert(&entry);\n\n// generate a witness for this entry in the tree\nlet witness = http_certification_tree.witness(&entry, request_url);\n\n// delete the entry from the tree\nhttp_certification_tree.delete(&entry);\n```\n\n----------------------------------------\n\nTITLE: Inserting Assets into AssetRouter in Rust\nDESCRIPTION: Demonstrates how to create an AssetRouter, define assets and their configurations, and certify them. It includes examples of various asset types and configurations for HTML, JavaScript, and CSS files.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::StatusCode;\nuse ic_asset_certification::{Asset, AssetConfig, AssetFallbackConfig, AssetRouter, AssetRedirectKind};\n\nlet mut asset_router = AssetRouter::default();\n\nlet assets = vec![\n    Asset::new(\n        \"index.html\",\n        b\"<html><body><h1>Hello World!</h1></body></html>\".as_slice(),\n    ),\n    Asset::new(\n        \"index.html.gz\",\n        [0, 1, 2, 3, 4, 5]\n    ),\n    Asset::new(\n        \"index.html.br\",\n        [6, 7, 8, 9, 10, 11]\n    ),\n    Asset::new(\n        \"app.js\",\n        b\"console.log('Hello World!');\".as_slice(),\n    ),\n    Asset::new(\n        \"app.js.gz\",\n        [12, 13, 14, 15, 16, 17],\n    ),\n    Asset::new(\n        \"app.js.br\",\n        [18, 19, 20, 21, 22, 23],\n    ),\n    Asset::new(\n      \"css/app-ba74b708.css\",\n      b\"html,body{min-height:100vh;}\".as_slice(),\n    ),\n    Asset::new(\n        \"css/app-ba74b708.css.gz\",\n        [24, 25, 26, 27, 28, 29],\n    ),\n    Asset::new(\n        \"css/app-ba74b708.css.br\",\n        [30, 31, 32, 33, 34, 35],\n    ),\n];\n\nlet asset_configs = vec![\n    AssetConfig::File {\n        path: \"index.html\".to_string(),\n        content_type: Some(\"text/html\".to_string()),\n        headers: vec![\n            (\"cache-control\".to_string(), \"public, no-cache, no-store\".to_string())\n        ],\n        fallback_for: vec![AssetFallbackConfig {\n            scope: \"/\".to_string(),\n            status_code: Some(StatusCode::OK),\n        }],\n        aliased_by: vec![\"/\".to_string()],\n        encodings: vec![\n            AssetEncoding::Brotli.default(),\n            AssetEncoding::Gzip.default(),\n        ],\n    },\n    AssetConfig::Pattern {\n        pattern: \"**/*.js\".to_string(),\n        content_type: Some(\"text/javascript\".to_string()),\n        headers: vec![\n            (\"cache-control\".to_string(), \"public, max-age=31536000, immutable\".to_string())\n        ],\n        encodings: vec![\n            AssetEncoding::Brotli.default(),\n            AssetEncoding::Gzip.default(),\n        ],\n    },\n    AssetConfig::Pattern {\n        pattern: \"**/*.css\".to_string(),\n        content_type: Some(\"text/css\".to_string()),\n        headers: vec![\n            (\"cache-control\".to_string(), \"public, max-age=31536000, immutable\".to_string())\n        ],\n        encodings: vec![\n            AssetEncoding::Brotli.default(),\n            AssetEncoding::Gzip.default(),\n        ],\n    },\n    AssetConfig::Redirect {\n        from: \"/old\".to_string(),\n        to: \"/new\".to_string(),\n        kind: AssetRedirectKind::Permanent,\n        headers: vec![\n            (\"content-type\".to_string(), \"text/plain; charset=utf-8\".to_string())\n        ],\n    },\n];\n\nasset_router.certify_assets(assets, asset_configs).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Implementing Canister Lifecycle Hooks for Asset Certification in Rust\nDESCRIPTION: Defines the init and post_upgrade lifecycle hooks to ensure all assets are certified when the canister starts and after upgrades, as certification data is not stored in stable memory.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/assets/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[init]\nfn init() {\n    certify_all_assets();\n}\n\n#[post_upgrade]\nfn post_upgrade() {\n    init();\n}\n```\n\n----------------------------------------\n\nTITLE: Asset Certification Implementation in Rust DFINITY Canister\nDESCRIPTION: Implements asset certification for a DFINITY canister including thread-local storage setup, asset configuration, and certification process. Handles different asset types with various encoding options and security headers.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/assets/README.md#2025-04-20_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nthread_local! {\n    static HTTP_TREE: Rc<RefCell<HttpCertificationTree>> = Default::default();\n\n    static ASSET_ROUTER: RefCell<AssetRouter<'static>> = RefCell::new(AssetRouter::with_tree(HTTP_TREE.with(|tree| tree.clone())));\n\n    // initializing the asset router with an HTTP certification tree is optional.\n    // if direct access to the HTTP certification tree is not needed for certifying\n    // requests and responses outside of the asset router, then this step can be skipped\n    // and the asset router can be initialized like so:\n    static ASSET_ROUTER: RefCell<AssetRouter<'static>> = Default::default();\n}\n\nconst IMMUTABLE_ASSET_CACHE_CONTROL: &str = \"public, max-age=31536000, immutable\";\nconst NO_CACHE_ASSET_CACHE_CONTROL: &str = \"public, no-cache, no-store\";\n\nfn certify_all_assets() {\n    // 1. Define the asset certification configurations.\n    let encodings = vec![\n        AssetEncoding::Brotli.default(),\n        AssetEncoding::Gzip.default(),\n    ];\n\n    let asset_configs = vec![\n        AssetConfig::File {\n            path: \"index.html\".to_string(),\n            content_type: Some(\"text/html\".to_string()),\n            headers: get_asset_headers(vec![(\"cache-control\".to_string(), NO_CACHE_ASSET_CACHE_CONTROL.to_string())]),\n            fallback_for: vec![AssetFallbackConfig {\n                scope: \"/\".to_string(),\n                status_code: Some(StatusCode::OK),\n            }],\n            aliased_by: vec![\"/\".to_string()],\n            encodings: encodings.clone(),\n        },\n        AssetConfig::Pattern {\n            pattern: \"**/*.js\".to_string(),\n            content_type: Some(\"text/javascript\".to_string()),\n            headers: get_asset_headers(vec![(\"cache-control\".to_string(), IMMUTABLE_ASSET_CACHE_CONTROL.to_string())]),\n            encodings: encodings.clone(),\n        },\n        AssetConfig::Pattern {\n            pattern: \"**/*.css\".to_string(),\n            content_type: Some(\"text/css\".to_string()),\n            headers: get_asset_headers(vec![(\"cache-control\".to_string(), IMMUTABLE_ASSET_CACHE_CONTROL.to_string())]),\n            encodings,\n        },\n        AssetConfig::Pattern {\n            pattern: \"**/*.ico\".to_string(),\n            content_type: Some(\"image/x-icon\".to_string()),\n            headers: get_asset_headers(vec![(\"cache-control\".to_string(), IMMUTABLE_ASSET_CACHE_CONTROL.to_string())]),\n            encodings: vec![],\n        },\n        AssetConfig::Redirect {\n            from: \"/old-url\".to_string(),\n            to: \"/\".to_string(),\n            kind: AssetRedirectKind::Permanent,\n            headers: get_asset_headers(vec![\n                (\"content-type\".to_string(), \"text/plain\".to_string()),\n                (\"cache-control\".to_string(), NO_CACHE_ASSET_CACHE_CONTROL.to_string()),\n            ]),\n        },\n    ];\n\n    // 2. Collect all assets from the frontend build directory.\n    let mut assets = Vec::new();\n    collect_assets(&ASSETS_DIR, &mut assets);\n\n    // 3. Skip certification for the metrics endpoint.\n    HTTP_TREE.with(|tree| {\n        let mut tree = tree.borrow_mut();\n\n        let metrics_tree_path = HttpCertificationPath::exact(\"/metrics\");\n        let metrics_certification = HttpCertification::skip();\n        let metrics_tree_entry = HttpCertificationTreeEntry::new(metrics_tree_path, metrics_certification);\n\n        tree.insert(&metrics_tree_entry);\n    });\n\n    ASSET_ROUTER.with_borrow_mut(|asset_router| {\n        // 4. Certify the assets using the `certify_assets` function from the `ic-asset-certification` crate.\n        if let Err(err) = asset_router.certify_assets(assets, asset_configs) {\n            ic_cdk::trap(&format!(\"Failed to certify assets: {}\", err));\n        }\n\n        // 5. Set the canister's certified data.\n        set_certified_data(&asset_router.root_hash());\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Certified HTTP Responses in Rust for Internet Computer\nDESCRIPTION: Implements the query_handler function for serving certified HTTP responses. It checks for existing responses, falls back to a 'Not Found' response if necessary, and adds the required IC-Certificate header.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn query_handler(request: &HttpRequest, _params: &Params) -> HttpResponse<'static> {\n    let request_path = request.get_path().expect(\"Failed to get req path\");\n\n    // first check if there is a certified response for the request method and path\n    let (tree_path, certified_response) = RESPONSES\n        .with_borrow(|responses| {\n            responses\n                .get(&(request.method().to_string(), request_path.clone()))\n                .map(|response| {\n                    (\n                        HttpCertificationPath::exact(&request_path),\n                        response.clone(),\n                    )\n                })\n        })\n        // if there is no certified response, use the fallback response\n        .unwrap_or_else(|| {\n            FALLBACK_RESPONSES.with_borrow(|fallback_responses| {\n                fallback_responses\n                    .get(NOT_FOUND_PATH)\n                    .clone()\n                    .map(|response| (NOT_FOUND_TREE_PATH.to_owned(), response.clone()))\n                    .unwrap()\n            })\n        });\n\n    let mut response = certified_response.response;\n\n    HTTP_TREE.with_borrow(|http_tree| {\n        add_v2_certificate_header(\n            &data_certificate().expect(\"No data certificate available\"),\n            &mut response,\n            &http_tree\n                .witness(\n                    &HttpCertificationTreeEntry::new(&tree_path, certified_response.certification),\n                    &request_path,\n                )\n                .unwrap(),\n            &tree_path.to_expr_path(),\n        );\n    });\n\n    response\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CEL Expressions for HTTP Certification in Rust\nDESCRIPTION: Sets up Custom Expression Language (CEL) expressions using lazy_static to define what parts of requests and responses should be certified. Two different expression types are defined: a full CEL expression for todos and a response-only CEL expression for not found routes.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlazy_static! {\n    // define a full CEL expression that will certify the following:\n    // - request\n    //   - method\n    //   - body\n    //   - no headers\n    //   - no query parameters\n    // - response\n    //   - status code\n    //   - body\n    //   - all headers\n    // this CEL expression will be used for all routes except for the not found route\n    static ref TODO_CEL_EXPR_DEF: DefaultFullCelExpression<'static> = DefaultCelBuilder::full_certification()\n        .with_request_headers(vec![])\n        .with_request_query_parameters(vec![])\n        .with_response_certification(DefaultResponseCertification::response_header_exclusions(\n            vec![],\n        ))\n        .build();\n    static ref TODO_CEL_EXPR: String = TODO_CEL_EXPR_DEF.to_string();\n\n    // define a response-only CEL expression that will certify the following:\n    // - response\n    //   - status code\n    //   - body\n    //   - all headers\n    // this CEL expression will be used for the not found route\n    static ref NOT_FOUND_CEL_EXPR_DEF: DefaultResponseOnlyCelExpression<'static> = DefaultCelBuilder::response_only_certification()\n        .with_response_certification(DefaultResponseCertification::response_header_exclusions(\n            vec![],\n        ))\n        .build();\n    static ref NOT_FOUND_CEL_EXPR: String = NOT_FOUND_CEL_EXPR_DEF.to_string();\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Assets with AssetRouter in Rust\nDESCRIPTION: Illustrates how to serve assets using the AssetRouter, including creating and certifying an asset, handling an HTTP request, and adding a certificate header to the response.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::{HttpRequest, utils::add_v2_certificate_header, StatusCode};\nuse ic_asset_certification::{Asset, AssetConfig, AssetFallbackConfig, AssetRouter};\n\nlet mut asset_router = AssetRouter::default();\n\nlet asset = Asset::new(\n    \"index.html\",\n    b\"<html><body><h1>Hello World!</h1></body></html>\".as_slice(),\n);\n\nlet asset_config = AssetConfig::File {\n    path: \"index.html\".to_string(),\n    content_type: Some(\"text/html\".to_string()),\n    headers: vec![\n        (\"Cache-Control\".to_string(), \"public, no-cache, no-store\".to_string()),\n    ],\n    fallback_for: vec![AssetFallbackConfig {\n        scope: \"/\".to_string(),\n        status_code: Some(StatusCode::OK),\n    }],\n    aliased_by: vec![\"/\".to_string()],\n    encodings: vec![],\n};\n\nlet http_request = HttpRequest::get(\"/\").build();\n\nasset_router.certify_assets(vec![asset], vec![asset_config]).unwrap();\n\nlet (mut response, witness, expr_path) = asset_router.serve_asset(&http_request).unwrap();\n\n// This should normally be retrieved using `ic_cdk::api::data_certificate()`.\nlet data_certificate = vec![1, 2, 3];\n\nadd_v2_certificate_header(\n    data_certificate,\n    &mut response,\n    &witness,\n    &expr_path,\n);\n```\n\n----------------------------------------\n\nTITLE: Serving Certified Assets in DFINITY Canister\nDESCRIPTION: Implements an asset serving function that handles HTTP requests and returns certified responses. Uses the AssetRouter to serve assets with proper certification.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/assets/README.md#2025-04-20_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn serve_asset(req: &HttpRequest) -> HttpResponse<'static> {\n    ASSET_ROUTER.with_borrow(|asset_router| {\n        if let Ok(response) = asset_router.serve_asset(\n            &data_certificate().expect(\"No data certificate available\"),\n            req,\n        ) {\n            response\n        } else {\n            ic_cdk::trap(\"Failed to serve asset\");\n        }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Certifying Index Asset in Rust for IC Canister\nDESCRIPTION: This function specifically certifies the index.html file for a single-page application. It uses a wildcard certification path to allow the canister to return this file for any path that doesn't match an existing path in the tree.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlazy_static! {\n    static ref INDEX_REQ_PATH: &'static str = \"\";\n    static ref INDEX_TREE_PATH: HttpCertificationPath<'static> = HttpCertificationPath::wildcard(*INDEX_REQ_PATH);\n    static ref INDEX_FILE_PATH: &'static str = \"index.html\";\n}\n\nconst NO_CACHE_ASSET_CACHE_CONTROL: &str = \"public, no-cache, no-store\";\n\nfn certify_index_asset() {\n    let additional_headers = vec![\n        (\"content-type\".to_string(), \"text/html\".to_string()),\n        (\n            \"cache-control\".to_string(),\n            NO_CACHE_ASSET_CACHE_CONTROL.to_string(),\n        ),\n    ];\n\n    let identity_file = ASSETS_DIR\n        .get_file(*INDEX_FILE_PATH)\n        .expect(\"No index.html file found!!!\");\n    let body = identity_file.contents();\n\n    certify_asset(\n        body,\n        INDEX_FILE_PATH.to_string(),\n        &*INDEX_TREE_PATH,\n        INDEX_REQ_PATH.to_string(),\n        additional_headers,\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Full Request/Response Certification in Rust\nDESCRIPTION: Shows how to create a fully certified request and response pair using CelExpression with request headers, query parameters, and response headers certification.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse std::borrow::Cow;\nuse ic_http_certification::cel::{CelExpression, DefaultCelExpression, DefaultFullCelExpression, DefaultRequestCertification, DefaultResponseCertification};\n\nlet cel_expr = CelExpression::Default(DefaultCelExpression::Full(\n  DefaultFullCelExpression {\n    request: DefaultRequestCertification::new(\n      vec![\"Accept\", \"Accept-Encoding\", \"If-None-Match\"],\n      vec![\"foo\", \"bar\", \"baz\"],\n    ),\n    response: DefaultResponseCertification::certified_response_headers(vec![\n      \"ETag\",\n      \"Cache-Control\",\n    ]),\n  }));\n```\n\nLANGUAGE: protobuf\nCODE:\n```\ndefault_certification (\n  ValidationArgs {\n    request_certification: RequestCertification {\n      certified_request_headers: [\"Accept\", \"Accept-Encoding\", \"If-None-Match\"],\n      certified_query_parameters: [\"foo\", \"bar\", \"baz\"]\n    },\n    response_certification: ResponseCertification {\n      certified_response_headers: ResponseHeaderList {\n        headers: [\n          \"ETag\",\n          \"Cache-Control\"\n        ]\n      }\n    }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Asset in Rust for ICP Certification\nDESCRIPTION: Demonstrates how to create a new Asset object for certification with a simple HTML content. This shows the basic pattern for preparing an asset to be certified and served from an Internet Computer canister.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_asset_certification::Asset;\n\nlet asset = Asset::new(\n    \"index.html\",\n    b\"<html><body><h1>Hello World!</h1></body></html>\".as_slice(),\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Data Structures for Certified HTTP Responses in Rust\nDESCRIPTION: Defines the CertifiedHttpResponse struct and thread-local storage for responses and the HTTP certification tree. This setup allows for efficient storage and retrieval of certified responses.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstruct CertifiedHttpResponse<'a> {\n    response: HttpResponse<'a>,\n    certification: HttpCertification,\n}\n\nthread_local! {\n    static FALLBACK_RESPONSES: RefCell<HashMap<String, CertifiedHttpResponse<'static>>> = RefCell::new(HashMap::new());\n    static RESPONSES: RefCell<HashMap<(String, String), CertifiedHttpResponse<'static>>> = RefCell::new(HashMap::new());\n\n    static HTTP_TREE: RefCell<HttpCertificationTree> = RefCell::new(HttpCertificationTree::default());\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HashTree Enum in Rust for IC Certification\nDESCRIPTION: Implements the HashTree enum representing different node types in a hash tree structure used for certification. It includes variants for empty nodes, forks, labeled nodes, leaf nodes, and pruned nodes.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-certification/README.md#2025-04-20_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Clone, Debug, PartialEq, Eq)]\n#[cfg_attr(feature = \"serde\", derive(Serialize, Deserialize))]\npub enum HashTree {\n    Empty,\n    Fork(Box<HashTree>, Box<HashTree>),\n    Labeled(Vec<u8>, Box<HashTree>),\n    Leaf(Vec<u8>),\n    Pruned(Digest),\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Certificate Struct in Rust for IC Certification\nDESCRIPTION: Defines the Certificate struct which contains the tree and signature components of a certificate. It includes optional serialization support through the serde feature.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-certification/README.md#2025-04-20_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\n#[derive(Clone, Debug)]\n#[cfg_attr(feature = \"serde\", derive(Serialize, Deserialize))]\npub struct Certificate {\n    pub tree: HashTree,\n    pub signature: Vec<u8>,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Secure HTTP Responses for JSON API in Rust\nDESCRIPTION: A utility function for creating consistent HTTP responses with appropriate security headers based on OWASP recommendations. The function adds headers for content type, transport security, content type options, referrer policy, and cache control.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn create_response(status_code: StatusCode, body: Vec<u8>) -> HttpResponse<'static> {\n    HttpResponse::builder()\n        .with_status_code(status_code)\n        .with_headers(vec![\n            (\"content-type\".to_string(), \"application/json\".to_string()),\n            (\n                \"strict-transport-security\".to_string(),\n                \"max-age=31536000; includeSubDomains\".to_string(),\n            ),\n            (\"x-content-type-options\".to_string(), \"nosniff\".to_string()),\n            (\"referrer-policy\".to_string(), \"no-referrer\".to_string()),\n            (\n                \"cache-control\".to_string(),\n                \"no-store, max-age=0\".to_string(),\n            ),\n            (\"pragma\".to_string(), \"no-cache\".to_string()),\n        ])\n        .with_body(body)\n        .build()\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Asset Router with Multiple Assets and Configurations in Rust\nDESCRIPTION: This code snippet demonstrates the initial setup of an AssetRouter with various assets including HTML, JavaScript, and CSS files with multiple encodings (Brotli, Gzip) and configurations including content types, headers, fallbacks, and aliases.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::StatusCode;\nuse ic_asset_certification::{Asset, AssetConfig, AssetFallbackConfig, AssetRouter, AssetRedirectKind, AssetEncoding};\n\nlet mut asset_router = AssetRouter::default();\n\nlet assets = vec![\n    Asset::new(\n        \"index.html\",\n        b\"<html><body><h1>Hello World!</h1></body></html>\".as_slice(),\n    ),\n    Asset::new(\n        \"index.html.gz\",\n        &[0, 1, 2, 3, 4, 5]\n    ),\n    Asset::new(\n        \"index.html.br\",\n        &[6, 7, 8, 9, 10, 11]\n    ),\n    Asset::new(\n        \"app.js\",\n        b\"console.log('Hello World!');\".as_slice(),\n    ),\n    Asset::new(\n        \"app.js.gz\",\n        &[12, 13, 14, 15, 16, 17],\n    ),\n    Asset::new(\n        \"app.js.br\",\n        &[18, 19, 20, 21, 22, 23],\n    ),\n    Asset::new(\n        \"css/app-ba74b708.css\",\n        b\"html,body{min-height:100vh;}\".as_slice(),\n    ),\n    Asset::new(\n        \"css/app-ba74b708.css.gz\",\n        &[24, 25, 26, 27, 28, 29],\n    ),\n    Asset::new(\n        \"css/app-ba74b708.css.br\",\n        &[30, 31, 32, 33, 34, 35],\n    ),\n];\n\nlet asset_configs = vec![\n    AssetConfig::File {\n        path: \"index.html\".to_string(),\n        content_type: Some(\"text/html\".to_string()),\n        headers: vec![(\n            \"cache-control\".to_string(),\n            \"public, no-cache, no-store\".to_string(),\n        )],\n        fallback_for: vec![AssetFallbackConfig {\n            scope: \"/\".to_string(),\n            status_code: Some(StatusCode::OK),\n        }],\n        aliased_by: vec![\"/\".to_string()],\n        encodings: vec![\n            AssetEncoding::Brotli.default_config(),\n            AssetEncoding::Gzip.default_config(),\n        ],\n    },\n    AssetConfig::Pattern {\n        pattern: \"**/*.js\".to_string(),\n        content_type: Some(\"text/javascript\".to_string()),\n        headers: vec![(\n            \"cache-control\".to_string(),\n            \"public, max-age=31536000, immutable\".to_string(),\n        )],\n        encodings: vec![\n            AssetEncoding::Brotli.default_config(),\n            AssetEncoding::Gzip.default_config(),\n        ],\n    },\n    AssetConfig::Pattern {\n        pattern: \"**/*.css\".to_string(),\n        content_type: Some(\"text/css\".to_string()),\n        headers: vec![(\n            \"cache-control\".to_string(),\n            \"public, max-age=31536000, immutable\".to_string(),\n        )],\n        encodings: vec![\n            AssetEncoding::Brotli.default_config(),\n            AssetEncoding::Gzip.default_config(),\n        ],\n    },\n    AssetConfig::Redirect {\n        from: \"/old\".to_string(),\n        to: \"/new\".to_string(),\n        kind: AssetRedirectKind::Permanent,\n        headers: vec![(\"content-type\".to_string(), \"text/plain\".to_string())],\n    },\n];\n\nasset_router.certify_assets(assets, asset_configs).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Initializing AssetRouter with HttpCertificationTree in Rust\nDESCRIPTION: Demonstrates how to initialize an AssetRouter with an HttpCertificationTree, which is useful for certifying HttpRequests and HttpResponses outside of the AssetRouter.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{cell::RefCell, rc::Rc};\nuse ic_http_certification::HttpCertificationTree;\nuse ic_asset_certification::AssetRouter;\n\nlet mut http_certification_tree: Rc<RefCell<HttpCertificationTree>> = Default::default();\nlet mut asset_router = AssetRouter::default();\n\nasset_router.init_with_tree(http_certification_tree.clone());\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP Responses with Security Headers\nDESCRIPTION: Defines functions to create HTTP responses with appropriate security headers for static assets, including content security policy, referrer policy, and other security-focused headers.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn get_asset_headers(\n    additional_headers: Vec<HeaderField>,\n    content_length: usize,\n    cel_expr: String,\n) -> Vec<(String, String)> {\n    // set up the default headers and include additional headers provided by the caller\n    let mut headers = vec![\n        (\"strict-transport-security\".to_string(), \"max-age=31536000; includeSubDomains\".to_string()),\n        (\"x-frame-options\".to_string(), \"DENY\".to_string()),\n        (\"x-content-type-options\".to_string(), \"nosniff\".to_string()),\n        (\"content-security-policy\".to_string(), \"default-src 'self'; form-action 'self'; object-src 'none'; frame-ancestors 'none'; upgrade-insecure-requests; block-all-mixed-content\".to_string()),\n        (\"referrer-policy\".to_string(), \"no-referrer\".to_string()),\n        (\"permissions-policy\".to_string(), \"accelerometer=(),ambient-light-sensor=(),autoplay=(),battery=(),camera=(),display-capture=(),document-domain=(),encrypted-media=(),fullscreen=(),gamepad=(),geolocation=(),gyroscope=(),layout-animations=(self),legacy-image-formats=(self),magnetometer=(),microphone=(),midi=(),oversized-images=(self),payment=(),picture-in-picture=(),publickey-credentials-get=(),speaker-selection=(),sync-xhr=(self),unoptimized-images=(self),unsized-media=(self),usb=(),screen-wake-lock=(),web-share=(),xr-spatial-tracking=()\".to_string()),\n        (\"cross-origin-embedder-policy\".to_string(), \"require-corp\".to_string()),\n        (\"cross-origin-opener-policy\".to_string(), \"same-origin\".to_string()),\n        (\"content-length\".to_string(), content_length.to_string()),\n        (CERTIFICATE_EXPRESSION_HEADER_NAME.to_string(), cel_expr),\n    ];\n    headers.extend(additional_headers);\n\n    headers\n}\n\nfn create_asset_response(\n    additional_headers: Vec<HeaderField>,\n    body: &[u8],\n    cel_expr: String,\n) -> HttpResponse {\n    let headers = get_asset_headers(additional_headers, body.len(), cel_expr);\n\n    HttpResponse::ok(body, headers).build()\n}\n```\n\n----------------------------------------\n\nTITLE: Certifying Not Found Response in Rust for Internet Computer\nDESCRIPTION: Implements the certification process for the 'Not Found' response, which differs slightly from regular responses. It uses a wildcard path and a different CEL expression type.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn certify_not_found_response() {\n    let body = ErrorResponse::not_found().encode();\n    let mut response = create_response(StatusCode::NOT_FOUND, body);\n\n    let tree_path = HttpCertificationPath::wildcard(NOT_FOUND_PATH);\n\n    // insert the `Ic-CertificationExpression` header with the stringified CEL expression as its value\n    response.add_header((\n        CERTIFICATE_EXPRESSION_HEADER_NAME.to_string(),\n        NOT_FOUND_CEL_EXPR.clone(),\n    ));\n\n    // create the certification for this response and CEL expression pair\n    let certification =\n        HttpCertification::response_only(&NOT_FOUND_CEL_EXPR_DEF, &response, None).unwrap();\n\n    FALLBACK_RESPONSES.with_borrow_mut(|responses| {\n        responses.insert(\n            NOT_FOUND_PATH.to_string(),\n            CertifiedHttpResponse {\n                response,\n                certification,\n            },\n        );\n    });\n\n    HTTP_TREE.with_borrow_mut(|http_tree| {\n        // insert the certification into the certification tree\n        http_tree.insert(&HttpCertificationTreeEntry::new(tree_path, &certification));\n\n        // set the canister's certified data\n        set_certified_data(&http_tree.root_hash());\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Certifying Encoded Assets with HTTP Compression\nDESCRIPTION: Certifies assets with specific encodings (gzip, brotli) by checking for encoded versions of files, creating responses with appropriate content-encoding headers, and storing them in a separate encoded responses map.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nfn certify_asset_with_encoding(\n    asset_file_path: &str,\n    asset_tree_path: &HttpCertificationPath,\n    asset_req_path: String,\n    encoding: &str,\n    additional_headers: Vec<HeaderField>,\n) {\n    // check if the file exists before certifying it\n    if let Some(file) = ASSETS_DIR.get_file(format!(\"{}.{}\", asset_file_path, encoding)) {\n        let body = file.contents();\n\n        // add the content encoding header\n        let mut headers = vec![(\"content-encoding\".to_string(), encoding.to_string())];\n        headers.extend(additional_headers);\n\n        // create the response\n        let response = create_asset_response(headers, body, ASSET_CEL_EXPR.clone());\n\n        // certify the response\n        let certification =\n            HttpCertification::response_only(&ASSET_CEL_EXPR_DEF, &response, None).unwrap();\n\n        HTTP_TREE.with_borrow_mut(|http_tree| {\n            // add the certification to the certification tree\n            http_tree.insert(&HttpCertificationTreeEntry::new(\n                asset_tree_path,\n                &certification,\n            ));\n        });\n\n        ENCODED_RESPONSES.with_borrow_mut(|responses| {\n            // store the response for later retrieval\n            responses.insert(\n                (asset_req_path, encoding.to_string()),\n                CertifiedHttpResponse {\n                    response,\n                    certification,\n                },\n            );\n        });\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Route Storage in Rust Internet Computer Canister\nDESCRIPTION: Sets up thread-local storage for HTTP request routers, separating query and update call handlers. Uses HashMaps to store routers for different HTTP methods, with each router containing path-to-handler mappings.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nthread_local! {\n    static QUERY_ROUTER: RefCell<HashMap<String, Router<RouteHandler>>> = RefCell::new(HashMap::new());\n    static UPDATE_ROUTER: RefCell<HashMap<String, Router<RouteHandler>>> = RefCell::new(HashMap::new());\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Security Headers for Asset Responses in Rust\nDESCRIPTION: Implements a function to generate secure HTTP headers based on OWASP security guidelines. Includes headers for transport security, content security policy, frame options, and other security measures.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/assets/README.md#2025-04-20_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nfn get_asset_headers(additional_headers: Vec<HeaderField>) -> Vec<HeaderField> {\n    // set up the default headers and include additional headers provided by the caller\n    let mut headers = vec![\n        (\"strict-transport-security\".to_string(), \"max-age=31536000; includeSubDomains\".to_string()),\n        (\"x-frame-options\".to_string(), \"DENY\".to_string()),\n        (\"x-content-type-options\".to_string(), \"nosniff\".to_string()),\n        (\"content-security-policy\".to_string(), \"default-src 'self'; img-src 'self' data:; form-action 'self'; object-src 'none'; frame-ancestors 'none'; upgrade-insecure-requests; block-all-mixed-content\".to_string()),\n        (\"referrer-policy\".to_string(), \"no-referrer\".to_string()),\n        (\"permissions-policy\".to_string(), \"accelerometer=(),ambient-light-sensor=(),autoplay=(),battery=(),camera=(),display-capture=(),document-domain=(),encrypted-media=(),fullscreen=(),gamepad=(),geolocation=(),gyroscope=(),layout-animations=(self),legacy-image-formats=(self),magnetometer=(),microphone=(),midi=(),oversized-images=(self),payment=(),picture-in-picture=(),publickey-credentials-get=(),speaker-selection=(),sync-xhr=(self),unoptimized-images=(self),unsized-media=(self),usb=(),screen-wake-lock=(),web-share=(),xr-spatial-tracking=()\".to_string()),\n        (\"cross-origin-embedder-policy\".to_string(), \"require-corp\".to_string()),\n        (\"cross-origin-opener-policy\".to_string(), \"same-origin\".to_string()),\n    ];\n    headers.extend(additional_headers);\n\n    headers\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a 404 Asset with Multiple Fallbacks and Aliases in Rust\nDESCRIPTION: Shows how to configure a 404 error page with multiple fallback scopes and aliases. This setup allows the asset to serve as a not-found response for different URL paths and to be accessible through various alternative paths.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::StatusCode;\nuse ic_asset_certification::{AssetConfig, AssetFallbackConfig};\n\nlet config = AssetConfig::File {\n    path: \"404.html\".to_string(),\n    content_type: Some(\"text/html\".to_string()),\n    headers: vec![\n        (\"Cache-Control\".to_string(), \"public, no-cache, no-store\".to_string()),\n    ],\n    fallback_for: vec![\n        AssetFallbackConfig {\n            scope: \"/css\".to_string(),\n            status_code: Some(StatusCode::NOT_FOUND),\n        },\n        AssetFallbackConfig {\n            scope: \"/js\".to_string(),\n            status_code: Some(StatusCode::NOT_FOUND),\n        },\n    ],\n    aliased_by: vec![\n        \"/404\".to_string(),\n        \"/404/\".to_string(),\n        \"/404.html\".to_string(),\n        \"/not-found\".to_string(),\n        \"/not-found/\".to_string(),\n        \"/not-found/index.html\".to_string(),\n    ],\n    encodings: vec![\n        AssetEncoding::Brotli.default(),\n        AssetEncoding::Gzip.default(),\n    ],\n};\n```\n\n----------------------------------------\n\nTITLE: Certifying Individual Assets in Rust for IC Canister\nDESCRIPTION: This function certifies a single asset for an Internet Computer canister. It takes the asset's body, file path, tree path, request path, and additional headers as parameters. The function creates an HTTP response and inserts it into the certification tree.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn certify_asset(\n    body: &[u8],\n    asset_file_path: String,\n    asset_tree_path: &HttpCertificationPath,\n    asset_req_path: String,\n    additional_headers: Vec<(String, String)>,\n) {\n    let headers = get_asset_headers(\n        additional_headers,\n        body.len(),\n        DefaultCelBuilder::default().to_string(),\n    );\n    let response = HttpResponse::ok(body.to_vec(), headers).build();\n    let certification = HttpCertification::cert_body_hash();\n\n    HTTP_TREE.with_borrow_mut(|http_tree| {\n        http_tree.insert(&HttpCertificationTreeEntry::new(\n            asset_tree_path,\n            &certification,\n        ));\n    });\n\n    RESPONSES.with_borrow_mut(|responses| {\n        responses.insert(\n            asset_req_path,\n            CertifiedHttpResponse {\n                certification,\n                response,\n            },\n        );\n    });\n\n    certify_encoded_asset(\n        body,\n        asset_file_path,\n        asset_tree_path,\n        asset_req_path,\n        additional_headers,\n        \"br\",\n    );\n    certify_encoded_asset(\n        body,\n        asset_file_path,\n        asset_tree_path,\n        asset_req_path,\n        additional_headers,\n        \"gzip\",\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Certified Response Interface in Candid\nDESCRIPTION: A Candid service definition that specifies the structure for certified responses from a canister, including data, certificate, and witness fields.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/certificate-verification-js/README.md#2025-04-20_snippet_0\n\nLANGUAGE: candid\nCODE:\n```\ntype certified_response = record {\n  \"data\" : nat32;\n  \"certificate\" : blob;\n  \"witness\" : blob;\n};\n\nservice : {\n  \"get_data\" : () -> (certified_response) query;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Full Certification with Request Parameters and Headers\nDESCRIPTION: Creates a full certification that includes both request and response, with specific request headers and query parameters to be certified.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::DefaultCelBuilder;\n\nlet cel_expr = DefaultCelBuilder::full_certification()\n    .with_request_headers(vec![\"Accept\", \"Accept-Encoding\", \"If-None-Match\"])\n    .with_request_query_parameters(vec![\"foo\", \"bar\", \"baz\"])\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Adding Certification Skips in Rust for IC Canister\nDESCRIPTION: This function demonstrates how to skip certification for certain routes, such as a metrics endpoint. It's useful for scenarios where the response content is unpredictable or not security-sensitive.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nconst METRICS_REQ_PATH: &str = \"/metrics\";\n\nfn add_certification_skips() {\n    let metrics_tree_path = HttpCertificationPath::exact(METRICS_REQ_PATH);\n    let metrics_certification = HttpCertification::skip();\n\n    HTTP_TREE.with_borrow_mut(|http_tree| {\n        http_tree.insert(&HttpCertificationTreeEntry::new(\n            metrics_tree_path,\n            &metrics_certification,\n        ));\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring File Patterns in Rust using AssetConfig\nDESCRIPTION: Demonstrates how to configure file patterns for asset management using the AssetConfig struct. It shows setting up a pattern for JavaScript files with specific content type, caching headers, and encoding options.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::StatusCode;\nuse ic_asset_certification::AssetConfig;\n\nlet config = AssetConfig::Pattern {\n    pattern: \"js/*.js\".to_string(),\n    content_type: Some(\"application/javascript\".to_string()),\n    headers: vec![\n        (\"Cache-Control\".to_string(), \"public, max-age=31536000, immutable\".to_string()),\n    ],\n    encodings: vec![\n        AssetEncoding::Brotli.default(),\n        AssetEncoding::Gzip.default(),\n    ],\n};\n```\n\n----------------------------------------\n\nTITLE: Recursively Collecting Assets for Certification in Rust\nDESCRIPTION: Implements a function to recursively traverse directories and collect all assets, converting them to the Asset type used by the ic-asset-certification crate.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/assets/README.md#2025-04-20_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n/// Rescursively collect all assets from the provided directory\nfn collect_assets<'content, 'path>(\n    dir: &'content Dir<'path>,\n    assets: &mut Vec<Asset<'content, 'path>>,\n) {\n    for file in dir.files() {\n        assets.push(Asset::new(file.path().to_string_lossy(), file.contents()));\n    }\n\n    for dir in dir.dirs() {\n        collect_assets(dir, assets);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Todo Items Handler in Rust Internet Computer Canister\nDESCRIPTION: Handles POST requests to create new todo items. It assigns a unique ID, stores the item in a thread-local collection, re-certifies responses, and returns the created item with a 201 Created status code.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nfn create_todo_item_handler(req: &HttpRequest, _params: &Params) -> HttpResponse<'static> {\n    let req_body: CreateTodoItemRequest = json_decode(req.body());\n\n    let id = NEXT_TODO_ID.with_borrow_mut(|f| {\n        let id = *f;\n        *f += 1;\n        id\n    });\n\n    let todo_item = TODO_ITEMS.with_borrow_mut(|items| {\n        let todo_item = TodoItem {\n            id,\n            title: req_body.title,\n            completed: false,\n        };\n\n        items.insert(id, todo_item.clone());\n\n        todo_item\n    });\n\n    certify_list_todos_response();\n\n    let body = CreateTodoItemResponse::ok(&todo_item).encode();\n    create_response(StatusCode::CREATED, body)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Response-Only Certification in Rust\nDESCRIPTION: Certifies only the response body and status code using DefaultCelBuilder, without certifying any response headers.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::DefaultCelBuilder;\n\nlet cel_expr = DefaultCelBuilder::response_only_certification().build();\n```\n\n----------------------------------------\n\nTITLE: Certifying HTTP Responses in Rust for Internet Computer\nDESCRIPTION: Implements the certify_response function, which handles the certification process for HTTP responses. This includes removing existing responses, calculating certifications, and updating the certification tree.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn certify_response(\n    request: HttpRequest,\n    response: &mut HttpResponse<'static>,\n    tree_path: &HttpCertificationPath,\n) {\n    let request_path = request.get_path().unwrap();\n\n    // retrieve and remove any existing response for the request method and path\n    let existing_response = RESPONSES.with_borrow_mut(|responses| {\n        responses.remove(&(request.method().to_string(), request_path.clone()))\n    });\n\n    // if there is an existing response, remove its certification from the certification tree\n    if let Some(existing_response) = existing_response {\n        HTTP_TREE.with_borrow_mut(|http_tree| {\n            http_tree.delete(&HttpCertificationTreeEntry::new(\n                tree_path.clone(),\n                &existing_response.certification,\n            ));\n        })\n    }\n\n    // insert the `Ic-CertificationExpression` header with the stringified CEL expression as its value\n    response.add_header((\n        CERTIFICATE_EXPRESSION_HEADER_NAME.to_string(),\n        TODO_CEL_EXPR.clone(),\n    ));\n\n    // create the certification for this response and CEL expression pair\n    let certification =\n        HttpCertification::full(&TODO_CEL_EXPR_DEF, &request, &response, None).unwrap();\n\n    RESPONSES.with_borrow_mut(|responses| {\n        // store the response for later retrieval\n        responses.insert(\n            (request.method().to_string(), request_path),\n            CertifiedHttpResponse {\n                response: response.clone(),\n                certification: certification.clone(),\n            },\n        );\n    });\n\n    HTTP_TREE.with_borrow_mut(|http_tree| {\n        // insert the certification into the certification tree\n        http_tree.insert(&HttpCertificationTreeEntry::new(tree_path, &certification));\n\n        // set the canister's certified data\n        set_certified_data(&http_tree.root_hash());\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Todo Items Handler in Rust Internet Computer Canister\nDESCRIPTION: Handles PATCH requests to update existing todo items. It parses the item ID from the URL parameters, updates the specified fields, re-certifies the list response, and returns a success message with a 200 OK status code.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nfn update_todo_item_handler(req: &HttpRequest, params: &Params) -> HttpResponse<'static> {\n    let req_body: UpdateTodoItemRequest = json_decode(req.body());\n    let id: u32 = params.get(\"id\").unwrap().parse().unwrap();\n\n    TODO_ITEMS.with_borrow_mut(|items| {\n        let item = items.get_mut(&id).unwrap();\n\n        if let Some(title) = req_body.title {\n            item.title = title;\n        }\n\n        if let Some(completed) = req_body.completed {\n            item.completed = completed;\n        }\n    });\n\n    certify_list_todos_response();\n\n    let body = UpdateTodoItemResponse::ok(&()).encode();\n    create_response(StatusCode::OK, body)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Response-Only Certification\nDESCRIPTION: Shows how to skip request certification entirely and only certify the response with specific header exclusions, which is appropriate when the response is determined solely by the request path.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::{DefaultCelBuilder, DefaultResponseCertification};\n\nlet cel_expr = DefaultCelBuilder::response_only_certification()\n    .with_response_certification(DefaultResponseCertification::response_header_exclusions(vec![\n        \"Date\",\n        \"Cookie\",\n        \"Set-Cookie\",\n    ]))\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Creating a Partially Certified Request with Minimal Certification\nDESCRIPTION: Shows how to create a CEL expression that certifies only the request body and method along with specified response headers, omitting certification of request headers and query parameters.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::{DefaultCelBuilder, DefaultResponseCertification};\n\nlet cel_expr = DefaultCelBuilder::full_certification()\n    .with_response_certification(DefaultResponseCertification::certified_response_headers(vec![\n        \"Cache-Control\",\n        \"ETag\",\n    ]))\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Deleting Todo Items Handler in Rust Internet Computer Canister\nDESCRIPTION: Handles DELETE requests to remove todo items. It extracts the item ID from URL parameters, removes the item from the collection, re-certifies the list response, and returns a 204 No Content status code.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nfn delete_todo_item_handler(_req: &HttpRequest, params: &Params) -> HttpResponse<'static> {\n    let id: u32 = params.get(\"id\").unwrap().parse().unwrap();\n\n    TODO_ITEMS.with_borrow_mut(|items| {\n        items.remove(&id);\n    });\n\n    certify_list_todos_response();\n\n    let body = DeleteTodoItemResponse::ok(&()).encode();\n    create_response(StatusCode::NO_CONTENT, body)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Full Response Header Certification with Exclusions in Rust\nDESCRIPTION: Creates a CEL expression that certifies specific request components and all response headers by using the response_header_exclusions function with an empty array. This approach certifies all response headers since no exclusions are specified.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nuse std::borrow::Cow;\nuse ic_http_certification::cel::{CelExpression, DefaultCelExpression, DefaultFullCelExpression, DefaultRequestCertification, DefaultResponseCertification};\n\nlet cel_expr = CelExpression::Default(DefaultCelExpression::Full(\n  DefaultFullCelExpression {\n    request: DefaultRequestCertification::new(\n      vec![\"Accept\", \"Accept-Encoding\", \"If-None-Match\"],\n      vec![\"foo\", \"bar\", \"baz\"],\n    ),\n    response: DefaultResponseCertification::response_header_exclusions(vec![]),\n  }));\n```\n\n----------------------------------------\n\nTITLE: Setting Up Query Route Handlers in Rust Internet Computer Canister\nDESCRIPTION: Configures routing for query calls, directing state-modifying methods (POST, PATCH, DELETE) to the upgrade handler and all other methods to the standard query handler. Uses the matchit crate for path pattern matching.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nfn prepare_query_handlers() {\n    insert_query_route(\"POST\", \"/todos\", upgrade_to_update_call_handler);\n    insert_query_route(\"PATCH\", \"/todos/{id}\", upgrade_to_update_call_handler);\n    insert_query_route(\"DELETE\", \"/todos/{id}\", upgrade_to_update_call_handler);\n\n    insert_query_route(\"GET\", \"/{*p}\", query_handler);\n    [\"HEAD\", \"PUT\", \"OPTIONS\", \"TRACE\", \"CONNECT\"]\n        .iter()\n        .for_each(|method| {\n            insert_query_route(method, \"/{*p}\", query_handler);\n        });\n}\n\nfn insert_query_route(method: &str, path: &str, route_handler: RouteHandler) {\n    QUERY_ROUTER.with_borrow_mut(|query_router| {\n        let router = query_router.entry(method.to_string()).or_default();\n\n        router.insert(path, route_handler).unwrap();\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Certifying Asset Responses for HTTP Certification\nDESCRIPTION: Certifies asset responses by creating a response with security headers, certifying it using a certification expression, and storing it in a certification tree for later verification.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nfn certify_asset_response(\n    body: &'static [u8],\n    additional_headers: Vec<HeaderField>,\n    asset_tree_path: &HttpCertificationPath,\n    asset_req_path: String,\n) {\n    // create the response\n    let response = create_asset_response(additional_headers, body, ASSET_CEL_EXPR.clone());\n\n    // certify the response\n    let certification =\n        HttpCertification::response_only(&ASSET_CEL_EXPR_DEF, &response, None).unwrap();\n\n    HTTP_TREE.with_borrow_mut(|http_tree| {\n        // add the certification to the certification tree\n        http_tree.insert(&HttpCertificationTreeEntry::new(\n            asset_tree_path,\n            &certification,\n        ));\n    });\n\n    RESPONSES.with_borrow_mut(|responses| {\n        // store the response for later retrieval\n        responses.insert(\n            asset_req_path,\n            CertifiedHttpResponse {\n                response,\n                certification,\n            },\n        );\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Response-Only HTTP Certification\nDESCRIPTION: Implements HTTP certification for just the response, without including the request, certifying specific response headers like Cache-Control and ETag.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::{HttpCertification, HttpResponse, DefaultCelBuilder, DefaultResponseCertification};\n\nlet cel_expr = DefaultCelBuilder::response_only_certification()\n    .with_response_certification(DefaultResponseCertification::certified_response_headers(vec![\n        \"Cache-Control\",\n        \"ETag\",\n    ]))\n    .build();\n\nlet response = HttpResponse {\n    status_code: 200,\n    headers: vec![\n        (\"Cache-Control\".to_string(), \"no-cache\".to_string()),\n        (\"ETag\".to_string(), \"123456789\".to_string()),\n        (\"IC-CertificateExpression\".to_string(), cel_expr.to_string()),\n    ],\n    body: vec![1, 2, 3, 4, 5, 6],\n    upgrade: None,\n};\n\nlet certification = HttpCertification::response_only(&cel_expr, &response, None).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Setting Up Update Route Handlers in Rust Internet Computer Canister\nDESCRIPTION: Configures routing for update calls, mapping each state-modifying HTTP method to its specific handler function. Uses the matchit crate for path matching and captures URL parameters.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nfn prepare_update_handlers() {\n    insert_update_route(\"POST\", TODOS_PATH, create_todo_item_handler);\n    insert_update_route(\"PATCH\", \"/todos/{id}\", update_todo_item_handler);\n    insert_update_route(\"DELETE\", \"/todos/{id}\", delete_todo_item_handler);\n\n    [\"GET\", \"HEAD\", \"PUT\", \"OPTIONS\", \"TRACE\", \"CONNECT\"]\n        .iter()\n        .for_each(|method| {\n            insert_update_route(method, \"/{*p}\", no_update_call_handler);\n        });\n}\n\nfn insert_update_route(method: &str, path: &str, route_handler: RouteHandler) {\n    UPDATE_ROUTER.with_borrow_mut(|update_router| {\n        let router = update_router.entry(method.to_string()).or_default();\n\n        router.insert(path, route_handler).unwrap();\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Update Calls for Read-Only Endpoints in Rust\nDESCRIPTION: Implements a handler for update calls to endpoints that don't update state, returning a bad request error to prevent unnecessary cycle costs.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn no_update_call_handler(_http_request: &HttpRequest, _params: &Params) -> HttpResponse<'static> {\n    create_response(StatusCode::BAD_REQUEST, vec![])\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Wildcard Path for HTTP Certification Tree\nDESCRIPTION: Defines a wildcard path for HTTP certification that matches any URL starting with the specified prefix, useful for 404 responses or fallbacks.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::HttpCertificationPath;\n\nlet path = HttpCertificationPath::wildcard(\"/js\");\n```\n\n----------------------------------------\n\nTITLE: Defining CEL Expressions for Asset Certification in Rust\nDESCRIPTION: This snippet shows the definition of Common Expression Language (CEL) expressions used for certifying static assets. It sets up a default response-only certification with no header exclusions.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlazy_static! {\n    static ref ASSET_CEL_EXPR_DEF: DefaultResponseOnlyCelExpression<'static> =\n        DefaultCelBuilder::response_only_certification()\n            .with_response_certification(DefaultResponseCertification::response_header_exclusions(\n                vec![],\n            ))\n            .build();\n    static ref ASSET_CEL_EXPR: String = ASSET_CEL_EXPR_DEF.to_string();\n}\n```\n\n----------------------------------------\n\nTITLE: Upgrading Query to Update Call in Rust Internet Computer Canister\nDESCRIPTION: Handles upgrades from query calls to update calls, which is necessary when state changes are required. This function returns an HTTP response that signals to the HTTP gateway that the request should be remade as an update call.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn upgrade_to_update_call_handler(\n    _http_request: &HttpRequest,\n    _params: &Params,\n) -> HttpResponse<'static> {\n    HttpResponse::builder().with_upgrade(true).build()\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Metrics Without Certification in Rust for Internet Computer\nDESCRIPTION: This function serves metrics data (number of assets, fallback assets, and cycle balance) as JSON without certification. It uses the `ic-http-certification` library to add appropriate headers to indicate the certification is skipped, which is acceptable for non-sensitive metrics data.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/assets/README.md#2025-04-20_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn serve_metrics() -> HttpResponse<'static> {\n    ASSET_ROUTER.with_borrow(|asset_router| {\n        let metrics = Metrics {\n            num_assets: asset_router.get_assets().len(),\n            num_fallback_assets: asset_router.get_fallback_assets().len(),\n            cycle_balance: canister_balance(),\n        };\n        let body = serde_json::to_vec(&metrics).expect(\"Failed to serialize metrics\");\n        let headers = get_asset_headers(vec![\n            (\n                CERTIFICATE_EXPRESSION_HEADER_NAME.to_string(),\n                DefaultCelBuilder::skip_certification().to_string(),\n            ),\n            (\"content-type\".to_string(), \"application/json\".to_string()),\n            (\n                \"cache-control\".to_string(),\n                NO_CACHE_ASSET_CACHE_CONTROL.to_string(),\n            ),\n        ]);\n        let mut response = HttpResponse::builder()\n            .with_status_code(200)\n            .with_body(body)\n            .with_headers(headers)\n            .build();\n\n        HTTP_TREE.with(|tree| {\n            let tree = tree.borrow();\n\n            let metrics_tree_path = HttpCertificationPath::exact(\"/metrics\");\n            let metrics_certification = HttpCertification::skip();\n            let metrics_tree_entry =\n                HttpCertificationTreeEntry::new(&metrics_tree_path, metrics_certification);\n            add_v2_certificate_header(\n                &data_certificate().expect(\"No data certificate available\"),\n                &mut response,\n                &tree.witness(&metrics_tree_entry, \"/metrics\").unwrap(),\n                &metrics_tree_path.to_expr_path(),\n            );\n\n            response\n        })\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Partially Certified Request in Rust\nDESCRIPTION: Demonstrates creating a partially certified request where only the request body and method are certified, with empty arrays for headers and query parameters.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nuse std::borrow::Cow;\nuse ic_http_certification::cel::{CelExpression, DefaultCelExpression, DefaultFullCelExpression, DefaultRequestCertification, DefaultResponseCertification};\n\nlet cel_expr = CelExpression::Default(DefaultCelExpression::Full(\n  DefaultFullCelExpression {\n    request: DefaultRequestCertification::new(\n      vec![],\n      vec![],\n    ),\n    response: DefaultResponseCertification::certified_response_headers(vec![\n      \"ETag\",\n      \"Cache-Control\",\n    ]),\n  }));\n```\n\nLANGUAGE: protobuf\nCODE:\n```\ndefault_certification (\n  ValidationArgs {\n    request_certification: RequestCertification {\n      certified_request_headers: [],\n      certified_query_parameters: []\n    },\n    response_certification: ResponseCertification {\n      certified_response_headers: ResponseHeaderList {\n        headers: [\n          \"ETag\",\n          \"Cache-Control\"\n        ]\n      }\n    }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Certified Data in Rust for IC Canister\nDESCRIPTION: This function sets the canister's certified data to ensure the correct data is signed during the next consensus round. It uses the root hash of the HTTP certification tree.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nfn update_certified_data() {\n    HTTP_TREE.with_borrow(|http_tree| {\n        set_certified_data(&http_tree.root_hash());\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Redirects in Rust using AssetConfig\nDESCRIPTION: Shows how to set up a permanent redirect from '/old' to '/new' using the AssetConfig::Redirect variant. It includes setting the redirect kind and content type header.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_asset_certification::{AssetConfig, AssetRedirectKind};\n\nlet config = AssetConfig::Redirect {\n  from: \"/old\".to_string(),\n  to: \"/new\".to_string(),\n  kind: AssetRedirectKind::Permanent,\n  headers: vec![\n    (\"content-type\".to_string(), \"text/plain; charset=utf-8\".to_string()),\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Response-Only Certification in Rust\nDESCRIPTION: Shows how to skip request certification entirely and create a response-only certification using the ResponseOnly variant.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nuse std::borrow::Cow;\nuse ic_http_certification::cel::{CelExpression, DefaultCelExpression, DefaultResponseOnlyCelExpression, DefaultResponseCertification};\n\nlet cel_expr = CelExpression::Default(DefaultCelExpression::ResponseOnly(\n  DefaultResponseOnlyCelExpression {\n    response: DefaultResponseCertification::certified_response_headers(vec![\n      \"ETag\",\n      \"Cache-Control\",\n    ]),\n  }));\n```\n\nLANGUAGE: protobuf\nCODE:\n```\ndefault_certification (\n  ValidationArgs {\n    no_request_certification: Empty {},\n    response_certification: ResponseCertification {\n      certified_response_headers: ResponseHeaderList {\n        headers: [\n          \"ETag\",\n          \"Cache-Control\"\n        ]\n      }\n    }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Certifying Assets Using Glob Patterns with Content Type\nDESCRIPTION: Certifies multiple assets that match a glob pattern with a specific content type, processing each matching file by computing paths and applying appropriate headers including cache-control directives.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nfn certify_asset_glob(glob: &str, content_type: &str) {\n    // iterate over every asset matching the glob\n    for identity_file in ASSETS_DIR\n        .find(glob)\n        .unwrap()\n        .map(|entry| entry.as_file().unwrap())\n    {\n        // compute the different paths needed for this asset\n        let asset_file_path = identity_file.path().to_str().unwrap().to_string();\n        let asset_req_path = if !asset_file_path.starts_with(\"/\") {\n            format!(\"/{}\" , asset_file_path)\n        } else {\n            asset_file_path.clone()\n        };\n        let asset_tree_path = HttpCertificationPath::exact(&asset_req_path);\n\n        // add the content-type and cache-control headers\n        let additional_headers = vec![\n            (\"content-type\".to_string(), content_type.to_string()),\n            (\n                \"cache-control\".to_string(),\n                \"public, max-age=31536000, immutable\".to_string(),\n            ),\n        ];\n```\n\n----------------------------------------\n\nTITLE: HTTP Request Handler in Rust for IC Canister\nDESCRIPTION: This function serves as the main HTTP request handler for the canister. It simply calls the asset_handler function to process incoming HTTP requests and return appropriate responses.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n#[query]\nfn http_request(req: HttpRequest) -> HttpResponse {\n    asset_handler(&req)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Asset with Referenced Binary Data in Rust\nDESCRIPTION: Shows how to create an Asset using a reference to binary data included at compile time. This approach is recommended for larger assets to avoid duplicating content in memory.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_asset_certification::Asset;\n\nlet pretty_big_asset = include_bytes!(\"lib.rs\");\nlet asset = Asset::new(\n    \"assets/pretty-big-asset.gz\",\n    pretty_big_asset.as_slice(),\n);\n```\n\n----------------------------------------\n\nTITLE: Certifying Assets with Multiple Encodings\nDESCRIPTION: Certifies an asset in multiple encodings (identity, gzip, brotli) by calling the appropriate certification functions for each encoding type, reusing the same certification path and additional headers.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nfn certify_asset(\n    body: &'static [u8],\n    asset_file_path: String,\n    asset_tree_path: &HttpCertificationPath,\n    asset_req_path: String,\n    additional_headers: Vec<HeaderField>,\n) {\n    certify_asset_response(\n        body,\n        additional_headers.clone(),\n        asset_tree_path,\n        asset_req_path.to_string(),\n    );\n    certify_asset_with_encoding(\n        &asset_file_path,\n        asset_tree_path,\n        asset_req_path.to_string(),\n        \"gzip\",\n        additional_headers.clone(),\n    );\n    certify_asset_with_encoding(\n        &asset_file_path,\n        asset_tree_path,\n        asset_req_path.to_string(),\n        \"br\",\n        additional_headers,\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Skipping HTTP Certification\nDESCRIPTION: Creates a certification that explicitly skips verification, which should only be used when certification is not possible and security isn't compromised.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::HttpCertification;\n\nlet certification = HttpCertification::skip();\n```\n\n----------------------------------------\n\nTITLE: Setting Certified Data in Rust for AssetRouter\nDESCRIPTION: Shows how to set the certified data for a canister after certifying assets in the AssetRouter.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_cdk::api::set_certified_data;\n\nset_certified_data(&asset_router.root_hash());\n```\n\n----------------------------------------\n\nTITLE: Embedding and Loading Static Assets in Rust Canister\nDESCRIPTION: Uses the include_dir crate to embed frontend assets into the canister's Wasm at build time, importing them from the frontend build directory.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/assets/README.md#2025-04-20_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstatic ASSETS_DIR: Dir<'_> = include_dir!(\"$CARGO_MANIFEST_DIR/../frontend/dist\");\n```\n\n----------------------------------------\n\nTITLE: Creating Exact Path for HTTP Certification Tree\nDESCRIPTION: Defines an exact path for HTTP certification that only matches the specific URL, suitable for individual files within the certification tree.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::HttpCertificationPath;\n\nlet path = HttpCertificationPath::exact(\"/js/example.js\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite for Compressed Asset Generation in TypeScript\nDESCRIPTION: Sets up Vite build configuration with the vite-plugin-compression plugin to generate Gzip and Brotli encoded versions of static assets alongside originals, which will be served by the canister.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/assets/README.md#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vite';\nimport solidPlugin from 'vite-plugin-solid';\n\n// import the compression plugin\nimport viteCompressionPlugin from 'vite-plugin-compression';\n\nexport default defineConfig({\n  plugins: [\n    solidPlugin(),\n\n    // setup Gzip compression\n    viteCompressionPlugin({\n      algorithm: 'gzip',\n      // this extension will be referenced later in the canister code\n      ext: '.gz',\n      // ensure to not delete the original files\n      deleteOriginFile: false,\n      threshold: 0,\n    }),\n\n    // setup Brotli compression\n    viteCompressionPlugin({\n      algorithm: 'brotliCompress',\n      // this extension will be referenced later in the canister code\n      ext: '.br',\n      // ensure to not delete the original files\n      deleteOriginFile: false,\n      threshold: 0,\n    }),\n  ],\n  server: {\n    port: 3000,\n  },\n  build: {\n    target: 'esnext',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Deleting JavaScript Assets with Pattern Configuration in Rust\nDESCRIPTION: Example of deleting a JavaScript file and its encoded versions using a pattern-based asset configuration. The pattern matches all JavaScript files, and the deletion includes both Brotli and Gzip compressed versions.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nasset_router\n    .delete_assets(\n        vec![\n            Asset::new(\"app.js\", b\"console.log('Hello World!');\".as_slice()),\n            Asset::new(\"app.js.gz\", &[12, 13, 14, 15, 16, 17]),\n            Asset::new(\"app.js.br\", &[18, 19, 20, 21, 22, 23]),\n        ],\n        vec![AssetConfig::Pattern {\n            pattern: \"**/*.js\".to_string(),\n            content_type: Some(\"text/javascript\".to_string()),\n            headers: vec![(\n                \"cache-control\".to_string(),\n                \"public, max-age=31536000, immutable\".to_string(),\n            )],\n            encodings: vec![\n                AssetEncoding::Brotli.default_config(),\n                AssetEncoding::Gzip.default_config(),\n            ],\n        }],\n    )\n    .unwrap();\n```\n\n----------------------------------------\n\nTITLE: Defining Data Structures for Certified HTTP Responses\nDESCRIPTION: Creates data structures to store certified HTTP responses with proper certification information, using thread_local storage for both regular and encoded responses.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone)]\nstruct CertifiedHttpResponse<'a> {\n    response: HttpResponse<'a>,\n    certification: HttpCertification,\n}\n\nthread_local! {\n    static RESPONSES: RefCell<HashMap<String, CertifiedHttpResponse<'static>>> = RefCell::new(HashMap::new());\n    static ENCODED_RESPONSES: RefCell<HashMap<(String, String), CertifiedHttpResponse<'static>>> = RefCell::new(HashMap::new());\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite for Asset Compression in TypeScript\nDESCRIPTION: This snippet shows how to configure Vite to generate compressed (Gzip and Brotli) versions of static assets alongside the originals. It uses the vite-plugin-compression plugin to create .gzip and .br files without deleting the original assets.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'vite';\nimport solidPlugin from 'vite-plugin-solid';\n\n// import the compression plugin\nimport viteCompressionPlugin from 'vite-plugin-compression';\n\nexport default defineConfig({\n  plugins: [\n    solidPlugin(),\n\n    // setup Gzip compression\n    viteCompressionPlugin({\n      algorithm: 'gzip',\n      // this extension will be referenced later in the canister code\n      ext: '.gzip',\n      // ensure to not delete the original files\n      deleteOriginFile: false,\n      threshold: 0,\n    }),\n\n    // setup Brotli compression\n    viteCompressionPlugin({\n      algorithm: 'brotliCompress',\n      // this extension will be referenced later in the canister code\n      ext: '.br',\n      // ensure to not delete the original files\n      deleteOriginFile: false,\n      threshold: 0,\n    }),\n  ],\n  server: {\n    port: 3000,\n  },\n  build: {\n    target: 'esnext',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Certified Data After Asset Deletion in Rust\nDESCRIPTION: Example of updating the canister's certified data hash after deleting assets from the AssetRouter. This is a necessary step to ensure that clients can verify the new state of the assets.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_cdk::api::set_certified_data;\n\nset_certified_data(&asset_router.root_hash());\n```\n\n----------------------------------------\n\nTITLE: Updating Certified Data After Asset Deletion in Rust\nDESCRIPTION: This code snippet shows how to update the canister's certified data after deleting assets by setting the new root hash from the asset router.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_cdk::api::set_certified_data;\n\nset_certified_data(&asset_router.root_hash());\n```\n\n----------------------------------------\n\nTITLE: Embedding Assets Directory in Rust Canister\nDESCRIPTION: Uses the include_dir crate to embed static assets from the frontend build directory into the canister's Wasm at compile time.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nstatic ASSETS_DIR: Dir<'_> = include_dir!(\"$CARGO_MANIFEST_DIR/../frontend/dist\");\n```\n\n----------------------------------------\n\nTITLE: Skipping Certification in Rust\nDESCRIPTION: Demonstrates how to skip certification entirely, which should only be done when certification is not possible for a request-response pair and when security isn't compromised.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::DefaultCelBuilder;\n\nlet cel_expr = DefaultCelBuilder::skip_certification();\n```\n\n----------------------------------------\n\nTITLE: Setting Certified Data in Canister Init for Certification Skipping in Rust\nDESCRIPTION: Code for the canister's init lifecycle hook that sets the certified data to skip certification. This ensures the correct certified data is set for signing during the next consensus round.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/skip-certification/README.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_cdk::*;\nuse ic_http_certification::utils::skip_certification_certified_data;\n\n#[init]\nfn init() {\n    set_certified_data(&skip_certification_certified_data());\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Uncertified Metrics Response in Rust for IC Canister\nDESCRIPTION: This function creates an uncertified HTTP response for the metrics endpoint. It serializes metrics data to JSON and sets appropriate headers. The response is not validated and can potentially return any content.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/custom-assets/README.md#2025-04-20_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nfn create_metrics_response() -> HttpResponse<'static> {\n    let metrics = Metrics {\n        cycle_balance: canister_balance(),\n    };\n    let body = serde_json::to_vec(&metrics).expect(\"Failed to serialize metrics\");\n    let additional_headers = vec![\n        (\"content-type\".to_string(), \"application/json\".to_string()),\n        (\n            \"cache-control\".to_string(),\n            NO_CACHE_ASSET_CACHE_CONTROL.to_string(),\n        ),\n    ];\n    let headers = get_asset_headers(\n        additional_headers,\n        body.len(),\n        DefaultCelBuilder::skip_certification().to_string(),\n    );\n\n    HttpResponse::ok(body, headers).build()\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting CSS Assets with Pattern Configuration in Rust\nDESCRIPTION: Example of deleting a CSS file and its encoded versions using a pattern-based asset configuration. The pattern matches all CSS files, and the deletion includes both Brotli and Gzip compressed versions.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nasset_router.delete_assets(\n    vec![\n        Asset::new(\n            \"css/app-ba74b708.css\",\n            b\"html,body{min-height:100vh;}\".as_slice(),\n        ),\n        Asset::new(\n            \"css/app-ba74b708.css.gz\",\n            &[24, 25, 26, 27, 28, 29],\n        ),\n        Asset::new(\n            \"css/app-ba74b708.css.br\",\n            &[30, 31, 32, 33, 34, 35],\n        ),\n    ],\n    vec![\n        AssetConfig::Pattern {\n            pattern: \"**/*.css\".to_string(),\n            content_type: Some(\"text/css\".to_string()),\n            headers: vec![(\n                \"cache-control\".to_string(),\n                \"public, max-age=31536000, immutable\".to_string(),\n            )],\n            encodings: vec![\n                AssetEncoding::Brotli.default_config(),\n                AssetEncoding::Gzip.default_config(),\n            ],\n        },\n    ]\n).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Adding Skip Certification Header to HTTP Response in Rust\nDESCRIPTION: Code for adding the certificate header to HTTP responses that instructs the HTTP Gateway to skip verification. This uses the data_certificate function to get a certificate proving the canister's certified data was signed by consensus.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/skip-certification/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_cdk::{api::data_certificate, *};\nuse ic_http_certification::utils::add_skip_certification_header;\n\n#[query]\nfn http_request() -> HttpResponse<'static> {\n    let mut response = create_response();\n\n    add_skip_certification_header(data_certificate().unwrap(), &mut response);\n\n    response\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying the Canister to Internet Computer Replica\nDESCRIPTION: Deploys the HTTP certification JSON API backend canister to the local Internet Computer replica using the dfx deployment tool.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_17\n\nLANGUAGE: shell\nCODE:\n```\ndfx deploy http_certification_json_api_backend\n```\n\n----------------------------------------\n\nTITLE: Deleting Assets and Fallbacks by Path in Rust\nDESCRIPTION: This code snippet shows how to delete the index.html asset along with its fallback configuration, the root alias, and all alternative encodings. It demonstrates the usage of delete_assets_by_path and delete_fallback_assets_by_path methods.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nasset_router\n    .delete_assets_by_path(\n        vec![\n            \"/index.html\", // deletes the index.html asset, along with all encodings\n            \"/\" // deletes the `/` alias for index.html, along with all encodings\n        ],\n    )\n    .unwrap();\n\nasset_router\n    .delete_fallback_assets_by_path(\n       vec![\n          \"/\" // deletes the fallback configuration for the `/` scope, along with all encodings\n      ]\n   )\n  .unwrap();\n```\n\n----------------------------------------\n\nTITLE: Configuring Asset with Fallback and Aliases for ICP Certification\nDESCRIPTION: Demonstrates how to configure an individual HTML file with content type, headers, fallback scope, and aliases. This configuration enables the asset to be served at its primary path while also acting as a fallback for the root path.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::StatusCode;\nuse ic_asset_certification::{AssetConfig, AssetFallbackConfig};\n\nlet config = AssetConfig::File {\n    path: \"index.html\".to_string(),\n    content_type: Some(\"text/html\".to_string()),\n    headers: vec![\n        (\"Cache-Control\".to_string(), \"public, no-cache, no-store\".to_string()),\n    ],\n    fallback_for: vec![AssetFallbackConfig {\n        scope: \"/\".to_string(),\n        status_code: Some(StatusCode::OK),\n    }],\n    aliased_by: vec![\"/\".to_string()],\n    encodings: vec![\n        AssetEncoding::Brotli.default(),\n        AssetEncoding::Gzip.default()\n    ],\n};\n```\n\n----------------------------------------\n\nTITLE: Skipping Certification Entirely in Rust\nDESCRIPTION: Creates a CEL expression that skips certification completely for both requests and responses using the DefaultCelExpression::Skip variant.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::cel::{CelExpression, DefaultCelExpression};\n\nlet cel_expr = CelExpression::Default(DefaultCelExpression::Skip);\n```\n\n----------------------------------------\n\nTITLE: Deleting JavaScript Assets in Rust\nDESCRIPTION: This code snippet demonstrates how to delete the app.js asset along with all its alternative encodings using the delete_assets method.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nasset_router.delete_assets(vec![\"/app.js\"]).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Creating a Dynamically Generated Asset in Rust\nDESCRIPTION: Demonstrates how to create an Asset with dynamically generated content at runtime. This approach uses owned values rather than references, which is useful when content needs to be modified during execution.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_asset_certification::Asset;\n\nlet name = \"World\";\nlet asset = Asset::new(\n    \"index.html\",\n    format!(\"<html><body><h1>Hello {name}!</h1></body></html>\").into_bytes(),\n);\n```\n\n----------------------------------------\n\nTITLE: Deleting CSS Assets in Rust\nDESCRIPTION: This code snippet shows how to delete a CSS asset (css/app-ba74b708.css) and all its alternative encodings using the delete_assets method.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\nasset_router.delete_assets(vec![\"/css/app-ba74b708.css\"]).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Call Upgrades in Rust\nDESCRIPTION: This Rust code implements the HTTP request upgrade pattern by using two main functions: http_request for initial query calls and http_request_update for the upgraded update calls. The http_request function signals the HTTP gateway to upgrade the call, while http_request_update provides the actual response with a custom status code.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/upgrade-to-update-call/README.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_cdk::*;\nuse ic_http_certification::{HttpResponse, HttpUpdateResponse};\n\n#[query]\nfn http_request() -> HttpResponse<'static> {\n    HttpResponse::builder().with_upgrade(true).build()\n}\n\n#[update]\nfn http_request_update() -> HttpUpdateResponse<'static> {\n    HttpResponse::builder()\n        .with_status_code(StatusCode::IM_A_TEAPOT)\n        .with_body(b\"I'm a teapot\")\n        .build_update()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Deleting Redirect Configuration in Rust\nDESCRIPTION: Example of deleting a redirect from the AssetRouter. This particular example shows how to remove a permanent redirect from '/old' to '/new' with its associated headers, without needing to provide any actual asset data.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nasset_router\n    .delete_assets(\n        vec![],\n        vec![AssetConfig::Redirect {\n            from: \"/old\".to_string(),\n            to: \"/new\".to_string(),\n            kind: AssetRedirectKind::Permanent,\n            headers: vec![(\n                \"content-type\".to_string(),\n                \"text/plain; charset=utf-8\".to_string(),\n            )],\n        }],\n    )\n    .unwrap();\n```\n\n----------------------------------------\n\nTITLE: Generated CEL Expression for Partially Certified Responses\nDESCRIPTION: The resulting CEL expression in protobuf format for the configuration with specified request headers and query parameters, but with empty certified response headers.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_20\n\nLANGUAGE: protobuf\nCODE:\n```\ndefault_certification (\n  ValidationArgs {\n    request_certification: RequestCertification {\n      certified_request_headers: [\"Accept\", \"Accept-Encoding\", \"If-None-Match\"],\n      certified_query_parameters: [\"foo\", \"bar\", \"baz\"]\n    },\n    response_certification: ResponseCertification {\n      certified_response_headers: ResponseHeaderList {\n        headers: []\n      }\n    }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Call Upgrades in Motoko\nDESCRIPTION: This Motoko code demonstrates the HTTP request upgrade pattern by defining two functions: http_request for the initial query call and http_request_update for the upgraded update call. The code includes type definitions for HTTP requests and responses, with http_request returning an upgrade flag set to true.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/upgrade-to-update-call/README.md#2025-04-20_snippet_1\n\nLANGUAGE: motoko\nCODE:\n```\nimport Text \"mo:base/Text\";\n\nactor Http {\n  type HeaderField = (Text, Text);\n\n  type HttpRequest = {\n    method : Text;\n    url : Text;\n    headers : [HeaderField];\n    body : Blob;\n    certificate_version : ?Nat16;\n  };\n\n  type HttpUpdateRequest = {\n    method : Text;\n    url : Text;\n    headers : [HeaderField];\n    body : Blob;\n  };\n\n  type HttpResponse = {\n    status_code : Nat16;\n    headers : [HeaderField];\n    body : Blob;\n    upgrade : ?Bool;\n  };\n\n  type HttpUpdateResponse = {\n    status_code : Nat16;\n    headers : [HeaderField];\n    body : Blob;\n  };\n\n  public query func http_request(_req: HttpRequest) : async HttpResponse {\n    return {\n      status_code = 200;\n      headers = [];\n      body = \"\";\n      upgrade = ?true;\n    };\n  };\n\n  public func http_request_update(_req: HttpUpdateRequest) : async HttpUpdateResponse {\n    return {\n      status_code = 418;\n      headers = [];\n      body = Text.encodeUtf8(\"I'm a teapot\");\n    };\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Generated CEL Expression for Full Response Header Certification\nDESCRIPTION: The resulting CEL expression in protobuf format for the configuration that certifies specific request components and all response headers using an empty exclusion list.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_22\n\nLANGUAGE: protobuf\nCODE:\n```\ndefault_certification (\n  ValidationArgs {\n    request_certification: RequestCertification {\n      certified_request_headers: [\"Accept\", \"Accept-Encoding\", \"If-None-Match\"],\n      certified_query_parameters: [\"foo\", \"bar\", \"baz\"]\n    },\n    response_certification: ResponseCertification {\n      response_header_exclusions: ResponseHeaderList {\n        headers: []\n      }\n    }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Verifying Certificate and Data in JavaScript\nDESCRIPTION: JavaScript code demonstrating how to verify a certificate from a canister response using the response-verification package. The code fetches certified data, verifies the certification, and compares data hashes to ensure response integrity.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/certificate-verification-js/README.md#2025-04-20_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { data, certificate, witness } = await canister.get_data();\n\nconst tree = await verifyCertification({\n  canisterId: Principal.fromText(canisterId),\n  encodedCertificate: new Uint8Array(certificate).buffer,\n  encodedTree: new Uint8Array(witness).buffer,\n  rootKey: agent.rootKey,\n  maxCertificateTimeOffsetMs: 50000,\n});\n\nconst treeDataHash = lookup_path(['count'], tree);\nconst responseDataHash = calculateDataHash(data);\n\nif (treeDataHash !== responseDataHash) {\n  // The data returned from the canister does not match the certified data.\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying the Canister with DFX\nDESCRIPTION: Shell command to deploy the HTTP certification skip canister to the local replica using DFX.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/skip-certification/README.md#2025-04-20_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ndfx deploy http_certification_skip_certification_backend\n```\n\n----------------------------------------\n\nTITLE: Generated CEL Expression for Skipping Certification\nDESCRIPTION: The resulting CEL expression in protobuf format when certification is skipped entirely for both requests and responses.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_24\n\nLANGUAGE: protobuf\nCODE:\n```\ndefault_certification (\n  ValidationArgs {\n    no_certification: Empty {}\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Explicitly Implementing Response-Only Certification with Empty Headers\nDESCRIPTION: Similar to the previous example but explicitly specifies an empty vector of headers to certify, making it clear that only the response body and status code will be certified.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::{DefaultCelBuilder, DefaultResponseCertification};\n\nlet cel_expr = DefaultCelBuilder::response_only_certification()\n    .with_response_certification(DefaultResponseCertification::certified_response_headers(vec![]))\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Deleting Redirect Assets in Rust\nDESCRIPTION: This code snippet demonstrates how to delete a redirect asset (/old) using the delete_assets_by_path method.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nasset_router.delete_assets_by_path(vec![\"/old\"]).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Testing the Canister with cURL\nDESCRIPTION: Shell command using cURL to test the HTTP canister with certification skipping, piping the output to jq for formatting the JSON response.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/skip-certification/README.md#2025-04-20_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncurl -s http://localhost:$(dfx info webserver-port)?canisterId=$(dfx canister id http_certification_skip_certification_backend) | jq\n```\n\n----------------------------------------\n\nTITLE: Configuring Partially Certified Responses with Empty Response Headers in Rust\nDESCRIPTION: Creates a CEL expression for request certification with specific request headers and query parameters, but with an empty array of certified response headers. This configuration certifies the specified request components but no response headers.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nuse std::borrow::Cow;\nuse ic_http_certification::cel::{CelExpression, DefaultCertification, DefaultRequestCertification, DefaultResponseCertification};\n\nlet cel_expr = CelExpression::DefaultCertification(Some(DefaultCertification {\n  request: DefaultRequestCertification::new(\n    vec![\"Accept\", \"Accept-Encoding\", \"If-None-Match\"],\n    vec![\"foo\", \"bar\", \"baz\"],\n  ),\n  response_certification: DefaultResponseCertification::certified_response_headers(vec![]),\n}));\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Response from Canister\nDESCRIPTION: Example JSON output from the canister showing the cycle balance when requesting data from the canister with certification skipping enabled.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/skip-certification/README.md#2025-04-20_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"cycle_balance\": 3092211597987\n}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Creating a Partially Certified Request\nDESCRIPTION: Demonstrates an alternative, more explicit approach to creating a partially certified request by providing empty vectors for request headers and query parameters, while still certifying specific response headers.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::{DefaultCelBuilder, DefaultResponseCertification};\n\nlet cel_expr = DefaultCelBuilder::full_certification()\n    .with_request_headers(vec![])\n    .with_request_query_parameters(vec![])\n    .with_response_certification(DefaultResponseCertification::certified_response_headers(vec![\n        \"Cache-Control\",\n        \"ETag\",\n    ]))\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Running End-to-End Tests for Response Verification\nDESCRIPTION: Shell command to execute the end-to-end test suite for the response verification project. This script likely initializes the test environment, runs the tests, and verifies the output.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-response-verification-tests/README.md#2025-04-20_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./scripts/e2e.sh\n```\n\n----------------------------------------\n\nTITLE: Visualizing Certification Process Flow with Mermaid Diagram\nDESCRIPTION: This Mermaid flowchart illustrates the process flow for canister certification, including lifecycle hooks, update calls, query calls, and the certification steps. It shows how different operations trigger the certification process and how pre-calculated responses are served for query calls.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/README.md#2025-04-20_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TB;\n  subgraph lifecycle_hooks[Lifecycle hooks]\n    init;\n    post_upgrade;\n  end\n  init-->certification;\n  post_upgrade-->certification;\n\n  subgraph update_calls\n    update_call;\n    update_state;\n    update_call-->update_state;\n  end\n  update_state-->certification;\n\n  subgraph query_calls\n    direction TB;\n\n    query_call;\n    serve_response[Serve pre-calculated response];\n    query_call-->serve_response;\n  end\n\n  subgraph certification[Certification]\n    direction TB;\n\n    certification_step_one[pre-calculate response];\n    certification_step_two[insert response hash into merkle tree];\n    certification_step_three[calculate root hash of merkle tree];\n    certification_step_four[set canister certified data];\n\n    certification_step_one-->certification_step_two-->certification_step_three-->certification_step_four;\n  end\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for WASM Target\nDESCRIPTION: A configuration file to set the Rust compiler target to WebAssembly, allowing proper IDE integration for WASM crates. This workaround addresses the issue with rust-analyzer applying the same target to all crates.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/README.md#2025-04-20_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[build]\ntarget = \"wasm32-unknown-unknown\"\n```\n\n----------------------------------------\n\nTITLE: Visualizing Response Verification Process Flow with Mermaid\nDESCRIPTION: A flowchart diagram that illustrates the complete process flow of response verification on the Internet Computer, including lifecycle hooks, query calls, update calls, and certification steps.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/README.md#2025-04-20_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TB;\n  subgraph lifecycle_hooks[Lifecycle hooks]\n    init;\n    post_upgrade;\n  end\n  init-->certification;\n  post_upgrade-->certification;\n\n  subgraph query_calls[Query calls]\n    http_request;\n    should_upgrade{State change?};\n    serve_response[Serve pre-calculated response];\n    upgrade[Upgrade to update call];\n\n    http_request-->should_upgrade;\n    should_upgrade -- No-->serve_response;\n    should_upgrade -- Yes-->upgrade;\n  end\n  upgrade-->update_calls;\n\n  subgraph update_calls[Update calls]\n    http_request_update;\n    update_state;\n\n    http_request_update-->update_state;\n  end\n  update_state-->certification;\n\n  subgraph certification[Certification]\n    direction TB;\n\n    certification_step_one[pre-calculate response];\n    certification_step_two[pre-calculate CEL expression];\n    certification_step_three[pre-calculate certification];\n\n    certification_step_one[pre-calculate response];\n    certification_step_two[pre-calculate CEL expression];\n    certification_step_three[insert response hash into merkle tree];\n    certification_step_four[calculate root hash of merkle tree];\n    certification_step_five[set canister certified data];\n\n    certification_step_one-->certification_step_two-->certification_step_three-->certification_step_four-->certification_step_five;\n  end\n```\n\n----------------------------------------\n\nTITLE: Referencing a Published Cargo Crate\nDESCRIPTION: Example of referencing a Cargo crate that will be published to crates.io, including both the local path and version. This is required when the referencing crate will also be published.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/README.md#2025-04-20_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nic-response-verification-test-utils = { path = \"../ic-response-verification-test-utils\", version = \"1.0.0\" }\n```\n\n----------------------------------------\n\nTITLE: Generating Backend Canister Bindings\nDESCRIPTION: Command to generate TypeScript/JavaScript bindings for the backend canister, enabling frontend to interact with the canister.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/certification/certified-counter/README.md#2025-04-20_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ndfx generate backend\n```\n\n----------------------------------------\n\nTITLE: Referencing a Local Cargo Crate\nDESCRIPTION: Example of how to reference another Cargo crate in the same repository using a relative path in Cargo.toml. This allows for local development without publishing dependencies.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/README.md#2025-04-20_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nic-response-verification-test-utils = { path = \"../ic-response-verification-test-utils\" }\n```\n\n----------------------------------------\n\nTITLE: Making a Conventional Commit\nDESCRIPTION: Command to create a commit using Commitizen, which enforces the Conventional Commits format. This helps maintain consistent commit message formats throughout the project.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/README.md#2025-04-20_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncz commit\n```\n\n----------------------------------------\n\nTITLE: Deleting All Assets in Rust\nDESCRIPTION: This code snippet demonstrates how to delete all assets and their certification in one operation using the delete_all_assets method.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\nasset_router.delete_all_assets();\n```\n\n----------------------------------------\n\nTITLE: Starting Local Internet Computer Replica with dfx\nDESCRIPTION: Initializes a local replica instance using the dfx command-line tool. The --background flag runs it as a background process, and --clean ensures a fresh state.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\ndfx start --background --clean\n```\n\n----------------------------------------\n\nTITLE: Building and Deploying Canisters\nDESCRIPTION: Command to build and deploy all canisters to the local Internet Computer replica.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/certification/certified-counter/README.md#2025-04-20_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ndfx deploy\n```\n\n----------------------------------------\n\nTITLE: Deleting a Todo Item with curl in Internet Computer Canister\nDESCRIPTION: Sends a DELETE request to remove the todo item with ID 0 from the canister. The command resolves the canister ID to localhost and pipes the output through jq for formatting.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\ncurl -s -X DELETE \\\n    \"http://$(dfx canister id http_certification_json_api_backend).localhost:$(dfx info webserver-port)/todos/0\" \\\n    --resolve \"$(dfx canister id http_certification_json_api_backend).localhost:$(dfx info webserver-port):127.0.0.1\" | jq\n```\n\n----------------------------------------\n\nTITLE: Building the Certificate Verification Package\nDESCRIPTION: Command to build the certificate verification package which provides the functionality to verify canister response certifications.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/certification/certified-counter/README.md#2025-04-20_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npnpm run --filter @dfinity/certificate-verification build\n```\n\n----------------------------------------\n\nTITLE: Getting the Frontend Canister URL\nDESCRIPTION: Command to generate and display the local URL for accessing the deployed frontend canister in a web browser.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/certification/certified-counter/README.md#2025-04-20_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\necho \"http://$(dfx canister id certification_certified_counter_frontend).localhost:$(dfx info webserver-port)\"\n```\n\n----------------------------------------\n\nTITLE: Printing Canister URL for Browser Testing\nDESCRIPTION: Shell command that prints the URL of the deployed canister to the terminal for opening in a browser to test the HTTP certification skipping.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/skip-certification/README.md#2025-04-20_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\necho http://localhost:$(dfx info webserver-port)?canisterId=$(dfx canister id http_certification_skip_certification_backend)\n```\n\n----------------------------------------\n\nTITLE: Navigating to Project Directory for Certified Counter Example\nDESCRIPTION: Command to navigate to the certified counter example project directory within the response-verification repository.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/certification/certified-counter/README.md#2025-04-20_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd examples/certification/certified-counter\n```\n\n----------------------------------------\n\nTITLE: Referencing a Workspace NPM Package\nDESCRIPTION: Example of how to reference an NPM package within the same PNPM workspace using the workspace protocol. This allows for local development while maintaining proper dependency management.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/README.md#2025-04-20_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"dependencies\": {\n    \"@dfinity/certificate-verification\": \"workspace:*\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing HTTP Call Upgrades with DFX\nDESCRIPTION: These shell commands demonstrate how to deploy and test the HTTP upgrade functionality in both Rust and Motoko canisters. The commands start a local replica, deploy the canister, and use curl to make a request that triggers the upgrade process.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/upgrade-to-update-call/README.md#2025-04-20_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndfx start --background --clean\n```\n\nLANGUAGE: shell\nCODE:\n```\ndfx deploy http_certification_upgrade_to_update_call_rust_backend\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -v http://localhost:$(dfx info webserver-port)?canisterId=$(dfx canister id http_certification_upgrade_to_update_call_rust_backend)\n```\n\nLANGUAGE: shell\nCODE:\n```\ndfx deploy http_certification_upgrade_to_update_call_motoko_backend\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl -v http://localhost:$(dfx info webserver-port)?canisterId=$(dfx canister id http_certification_upgrade_to_update_call_motoko_backend)\n```\n\n----------------------------------------\n\nTITLE: Testing Internet Computer Canister with dfx\nDESCRIPTION: These shell commands demonstrate how to test the HTTP certification assets canister. The steps include starting a local replica, deploying the canister, and accessing its assets either through a web browser or using curl.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/assets/README.md#2025-04-20_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ndfx start --background --clean\n```\n\nLANGUAGE: shell\nCODE:\n```\ndfx deploy http_certification_assets_backend\n```\n\nLANGUAGE: shell\nCODE:\n```\necho \"http://$(dfx canister id http_certification_assets_backend).localhost:$(dfx info webserver-port)\"\n```\n\nLANGUAGE: shell\nCODE:\n```\ncurl \"http://$(dfx canister id http_certification_assets_backend).localhost:$(dfx info webserver-port)\" --resolve \"$(dfx canister id http_certification_assets_backend).localhost:$(dfx info webserver-port):127.0.0.1\"\n```\n\n----------------------------------------\n\nTITLE: Converting CEL Expressions to String Using create_cel_expr()\nDESCRIPTION: Shows an alternative approach to convert CelExpression to its String representation using the create_cel_expr() function, which takes a reference to a CelExpression as input.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::cel::{CelExpression, DefaultCelExpression, create_cel_expr};\n\nlet certification = CelExpression::Default(DefaultCelExpression::Skip);\nlet cel_expr = create_cel_expr(&certification);\n```\n\n----------------------------------------\n\nTITLE: Starting DFX Development Environment in Background\nDESCRIPTION: Command to start the DFINITY Canister SDK (DFX) in background mode for local development.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/certification/certified-counter/README.md#2025-04-20_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndfx start --background\n```\n\n----------------------------------------\n\nTITLE: Starting Local Replica with DFX for Testing\nDESCRIPTION: Shell command to start a local instance of the Internet Computer replica using DFX for testing the canister with certification skipping.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/skip-certification/README.md#2025-04-20_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndfx start --background --clean\n```\n\n----------------------------------------\n\nTITLE: Creating All Required Canisters\nDESCRIPTION: Command to create all canisters defined in the project configuration.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/certification/certified-counter/README.md#2025-04-20_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndfx canister create --all\n```\n\n----------------------------------------\n\nTITLE: Deleting HTML Assets with Fallback Configuration in Rust\nDESCRIPTION: Example of deleting an HTML file along with its compressed versions (Brotli and Gzip), fallback configuration, and alias. The deletion requires providing the same configuration as used when certifying the assets.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-asset-certification/README.md#2025-04-20_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nasset_router\n    .delete_assets(\n        vec![\n            Asset::new(\n                \"index.html\",\n                b\"<html><body><h1>Hello World!</h1></body></html>\".as_slice(),\n            ),\n            Asset::new(\"index.html.gz\", &[0, 1, 2, 3, 4, 5]),\n            Asset::new(\"index.html.br\", &[6, 7, 8, 9, 10, 11]),\n        ],\n        vec![AssetConfig::File {\n            path: \"index.html\".to_string(),\n            content_type: Some(\"text/html\".to_string()),\n            headers: vec![(\n                \"cache-control\".to_string(),\n                \"public, no-cache, no-store\".to_string(),\n            )],\n            fallback_for: vec![AssetFallbackConfig {\n                scope: \"/\".to_string(),\n                status_code: Some(StatusCode::OK),\n            }],\n            aliased_by: vec![\"/\".to_string()],\n            encodings: vec![\n                AssetEncoding::Brotli.default_config(),\n                AssetEncoding::Gzip.default_config(),\n            ],\n        }],\n    )\n    .unwrap();\n```\n\n----------------------------------------\n\nTITLE: Navigating Back to Repository Root\nDESCRIPTION: Command to navigate back to the root directory of the repository to access package dependencies.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/certification/certified-counter/README.md#2025-04-20_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncd ../../\n```\n\n----------------------------------------\n\nTITLE: Fetching Todo Items with curl from Internet Computer Canister\nDESCRIPTION: Sends a GET request to retrieve all todo items from the deployed canister. The command resolves the canister ID to localhost and pipes the output through jq for pretty-printing the JSON.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\ncurl -s \\\n    \"http://$(dfx canister id http_certification_json_api_backend).localhost:$(dfx info webserver-port)/todos\" \\\n    --resolve \"$(dfx canister id http_certification_json_api_backend).localhost:$(dfx info webserver-port):127.0.0.1\" | jq\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm\nDESCRIPTION: Command to install all dependencies defined in the package.json file using pnpm package manager.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/certification/certified-counter/README.md#2025-04-20_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\npnpm i\n```\n\n----------------------------------------\n\nTITLE: Creating a Todo Item with curl in Internet Computer Canister\nDESCRIPTION: Sends a POST request to create a new todo item with the title 'Learn Motoko'. Uses the Content-Type header to specify JSON data and pipes the response through jq for formatting.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\ncurl -s -X POST \\\n    \"http://$(dfx canister id http_certification_json_api_backend).localhost:$(dfx info webserver-port)/todos\" \\\n    --resolve \"$(dfx canister id http_certification_json_api_backend).localhost:$(dfx info webserver-port):127.0.0.1\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{ \"title\": \"Learn Motoko\" }' | jq\n```\n\n----------------------------------------\n\nTITLE: Creating and Verifying Certificates in TypeScript for Internet Computer\nDESCRIPTION: This code snippet demonstrates how to create a hash tree, generate a certificate, and verify it using DFINITY libraries. It utilizes @dfinity/agent for hash tree creation, @dfinity/certification-testing for certificate building, and @dfinity/certificate-verification for certificate verification.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-certification-testing-wasm/README.md#2025-04-20_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { describe, expect, it } from 'vitest';\nimport { HashTree, reconstruct, Cbor } from '@dfinity/agent';\nimport { CertificateBuilder } from '@dfinity/certification-testing';\nimport { verifyCertification } from '@dfinity/certificate-verification';\nimport { Principal } from '@dfinity/principal';\nimport { createHash } from 'node:crypto';\n\nconst userId = '1234';\n\nconst username = 'testuser';\nconst usernameHash = new Uint8Array(\n  createHash('sha256').update(username).digest(),\n);\n\nconst hashTree: HashTree = [\n  2,\n  new Uint8Array(Buffer.from(userId)),\n  [3, usernameHash],\n];\nconst rootHash = await reconstruct(hashTree);\nconst cborEncodedTree = Cbor.encode(hashTree);\n\nconst canisterId = Principal.fromUint8Array(\n  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]),\n);\nconst time = BigInt(Date.now());\nconst MAX_CERT_TIME_OFFSET_MS = 300_000;\n\nlet certificate = new CertificateBuilder(\n  canisterId.toString(),\n  new Uint8Array(rootHash),\n)\n  .withTime(time)\n  .build();\n\nconst decodedHashTree = await verifyCertification({\n  canisterId,\n  encodedCertificate: certificate.cborEncodedCertificate,\n  encodedTree: cborEncodedTree,\n  maxCertificateTimeOffsetMs: MAX_CERT_TIME_OFFSET_MS,\n  rootKey: certificate.rootKey,\n});\nexpect(decodedHashTree).toEqual(hashTree);\n```\n\n----------------------------------------\n\nTITLE: Returning to Project Directory\nDESCRIPTION: Command to navigate back to the certified counter project directory to continue with deployment.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/certification/certified-counter/README.md#2025-04-20_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ncd examples/certification/certified-counter\n```\n\n----------------------------------------\n\nTITLE: Updating a Todo Item with curl in Internet Computer Canister\nDESCRIPTION: Sends a PATCH request to update the completion status of a todo item with ID 0. Uses the Content-Type header to specify JSON data format and pipes the response through jq.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/json-api/README.md#2025-04-20_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\ncurl -s -X PATCH \\\n    \"http://$(dfx canister id http_certification_json_api_backend).localhost:$(dfx info webserver-port)/todos/0\" \\\n    --resolve \"$(dfx canister id http_certification_json_api_backend).localhost:$(dfx info webserver-port):127.0.0.1\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{ \"completed\": true }' | jq\n```\n\n----------------------------------------\n\nTITLE: Converting CEL Expressions to String Representation Using to_string()\nDESCRIPTION: Demonstrates how to convert a CelExpression enum into its String representation using the to_string() method, specifically showing how to convert a DefaultCelExpression::Skip value.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-http-certification/README.md#2025-04-20_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse ic_http_certification::cel::{CelExpression, DefaultCelExpression};\n\nlet cel_expr = CelExpression::Default(DefaultCelExpression::Skip).to_string();\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP Requests for Certified Assets in Rust Canister\nDESCRIPTION: Implements the http_request query endpoint that routes requests either to a metrics endpoint or to the asset serving function based on the requested path.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/examples/http-certification/assets/README.md#2025-04-20_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[query]\nfn http_request(req: HttpRequest) -> HttpResponse {\n    let path = req.get_path().expect(\"Failed to parse request path\");\n\n    // if the request is for the metrics endpoint, serve the metrics\n    if path == \"/metrics\" {\n        return serve_metrics();\n    }\n\n    // otherwise, serve the requested asset\n    serve_asset(&req)\n}\n```\n\n----------------------------------------\n\nTITLE: Documentation for Representation Independent Hash\nDESCRIPTION: Markdown documentation explaining the purpose of representation independent hashing functionality with a link to the IC interface specification.\nSOURCE: https://github.com/dfinity/response-verification/blob/main/packages/ic-representation-independent-hash/README.md#2025-04-20_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Representation Independent Hash\\n\\nUtilities for calculating [Representation Independent Hashes](https://internetcomputer.org/docs/current/references/ic-interface-spec/#hash-of-map) of arbitrary Rust objects.\n```"
  }
]