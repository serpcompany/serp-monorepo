[
  {
    "owner": "payloadcms",
    "repo": "payload",
    "content": "TITLE: Creating a Post on the Server with Payload Local API (TypeScript)\nDESCRIPTION: This server function creates a new document in the 'posts' collection by using Payload CMS's Local API within a Next.js server function (indicated by the 'use server' directive). Dependencies include 'payload', '@payload-config', and the 'getPayload' utility. The function expects 'data' as the post's content and returns the created post document; any errors encountered during the operation are thrown as new Error instances.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"'use server'\\n\\nimport { getPayload } from 'payload'\\nimport config from '@payload-config'\\n\\nexport async function createPost(data) {\\n  const payload = await getPayload({ config })\\n\\n  try {\\n    const post = await payload.create({\\n      collection: 'posts',\\n      data,\\n    })\\n    return post\\n  } catch (error) {\\n    throw new Error(`Error creating post: ${error.message}`)\\n  }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Access Control in a Payload Server Function (TypeScript)\nDESCRIPTION: Illustrates how to add security checks within a Next.js server function before performing sensitive Payload Local API operations. This example checks if a user object exists and if the user has the 'admin' role before allowing a post deletion. If the checks fail, it throws an 'Unauthorized' error, preventing the operation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Assuming getPayload and config are available\nimport { getPayload } from 'payload'\nimport config from '@payload-config'\n\n// Define a user type/interface if possible\ninterface User {\n  role?: string;\n  // other user properties\n}\n\nexport async function deletePost(postId: string, user: User | null | undefined) {\n  // Check if the user is authenticated and has the 'admin' role\n  if (!user || user.role !== 'admin') {\n    throw new Error('Unauthorized') // Throw an error if checks fail\n  }\n\n  const payload = await getPayload({ config })\n  // Proceed with the delete operation only if authorized\n  return await payload.delete({ collection: 'posts', id: postId })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Fields within a Payload Collection Configuration (TypeScript)\nDESCRIPTION: This snippet illustrates the basic structure for defining fields within a Payload CMS Collection. Fields are configured within the `fields` array property of an object conforming to the `CollectionConfig` type imported from `payload`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Page: CollectionConfig = {\n  // ...\n  fields: [\n    // highlight-line\n    // ...\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Logging In a User via REST API using Fetch in TypeScript\nDESCRIPTION: Demonstrates how to perform a user login using the `fetch` API to send a POST request to the `/api/[collection-slug]/login` endpoint. Includes setting headers and sending email/password in the request body. The expected JSON response containing user data and token is also shown.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await fetch('http://localhost:3000/api/[collection-slug]/login', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    email: 'dev@payloadcms.com',\n    password: 'this-is-not-our-password...or-is-it?',\n  }),\n})\n\nconst json = await res.json()\n\n// JSON will be equal to the following:\n/*\n{\n  user: {\n    email: 'dev@payloadcms.com',\n    createdAt: \"2020-12-27T21:16:45.645Z\",\n    updatedAt: \"2021-01-02T18:37:41.588Z\",\n    id: \"5ae8f9bde69e394e717c8832\"\n  },\n  token: '34o4345324...',\n  exp: 1609619861\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Configuring Collection Access Control - Payload CMS - TypeScript\nDESCRIPTION: Demonstrates how to add an 'access' property to a Payload CMS CollectionConfig, enabling granular permissions for different operations. Requires the 'payload' dependency and a valid CollectionConfig export. This code sets up the structure for defining custom access logic for collections, but leaves implementation details for access functions empty.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionWithAccessControl: CollectionConfig = {\n  // ...\n  access: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Field-Level Access Control Rules in a Collection (PayloadCMS, TypeScript)\nDESCRIPTION: This snippet defines a 'Posts' collection in PayloadCMS and demonstrates how to add field-level access controls using the \"access\" property. Callback functions for create, read, and update are assigned, allowing developers to insert logic that controls per-operation permissions based on the request context and user. Requires the 'payload' library, with types imported from 'payload', and should be placed within the configuration section for a registered collection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/fields.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload';\n\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  fields: [\n    {\n      name: 'title',\n      type: 'text',\n      // highlight-start\n      access: {\n        create: ({ req: { user } }) => { ... },\n        read: ({ req: { user } }) => { ... },\n        update: ({ req: { user } }) => { ... },\n      },\n      // highlight-end\n    };\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Email Verification in Payload CMS Collection (TypeScript)\nDESCRIPTION: This snippet demonstrates how to enable email verification for a collection in Payload CMS by setting the `verify` property on the authentication configuration to `true`. Requires Payload CMS and correct TypeScript configuration for the collection. No parameters are required; this flag controls sending verification emails when users sign up. The primary output is that unverified users receive an email to confirm their address before the account is active.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/email.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Customers: CollectionConfig = {\n  // ...\n  auth: {\n    verify: true, // highlight-line\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Group Field in Payload CMS using TypeScript\nDESCRIPTION: Demonstrates the basic structure for defining a Group Field in a Payload CMS configuration. It highlights setting the `type` property to 'group' and including a nested `fields` array to contain other field definitions. This structure allows grouping related fields under a single property name.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/group.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyGroupField: Field = {\n  // ...\n  // highlight-start\n  type: 'group',\n  fields: [\n    // ...\n  ],\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Field-Level Access Control in Payload (TypeScript)\nDESCRIPTION: This code demonstrates applying field-level access control rules in Payload using the `Field` type. It involves adding the `access` property (an object containing access control functions) to the field configuration, enabling fine-grained permission control for reading or updating the specific field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyField: Field = {\n  type: 'text',\n  name: 'myField',\n  // highlight-start\n  access: {\n    // ...\n  },\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Select Field in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates the basic configuration for a Select field in Payload CMS. It imports the 'Field' type from 'payload' and defines a field object, setting the 'type' property to 'select' and including a placeholder for the 'options' array, which defines the list of choices available in the dropdown.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/select.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MySelectField: Field = {\n  // ...\n  // highlight-start\n  type: 'select',\n  options: [\n    // ...\n  ],\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring the Basic Stripe Plugin in Payload (TypeScript)\nDESCRIPTION: Demonstrates the basic configuration of the Stripe plugin within the PayloadCMS config file (`payload.config.ts`). It imports the `stripePlugin` and adds it to the `plugins` array in `buildConfig`, passing the required `stripeSecretKey` obtained from environment variables. This setup initializes the plugin for use in the Payload application.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/stripe.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { stripePlugin } from '@payloadcms/plugin-stripe'\n\nconst config = buildConfig({\n  plugins: [\n    stripePlugin({\n      stripeSecretKey: process.env.STRIPE_SECRET_KEY,\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Minimal Payload CMS Configuration - TypeScript\nDESCRIPTION: This is a minimal but functional 'payload.config.ts' configuration for initializing a Payload CMS instance. It imports Sharp for image processing, Lexical for the rich text editor, and a database adapter (MongoDB shown in example). Required fields: 'editor', 'collections', 'secret', 'db', and optionally 'sharp' for image tasks. Inputs: environment variables for database URL and secret. Outputs: default payload CMS configuration. Limitation: MongoDB is used, swap adapter for other databases as needed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/installation.mdx#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport sharp from 'sharp'\nimport { lexicalEditor } from '@payloadcms/richtext-lexical'\nimport { mongooseAdapter } from '@payloadcms/db-mongodb'\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // If you'd like to use Rich Text, pass your editor here\n  editor: lexicalEditor(),\n\n  // Define and configure your collections in this array\n  collections: [],\n\n  // Your Payload secret - should be a complex and secure string, unguessable\n  secret: process.env.PAYLOAD_SECRET || '',\n  // Whichever Database Adapter you're using should go here\n  // Mongoose is shown as an example, but you can also use Postgres\n  db: mongooseAdapter({\n    url: process.env.DATABASE_URI || '',\n  }),\n  // If you want to resize images, crop, set focal point, etc.\n  // make sure to install it and pass it to the config.\n  // This is optional - if you don't need to do these things,\n  // you don't need it!\n  sharp,\n})\n```\n\n----------------------------------------\n\nTITLE: Example JSON Field in Collection Configuration (TypeScript)\nDESCRIPTION: This example provides a complete CollectionConfig for Payload CMS, defining a collection with a single JSON field called 'customerJSON'. The field is required and uses the 'json' type, illustrating best practices for adding and validating custom JSON data in a Payload collection. Required dependencies include Payload CMS and its type definitions. Key parameters are 'name', 'type', and 'required', which set the field's identity and validation status. The output is a CollectionConfig object containing a JSON field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/json.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'customerJSON', // required\n      type: 'json', // required\n      required: true,\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Types via CLI - Payload CMS - Shell/Command\nDESCRIPTION: This command runs the Payload CMS TypeScript type generator, creating strongly-typed interfaces based on the current Payload configuration file (usually payload.config.ts). It should be run whenever the schema changes to keep types up-to-date. The generated types can be imported in your TypeScript code for improved type safety.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/generating-types.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npayload generate:types\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing Payload with `getPayload` (TypeScript)\nDESCRIPTION: Illustrates how to obtain the Payload instance in contexts where it's not directly available via arguments, such as custom scripts or external modules. It imports the `getPayload` function and the application's configuration file (`@payload-config`), then calls `getPayload` asynchronously to initialize and retrieve the instance. This method supports HMR in Next.js development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { getPayload } from 'payload'\nimport config from '@payload-config'\n\nconst payload = await getPayload({ config })\n```\n```\n\n----------------------------------------\n\nTITLE: Inserting Documents into Collections - Payload CMS JavaScript\nDESCRIPTION: This code creates a new document in a specified collection using the Payload Local API. It showcases support for locales, user assignment, access overrides, hidden fields, file uploads (by file path or File object), and the duplication of existing documents. The snippet also demonstrates overrides related to authentication and upload-specific options. Payload and node path module must be available, and required parameters include collection and data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\n// The created Post document is returned\nconst post = await payload.create({\n  collection: 'posts', // required\n  data: {\n    // required\n    title: 'sure',\n    description: 'maybe',\n  },\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUserDoc,\n  overrideAccess: true,\n  showHiddenFields: false,\n\n  // If creating verification-enabled auth doc,\n  // you can optionally disable the email that is auto-sent\n  disableVerificationEmail: true,\n\n  // If your collection supports uploads, you can upload\n  // a file directly through the Local API by providing\n  // its full, absolute file path.\n  filePath: path.resolve(__dirname, './path-to-image.jpg'),\n\n  // Alternatively, you can directly pass a File,\n  // if file is provided, filePath will be omitted\n  file: uploadedFile,\n\n  // If you want to create a document that is a duplicate of another document\n  duplicateFromID: 'document-id-to-duplicate',\n})\n```\n\n----------------------------------------\n\nTITLE: Scaffolding a New Payload App Using NPX - Bash\nDESCRIPTION: This snippet shows how to quickly scaffold a new Payload application using the npx package runner. It runs the create-payload-app utility, which prompts the user for configuration and generates a new directory with a functioning Payload instance. Requires Node.js and a JavaScript package manager. Outputs: scaffolded project folder structure. No input parameters beyond optional command-line flags. Limitations: relies on npx and upstream package availability.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/installation.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-payload-app\n```\n\n----------------------------------------\n\nTITLE: Creating Access Control for Read Operation - Payload CMS - TypeScript\nDESCRIPTION: Defines a read access function in a CollectionConfig, granting document access if 'user' is authenticated. The logic receives a 'req' object with a 'user' property and returns a boolean. This snippet assumes an authenticated request context and is suitable for scenarios where only logged-in users should read documents.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionWithReadAccess: CollectionConfig = {\n  // ...\n  access: {\n    // highlight-start\n    read: ({ req: { user } }) => {\n      return Boolean(user)\n    },\n    // highlight-end\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with Payload Local API in a React Server Component (TSX)\nDESCRIPTION: This snippet demonstrates how to use Payload's Local API within a React Server Component to fetch data directly from the database. It initializes the Payload instance using the application config (`@payload-config`) and then uses the `payload.find` method to retrieve documents from the 'pages' collection. The retrieved data (`findResult`) is fully typed, providing access to the `docs` array containing page data, along with pagination details. This method offers high performance by bypassing HTTP overhead.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/concepts.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport React from 'react'\nimport config from '@payload-config'\nimport { getPayload } from 'payload'\n\nconst MyServerComponent: React.FC = () => {\n  const payload = await getPayload({ config })\n\n  // The `findResult` here will be fully typed as `PaginatedDocs<Page>`,\n  // where you will have the `docs` that are returned as well as\n  // information about how many items are returned / are available in total / etc\n  const findResult = await payload.find({ collection: 'pages' })\n\n  return (\n    <ul>\n      {findResult.docs.map((page) => {\n        // Render whatever here!\n        // The `page` is fully typed as your Pages collection!\n      })}\n    </ul>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Managing Feature Load Order with Dependencies in PayloadCMS in TypeScript\nDESCRIPTION: Demonstrates using the `dependenciesPriority` property within `createServerFeature` to enforce feature load order. This example ensures that the feature identified by the key 'otherFeature' is loaded *before* the current feature ('myFeature'). This is crucial when one feature relies on another being initialized first.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nimport { createServerFeature } from '@payloadcms/richtext-lexical'\n\nexport const MyFeature = createServerFeature({\n  feature: ({ featureProviderMap }) => {\n    return {\n      // ...\n    }\n  },\n  key: 'myFeature',\n  dependenciesPriority: ['otherFeature'],\n})\n```\n\n----------------------------------------\n\nTITLE: Using a Function for Dynamic Field Descriptions in Payload CMS (TypeScript)\nDESCRIPTION: Illustrates using a server-side function for the 'admin.description' property. This allows for dynamic description generation, potentially leveraging the 't' function for internationalization based on the user's locale.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollectionConfig: CollectionConfig = {\n  // ...\n  fields: [\n    // ...\n    {\n      name: 'myField',\n      type: 'text',\n      admin: {\n        description: ({ t }) => `${t('Hello, world!')}`, // highlight-line\n      },\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Exporting a Field with Access Control in PayloadCMS (TypeScript)\nDESCRIPTION: This snippet defines a TypeScript field configuration object in PayloadCMS and demonstrates where and how to apply the \"access\" property. The \"access\" block is set up for further granular functions such as create, read, and update. Before using this code, ensure that the 'payload' library is installed and imported; you must also place this config within a registered schema context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/fields.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const FieldWithAccessControl: Field = {\n  // ...\n  access: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Group Field in a Payload CMS Collection using TypeScript\nDESCRIPTION: Provides a complete example of defining a 'pageMeta' Group Field within a Payload CMS collection named 'ExampleCollection'. This group contains required 'title' (text) and 'description' (textarea) fields. The example demonstrates a practical use case for organizing related fields and optionally specifies an `interfaceName` ('Meta') for generating corresponding TypeScript and GraphQL types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/group.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'pageMeta', // required\n      type: 'group', // required\n      interfaceName: 'Meta', // optional\n      fields: [\n        // required\n        {\n          name: 'title',\n          type: 'text',\n          required: true,\n          minLength: 20,\n          maxLength: 100,\n        },\n        {\n          name: 'description',\n          type: 'textarea',\n          required: true,\n          minLength: 40,\n          maxLength: 160,\n        },\n      ],\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Login Form React Client Component (TSX)\nDESCRIPTION: Provides a React client component (`LoginForm`) for user login. It uses local state to manage email and password inputs and calls the `loginAction` server function upon form submission. Requires the `loginAction` server function to be defined elsewhere (e.g., `../loginAction`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\n\nimport { useState, ChangeEvent } from 'react'\nimport { loginAction } from '../loginAction' // Path to the server action\n\nexport default function LoginForm() {\n  const [email, setEmail] = useState<string>('')\n  const [password, setPassword] = useState<string>('')\n\n  return (\n    <form onSubmit={async (e) => { \n        e.preventDefault(); // Prevent default form submission\n        try {\n          await loginAction({ email, password });\n          // Handle successful login (e.g., redirect)\n        } catch (error) {\n          // Handle login error (e.g., display message)\n          console.error(error);\n        } \n      }}>\n      <label htmlFor=\"email\">Email</label>\n      <input\n        id=\"email\"\n        onChange={(e: ChangeEvent<HTMLInputElement>) =>\n          setEmail(e.target.value)\n        }\n        type=\"email\"\n        value={email}\n        required\n      />\n      <label htmlFor=\"password\">Password</label>\n      <input\n        id=\"password\"\n        onChange={(e: ChangeEvent<HTMLInputElement>) =>\n          setPassword(e.target.value)\n        }\n        type=\"password\"\n        value={password}\n        required\n      />\n      <button type=\"submit\">Login</button>\n    </form>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Label Component in Payload Field (TypeScript)\nDESCRIPTION: Shows how to configure a custom `Label` component for a 'text' field using the `admin.components.Label` property in the Payload field definition. This custom component will be used wherever the field's label is displayed, such as in the Edit View.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_24\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const myField: Field = {\n  name: 'myField',\n  type: 'text',\n  admin: {\n    components: {\n      Label: '/path/to/MyCustomLabelComponent', // highlight-line\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Restricting Upload MIME Types in Payload CMS TypeScript\nDESCRIPTION: This snippet demonstrates how to restrict the types of files that can be uploaded to a specific Payload CMS collection. By providing an array of MIME type strings (including wildcards like 'image/*') to the 'mimeTypes' property within the collection's 'upload' configuration, the file input in the admin UI will filter selectable files accordingly.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/overview.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Media: CollectionConfig = {\n  slug: 'media',\n  upload: {\n    mimeTypes: ['image/*', 'application/pdf'], // highlight-line\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Verifying User Email via REST API using Fetch in TypeScript\nDESCRIPTION: Demonstrates how to verify a user's email by sending a POST request to the `/api/[collection-slug]/verify/${TOKEN_HERE}` endpoint using the `fetch` API, passing the unique verification token in the URL. Requires a valid, non-expired verification token.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await fetch(\n  `http://localhost:3000/api/[collection-slug]/verify/${TOKEN_HERE}`,\n  {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Generating a Custom Meta Description Function - TypeScript\nDESCRIPTION: This snippet configures the generateDescription function for the SEO plugin, returning a meta description from a custom field (e.g., excerpt) of the current document. It enhances SEO by dynamically reflecting document content and should be supplied in the plugin options within your config.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  seoPlugin({\n    generateDescription: ({ doc }) => doc?.excerpt,\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing beforeRead Hook in Payload (TypeScript)\nDESCRIPTION: Demonstrates how to implement the beforeRead hook for a Payload collection using TypeScript. The snippet imports the CollectionBeforeReadHook type for type safety and defines an async hook function that receives all locales and hidden fields via the doc argument. This template returns the document unmodified and can be extended to manipulate docs before they are filtered or localized. Requires Payload as a dependency.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionBeforeReadHook } from 'payload'\n\nconst beforeReadHook: CollectionBeforeReadHook = async ({ doc }) => {\n  return doc\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Access Control for Update Operation - Payload CMS - TypeScript\nDESCRIPTION: Configures update access in CollectionConfig to allow updates only for authenticated users. The access function inspects the 'user' in the request and returns a boolean result. To be effective, the function should be extended for role-based or record-level restrictions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionWithUpdateAccess: CollectionConfig = {\n  // ...\n  access: {\n    // highlight-start\n    update: ({ req: { user } }) => {\n      return Boolean(user)\n    },\n    // highlight-end\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Example Email Field in a Payload CMS Collection (TypeScript)\nDESCRIPTION: This snippet provides a complete example of integrating an Email field within a Payload CMS Collection configuration. It defines a collection `ExampleCollection` with a required Email field named `contact`, including a user-friendly label. This demonstrates a practical use case for the email field type.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/email.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'contact', // required\n      type: 'email', // required\n      label: 'Contact Email Address',\n      required: true,\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Authenticating and Sending JWT with HTTP Requests in Payload (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to perform a login using Payload's users API to obtain a JWT, then how to use that token to authenticate a follow-up HTTP request by setting the Authorization header. Dependencies include fetch and TypeScript's Promise handling; the login endpoint expects valid user credentials (email and password), and the JWT received from the initial login is used for authentication in subsequent requests. Inputs required are user credentials, and outputs are the authenticated user object and authenticated fetch response.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/jwt.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst user = await fetch('http://localhost:3000/api/users/login', {\n  method: 'POST',\n  body: JSON.stringify({\n    email: 'dev@payloadcms.com',\n    password: 'password',\n  }),\n}).then((req) => await req.json())\n\nconst request = await fetch('http://localhost:3000', {\n  headers: {\n    Authorization: `JWT ${user.token}`,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Querying Document by ID - Payload CMS JavaScript\nDESCRIPTION: This snippet fetches a single document by its unique ID from a collection via the Payload Local API. It displays usage of depth, localization, user, and field visibility options. Required parameters include collection and the document ID, and recommended usage of user context and access overrides.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Result will be a Post document.\nconst result = await payload.findByID({\n  collection: 'posts', // required\n  id: '507f1f77bcf86cd799439011', // required\n  depth: 2,\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUser,\n  overrideAccess: false,\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Field with `useField` in Payload CMS (TSX)\nDESCRIPTION: This snippet shows how to create a custom text field component using the `useField` hook from `@payloadcms/ui`. It demonstrates initializing the hook with the field's `path` to get its `value` and the `setValue` function for updating the form state. The component must be marked as a client component (`'use client'`) as hooks only work client-side.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport type { TextFieldClientComponent } from 'payload'\nimport { useField } from '@payloadcms/ui'\n\nexport const CustomTextField: TextFieldClientComponent = ({ path }) => {\n  const { value, setValue } = useField({ path }) // highlight-line\n\n  return (\n    <div>\n      <p>{path}</p>\n      <input\n        onChange={(e) => {\n          setValue(e.target.value)\n        }}\n        value={value}\n      />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring an Upload Field in Payload CMS (TypeScript)\nDESCRIPTION: This snippet demonstrates how to define an Upload Field within a Payload CMS field configuration using TypeScript. The 'type' property is set to 'upload' to specify that this field will store a file reference, while the 'relationTo' property determines the target collection for the upload (here, 'media'). To use this field, ensure a collection exists and is configured for uploads via Payload CMS. The field expects a document referencing a file from the specified collection (e.g., a featured image for a page).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/upload.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyUploadField: Field = {\n  // ...\n  // highlight-start\n  type: 'upload',\n  relationTo: 'media',\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Number Field in a Payload CMS Collection using TypeScript\nDESCRIPTION: This TypeScript example demonstrates a complete implementation of a required Number field named 'age' within a Payload CMS collection configuration (`CollectionConfig`). It specifies the field type as 'number', marks it as required, and sets an admin-specific step value of 1. This code would typically reside in a collection definition file like `collections/ExampleCollection.ts`. It depends on the `CollectionConfig` type from the `payload` package.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/number.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'age', // required\n      type: 'number', // required\n      required: true,\n      admin: {\n        step: 1,\n      },\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Endpoints within a Payload CollectionConfig in TypeScript\nDESCRIPTION: Demonstrates configuring custom REST endpoints (`GET`, `POST`) within a Payload CMS `CollectionConfig` for an 'orders' collection. Includes examples for handling route parameters (`req.routeParams.id`), reading request bodies (`req.json()`), using the internal Payload API (`req.payload.update`), returning JSON responses, and implementing basic authentication checks (`req.user`). Note that custom endpoints are not authenticated by default.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\n// a collection of 'orders' with an additional route for tracking details, reachable at /api/orders/:id/tracking\nexport const Orders: CollectionConfig = {\n  slug: 'orders',\n  fields: [\n    /* ... */\n  ],\n  // highlight-start\n  endpoints: [\n    {\n      path: '/:id/tracking',\n      method: 'get',\n      handler: async (req) => {\n        const tracking = await getTrackingInfo(req.routeParams.id)\n\n        if (!tracking) {\n          return Response.json({ error: 'not found' }, { status: 404 })\n        }\n\n        return Response.json({\n          message: `Hello ${req.routeParams.name as string} @ ${req.routeParams.group as string}`,\n        })\n      },\n    },\n    {\n      path: '/:id/tracking',\n      method: 'post',\n      handler: async (req) => {\n        // `data` is not automatically appended to the request\n        // if you would like to read the body of the request\n        // you can use `data = await req.json()`\n        const data = await req.json()\n        await req.payload.update({\n          collection: 'tracking',\n          data: {\n            // data to update the document with\n          },\n        })\n        return Response.json({\n          message: 'successfully updated tracking info',\n        })\n      },\n    },\n    {\n      path: '/:id/forbidden',\n      method: 'post',\n      handler: async (req) => {\n        // this is an example of an authenticated endpoint\n        if (!req.user) {\n          return Response.json({ error: 'forbidden' }, { status: 403 })\n        }\n\n        // do something\n\n        return Response.json({\n          message: 'successfully updated tracking info',\n        })\n      },\n    },\n  ],\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing User Authentication State with useAuth in React (TypeScript)\nDESCRIPTION: Shows how to retrieve the currently logged-in user using the useAuth hook with user type from Payload in a React component. The hook can also provide logout and token-refresh methods. Requires @payloadcms/ui and the typing for User; outputs a user object with an email property for display.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport { useAuth } from '@payloadcms/ui'\\nimport type { User } from '../payload-types.ts'\\n\\nconst Greeting: React.FC = () => {\\n  // highlight-start\\n  const { user } = useAuth<User>()\\n  // highlight-end\\n\\n  return <span>Hi, {user.email}!</span>\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Field Label Client Component - React with Payload - TypeScript\nDESCRIPTION: Defines a client-only custom field label for Payload CMS using React. The component is registered as a TextFieldLabelClientComponent, using FieldLabel from @payloadcms/ui. It receives field data, path, and required status, ensuring proper label display. The 'use client' directive restricts it to client-side rendering, and external dependencies include React and @payloadcms/ui. Used for customizing field labels in client-rendered Payload UI forms.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/text.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport React from 'react'\\nimport { FieldLabel } from '@payloadcms/ui'\\nimport type { TextFieldLabelClientComponent } from 'payload'\\n\\nexport const CustomTextFieldLabelClient: TextFieldLabelClientComponent = ({\\n  field,\\n  path,\\n}) => {\\n  return (\\n    <FieldLabel\\n      label={field?.label || field?.name}\\n      path={path}\\n      required={field?.required}\\n    />\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Example .env File Content\nDESCRIPTION: Shows sample key-value pairs for common configuration variables like `SERVER_URL` and `DATABASE_URI` stored within a `.env` file. These variables are typically loaded into the application's environment.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/environment-vars.mdx#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nSERVER_URL=localhost:3000\nDATABASE_URI=mongodb://localhost:27017/my-database\n```\n\n----------------------------------------\n\nTITLE: Implementing Before Login Hook for Payload CMS (TypeScript)\nDESCRIPTION: Sets up a beforeLogin hook for authentication-enabled Payload CMS collections using TypeScript, allowing execution of custom logic before a login token is issued. The function, typed as CollectionBeforeLoginHook, receives an object containing the user and may return or modify the user object, or throw to deny login. This hook requires the 'payload' package, a TypeScript environment, and an auth-enabled collection. Expected input is the user object being logged in; output is the potentially modified user object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_12\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionBeforeLoginHook } from 'payload'\\n\\nconst beforeLoginHook: CollectionBeforeLoginHook = async ({ user }) => {\\n  return user\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Reusable Update Access Control Function with Roles - Payload CMS - TypeScript\nDESCRIPTION: Implements a reusable function, 'canUpdateUser', for sophisticated update access logic: users with the 'admin' role can update any document; regular users may update only their own resources. It takes a context object containing 'req', 'user', and 'id', and returns a boolean based on the logic. Requires 'Access' type from Payload CMS and the presence of 'roles' and 'id' properties on user objects.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Access } from 'payload'\n\nexport const canUpdateUser: Access = ({ req: { user }, id }) => {\n  // Allow users with a role of 'admin'\n  if (user.roles && user.roles.some((role) => role === 'admin')) {\n    return true\n  }\n\n  // allow any other users to update only oneself\n  return user.id === id\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Admin Options for Relationship Fields - PayloadCMS - TypeScript\nDESCRIPTION: This snippet demonstrates adding or customizing the 'admin' property on a Field definition in PayloadCMS using TypeScript. The 'admin' object can include UI controls specific to the admin panel, such as sortability, creation or editing permissions, sort behavior, and appearance. This field configuration is typically used within a Collection or Global config file and assumes the Payload and Field types are available as dependencies.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyRelationshipField: Field = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Date Field Label Client Component in Payload TSX\nDESCRIPTION: This snippet demonstrates creating a custom client component for a Date field's label in Payload CMS, using the 'use client' directive. The `CustomDateFieldLabelClient` component renders the `@payloadcms/ui/FieldLabel`, taking `field` and `path` as props. It dynamically sets the label text using `field?.label` or `field?.name` and passes the `path` and `required` status to the underlying label component.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/date.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { DateFieldLabelClientComponent } from 'payload'\n\nexport const CustomDateFieldLabelClient: DateFieldLabelClientComponent = ({\n  field,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={field?.label || field?.name}\n      path={path}\n      required={field?.required}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Date Field Label Server Component in Payload TSX\nDESCRIPTION: This snippet illustrates creating a custom server component for rendering the label associated with a Date field in Payload CMS. The `CustomDateFieldLabelServer` component uses the `@payloadcms/ui/FieldLabel` component to display the label. It determines the label text based on `clientField?.label` or `clientField?.name`, and sets the `path` and `required` status based on the provided props.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/date.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { DateFieldLabelServerComponent } from 'payload'\n\nexport const CustomDateFieldLabelServer: DateFieldLabelServerComponent = ({\n  clientField,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={clientField?.label || clientField?.name}\n      path={path}\n      required={clientField?.required}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing beforeChange Hook with Conditional Logic in Payload TypeScript\nDESCRIPTION: Shows an example of a `beforeChange` hook on an `email` field in Payload CMS. This hook demonstrates how to apply logic conditionally based on the current operation (`create` or `update`) using the `operation` argument provided to the hook function. It runs after validation but before the data is saved.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/fields.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nconst emailField: Field = {\n  name: 'email',\n  type: 'email',\n  hooks: {\n    beforeChange: [\n      ({ value, operation }) => {\n        if (operation === 'create') {\n          // Perform additional validation or transformation for 'create' operation\n        }\n        return value\n      },\n    ],\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Field Logic in Payload CMS (TypeScript)\nDESCRIPTION: Shows how to use the 'admin.condition' property to conditionally display a field ('greeting') based on the value of another field ('enableGreeting'). The condition function receives 'data' (full document), 'siblingData', and 'ctx' (context object with user, path, etc.) and must return a boolean.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n{\n  fields: [\n    {\n      name: 'enableGreeting',\n      type: 'checkbox',\n      defaultValue: false,\n    },\n    {\n      name: 'greeting',\n      type: 'text',\n      admin: {\n        // highlight-start\n        condition: (data, siblingData, { blockData, path, user }) => {\n          if (data.enableGreeting) {\n            return true\n          } else {\n            return false\n          }\n        },\n        // highlight-end\n      },\n    },\n  ]\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Filtering Relationship Field Options Dynamically - PayloadCMS - TypeScript\nDESCRIPTION: This example defines a CollectionConfig in Payload where a relationship field (to \"products\" or \"services\") uses a filterOptions function to dynamically provide a Where query. The filter function receives contextual arguments (like relationTo and siblingData) and returns filtering criteria relevant to the relationship type being referenced. This approach requires Payload's type definitions and is designed for use in the configuration of a collection, with the function potentially returning a Where query object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'purchase',\n      type: 'relationship',\n      relationTo: ['products', 'services'],\n      filterOptions: ({ relationTo, siblingData }) => {\n        // returns a Where query dynamically by the type of relationship\n        if (relationTo === 'products') {\n          return {\n            stock: { greater_than: siblingData.quantity },\n          }\n        }\n\n        if (relationTo === 'services') {\n          return {\n            isAvailable: { equals: true },\n          }\n        }\n      },\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Point Field Label Component with PayloadCMS UI (TypeScript/TSX)\nDESCRIPTION: This snippet defines a React client component, 'CustomPointFieldLabelClient', used for rendering field labels for point fields in PayloadCMS forms. It imports 'FieldLabel' from '@payloadcms/ui' and ensures type safety with the 'PointFieldLabelClientComponent' type from 'payload'. The component takes 'field' and 'path' as props, displaying the label (falling back to field name if absent) and indicating if the field is required. Inputs include field metadata and path for the form; output is a rendered FieldLabel React element. There are no external configuration requirements beyond PayloadCMS and its UI package.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/point.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n\"'use client'\\nimport React from 'react'\\nimport { FieldLabel } from '@payloadcms/ui'\\nimport type { PointFieldLabelClientComponent } from 'payload'\\n\\nexport const CustomPointFieldLabelClient: PointFieldLabelClientComponent = ({\\n  field,\\n  path,\\n}) => {\\n  return (\\n    <FieldLabel\\n      label={field?.label || field?.name}\\n      path={path}\\n      required={field?.required}\\n    />\\n  )\\n}\\n\"\n```\n\n----------------------------------------\n\nTITLE: Executing Queries with the Payload Local API in TypeScript\nDESCRIPTION: Shows how to use the `payload.find` method from the Local API to query a specific collection ('posts'). It accepts a `where` parameter containing a query object (filtering for 'color' equals 'mint') to fetch matching documents directly from the database. Requires an initialized Payload instance and the `Payload` type.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/overview.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Payload } from 'payload'\n\nconst getPosts = async (payload: Payload) => {\n  const posts = await payload.find({\n    collection: 'posts',\n    where: {\n      color: {\n        equals: 'mint',\n      },\n    },\n  })\n\n  return posts\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Cloud Storage for Payload CMS - TypeScript\nDESCRIPTION: Shows how to import and configure the gcsStorage plugin in the main Payload configuration file using TypeScript. The snippet includes example configuration for multiple collections, demonstrates the usage of environment variables for sensitive options such as bucket name, API endpoint, and project ID, and illustrates how to customize storage behavior per collection. Dependencies: @payloadcms/storage-gcs, Payload CMS, and existing collection modules. Required parameters include the collections object, bucket string, and options object, and the output is a Payload config enabling GCS-backed file storage with support for server/client uploads and per-collection prefixes.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/storage-gcs/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { gcsStorage } from '@payloadcms/storage-gcs'\nimport { Media } from './collections/Media'\nimport { MediaWithPrefix } from './collections/MediaWithPrefix'\n\nexport default buildConfig({\n  collections: [Media, MediaWithPrefix],\n  plugins: [\n    gcsStorage({\n      collections: {\n        media: true,\n        'media-with-prefix': {\n          prefix,\n        },\n      },\n      bucket: process.env.GCS_BUCKET,\n      options: {\n        apiEndpoint: process.env.GCS_ENDPOINT,\n        projectId: process.env.GCS_PROJECT_ID,\n      },\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Documents via Payload REST API\nDESCRIPTION: Performs a PATCH request to update multiple documents within a specific collection that match a given 'where' query parameter. Requires necessary authentication headers and a request body containing the fields to update.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_4\n\nLANGUAGE: HTTP\nCODE:\n```\nPATCH /api/{collection-slug}\n```\n\n----------------------------------------\n\nTITLE: Uploading Local Files using payload.create - Payload CMS - TypeScript\nDESCRIPTION: This TypeScript example shows how to upload a local file to a Payload CMS collection via the payload.create method in Node.js. It constructs an absolute file path using path.resolve and supplies it with the required collection name, data fields (such as alt), and the filePath property. Assumes that payload is initialized and path and filename variables are defined. The data property must match the requirements of the target upload-enabled collection. The method awaits the asynchronous create operation and triggers collection hooks as normal.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/overview.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst localFilePath = path.resolve(__dirname, filename)\n\nawait payload.create({\n  collection: 'media',\n  data: {\n    alt,\n  },\n  filePath: localFilePath,\n})\n\n```\n\n----------------------------------------\n\nTITLE: Querying Draft Content in Next.js Page Component (TypeScript)\nDESCRIPTION: Modifies a Next.js page component (`/app/[slug]/page.tsx`) using the App Router to conditionally fetch draft content from Payload CMS. It checks if Draft Mode is enabled using `draftMode().isEnabled` from `next/headers` and passes `draft: isDraftMode` and `overrideAccess: isDraftMode` to the Payload `find` operation accordingly. This ensures that draft versions are fetched when previewing and published versions otherwise.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/preview.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport default async function Page({ params: paramsPromise }) {\n  const { slug = 'home' } = await paramsPromise\n\n  const { isEnabled: isDraftMode } = await draftMode()\n\n  const payload = await getPayload({ config })\n\n  const page = await payload.find({\n    collection: 'pages',\n    depth: 0,\n    draft: isDraftMode, // highlight-line\n    limit: 1,\n    overrideAccess: isDraftMode,\n    where: {\n      slug: {\n        equals: slug,\n      },\n    },\n  })?.then(({ docs }) => docs?.[0])\n\n  if (page === null) {\n    return notFound()\n  }\n\n  return (\n    <main>\n      <h1>{page?.title}</h1>\n    </main>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Strongly Typed Field Hook with Payload FieldHook Generic - TypeScript\nDESCRIPTION: Shows how to declare a strongly-typed field hook using Payload's FieldHook generic for TypeScript. The example demonstrates type assignment for value, data, siblingData, and usage of other properties such as originalDoc, operation, and req. Requires importing FieldHook from Payload CMS and defining concrete types for the document and sibling data; returns a string, undefined, or null.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/fields.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { FieldHook } from 'payload'\n\n// Field hook type is a generic that takes three arguments:\n// 1: The document type\n// 2: The value type\n// 3: The sibling data type\n\ntype ExampleFieldHook = FieldHook<ExampleDocumentType, string, SiblingDataType>\n\nconst exampleFieldHook: ExampleFieldHook = (args) => {\n  const {\n    value, // Typed as `string` as shown above\n    data, // Typed as a Partial of your ExampleDocumentType\n    siblingData, // Typed as a Partial of SiblingDataType\n    originalDoc, // Typed as ExampleDocumentType\n    operation,\n    req,\n  } = args\n\n  // Do something here...\n\n  return value // should return a string as typed above, undefined, or null\n}\n\n```\n\n----------------------------------------\n\nTITLE: Querying Collections with Transactions - Payload CMS JavaScript\nDESCRIPTION: This snippet demonstrates how to use the Local API to query a collection in Payload CMS with transaction support, ensuring the req context is threaded for transactional integrity. No external dependencies apart from a properly initialized Payload instance are required. It highlights best practices by recommending the passing of the req object to support transactional databases such as Postgres or MongoDB with replica sets.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst post = await payload.find({\n  collection: 'posts',\n  req, // passing req is recommended\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing PayloadCMS TypeScript Boilerplate - Bash\nDESCRIPTION: This snippet demonstrates how to initialize a new PayloadCMS project with built-in TypeScript support using the official boilerplate generator. It requires Node.js and npm installed as prerequisites. The command downloads and executes the latest version of the create-payload-app utility, prompting the user to select a project type. Inputs include user selections during setup, and the output is a ready-to-use PayloadCMS TypeScript project in the chosen directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/overview.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-payload-app@latest\n```\n\n----------------------------------------\n\nTITLE: Preventing Infinite Loops in Payload `afterChange` Hook using Context (TypeScript)\nDESCRIPTION: Shows the correct way to update a document within its own `afterChange` hook by using the `context` object. A flag (`triggerAfterChange`) is checked at the start of the hook and set to `false` when calling `req.payload.update` via its `context` option, preventing subsequent recursive executions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/context.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nconst MyCollection: CollectionConfig = {\n  slug: 'slug',\n  hooks: {\n    afterChange: [\n      async ({ context, doc, req }) => {\n        // return if flag was previously set\n        if (context.triggerAfterChange === false) {\n          return\n        }\n        await req.payload.update({\n          collection: contextHooksSlug,\n          id: doc.id,\n          data: {\n            ...(await fetchCustomerData(data.customerID)),\n          },\n          context: {\n            // set a flag to prevent from running again\n            triggerAfterChange: false,\n          },\n        })\n      },\n    ],\n  },\n  fields: [\n    /* ... */\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Output File Path for Generated Types - Payload CMS - TypeScript\nDESCRIPTION: This snippet shows how to specify a custom output file path for the generated TypeScript types by setting the 'outputFile' property. The value uses Node.js 'path.resolve' to ensure the path is absolute. Without this option, types are generated by default as 'payload-types.ts' next to the config file. Use this to control type file placement for easier organization.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/generating-types.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n\ttypescript: {\n    // defaults to: path.resolve(__dirname, './payload-types.ts')\n\t\toutputFile: path.resolve(__dirname, './generated-types.ts'),\n\t},\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Documents with Type Inference - Payload CMS TypeScript\nDESCRIPTION: This TypeScript example demonstrates how local API calls to Payload CMS are automatically type-inferred using regenerated types, ensuring type safety and code intelligence. The data object conforms to the typed shape of the \"Post\" collection. TypeScript must be enabled in the project, and types generated via Payload's codegen tools.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Properly inferred as `Post` type\nconst post = await payload.create({\n  collection: 'posts',\n\n  // Data will now be typed as Post and give you type hints\n  data: {\n    title: 'my title',\n    description: 'my description',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing a Configurable Payload Plugin Factory (TypeScript)\nDESCRIPTION: Factory function for building a configurable Payload CMS plugin in TypeScript. Accepts plugin-specific options, clones and extends incoming config, modifies arrays with spread syntax, and extends lifecycle hooks. Requires TypeScript and payload types. Inputs: pluginOptions, incomingConfig; Output: modified config for Payload CMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Config } from 'payload'\n\nexport const samplePlugin =\n  (pluginOptions: PluginTypes) =>\n  (incomingConfig: Config): Config => {\n    // create copy of incoming config\n    let config = { ...incomingConfig }\n\n    /**\n    * This is where you could modify the\n    * config based on the plugin options\n    */\n\n    // If you wanted to add a new collection:\n    config.collections = [\n      ...(config.collections || []),\n      newCollection,\n    ]\n\n    // If you wanted to add a new global:\n    config.globals = [\n      ...(config.globals || []),\n      newGlobal,\n    ]\n\n    /**\n    * If you wanted to add a new field to a collection:\n    *\n    * 1. Loop over collections\n    * 2. Find the collection you want to add the field to\n    * 3. Add the field to the collection\n    */\n\n    // If you wanted to add to the onInit:\n    config.onInit = async payload => {\n      if (incomingConfig.onInit) await incomingConfig.onInit(payload)\n      // Add additional onInit code here\n    }\n\n    // Finally, return the modified config\n    return config\n }\n```\n\n----------------------------------------\n\nTITLE: Registering Root Hooks in Payload CMS Configuration (TypeScript)\nDESCRIPTION: This snippet demonstrates how to register root-level hooks in the Payload CMS configuration file using TypeScript. Developers add a hooks property to the exported buildConfig call, assigning specific hook types (such as afterError) as arrays of functions. This approach provides global extensibility for side effects or integration logic in the Payload app. The snippet requires the Payload CMS package and an understanding of its config structure. The hooks property accepts arrays of synchronous or asynchronous hook functions. Inputs include the desired hook type and functions to run; output is an exported configuration object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/overview.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  // highlight-start\n  hooks: {\n    afterError:[() => {...}]\n  },\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling Declare Statement in Generated Types - Payload CMS - TypeScript\nDESCRIPTION: This snippet demonstrates how to disable the default 'declare' statement in the TypeScript types file generated by Payload CMS. By setting 'declare: false' under the typescript configuration, you prevent the file from auto-including global type declarations, which is useful if you plan to share the types externally (e.g., in other repositories) where Payload might not be installed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/generating-types.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  typescript: {\n    declare: false, // defaults to true if not set\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Field-Level Hooks in Payload (TypeScript)\nDESCRIPTION: This snippet illustrates how to configure field-level hooks within a Payload field definition using the `Field` type. It shows adding the `hooks` property (an object) to the field configuration, enabling granular logic execution tied specifically to this field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyField: Field = {\n  type: 'text',\n  name: 'myField',\n  // highlight-start\n  hooks: {\n    // ...\n  },\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Read Versions Access Control for Global - Payload CMS - TypeScript\nDESCRIPTION: Shows how to set a `readVersions` access function in the Global Config to govern version history access for authenticated users. Intended for version-enabled Globals in Payload CMS; returns a boolean to allow or restrict viewing of historic versions. Useful for managing advanced permissions around version control.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/globals.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalConfig } from 'payload'\n\nexport const GlobalWithVersionsAccess: GlobalConfig = {\n  // ...\n  access: {\n    // highlight-start\n    readVersions: ({ req: { user } }) => {\n      return Boolean(user)\n    },\n    // highlight-end\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an afterForgotPassword Collection Hook in TypeScript\nDESCRIPTION: This snippet demonstrates the structure of an `afterForgotPassword` hook function for an Auth-enabled Payload Collection. This hook executes after a successful `forgotPassword` operation. It receives `args` (operation arguments), `context` (custom data), and `collection` (the Collection config) as parameters. Any value returned by this hook is discarded.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionAfterForgotPasswordHook } from 'payload'\n\nconst afterForgotPasswordHook: CollectionAfterForgotPasswordHook = async ({\n  args,\n  context,\n  collection,\n}) => {...}\n```\n\n----------------------------------------\n\nTITLE: NPM Script for Generating Types with Custom Payload Config Path - Payload CMS - JSON\nDESCRIPTION: This JSON snippet provides a custom npm script definition in 'package.json' for generating Payload types when the config is not in the root directory. It sets the 'PAYLOAD_CONFIG_PATH' environment variable to specify the path to 'payload.config.ts'. Running 'pnpm generate:types' will trigger Payload to read the specific config and output types accordingly.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/generating-types.mdx#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"generate:types\": \"PAYLOAD_CONFIG_PATH=src/payload.config.ts payload generate:types\",\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Direct Database Transaction Management in Payload Script using TypeScript\nDESCRIPTION: Shows how to manually control database transactions in a standalone Payload script. It initializes Payload, starts a transaction using `payload.db.beginTransaction()`, performs a database update via the Local API (`payload.update`) ensuring it uses the transaction by passing `{ transactionID }` in a mock `req` object, and then either commits (`payload.db.commitTransaction`) or rolls back (`payload.db.rollbackTransaction`) based on success or failure within a try/catch block.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/transactions.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport payload from 'payload'\nimport config from './payload.config'\n\nconst standalonePayloadScript = async () => {\n  // initialize Payload\n  await payload.init({ config })\n\n  const transactionID = await payload.db.beginTransaction()\n\n  try {\n    // Make an update using the Local API\n    await payload.update({\n      collection: 'posts',\n      data: {\n        some: 'data',\n      },\n      where: {\n        slug: { equals: 'my-slug' },\n      },\n      req: { transactionID },\n    })\n\n    /*\n      You can make additional db changes or run other functions\n      that need to be committed on an all or nothing basis\n     */\n\n    // Commit the transaction\n    await payload.db.commitTransaction(transactionID)\n  } catch (error) {\n    // Rollback the transaction\n    await payload.db.rollbackTransaction(transactionID)\n  }\n}\n\nstandalonePayloadScript()\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Next.js API Route for Draft Mode Activation (TypeScript)\nDESCRIPTION: Implements a Next.js API route handler (`/app/preview/route.ts`) using the App Router that receives the preview request generated by Payload. It validates the `previewSecret` from query parameters against an environment variable, authenticates the user using `payload.auth` with the request cookies, enables Next.js Draft Mode using `draftMode().enable()` from `next/headers`, and finally redirects the user to the intended preview path using `redirect` from `next/navigation`. Requires a Payload instance, config promise (`@payload-config`), and necessary imports.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/preview.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionSlug, PayloadRequest } from 'payload'\nimport { getPayload } from 'payload'\n\nimport { draftMode } from 'next/headers'\nimport { redirect } from 'next/navigation'\n\nimport configPromise from '@payload-config'\n\nexport async function GET(\n  req: {\n    cookies: {\n      get: (name: string) => {\n        value: string\n      }\n    }\n  } & Request,\n): Promise<Response> {\n  const payload = await getPayload({ config: configPromise })\n\n  const { searchParams } = new URL(req.url)\n\n  const path = searchParams.get('path')\n  const collection = searchParams.get('collection') as CollectionSlug\n  const slug = searchParams.get('slug')\n  const previewSecret = searchParams.get('previewSecret')\n\n  if (previewSecret !== process.env.PREVIEW_SECRET) {\n    return new Response('You are not allowed to preview this page', {\n      status: 403,\n    })\n  }\n\n  if (!path || !collection || !slug) {\n    return new Response('Insufficient search params', { status: 404 })\n  }\n\n  if (!path.startsWith('/')) {\n    return new Response(\n      'This endpoint can only be used for relative previews',\n      { status: 500 },\n    )\n  }\n\n  let user\n\n  try {\n    user = await payload.auth({\n      req: req as unknown as PayloadRequest,\n      headers: req.headers,\n    })\n  } catch (error) {\n    payload.logger.error(\n      { err: error },\n      'Error verifying token for live preview',\n    )\n    return new Response('You are not allowed to preview this page', {\n      status: 403,\n    })\n  }\n\n  const draft = await draftMode()\n\n  if (!user) {\n    draft.disable()\n    return new Response('You are not allowed to preview this page', {\n      status: 403,\n    })\n  }\n\n  // You can add additional checks here to see if the user is allowed to preview this page\n\n  draft.enable()\n\n  redirect(path)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Initiating Forgot Password via Local API in TypeScript\nDESCRIPTION: Utilizes the `payload.forgotPassword` method from the Payload Local API to initiate the password reset flow programmatically. It requires specifying the target collection slug and providing the user's email in the `data` object. The `disableEmail` option allows preventing the automatic email dispatch, returning the generated reset token directly, which is useful for custom workflows.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nconst token = await payload.forgotPassword({\n  collection: 'collection-slug',\n  data: {\n    email: 'dev@payloadcms.com',\n  },\n  disableEmail: false, // you can disable the auto-generation of email via Local API\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing the Plugins Array in Payload Config with TypeScript\nDESCRIPTION: This snippet demonstrates the basic structure of a Payload configuration file using `buildConfig` from the 'payload' library. It highlights the `plugins` property, an array where plugin functions are added to extend Payload's functionality. This is the entry point for integrating any plugin into a Payload application.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/overview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  // highlight-start\n  plugins: [\n    // Add Plugins here\n  ],\n  // highlight-end\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Query Filter in TypeScript\nDESCRIPTION: Imports the `Where` type from Payload and defines a simple query object. This query filters for documents where the 'color' field is exactly equal to 'blue'. This structure is fundamental for filtering data across different Payload APIs.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/overview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Where } from 'payload'\n\nconst query: Where = {\n  color: {\n    equals: 'blue',\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Relationship Field in Payload CMS Configuration (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates how to define a relationship field within a Payload CMS field configuration. It imports the Field type from Payload and exports a field config object with type set to 'relationship' and relationTo assigned to the 'products' collection. Required dependencies include the Payload CMS package. The key parameters are 'type' (which must be 'relationship') and 'relationTo' (specifying the collection to relate to). The output is a valid Relationship field config for integration into a Payload collection or global config file. This example assumes familiarity with Payload CMS field definitions and requires correct collection slugs to function.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyRelationshipField: Field = {\n  // ...\n  // highlight-start\n  type: 'relationship',\n  relationTo: 'products',\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying select Parameters in REST API Requests - JavaScript\nDESCRIPTION: Demonstrates how to specify select query parameters directly in a REST API request URL to control returned fields. Achieves fine-grained selection, including nested fields, through URL query parameters compatible with PayloadCMS. The snippet is standalone JavaScript for browser or Node fetch usage, and expects a valid API URL.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/select.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfetch(\n  'https://localhost:3000/api/posts?select[color]=true&select[group][number]=true',\n) // highlight-line\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n```\n\n----------------------------------------\n\nTITLE: Updating Multiple Documents - Payload CMS JavaScript\nDESCRIPTION: This snippet bulk-updates multiple documents using a 'where' condition in the Payload Local API. It supports the same uploading and localization options as the single-update method, with an output that includes updated documents and error details if any occur. The result is a structured object containing docs and errors arrays, enabling review of both successful and failed operations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Result will be an object with:\n// {\n//   docs: [], // each document that was updated\n//   errors: [], // each error also includes the id of the document\n// }\nconst result = await payload.update({\n  collection: 'posts', // required\n  where: {\n    // required\n    fieldName: { equals: 'value' },\n  },\n  data: {\n    // required\n    title: 'sure',\n    description: 'maybe',\n  },\n  depth: 0,\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUser,\n  overrideAccess: false,\n  overrideLock: false, // By default, document locks are ignored. Set to false to enforce locks.\n  showHiddenFields: true,\n\n  // If your collection supports uploads, you can upload\n  // a file directly through the Local API by providing\n  // its full, absolute file path.\n  filePath: path.resolve(__dirname, './path-to-image.jpg'),\n\n  // If you are uploading a file and would like to replace\n  // the existing file instead of generating a new filename,\n  // you can set the following property to `true`\n  overwriteExistingFiles: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Queuing a Workflow Job - Payload CMS - TypeScript\nDESCRIPTION: This snippet demonstrates how to queue a new Job in Payload CMS, referencing an existing Workflow named 'createPostAndUpdate'. It uses the async function 'payload.jobs.queue' to enqueue the workflow with automatically typed input. Requires the Payload CMS Node.js API to be set up and accessible as 'payload'. The main parameter is the workflow name and its associated input, and it returns the created Job object with details about execution status.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/jobs.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst createdJob = await payload.jobs.queue({\n  // Pass the name of the workflow\n  workflow: 'createPostAndUpdate',\n  // The input type will be automatically typed\n  // according to the input you've defined for this workflow\n  input: {\n    title: 'my title',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Default Field Validation Functions in Payload CMS (TypeScript)\nDESCRIPTION: This snippet lists the available default field validation functions that can be imported from `payload/shared`. These functions correspond to the various field types available in Payload CMS and can be reused within custom validation logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport {\n  array,\n  blocks,\n  checkbox,\n  code,\n  date,\n  email,\n  group,\n  json,\n  number,\n  point,\n  radio,\n  relationship,\n  richText,\n  select,\n  tabs,\n  text,\n  textarea,\n  upload,\n} from 'payload/shared'\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Global Lifecycle Hooks in Payload CMS - TypeScript\nDESCRIPTION: This code block provides a configuration object for a Payload CMS global that registers all standard global hooks (beforeValidate, beforeChange, beforeRead, afterChange, and afterRead) as function arrays. Each hook receives its context-relevant arguments and can be implemented with synchronous or asynchronous logic to customize global document behavior. This approach allows developers to define validation, transformation, and side-effect operations for global document updates.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/globals.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalConfig } from 'payload';\n\nconst GlobalWithHooks: GlobalConfig = {\n  // ...\n  // highlight-start\n  hooks: {\n    beforeValidate: [(args) => {...}],\n    beforeChange: [(args) => {...}],\n    beforeRead: [(args) => {...}],\n    afterChange: [(args) => {...}],\n    afterRead: [(args) => {...}],\n  }\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Text Field to a Payload Collection (TypeScript)\nDESCRIPTION: This code demonstrates adding a basic 'text' field named 'field' to the `fields` array within a Payload `CollectionConfig`. It shows a minimal field definition object containing the required `name` and `type` properties.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Page: CollectionConfig = {\n  slug: 'pages',\n  // highlight-start\n  fields: [\n    {\n      name: 'field',\n      type: 'text',\n    },\n  ],\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Access Control for Create Operation - Payload CMS - TypeScript\nDESCRIPTION: Implements access control for the create operation, allowing document creation only if the 'user' is present in the request context. Requires correct typing from 'payload' and expects 'user' authentication implemented. Inputs: the access function receives a 'req' with 'user' and a 'data' payload. Output: boolean indicating if creation is allowed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionWithCreateAccess: CollectionConfig = {\n  // ...\n  access: {\n    // highlight-start\n    create: ({ req: { user }, data }) => {\n      return Boolean(user)\n    },\n    // highlight-end\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Querying and Paginating Collections - Payload CMS JavaScript\nDESCRIPTION: This example shows how to query and paginate collection documents using Payload's Local API. It supports filtering via 'where', control over pagination and sorting, multilingual settings, and user context. The snippet demonstrates result pagination, hidden fields, and access overrides. Key parameters: collection, depth, page, limit, where, and others for localization and security.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Result will be a paginated set of Posts.\n// See /docs/queries/pagination for more.\nconst result = await payload.find({\n  collection: 'posts', // required\n  depth: 2,\n  page: 1,\n  limit: 10,\n  pagination: false, // If you want to disable pagination count, etc.\n  where: {}, // pass a `where` query here\n  sort: '-title',\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUser,\n  overrideAccess: false,\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Vercel Blob Storage in Payload CMS with TypeScript\nDESCRIPTION: Sets up Payload CMS with the Vercel Blob storage plugin for media file uploads. Requires the \"@payloadcms/storage-vercel-blob\" package and ensures \"BLOB_READ_WRITE_TOKEN\" is set in your environment variables. The configuration maps which collections use the Vercel Blob adapter, optionally adding a prefix or customizing options. Setting \"clientUploads\" to true enables direct client uploads to bypass Vercel's 4.5MB server upload limit. Expects an object containing \"collections\", \"token\", and optional provider-specific options, returning a Payload config.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { vercelBlobStorage } from '@payloadcms/storage-vercel-blob'\nimport { Media } from './collections/Media'\nimport { MediaWithPrefix } from './collections/MediaWithPrefix'\n\nexport default buildConfig({\n  collections: [Media, MediaWithPrefix],\n  plugins: [\n    vercelBlobStorage({\n      enabled: true, // Optional, defaults to true\n      // Specify which collections should use Vercel Blob\n      collections: {\n        media: true,\n        'media-with-prefix': {\n          prefix: 'my-prefix',\n        },\n      },\n      // Token provided by Vercel once Blob storage is added to your Vercel project\n      token: process.env.BLOB_READ_WRITE_TOKEN,\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Sorting by Multiple Fields via Payload REST API (JavaScript Fetch)\nDESCRIPTION: This snippet shows how to fetch documents sorted by multiple fields using the Payload REST API. It uses `fetch` to query the '/api/posts' endpoint with the `sort` query parameter set to `priority,-createdAt`. Fields are separated by commas. This sorts posts first by 'priority' (ascending) and then by 'createdAt' (descending).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/sort.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nfetch('https://localhost:3000/api/posts?sort=priority,-createdAt') // highlight-line\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n```\n\n----------------------------------------\n\nTITLE: Integrating Payload Hook with Request Transaction in TypeScript\nDESCRIPTION: Demonstrates how to ensure a database operation within a Payload `afterChange` hook is part of the main request's transaction. By passing the `req` object (which contains `req.transactionID` assigned by Payload) to the `req.payload.create` call, the creation of 'my-slug' will only be persisted if the entire original request, including the hook execution, completes successfully without errors.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/transactions.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst afterChange: CollectionAfterChangeHook = async ({ req }) => {\n  // because req.transactionID is assigned from Payload and passed through,\n  // my-slug will only persist if the entire request is successful\n  await req.payload.create({\n    req,\n    collection: 'my-slug',\n    data: {\n      some: 'data',\n    },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Deleting Document by ID - Payload CMS JavaScript\nDESCRIPTION: This code deletes a single document by its ID in a specified collection using the Local API. It returns the deleted document, allowing for confirmation or audit. Parameters for user and document lock control, with localization and visibility options, are demonstrated. Access and locking can be controlled via override flags.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Result will be the now-deleted Post document.\nconst result = await payload.delete({\n  collection: 'posts', // required\n  id: '507f1f77bcf86cd799439011', // required\n  depth: 2,\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUser,\n  overrideAccess: false,\n  overrideLock: false, // By default, document locks are ignored. Set to false to enforce locks.\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Overriding the Default Field Component in Payload Config (TypeScript)\nDESCRIPTION: This configuration snippet shows how to replace the default form field component rendered in the Edit View for a specific field. It assigns the path to a custom React component file to the `Field` property within the `admin.components` object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionConfig: CollectionConfig = {\n  // ...\n  fields: [\n    // ...\n    {\n      // ...\n      admin: {\n        components: {\n          Field: '/path/to/MyFieldComponent', // highlight-line\n        },\n      },\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Example Document Data for Many-to-One Relationship Field - PayloadCMS - JSON\nDESCRIPTION: This snippet provides the JSON structure for documents storing many-to-one relationships using an array of ObjectIDs in the 'owners' field. This format is utilized when the field is configured with hasMany: true and references a single collection. This array of IDs is used for both saving and querying related values.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_10\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"owners\": [\"6031ac9e1289176380734024\", \"602c3c327b811235943ee12b\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Server Field Label in Payload CMS (TypeScript/React)\nDESCRIPTION: This TypeScript React server component (`CustomCodeFieldLabelServer`) renders a custom label for a code field within the Payload CMS admin UI. It receives server-side context via props (`clientField`, `path`) and utilizes the `@payloadcms/ui` `FieldLabel` component. The label displayed is either the `clientField.label` or falls back to `clientField.name`. It also passes the `required` status from the `clientField`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/code.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { CodeFieldLabelServerComponent } from 'payload'\n\nexport const CustomCodeFieldLabelServer: CodeFieldLabelServerComponent = ({\n  clientField,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={clientField?.label || clientField?.name}\n      path={path}\n      required={clientField?.required}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Generating select Query Strings with qs-esm Package - TypeScript\nDESCRIPTION: Shows how to programmatically generate a select query string for PayloadCMS REST API requests using the qs-esm package in TypeScript. Leverages type safety for query object construction and stringifies deeply nested select conditions. Requires qs-esm and type {Where} from payload. Input is a Where select object; output is a query string used in a fetch request.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/select.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { stringify } from 'qs-esm'\nimport type { Where } from 'payload'\n\nconst select: Where = {\n  text: true,\n  group: {\n    number: true,\n  },\n  // This query could be much more complex\n  // and QS would handle it beautifully\n}\n\nconst getPosts = async () => {\n  const stringifiedQuery = stringify(\n    {\n      select, // ensure that `qs` adds the `select` property, too!\n    },\n    { addQueryPrefix: true },\n  )\n\n  const response = await fetch(\n    `http://localhost:3000/api/posts${stringifiedQuery}`,\n  )\n  // Continue to handle the response below...\n}\n```\n\n----------------------------------------\n\nTITLE: Making an Authenticated API Request Using API Key (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to authenticate a fetch request to a Payload CMS REST (or GraphQL) endpoint using an API key. The 'Authorization' header is constructed using the collection slug, the 'API-Key' string, and the API key value assigned to the user. Use this pattern in external applications or services to perform authenticated requests on behalf of a user with an API key; the provided API key should be securely generated and stored.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/api-keys.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport Users from '../collections/Users'\n\nconst response = await fetch('http://localhost:3000/api/pages', {\n  headers: {\n    Authorization: `${Users.slug} API-Key ${YOUR_API_KEY}`,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Querying with Drizzle ORM Tables in PayloadCMS (TypeScript)\nDESCRIPTION: Details how to import Drizzle ORM tables and query utilities for type-safe queries directly within PayloadCMS. Imports table definitions from the generated Drizzle file and query builders (`eq`, `sql`, `and`) from the SQLite adapter. Demonstrates both Drizzle's querying (`findMany`) and select APIs, including advanced filtering with raw SQL and chained conditions. Assumes prior execution of schema generation and existence of the `posts` table artifact.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/sqlite.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Import table from the generated file\nimport { posts } from './payload-generated-schema'\n// To avoid installing Drizzle, you can import everything that drizzle has from our re-export path.\nimport { eq, sql, and } from '@payloadcms/db-sqlite/drizzle'\n\n// Drizzle's Querying API: https://orm.drizzle.team/docs/rqb\nconst posts = await payload.db.drizzle.query.posts.findMany()\n// Drizzle's Select API https://orm.drizzle.team/docs/select\nconst result = await payload.db.drizzle\n  .select()\n  .from(posts)\n  .where(\n    and(eq(posts.id, 50), sql`lower(${posts.title}) = 'example post title'`),\n  )\n```\n\n----------------------------------------\n\nTITLE: Example Field Configuration with All Hook Types in Payload TypeScript\nDESCRIPTION: Demonstrates a sample Payload Field configuration (`FieldWithHooks`) illustrating the placement of all available field hook types: `beforeValidate`, `beforeChange`, `beforeDuplicate`, `afterChange`, and `afterRead`. Each hook accepts an array of synchronous or asynchronous functions. Requires the `Field` type from Payload.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/fields.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload';\n\nconst FieldWithHooks: Field = {\n  name: 'name',\n  type: 'text',\n  // highlight-start\n  hooks: {\n    beforeValidate: [(args) => {...}],\n    beforeChange: [(args) => {...}],\n    beforeDuplicate: [(args) => {...}],\n    afterChange: [(args) => {...}],\n    afterRead: [(args) => {...}],\n  }\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Building Dynamic Preview URL using Request Object (TypeScript)\nDESCRIPTION: Demonstrates how to use the `req` object, provided as an argument to the `preview` function, to construct a fully qualified URL dynamically using the request's protocol and host. This is useful for environments like Vercel Preview Deployments where the hostname might vary.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/preview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\npreview: (doc, { req }) => `${req.protocol}//${req.host}/${doc.slug}` // highlight-line\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing JWT Token Data in PayloadCMS Access Control (TypeScript)\nDESCRIPTION: Illustrates how to use custom JWT token data (such as role) in PayloadCMS access control logic within a collection config. Depends on the shape of req.user as determined by the saveToJWT config in authentication collections. Parameters include req.user properties (e.g., role, id); the function expects to authorize based on user role or resource ownership. Used as part of the access control settings in collection configurations; outputs a boolean indicating permission.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/token-data.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Invoices: CollectionConfig = {\n  slug: 'invoices',\n  access: {\n    read: ({ req, data }) => {\n      if (!req?.user) return false\n      // highlight-start\n      if ({ req.user?.role === 'super-admin'}) {\n        return true\n      }\n      // highlight-end\n      return data.owner === req.user.id\n    }\n  }\n  fields: [\n    {\n      name: 'owner',\n      relationTo: 'users'\n    },\n    // ... other fields\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Lexical JSON to HTML On-Demand in React (Client)\nDESCRIPTION: Demonstrates using the `convertLexicalToHTML` function within a React client component ('use client') to transform Lexical's `SerializedEditorState` JSON data into an HTML string. The resulting HTML is then rendered using `dangerouslySetInnerHTML`. This is the recommended approach for frontend display.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-html.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\nimport { convertLexicalToHTML } from '@payloadcms/richtext-lexical/html'\n\nimport React from 'react'\n\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) => {\n  const html = convertLexicalToHTML({ data })\n\n  return <div dangerouslySetInnerHTML={{ __html: html }} />\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Date Field in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates the basic configuration for defining a Date Field within a Payload CMS collection or global. It imports the 'Field' type from 'payload' and sets the 'type' property to 'date' to designate the field as a date input.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/date.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyDateField: Field = {\n  // ...\n  type: 'date', // highlight-line\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Refresh Token Server Action in TypeScript\nDESCRIPTION: Defines a Next.js server action (`refreshAction`) that wraps the Payload `refresh` function. It imports the Payload config, specifies the user collection slug, calls the `refresh` function, and includes error handling. This server action is necessary as the Payload config cannot be accessed directly from the client.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n'use server'\n\nimport { refresh } from '@payloadcms/next/auth'\nimport config from '@payload-config'\n\nexport async function refreshAction() {\n  try {\n    return await refresh({\n      collection: 'users', // Specify the user collection slug\n      config, // Pass the Payload config\n    })\n  } catch (error) {\n    throw new Error(\n      `Refresh failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    )\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Extending Default Node Types in Typed Editor State - Payload Rich Text - TypeScript\nDESCRIPTION: Illustrates extending the DefaultTypedEditorState type to support custom node types alongside the default ones in the Lexical editor for PayloadCMS. Supply additional node types (such as SerializedBlockNode and YourCustomSerializedNode) as generics. Only type declarations are shown; actual structure and dependencies must be defined elsewhere.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/overview.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nDefaultTypedEditorState<SerializedBlockNode | YourCustomSerializedNode>\n```\n\n----------------------------------------\n\nTITLE: Generating a Custom Meta Image Function - TypeScript\nDESCRIPTION: This snippet configures the generateImage function used by the SEO plugin to retrieve an image for metadata, such as from a doc's featuredImage property. It enables richer link previews and should be used as part of the plugin configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  seoPlugin({\n    generateImage: ({ doc }) => doc?.featuredImage,\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Stripe SDK in Node.js Server (TypeScript)\nDESCRIPTION: This snippet demonstrates how to initialize and use the official Stripe SDK in a Node.js server environment. It authenticates using an environment variable for the Stripe secret key, sets the API version, and shows a sample async function for creating a Stripe customer and handling potential errors. Dependencies include the Stripe npm module and a properly configured environment.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/stripe.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport Stripe from 'stripe'\n\nconst stripeSecretKey = process.env.STRIPE_SECRET_KEY\nconst stripe = new Stripe(stripeSecretKey, {\n  apiVersion: '2022-08-01',\n})\n\nexport const MyFunction = async () => {\n  try {\n    const customer = await stripe.customers.create({\n      email: data.email,\n    })\n\n    // do something...\n  } catch (error) {\n    console.error(error.message)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing a Custom Payload Bin Script (Shell)\nDESCRIPTION: Demonstrates the command-line execution of a custom Payload bin script (registered with the key 'seed') using `pnpm`. This command invokes the Payload CLI, which in turn runs the associated script.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n```sh\npnpm payload seed\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Field Validation in Payload CMS (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create an asynchronous custom validation function using `async`/`await`. It optimizes performance by checking the `event` property from the context (`ctx`) and only performing an expensive operation (an external API call via `fetch`) when the form is submitted (`event === 'submit'`), not on every field change (`onChange`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Orders: CollectionConfig = {\n  slug: 'orders',\n  fields: [\n    {\n      name: 'customerNumber',\n      type: 'text',\n      // highlight-start\n      validate: async (val, { event }) => {\n        if (event === 'onChange') {\n          return true\n        }\n\n        // only perform expensive validation when the form is submitted\n        const response = await fetch(`https://your-api.com/customers/${val}`)\n\n        if (response.ok) {\n          return true\n        }\n\n        return 'The customer number provided does not match any customers within our records.'\n      },\n      // highlight-end\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Disabling Local Authentication and Enabling API Key-Only Auth in Payload CMS (TypeScript)\nDESCRIPTION: This snippet shows how to restrict authentication on a Payload CMS collection to API keys only by setting 'disableLocalStrategy' to true. With this configuration, email and password authentication is disabled, and only API Key authentication is permitted. This is useful for scenarios that require automated or service-to-service integrations without user/password credentials; ensure only intended users have API key access.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/api-keys.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ThirdPartyAccess: CollectionConfig = {\n  slug: 'third-party-access',\n  auth: {\n    useAPIKey: true,\n    disableLocalStrategy: true, // highlight-line\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Async Payload Hooks with Transactions in TypeScript\nDESCRIPTION: Illustrates potential issues and correct handling of asynchronous operations within Payload hooks concerning transactions. The first `create` call (`dangerouslyIgnoreAsync`) is part of the transaction but not awaited, risking an incorrect success response if it later fails and rolls back. The second `create` call (`safelyIgnoredAsync`) is intentionally excluded from the transaction by not passing the `req` object, ensuring its potential failure doesn't cause a rollback of other operations within the main request's transaction.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/transactions.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst afterChange: CollectionAfterChangeHook = async ({ req }) => {\n  // WARNING: an async call made with the same req, but NOT awaited,\n  // may fail resulting in an OK response being returned with response data that is not committed\n  const dangerouslyIgnoreAsync = req.payload.create({\n    req,\n    collection: 'my-slug',\n    data: {\n      some: 'other data',\n    },\n  })\n\n  // Should this call fail, it will not rollback other changes\n  // because the req (and its transactionID) is not passed through\n  const safelyIgnoredAsync = req.payload.create({\n    collection: 'my-slug',\n    data: {\n      some: 'other data',\n    },\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Hooks Property to Collection Configuration (TypeScript)\nDESCRIPTION: Demonstrates how to add the `hooks` property to a Payload CMS `CollectionConfig` object. This property serves as the container for defining various collection-level hooks.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionWithHooks: CollectionConfig = {\n  // ...\n  hooks: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding defaultPopulate with populate Option in Local API - Payload CMS TypeScript\nDESCRIPTION: Explains how to override the defaultPopulate collection field selection by specifying the populate property in a local API query. Allows for granular control over which fields from related collections are returned during population. Requires an instance of Payload and TypeScript environment; demonstrates use of deeply-nested field selection for population.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/select.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Payload } from 'payload'\n\nconst getPosts = async (payload: Payload) => {\n  const posts = await payload.find({\n    collection: 'posts',\n    populate: {\n      // Select only `text` from populated docs in the \"pages\" collection\n      // Now, no matter what the `defaultPopulate` is set to on the \"pages\" collection,\n      // it will be overridden, and the `text` field will be returned instead.\n      pages: {\n        text: true,\n      }, // highlight-line\n    },\n  })\n\n  return posts\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Nested Docs Plugin in Payload Config - TypeScript\nDESCRIPTION: Demonstrates how to register and configure the nestedDocsPlugin within the plugins array in a Payload CMS configuration file. This setup enables hierarchical parent/child relationships for the 'pages' collection and customizes breadcrumbs generation with generateLabel and generateURL callback functions. Dependencies include 'payload' and '@payloadcms/plugin-nested-docs'. Key options: 'collections', 'generateLabel', and 'generateURL' for label/URL generation for each document's breadcrumbs. Returns a fully configured Payload config object; expects input collections and relevant fields. Ensure any referenced fields ('title', 'slug') exist in the schema.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/nested-docs.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { nestedDocsPlugin } from '@payloadcms/plugin-nested-docs'\n\nconst config = buildConfig({\n  collections: [\n    {\n      slug: 'pages',\n      fields: [\n        {\n          name: 'title',\n          type: 'text',\n        },\n        {\n          name: 'slug',\n          type: 'text',\n        },\n      ],\n    },\n  ],\n  plugins: [\n    nestedDocsPlugin({\n      collections: ['pages'],\n      generateLabel: (_, doc) => doc.title,\n      generateURL: (docs) =>\n        docs.reduce((url, doc) => `${url}/${doc.slug}`, ''),\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Text Field Server Component - React with Payload - TypeScript\nDESCRIPTION: Implements a server-rendered custom text field for Payload CMS admin UI using React and TypeScript. Utilizes the TextField component from @payloadcms/ui and registers it as a TextFieldServerComponent type. Receives props such as clientField, path, schemaPath, and permissions, which are passed through to the inner TextField, allowing for permission-sensitive server-side rendering. Requires Payload and @payloadcms/ui as dependencies, with TypeScript for type safety.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/text.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport type React from 'react'\\nimport { TextField } from '@payloadcms/ui'\\nimport type { TextFieldServerComponent } from 'payload'\\n\\nexport const CustomTextFieldServer: TextFieldServerComponent = ({\\n  clientField,\\n  path,\\n  schemaPath,\\n  permissions,\\n}) => {\\n  return (\\n    <TextField\\n      field={clientField}\\n      path={path}\\n      schemaPath={schemaPath}\\n      permissions={permissions}\\n    />\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Fetching Payload Resources with Credentials using TypeScript\nDESCRIPTION: Demonstrates how to use the `fetch` API in TypeScript to retrieve resources from a Payload API, ensuring authentication cookies are included by setting the `credentials` option to `'include'`. This is necessary for authenticated requests made via JavaScript APIs.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/cookies.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst response = await fetch('http://localhost:3000/api/pages', {\n  credentials: 'include',\n})\n\nconst pages = await response.json()\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Global Config Structure in Payload (TypeScript)\nDESCRIPTION: This example illustrates a simple GlobalConfig for a navigation menu in Payload CMS, written in TypeScript. It defines a Global with the slug 'nav' containing an array of required navigation items, each with a relationship to an existing 'pages' collection. Dependencies include importing 'GlobalConfig' from 'payload'. The 'fields' array determines the data structure, with key parameters such as required fields and relationship type. Inputs are document data matching the specified fields; outputs are the singleton document for this Global, managed by Payload. The configuration must be imported into the main Payload config to take effect.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/globals.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { GlobalConfig } from 'payload'\n\nexport const Nav: GlobalConfig = {\n  slug: 'nav',\n  fields: [\n    {\n      name: 'items',\n      type: 'array',\n      required: true,\n      maxRows: 8,\n      fields: [\n        {\n          name: 'page',\n          type: 'relationship',\n          relationTo: 'pages', // \"pages\" is the slug of an existing collection\n          required: true,\n        },\n      ],\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MongoDB Adapter in Payload Config (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to configure the Payload CMS database connection using the official MongoDB adapter (`@payloadcms/db-mongodb`). It imports `buildConfig` from `payload` and `mongooseAdapter` from the adapter package. The `db` property within the `buildConfig` options is assigned the result of calling `mongooseAdapter`, passing the database connection string (retrieved from environment variables) to the `url` property.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/overview.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\nimport { mongooseAdapter } from '@payloadcms/db-mongodb'\n\nexport default buildConfig({\n  // ...\n  // highlight-start\n  db: mongooseAdapter({\n    url: process.env.DATABASE_URI,\n  }),\n  // highlight-end\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Delete Access Control Inline in Payload CMS (TypeScript)\nDESCRIPTION: Defines a simple `delete` access control function directly within a Payload CMS Collection configuration. This function checks if a user is logged in (`Boolean(user)`) to determine if they can delete documents in this collection. It receives the `req` object containing the `user` property.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionWithDeleteAccess: CollectionConfig = {\n  // ...\n  access: {\n    // highlight-start\n    delete: ({ req: { user } }) => {\n      return Boolean(user)\n    },\n    // highlight-end\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload with Vercel Postgres Adapter (Explicit Connection String) in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to configure Payload CMS using the `buildConfig` function to connect to Vercel Postgres. It explicitly specifies the database connection string obtained from the `DATABASE_URI` environment variable using the `vercelPostgresAdapter`. This setup requires importing `buildConfig` from 'payload' and `vercelPostgresAdapter` from '@payloadcms/db-vercel-postgres'.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/db-vercel-postgres/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { vercelPostgresAdapter } from '@payloadcms/db-vercel-postgres'\n\nexport default buildConfig({\n  db: vercelPostgresAdapter({\n    pool: {\n      connectionString: process.env.DATABASE_URI,\n    },\n  }),\n  // ...rest of config\n})\n```\n\n----------------------------------------\n\nTITLE: Deleting a Document by ID via Payload REST API\nDESCRIPTION: Performs a DELETE request to delete a single document within a specific collection using its unique ID. Requires necessary authentication headers.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_7\n\nLANGUAGE: HTTP\nCODE:\n```\nDELETE /api/{collection-slug}/{id}\n```\n\n----------------------------------------\n\nTITLE: Creating a Post with File Upload on the Server with Payload Local API (TypeScript)\nDESCRIPTION: This server function creates a new document in the 'posts' collection, handling both plain data and a file upload (media). Inputs are a data object and a file (upload), which are combined and sent to 'payload.create'. Dependencies include Payload, its configuration, and 'getPayload'. Errors are returned with descriptive messages. The function is designated server-only with 'use server'.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n\"'use server'\\n\\nimport { getPayload } from 'payload'\\nimport config from '@payload-config'\\n\\nexport async function createPostWithUpload(data, upload) {\\n  const payload = await getPayload({ config })\\n\\n  try {\\n    // Prepare the data with the file\\n    const postData = {\\n      ...data,\\n      media: upload,\\n    }\\n\\n    const post = await payload.create({\\n      collection: 'posts',\\n      data: postData,\\n    })\\n\\n    return post\\n  } catch (error) {\\n    throw new Error(`Error creating post: ${error.message}`)\\n  }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Defining an afterChange Collection Hook (TypeScript)\nDESCRIPTION: Illustrates the implementation of an `afterChange` hook function in Payload CMS. This hook runs after a document is successfully created or updated, receiving the final `doc`, the `previousDoc`, `operation`, and `req`. It's suitable for side effects like triggering notifications or recalculating related data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionAfterChangeHook } from 'payload'\n\nconst afterChangeHook: CollectionAfterChangeHook = async ({ doc }) => {\n  return doc\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Delete Access Control in Payload CMS (TypeScript)\nDESCRIPTION: Defines a more complex, asynchronous `delete` access control function (`canDeleteCustomer`) intended for use in a separate file. It checks if a customer document (identified by `id`) can be deleted by querying a related 'contracts' collection using `req.payload.find`. Deletion is permitted only if no associated contracts exist or if the `id` is not provided (to allow UI controls when the specific document isn't yet known). It receives `req` (containing the payload API and user) and the document `id` as arguments.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Access } from 'payload'\n\nexport const canDeleteCustomer: Access = async ({ req, id }) => {\n  if (!id) {\n    // allow the admin UI to show controls to delete since it is indeterminate without the `id`\n    return true\n  }\n\n  // Query another Collection using the `id`\n  const result = await req.payload.find({\n    collection: 'contracts',\n    limit: 0,\n    depth: 0,\n    where: {\n      customer: { equals: id },\n    },\n  })\n\n  return result.totalDocs === 0\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Text Field in Payload CMS - TypeScript\nDESCRIPTION: This snippet demonstrates how to declare a simple text field in Payload CMS using a TypeScript field configuration. It requires importing the Field type from Payload, and setting the type parameter to 'text'. Key parameters include the required 'type', and typically 'name'. The output is a field configuration object to be included in a Payload collection or global schema. No additional dependencies are required beyond Payload and TypeScript.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/text.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyTextField: Field = {\n  // ...\n  type: 'text', // highlight-line\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Payload Search Plugin in Payload Config with JavaScript\nDESCRIPTION: Shows how to register the searchPlugin in the Payload CMS configuration in a JavaScript environment. Requires the Payload and @payloadcms/plugin-search libraries as dependencies. The config enables search indexing for 'pages' and 'posts' collections, and demonstrates specifying custom default priorities. The input is a JavaScript config object; the output is the augmented Payload config enabling plugin-powered search.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/search.mdx#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { searchPlugin } from '@payloadcms/plugin-search'\n\nconst config = buildConfig({\n  collections: [\n    {\n      slug: 'pages',\n      fields: [],\n    },\n    {\n      slug: 'posts',\n      fields: [],\n    },\n  ],\n  plugins: [\n    searchPlugin({\n      collections: ['pages', 'posts'],\n      defaultPriorities: {\n        pages: 10,\n        posts: 20,\n      },\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Accessing Specific Form Field State with `useFormFields` in Payload CMS (TSX)\nDESCRIPTION: This snippet demonstrates using the `useFormFields` hook from `@payloadcms/ui` to access the state of individual fields ('amount' and 'feePercentage') within a React component. It uses a selector function `([fields, dispatch]) => fields.fieldName` to retrieve specific field data, ensuring the component only re-renders when those specific fields change, leveraging `use-context-selector`. The component must be a client component.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport { useFormFields } from '@payloadcms/ui'\n\nconst MyComponent: React.FC = () => {\n  // Get only the `amount` field state, and only cause a rerender when that field changes\n  const amount = useFormFields(([fields, dispatch]) => fields.amount)\n\n  // Do the same thing as above, but to the `feePercentage` field\n  const feePercentage = useFormFields(\n    ([fields, dispatch]) => fields.feePercentage,\n  )\n\n  if (\n    typeof amount?.value !== 'undefined' &&\n    typeof feePercentage?.value !== 'undefined'\n  ) {\n    return <span>The fee is ${(amount.value * feePercentage.value) / 100}</span>\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SMTP Email via Nodemailer Adapter in Payload CMS (TypeScript)\nDESCRIPTION: This snippet demonstrates configuring Payload CMS with the Nodemailer adapter to send emails via SMTP. It imports and invokes the nodemailerAdapter with required sender information and SMTP transportOptions sourced from environment variables. Prerequisites include installing @payloadcms/email-nodemailer and having SMTP credentials available as environment variables (SMTP_HOST, SMTP_USER, SMTP_PASS). Inputs include email sender/SMTP parameters; the output is a Payload config setup for SMTP email. Only available with the appropriate packages installed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/email/overview.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { nodemailerAdapter } from '@payloadcms/email-nodemailer'\n\nexport default buildConfig({\n  email: nodemailerAdapter({\n    defaultFromAddress: 'info@payloadcms.com',\n    defaultFromName: 'Payload',\n    // Nodemailer transportOptions\n    transportOptions: {\n      host: process.env.SMTP_HOST,\n      port: 587,\n      auth: {\n        user: process.env.SMTP_USER,\n        pass: process.env.SMTP_PASS,\n      },\n    },\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload CMS MongoDB Adapter in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the basic configuration required to use the MongoDB adapter (`mongooseAdapter`) within a Payload CMS project. It imports the adapter from `@payloadcms/db-mongodb` and passes it to the `db` property of the `buildConfig` function, specifying the mandatory MongoDB connection `url` (typically sourced from environment variables like `process.env.DATABASE_URI`). The `collections` array is shown as a placeholder for where collection definitions would reside.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/mongodb.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { mongooseAdapter } from '@payloadcms/db-mongodb'\n\nexport default buildConfig({\n  // Your config goes here\n  collections: [\n    // Collections go here\n  ],\n  // Configure the Mongoose adapter here\n  db: mongooseAdapter({\n    // Mongoose-specific arguments go here.\n    // URL is required.\n    url: process.env.DATABASE_URI,\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Top-level Form State with useDocumentForm - PayloadCMS - TypeScript/TSX\nDESCRIPTION: This snippet uses the useDocumentForm hook from @payloadcms/ui to access the parent document's Form context in custom React components. The example logs the number of fields in the parent form using the fields property. This technique is vital in nested (e.g., lexical block) components where direct context access is otherwise shadowed. Requires @payloadcms/ui in a React (Next.js) client-side component and assumes the existence of a parent Form context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport { useDocumentForm } from '@payloadcms/ui'\n\nconst MyComponent: React.FC = () => {\n  const { fields: parentDocumentFields } = useDocumentForm()\n\n  return (\n    <p>\n      The document's Form has ${Object.keys(parentDocumentFields).length} fields\n    </p>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Access Property in Global Config - Payload CMS - TypeScript\nDESCRIPTION: Shows how to add an `access` property to a Global Config in Payload CMS to control which users can read or update Global documents. Requires Payload CMS installed with proper authentication setup. The snippet illustrates where to place the `access` object, allowing specification of granular control per operation. Usage expects authenticated requests and configuration as part of your Payload project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/globals.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalConfig } from 'payload'\n\nexport const GlobalWithAccessControl: GlobalConfig = {\n  // ...\n  access: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Collection Views in Payload CMS via TypeScript Config\nDESCRIPTION: This code shows how to customize Collection Views (such as document edit and list) by supplying custom React components in the admin.components.views config property for a collection. It imports the CollectionConfig type and demonstrates replacing the default edit view with a custom component path. The main dependency is 'payload', and the config must be attached to the relevant collection in the Payload setup. Nested keys like 'edit.default' allow targeting specific view variants.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-views.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollectionConfig: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      views: {\n        // highlight-start\n        edit: {\n          default: {\n            Component: '/path/to/MyCustomCollectionView',\n          },\n        },\n        // highlight-end\n        // Other options include:\n        // - list\n        // - [key: string]\n        // See below for more details\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Multiple Documents - Payload CMS JavaScript\nDESCRIPTION: This example deletes multiple documents matching a 'where' query and returns an object with two arrays: deleted documents and errors. It illustrates configuration options similar to single deletes, including document locking, localization, and access overrides. The method is useful for batch data management and error tracking.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Result will be an object with:\n// {\n//   docs: [], // each document that is now deleted\n//   errors: [], // any errors that occurred, including the id of the errored on document\n// }\nconst result = await payload.delete({\n  collection: 'posts', // required\n  where: {\n    // required\n    fieldName: { equals: 'value' },\n  },\n  depth: 0,\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUser,\n  overrideAccess: false,\n  overrideLock: false, // By default, document locks are ignored. Set to false to enforce locks.\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Importing and Configuring a Payload Plugin in JavaScript\nDESCRIPTION: Demonstrates adding a plugin to the Payload CMS configuration file in JavaScript. The code imports a plugin, integrates it in the plugins array, and provides initial options. Dependencies: Node.js, Payload CMS, and the plugin package. Inputs include the config, with expected modification of Payload CMS features as per the plugin configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport samplePlugin from 'sample-plugin';\n\nconst config = buildConfig({\n  plugins: [\n    // Add plugins here\n    samplePlugin({\n\t\tenabled: true,\n    }),\n  ],\n});\n\nexport default config;\n```\n\n----------------------------------------\n\nTITLE: Overriding Document Root View - Payload CMS TypeScript\nDESCRIPTION: This TypeScript configuration example demonstrates how to completely override the root Document View for a collection in Payload CMS. By setting the views.edit.root property with a custom component, you take control of the entire document layout, disabling all default document controls, tabs, and nested views (such as edit and API views). The CollectionConfig requires a custom React component at the specified path, and the resulting configuration replaces the entire rendered UI for that document type.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/document-views.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  slug: 'my-collection',\n  admin: {\n    components: {\n      views: {\n        edit: {\n          // highlight-start\n          root: {\n            Component: '/path/to/MyCustomRootComponent', // highlight-line\n          },\n          // highlight-end\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Description Component in Payload Field (TypeScript)\nDESCRIPTION: Example of adding a custom `Description` component to a 'text' field within a Payload `CollectionConfig`. The `admin.components.Description` property points to the path of the custom React component, allowing for more complex or dynamic field descriptions than the standard text property.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_26\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollectionConfig: CollectionConfig = {\n  // ...\n  fields: [\n    // ...\n    {\n      name: 'myField',\n      type: 'text',\n      admin: {\n        components: {\n          Description: '/path/to/MyCustomDescriptionComponent', // highlight-line\n        },\n      },\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a JSON Field in Payload Config (TypeScript)\nDESCRIPTION: This snippet demonstrates how to define a JSON field by setting the 'type' property to 'json' within a Payload Field configuration object in TypeScript. It imports the necessary 'Field' type from Payload and shows the minimal configuration required to add a JSON field. The key parameter is 'type', which must be set to 'json' to enable the field. No additional dependencies are required except for the Payload library. The output is a Field object ready to be included in a Payload configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/json.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyJSONField: Field = {\n  // ...\n  type: 'json', // highlight-line\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Label Generation for Breadcrumbs - TypeScript\nDESCRIPTION: Shows the use of a generateLabel function in the nestedDocsPlugin configuration which sets each breadcrumb label dynamically based on the 'title' field of the document. Intended for use in payload.config.ts and expects that the documents being processed have a 'title' field. The generateLabel function receives the current document as its argument and should return a string label.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/nested-docs.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nnestedDocsPlugin({\n  //...\n  generateLabel: (_, doc) => doc.title, // NOTE: 'title' is a hypothetical field\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Component Props in Payload (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure a custom component for the admin UI within the Payload config (`buildConfig`). It specifically shows replacing the default logout button component and passing a serializable custom prop (`myCustomProp`) using the `clientProps` option.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    // highlight-line\n    components: {\n      logout: {\n        Button: {\n          path: '/src/components/Logout#MyComponent',\n          clientProps: {\n            myCustomProp: 'Hello, World!', // highlight-line\n          },\n        },\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting defaultPopulate Property in Collection Config - Payload CMS TypeScript\nDESCRIPTION: Describes configuring the defaultPopulate property in a collection schema to control which fields are populated by default in relationships or uploads. Focuses on selecting only the slug field in a Pages collection for optimization. Requires type {CollectionConfig} from payload. Only the specified fields are always returned when populated, reducing unnecessary data transfer.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/select.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\n// The TSlug generic can be passed to have type safety for `defaultPopulate`.\n// If avoided, the `defaultPopulate` type resolves to `SelectType`.\nexport const Pages: CollectionConfig<'pages'> = {\n  slug: 'pages',\n  // Specify `select`.\n  defaultPopulate: {\n    slug: true,\n  },\n  fields: [\n    {\n      name: 'slug',\n      type: 'text',\n      required: true,\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Redirect Relationships in Form Builder Plugin (TypeScript)\nDESCRIPTION: Configures the redirectRelationships array to provide valid page destinations for the form's redirect field after submission. In this example, 'pages' is given as a target collection. This alters plugin admin UI and redirect logic. Required dependencies are correctly structured collections.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nformBuilderPlugin({\n  // ...\n  redirectRelationships: ['pages'],\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Textarea Field - Payload CMS TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to define a Textarea Field within a Payload CMS Field configuration. The object sets the property 'type' to 'textarea' to indicate the field type, allowing for extended text input. May include additional field configuration options as needed. Requires the 'payload' package and is used in any Field array in collections or globals. Expects a string value as input and stores it in the document's database record.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/textarea.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Field } from 'payload'\\n\\nexport const MyTextareaField: Field = {\\n  // ...\\n  type: 'textarea', // highlight-line\\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing afterRead Hook in PayloadCMS - TypeScript\nDESCRIPTION: Defines a TypeScript async function afterReadHook using PayloadCMS's GlobalAfterReadHook type. The hook parameters include doc, req, and findMany, granting access to the resulting document, the request object, and a boolean flag for single/multiple fetch scenarios. This pattern ensures type-safety and extensibility for customizing workflows prior to returning global data objects. The code requires Payload and appropriate Payload types installed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/globals.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalAfterReadHook } from 'payload'\n\nconst afterReadHook: GlobalAfterReadHook = async ({\n  doc,\n  req,\n  findMany,\n}) => {...}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom JSON Field Server Component in TSX\nDESCRIPTION: Defines a React server component (`CustomJSONFieldServer`) to customize the server-side rendering of a JSON field in the Payload CMS admin interface. It utilizes the default `JSONField` component from `@payloadcms/ui`, passing along necessary props like `clientField`, `path`, `schemaPath`, and `permissions`. This allows overriding the default field rendering while leveraging existing functionality.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/json.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport type React from 'react'\nimport { JSONField } from '@payloadcms/ui'\nimport type { JSONFieldServerComponent } from 'payload'\n\nexport const CustomJSONFieldServer: JSONFieldServerComponent = ({\n  clientField,\n  path,\n  schemaPath,\n  permissions,\n}) => {\n  return (\n    <JSONField\n      field={clientField}\n      path={path}\n      schemaPath={schemaPath}\n      permissions={permissions}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Verification Email HTML Template in Payload CMS (TypeScript)\nDESCRIPTION: This snippet shows how to provide a custom `generateEmailHTML` function that creates a personalized email verification message for users. The function receives an object with `req`, `token`, and `user`, and returns a string containing HTML content. Dependencies include Payload CMS, and implementers may need to route users to their front end for token processing. The function allows customizing the verification flow and must ensure the verification endpoint on the frontend calls the Payload API as required.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/email.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Customers: CollectionConfig = {\n  // ...\n  auth: {\n    verify: {\n      // highlight-start\n      generateEmailHTML: ({ req, token, user }) => {\n        // Use the token provided to allow your user to verify their account\n        const url = `https://yourfrontend.com/verify?token=${token}`\n\n        return `Hey ${user.email}, verify your email by clicking here: ${url}`\n      },\n      // highlight-end\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing i18n Configuration in Payload CMS Config\nDESCRIPTION: Shows the basic structure for integrating internationalization settings into the main Payload CMS configuration file (`payload.config.ts`). The `i18n` key is added to the object passed to the `buildConfig` function.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/i18n.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  i18n: {\n    // highlight-line\n    // ...\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Toolbar Dropdown Group in Payload RichText Lexical (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates a helper function, toolbarAddDropdownGroupWithItems, to create a toolbar group configured as a dropdown for the Payload RichText Lexical editor. It takes an array of ToolbarGroupItem objects and returns a ToolbarGroup object with the type 'dropdown', a custom ChildComponent for rendering icons or labels, a unique key, and an order parameter. Dependencies include type imports from '@payloadcms/richtext-lexical' and a React component import for the ChildComponent. Intended for use cases where toolbar items should be displayed vertically in a dropdown with customized visual content.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_17\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type {\n  ToolbarGroup,\n  ToolbarGroupItem,\n} from '@payloadcms/richtext-lexical'\n\nimport { MyIcon } from './icons/MyIcon'\n\nexport const toolbarAddDropdownGroupWithItems = (\n  items: ToolbarGroupItem[],\n): ToolbarGroup => {\n  return {\n    type: 'dropdown',\n    ChildComponent: MyIcon,\n    items,\n    key: 'myDropdownToolbar',\n    order: 10,\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Metadata in Payload (TypeScript)\nDESCRIPTION: Shows how to define site-wide global metadata for Payload admin panel pages using the GlobalConfig type in TypeScript. Customizes title and description at the global level through the 'admin.meta' object, affecting all related views unless further overridden. Requires importing GlobalConfig and structuring the export accordingly.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/metadata.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { GlobalConfig } from 'payload'\n\nexport const MyGlobal: GlobalConfig = {\n  // ...\n  admin: {\n    // highlight-start\n    meta: {\n      // highlight-end\n      title: 'My Global',\n      description: 'The best admin panel in the world',\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Admin Configuration to a Payload CMS Group Field using TypeScript\nDESCRIPTION: Illustrates where to add admin-specific configurations for a Group Field within the Payload CMS field definition. The `admin` property is used to nest options that customize the field's appearance and behavior specifically within the Admin Panel.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/group.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyGroupField: Field = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom JSON Field Label Server Component in TSX\nDESCRIPTION: Defines a React server component (`CustomJSONFieldLabelServer`) to customize the rendering of a JSON field's label on the server side in Payload CMS. It uses the `@payloadcms/ui` `FieldLabel` component, determining the label text from `clientField?.label` or `clientField?.name` and indicating if the field is required based on `clientField?.required`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/json.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { JSONFieldLabelServerComponent } from 'payload'\n\nexport const CustomJSONFieldLabelServer: JSONFieldLabelServerComponent = ({\n  clientField,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={clientField?.label || clientField?.name}\n      path={path}\n      required={clientField?.required}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a Media Collection with Uploads in Payload CMS using TypeScript\nDESCRIPTION: This TypeScript code defines a Payload CMS Collection configuration named 'Media'. It enables the upload functionality by setting the `upload` property, specifying the static directory ('media'), defining multiple image sizes ('thumbnail', 'card', 'tablet') for automatic resizing, setting the admin panel thumbnail size, and restricting allowed mime types to images ('image/*'). An additional 'alt' text field is also defined for the collection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/overview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Media: CollectionConfig = {\n  slug: 'media',\n  upload: {\n    staticDir: 'media',\n    imageSizes: [\n      {\n        name: 'thumbnail',\n        width: 400,\n        height: 300,\n        position: 'centre',\n      },\n      {\n        name: 'card',\n        width: 768,\n        height: 1024,\n        position: 'centre',\n      },\n      {\n        name: 'tablet',\n        width: 1024,\n        // By specifying `undefined` or leaving a height undefined,\n        // the image will be sized to a certain width,\n        // but it will retain its original aspect ratio\n        // and calculate a height automatically.\n        height: undefined,\n        position: 'centre',\n      },\n    ],\n    adminThumbnail: 'thumbnail',\n    mimeTypes: ['image/*'],\n  },\n  fields: [\n    {\n      name: 'alt',\n      type: 'text',\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a beforeChange Collection Hook (TypeScript)\nDESCRIPTION: Presents an example of a `beforeChange` hook function in Payload CMS. Executed after validation but before saving during `create` and `update`, this hook allows final modifications to the validated `data`. It receives `data`, `operation`, `originalDoc`, and `req` as arguments.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionBeforeChangeHook } from 'payload'\n\nconst beforeChangeHook: CollectionBeforeChangeHook = async ({ data }) => {\n  return data\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLite Adapter in PayloadCMS (TypeScript)\nDESCRIPTION: Demonstrates how to configure PayloadCMS to use the SQLite adapter, leveraging Drizzle ORM for database interaction. The `sqliteAdapter` function is imported and invoked in the `db` property of the Payload config, requiring at minimum a `client.url` (typically set via environment variable). Optional configuration fields like `authToken` can also be passed for database authentication. Expects the environment variables `DATABASE_URL` and optionally `DATABASE_AUTH_TOKEN`. Outputs a fully-typed Payload config file ready for SQLite-backed Content Management.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/sqlite.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { sqliteAdapter } from '@payloadcms/db-sqlite'\n\nexport default buildConfig({\n  // Your config goes here\n  collections: [\n    // Collections go here\n  ],\n  // Configure the SQLite adapter here\n  db: sqliteAdapter({\n    // SQLite-specific arguments go here.\n    // `client.url` is required.\n    client: {\n      url: process.env.DATABASE_URL,\n      authToken: process.env.DATABASE_AUTH_TOKEN,\n    },\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a beforeValidate Hook for Payload CMS Global - TypeScript\nDESCRIPTION: This TypeScript code defines a 'beforeValidate' hook for a Payload CMS global document. The hook receives arguments including data, req (web request), and the original document. Its purpose is to mutate or format the input data before server-side validation occurs, returning the modified data for continued processing. It requires 'payload' TypeScript types for proper type-checking. Expected input includes the current editing context and document; output must be the transformed data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/globals.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalBeforeValidateHook } from 'payload'\n\nconst beforeValidateHook: GlobalBeforeValidateHook = async ({\n  data,\n  req,\n  originalDoc,\n}) => {\n  return data\n}\n```\n\n----------------------------------------\n\nTITLE: Reusable Read Access Control Function - Payload CMS - TypeScript\nDESCRIPTION: Provides a reusable access control function, 'canReadPage', usable in multiple CollectionConfigs. Authenticated users are granted access; unauthenticated guests may read documents only if the document's 'isPublic' flag is set. Requires a boolean 'isPublic' field and the 'Access' type from Payload CMS. Returns either a boolean or a query constraint object for granular filtering.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Access } from 'payload'\n\nexport const canReadPage: Access = ({ req: { user } }) => {\n  // Allow authenticated users\n  if (user) {\n    return true\n  }\n\n  // By returning a Query, guest users can read public Documents\n  // Note: this assumes you have a `isPublic` checkbox field on your Collection\n  return {\n    isPublic: {\n      equals: true,\n    },\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Number Field in Payload CMS using TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates the fundamental step of defining a Number field in Payload CMS by setting the `type` property to `'number'` within a Field configuration object. It requires the `Field` type from the `payload` package.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/number.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyNumberField: Field = {\n  // ...\n  type: 'number', // highlight-line\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Cloud Storage in Payload CMS with TypeScript\nDESCRIPTION: Configures Payload CMS to use Google Cloud Storage for media file uploads via the \"@payloadcms/storage-gcs\" plugin. Requires environment variables for the storage bucket, API endpoint, and project ID, all provided in the \"options\" property. The configuration specifies which collections are handled by the adapter and can be altered to support client direct uploads for Vercel. Outputs a ready-to-use Payload configuration for Google Cloud Storage integration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { gcsStorage } from '@payloadcms/storage-gcs'\nimport { Media } from './collections/Media'\nimport { MediaWithPrefix } from './collections/MediaWithPrefix'\n\nexport default buildConfig({\n  collections: [Media, MediaWithPrefix],\n  plugins: [\n    gcsStorage({\n      collections: {\n        media: true,\n        'media-with-prefix': {\n          prefix,\n        },\n      },\n      bucket: process.env.GCS_BUCKET,\n      options: {\n        apiEndpoint: process.env.GCS_ENDPOINT,\n        projectId: process.env.GCS_PROJECT_ID,\n      },\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Invoking Create Post with File Upload Server Function from React Client Component (TypeScript)\nDESCRIPTION: This React client component provides a form to let users create a post with both a title and file upload by calling the 'createPostWithUpload' server function on form submission. It handles form state, file input validation, and displays success or error feedback. Prerequisites include importing the server action and that the file upload field ('media') is supported in the 'posts' collection. Data is passed as a combination of the text input value and the selected file object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n\"'use client';\\n\\nimport React, { useState } from 'react';\\nimport { createPostWithUpload } from '../server/actions';\\n\\nexport const PostForm: React.FC = () => {\\n  const [title, setTitle] = useState<string>('');\\n  const [file, setFile] = useState<File | null>(null);\\n  const [result, setResult] = useState<string>('');\\n\\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\\n    if (e.target.files) {\\n      setFile(e.target.files[0]);\\n    }\\n  };\\n\\n  const handleSubmit = async (e: React.FormEvent) => {\\n    e.preventDefault();\\n    if (!file) {\\n      setResult('Please upload a file.');\\n      return;\\n    }\\n\\n    try {\\n      // Call the server function to create the post with the file\\n      const newPost = await createPostWithUpload({ title }, file);\\n      setResult('Post created with file: ' + newPost.title);\\n    } catch (error) {\\n      setResult('Error: ' + error.message);\\n    }\\n  };\\n\\n  return (\\n    <form onSubmit={handleSubmit}>\\n      <input\\n        type=\\\"text\\\"\\n        value={title}\\n        onChange={(e) => setTitle(e.target.value)}\\n        placeholder=\\\"Post Title\\\"\\n      />\\n      <input type=\\\"file\\\" onChange={handleFileChange} />\\n      <button type=\\\"submit\\\">Create Post</button>\\n      <p>{result}</p>\\n    </form>\\n  );\\n};\"\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Slash Menu Items with Payload CMS in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a custom rich text slash menu group with items by using Payload CMS's createClientFeature API. It depends on the @payloadcms/richtext-lexical/client package and imports required commands, icon components, and menu utilities. Each menu item requires an Icon, key, keywords, a label (with i18n support), and an onSelect handler for integrating custom editor commands. Input parameters include icon components, keys, keywords, and selection handlers, and the output is a bundled Payload CMS client feature ready for registration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_20\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"'use client'\\n\\nimport {\\n  createClientFeature,\\n  slashMenuBasicGroupWithItems,\\n} from '@payloadcms/richtext-lexical/client'\\nimport { INSERT_MYNODE_COMMAND } from './plugin'\\nimport { IconComponent } from './icon'\\n\\nexport const MyClientFeature = createClientFeature({\\n  slashMenu: {\\n    groups: [\\n      slashMenuBasicGroupWithItems([\\n        {\\n          Icon: IconComponent,\\n          key: 'myNode',\\n          keywords: ['myNode', 'myFeature', 'someOtherKeyword'],\\n          label: ({ i18n }) => {\\n            return i18n.t('lexical:myFeature:label')\\n          },\\n          onSelect: ({ editor }) => {\\n            editor.dispatchCommand(INSERT_MYNODE_COMMAND, undefined)\\n          },\\n        },\\n      ]),\\n    ],\\n  },\\n})\\n\"\n```\n\n----------------------------------------\n\nTITLE: Configuring a Row Field within a Payload Collection in TypeScript\nDESCRIPTION: This example illustrates how to embed a Row Field into a Payload CMS collection configuration file using TypeScript. The 'type: row' field allows two nested text fields, 'label' and 'value', to display side by side in the Admin Panel. Dependencies include TypeScript and Payload CMS (with types). Key parameters are the 'fields' array for field nesting and 'admin.width' to control visual width. The snippet expects a CollectionConfig object as input and yields a complete configuration usable by Payload CMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/row.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      type: 'row', // required\n      fields: [\n        // required\n        {\n          name: 'label',\n          type: 'text',\n          required: true,\n          admin: {\n            width: '50%',\n          },\n        },\n        {\n          name: 'value',\n          type: 'text',\n          required: true,\n          admin: {\n            width: '50%',\n          },\n        },\n      ],\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Global Entity - Payload CMS JavaScript\nDESCRIPTION: This code updates a global entity in Payload CMS given its slug and new data (e.g., navigation links). The snippet supports additional options like localization, user assignment, access control, lock ignoring, and hidden field visibility. Key parameters are slug and data, with optional document locking.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_18\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Result will be the updated Header Global.\nconst result = await payload.updateGlobal({\n  slug: 'header', // required\n  data: {\n    // required\n    nav: [\n      {\n        url: 'https://google.com',\n      },\n      {\n        url: 'https://payloadcms.com',\n      },\n    ],\n  },\n  depth: 2,\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUser,\n  overrideAccess: false,\n  overrideLock: false, // By default, document locks are ignored. Set to false to enforce locks.\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Component Path for Logout Button in Payload Config (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to specify a custom React component for the Admin Panel's logout button within the `buildConfig` function. It uses a component path string relative to the project root, including a named export (`#MyComponent`), within the `admin.components` configuration object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    components: {\n      logout: {\n        Button: '/src/components/Logout#MyComponent', // highlight-line\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Granting Read Access to Published and Legacy Documents in Payload CMS - TypeScript\nDESCRIPTION: Shows how to configure Payload CMS access control to allow unauthenticated users to read both documents where _status equals 'published' and documents without a _status field (such as legacy documents before enabling drafts). Implements a complex logical condition using 'or' in the query constraint. Dependency: Payload CMS. Handles the req object and supports both new and legacy document visibility. Intended for integration in a Payload collection configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/versions/drafts.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Pages: CollectionConfig = {\n  slug: 'pages',\n  access: {\n    read: ({ req }) => {\n      // If there is a user logged in,\n      // let them retrieve all documents\n      if (req.user) return true\n\n      // If there is no user,\n      // restrict the documents that are returned\n      // to only those where `_status` is equal to `published`\n      // or where `_status` does not exist\n      return {\n        or: [\n          {\n            _status: {\n              equals: 'published',\n            },\n          },\n          {\n            _status: {\n              exists: false,\n            },\n          },\n        ],\n      }\n    },\n  },\n  versions: {\n    drafts: true,\n  },\n  //.. the rest of the Pages config here\n}\n```\n\n----------------------------------------\n\nTITLE: Outputting Markdown from a Payload Collection using Hook-Based Conversion - TypeScript\nDESCRIPTION: This example shows how to integrate Lexical to Markdown conversion directly within a Payload Collection using field-level hooks. The 'nameOfYourRichTextField' is configured as a Lexical richtext field and a hidden 'markdown' textarea field. The 'afterRead' hook converts the Lexical state of the richtext field to Markdown and sets it on the 'markdown' field; 'beforeChange' ensures the Markdown does not persist in the database. Requires dependencies: @payloadcms/richtext-lexical, Payload CollectionConfig, and RichTextField types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-markdown.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\nimport type { CollectionConfig, RichTextField } from 'payload'\n\nimport {\n  convertLexicalToMarkdown,\n  editorConfigFactory,\n  lexicalEditor,\n} from '@payloadcms/richtext-lexical'\n\nconst Pages: CollectionConfig = {\n  slug: 'pages',\n  fields: [\n    {\n      name: 'nameOfYourRichTextField',\n      type: 'richText',\n      editor: lexicalEditor(),\n    },\n    {\n      name: 'markdown',\n      type: 'textarea',\n      admin: {\n        hidden: true,\n      },\n      hooks: {\n        afterRead: [\n          ({ siblingData, siblingFields }) => {\n            const data: SerializedEditorState =\n              siblingData['nameOfYourRichTextField']\n\n            if (!data) {\n              return ''\n            }\n\n            const markdown = convertLexicalToMarkdown({\n              data,\n              editorConfig: editorConfigFactory.fromField({\n                field: siblingFields.find(\n                  (field) =>\n                    'name' in field && field.name === 'nameOfYourRichTextField',\n                ) as RichTextField,\n              }),\n            })\n\n            return markdown\n          },\n        ],\n        beforeChange: [\n          ({ siblingData }) => {\n            // Ensure that the markdown field is not saved in the database\n            delete siblingData['markdown']\n            return null\n          },\n        ],\n      },\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Field Component with `useField` Hook (TSX)\nDESCRIPTION: This React component demonstrates how to create a custom field input for the Payload admin UI. It utilizes the `useField` hook from `@payloadcms/ui` to get the current field value and the `setValue` function to update the form state when the input changes. This component is intended to run on the client.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport { useField } from '@payloadcms/ui'\n\nexport const CustomTextField: React.FC = () => {\n  const { value, setValue } = useField() // highlight-line\n\n  return <input onChange={(e) => setValue(e.target.value)} value={value} />\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a PayloadCMS Server Feature with a Custom Node in TypeScript\nDESCRIPTION: Demonstrates defining a server feature using `createServerFeature` and registering a custom node (`MyNode`) with the `createNode` helper. It includes configuration for an HTML converter, specifying how the node should be rendered to HTML on the server. This pattern is used for managing server-side aspects like conversions, hooks, and headless editor behavior.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { createServerFeature, createNode } from '@payloadcms/richtext-lexical'\nimport { MyNode } from './nodes/MyNode'\n\nexport const MyFeature = createServerFeature({\n  feature: {\n    nodes: [\n      // Use the createNode helper function to more easily create nodes with proper typing\n      createNode({\n        converters: {\n          html: {\n            converter: () => {\n              return `<hr/>`\n            },\n            nodeTypes: [MyNode.getType()],\n          },\n        },\n        // Here you can add your actual node. On the server, they will be\n        // used to initialize a headless editor which can be used to perform\n        // operations on the editor, like markdown / html conversion.\n        node: MyNode,\n      }),\n    ],\n  },\n  key: 'myFeature',\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Stripe Webhook Handlers in Payload (TypeScript)\nDESCRIPTION: Illustrates how to configure webhook handlers within the Stripe plugin setup in PayloadCMS. It provides the `stripeWebhooksEndpointSecret` and defines a `webhooks` object where keys are Stripe event names (like `'customer.subscription.updated'`) and values are handler functions. These functions execute custom logic when the corresponding Stripe event occurs. An alternative approach using a single function to handle all events is also shown (commented out).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/stripe.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport stripePlugin from '@payloadcms/plugin-stripe'\n\nconst config = buildConfig({\n  plugins: [\n    stripePlugin({\n      stripeSecretKey: process.env.STRIPE_SECRET_KEY,\n      stripeWebhooksEndpointSecret: process.env.STRIPE_WEBHOOKS_ENDPOINT_SECRET,\n      webhooks: {\n        'customer.subscription.updated': ({ event, stripe, stripeConfig }) => {\n          // do something...\n        },\n      },\n      // NOTE: you can also catch all Stripe webhook events and handle the event types yourself\n      // webhooks: (event, stripe, stripeConfig) => {\n      //   switch (event.type): {\n      //     case 'customer.subscription.updated': {\n      //       // do something...\n      //       break;\n      //     }\n      //     default: {\n      //       break;\n      //     }\n      //   }\n      // }\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Registering a Client Feature in a Server Feature (TypeScript)\nDESCRIPTION: Illustrates how to link a client feature to its corresponding server feature within Payload CMS. The `createServerFeature` function takes a configuration object where the `ClientFeature` property under `feature` specifies the import path and exported name of the client feature component (e.g., './path/to/feature.client#MyClientFeature'). This ensures the client-side code is loaded correctly by the editor.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServerFeature } from '@payloadcms/richtext-lexical'\n\nexport const MyFeature = createServerFeature({\n  feature: {\n    ClientFeature: './path/to/feature.client#MyClientFeature',\n  },\n  key: 'myFeature',\n  dependenciesPriority: ['otherFeature'],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring SendGrid as the Custom Nodemailer Transport in Payload CMS (TypeScript)\nDESCRIPTION: This snippet configures Payload CMS to send email via SendGrid using the nodemailer-sendgrid transport module. It passes the result of nodemailerSendgrid, parameterized by SENDGRID_API_KEY, to the transportOptions. Required dependencies include @payloadcms/email-nodemailer and nodemailer-sendgrid; SENDGRID_API_KEY must be set in the environment. Used for integrating SendGrid with Payload’s email system throughput.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/email/overview.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { nodemailerAdapter } from '@payloadcms/email-nodemailer'\nimport nodemailerSendgrid from 'nodemailer-sendgrid'\n\nexport default buildConfig({\n  email: nodemailerAdapter({\n    defaultFromAddress: 'info@payloadcms.com',\n    defaultFromName: 'Payload',\n    transportOptions: nodemailerSendgrid({\n      apiKey: process.env.SENDGRID_API_KEY,\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Managing Admin User Preferences via REST Endpoints in PayloadCMS (JavaScript/REST)\nDESCRIPTION: These JavaScript/REST snippets describe how to get, set, and delete admin user-specific preferences in PayloadCMS using REST API endpoints. Each operation is keyed by a unique preference identifier and generally expects authentication. The endpoints accept or return user and key details along with the preference value. Creating or updating a preference requires sending the new value in the request body, while deletion only needs authentication headers.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Preferences Operation: Get Preference\n{\n  operation: 'Get Preference',\n  method: 'GET',\n  path: '/api/payload-preferences/{key}',\n  description: 'Get a preference by key',\n  example: {\n    slug: 'getPreference',\n    req: {\n      headers: true,\n      credentials: true,\n    },\n    res: {\n      _id: '644bb7a8307b3d363c6edf2c',\n      key: 'region',\n      user: '644b8453cd20c7857da5a9b0',\n      userCollection: 'users',\n      __v: 0,\n      createdAt: '2023-04-28T12:10:16.689Z',\n      updatedAt: '2023-04-28T12:10:16.689Z',\n      value: 'Europe/London',\n    },\n  },\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Preferences Operation: Create or Update Preference\n{\n  operation: 'Create Preference',\n  method: 'POST',\n  path: '/api/payload-preferences/{key}',\n  description: 'Create or update a preference by key',\n  example: {\n    slug: 'createPreference',\n    req: {\n      headers: true,\n      credentials: true,\n      body: {\n        value: 'Europe/London',\n      },\n    },\n    res: {\n      message: 'Updated successfully.',\n      doc: {\n        user: '644b8453cd20c7857da5a9b0',\n        key: 'region',\n        userCollection: 'users',\n        value: 'Europe/London',\n      },\n    },\n  },\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Preferences Operation: Delete Preference\n{\n  operation: 'Delete Preference',\n  method: 'DELETE',\n  path: '/api/payload-preferences/{key}',\n  description: 'Delete a preference by key',\n  example: {\n    slug: 'deletePreference',\n    req: {\n      headers: true,\n    },\n    res: {\n      message: 'deletedSuccessfully',\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Querying Collection Depth in Payload CMS REST API (TypeScript)\nDESCRIPTION: This TypeScript snippet illustrates how to use the browser or Node.js 'fetch' API to query the Payload CMS REST endpoint for posts with a specified depth. The URL parameter 'depth=2' determines the level of population for related documents in the response. Requires a running Payload CMS API and access to the 'fetch' function. Inputs are the REST API endpoint and optional request options; outputs are post documents with related objects populated up to depth 2, which are logged to the console. Authentication requirements may apply based on API policy.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/depth.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfetch('https://localhost:3000/api/posts?depth=2') // highlight-line\\n  .then((res) => res.json())\\n  .then((data) => console.log(data))\\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Array Field Server Component in TSX\nDESCRIPTION: This snippet defines a custom React server component (`CustomArrayFieldServer`) for rendering a Payload CMS Array Field. It imports and wraps the standard `ArrayField` component from `@payloadcms/ui`. The component receives server-side props (`clientField`, `path`, `schemaPath`, `permissions`) specific to the Array Field's configuration and passes them to the underlying `ArrayField`. Requires React and dependencies from `@payloadcms/ui` and `payload`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/array.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport type React from 'react'\nimport { ArrayField } from '@payloadcms/ui'\nimport type { ArrayFieldServerComponent } from 'payload'\n\nexport const CustomArrayFieldServer: ArrayFieldServerComponent = ({\n  clientField,\n  path,\n  schemaPath,\n  permissions,\n}) => {\n  return (\n    <ArrayField\n      field={clientField}\n      path={path}\n      schemaPath={schemaPath}\n      permissions={permissions}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Update Access Control for Global - Payload CMS - TypeScript\nDESCRIPTION: Illustrates adding an `update` access control function on a Global Config, which evaluates whether an authenticated user can perform update operations. Requires Payload CMS and receives both the request and updated data as parameters. Returns a boolean to authorize the action, supporting custom logic based on the user or data provided.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/globals.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { GlobalConfig } from 'payload'\n\nconst Header: GlobalConfig = {\n  // ...\n  // highlight-start\n  access: {\n    update: ({ req: { user }, data }) => {\n      return Boolean(user)\n    },\n  },\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Checkbox Field Label Client Component (React/TSX)\nDESCRIPTION: This snippet demonstrates creating a custom React Client Component for a Checkbox field's label, marked with 'use client'. It imports and uses the 'FieldLabel' component from '@payloadcms/ui', receiving 'label', 'path', and 'required' as props. Note: The implementation uses 'field?.label' and 'field?.required' which seems inconsistent with the destructured props ('label', 'path', 'required') but reflects the provided source code.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/checkbox.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { CheckboxFieldLabelClientComponent } from 'payload'\n\nexport const CustomCheckboxFieldLabelClient: CheckboxFieldLabelClientComponent =\n  ({ label, path, required }) => {\n    return (\n      <FieldLabel\n        label={field?.label || field?.name} // Note: Uses 'field' which is not in scope from props\n        path={path}\n        required={field?.required} // Note: Uses 'field' which is not in scope from props\n      />\n    )\n  }\n```\n```\n\n----------------------------------------\n\nTITLE: Filtering Available Locales for Admin UI (TypeScript)\nDESCRIPTION: Provides a real-world example for customizing which locales are shown to users in the Payload admin UI using the `filterAvailableLocales` function of the localization config. This async function uses request headers and tenant information to return a filtered array of supported locales. Dependencies: Payload CMS, application logic for multi-tenancy, and a helper function `getTenantFromCookie`. Key parameters: the incoming request and current locales array. Outputs: restricted locale choices for end users in the UI. Limitation: Assumes the presence of multi-tenancy logic and tenant collections.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/localization.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// ... rest of Payload config\nlocalization: {\n  defaultLocale: 'en',\n  locales: ['en', 'es'],\n  filterAvailableLocales: async ({ req, locales }) => {\n    if (getTenantFromCookie(req.headers, 'text')) {\n      const fullTenant = await req.payload.findByID({\n        id: getTenantFromCookie(req.headers, 'text') as string,\n        collection: 'tenants',\n        req,\n      })\n      if (fullTenant && fullTenant.supportedLocales?.length) {\n        return locales.filter((locale) => {\n          return fullTenant.supportedLocales?.includes(locale.code as 'en' | 'es')\n        })\n      }\n    }\n    return locales\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Lexical Richtext to Markdown using Payload Lexical Editor - TypeScript\nDESCRIPTION: This snippet demonstrates how to convert a Lexical richtext editor state to a Markdown string using the Payload CMS richtext-lexical utility functions. It requires the Payload Config and the lexical editor config (obtained via editorConfigFactory) as dependencies. Pass the SerializedEditorState to convertLexicalToMarkdown, ensuring that config is present for editorConfigFactory; the output is a Markdown-formatted string.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-markdown.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\n\nimport {\n  convertLexicalToMarkdown,\n  editorConfigFactory,\n} from '@payloadcms/richtext-lexical'\n\n// Your richtext data here\nconst data: SerializedEditorState = {}\n\nconst markdown = convertLexicalToMarkdown({\n  data,\n  editorConfig: await editorConfigFactory.default({\n    config, // <= make sure you have access to your Payload Config\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Read Access Control for Global - Payload CMS - TypeScript\nDESCRIPTION: Explains how to implement the `read` property in a Global Config to restrict Global read operations based on the authenticated user. Relies on the Payload CMS framework and expects the `user` property to be present on the request object. Returns a boolean to allow or deny the operation, supporting custom logic as needed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/globals.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { GlobalConfig } from 'payload'\n\nconst Header: GlobalConfig = {\n  // ...\n  // highlight-start\n  read: {\n    read: ({ req: { user } }) => {\n      return Boolean(user)\n    },\n  },\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Example Payload Configuration with Collections - Payload CMS - TypeScript\nDESCRIPTION: This example shows a typical 'payload.config.ts' defining collections for 'users' and 'posts' in a Payload CMS project. The config specifies fields and relationships used for type generation. It demonstrates how type definitions are inferred from the schema for both collections and their fields, such as required and optional attributes. The generated types can then be used throughout the codebase for type safety.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/generating-types.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Config } from 'payload'\n\nconst config: Config = {\n  serverURL: process.env.NEXT_PUBLIC_SERVER_URL,\n  admin: {\n    user: 'users',\n  },\n  collections: [\n    {\n      slug: 'users',\n      fields: [\n        {\n          name: 'name',\n          type: 'text',\n          required: true,\n        },\n      ],\n    },\n    {\n      slug: 'posts',\n      admin: {\n        useAsTitle: 'title',\n      },\n      fields: [\n        {\n          name: 'title',\n          type: 'text',\n        },\n        {\n          name: 'author',\n          type: 'relationship',\n          relationTo: 'users',\n        },\n      ],\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting User Password via REST API in TypeScript\nDESCRIPTION: Sends a POST request to the specific collection's reset-password endpoint in the Payload CMS REST API. The request body must include the `token` received from the forgot password process and the desired `password`. Upon successful validation of the token and password update, it returns an object containing the updated user details and a new authentication token.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await fetch(`http://localhost:3000/api/[collection-slug]/reset-password`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    token: 'TOKEN_GOES_HERE'\n    password: 'not-today',\n  }),\n});\n\nconst json = await res.json();\n\n// JSON will be equal to the following:\n/*\n{\n  user: {\n    email: 'dev@payloadcms.com',\n    createdAt: \"2020-12-27T21:16:45.645Z\",\n    updatedAt: \"2021-01-02T18:37:41.588Z\",\n    id: \"5ae8f9bde69e394e717c8832\"\n  },\n  token: '34o4345324...',\n  exp: 1609619861\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Installing Payload Live Preview React Package (Bash)\nDESCRIPTION: This command uses the Node Package Manager (npm) to install the `@payloadcms/live-preview-react` package and add it as a dependency to the project. This package provides React components and hooks specifically designed for implementing Payload's Live Preview feature in React applications (both server and client components).\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/live-preview-react\n```\n\n----------------------------------------\n\nTITLE: Restricting Read Access by Draft Status in Payload CMS - TypeScript\nDESCRIPTION: Demonstrates how to set up a Payload CMS collection configuration with custom access control for reading documents based on the user's authentication status and the document's draft status. The code uses the CollectionConfig type, restricts unauthenticated access to published documents only, and enables drafts. Dependency: Payload CMS. Key parameters include the request object (req) and the access.read function. Returns a MongoDB query constraint or a boolean. Designed for Payload configuration files.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/versions/drafts.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Pages: CollectionConfig = {\n  slug: 'pages',\n  access: {\n    read: ({ req }) => {\n      // If there is a user logged in,\n      // let them retrieve all documents\n      if (req.user) return true\n\n      // If there is no user,\n      // restrict the documents that are returned\n      // to only those where `_status` is equal to `published`\n      return {\n        _status: {\n          equals: 'published',\n        },\n      }\n    },\n  },\n  versions: {\n    drafts: true,\n  },\n  //.. the rest of the Pages config here\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Payload Field Type (TypeScript)\nDESCRIPTION: This snippet shows how to define a single field object using the `Field` type imported from `payload`. It specifically highlights setting the mandatory `type` property (set to 'text' here), which determines the field's behavior and appearance. The `name` property is also included.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyField: Field = {\n  type: 'text', // highlight-line\n  name: 'myField',\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Workflow in Payload CMS Configuration (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to define a workflow within the `jobs.workflows` array in the Payload CMS configuration using `buildConfig`. It specifies a unique `slug`, defines the expected `inputSchema` for the workflow, and implements the `handler` function. The handler orchestrates the execution of two tasks (`createPost` and `updatePost`) sequentially, passing data derived from the job input and the output of the first task to the second, using unique IDs ('1', '2') for each task invocation to enable proper retry logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/workflows.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nexport default buildConfig({\n  // ...\n  jobs: {\n    tasks: [\n      // ...\n    ]\n    workflows: [\n      {\n        slug: 'createPostAndUpdate',\n\n        // The arguments that the workflow will accept\n        inputSchema: [\n          {\n            name: 'title',\n            type: 'text',\n            required: true,\n          },\n        ],\n\n        // The handler that defines the \"control flow\" of the workflow\n        // Notice how it uses the `tasks` argument to execute your predefined tasks.\n        // These are strongly typed!\n        handler: async ({ job, tasks }) => {\n\n          // This workflow first runs a task called `createPost`.\n\n          // You need to define a unique ID for this task invocation\n          // that will always be the same if this workflow fails\n          // and is re-executed in the future. Here, we hard-code it to '1'\n          const output = await tasks.createPost('1', {\n            input: {\n              title: job.input.title,\n            },\n          })\n\n          // Once the prior task completes, it will run a task\n          // called `updatePost`\n          await tasks.updatePost('2', {\n            input: {\n              post: job.taskStatus.createPost['1'].output.postID, // or output.postID\n              title: job.input.title + '2',\n            },\n          })\n        },\n      } as WorkflowConfig<'updatePost'>\n    ]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Lexical Editor in Payload CMS - TypeScript\nDESCRIPTION: This TypeScript snippet illustrates how to integrate the Lexical Rich Text Editor with a Payload CMS configuration. It imports the necessary functions from the 'payload' and '@payloadcms/richtext-lexical' packages, then defines a configuration object that sets 'editor' to the result of lexicalEditor({}). Key parameters include the imported editor object, and you can customize the rest of the Payload config as needed. Expected output is a Payload CMS config exporting the Lexical editor as the content editor. Requires both 'payload' and '@payloadcms/richtext-lexical' to be installed. This setup should be included in the main Payload config file.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/richtext-lexical/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { lexicalEditor } from '@payloadcms/richtext-lexical'\n\nexport default buildConfig({\n  editor: lexicalEditor({}),\n  // ...rest of config\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Blocks Field in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates the fundamental structure for defining a Blocks Field in Payload CMS. It imports the `Field` type from the 'payload' package and shows setting the `type` property to 'blocks' and including a `blocks` array where specific block configurations (schemas) will be defined. This is the core setup for creating a flexible content building field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyBlocksField: Field = {\n  // ...\n  // highlight-start\n  type: 'blocks',\n  blocks: [\n    // ...\n  ],\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Live Preview Configuration in Payload\nDESCRIPTION: This snippet shows the basic configuration required to enable Live Preview in the Payload CMS admin panel. It sets the `url` pointing to the front-end application and specifies the `collections` for which Live Preview should be enabled.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/overview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    // ...\n    // highlight-start\n    livePreview: {\n      url: 'http://localhost:3000',\n      collections: ['pages'],\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Unique Constraints before Duplicating a Field with Payload Hooks - TypeScript\nDESCRIPTION: Implements a beforeDuplicate hook for a number field in Payload CMS to avoid unique constraint violations by incrementing the field value when duplicating documents. Ensures each duplicate receives an incremented value instead of a repeated one. Requires Payload CMS; field should be configured with a unique constraint for this to be effective.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/fields.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nconst numberField: Field = {\n  name: 'number',\n  type: 'number',\n  hooks: {\n    // increment existing value by 1\n    beforeDuplicate: [\n      ({ value }) => {\n        return (value ?? 0) + 1\n      },\n    ],\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Specifying the Admin User Collection in Payload Config (TypeScript)\nDESCRIPTION: Demonstrates setting the `user` property within the `admin` configuration object in `payload.config.ts`. This specifies the `slug` of the auth-enabled Collection whose members are permitted to log in to the Payload Admin Panel. In this example, only users from the 'admins' collection can access the admin UI.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/overview.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    user: 'admins', // highlight-line\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Serializing Rich Text JSON to React JSX in TypeScript\nDESCRIPTION: This snippet demonstrates how to convert Rich Text content stored as JSON into JSX elements for rendering in a React application. It leverages SlateJS's Text utilities, React's Fragment, and escapeHTML to safely format and display various text styles (bold, italic, code, etc.) as appropriate HTML elements. To use, ensure dependencies on React and Slate (and escape-html) are installed; input is an array of Slate JSON nodes and output is a JSX element tree for use in React components.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/slate.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport React, { Fragment } from \"react\";\nimport escapeHTML from \"escape-html\";\nimport { Text } from \"slate\";\n\nconst serialize = (children) =>\n  children.map((node, i) => {\n    if (Text.isText(node)) {\n      let text = (\n        <span dangerouslySetInnerHTML={{ __html: escapeHTML(node.text) }} />\n      );\n\n      if (node.bold) {\n        text = <strong key={i}>{text}</strong>;\n      }\n\n      if (node.code) {\n        text = <code key={i}>{text}</code>;\n      }\n\n      if (node.italic) {\n        text = <em key={i}>{text}</em>;\n      }\n\n      // Handle other leaf types here...\n\n      return <Fragment key={i}>{text}</Fragment>;\n    }\n\n    if (!node) {\n      return null;\n    }\n\n    switch (node.type) {\n      case \"h1\":\n        return <h1 key={i}>{serialize(node.children)}</h1>;\n      // Iterate through all headings here...\n      case \"h6\":\n        return <h6 key={i}>{serialize(node.children)}</h6>;\n      case \"blockquote\":\n        return <blockquote key={i}>{serialize(node.children)}</blockquote>;\n      case \"ul\":\n        return <ul key={i}>{serialize(node.children)}</ul>;\n      case \"ol\":\n        return <ol key={i}>{serialize(node.children)}</ol>;\n      case \"li\":\n        return <li key={i}>{serialize(node.children)}</li>;\n      case \"link\":\n        return (\n          <a href={escapeHTML(node.url)} key={i}>\n            {serialize(node.children)}\n          </a>\n        );\n\n      default:\n        return <p key={i}>{serialize(node.children)}</p>;\n    }\n  });\n```\n\n----------------------------------------\n\nTITLE: Updating Document by ID - Payload CMS JavaScript\nDESCRIPTION: This snippet updates a specific document by its ID within a collection using the Local API. It demonstrates support for localization, file uploads (with file replacement control), deeper population (depth), and locking behavior. Key inputs include collection name, document ID, data object, and options for uploads. File handling requires file or filePath availability.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Result will be the updated Post document.\nconst result = await payload.update({\n  collection: 'posts', // required\n  id: '507f1f77bcf86cd799439011', // required\n  data: {\n    // required\n    title: 'sure',\n    description: 'maybe',\n  },\n  depth: 2,\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUser,\n  overrideAccess: false,\n  overrideLock: false, // By default, document locks are ignored. Set to false to enforce locks.\n  showHiddenFields: true,\n\n  // If your collection supports uploads, you can upload\n  // a file directly through the Local API by providing\n  // its full, absolute file path.\n  filePath: path.resolve(__dirname, './path-to-image.jpg'),\n\n  // If you are uploading a file and would like to replace\n  // the existing file instead of generating a new filename,\n  // you can set the following property to `true`\n  overwriteExistingFiles: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Client Component in Payload (TSX)\nDESCRIPTION: This snippet illustrates how to define a React Client Component for use within Payload by adding the `'use client'` directive at the top of the file. This allows the use of client-side hooks like `useState`. Payload automatically handles non-serializable props for such components.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// highlight-start\n'use client'\n// highlight-end\nimport React, { useState } from 'react'\n\nexport function MyClientComponent() {\n  const [count, setCount] = useState(0)\n\n  return (\n    <button onClick={() => setCount(count + 1)}>Clicked {count} times</button>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Collection-Level Access Control for Query Presets - TypeScript\nDESCRIPTION: This snippet shows how to restrict Query Presets access at the collection level to users with the 'admin' role by using the access property under queryPresets in the Payload CMS config. Access functions check the roles property of the user in the request to determine permissions for read and update operations. Dependencies include a user authentication setup and a 'roles' field on the user object. This setup overrides default Payload access, so ensure authentication checks are handled to prevent unintended public access.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/query-presets/overview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  queryPresets: {\n    // ...\n    // highlight-start\n    access: {\n      read: ({ req: { user } }) =>\n        user ? user?.roles?.some((role) => role === 'admin') : false,\n      update: ({ req: { user } }) =>\n        user ? user?.roles?.some((role) => role === 'admin') : false,\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Slate Editor in Root Payload Config - Payload CMS - TypeScript\nDESCRIPTION: Demonstrates how to globally configure the legacy Slate rich text editor as the default editor for Payload CMS collections. Imports buildConfig and slateEditor, then initializes the root config passing the Slate editor via the 'editor' property. Requires @payloadcms/richtext-slate to be installed and expects this config to be the main entry point for Payload. Takes editor options as an optional argument, shown here with an empty config ({}).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/slate.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { slateEditor } from '@payloadcms/richtext-slate'\n\nexport default buildConfig({\n  collections: [\n    // your collections here\n  ],\n  // Pass the Slate editor to the root config\n  editor: slateEditor({}),\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Array Field Client Component in TSX\nDESCRIPTION: This snippet defines a custom React client component (`CustomArrayFieldClient`) for rendering a Payload CMS Array Field, marked with the `'use client'` directive. It imports and wraps the standard `ArrayField` component from `@payloadcms/ui`. The component accepts standard client-side props for the field and spreads them onto the wrapped `ArrayField`. Requires React and dependencies from `@payloadcms/ui` and `payload`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/array.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport React from 'react'\nimport { ArrayField } from '@payloadcms/ui'\nimport type { ArrayFieldClientComponent } from 'payload'\n\nexport const CustomArrayFieldClient: ArrayFieldClientComponent = (props) => {\n  return <ArrayField {...props} />\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Email Field in Payload CMS (TypeScript)\nDESCRIPTION: This snippet shows the fundamental configuration for creating an Email field in Payload CMS. It imports the `Field` type and defines a field configuration object where the `type` property is set to `'email'`, indicating that this field should validate input as an email address.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/email.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyEmailField: Field = {\n  // ...\n  type: 'email', // highlight-line\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom useLivePreview React Hook with Payload CMS in TypeScript\nDESCRIPTION: This full-featured React/TypeScript example defines a custom useLivePreview hook that manages subscribing to and handling Payload CMS Live Preview events. It relies on the @payloadcms/live-preview package for real-time updates and merges initial document data with preview changes, handling loading state and unsubscription. Key parameters include depth (relationship depth), initialData (seed data object), and serverURL (Payload server endpoint). Dependencies are React (useState, useEffect, useCallback, useRef) and Payload's live-preview tools.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/client.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { subscribe, unsubscribe, ready } from '@payloadcms/live-preview'\nimport { useCallback, useEffect, useState, useRef } from 'react'\n\nexport const useLivePreview = <T extends any>(props: {\n  depth?: number\n  initialData: T\n  serverURL: string\n}): {\n  data: T\n  isLoading: boolean\n} => {\n  const { depth = 0, initialData, serverURL } = props\n  const [data, setData] = useState<T>(initialData)\n  const [isLoading, setIsLoading] = useState<boolean>(true)\n  const hasSentReadyMessage = useRef<boolean>(false)\n\n  const onChange = useCallback((mergedData) => {\n    // When a change is made, the `onChange` callback will be called with the merged data\n    // Set this merged data into state so that React will re-render the UI\n    setData(mergedData)\n    setIsLoading(false)\n  }, [])\n\n  useEffect(() => {\n    // Listen for `window.postMessage` events from the Admin Panel\n    // When a change is made, the `onChange` callback will be called with the merged data\n    const subscription = subscribe({\n      callback: onChange,\n      depth,\n      initialData,\n      serverURL,\n    })\n\n    // Once subscribed, send a `ready` message back up to the Admin Panel\n    // This will indicate that the front-end is ready to receive messages\n    if (!hasSentReadyMessage.current) {\n      hasSentReadyMessage.current = true\n\n      ready({\n        serverURL,\n      })\n    }\n\n    // When the component unmounts, unsubscribe from the `window.postMessage` events\n    return () => {\n      unsubscribe(subscription)\n    }\n  }, [serverURL, onChange, depth, initialData])\n\n  return {\n    data,\n    isLoading,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a Page URL for SEO Preview - TypeScript\nDESCRIPTION: This code provides an example generateURL function for the SEO plugin, constructing a page URL using the collection slug and document slug. The function is used in the SEO preview to reflect the actual frontend route and should be included in plugin options.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  seoPlugin({\n    generateURL: ({ doc, collectionSlug }) =>\n      `https://yoursite.com/${collectionSlug}/${doc?.slug}`,\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing After Refresh Hook for Payload CMS (TypeScript)\nDESCRIPTION: Implements an afterRefresh hook for Payload CMS, using CollectionAfterRefreshHook in TypeScript. This hook is triggered after a user's authentication token is refreshed, and receives arguments such as the refreshed token. The snippet allows extension for operations like audit logging or modifying the token response. Requires the 'payload' package in a TypeScript project. Inputs include the token and optionally request context; outputs may be a modified token or side effect.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionAfterRefreshHook } from 'payload';\\n\\nconst afterRefreshHook: CollectionAfterRefreshHook = async ({\\n  token,\\n}) => {...}\\n\n```\n\n----------------------------------------\n\nTITLE: Importing PayloadCMS Collection Types for Type Safety - TypeScript\nDESCRIPTION: Illustrates the import of CollectionConfig and SanitizedCollectionConfig types from the 'payload' package, supporting type checking and type safety in collection configuration files. Intended for use in TypeScript environments to distinguish between raw and sanitized config states. Output is for direct import in config files, with no runtime behavior.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/collections.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig, SanitizedCollectionConfig } from 'payload'\n```\n\n----------------------------------------\n\nTITLE: Recommended Directory Structure for Custom GraphQL Logic\nDESCRIPTION: Suggests a best-practice directory structure for organizing custom GraphQL queries, mutations, and resolvers within a PayloadCMS project. It recommends a top-level `graphql` directory with subdirectories for `queries` and `mutations`, potentially further nested by operation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/extending.mdx#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nsrc/graphql\n---- queries/\n     index.ts\n    -- myCustomQuery/\n       index.ts\n       resolver.ts\n\n---- mutations/\n```\n\n----------------------------------------\n\nTITLE: Configuring Edit View Options in PayloadCMS - TypeScript\nDESCRIPTION: Defines a custom collection using Payload\"s CollectionConfig, specifying the admin.edit.components to override or enhance default edit view UI elements, such as custom Save, Publish, or Preview buttons. Requires the 'payload' Node.js package, with dependencies on properly configured collection admin settings. The snippet expects a collection export and an object with an 'admin' property containing nested 'components' for edit view customization. Custom component overrides will only take effect if relevant features (like Drafts or Preview) are enabled/disabled as noted in accompanying comments.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/collections.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionCOnfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      edit: {\n        // highlight-line\n        // ...\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Payload SCSS Variables and Utilities\nDESCRIPTION: This SCSS snippet demonstrates how to import Payload's predefined SCSS variables and utilities into a custom stylesheet from the `@payloadcms/ui` package. This allows developers to reuse existing styles, colors, mixins, and other utilities provided by Payload UI.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/customizing-css.mdx#_snippet_2\n\nLANGUAGE: scss\nCODE:\n```\n@import '~@payloadcms/ui/scss';\n```\n\n----------------------------------------\n\nTITLE: Custom Blocks Field Label (Server Component) - React TypeScript\nDESCRIPTION: Implements a server-side field label component for PayloadCMS blocks using the '@payloadcms/ui' FieldLabel utility. The component accepts clientField, path, and required props, conditionally choosing the label to display, and fits into customized admin UIs for server-rendered environments. Integration requires Payload's server-side label types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { BlocksFieldLabelServerComponent } from 'payload'\n\nexport const CustomBlocksFieldLabelServer: BlocksFieldLabelServerComponent = ({\n  clientField,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={clientField?.label || clientField?.name}\n      path={path}\n      required={clientField?.required}\n    />\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Email Field Server Component in Payload CMS (TSX)\nDESCRIPTION: This snippet shows how to create a custom React Server Component for rendering an Email field in the Payload Admin UI. It imports and utilizes the default `EmailField` component from `@payloadcms/ui`, passing necessary props like `clientField`, `path`, `schemaPath`, and `permissions`. This allows for server-side customization or wrapping of the default field component.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/email.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport type React from 'react'\nimport { EmailField } from '@payloadcms/ui'\nimport type { EmailFieldServerComponent } from 'payload'\n\nexport const CustomEmailFieldServer: EmailFieldServerComponent = ({\n  clientField,\n  path,\n  schemaPath,\n  permissions,\n}) => {\n  return (\n    <EmailField\n      field={clientField}\n      path={path}\n      schemaPath={schemaPath}\n      permissions={permissions}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in a Payload Server Function (TypeScript)\nDESCRIPTION: Demonstrates best practices for error handling within a Next.js server function that interacts with the Payload Local API. It uses a try/catch block to capture errors during the API call (`payload.create`), logs the error server-side for debugging, and returns a structured error object to the client instead of exposing raw error details.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Assuming getPayload and config are available\nimport { getPayload } from 'payload'\nimport config from '@payload-config'\n\nexport async function createPost(data: any) { // Use specific type for data if possible\n  try {\n    const payload = await getPayload({ config })\n    // Attempt to create a post using Payload Local API\n    return await payload.create({ collection: 'posts', data })\n  } catch (error) {\n    // Log the detailed error on the server\n    console.error('Error creating post:', error)\n    // Return a generic, structured error response to the client\n    return { error: 'Failed to create post' }\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Next.js with the withPayload Plugin - JavaScript\nDESCRIPTION: Shows a Next.js configuration file set up to use the withPayload plugin from @payloadcms/next/withPayload. Ensures compatibility with key dependencies. Prerequisites: Next.js 15+, ECMAScript module environment (set via package.json or .mjs extension). Key parameter: 'nextConfig' is your Next.js configuration object. Outputs an ESM-exported, Payload-wrapped Next.js config. Limitation: All imports/exports must follow ESM conventions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/installation.mdx#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nimport { withPayload } from '@payloadcms/next/withPayload'\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  // Your Next.js config here\n  experimental: {\n    reactCompiler: false,\n  },\n}\n\n// Make sure you wrap your `nextConfig`\n// with the `withPayload` plugin\nexport default withPayload(nextConfig) // highlight-line\n```\n\n----------------------------------------\n\nTITLE: Defining a Group Field with a Reusable Interface Name - TypeScript\nDESCRIPTION: This TypeScript configuration snippet defines a Payload CMS 'group' field named 'meta' and specifies an interfaceName for reusable type generation. This enables the code generator to output a top-level GraphQL type named 'SharedMeta'. Required prerequisites: Payload CMS environment, familiarity with collection field configs. The config expects child fields, such as 'title' and 'description', and outputs a GraphQL schema referencing SharedMeta. Used in schema customization.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/graphql-schema.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  type: 'group',\n  name: 'meta',\n  interfaceName: 'SharedMeta', // highlight-line\n  fields: [\n    {\n      name: 'title',\n      type: 'text',\n    },\n    {\n      name: 'description',\n      type: 'text',\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a CollectionConfig in Payload (TypeScript)\nDESCRIPTION: Demonstrates how to define a CollectionConfig in Payload CMS to enable authentication and specify custom fields. Requires Payload and TypeScript. By setting the slug and auth properties, this config exposes standard GraphQL queries and authentication mutations for the defined collection. Inputs include field definitions, outputs include auto-generated GraphQL operations for the collection. Limitations: uploading files is supported only via REST, not GraphQL.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/overview.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\\n\\nexport const PublicUser: CollectionConfig = {\\n  slug: 'public-users',\\n  auth: true, // Auth is enabled\\n  fields: [\\n    ...\\n  ],\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Logout Server Action in TypeScript\nDESCRIPTION: Defines a Next.js server action (`logoutAction`) that wraps the Payload `logout` function. It imports the Payload config, calls the `logout` function, and handles potential errors. This server action is needed because the Payload config cannot be used directly in client components.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n'use server'\n\nimport { logout } from '@payloadcms/next/auth'\nimport config from '@payload-config'\n\nexport async function logoutAction() {\n  try {\n    return await logout({ config }) // Pass the Payload config\n  } catch (error) {\n    throw new Error(\n      `Logout failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    )\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Task with Inline Handler in PayloadCMS Config (TypeScript)\nDESCRIPTION: This snippet shows how to register a Task within the PayloadCMS config by defining its properties, input/output schemas, retry logic, and an inline async handler function. Dependencies include 'payload', TypeScript types, and a valid Payload configuration. The handler function uses the 'req.payload.create' method to create a post and returns the new post's ID. Required parameters include 'retries', 'slug', input/output schemas, and 'handler'. The input expects a title, and the output provides the created post's ID. Handler inline definition simplifies deployment but may bundle all dependencies with the app.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/tasks.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default buildConfig({\n  // ...\n  jobs: {\n    tasks: [\n      {\n        // Configure this task to automatically retry\n        // up to two times\n        retries: 2,\n\n        // This is a unique identifier for the task\n\n        slug: 'createPost',\n\n        // These are the arguments that your Task will accept\n        inputSchema: [\n          {\n            name: 'title',\n            type: 'text',\n            required: true,\n          },\n        ],\n\n        // These are the properties that the function should output\n        outputSchema: [\n          {\n            name: 'postID',\n            type: 'text',\n            required: true,\n          },\n        ],\n\n        // This is the function that is run when the task is invoked\n        handler: async ({ input, job, req }) => {\n          const newPost = await req.payload.create({\n            collection: 'post',\n            req,\n            data: {\n              title: input.title,\n            },\n          })\n          return {\n            output: {\n              postID: newPost.id,\n            },\n          }\n        },\n      } as TaskConfig<'createPost'>,\n    ],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Root Admin Views in Payload CMS with TypeScript\nDESCRIPTION: This snippet demonstrates how to override or extend Root Views (such as Dashboard or Account) in the Payload CMS admin panel. It uses the buildConfig function to define the admin.components.views property, mapping route keys to custom component paths. Required dependency is the 'payload' package, and the configuration must be supplied to the main Payload setup. Keys like 'dashboard' and 'account' map to main admin views, while arbitrary keys allow for adding new root-level admin pages.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-views.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    components: {\n      views: {\n        // highlight-start\n        dashboard: {\n          Component: '/path/to/Dashboard',\n        },\n        // highlight-end\n        // Other options include:\n        // - account\n        // - [key: string]\n        // See below for more details\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating Custom Converters into Slate-to-Lexical Feature in TypeScript\nDESCRIPTION: This code demonstrates how to configure the `SlateToLexicalFeature` within a Payload CMS `lexicalEditor` to utilize custom node converters during the on-the-fly migration from Slate to Lexical. It imports a custom converter (`YourCustomConverter`) and adds it to the `converters` array passed to `SlateToLexicalFeature`, alongside the `defaultSlateConverters` also imported from `@payloadcms/richtext-lexical`. This configuration allows the feature to handle both standard and custom Slate node types found in the rich text data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/migration.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nimport { lexicalEditor } from '@payloadcms/richtext-lexical'\nimport {\n  SlateToLexicalFeature,\n  defaultSlateConverters,\n} from '@payloadcms/richtext-lexical'\n\nimport { YourCustomConverter } from '../converters/YourCustomConverter'\n\nconst Pages: CollectionConfig = {\n  slug: 'pages',\n  fields: [\n    {\n      name: 'nameOfYourRichTextField',\n      type: 'richText',\n      editor: lexicalEditor({\n        features: ({ defaultFeatures }) => [\n          ...defaultFeatures,\n          SlateToLexicalFeature({\n            converters: [...defaultSlateConverters, YourCustomConverter],\n          }),\n        ],\n      }),\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Manipulating Active Table Columns with useTableColumns in React (TypeScript)\nDESCRIPTION: Demonstrates use of setActiveColumns from the useTableColumns hook in @payloadcms/ui to reset displayed columns in a table within Payload CMS admin. Useful for end-user column visibility controls. This example shows resetting to default; requires @payloadcms/ui and works in admin List/Table context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport { useTableColumns } from '@payloadcms/ui'\\n\\nconst MyComponent: React.FC = () => {\\n  // highlight-start\\n  const { setActiveColumns } = useTableColumns()\\n\\n  const resetColumns = () => {\\n    setActiveColumns(['id', 'createdAt', 'updatedAt'])\\n  }\\n  // highlight-end\\n\\n  return (\\n    <button type=\\\"button\\\" onClick={resetColumns}>\\n      Reset columns\\n    </button>\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom beforeDocumentControls Client Component (TSX)\nDESCRIPTION: Example of a custom React client component ('use client' directive) for the `beforeDocumentControls` slot. It receives `BeforeDocumentControlsClientProps` and can render interactive UI elements just before the main action buttons.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport React from 'react'\nimport type { BeforeDocumentControlsClientProps } from 'payload'\n\nexport function MyCustomDocumentControlButton(\n  props: BeforeDocumentControlsClientProps,\n) {\n  return <div>This is a custom beforeDocumentControl button (Client)</div>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Custom Filenames for Image Sizes in Payload CMS TypeScript\nDESCRIPTION: This snippet illustrates how to define a custom filename generation function for a specific image size within a Payload CMS collection's upload configuration. The 'generateImageName' function receives details like the original filename, resize name ('sizeName'), extension, height, and width, allowing for patterned filenames for resized images (e.g., 'custom-thumbnail-300-400.jpg').\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/overview.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n{\n  name: 'thumbnail',\n  width: 400,\n  height: 300,\n  generateImageName: ({ height, sizeName, extension, width }) => {\n    return `custom-${sizeName}-${height}-${width}.${extension}`\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining the Context Type for useTenantSelection Hook in TypeScript\nDESCRIPTION: Defines the `ContextType` TypeScript interface returned by the `useTenantSelection` hook. It outlines the structure of the context object, which includes an array of tenant `options` for selection, the `selectedTenantID`, a function `setPreventRefreshOnChange` to control page reloads on tenant change, and the `setTenant` function to programmatically change the selected tenant.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/multi-tenant.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ntype ContextType = {\n  /**\n   * Array of options to select from\n   */\n  options: OptionObject[]\n  /**\n   * The currently selected tenant ID\n   */\n  selectedTenantID: number | string | undefined\n  /**\n   * Prevents a refresh when the tenant is changed\n   *\n   * If not switching tenants while viewing a \"global\", set to true\n   */\n  setPreventRefreshOnChange: React.Dispatch<React.SetStateAction<boolean>>\n  /**\n   * Sets the selected tenant ID\n   *\n   * @param args.id - The ID of the tenant to select\n   * @param args.refresh - Whether to refresh the page after changing the tenant\n   */\n  setTenant: (args: {\n    id: number | string | undefined\n    refresh?: boolean\n  }) => void\n}\n```\n\n----------------------------------------\n\nTITLE: Performing a Payload GET Request via POST Method Override (TypeScript Fetch)\nDESCRIPTION: Provides a client-side example using the `fetch` API in TypeScript to make a GET request to a Payload endpoint using the POST method. It utilizes the `X-HTTP-Method-Override: GET` header and sends query parameters (like `depth` and `locale`) in the `application/x-www-form-urlencoded` request body, which is useful for bypassing potential query string length limitations. Requires a library like `qs` to stringify the body.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst res = await fetch(`${api}/${collectionSlug}`, {\n  method: 'POST',\n  credentials: 'include',\n  headers: {\n    'Accept-Language': i18n.language,\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'X-HTTP-Method-Override': 'GET',\n  },\n  body: qs.stringify({\n    depth: 1,\n    locale: 'en',\n  }),\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Join Fields with PayloadCMS Local API in JavaScript\nDESCRIPTION: Provides a JavaScript example using the PayloadCMS Local API (`payload.find`) to query a collection (`categories`) and customize the retrieval of related documents within a specific Join Field (`relatedPosts`). It demonstrates applying `limit`, `where` conditions, and `sort` order directly to the joined data using the `joins` parameter.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/join.mdx#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst result = await payload.find({\n  collection: 'categories',\n  where: {\n    title: {\n      equals: 'My Category',\n    },\n  },\n  joins: {\n    relatedPosts: {\n      limit: 5,\n      where: {\n        title: {\n          equals: 'My Post',\n        },\n      },\n      sort: 'title',\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Overriding the Form Submissions Collection in Form Builder Plugin (TypeScript)\nDESCRIPTION: Configures formSubmissionOverrides to extend or restrict the form-submissions collection, such as customizing fields or altering default access. Ensures that by default, only submission creation is allowed publicly, with read/update restricted. Appends a custom text field to default fields for each form submission document.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nformBuilderPlugin({\n  // ...\n  formSubmissionOverrides: {\n    slug: 'leads',\n    fields: ({ defaultFields }) => {\n      return [\n        ...defaultFields,\n        {\n          name: 'custom',\n          type: 'text',\n        },\n      ]\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Sorting by Single Field in Payload Local API (TypeScript)\nDESCRIPTION: This snippet demonstrates how to retrieve and sort documents using the Payload Local API in TypeScript. It uses the `payload.find` method on the 'posts' collection, specifying the `sort` option with '-createdAt' to sort the results by the 'createdAt' field in descending order. Requires a Payload instance.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/sort.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Payload } from 'payload'\n\nconst getPosts = async (payload: Payload) => {\n  const posts = await payload.find({\n    collection: 'posts',\n    sort: '-createdAt', // highlight-line\n  })\n\n  return posts\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Custom Field Validation Function in Payload CMS (TypeScript)\nDESCRIPTION: This snippet demonstrates how to define a custom validation function for a text field within a Payload CMS field configuration. The `validate` function checks if a value exists and returns either `true` (if valid) or an error message string (if invalid).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyField: Field = {\n  type: 'text',\n  name: 'myField',\n  validate: (value) => Boolean(value) || 'This field is required', // highlight-line\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Basic Configuration of Payload Cloud Storage Plugin in TypeScript\nDESCRIPTION: Demonstrates how to integrate the Payload Cloud Storage plugin into a Payload CMS configuration using `buildConfig`. It shows importing the plugin and applying it within the `plugins` array, specifying the target collection slug ('my-collection-slug') and the storage adapter (`theAdapterToUse`). This setup enables storing media for the specified collection in a configured cloud storage provider.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { cloudStoragePlugin } from '@payloadcms/plugin-cloud-storage'\n\nexport default buildConfig({\n  plugins: [\n    cloudStoragePlugin({\n      collections: {\n        'my-collection-slug': {\n          adapter: theAdapterToUse, // see docs for the adapter you want to use\n        },\n      },\n    }),\n  ],\n  // The rest of your config goes here\n})\n```\n\n----------------------------------------\n\nTITLE: Defining and Running Nested Tasks in Payload CMS (TypeScript)\nDESCRIPTION: This snippet shows how to define a parent task that executes sub-tasks using `inlineTask` and `tasks` helpers within the `handler` function of the Payload CMS task definition. The configuration recommends setting `addParentToTaskLog` to `true` for enhanced observability, and demonstrates initiating sub-tasks with input and output handling. The implementation relies on Payload CMS jobs infrastructure with TypeScript and expects `TaskConfig` type for task typing.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/tasks.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default buildConfig({\n  // ...\n  jobs: {\n    // It is recommended to set `addParentToTaskLog` to `true` when using nested tasks, so that the parent task is included in the task log\n    // This allows for better observability and debugging of the task execution\n    addParentToTaskLog: true,\n    tasks: [\n      {\n        slug: 'parentTask',\n        inputSchema: [\n          {\n            name: 'text',\n            type: 'text',\n          },\n        ],\n        handler: async ({ input, req, tasks, inlineTask }) => {\n          await inlineTask('Sub Task 1', {\n            task: () => {\n              // Do something\n              return {\n                output: {},\n              }\n            },\n          })\n\n          await tasks.CreateSimple('Sub Task 2', {\n            input: { message: 'hello' },\n          })\n\n          return {\n            output: {},\n          }\n        },\n      } as TaskConfig<'parentTask'>,\n    ],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Constructing Complex Queries with AND/OR Logic in TypeScript\nDESCRIPTION: Demonstrates combining multiple query conditions using `and` and `or` operators within the `Where` type imported from Payload. This example constructs a query to find documents where either the 'color' is 'mint' OR both the 'color' is 'white' and 'featured' is false. Allows for deeply nested, complex filtering logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/overview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Where } from 'payload'\n\nconst query: Where = {\n  or: [\n    // highlight-line\n    {\n      color: {\n        equals: 'mint',\n      },\n    },\n    {\n      and: [\n        // highlight-line\n        {\n          color: {\n            equals: 'white',\n          },\n        },\n        {\n          featured: {\n            equals: false,\n          },\n        },\n      ],\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Data using Payload's GraphQL API\nDESCRIPTION: Provides a GraphQL query example for fetching data from the 'Posts' collection. It utilizes the `where` argument to filter documents where the 'color' field equals 'mint' and specifies the desired output fields (`color`, `totalDocs`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/overview.mdx#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  Posts(where: { color: { equals: mint } }) {\n    docs {\n      color\n    }\n    totalDocs\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Locale-Specific Access Control - Payload CMS - TypeScript\nDESCRIPTION: This code demonstrates how to implement locale-aware access control within Payload CMS, allowing or denying access based on the `locale` value from the request object. The function checks whether the locale is `'en'` and grants access accordingly. The snippet requires the request context to provide a `locale` property and is intended for use within Payload's access control configuration. The expected input is an object containing a `req` parameter, and the output is a boolean indicating access permission. Only the `'en'` locale is allowed in this example; other locales are denied.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/overview.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst access = ({ req }) => {\n  // Grant access if the locale is 'en'\n  if (req.locale === 'en') {\n    return true\n  }\n\n  // Deny access for all other locales\n  return false\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Documents via Payload REST API\nDESCRIPTION: Performs a GET request to find paginated documents within a specific collection. Supports query parameters like sort, where, limit, and page for refined results. See drawer content in the original example for parameter details.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_0\n\nLANGUAGE: HTTP\nCODE:\n```\nGET /api/{collection-slug}\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Toolbar Item to the Fixed Toolbar in Payload RichText Lexical (TypeScript)\nDESCRIPTION: This TypeScript code shows how to register a custom client feature called MyClientFeature using createClientFeature from '@payloadcms/richtext-lexical/client', configuring it with a fixed toolbar group. It imports a set of commands, icon and utility functions. The group contains a toolbar item with several properties: ChildComponent for icon rendering, isActive to control item highlighting based on current selection, label supporting i18n, and onSelect to dispatch a custom Lexical command. This snippet demonstrates adding interactive functionality to the fixed toolbar, with conditional activation based on current editor state, and is intended to be placed within a Payload CMS project supporting client features and rich editing workflows.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_18\n\nLANGUAGE: TypeScript\nCODE:\n```\n'use client'\n\nimport {\n  createClientFeature,\n  toolbarAddDropdownGroupWithItems,\n} from '@payloadcms/richtext-lexical/client'\nimport { IconComponent } from './icon'\nimport { $isHorizontalRuleNode } from './nodes/MyNode'\nimport { INSERT_MYNODE_COMMAND } from './plugin'\nimport { $isNodeSelection } from '@payloadcms/richtext-lexical/lexical'\n\nexport const MyClientFeature = createClientFeature({\n  toolbarFixed: {\n    groups: [\n      toolbarAddDropdownGroupWithItems([\n        {\n          ChildComponent: IconComponent,\n          isActive: ({ selection }) => {\n            if (!$isNodeSelection(selection) || !selection.getNodes().length) {\n              return false\n            }\n\n            const firstNode = selection.getNodes()[0]\n            return $isHorizontalRuleNode(firstNode)\n          },\n          key: 'myNode',\n          label: ({ i18n }) => {\n            return i18n.t('lexical:myFeature:label')\n          },\n          onSelect: ({ editor }) => {\n            editor.dispatchCommand(INSERT_MYNODE_COMMAND, undefined)\n          },\n        },\n      ]),\n    ],\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Configuring a Custom SaveDraftButton for a Collection (TypeScript)\nDESCRIPTION: This snippet shows how to replace the default Save Draft button in a Collection's Edit View by providing a path to a custom component via the `admin.components.edit.SaveDraftButton` property in the Collection configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_12\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      edit: {\n        // highlight-start\n        SaveDraftButton: '/path/to/MySaveDraftButton',\n        // highlight-end\n      },\n    },\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Integrating a Custom Server Feature into Payload Lexical Editor (TypeScript)\nDESCRIPTION: Illustrates how to add a custom server-side feature (`MyFeature`) to the `features` array within the `lexicalEditor` configuration for a Payload Rich Text field. This enables the custom feature within the editor instance. Requires `@payloadcms/richtext-lexical` and the previously defined `MyFeature`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { MyFeature } from './myFeature/feature.server';\nimport { lexicalEditor } from '@payloadcms/richtext-lexical';\n\n//...\n {\n    name: 'richText',\n    type: 'richText',\n    editor: lexicalEditor({\n      features: [\n        MyFeature(),\n      ],\n    }),\n },\n```\n\n----------------------------------------\n\nTITLE: Customizing Lexical to Plaintext Conversion with Converters in PayloadCMS (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to define custom converters that control how specific Lexical nodes are transformed into plaintext strings during conversion. It imports various type definitions and the conversion function from @payloadcms/richtext-lexical. The converters object allows you to override plaintext serialization for blocks and links, providing tailored output. The snippet expects that node data matches the provided type definitions. Main dependencies are the PayloadCMS richtext-lexical packages and optional custom block types. The output is a string, where the plaintext is determined by your converter logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-plaintext.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type {\n  DefaultNodeTypes,\n  SerializedBlockNode,\n} from '@payloadcms/richtext-lexical'\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\nimport type { MyTextBlock } from '@/payload-types'\n\nimport {\n  convertLexicalToPlaintext,\n  type PlaintextConverters,\n} from '@payloadcms/richtext-lexical/plaintext'\n\n// Your richtext data here\nconst data: SerializedEditorState = {}\n\nconst converters: PlaintextConverters<\n  DefaultNodeTypes | SerializedBlockNode<MyTextBlock>\n> = {\n  blocks: {\n    textBlock: ({ node }) => {\n      return node.fields.text ?? ''\n    },\n  },\n  link: ({ node }) => {\n    return node.fields.url ?? ''\n  },\n}\n\nconst plaintext = convertLexicalToPlaintext({\n  converters,\n  data,\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Admin Thumbnail via Custom Function in Payload CMS TypeScript\nDESCRIPTION: This configuration snippet shows how to define a custom function to generate the URL for an admin panel thumbnail in a Payload CMS collection. The 'adminThumbnail' function receives the document data ('doc') and should return a complete URL string pointing to the desired thumbnail image, allowing for dynamic or external thumbnail sources.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/overview.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Media: CollectionConfig = {\n  slug: 'media',\n  upload: {\n    // highlight-start\n    adminThumbnail: ({ doc }) =>\n      `https://google.com/custom-path-to-file/${doc.filename}`,\n    // highlight-end\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Custom Document Tab (Client Component) - React TSX\nDESCRIPTION: This TSX code defines a custom Document Tab as a client-side React component for Payload CMS using DocumentTabClientProps. It imports React, the necessary props type from Payload, and the Link component from the Payload UI package. The function renders a navigation link labeled \"This is a custom Document Tab (Client)\", intended for client-side rendering within the Payload admin panel. Dependencies include React, Payload CMS, and @payloadcms/ui.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/document-views.mdx#_snippet_4\n\nLANGUAGE: TSX\nCODE:\n```\n'use client'\nimport React from 'react'\nimport type { DocumentTabClientProps } from 'payload'\nimport { Link } from '@payloadcms/ui'\n\nexport function MyCustomTabComponent(props: DocumentTabClientProps) {\n  return (\n    <Link href=\"/my-custom-tab\">This is a custom Document Tab (Client)</Link>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Checkbox Field Server Component (React/TSX)\nDESCRIPTION: This snippet provides the code for a custom React Server Component to render a Checkbox field in the Payload admin UI. It imports the default 'CheckboxField' component from '@payloadcms/ui' and wraps it, passing through necessary props like 'clientField', 'path', 'schemaPath', and 'permissions'. This allows developers to override or extend the server-side rendering of the checkbox.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/checkbox.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport type React from 'react'\nimport { CheckboxField } from '@payloadcms/ui'\nimport type { CheckboxFieldServerComponent } from 'payload'\n\nexport const CustomCheckboxFieldServer: CheckboxFieldServerComponent = ({\n  clientField,\n  path,\n  schemaPath,\n  permissions,\n}) => {\n  return (\n    <CheckboxField\n      field={clientField}\n      path={path}\n      schemaPath={schemaPath}\n      permissions={permissions}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Selection State with useSelection Hook in React (TypeScript)\nDESCRIPTION: Demonstrates how to access selection state including count, toggleAll, and totalDocs using the useSelection hook from @payloadcms/ui. This hook exposes helpers for managing row selection in the List View within a custom component. Requires @payloadcms/ui and assumes a List View context, with the main inputs being list state and outputs being current selection info and callback methods.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport { useSelection } from '@payloadcms/ui'\\n\\nconst MyComponent: React.FC = () => {\\n  // highlight-start\\n  const { count, toggleAll, totalDocs } = useSelection()\\n  // highlight-end\\n\\n  return (\\n    <>\\n      <span>\\n        Selected {count} out of {totalDocs} docs!\\n      </span>\\n      <button type=\\\"button\\\" onClick={() => toggleAll(true)}>\\n        Toggle All Selections\\n      </button>\\n    </>\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Automating Schema Generation with npm Script in package.json - JSON\nDESCRIPTION: This JSON snippet demonstrates how to add a custom npm script for running schema generation in environments where Payload config isn't at the default location. It uses 'cross-env' to set 'PAYLOAD_CONFIG_PATH', ensuring Payload locates your config file before running 'payload-graphql generate:schema'. For use in package.json under 'scripts'. Required dependencies: cross-env, payload-graphql, and correct config path. Invocable via 'pnpm generate:graphQLSchema'.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/graphql-schema.mdx#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"generate:graphQLSchema\": \"cross-env PAYLOAD_CONFIG_PATH=src/payload.config.ts payload-graphql generate:schema\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Payload Collection Hook Types in TypeScript\nDESCRIPTION: This snippet demonstrates how to import various TypeScript types corresponding to different Payload Collection hooks from the 'payload' package. This allows for strong typing when defining hook functions within a Payload CMS project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {\n  CollectionBeforeOperationHook,\n  CollectionBeforeValidateHook,\n  CollectionBeforeChangeHook,\n  CollectionAfterChangeHook,\n  CollectionAfterReadHook,\n  CollectionBeforeReadHook,\n  CollectionBeforeDeleteHook,\n  CollectionAfterDeleteHook,\n  CollectionBeforeLoginHook,\n  CollectionAfterLoginHook,\n  CollectionAfterLogoutHook,\n  CollectionAfterRefreshHook,\n  CollectionAfterMeHook,\n  CollectionAfterForgotPasswordHook,\n  CollectionRefreshHook,\n  CollectionMeHook,\n} from 'payload'\n```\n\n----------------------------------------\n\nTITLE: Configuring Admin Options for Payload Rich Text Field in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to define a Payload Rich Text field (`MyRichTextField`) and access its `admin` property to customize its appearance and behavior within the Payload Admin Panel. It requires the `Field` type from the `payload` package.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/rich-text.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyRichTextField: Field = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring CSRF Protection in Payload CMS using TypeScript\nDESCRIPTION: Shows how to configure CSRF protection in Payload CMS within the `payload.config.ts` file. The `csrf` option takes an array of trusted domain origins from which cookie-based authentication requests will be accepted. The `serverURL` is automatically included if defined.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/cookies.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// payload.config.ts\n\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  serverURL: 'https://my-payload-instance.com',\n  // highlight-start\n  csrf: [\n    // whitelist of domains to allow cookie auth from\n    'https://your-frontend-app.com',\n    'https://your-other-frontend-app.com',\n    // `config.serverURL` is added by default if defined\n  ],\n  // highlight-end\n  collections: [\n    // collections here\n  ],\n})\n\nexport default config\n```\n```\n\n----------------------------------------\n\nTITLE: Building Payload CMS with a Multi-Stage Dockerfile\nDESCRIPTION: This Dockerfile provides a multi-stage build process for deploying a Payload CMS application built with Next.js. It installs dependencies, builds the project using the detected package manager (yarn, npm, or pnpm), and creates a minimal production image leveraging Next.js's standalone output feature. It sets up a non-root user and exposes port 3000. Remember to set necessary environment variables like `PAYLOAD_SECRET`, `PAYLOAD_CONFIG_PATH`, and `DATABASE_URI` during deployment.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/production/deployment.mdx#_snippet_1\n\nLANGUAGE: dockerfile\nCODE:\n```\n# Dockerfile\n# From https://github.com/vercel/next.js/blob/canary/examples/with-docker/Dockerfile\n\nFROM node:18-alpine AS base\n\n# Install dependencies only when needed\nFROM base AS deps\n# Check https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine to understand why libc6-compat might be needed.\nRUN apk add --no-cache libc6-compat\nWORKDIR /app\n\n# Install dependencies based on the preferred package manager\nCOPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./\nRUN \\\n  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \\\n  elif [ -f package-lock.json ]; then npm ci; \\\n  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm i --frozen-lockfile; \\\n  else echo \"Lockfile not found.\" && exit 1; \\\n  fi\n\n\n# Rebuild the source code only when needed\nFROM base AS builder\nWORKDIR /app\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY . .\n\n# Next.js collects completely anonymous telemetry data about general usage.\n# Learn more here: https://nextjs.org/telemetry\n# Uncomment the following line in case you want to disable telemetry during the build.\n# ENV NEXT_TELEMETRY_DISABLED 1\n\nRUN \\\n  if [ -f yarn.lock ]; then yarn run build; \\\n  elif [ -f package-lock.json ]; then npm run build; \\\n  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm run build; \\\n  else echo \"Lockfile not found.\" && exit 1; \\\n  fi\n\n# Production image, copy all the files and run next\nFROM base AS runner\nWORKDIR /app\n\nENV NODE_ENV production\n# Uncomment the following line in case you want to disable telemetry during runtime.\n# ENV NEXT_TELEMETRY_DISABLED 1\n\nRUN addgroup --system --gid 1001 nodejs\nRUN adduser --system --uid 1001 nextjs\n\nCOPY --from=builder /app/public ./public\n\n# Set the correct permission for prerender cache\nRUN mkdir .next\nRUN chown nextjs:nodejs .next\n\n# Automatically leverage output traces to reduce image size\n# https://nextjs.org/docs/advanced-features/output-file-tracing\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static\n\nUSER nextjs\n\nEXPOSE 3000\n\nENV PORT 3000\n\n# server.js is created by next build from the standalone output\n# https://nextjs.org/docs/pages/api-reference/next-config-js/output\nCMD HOSTNAME=\"0.0.0.0\" node server.js\n```\n\n----------------------------------------\n\nTITLE: Accessing MongoDB Directly within a Migration Transaction (TypeScript)\nDESCRIPTION: Shows how to perform direct MongoDB operations within a Payload migration's `up` function while leveraging the transaction managed by Payload. It imports `MigrateUpArgs` from `@payloadcms/db-mongodb`. The `up` function receives the `session` object (representing the MongoDB transaction session) along with `payload` and `req`. This `session` must be passed to direct driver calls (like `payload.db.collections.posts.collection.find({ session })`) to ensure they are part of the migration's transaction.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { type MigrateUpArgs } from '@payloadcms/db-mongodb'\n\nexport async function up({\n  session,\n  payload,\n  req,\n}: MigrateUpArgs): Promise<void> {\n  const posts = await payload.db.collections.posts.collection\n    .find({ session })\n    .toArray()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Authentication Strategy in Payload CMS - TypeScript\nDESCRIPTION: This snippet defines a custom authentication strategy within a Payload CMS collection configuration in TypeScript. It replaces Payload's built-in authentication strategies by adding a custom \"authenticate\" function that queries registered users via incoming request headers. Dependencies include the Payload CMS library. The snippet configures user fields (with \"code\" and \"secret\") and disables local strategy authentication. It expects authentication headers in the request and returns a user object or null along with optional response headers. Any strategy must maintain the defined method signature and return type.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/custom-strategies.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Users: CollectionConfig = {\n  slug: 'users',\n  auth: {\n    disableLocalStrategy: true,\n    // highlight-start\n    strategies: [\n      {\n        name: 'custom-strategy',\n        authenticate: ({ payload, headers }) => {\n          const usersQuery = await payload.find({\n            collection: 'users',\n            where: {\n              code: {\n                equals: headers.get('code'),\n              },\n              secret: {\n                equals: headers.get('secret'),\n              },\n            },\n          })\n\n          return {\n            // Send the user with the collection slug back to authenticate,\n            // or send null if no user should be authenticated\n            user: usersQuery.docs[0] ? {\n              collection: 'users'\n              ...usersQuery.docs[0],\n            } : null,\n\n            // Optionally, you can return headers\n            // that you'd like Payload to set here when\n            // it returns the response\n            responseHeaders: new Headers({\n              'some-header': 'my header value'\n            })\n          }\n        }\n      }\n    ]\n    // highlight-end\n  },\n  fields: [\n    {\n      name: 'code',\n      type: 'text',\n      index: true,\n      unique: true,\n    },\n    {\n      name: 'secret',\n      type: 'text',\n    },\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Restoring Collection Version using Payload Local API in JavaScript\nDESCRIPTION: This snippet demonstrates how to restore a specific version of a document within a collection using the Payload Local API. It requires the collection slug and the version ID. Optional parameters like `depth`, `user`, `overrideAccess`, and `showHiddenFields` can customize the operation. The function returns the restored document.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/versions/overview.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Result will be the restored global document.\nconst result = await payload.restoreVersion({\n  collection: 'posts', // required\n  id: '507f1f77bcf86cd799439013', // required\n  depth: 2,\n  user: dummyUser,\n  overrideAccess: false,\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Custom URL Generation for Breadcrumbs - TypeScript\nDESCRIPTION: Demonstrates creating a generateURL function for the plugin, concatenating each document's 'slug' into a URL path for breadcrumbs. Designed for use in Payload config and assumes existence of a 'slug' field in each document. This function processes an array of breadcrumb documents to construct a hierarchical URL string.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/nested-docs.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nnestedDocsPlugin({\n  //...\n  generateURL: (docs) => docs.reduce((url, doc) => `${url}/${doc.slug}`, ''), // NOTE: 'slug' is a hypothetical field\n})\n```\n\n----------------------------------------\n\nTITLE: Manual Module Declaration for Payload Types - Payload CMS - TypeScript\nDESCRIPTION: This code manually declares a module augmentation for the 'payload' module, specifying that the exported 'GeneratedTypes' interface extends the custom 'Config' interface from your generated types. This is necessary if you disable the automatic 'declare' pattern, ensuring type recognition within Payload's type system. The 'Config' import must reference your generated types file.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/generating-types.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Config } from './payload-types'\n\ndeclare module 'payload' {\n  export interface GeneratedTypes extends Config {}\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Schema Before Initialization with Payload Postgres Adapter (TypeScript)\nDESCRIPTION: This snippet leverages the beforeSchemaInit hook from the Payload CMS Postgres adapter to add custom tables to the database schema before initialization. It imports Drizzle schema utilities and extends the schema object by adding a new table ('added_table') with a serial primary key column. This allows users to preserve or introduce tables that are not managed through Payload's built-in configuration. Dependencies include @payloadcms/db-postgres and Drizzle's pg-core. The expected input is an initial schema object; the output is an augmented schema, with new tables merged in. Ensure that added tables do not conflict with Payload's managed collections.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/postgres.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { postgresAdapter } from '@payloadcms/db-postgres'\nimport {\n  integer,\n  pgTable,\n  serial,\n} from '@payloadcms/db-postgres/drizzle/pg-core'\n\npostgresAdapter({\n  beforeSchemaInit: [\n    ({ schema, adapter }) => {\n      return {\n        ...schema,\n        tables: {\n          ...schema.tables,\n          addedTable: pgTable('added_table', {\n            id: serial('id').notNull(),\n          }),\n        },\n      }\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Vercel-Optimized Postgres Adapter in Payload CMS (TypeScript)\nDESCRIPTION: This snippet illustrates how to configure Payload CMS with the @payloadcms/db-vercel-postgres adapter, optimized for deployment on Vercel. It automatically uses process.env.POSTGRES_URL if no options are provided and can optionally receive advanced pool configuration matching @vercel/postgres requirements. The example shows two ways to instantiate the adapter: with and without explicit configuration. Required dependencies are @payloadcms/db-vercel-postgres and optionally @vercel/postgres. Inputs are connection options, and the output is a Payload CMS instance configured for Vercel Postgres. Note: If pointing to a local database, the adapter switches to use the pg module by default.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/postgres.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { vercelPostgresAdapter } from '@payloadcms/db-vercel-postgres'\n\nexport default buildConfig({\n  // Automatically uses proces.env.POSTGRES_URL if no options are provided.\n  db: vercelPostgresAdapter(),\n  // Optionally, can accept the same options as the @vercel/postgres package.\n  db: vercelPostgresAdapter({\n    pool: {\n      connectionString: process.env.DATABASE_URL,\n    },\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Generating Drizzle ORM Schema for Payload CMS (Shell)\nDESCRIPTION: This single-line shell command generates a Drizzle-compatible schema file for usage with Payload CMS. It is a required step to ensure type-safety when accessing Drizzle APIs within Payload. This command should be run in a project terminal. The generated schema is used for strongly typed queries and is necessary before using custom table/relation types in Drizzle. Prerequisite: Payload CLI and a valid Payload config.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/postgres.mdx#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpx payload generate:db-schema\n```\n\n----------------------------------------\n\nTITLE: Extending Schema via beforeSchemaInit Hook in PayloadCMS (TypeScript)\nDESCRIPTION: Shows how to use the `beforeSchemaInit` hook in the SQLite adapter to inject custom tables into the Drizzle schema before Payload completes initialization. This technique allows tables unmanaged by Payload to coexist, which is crucial for legacy database support or advanced customizations. Depends on import of table constructors from the drizzle/sqlite-core, and expects to be integrated in the PayloadCMS config under the adapter's `beforeSchemaInit` option.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/sqlite.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { sqliteAdapter } from '@payloadcms/db-sqlite'\nimport { integer, sqliteTable } from '@payloadcms/db-sqlite/drizzle/sqlite-core'\n\nsqliteAdapter({\n  beforeSchemaInit: [\n    ({ schema, adapter }) => {\n      return {\n        ...schema,\n        tables: {\n          ...schema.tables,\n          addedTable: sqliteTable('added_table', {\n            id: integer('id').primaryKey({ autoIncrement: true }),\n          }),\n        },\n      }\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Verifying User Email with a GraphQL Mutation\nDESCRIPTION: Example GraphQL mutation `verifyEmail[collection-singular-label]` (replace with actual label, e.g., `verifyEmailUser`) used to verify a user's email address. It requires passing the unique verification token associated with the user.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_12\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  verifyEmail[collection-singular-label](token: \"TOKEN_HERE\")\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Root-Level Metadata in Payload Admin Panel (TypeScript)\nDESCRIPTION: Configures root-level metadata for all admin panel pages by setting the 'admin.meta' key in the Payload config object. This snippet sets global properties like title, description, and favicon via an array of icon objects. Inputs include any Next.js supported metadata fields, and outputs alter how the admin panel appears in the browser and when shared. Depends on Payload's configuration and is expected to be used in a TypeScript-based config file.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/metadata.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  // ...\n  admin: {\n    // highlight-start\n    meta: {\n    // highlight-end\n      title: 'My Admin Panel',\n      description: 'The best admin panel in the world',\n      icons: [\n        {\n          rel: 'icon',\n          type: 'image/png',\n          url: '/favicon.png',\n        },\n      ],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Login Server Action in TypeScript\nDESCRIPTION: Defines a Next.js server action (`loginAction`) that wraps the Payload `login` function. It accepts user credentials (email, password), imports the Payload config, calls the `login` function, and handles potential errors. This server action pattern is necessary because the Payload config cannot be directly imported or used in client components.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n'use server'\n\nimport { login } from '@payloadcms/next/auth'\nimport config from '@payload-config'\n\nexport async function loginAction({\n  email,\n  password,\n}: {\n  email: string\n  password: string\n}) {\n  try {\n    const result = await login({\n      collection: 'users', // The user collection slug\n      config, // Payload config object\n      email, // User's email\n      password, // User's password\n    })\n    return result\n  } catch (error) {\n    throw new Error(\n      `Login failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    )\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Formulating a REST API Query String\nDESCRIPTION: Shows the basic structure of a URL query string for filtering data via Payload's REST API. This example targets the '/api/posts' endpoint and filters for documents where the 'color' field equals 'mint' by encoding the `where` clause and operator directly in the URL parameters.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/overview.mdx#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nhttps://localhost:3000/api/posts?where[color][equals]=mint\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload Script in package.json (JSON)\nDESCRIPTION: Defines an npm script named `payload` within the `scripts` section of a `package.json` file. This script uses `cross-env` to set the `PAYLOAD_CONFIG_PATH` environment variable before executing the Payload CLI, ensuring the CLI uses the correct configuration file (`src/payload.config.ts` in this example). It's a prerequisite for running migration commands like `npm run payload migrate`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"payload\": \"cross-env PAYLOAD_CONFIG_PATH=src/payload.config.ts payload\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Polymorphic HasMany Relationship Field in PayloadCMS (TypeScript)\nDESCRIPTION: This snippet shows how to define a polymorphic relationship field named 'owners' with hasMany enabled in a PayloadCMS collection schema using TypeScript. The relationship is set up to allow multiple related documents from either the 'users' or 'organizations' collection. This field is required and is stored as an array of objects in the resulting documents. Dependencies: PayloadCMS. Key parameters: 'relationTo' (array of collection slugs), 'hasMany' (true), 'required' (true).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'owners', // required\n      type: 'relationship', // required\n      relationTo: ['users', 'organizations'], // required\n      hasMany: true,\n      required: true,\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Collection Access Control with Multi Tenant Plugin (TypeScript)\nDESCRIPTION: Illustrates how to customize read access control for a collection ('media') within a Payload configuration using the Multi Tenant Plugin. It disables the default tenant-based access control (`useTenantAccess: false`) for the 'media' collection and implements custom logic using the `getTenantAccess` utility combined with a custom condition (checking an `isShared` flag) to allow access either based on tenant association or if the document is marked as shared.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-multi-tenant/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// File: payload.config.ts\n\nimport { buildConfig } from 'payload'\nimport { multiTenantPlugin } from '@payloadcms/plugin-multi-tenant'\nimport { getTenantAccess } from '@payloadcms/plugin-multi-tenant/utilities'\nimport { Config as ConfigTypes } from './payload-types'\n\n// Add the plugin to your payload config\nexport default buildConfig({\n  plugins: [\n    multiTenantPlugin<ConfigTypes>({\n      collections: {\n        media: {\n          useTenantAccess: false,\n        },\n      },\n    }),\n  ],\n  collections: [\n    {\n      slug: 'media',\n      fields: [\n        {\n          name: 'isShared',\n          type: 'checkbox',\n          defaultValue: false,\n          // you likely want to set access control on fields like this\n          // to prevent just any user from modifying it\n        },\n      ],\n      access: {\n        read: ({ req, doc }) => {\n          if (!req.user) return false\n\n          const whereConstraint = {\n            or: [\n              {\n                isShared: {\n                  equals: true,\n                },\n              },\n            ],\n          }\n\n          const tenantAccessResult = getTenantAccess({ user: req.user })\n\n          if (tenantAccessResult) {\n            whereConstraint.or.push(tenantAccessResult)\n          }\n\n          return whereConstraint\n        },\n      },\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Setting a Dynamic Default Value Function for a Payload Field (TypeScript)\nDESCRIPTION: This code illustrates defining a dynamic default value for a Payload field by assigning a function to the `defaultValue` property in the `Field` configuration. The function receives context parameters like `user`, `locale`, and `req`, allowing it to return a computed default value based on the current context (e.g., user details, localization).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nconst translation: {\n  en: 'Written by'\n  es: 'Escrito por'\n}\n\nexport const myField: Field = {\n  name: 'attribution',\n  type: 'text',\n  // highlight-start\n  defaultValue: ({ user, locale, req }) =>\n    `${translation[locale]} ${user.name}`,\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring One-to-One Relationship Field - PayloadCMS - TypeScript\nDESCRIPTION: This configuration defines a simple relationship field within a collection using hasMany: false and a single collection ('users') as the relationTo target. The resulting field enables the document to reference a single user by their ObjectID, with type safety and validation handled by Payload. The field definition is placed in the fields array of a collection config and requires no external libraries beyond Payload.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'owner', // required\n      type: 'relationship', // required\n      relationTo: 'users', // required\n      hasMany: false,\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Authentication Options in Payload Collection - TypeScript\nDESCRIPTION: Shows how to configure advanced authentication options within a Payload collection by providing an 'auth' object in the configuration. Options include token expiration, email verification, and login attempt restrictions. Payload CMS and TypeScript are required. The object supports more properties for further customization as documented in Payload docs.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/overview.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\\n\\nexport const Admins: CollectionConfig = {\\n  // ...\\n  // highlight-start\\n  auth: {\\n    tokenExpiration: 7200, // How many seconds to keep the user logged in\\n    verify: true, // Require email verification before being allowed to authenticate\\n    maxLoginAttempts: 5, // Automatically lock a user out after X amount of failed logins\\n    lockTime: 600 * 1000, // Time period to allow the max login attempts\\n    // More options are available\\n  },\\n  // highlight-end\\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing the Dashboard View in Payload Config (TypeScript)\nDESCRIPTION: This snippet demonstrates how to replace the default Dashboard view in the Payload CMS admin panel with a custom React component. It involves modifying the `admin.components.views` object within the Payload configuration (`buildConfig`) to specify the path to the custom component for the `dashboard` key.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-views.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    components: {\n      views: {\n        // highlight-start\n        dashboard: {\n          Component: '/path/to/MyCustomDashboard',\n        },\n        // highlight-end\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Document Edit View - Payload CMS TypeScript\nDESCRIPTION: This TypeScript snippet shows how to override or add custom views for a Collection or Global document in Payload CMS by modifying the admin.components.views.edit property of a CollectionConfig. The example demonstrates setting the default Edit View to a custom React component and documents other replaceable views such as root, api, versions, version, and livePreview. Dependencies include Payload CMS and a custom edit component located at the provided import path. Required input is a valid CollectionConfig object, and outputs will affect the Payload CMS admin UI rendering.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/document-views.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollectionOrGlobalConfig: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      views: {\n        // highlight-start\n        edit: {\n          default: {\n            Component: '/path/to/MyCustomEditView',\n          },\n          // Other options include:\n          // - root\n          // - api\n          // - versions\n          // - version\n          // - livePreview\n          // - [key: string]\n          // See below for more details\n        },\n        // highlight-end\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Page Data in NextJS with getStaticProps - TypeScript\nDESCRIPTION: This snippet defines a getStaticProps function for NextJS to fetch page data based on a dynamic slug parameter. It makes a fetch request to the Payload CMS API, retrieves the relevant document, and prepares the props (including the document data, collection name, and labels) to be passed to the React component. Requires TypeScript, NextJS, and access to the Payload CMS REST API; expects slug as a routing parameter and returns the required props for admin bar configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/admin-bar/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport const getStaticProps = async ({ params: { slug } }) => {\n  const props = {}\n\n  const pageReq = await fetch(\n    `https://cms.website.com/api/pages?where[slug][equals]=${slug}&depth=1`,\n  )\n  const pageData = await pageReq.json()\n\n  if (pageReq.ok) {\n    const { docs } = pageData\n    const [doc] = docs\n\n    props = {\n      ...doc,\n      collection: 'pages',\n      collectionLabels: {\n        singular: 'page',\n        plural: 'pages',\n      },\n    }\n  }\n\n  return props\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Data Between Payload Hooks using Context (TypeScript)\nDESCRIPTION: Demonstrates how to fetch data in a `beforeChange` hook, store it in the `req.context` object, and then access that same data in a subsequent `afterChange` hook without needing to fetch it again. This optimizes performance by avoiding redundant API calls.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/context.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nconst Customer: CollectionConfig = {\n  slug: 'customers',\n  hooks: {\n    beforeChange: [\n      async ({ context, data }) => {\n        // assign the customerData to context for use later\n        context.customerData = await fetchCustomerData(data.customerID)\n        return {\n          ...data,\n          // some data we use here\n          name: context.customerData.name,\n        }\n      },\n    ],\n    afterChange: [\n      async ({ context, doc, req }) => {\n        // use context.customerData without needing to fetch it again\n        if (context.customerData.contacted === false) {\n          createTodo('Call Customer', context.customerData)\n        }\n      },\n    ],\n  },\n  fields: [\n    /* ... */\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Authentication in Payload Collection - TypeScript\nDESCRIPTION: Demonstrates how to enable authentication for a specific collection in Payload CMS by setting the 'auth' property to true in the CollectionConfig object. This enables default authentication workflows (login, registration, password recovery) for the collection. Requires Payload CMS and the relevant version of TypeScript. The collection configuration must be exported for Payload's runtime to pick up the changes.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/overview.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\\n\\nexport const Users: CollectionConfig = {\\n  // ...\\n  auth: true, // highlight-line\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an afterChange Hook for Payload CMS Global - TypeScript\nDESCRIPTION: This TypeScript code creates an 'afterChange' hook that runs after a global document is updated in Payload CMS. It receives the post-change document, previous version, and the request context, typically used for triggering side effects such as cache invalidation or external synchronization. It imports the appropriate type from 'payload' and returns the (possibly modified) data. Developers should ensure error handling for any side effects performed inside the hook.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/globals.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalAfterChangeHook } from 'payload'\n\nconst afterChangeHook: GlobalAfterChangeHook = async ({\n  doc,\n  previousDoc,\n  req,\n}) => {\n  return data\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Localization for a Field (JavaScript)\nDESCRIPTION: Shows how to enable localization for an individual field within a Payload collection schema by adding the `localized: true` property. Dependencies: Used within the fields array in a Payload collection. Key parameters: `name` (field identifier), `type` (field data type), and `localized` (enables locale-specific storage). Input: collection schema object; output: field data is stored and managed per enabled locale. Limitation: Changing this property on existing data will change data structure and may lead to loss of values.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/localization.mdx#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\n{\n  name: 'title',\n  type: 'text',\n  // highlight-start\n  localized: true,\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Payload CMS Array Field in TypeScript\nDESCRIPTION: This snippet defines a Payload CMS collection configuration (`ExampleCollection`) featuring an Array Field named `slider`. It configures properties like `label`, row count limits (`minRows`, `maxRows`), an optional TypeScript interface name (`interfaceName`), custom singular/plural labels, and specifies the nested fields (`title`, `image`, `caption`) contained within each array row. The `image` field is an upload type related to the `media` collection and is marked as required.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/array.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'slider', // required\n      type: 'array', // required\n      label: 'Image Slider',\n      minRows: 2,\n      maxRows: 10,\n      interfaceName: 'CardSlider', // optional\n      labels: {\n        singular: 'Slide',\n        plural: 'Slides',\n      },\n      fields: [\n        // required\n        {\n          name: 'title',\n          type: 'text',\n        },\n        {\n          name: 'image',\n          type: 'upload',\n          relationTo: 'media',\n          required: true,\n        },\n        {\n          name: 'caption',\n          type: 'text',\n        },\n      ],\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Polymorphic (Dynamic) One-to-One Relationship Field - PayloadCMS - TypeScript\nDESCRIPTION: This snippet demonstrates setting up a polymorphic one-to-one relationship field, where relationTo accepts multiple collection slugs. The field can reference documents from either 'users' or 'organizations'. The field configuration is defined in a collection config's fields array and requires Payload's type ecosystem.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'owner', // required\n      type: 'relationship', // required\n      relationTo: ['users', 'organizations'], // required\n      hasMany: false,\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Invoking Authenticate Server Function from React Client Component (TypeScript)\nDESCRIPTION: This React client component imports and calls the server-side 'authenticateUser' function to check authentication status when a button is clicked. It maintains local state to display the returned authentication result, which is shown as a paragraph in the UI. The component expects the server function to return a message and gracefully handles update of the user-facing state.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n\"'use client';\\n\\nimport React, { useState } from 'react';\\n\\nimport { authenticateUser } from '../server/actions'; // Import the server function\\n\\nexport const AuthComponent: React.FC = () => {\\n  const [userInfo, setUserInfo] = useState<string>('');\\n\\n\\n  return (\\n    <React.Fragment>\\n      <p>{userInfo}</p>\\n\\n      <button\\n        onClick={async () => {\\n          // Call the server function to authenticate the user\\n          const result = await authenticateUser();\\n          setUserInfo(result.hello);\\n        }}\\n        type=\\\"button\\\"\\n      >\\n        Check Authentication\\n      </button>\\n    </React.Fragment>\\n  );\\n};\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Advanced Username Login Options - TypeScript\nDESCRIPTION: Illustrates providing an object to the 'loginWithUsername' property for more granular control of username login behavior. 'allowEmailLogin' enables login via both email and username, while 'requireEmail' makes the email field mandatory upon user creation. Used for flexible user authentication requirements in Payload collections.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/overview.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\\n  slug: 'customers',\\n  auth: {\\n    loginWithUsername: {\\n      allowEmailLogin: true, // default: false\\n      requireEmail: false, // default: false\\n    },\\n  },\\n}\n```\n\n----------------------------------------\n\nTITLE: Mutating Payload Raw SQL Schema before Initialization - TypeScript\nDESCRIPTION: This code shows how to use the beforeSchemaInit hook on sqliteAdapter to directly mutate the internal Payload raw SQL schema before it is used to generate the Drizzle schema in TypeScript. It demonstrates adding a new table (myTable), a new column (customColumn) to an existing table (posts), and a unique index (customColumnIdx) on that column by mutating adapter.rawTables. Useful for structural changes that need to be present in the Drizzle schema output. Dependencies include PayloadCMS, the SQLite adapter, and an understanding of the Payload rawTables schema format.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/sqlite.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { sqliteAdapter } from '@payloadcms/db-sqlite'\n\nsqliteAdapter({\n  beforeSchemaInit: [\n    ({ schema, adapter }) => {\n      // Add a new table\n      adapter.rawTables.myTable = {\n        name: 'my_table',\n        columns: {\n          my_id: {\n            name: 'my_id',\n            type: 'integer',\n            primaryKey: true,\n          },\n        },\n      }\n\n      // Add a new column to generated by Payload table:\n      adapter.rawTables.posts.columns.customColumn = {\n        name: 'custom_column',\n        // Note that Payload SQL doesn't support everything that Drizzle does.\n        type: 'integer',\n        notNull: true,\n      }\n      // Add a new index to generated by Payload table:\n      adapter.rawTables.posts.indexes.customColumnIdx = {\n        name: 'custom_column_idx',\n        unique: true,\n        on: ['custom_column'],\n      }\n\n      return schema\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Admin Options for a Payload Field (TypeScript)\nDESCRIPTION: This snippet demonstrates how to add admin-specific configurations to a Payload field using the `admin` property. While shown in the context of a Collapsible field, this pattern applies to other field types as well. Requires the `Field` type from the `payload` package.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/collapsible.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyCollapsibleField: Field = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Translations to Payload CMS Collection Labels and Fields\nDESCRIPTION: Demonstrates providing multi-language support directly within a Payload CMS Collection configuration. Translatable properties like `labels` (singular/plural), `admin.group`, field `label`, and field `admin.placeholder` accept objects keyed by language codes (e.g., `en`, `es`) to define the text for each supported language.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/i18n.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Articles: CollectionConfig = {\n  slug: 'articles',\n  labels: {\n    singular: {\n      // highlight-start\n      en: 'Article',\n      es: 'Artículo',\n      // highlight-end\n    },\n    plural: {\n      // highlight-start\n      en: 'Articles',\n      es: 'Artículos',\n      // highlight-end\n    },\n  },\n  admin: {\n    group: {\n      // highlight-start\n      en: 'Content',\n      es: 'Contenido',\n      // highlight-end\n    },\n  },\n  fields: [\n    {\n      name: 'title',\n      type: 'text',\n      label: {\n        // highlight-start\n        en: 'Title',\n        es: 'Título',\n        // highlight-end\n      },\n      admin: {\n        placeholder: {\n          // highlight-start\n          en: 'Enter title',\n          es: 'Introduce el título',\n          // highlight-end\n        },\n      },\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing View-Level Metadata for Admin Custom Views (TypeScript)\nDESCRIPTION: Configures metadata for a specific view under the admin panel, allowing for distinct title and description via the 'meta' property of the custom view entry. Sits inside the 'admin.views' object, isolates overrides from root, collection, or global configs, and affects only the rendered custom view. Used for advanced multi-view admin setups.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/metadata.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  // ...\n  admin: {\n    views: {\n      dashboard: {\n        // highlight-start\n        meta: {\n        // highlight-end\n          title: 'My Dashboard',\n          description: 'The best dashboard in the world',\n        }\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Migration Structure in TypeScript\nDESCRIPTION: Illustrates the basic structure of a Payload migration file in TypeScript. It imports `MigrateUpArgs` and `MigrateDownArgs` from the relevant database adapter package. It exports two asynchronous functions: `up` for applying changes and `down` for reverting them. Both functions receive arguments like `payload` (Payload API instance) and `req` (request object containing the transaction context) to interact with the database.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { MigrateUpArgs, MigrateDownArgs } from '@payloadcms/your-db-adapter'\n\nexport async function up({ payload, req }: MigrateUpArgs): Promise<void> {\n  // Perform changes to your database here.\n  // You have access to `payload` as an argument, and\n  // everything is done in TypeScript.\n}\n\nexport async function down({ payload, req }: MigrateDownArgs): Promise<void> {\n  // Do whatever you need to revert changes if the `up` function fails\n}\n```\n\n----------------------------------------\n\nTITLE: Creating User with Access Control Payload TypeScript\nDESCRIPTION: This snippet shows how to enforce access control when creating a user through the Payload CMS Local API. It requires that you pass both the 'overrideAccess: false' option and an authenticated 'user' object in the request. This configuration ensures the system checks the user's permissions before creating the document. Dependencies include a valid Payload instance and an authenticated user context. The snippet demonstrates secure creation by preventing unauthorized access. Inputs are user authentication and data fields; output is the new user document if access is allowed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/access-control.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst authedCreate = await payload.create({\n  collection: 'users',\n  overrideAccess: false, // This ensures access control will be applied\n  user, // Pass the authenticated user to check permissions\n  data: {\n    email: 'test@test.com',\n    password: 'test',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing Textarea Admin Field - Payload CMS TypeScript\nDESCRIPTION: This TypeScript snippet illustrates how to add an 'admin' configuration object to a Textarea Field, allowing customization of its appearance and behavior in the Payload CMS Admin Panel. The 'admin' property can include options such as placeholder, autoComplete, rows, and rtl, offering flexibility for UI/UX requirements. Dependencies include the 'payload' package and integration into a collection or global field array.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/textarea.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Field } from 'payload'\\n\\nexport const MyTextareaField: Field = {\\n  // ...\\n  admin: {\\n    // highlight-line\\n    // ...\\n  },\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Root Lexical Editor in Payload CMS (TypeScript)\nDESCRIPTION: Illustrates configuring the Lexical editor as the default editor by passing the lexicalEditor function in the root Payload config. Dependencies include the @payloadcms/richtext-lexical package and Payload's buildConfig function. Key parameters include collections (list of collections) and the editor property (receives lexicalEditor with options). Outputs a fully configured Payload config with Lexical as the primary editor.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/overview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { lexicalEditor } from '@payloadcms/richtext-lexical'\n\nexport default buildConfig({\n  collections: [\n    // your collections here\n  ],\n  // Pass the Lexical editor to the root config\n  editor: lexicalEditor({}),\n})\n```\n\n----------------------------------------\n\nTITLE: Incorrectly Updating Document in Payload `afterChange` Hook (TypeScript)\nDESCRIPTION: Illustrates a common pitfall where calling `req.payload.update` on the same collection within an `afterChange` hook creates an infinite loop. This happens because the update triggers the same hook again recursively.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/context.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nconst Customer: CollectionConfig = {\n  slug: 'customers',\n  hooks: {\n    afterChange: [\n      async ({ doc, req }) => {\n        await req.payload.update({\n          // DANGER: updating the same slug as the collection in an afterChange will create an infinite loop!\n          collection: 'customers',\n          id: doc.id,\n          data: {\n            ...(await fetchCustomerData(data.customerID)),\n          },\n        })\n      },\n    ],\n  },\n  fields: [\n    /* ... */\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Edit View Components for a Collection (TypeScript)\nDESCRIPTION: Demonstrates how to specify custom components for specific parts of the Edit View within a Collection's configuration. The `admin.components.edit` object is used to override elements like buttons or add components.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      // highlight-start\n      edit: {\n        // ...\n      },\n      // highlight-end\n    },\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Payload and Essential Packages - Bash\nDESCRIPTION: Installs the primary Payload CMS package along with its Next.js integration and supportive dependencies including rich text editor, sharp for image processing, and graphql. This snippet assumes the use of pnpm; users should swap out for their preferred package manager. Outputs: installs specified packages into node_modules. Limitations: must be run inside the target project directory and may require use of legacy peer deps with npm.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/installation.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm i payload @payloadcms/next @payloadcms/richtext-lexical sharp graphql\n```\n\n----------------------------------------\n\nTITLE: Querying Authenticated User Information via HTTP API - TypeScript\nDESCRIPTION: This TypeScript code snippet illustrates using the Fetch API to query current user information from a PayloadCMS REST endpoint. The request is sent as a GET with credentials included and 'Content-Type: application/json' header. It requires a running Payload server with users/authentication enabled and properly set up HTTP endpoints. The primary input is the fetch request to '/api/users/me' and the expected output is the authenticated user's data in JSON form, subject to authentication state. This approach provides server- or client-side integration via HTTP.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/auth/README.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nawait fetch('/api/users/me', {\n  method: 'GET',\n  credentials: 'include',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n})\n\n```\n\n----------------------------------------\n\nTITLE: Fetching Payload Page with Optional Draft Version (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates fetching page data from a Payload CMS API endpoint. It dynamically constructs the request URL, adding the `draft=true` query parameter if the `preview` flag is set. When fetching drafts (`preview` is true), it includes an `Authorization` header with a JWT token (`payloadToken`) to authenticate the request and bypass access controls that might restrict draft content visibility.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/draft-preview/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst preview = true // set this based on your own front-end environment (see `Preview Mode` below)\nconst pageSlug = 'example-page' // same here\nconst searchParams = `?where[slug][equals]=${pageSlug}&depth=1${preview ? `&draft=true` : ''}`\n\n// when previewing, send the payload token to bypass draft access control\nconst pageReq = await fetch(`${process.env.NEXT_PUBLIC_PAYLOAD_URL}/api/pages${searchParams}`, {\n  headers: {\n    ...(preview\n      ? {\n          Authorization: `JWT ${payloadToken}`,\n        }\n      : {}),\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Sorting by Multiple Fields in Payload Local API (TypeScript)\nDESCRIPTION: This snippet shows how to sort documents by multiple fields using the Payload Local API in TypeScript. It uses the `payload.find` method with the `sort` option set to an array `['priority', '-createdAt']`. This sorts the 'posts' collection first by 'priority' in ascending order, and then by 'createdAt' in descending order for documents with the same priority. Requires a Payload instance.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/sort.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Payload } from 'payload'\n\nconst getPosts = async (payload: Payload) => {\n  const posts = await payload.find({\n    collection: 'posts',\n    sort: ['priority', '-createdAt'], // highlight-line\n  })\n\n  return posts\n}\n```\n\n----------------------------------------\n\nTITLE: Logging In a User using Payload's Local API in TypeScript\nDESCRIPTION: Shows how to log in a user programmatically using Payload's Local API method `payload.login`. Requires specifying the collection slug and providing user credentials (email, password) in the `data` object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = await payload.login({\n  collection: 'collection-slug',\n  data: {\n    email: 'dev@payloadcms.com',\n    password: 'get-out',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Updating a Post on the Server with Payload Local API (TypeScript)\nDESCRIPTION: This server function updates a specific document in the 'posts' collection using Payload's Local API, requiring both the document ID and an object with new data. The function is wrapped with 'use server' and uses the 'getPayload' utility to retrieve the Payload instance. Errors are handled by throwing a new Error with a custom message. It returns the updated document object on success.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n\"'use server'\\n\\nimport { getPayload } from 'payload'\\nimport config from '@payload-config'\\n\\nexport async function updatePost(id, data) {\\n  const payload = await getPayload({ config })\\n\\n  try {\\n    const post = await payload.update({\\n      collection: 'posts',\\n      id, // the document id is required\\n      data,\\n    })\\n    return post\\n  } catch (error) {\\n    throw new Error(`Error updating post: ${error.message}`)\\n  }\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Integrating Payment Handling Logic into Form Plugin (TypeScript)\nDESCRIPTION: This snippet shows an example handlePayment hook that calculates the payment total (including dynamic price conditions) and can then process the payment with a third-party API. Depends on a properly structured form object with a payment field and requires getPaymentTotal utility. Enables advanced payment flows for form submissions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nformBuilderPlugin({\n  // ...\n  handlePayment: async ({ form, submissionData }) => {\n    // first calculate the price\n    const paymentField = form.fields?.find(\n      (field) => field.blockType === 'payment',\n    )\n    const price = getPaymentTotal({\n      basePrice: paymentField.basePrice,\n      priceConditions: paymentField.priceConditions,\n      fieldValues: submissionData,\n    })\n    // then asynchronously process the payment here\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Querying Nested Relational Fields in JavaScript\nDESCRIPTION: Illustrates how to query properties within related documents using dot notation (`'artists.featured'`). This example filters 'Song' documents based on whether the 'featured' property exists and is true within a related 'Artists' document. Requires the `Where` type from Payload.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/overview.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport type { Where } from 'payload'\n\nconst query: Where = {\n  'artists.featured': { // nested property name to filter on\n    exists: true, // operator to use and boolean value that needs to be true\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Settings in Payload Config (TypeScript)\nDESCRIPTION: Demonstrates how to configure TypeScript-specific settings within the Payload configuration object using the `typescript` property. This allows customization of type auto-generation and declaration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  typescript: {\n    // highlight-line\n    // ...\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Job Queues with Cron Schedules in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to set up job queues in Payload CMS with scheduled execution via the `autoRun` property in the configuration. It enables developers to define when and how many jobs to process, specify different queues, and even programmatically enable or disable the job runner. Dependencies include the Payload CMS environment and proper configuration with `buildConfig`. Inputs include cron schedule, job limit, queue name, and an async function for custom run conditions. Output is a configured job runner that automatically processes queued jobs per schedule.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/queues.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default buildConfig({\n  // Other configurations...\n  jobs: {\n    tasks: [\n      // your tasks here\n    ],\n    // autoRun can optionally be a function that receives `payload` as an argument\n    autoRun: [\n      {\n        cron: '0 * * * *', // every hour at minute 0\n        limit: 100, // limit jobs to process each run\n        queue: 'hourly', // name of the queue\n      },\n      // add as many cron jobs as you want\n    ],\n    shouldAutoRun: async (payload) => {\n      // Tell Payload if it should run jobs or not.\n      // This function will be invoked each time Payload goes to pick up and run jobs.\n      // If this function ever returns false, the cron schedule will be stopped.\n      return true\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Converting Internal Links in Payload Lexical Richtext to JSX\nDESCRIPTION: This example shows how to correctly render internal links within Lexical richtext by providing an `internalDocToHref` function to the `LinkJSXConverter`. This function resolves the document reference (`relationTo`, `value.slug`) into a URL string based on the related collection. The custom link converter is then added to the `jsxConverters` passed to the `RichText` component. Dependencies include `react` and `@payloadcms/richtext-lexical/react`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-jsx.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport type {\n  DefaultNodeTypes,\n  SerializedLinkNode,\n} from '@payloadcms/richtext-lexical'\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\n\nimport {\n  type JSXConvertersFunction,\n  LinkJSXConverter,\n  RichText,\n} from '@payloadcms/richtext-lexical/react'\nimport React from 'react'\n\nconst internalDocToHref = ({ linkNode }: { linkNode: SerializedLinkNode }) => {\n  const { relationTo, value } = linkNode.fields.doc!\n  if (typeof value !== 'object') {\n    throw new Error('Expected value to be an object')\n  }\n  const slug = value.slug\n\n  switch (relationTo) {\n    case 'posts':\n      return `/posts/${slug}`\n    case 'categories':\n      return `/category/${slug}`\n    case 'pages':\n      return `/${slug}`\n    default:\n      return `/${relationTo}/${slug}`\n  }\n}\n\nconst jsxConverters: JSXConvertersFunction<DefaultNodeTypes> = ({\n  defaultConverters,\n}) => ({\n  ...defaultConverters,\n  ...LinkJSXConverter({ internalDocToHref }),\n})\n\nexport const MyComponent: React.FC<{\n  lexicalData: SerializedEditorState\n}> = ({ lexicalData }) => {\n  return <RichText converters={jsxConverters} data={lexicalData} />\n}\n```\n\n----------------------------------------\n\nTITLE: Authenticating User Accounts Using Payload Local API in Next.js - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates using the Payload Local API within a Next.js server route to authenticate and authorize users for access to account pages. The dependencies are 'payload' and 'next/headers.js', requiring a valid Payload config and the ability to retrieve request headers. Inputs include the Next.js search parameters and incoming request headers, and the output is either redirected to the login page (if unauthenticated) or proceeds to the protected route. Limitations include the need for server-side environment and proper configuration of both Next.js and Payload.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/auth/README.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { headers as getHeaders } from 'next/headers.js'\nimport { getPayload } from 'payload'\nimport config from '../../payload.config'\n\nexport default async function AccountPage({ searchParams }) {\n  const headers = await getHeaders()\n  const payload = await getPayload({ config: configPromise })\n  const { permissions, user } = await payload.auth({ headers })\n\n  if (!user) {\n    redirect(\n      `/login?error=${encodeURIComponent('You must be logged in to access your account.')}&redirect=/account`,\n    )\n  }\n\n  return ...\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Read Versions Access Control in Payload CMS (TypeScript)\nDESCRIPTION: Defines a `readVersions` access control function for a version-enabled Payload CMS Collection. This function checks if the currently logged-in user (`req.user`) is authorized to view the historical versions of documents within that specific collection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionWithVersionsAccess: CollectionConfig = {\n  // ...\n  access: {\n    // highlight-start\n    readVersions: ({ req: { user } }) => {\n      return Boolean(user)\n    },\n    // highlight-end\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Document via Payload REST API\nDESCRIPTION: Performs a POST request to create a new document within a specific collection. Requires necessary authentication headers and a request body containing the document data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_3\n\nLANGUAGE: HTTP\nCODE:\n```\nPOST /api/{collection-slug}\n```\n\n----------------------------------------\n\nTITLE: Configuring Localization in Payload CMS (TypeScript)\nDESCRIPTION: Demonstrates how to enable localization in the Payload Config file using the `localization` property. This example shows the minimal setup for activating localization, which is required for enabling multi-language content management. It requires that the Payload dependency is installed and uses the config builder from Payload. Inputs: none directly; this config is consumed by Payload at runtime. Output: enables localization feature within the CMS. Limitation: does not specify locales or defaults; this is the template for adding the full config.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/localization.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  localization: {\n    // highlight-line\n    // ...\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Access Operations for Collections - Payload CMS - TypeScript\nDESCRIPTION: Shows a CollectionConfig 'access' block explicitly implementing operation handlers (create, read, update, delete, admin, unlock, readVersions) for Payload CMS access control. Each function enables fine-grained permissions per action. This template expects developer-supplied logic for each function and must be used in context of an authenticated Payload CMS backend.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload';\n\nexport const CollectionWithAccessControl: CollectionConfig = {\n  // ...\n  // highlight-start\n  access: {\n    create: () => {...},\n    read: () => {...},\n    update: () => {...},\n    delete: () => {...},\n\n    // Auth-enabled Collections only\n    admin: () => {...},\n    unlock: () => {...},\n\n    // Version-enabled Collections only\n    readVersions: () => {...},\n  },\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up TypeScript Path Aliases for Payload Config - JSON\nDESCRIPTION: Configures the TypeScript compiler to recognize '@payload-config' as an alias pointing to your 'payload.config.ts' file. Add this snippet to your 'tsconfig.json' in the root of your project. No external dependencies. Input: desired alias and path. Output: enables IDE and compilation time resolution for imports of '@payload-config' throughout the codebase.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/installation.mdx#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@payload-config\": [\"./payload.config.ts\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing a Row in an Array Field - PayloadCMS useForm - TypeScript/TSX\nDESCRIPTION: This code illustrates using the replaceFieldRow method from useForm to replace a specific row in an array or block field in the PayloadCMS admin UI. The replaceFieldRow method accepts parameters such as path, rowIndex, subFieldState (the new data for the row), and optional blockType. Inputs include target field info and replacement row data. The configuration snippet demonstrates how to reference a custom field manager inside a Payload collection definition. Requires @payloadcms/ui and React.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from \"@payloadcms/ui\"\n\nexport const CustomArrayManager = () => {\n  const { replaceFieldRow } = useForm()\n\nreturn (\n\n<button\n  type=\"button\"\n  onClick={() => {\n    replaceFieldRow({\n      path: 'arrayField',\n      schemaPath: 'arrayField',\n      rowIndex: 0, // optionally specify the index to add the row at\n      subFieldState: {\n        textField: {\n          initialValue: 'Updated text',\n          valid: true,\n          value: 'Upddated text',\n        },\n      },\n      // blockType: \"yourBlockSlug\",\n      // ^ if managing a block array, you need to specify the block type\n    })\n  }}\n>\n  Replace Row\n</button>\n) }\n```\n\nLANGUAGE: tsx\nCODE:\n```\nconst ExampleCollection = {\nslug: \"example-collection\",\nfields: [\n{\nname: \"arrayField\",\ntype: \"array\",\nfields: [\n{\nname: \"textField\",\ntype: \"text\",\n},\n],\n},\n{\ntype: \"ui\",\nname: \"customArrayManager\",\nadmin: {\ncomponents: {\nField: '/path/to/CustomArrayManagerField',\n},\n},\n},\n],\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Text Field Admin Configuration in Payload CMS - TypeScript\nDESCRIPTION: This snippet shows how to enhance a Payload text field by specifying the 'admin' property in the field configuration using TypeScript. In addition to specifying the type, this allows customization of admin panel behavior and appearance. It requires importing the Field type from Payload. Outputs a field configuration object for use in a Payload definition. Ensure the 'admin' object is set to customize admin options such as placeholder text, autocomplete, and RTL support.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/text.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyTextField: Field = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Searchable Fields in Admin List View in PayloadCMS - TypeScript\nDESCRIPTION: Demonstrates how to specify which fields are searchable within a collection\\'s admin list view by assigning an array of field names to admin.listSearchableFields in the CollectionConfig. This requires the referenced fields to exist and be indexed for best search performance. Parameters include a string array of field identifiers; output is a collection configuration object with enhanced search capabilities.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/collections.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Posts: CollectionConfig = {\n  // ...\n  admin: {\n    // highlight-start\n    listSearchableFields: ['title', 'slug'],\n    // highlight-end\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Running Jobs Programmatically via Local API (TypeScript)\nDESCRIPTION: This TypeScript snippet covers invoking jobs programmatically using the Local API of Payload CMS. It demonstrates running all jobs, specifying queues and limits, filtering jobs with a where clause, and running single jobs by ID. Dependencies include the Payload CMS JS/TS SDK available on the server side. Input parameters vary and can include queue name, job limits, filters, and job IDs. Outputs are arrays of job execution results or a specific job's result.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/queues.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst results = await payload.jobs.run()\n\n// You can customize the queue name and limit by passing them as arguments:\nawait payload.jobs.run({ queue: 'nightly', limit: 100 })\n\n// You can provide a where clause to filter the jobs that should be run:\nawait payload.jobs.run({\n  where: { 'input.message': { equals: 'secret' } },\n})\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst results = await payload.jobs.runByID({\n  id: myJobID,\n})\n```\n\n----------------------------------------\n\nTITLE: Updating Project Structure for Custom Admin Route - PayloadCMS - Plaintext\nDESCRIPTION: Illustrates the necessary project directory structure when customizing root-level routes in PayloadCMS, such as mounting the Admin Panel at application root. This snippet is informational and should be reflected in the file system of the project. No dependencies. Directories 'app/', '(payload)/', and '[[...segments]]/' are listed, indicating where relevant route handlers or directories should be set up.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/overview.mdx#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\napp/\n├─ (payload)/\n├── [[...segments]]/\n├──── ...\n```\n\n----------------------------------------\n\nTITLE: Querying with Drizzle ORM via Payload CMS (TypeScript)\nDESCRIPTION: This code demonstrates how to perform advanced, type-safe queries against a Postgres database using Drizzle ORM re-exported through Payload CMS. It shows importing a generated table schema and Drizzle query utilities, then executing both a standard query and a filtered select statement combining multiple conditions. Dependencies: Payload initialized with Drizzle adapter, payload-generated-schema, and @payloadcms/db-postgres/drizzle. Inputs are the database connection and Drizzle query expressions; output is a Promise resolving to query results from the posts table. Note: The schema file must be generated beforehand.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/postgres.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { posts } from './payload-generated-schema'\n// To avoid installing Drizzle, you can import everything that drizzle has from our re-export path.\nimport { eq, sql, and } from '@payloadcms/db-postgres/drizzle'\n\n// Drizzle's Querying API: https://orm.drizzle.team/docs/rqb\nconst posts = await payload.db.drizzle.query.posts.findMany()\n// Drizzle's Select API https://orm.drizzle.team/docs/select\nconst result = await payload.db.drizzle\n  .select()\n  .from(posts)\n  .where(\n    and(eq(posts.id, 50), sql`lower(${posts.title}) = 'example post title'`),\n  )\n```\n\n----------------------------------------\n\nTITLE: Invoking Update Post Server Function from a React Client Component (TypeScript)\nDESCRIPTION: This client-side React component (UpdatePostForm) demonstrates calling the 'updatePost' server function, typically triggered by a button click. The component manages local state for output results, and on click, calls 'updatePost' with a hardcoded ID and new title, setting the UI feedback. It depends on the appropriate import of the server action and can be easily tailored for real-world IDs or forms. The output is shown as a string result to the user.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n\"'use client';\\n\\nimport React, { useState } from 'react';\\nimport { updatePost } from '../server/actions'; // import the server function\\n\\nexport const UpdatePostForm: React.FC = () => {\\n  const [result, setResult] = useState<string>('');\\n\\n  return (\\n    <>\\n      <p>{result}</p>\\n\\n      <button\\n        type=\\\"button\\\"\\n        onClick={async () => {\\n          // Call the server function to update the post\\n          const updatedPost = await updatePost('your-post-id-123', { title: 'Updated Post' });\\n          setResult('Post updated: ' + updatedPost.title);\\n        }}\\n      >\\n        Update Post\\n      </button>\\n    </>\\n  );\\n};\\n\"\n```\n\n----------------------------------------\n\nTITLE: Illustrating CSRF Attack Potential with Fetch in TypeScript\nDESCRIPTION: This TypeScript code snippet shows an example of a potential Cross-Site Request Forgery (CSRF) attack. A script on a malicious domain attempts to make an authenticated request to the target Payload application (`https://payload-finances.com/api/me`) using `fetch` with `credentials: 'include'`, leveraging the user's existing login cookie if CSRF protection is not properly configured.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/cookies.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// malicious-intent.com\n// makes an authenticated request as on your behalf\n\nconst maliciousRequest = await fetch(`https://payload-finances.com/api/me`, {\n  credentials: 'include',\n}).then((res) => await res.json())\n```\n```\n\n----------------------------------------\n\nTITLE: Setting the Name for a Payload Data Field (TypeScript)\nDESCRIPTION: This code snippet demonstrates setting the required `name` property for a Payload data field using the `Field` type. The `name` ('myField' in this example) serves as the key for storing and retrieving the field's value in the database and must be unique among sibling fields.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyField: Field = {\n  type: 'text',\n  name: 'myField', // highlight-line\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload CMS with MongoDB Adapter (TypeScript)\nDESCRIPTION: Demonstrates how to import and configure the official Payload MongoDB adapter using TypeScript. Dependencies include 'payload' and '@payloadcms/db-mongodb'. The 'mongooseAdapter' is initialized with a database URL taken from the DATABASE_URI environment variable and then passed to the Payload configuration. Inputs required are valid Payload configuration and a MongoDB connection URI. This enables Payload to use MongoDB as its database backend.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/db-mongodb/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { mongooseAdapter } from '@payloadcms/db-mongodb'\n\nexport default buildConfig({\n  db: mongooseAdapter({\n    url: process.env.DATABASE_URI,\n  }),\n  // ...rest of config\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Code Field Component for Payload BlocksFeature (TSX)\nDESCRIPTION: Provides the client-side React component (`Code`) for the custom 'Code' block example. It uses the `useFormFields` hook from `@payloadcms/ui` to access the selected language from a sibling field and renders a `@payloadcms/ui/CodeField` with the appropriate language setting derived from a mapping. Requires React, `@payloadcms/ui`, and access to the field configuration's language options.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport type { CodeFieldClient, CodeFieldClientProps } from 'payload'\n\nimport { CodeField, useFormFields } from '@payloadcms/ui'\nimport React, { useMemo } from 'react'\n\nimport { languages } from './yourFieldConfig'\n\nconst languageKeyToMonacoLanguageMap = {\n  plaintext: 'plaintext',\n  ts: 'typescript',\n  tsx: 'typescript',\n}\n\ntype Language = keyof typeof languageKeyToMonacoLanguageMap\n\nexport const Code: React.FC<CodeFieldClientProps> = ({\n  autoComplete,\n  field,\n  forceRender,\n  path,\n  permissions,\n  readOnly,\n  renderedBlocks,\n  schemaPath,\n  validate,\n}) => {\n  const languageField = useFormFields(([fields]) => fields['language'])\n\n  const language: Language =\n    (languageField?.value as Language) ||\n    (languageField?.initialValue as Language) ||\n    'ts'\n\n  const label = languages[language]\n\n  const props: CodeFieldClient = useMemo<CodeFieldClient>(\n    () => ({\n      ...field,\n      type: 'code',\n      admin: {\n        ...field.admin,\n        editorOptions: undefined,\n        language: languageKeyToMonacoLanguageMap[language] || language,\n      },\n      label,\n    }),\n    [field, language, label],\n  )\n\n  const key = `${field.name}-${language}-${label}`\n\n  return (\n    <CodeField\n      autoComplete={autoComplete}\n      field={props}\n      forceRender={forceRender}\n      key={key}\n      path={path}\n      permissions={permissions}\n      readOnly={readOnly}\n      renderedBlocks={renderedBlocks}\n      schemaPath={schemaPath}\n      validate={validate}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload Sync with Stripe Plugin (TypeScript)\nDESCRIPTION: This example shows how to configure the Payload CMS with the Stripe plugin for automatic two-way resource synchronization. It sets up plugin options for Stripe keys, webhook secrets, and a mapping between a Payload collection and a corresponding Stripe resource. Dependencies include Payload CMS, the '@payloadcms/plugin-stripe' package, required environment variables, and the 'buildConfig' utility. The output is a full Payload config export ready for use with all Stripe sync hooks and limitations on nested fields due to Stripe API constraints.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/stripe.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport stripePlugin from '@payloadcms/plugin-stripe'\n\nconst config = buildConfig({\n  plugins: [\n    stripePlugin({\n      stripeSecretKey: process.env.STRIPE_SECRET_KEY,\n      stripeWebhooksEndpointSecret: process.env.STRIPE_WEBHOOKS_ENDPOINT_SECRET,\n      sync: [\n        {\n          collection: 'customers',\n          stripeResourceType: 'customers',\n          stripeResourceTypeSingular: 'customer',\n          fields: [\n            {\n              fieldPath: 'name', // this is a field on your own Payload Config\n              stripeProperty: 'name', // use dot notation, if applicable\n            },\n          ],\n        },\n      ],\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Adding Actions to the Payload Admin Panel Header (TypeScript)\nDESCRIPTION: Illustrates the placement of a custom action component within the Admin Panel header by specifying its file path in the actions property inside admin.components in Payload's TypeScript buildConfig. Dependency is Payload CMS; each entry should be a path string to a React component. This allows arbitrary custom components to appear as header actions, such as buttons or widgets.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  admin: {\n    // highlight-start\n    components: {\n      actions: ['/path/to/your/component'],\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieving Payload Admin Client Config with useConfig in React (TypeScript)\nDESCRIPTION: Illustrates how to use useConfig from @payloadcms/ui to access the Payload CMS admin configuration within a React component. The config object contains global settings like the serverURL, and this pattern is suitable for UI display or logic that needs config context. Requires @payloadcms/ui and appropriate admin UI context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport { useConfig } from '@payloadcms/ui'\\n\\nconst MyComponent: React.FC = () => {\\n  // highlight-start\\n  const { config } = useConfig()\\n  // highlight-end\\n\\n  return <span>{config.serverURL}</span>\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Adding i18n Translations to a Custom Server Feature in Payload Lexical (TypeScript)\nDESCRIPTION: Shows how to add internationalization (i18n) support to a custom server-side Lexical feature using the `i18n` property within `createServerFeature`. Translations are provided for different locales (e.g., 'en', 'de') and are automatically scoped by the feature's key (`myFeature`), accessible via `lexical:myFeature:label`. Requires `@payloadcms/richtext-lexical`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { createServerFeature } from '@payloadcms/richtext-lexical'\n\nexport const MyFeature = createServerFeature({\n  feature: {\n    i18n: {\n      en: {\n        label: 'My Feature',\n      },\n      de: {\n        label: 'Mein Feature',\n      },\n    },\n  },\n  key: 'myFeature',\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Admin-level Account Route - PayloadCMS - TypeScript\nDESCRIPTION: Shows how to customize the user account page path within the PayloadCMS Admin Panel using the `admin.routes.account` property in the Payload configuration file. Requires the 'payload' package and uses the `buildConfig` function. Set the desired account path by updating the `routes` object within the `admin` configuration. Inputs are configuration properties edited in the config file; output is an updated admin-level route. No additional dependencies required.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/overview.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    routes: {\n      account: '/my-account', // highlight-line\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Collection Admin Options in Payload CMS (TypeScript)\nDESCRIPTION: Demonstrates the basic structure for defining admin-specific settings for a Payload CMS Collection. The `admin` property is added within the `CollectionConfig` object to hold various configuration options that customize the collection's behavior and appearance in the admin panel.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/collections.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Payload API Data Reactively with usePayloadAPI\nDESCRIPTION: This React component demonstrates fetching data from a specific Payload API endpoint (`/api/posts/123`) using the `usePayloadAPI` hook. It handles loading and error states (`isLoading`, `isError`) and displays the fetched data (`data.title`). It also includes a button that uses the `setParams` function returned by the hook to trigger a data refresh by updating a cache-busting parameter.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport { usePayloadAPI } from '@payloadcms/ui'\n\nconst MyComponent: React.FC = () => {\n  // Fetch data from a collection item using its ID\n  const [{ data, isError, isLoading }, { setParams }] = usePayloadAPI(\n    '/api/posts/123',\n    {\n      initialParams: { depth: 1 },\n    },\n  )\n\n  if (isLoading) return <p>Loading...</p>\n  if (isError) return <p>Error occurred while fetching data.</p>\n\n  return (\n    <div>\n      <h1>{data?.title}</h1>\n      <button onClick={() => setParams({ cacheBust: Date.now() })}>\n        Refresh Data\n      </button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Tabs Field in a Payload CMS Collection TypeScript\nDESCRIPTION: Provides a complete example of configuring a Tabs field within a Payload CMS collection definition (`CollectionConfig`) using TypeScript. It showcases defining multiple tabs with labels, optional descriptions, and nested fields. It also illustrates the difference between tabs identified only by `label` and those identified by `name` (which affects data storage) and the usage of `interfaceName` for TypeScript/GraphQL type generation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/tabs.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      type: 'tabs', // required\n      tabs: [\n        // required\n        {\n          label: 'Tab One Label', // required\n          description: 'This will appear within the tab above the fields.',\n          fields: [\n            // required\n            {\n              name: 'someTextField',\n              type: 'text',\n              required: true,\n            },\n          ],\n        },\n        {\n          name: 'tabTwo',\n          label: 'Tab Two Label', // required\n          interfaceName: 'TabTwo', // optional (`name` must be present)\n          fields: [\n            // required\n            {\n              name: 'numberField', // accessible via tabTwo.numberField\n              type: 'number',\n              required: true,\n            },\n          ],\n        },\n      ],\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Querying a Single Version by ID via Local API - PayloadCMS - JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates retrieving a specific version document by its unique ID using the PayloadCMS local API. The method 'payload.findVersionByID' requires the target collection and the version's ID, and supports additional parameters for data depth, localization, user context, access overrides, and whether to expose hidden fields. Returns the corresponding version as a document object. This method is suited for precise rollback or inspection operations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/versions/overview.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n// Result will be a Post document.\\nconst result = await payload.findVersionByID({\\n  collection: 'posts', // required\\n  id: '507f1f77bcf86cd799439013', // required\\n  depth: 2,\\n  locale: 'en',\\n  fallbackLocale: false,\\n  user: dummyUser,\\n  overrideAccess: false,\\n  showHiddenFields: true,\\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Username Login for Users - TypeScript\nDESCRIPTION: Enables users to log in with their username instead of their email by specifying 'loginWithUsername: true' in the collection's authentication settings. This is useful for scenarios where username-based identification is preferred. Only the 'auth' property needs to be set within the collection definition.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/overview.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\\n  slug: 'customers',\\n  auth: {\\n    loginWithUsername: true,\\n  },\\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing After Login Hook for Payload CMS (TypeScript)\nDESCRIPTION: Implements an afterLogin hook function for Payload CMS collections, allowing developers to add custom logic after a successful user login. It uses the CollectionAfterLoginHook type and provides destructured inputs: user and token. The hook can modify and return the user object, and is invoked after authentication and token issuance. Dependencies include TypeScript and the 'payload' package. Inputs are the user and generated token; the output is the processed user object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionAfterLoginHook } from 'payload';\\n\\nconst afterLoginHook: CollectionAfterLoginHook = async ({\\n  user,\\n  token,\\n}) => {...}\\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure Blob Storage in Payload CMS with TypeScript\nDESCRIPTION: Establishes Azure Blob Storage as the file upload backend for specified Payload CMS collections. The configuration requires Azure environment variables for connection string, storage account, and container name. Allows for conditional container creation (via allowContainerCreate), collection mapping (with optional prefixes), and client upload optimization. Outputs a Payload CMS configuration object that loads and applies the Azure storage adapter based on the supplied options and enables/disables features per your Azure account setup.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { azureStorage } from '@payloadcms/storage-azure'\nimport { Media } from './collections/Media'\nimport { MediaWithPrefix } from './collections/MediaWithPrefix'\n\nexport default buildConfig({\n  collections: [Media, MediaWithPrefix],\n  plugins: [\n    azureStorage({\n      collections: {\n        media: true,\n        'media-with-prefix': {\n          prefix,\n        },\n      },\n      allowContainerCreate:\n        process.env.AZURE_STORAGE_ALLOW_CONTAINER_CREATE === 'true',\n      baseURL: process.env.AZURE_STORAGE_ACCOUNT_BASEURL,\n      connectionString: process.env.AZURE_STORAGE_CONNECTION_STRING,\n      containerName: process.env.AZURE_STORAGE_CONTAINER_NAME,\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Resetting User Password - Payload CMS JavaScript\nDESCRIPTION: This code resets the user's password given a new password and a valid reset token. After a successful call, a token and user object are returned, logging in the user automatically. Parameters include collection, new password, and the forgotPassword-generated token; optionally, the request object may be passed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_14\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Result will be formatted as follows:\n// {\n//   token: 'o38jf0q34jfij43f3f...', // JWT used for auth\n//   user: { ... } // the user document that just logged in\n// }\nconst result = await payload.resetPassword({\n  collection: 'users', // required\n  data: {\n    // required\n    password: req.body.password, // the new password to set\n    token: 'afh3o2jf2p3f...', // the token generated from the forgotPassword operation\n  },\n  req: req, // optional, pass a Request object to be provided to all hooks\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Lexical Richtext to JSX Conversion in React\nDESCRIPTION: This snippet demonstrates the fundamental usage of the `RichText` component from `@payloadcms/richtext-lexical/react` to convert serialized Lexical editor state (`SerializedEditorState`) into JSX. It takes the richtext data as the `data` prop and renders it using default converters. Requires `react` and `@payloadcms/richtext-lexical/react`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-jsx.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { RichText } from '@payloadcms/richtext-lexical/react'\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\n\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) => {\n  return <RichText data={data} />\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Collections with Payload Config (TypeScript)\nDESCRIPTION: This snippet demonstrates how to register collections in the main Payload configuration using the 'buildConfig' helper from the 'payload' package. The 'collections' property expects an array containing your collection schemas, allowing you to modularly structure data models. Required dependency: 'payload' package. Ensure that each collection schema is defined according to Payload's conventions. Inputs: an array of collection configurations. Output: an exported Payload config object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/collections.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  collections: [\n    // highlight-line\n    // Your Collections go here\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Multi-Tenant Plugin Usage in Payload CMS\nDESCRIPTION: Illustrates how to integrate and configure the `multiTenantPlugin` within the `plugins` array of a Payload CMS configuration file (`payload.config.ts`). It shows defining a `tenants` collection with basic fields (name, slug, domain) and enabling the plugin for specific collections like `pages` and `navigation`, marking `navigation` as a global collection (one document per tenant). Requires the `@payloadcms/plugin-multi-tenant` package and a defined Payload `Config` type.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/multi-tenant.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { multiTenantPlugin } from '@payloadcms/plugin-multi-tenant'\nimport type { Config } from './payload-types'\n\nconst config = buildConfig({\n  collections: [\n    {\n      slug: 'tenants',\n      admin: {\n        useAsTitle: 'name'\n      }\n      fields: [\n        // remember, you own these fields\n        // these are merely suggestions/examples\n        {\n        name: 'name',\n        type: 'text',\n        required: true,\n        },\n        {\n          name: 'slug',\n          type: 'text',\n          required: true,\n        },\n        {\n          name: 'domain',\n          type: 'text',\n          required: true,\n        }\n      ],\n    },\n  ],\n  plugins: [\n    multiTenantPlugin<Config>({\n      collections: {\n        pages: {},\n        navigation: {\n          isGlobal: true,\n        }\n      },\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Side Live Preview Page Component (TSX)\nDESCRIPTION: This TSX code outlines a Next.js App Router page component (`page.tsx`). It fetches initial page data using Payload's Local API (`getPayload`, `payload.find`) enabling draft access. It then renders the page content and includes the custom `RefreshRouteOnSave` component (defined elsewhere) to enable server-side Live Preview updates.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n`page.tsx`:\n\n```tsx\nimport { RefreshRouteOnSave } from './RefreshRouteOnSave.tsx'\nimport { getPayload } from 'payload'\nimport config from '../payload.config'\n\nexport default async function Page() {\n  const payload = await getPayload({ config })\n\n  const page = await payload.find({\n    collection: 'pages',\n    draft: true,\n  })\n\n  return (\n    <Fragment>\n      <RefreshRouteOnSave />\n      <h1>{page.title}</h1>\n    </Fragment>\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Radio Group Field Configuration in Payload CMS (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to define a radio input field within a Payload CMS configuration using TypeScript. It sets the field 'type' to 'radio' and supplies 'options', which represent the selectable choices. While this minimal example omits optional properties, it can be extended with validate functions, default values, labels, and access control as required by the CMS. It depends on the Payload CMS type definitions and expects the surrounding configuration to properly import and register the resulting field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/radio.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Field } from 'payload'\\n\\nexport const MyRadioField: Field = {\\n  // ...\\n  // highlight-start\\n  type: 'radio',\\n  options: [\\n    // ...\\n  ],\\n  // highlight-end\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Quote Block and Example Collection Config - TypeScript\nDESCRIPTION: Defines a custom QuoteBlock and integrates it as a reusable block within a CollectionConfig for PayloadCMS, following best practices for modular block configuration. Relies on Payload types and demonstrates configuration of required, optional, and visual properties including slug, fields, imageURL, and interfaceName. Collections are structured with block fields supporting a set lifecycle (minRows, maxRows).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Block, CollectionConfig } from 'payload'\n\nconst QuoteBlock: Block = {\n  slug: 'Quote', // required\n  imageURL: 'https://google.com/path/to/image.jpg',\n  imageAltText: 'A nice thumbnail image to show what this block looks like',\n  interfaceName: 'QuoteBlock', // optional\n  fields: [\n    // required\n    {\n      name: 'quoteHeader',\n      type: 'text',\n      required: true,\n    },\n    {\n      name: 'quoteText',\n      type: 'text',\n    },\n  ],\n}\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'layout', // required\n      type: 'blocks', // required\n      minRows: 1,\n      maxRows: 20,\n      blocks: [\n        // required\n        QuoteBlock,\n      ],\n    },\n  ],\n}\n\n```\n\n----------------------------------------\n\nTITLE: Authenticating User Session - Payload CMS JavaScript\nDESCRIPTION: This snippet retrieves the current user's authentication and permissions context by passing HTTP headers to the Local API. It includes instructions for integrating with Next.js environments and other frameworks, as well as returning permissions, user, and responseHeaders objects. Suitable for SSR or API routes requiring user identity in server context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\n// If you're using Next.js, you'll have to import headers from next/headers, like so:\n// import { headers as nextHeaders } from 'next/headers'\n\n// you'll also have to await headers inside your function, or component, like so:\n// const headers = await nextHeaders()\n\n// If you're using Payload outside of Next.js, you'll have to provide headers accordingly.\n\n// result will be formatted as follows:\n// {\n//    permissions: { ... }, // object containing current user's permissions\n//    user: { ... }, // currently logged in user's document\n//    responseHeaders: { ... } // returned headers from the response\n// }\n\nconst result = await payload.auth({ headers })\n```\n\n----------------------------------------\n\nTITLE: Generating a Custom Meta Title Function - TypeScript\nDESCRIPTION: This example shows how to supply a generateTitle function to the SEO plugin. The passed function receives a context object (including doc) and returns a templated string as the SEO meta title, allowing document title extension and branding. It requires access to the current document and should be part of the plugin configuration object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  seoPlugin({\n    generateTitle: ({ doc }) => `Website.com — ${doc?.title}`,\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @payloadcms/plugin-search via Bash\nDESCRIPTION: Demonstrates installation of the @payloadcms/plugin-search package using pnpm. Requires pnpm or a similar Node.js JavaScript package manager. No inputs or outputs; this command-line operation adds the package to your project's dependencies and enables its use in Payload CMS configurations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/search.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @payloadcms/plugin-search\n```\n\n----------------------------------------\n\nTITLE: Defining Custom and Overriding Translations in Payload CMS i18n\nDESCRIPTION: Shows how to add custom translation strings or override existing default translations within the Payload CMS configuration. Custom keys can be added under unique namespaces (e.g., `custom.key1`), and existing keys (e.g., `general.dashboard`) can be overridden by defining them within the `i18n.translations` object, keyed by language code.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/i18n.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  //...\n  i18n: {\n    // highlight-start\n    translations: {\n      en: {\n        custom: {\n          // namespace can be anything you want\n          key1: 'Translation with {{variable}}', // translation\n        },\n        // override existing translation keys\n        general: {\n          dashboard: 'Home',\n        },\n      },\n    },\n    // highlight-end\n  },\n  //...\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Block References in Payload CMS using TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to configure Payload CMS to use block references for optimization. A 'TextBlock' is defined once in the top-level 'blocks' array of the configuration. It's then referenced by its slug ('TextBlock') within the 'blockReferences' array of a 'blocks' field in 'collection1' and within the 'BlocksFeature' configuration for a 'richText' field (Lexical editor) in 'collection2'. This avoids redefining the block multiple times, improving performance. Note that the 'blocks' array within the field definition must be empty for compatibility when using 'blockReferences'. Referenced blocks are isolated; their configuration cannot be modified per-collection, and access control runs only once without collection-specific data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\nimport { lexicalEditor, BlocksFeature } from '@payloadcms/richtext-lexical'\n\n// Payload Config\nconst config = buildConfig({\n  // Define the block once\n  blocks: [\n    {\n      slug: 'TextBlock',\n      fields: [\n        {\n          name: 'text',\n          type: 'text',\n        },\n      ],\n    },\n  ],\n  collections: [\n    {\n      slug: 'collection1',\n      fields: [\n        {\n          name: 'content',\n          type: 'blocks',\n          // Reference the block by slug\n          blockReferences: ['TextBlock'],\n          blocks: [], // Required to be empty, for compatibility reasons\n        },\n      ],\n    },\n    {\n      slug: 'collection2',\n      fields: [\n        {\n          name: 'editor',\n          type: 'richText',\n          editor: lexicalEditor({\n            features: [\n              BlocksFeature({\n                // Same reference can be reused anywhere, even in the lexical editor, without incurred performance hit\n                blocks: ['TextBlock'],\n              }),\n            ],\n          }),\n        },\n      ],\n    },\n  ],\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Specific CORS Origins and Headers in Payload Config (TypeScript)\nDESCRIPTION: Demonstrates configuring CORS with specific settings in the Payload config. This example allows requests only from `http://localhost:3000` and adds `x-custom-header` to the allowed headers list.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  // highlight-start\n  cors: {\n    origins: ['http://localhost:3000'],\n    headers: ['x-custom-header'],\n  },\n  // highlight-end\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Identifying Payload Auto-Generated Files (TSX Comments)\nDESCRIPTION: Presents the comment block inserted at the beginning of files automatically generated by Payload. These comments serve as a warning that the file is managed by Payload and direct modifications may be lost during regeneration processes or updates.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/overview.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n/* THIS FILE WAS GENERATED AUTOMATICALLY BY PAYLOAD. */,\n/* DO NOT MODIFY IT BECAUSE IT COULD BE REWRITTEN AT ANY TIME. */\n```\n\n----------------------------------------\n\nTITLE: Conditionally Enabling Payload Cloud Storage Plugin in TypeScript\nDESCRIPTION: Illustrates how to conditionally enable or disable the Payload Cloud Storage plugin based on an environment variable (`process.env.MY_CONDITION`). The `enabled` property within the plugin configuration controls its activation. This is the recommended method for conditional usage to avoid potential webpack build errors if the plugin code is included but disabled differently.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncloudStoragePlugin({\n  enabled: process.env.MY_CONDITION === 'true',\n  collections: {\n    'my-collection-slug': {\n      adapter: theAdapterToUse, // see docs for the adapter you want to use\n    },\n  },\n}),\n```\n\n----------------------------------------\n\nTITLE: Configuring beforeDocumentControls for a Collection (TypeScript)\nDESCRIPTION: Illustrates how to inject custom components before the standard document action buttons (Save, Publish, etc.) in a Collection's Edit View. The `admin.components.edit.beforeDocumentControls` property takes an array of paths to the custom components.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```\nexport const MyCollection: CollectionConfig = {\n  admin: {\n    components: {\n      edit: {\n        // highlight-start\n        beforeDocumentControls: ['/path/to/CustomComponent'],\n        // highlight-end\n      },\n    },\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Removing a Row from an Array Field - PayloadCMS useForm - TypeScript/TSX\nDESCRIPTION: This snippet demonstrates usage of the removeFieldRow method from useForm to programmatically remove a row from an array or block field in the PayloadCMS admin UI. The onClick event of a button calls removeFieldRow with the path to the array/block and the specific rowIndex. The example config shows how to wire this into a collection definition. Requires @payloadcms/ui, React, and that the custom component is referenced in the collection config.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from \"@payloadcms/ui\"\n\nexport const CustomArrayManager = () => {\n  const { removeFieldRow } = useForm()\n\nreturn (\n\n<button\n  type=\"button\"\n  onClick={() => {\n    removeFieldRow({\n      path: 'arrayField',\n      rowIndex: 0,\n    })\n  }}\n>\n  Remove Row\n</button>\n) }\n```\n\nLANGUAGE: tsx\nCODE:\n```\nconst ExampleCollection = {\nslug: \"example-collection\",\nfields: [\n{\nname: \"arrayField\",\ntype: \"array\",\nfields: [\n{\nname: \"textField\",\ntype: \"text\",\n},\n],\n},\n{\ntype: \"ui\",\nname: \"customArrayManager\",\nadmin: {\ncomponents: {\nField: '/path/to/CustomArrayManagerField',\n},\n},\n},\n],\n}\n```\n\n----------------------------------------\n\nTITLE: Adding or Replacing Global Views in Payload CMS with TypeScript\nDESCRIPTION: This snippet illustrates how to configure Global Document Views (such as the Edit View) using the admin.components.views property in a global config object. It specifies a custom component for the 'edit.default' key, enabling the replacement or extension of Payload's global admin UI. Dependencies include 'payload' and the relevant Global config typing. The configuration supports arbitrary keys for additional view customization.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-views.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { SanitizedGlobalConfig } from 'payload'\n\nexport const MyGlobalConfig: SanitizedGlobalConfig = {\n  // ...\n  admin: {\n    components: {\n      views: {\n        // highlight-start\n        edit: {\n          default: {\n            Component: '/path/to/MyCustomGlobalView',\n          },\n        },\n        // highlight-end\n        // Other options include:\n        // - [key: string]\n        // See below for more details\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing the SEO Meta Interface Name - TypeScript\nDESCRIPTION: This TypeScript snippet shows how to set a custom name for the interface generated for the SEO meta group in TypeScript and GraphQL. The interfaceName option can help with type safety or GraphQL schema customizations in complex projects. Supply the interfaceName property within your plugin configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  seoPlugin({\n    interfaceName: 'customInterfaceNameSEO',\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom PreviewButton in Payload Collection\nDESCRIPTION: This TypeScript snippet shows how to specify a custom `PreviewButton` component within a Payload CMS Collection's configuration. The path to the custom component (`/path/to/MyPreviewButton`) is assigned to the `admin.components.edit.PreviewButton` property, enabling the replacement of the default preview button in the Edit View.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      edit: {\n        // highlight-start\n        PreviewButton: '/path/to/MyPreviewButton',\n        // highlight-end\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Using Context in Custom Field Validation in Payload CMS (TypeScript)\nDESCRIPTION: This snippet shows how to use the `ctx` argument provided to the custom `validate` function in Payload CMS. It specifically accesses the `user` property from the context to enforce that a user must be logged in to save the field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyField: Field = {\n  type: 'text',\n  name: 'myField',\n  // highlight-start\n  validate: (val, { user }) =>\n    Boolean(user) || 'You must be logged in to save this field',\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Triggering Actions after Field Change with Payload Hooks - TypeScript\nDESCRIPTION: Defines a Payload CMS select field with an afterChange hook to react when a user changes their membership status. This hook compares new and previous values, logs the update, and is suitable for triggering additional logic, such as analytics or notifications. Requires Payload CMS in a TypeScript project, expects authentication context on the req object, and returns no value (side effects only).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/fields.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nconst membershipStatusField: Field = {\n  name: 'membershipStatus',\n  type: 'select',\n  options: [\n    { label: 'Standard', value: 'standard' },\n    { label: 'Premium', value: 'premium' },\n    { label: 'VIP', value: 'vip' },\n  ],\n  hooks: {\n    afterChange: [\n      ({ value, previousValue, req }) => {\n        if (value !== previousValue) {\n          // Log or perform an action when the membership status changes\n          console.log(\n            `User ID ${req.user.id} changed their membership status from ${previousValue} to ${value}.`,\n          )\n          // Here, you can implement actions that could track conversions from one tier to another\n        }\n      },\n    ],\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Finding Specific Global Version by ID using Payload Local API in JavaScript\nDESCRIPTION: This snippet demonstrates retrieving a specific version of a global document by its ID using the Payload Local API. It requires both the global slug and the version ID. Optional parameters can control relationship depth, localization, user context, access override, and hidden field visibility. The function returns the specific version document found.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/versions/overview.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// Result will be a Post document.\nconst result = await payload.findGlobalVersionByID({\n  slug: 'header', // required\n  id: '507f1f77bcf86cd799439013', // required\n  depth: 2,\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUser,\n  overrideAccess: false,\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Finding Global Versions using Payload Local API in JavaScript\nDESCRIPTION: This snippet shows how to query for paginated versions of a specific global document using the Payload Local API. It requires the global slug. Optional parameters allow for controlling depth, pagination (`page`, `limit`), filtering (`where`), sorting (`sort`), localization (`locale`, `fallbackLocale`), user context, access override, and visibility of hidden fields. The function returns a paginated set of version documents.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/versions/overview.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// Result will be a paginated set of Versions.\n// See /docs/queries/pagination for more.\nconst result = await payload.findGlobalVersions({\n  slug: 'header', // required\n  depth: 2,\n  page: 1,\n  limit: 10,\n  where: {}, // pass a `where` query here\n  sort: '-createdAt',\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUser,\n  overrideAccess: false,\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Custom Blocks and Inline Blocks in Lexical to JSX Conversion\nDESCRIPTION: This snippet illustrates how to provide custom JSX converters for custom Blocks (`myNumberBlock`, `myTextBlock`) and Inline Blocks (`myInlineBlock`) defined in Payload CMS. Converters are defined within the `blocks` and `inlineBlocks` properties of the `jsxConverters` object, keyed by the block slugs, and receive the serialized node data. Type safety is enhanced by extending `DefaultNodeTypes` with custom block types. Requires `react` and `@payloadcms/richtext-lexical/react`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-jsx.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport type { MyInlineBlock, MyNumberBlock, MyTextBlock } from '@/payload-types'\nimport type {\n  DefaultNodeTypes,\n  SerializedBlockNode,\n  SerializedInlineBlockNode,\n} from '@payloadcms/richtext-lexical'\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\n\nimport {\n  type JSXConvertersFunction,\n  RichText,\n} from '@payloadcms/richtext-lexical/react'\nimport React from 'react'\n\n// Extend the default node types with your custom blocks for full type safety\ntype NodeTypes =\n  | DefaultNodeTypes\n  | SerializedBlockNode<MyNumberBlock | MyTextBlock>\n  | SerializedInlineBlockNode<MyInlineBlock>\n\nconst jsxConverters: JSXConvertersFunction<NodeTypes> = ({\n  defaultConverters,\n}) => ({\n  ...defaultConverters,\n  blocks: {\n    // Each key should match your block's slug\n    myNumberBlock: ({ node }) => <div>{node.fields.number}</div>,\n    myTextBlock: ({ node }) => (\n      <div style={{ backgroundColor: 'red' }}>{node.fields.text}</div>\n    ),\n  },\n  inlineBlocks: {\n    // Each key should match your inline block's slug\n    myInlineBlock: ({ node }) => <span>{node.fields.text}</span>,\n  },\n})\n\nexport const MyComponent: React.FC<{\n  lexicalData: SerializedEditorState\n}> = ({ lexicalData }) => {\n  return <RichText converters={jsxConverters} data={lexicalData} />\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Operation-specific Access Control - Payload CMS - TypeScript\nDESCRIPTION: Demonstrates detailed setup of the `access` property inside a Global Config, assigning access control functions to `read`, `update`, and optionally `readVersion` for versioned Globals. Requires Payload CMS, and expects access control functions that evaluate permissions based on the authenticated `user` object in the request. Suitable for securing operations with custom logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/globals.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { GlobalConfig } from 'payload'\n\nconst GlobalWithAccessControl: GlobalConfig = {\n  // ...\n  // highlight-start\n  access: {\n    read: ({ req: { user } }) => {...},\n    update: ({ req: { user } }) => {...},\n\n    // Version-enabled Globals only\n    readVersion: () => {...},\n  },\n  // highlight-end\n}\n\nexport default Header\n```\n\n----------------------------------------\n\nTITLE: Wrapping Payload Live Preview with Next.js Router - TypeScript React\nDESCRIPTION: This code defines the RefreshRouteOnSave component, which wraps the PayloadCMS Live Preview component and integrates it with Next.js router refresh functionality. It uses the useRouter hook from next/navigation to trigger route refreshes in response to live preview events from the Payload admin panel. Key parameters include the serverURL and an anonymous refresh function. Use this snippet within client-side React files in a Next.js application that uses PayloadCMS server-side live preview.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/server.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport { RefreshRouteOnSave as PayloadLivePreview } from '@payloadcms/live-preview-react'\nimport { useRouter } from 'next/navigation.js'\nimport React from 'react'\n\nexport const RefreshRouteOnSave: React.FC = () => {\n  const router = useRouter()\n\n  return (\n    <PayloadLivePreview\n      refresh={() => router.refresh()}\n      serverURL={process.env.NEXT_PUBLIC_PAYLOAD_URL}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Checkbox Field in Payload (TypeScript)\nDESCRIPTION: This snippet demonstrates the fundamental configuration for adding a Checkbox field to a Payload schema. It imports the 'Field' type and shows setting the 'type' property to 'checkbox' within a field definition object. This tells Payload to render a checkbox input and store a boolean value.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/checkbox.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyCheckboxField: Field = {\n  // ...\n  type: 'checkbox', // highlight-line\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Logging In a User with a GraphQL Mutation\nDESCRIPTION: Example GraphQL mutation for logging in a user (replace `[collection-singular-label]` with the actual label, e.g., `loginUser`). It takes email and password as arguments and requests the user's email, token expiration, and the token itself upon successful authentication.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_5\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  login[collection-singular-label](email: \"dev@payloadcms.com\", password: \"yikes\") {\n    user {\n      email\n    }\n    exp\n    token\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Formatting Preview URL for Next.js Draft Mode (TypeScript)\nDESCRIPTION: Shows how to configure the `preview` function in a Payload Collection to generate a URL specifically for enabling Next.js Draft Mode. It constructs a relative URL pointing to a custom `/preview` API route and includes necessary query parameters like `slug`, `collection`, the target `path`, and a `previewSecret` retrieved from environment variables.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/preview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Pages: CollectionConfig = {\n  slug: 'pages',\n  admin: {\n    preview: ({ slug, collection }) => {\n      const encodedParams = new URLSearchParams({\n        slug,\n        collection,\n        path: `/${slug}`,\n        previewSecret: process.env.PREVIEW_SECRET || '',\n      })\n\n      return `/preview?${encodedParams.toString()}` // highlight-line\n    },\n  },\n  fields: [\n    {\n      name: 'slug',\n      type: 'text',\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Supported Languages to Payload CMS i18n Configuration\nDESCRIPTION: Illustrates how to add multiple supported languages to the Payload CMS application. It involves importing language-specific translation objects (e.g., `en`, `de`) from `@payloadcms/translations` and assigning them to the `i18n.supportedLanguages` key in the `payload.config.ts` file.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/i18n.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { en } from '@payloadcms/translations/languages/en'\nimport { de } from '@payloadcms/translations/languages/de'\n\nexport default buildConfig({\n  // ...\n  // highlight-start\n  i18n: {\n    supportedLanguages: { en, de },\n  },\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload CMS to Use Vercel Blob Storage (TypeScript)\nDESCRIPTION: Demonstrates how to configure the Payload CMS `buildConfig` to use the Vercel Blob storage adapter. It involves importing `vercelBlobStorage` from the package, adding it to the `plugins` array, specifying which collections ('media', 'media-with-prefix') should use the adapter (optionally defining a `prefix`), and providing the required `BLOB_READ_WRITE_TOKEN` via environment variables. The `enabled` flag controls the plugin's activation. Dependencies include the `@payloadcms/storage-vercel-blob` package and defined Payload collections (`Media`, `MediaWithPrefix`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/storage-vercel-blob/README.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { vercelBlobStorage } from '@payloadcms/storage-vercel-blob'\nimport { Media } from './collections/Media'\nimport { MediaWithPrefix } from './collections/MediaWithPrefix'\n\nexport default buildConfig({\n  collections: [Media, MediaWithPrefix],\n  plugins: [\n    vercelBlobStorage({\n      enabled: true, // Optional, defaults to true\n      // Specify which collections should use Vercel Blob\n      collections: {\n        media: true,\n        'media-with-prefix': {\n          prefix: 'my-prefix',\n        },\n      },\n      // Token provided by Vercel once Blob storage is added to your Vercel project\n      token: process.env.BLOB_READ_WRITE_TOKEN,\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating Payload Cloud Plugin in Payload Config (TypeScript)\nDESCRIPTION: Demonstrates the basic setup of the Payload Cloud plugin within a Payload `buildConfig` function. It imports `payloadCloudPlugin` from '@payloadcms/payload-cloud' and adds an instance of it to the `plugins` array to enable default cloud features.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/payload-cloud/README.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { payloadCloudPlugin } from '@payloadcms/payload-cloud'\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  plugins: [payloadCloudPlugin()],\n  // rest of config\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Upload Component in Payload CMS\nDESCRIPTION: This snippet provides a basic example of a custom React component (`MyUploadComponent`) intended to replace the default file upload functionality in the Payload CMS Edit View for Collections. It renders a simple HTML file input element (`<input type=\"file\" />`). It requires `react`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_25\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\n\nexport function MyUploadComponent() {\n  return <input type=\"file\" />\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Payload CMS with Blank Template (Shell)\nDESCRIPTION: This shell command utilizes npx to execute the most recent version of the `create-payload-app` scaffolding tool. The `-t blank` option instructs the tool to set up a new Payload project using the 'blank' template, providing a minimal starting point ideal for custom enterprise tools or applications where specific configurations are defined from scratch.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/what-is-payload.mdx#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnpx create-payload-app@latest -t blank\n```\n\n----------------------------------------\n\nTITLE: Using Custom Translations in a React Component with useTranslation Hook\nDESCRIPTION: Demonstrates using the `useTranslation` hook from `@payloadcms/ui` within a custom React component (`MyComponent.tsx`). It imports the custom translation types (`CustomTranslationsObject`, `CustomTranslationsKeys`) and passes them as generic arguments to the hook, enabling type-safe access to both default and custom translation strings via the returned `t` function.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/i18n.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// <rootDir>/components/MyComponent.tsx\n\n'use client'\nimport type React from 'react'\nimport { useTranslation } from '@payloadcms/ui'\n\nimport type {\n  CustomTranslationsObject,\n  CustomTranslationsKeys,\n} from '../custom-translations'\n\nexport const MyComponent: React.FC = () => {\n  const { i18n, t } = useTranslation<\n    CustomTranslationsObject,\n    CustomTranslationsKeys\n  >() // These generics merge your custom translations with the default client translations\n\n  return t('general:myCustomKey')\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Absolute Live Preview URL using Request Object\nDESCRIPTION: This snippet shows how to dynamically construct a fully qualified absolute URL for Live Preview using the `req` (request) object passed to the `url` function. This is useful when the frontend is on a different domain or when a full URL is required, deriving the protocol and host from the incoming request.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/overview.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nurl: ({ data, req }) => `${req.protocol}//${req.host}/${data.slug}` // highlight-line\n```\n\n----------------------------------------\n\nTITLE: Configuring Job Processing Order in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript snippet shows various ways to configure the job processing order in the Payload CMS job queue. It displays setting a global processingOrder (LIFO via '-createdAt'), specifying order per queue (FIFO/LIFO), and using a dynamic function to determine the order based on queue name. These configurations are applied within the Payload buildConfig structure and influence how jobs are dequeued for processing. Dependencies are limited to Payload CMS configuration; input is the processingOrder value (string, object, or function); output is jobs processed in the specified order.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/queues.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default buildConfig({\n  // Other configurations...\n  jobs: {\n    tasks: [\n      // your tasks here\n    ],\n    processingOrder: '-createdAt', // Process jobs in reverse order of creation = LIFO\n  },\n})\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default buildConfig({\n  // Other configurations...\n  jobs: {\n    tasks: [\n      // your tasks here\n    ],\n    processingOrder: {\n      default: 'createdAt', // FIFO\n      queues: {\n        nightly: '-createdAt', // LIFO\n        myQueue: '-createdAt', // LIFO\n      },\n    },\n  },\n})\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default buildConfig({\n  // Other configurations...\n  jobs: {\n    tasks: [\n      // your tasks here\n    ],\n    processingOrder: ({ queue }) => {\n      if (queue === 'myQueue') {\n        return '-createdAt' // LIFO\n      }\n      return 'createdAt' // FIFO\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining an Upload Field in a Payload CMS Collection (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to configure a basic 'upload' field within a Payload CMS collection. It defines a required field named 'backgroundImage' of type 'upload' that establishes a relationship with the 'media' collection. This is part of the 'ExampleCollection' configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/upload.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'backgroundImage', // required\n      type: 'upload', // required\n      relationTo: 'media', // required\n      required: true,\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Standard Payload GET Request using Fetch API (TypeScript)\nDESCRIPTION: Illustrates a standard client-side GET request to a Payload endpoint using the `fetch` API in TypeScript. Parameters like `depth` and `locale` are passed directly in the URL query string. This serves as a comparison to the method override technique.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst res = await fetch(`${api}/${collectionSlug}?depth=1&locale=en`, {\n  method: 'GET',\n  credentials: 'include',\n  headers: {\n    'Accept-Language': i18n.language,\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Setting a Static Default Value for a Payload Field (TypeScript)\nDESCRIPTION: This snippet shows how to set a static default value for a Payload field using the `defaultValue` property within the `Field` configuration. The provided value ('Hello, World!') will automatically populate the field during document creation or update operations if no value is explicitly supplied.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyField: Field = {\n  type: 'text',\n  name: 'myField',\n  defaultValue: 'Hello, World!', // highlight-line\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Custom Stylesheet in a React Component (TSX)\nDESCRIPTION: This snippet shows how to apply custom styles to a React component by importing a local CSS or SCSS file (`./index.scss`). The component then uses a class name defined in the stylesheet.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nimport './index.scss'\n\nexport function MyComponent() {\n  return <div className=\"my-component\">My Custom Component</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping a New Payload App with pnpx - Shell\nDESCRIPTION: This snippet demonstrates how to initialize a new Payload CMS application using the create-payload-app package via pnpx. It requires Node.js and npm/yarn/pnpm to be installed. The command will prompt for configuration details and set up a new project directory containing Payload's backend and starter code. No arguments are needed by default, but optional flags can be provided for templates or other settings. Output is a new, ready-to-run Payload CMS project folder.\nSOURCE: https://github.com/payloadcms/payload/blob/main/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\npnpx create-payload-app@latest\n\n```\n\n----------------------------------------\n\nTITLE: Injecting Custom Components After the Nav Links (TypeScript)\nDESCRIPTION: Details usage of afterNavLinks in admin.components to add custom elements following admin sidebar links. Specify component file paths in an array. This feature is built into Payload CMS and is ideal for auxiliary links, support, or status metadata.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  admin: {\n    // highlight-start\n    components: {\n      afterNavLinks: ['/path/to/your/component'],\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Finding a Specific Document by ID via Payload REST API\nDESCRIPTION: Performs a GET request to find a single document within a specific collection using its unique ID. Returns the full document object if found.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_1\n\nLANGUAGE: HTTP\nCODE:\n```\nGET /api/{collection-slug}/{id}\n```\n\n----------------------------------------\n\nTITLE: Generating HTML Automatically in a Payload Collection Definition (Server)\nDESCRIPTION: Shows how to configure a Payload CMS collection (`Pages`) to automatically generate an HTML representation of a Lexical rich text field. It uses the `lexicalHTMLField` helper, which creates a new field (e.g., `nameOfYourRichTextField_html`) and uses an `afterRead` hook to populate it by converting the JSON from the specified `lexicalFieldName`. This example also demonstrates passing custom `converters` for blocks within the `lexicalHTMLField` configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-html.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { HTMLConvertersFunction } from '@payloadcms/richtext-lexical/html'\nimport type { MyTextBlock } from '@/payload-types.js'\nimport type { CollectionConfig } from 'payload'\n\nimport {\n  BlocksFeature,\n  type DefaultNodeTypes,\n  lexicalEditor,\n  lexicalHTMLField,\n  type SerializedBlockNode,\n} from '@payloadcms/richtext-lexical'\n\nconst Pages: CollectionConfig = {\n  slug: 'pages',\n  fields: [\n    {\n      name: 'nameOfYourRichTextField',\n      type: 'richText',\n      editor: lexicalEditor(),\n    },\n    lexicalHTMLField({\n      htmlFieldName: 'nameOfYourRichTextField_html',\n      lexicalFieldName: 'nameOfYourRichTextField',\n    }),\n    {\n      name: 'customRichText',\n      type: 'richText',\n      editor: lexicalEditor({\n        features: ({ defaultFeatures }) => [\n          ...defaultFeatures,\n          BlocksFeature({\n            blocks: [\n              {\n                interfaceName: 'MyTextBlock',\n                slug: 'myTextBlock',\n                fields: [\n                  {\n                    name: 'text',\n                    type: 'text',\n                  },\n                ],\n              },\n            ],\n          }),\n        ],\n      }),\n    },\n    lexicalHTMLField({\n      htmlFieldName: 'customRichText_html',\n      lexicalFieldName: 'customRichText',\n      // can pass in additional converters or override default ones\n      converters: (({ defaultConverters }) => ({\n        ...defaultConverters,\n        blocks: {\n          myTextBlock: ({ node, providedCSSString }) =>\n            `<div style=\"background-color: red;${providedCSSString}\">${node.fields.text}</div>`,\n        },\n      })) as HTMLConvertersFunction<\n        DefaultNodeTypes | SerializedBlockNode<MyTextBlock>\n      >,\n    }),\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Admin Configuration to a Payload CMS Field using TypeScript\nDESCRIPTION: This TypeScript code shows how to add admin-specific configurations to a Payload CMS field using the `admin` property within the Field definition. It requires the `Field` type from the `payload` package. This allows customization of the field's appearance and behavior in the Payload Admin Panel.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/number.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyNumberField: Field = {\n  // ...\n  admin: { // highlight-line\n    // ...\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Payload Plugin in TypeScript\nDESCRIPTION: This snippet defines a Payload plugin function named `addLastModified`. It takes the incoming Payload configuration (`incomingConfig`), iterates through all collections, and adds a new `lastModifiedBy` relationship field to each. This field links to auth-enabled collections and uses a `beforeChange` hook to automatically populate the field with the ID and collection slug of the user making the change. The function returns the modified configuration object. It depends on the `Config` and `Plugin` types from 'payload'.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/overview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { Config, Plugin } from 'payload'\n\nexport const addLastModified: Plugin = (incomingConfig: Config): Config => {\n  // Find all incoming auth-enabled collections\n  // so we can create a lastModifiedBy relationship field\n  // to all auth collections\n  const authEnabledCollections = incomingConfig.collections.filter(\n    (collection) => Boolean(collection.auth),\n  )\n\n  // Spread the existing config\n  const config: Config = {\n    ...incomingConfig,\n    collections: incomingConfig.collections.map((collection) => {\n      // Spread each item that we are modifying,\n      // and add our new field - complete with\n      // hooks and proper admin UI config\n      return {\n        ...collection,\n        fields: [\n          ...collection.fields,\n          {\n            name: 'lastModifiedBy',\n            type: 'relationship',\n            relationTo: authEnabledCollections.map(({ slug }) => slug),\n            hooks: {\n              beforeChange: [\n                ({ req }) => ({\n                  value: req?.user?.id,\n                  relationTo: req?.user?.collection,\n                }),\n              ],\n            },\n            admin: {\n              position: 'sidebar',\n              readOnly: true,\n            },\n          },\n        ],\n      }\n    }),\n  }\n\n  return config\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a Code Field to Payload Field Config - TypeScript\nDESCRIPTION: Demonstrates how to define a Code Field within a Payload Field configuration object in TypeScript. Requires the 'payload' package and the Field type import as a dependency. Setting 'type' to 'code' enables storage of an arbitrary string value in the database, with a code editor UI in the Admin Panel. No required input parameters, but the object can include further attributes for behavior and validation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/code.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyBlocksField: Field = {\n  // ...\n  type: 'code', // highlight-line\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Document Locking in Payload CMS with TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to enable and customize document locking for a collection within Payload CMS by setting the 'lockDocuments' property in the collection configuration. It requires the '@payloadcms/payload' dependency and expects a properly typed CollectionConfig object. The 'duration' parameter determines (in seconds) how long a document remains locked due to inactivity; other collection parameters may be customized as needed. Inputs include field definitions and locking configuration; output is a configuration object exported for use in Payload CMS setup.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/locked-documents.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  fields: [\n    {\n      name: 'title',\n      type: 'text',\n    },\n    // other fields...\n  ],\n  lockDocuments: {\n    duration: 600, // Duration in seconds\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Context Providers with Payload CMS Client Feature in TypeScript\nDESCRIPTION: This snippet demonstrates injecting a custom React context provider in the Payload CMS rich text editor's feature configuration. The approach depends on @payloadcms/richtext-lexical/client and expects an external context (here, TableContext). Providers are added to the providers array, making them available within the editor hierarchy to enable custom state/context logic. No direct parameters, but the context provider should be a valid React context or provider component, with the output being a Payload CMS client feature.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_22\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"'use client'\\n\\nimport { createClientFeature } from '@payloadcms/richtext-lexical/client'\\nimport { TableContext } from './context'\\n\\nexport const MyClientFeature = createClientFeature({\\n  providers: [TableContext],\\n})\\n\"\n```\n\n----------------------------------------\n\nTITLE: Implementing afterDelete Hook in Payload (TypeScript)\nDESCRIPTION: Illustrates how to set up an afterDelete hook in a Payload collection with TypeScript. The snippet shows importing the CollectionAfterDeleteHook type and defines an async hook function accessed after a document is removed from the database. Receives req, id, and doc for potential auditing or notifications but ignores return values. Depends on Payload and requires TypeScript support.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionAfterDeleteHook } from 'payload';\n\nconst afterDeleteHook: CollectionAfterDeleteHook = async ({\n  req,\n  id,\n  doc,\n}) => {...}\n```\n\n----------------------------------------\n\nTITLE: Configuring Postgres Adapter in Payload CMS with Drizzle ORM (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure the Payload CMS to use a Postgres database via the officially supported @payloadcms/db-postgres adapter. It highlights the integration using Drizzle ORM by passing a configuration object, which must include a pool with a connection string for the target Postgres instance. The adapter is provided to the db property of Payload\\'s buildConfig. Required dependencies: @payloadcms/db-postgres, Drizzle ORM, and node-postgres. The main parameter is pool.connectionString, typically set from an environment variable. Inputs include database connection options, and the output is a configured Payload CMS instance ready to use Postgres.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/postgres.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { postgresAdapter } from '@payloadcms/db-postgres'\n\nexport default buildConfig({\n  // Configure the Postgres adapter here\n  db: postgresAdapter({\n    // Postgres-specific arguments go here.\n    // `pool` is required.\n    pool: {\n      connectionString: process.env.DATABASE_URI,\n    },\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Invoking Create Post Server Function from a React Client Component (TypeScript)\nDESCRIPTION: This client-side React component demonstrates how to call the 'createPost' server function from the frontend. Upon button click, it triggers the server function to create a new post with a static title, displaying the result or feedback. Prerequisites include importing the server action, TypeScript React setup, and appropriate payload server function implementation. Inputs and outputs are simple strings corresponding to the post title.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n\"'use client';\\n\\nimport React, { useState } from 'react';\\nimport { createPost } from '../server/actions'; // import the server function\\n\\nexport const PostForm: React.FC = () => {\\n  const [result, setResult] = useState<string>('');\\n\\n  return (\\n    <>\\n      <p>{result}</p>\\n\\n      <button\\n        type=\\\"button\\\"\\n        onClick={async () => {\\n          // Call the server function\\n          const newPost = await createPost({ title: 'Sample Post' });\\n          setResult('Post created: ' + newPost.title);\\n        }}\\n      >\\n        Create Post\\n      </button>\\n    </>\\n  );\\n};\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload with Vercel Postgres Adapter (Automatic Detection) in TypeScript\nDESCRIPTION: This TypeScript code shows a simplified configuration for the Payload CMS Vercel Postgres adapter within `buildConfig`. It relies on Vercel's environment variable detection (typically `POSTGRES_URL`) to automatically determine the connection string, omitting the need for explicit configuration. Note: The example uses `postgresAdapter()`, implying it should be imported, likely as `vercelPostgresAdapter` from `@payloadcms/db-vercel-postgres`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/db-vercel-postgres/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport default buildConfig({\n  db: postgresAdapter(),\n  // ...rest of config\n})\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Plugin to Payload Config in TypeScript\nDESCRIPTION: This code shows how to add a specific custom plugin, imported as `addLastModified` from a local file (`./addLastModified.ts`), to the `plugins` array within the Payload configuration object created by `buildConfig`. This illustrates the practical application of registering a custom-built plugin.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/overview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\nimport { addLastModified } from './addLastModified.ts'\n\nconst config = buildConfig({\n  // ...\n  // highlight-start\n  plugins: [addLastModified],\n  // highlight-end\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Initiating Forgot Password via REST API in TypeScript\nDESCRIPTION: Sends a POST request to the specific collection's forgot-password endpoint in the Payload CMS REST API. The request body must contain the email address of the user requesting the password reset. This triggers Payload to generate a reset token and send an email to the specified address.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await fetch(\n  `http://localhost:3000/api/[collection-slug]/forgot-password`,\n  {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      email: 'dev@payloadcms.com',\n    }),\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Formatting Output after Reading Field Value with Payload Hooks - TypeScript\nDESCRIPTION: Demonstrates the use of the afterRead hook on a Payload CMS date field to automatically format the stored value for display. The hook uses toLocaleDateString() to present the date, making it user-friendly in the API or admin panel. Depends on Payload CMS and assumes the value is a valid date-compatible input.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/fields.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nconst dateField: Field = {\n  name: 'createdAt',\n  type: 'date',\n  hooks: {\n    afterRead: [\n      ({ value }) => {\n        // Format date for display\n        return new Date(value).toLocaleDateString()\n      },\n    ],\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using `addDataAndFileToRequest` Helper in Payload Custom Endpoint (TypeScript)\nDESCRIPTION: Illustrates the use of the `addDataAndFileToRequest` helper function from the `payload` package within a custom endpoint handler. This function simplifies processing request bodies by automatically parsing JSON data and potential file uploads, attaching `data` and `file` properties to the `req` object before further processing like `req.payload.update`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { addDataAndFileToRequest } from 'payload'\n\n// custom endpoint example\n{\n  path: '/:id/tracking',\n  method: 'post',\n  handler: async (req) => {\n    await addDataAndFileToRequest(req)\n    await req.payload.update({\n      collection: 'tracking',\n      data: {\n        // data to update the document with\n      }\n    })\n    return Response.json({\n      message: 'successfully updated tracking info'\n    })\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Payload Instance via `req` in a Hook (TypeScript)\nDESCRIPTION: Demonstrates accessing the Payload instance directly from the `req` object within a Payload hook (specifically, `CollectionAfterChangeHook`). This method is commonly used within Payload's built-in extension points like Hooks and Access Control functions. The example shows fetching all documents from the 'posts' collection using the accessed `payload` object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst afterChangeHook: CollectionAfterChangeHook = async ({\n  req: { payload },\n}) => {\n  const posts = await payload.find({\n    collection: 'posts',\n  })\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Array Field Label Server Component in TSX\nDESCRIPTION: This snippet defines a custom React server component (`CustomArrayFieldLabelServer`) for rendering the label associated with a Payload CMS Array Field. It utilizes the `FieldLabel` component from `@payloadcms/ui`. The component receives server-side props (`clientField`, `path`) and uses them to determine the label text (preferring `clientField.label` over `clientField.name`) and whether the field is required. Requires React and dependencies from `@payloadcms/ui` and `payload`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/array.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { ArrayFieldLabelServerComponent } from 'payload'\n\nexport const CustomArrayFieldLabelServer: ArrayFieldLabelServerComponent = ({\n  clientField,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={clientField?.label || clientField?.name}\n      path={path}\n      required={clientField?.required}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Omitting JWT from Auth Operation Responses in Payload Config (TypeScript)\nDESCRIPTION: This TypeScript configuration snippet shows how to prevent JWT tokens from being returned by authentication operations in a Payload collection by setting the removeTokenFromResponse flag to true. The snippet defines a collection config object for a new users collection; it requires the type CollectionConfig from Payload and demonstrates configuration via a simple object export. Inputs include specifying the collection slug and auth settings, while outputs are an updated collection schema. This is useful for enhanced security when JWTs should not be included in API responses.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/jwt.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const UsersWithoutJWTs: CollectionConfig = {\n  slug: 'users-without-jwts',\n  auth: {\n    removeTokenFromResponse: true, // highlight-line\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting via Payload GraphQL API (GraphQL)\nDESCRIPTION: This snippet illustrates how to sort documents using the Payload GraphQL API. It defines a GraphQL query named 'Posts' that accepts a `sort` argument. The value `\"-createdAt\"` is passed to sort the resulting documents by the 'createdAt' field in descending order. The query requests the 'color' field for each document in the sorted list.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/sort.mdx#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  Posts(sort: \"-createdAt\") {\n    docs {\n      color\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sorting by Single Field via Payload REST API (JavaScript Fetch)\nDESCRIPTION: This snippet demonstrates fetching documents sorted by a single field using the Payload REST API. It uses the native `fetch` API to make a GET request to the '/api/posts' endpoint, appending the query parameter `sort=-createdAt`. This instructs the API to return posts sorted by the 'createdAt' field in descending order. The response is then parsed as JSON.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/sort.mdx#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfetch('https://localhost:3000/api/posts?sort=-createdAt') // highlight-line\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n```\n\n----------------------------------------\n\nTITLE: Configuring Upload Caching Per Collection in Payload Cloud Plugin (TypeScript)\nDESCRIPTION: Shows advanced configuration options for the upload caching feature within the Payload Cloud plugin. It demonstrates setting a default `maxAge` for all collections and overriding this default or disabling caching entirely for specific collections identified by their slugs, providing fine-grained control over CDN caching behavior.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/payload-cloud/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\npayloadCloudPlugin({\n  uploadCaching: {\n    maxAge: 604800, // Override default maxAge for all collections\n    collection1Slug: {\n      maxAge: 10, // Collection-specific maxAge, takes precedence over others\n    },\n    collection2Slug: {\n      enabled: false, // Disable caching for this collection\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling API Key Authentication in Payload CMS Collection (TypeScript)\nDESCRIPTION: This snippet shows how to configure a Payload CMS collection to support API Key authentication by setting the 'useAPIKey' property to true in the 'auth' object. This enables a UI in the Admin Panel for generating and managing API keys for each document in the collection, allowing third-party integrations to authenticate securely. Requires the Payload CMS library and a compatible configuration environment; expected input is a CollectionConfig object, and output is collection API key support enabled.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/api-keys.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ThirdPartyAccess: CollectionConfig = {\n  slug: 'third-party-access',\n  auth: {\n    useAPIKey: true, // highlight-line\n  },\n  fields: [],\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Postgres Adapter via npm - Bash\nDESCRIPTION: This snippet demonstrates how to install the official Payload Postgres adapter package using npm. It is required as a dependency before adding Postgres support to your Payload project. Run this command in your project root. The adapter is necessary to enable Payload to communicate with a Postgres database backend.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/db-postgres/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/db-postgres\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Depth in Payload CMS Field Schema (JavaScript)\nDESCRIPTION: This JavaScript snippet provides an example schema configuration for a collection field in Payload CMS, demonstrating how to set a maximum allowed population depth using 'maxDepth'. The field is a relationship field named 'author' relating to the 'users' collection, and is limited to a max depth of 2, regardless of query request depth. Requires Payload CMS and familiarity with collection field configuration files. Inputs are collection/schema definitions; outputs are enforced depth limits for specific relational fields upon querying.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/depth.mdx#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n{\\n  slug: 'posts',\\n  fields: [\\n    {\\n      name: 'author',\\n      type: 'relationship',\\n      relationTo: 'users',\\n      maxDepth: 2, // highlight-line\\n    }\\n  ]\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Selecting and Excluding Fields with select Option - Payload CMS TypeScript\nDESCRIPTION: Illustrates how to use the select option in PayloadCMS Local API via TypeScript—first to include explicit fields and nested fields (include mode), and second to exclude specific fields (exclude mode). Requires the payload module and access to a Payload instance. The select property can deeply specify nested inclusions/exclusions for efficient querying. Expects a Payload instance as parameter and returns the queried post documents.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/select.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Payload } from 'payload'\n\n// Include mode\nconst getPosts = async (payload: Payload) => {\n  const posts = await payload.find({\n    collection: 'posts',\n    select: {\n      text: true,\n      // select a specific field from group\n      group: {\n        number: true,\n      },\n      // select all fields from array\n      array: true,\n    }, // highlight-line\n  })\n\n  return posts\n}\n\n// Exclude mode\nconst getPosts = async (payload: Payload) => {\n  const posts = await payload.find({\n    collection: 'posts',\n    // Select everything except for array and group.number\n    select: {\n      array: false,\n      group: {\n        number: false,\n      },\n    }, // highlight-line\n  })\n\n  return posts\n}\n```\n\n----------------------------------------\n\nTITLE: Example: Full Custom Slate Editor Integration for Collection - Payload CMS - TypeScript\nDESCRIPTION: Provides a full example of integrating and customizing the Slate editor on a collection's richText field. Defaults initial content, marks the field as required, and demonstrates how to pass custom elements (with custom buttons, elements, and plugins) and leaves (including a custom 'highlight' leaf). Shows injecting extra fields into the link modal and configuring upload modal meta fields per collection. Relies on external React components for custom UI (e.g., CustomCallToActionButton) and expects the developer to provide missing imports for these. Outputs rich text with custom behaviors serialized as JSON.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/slate.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nimport { slateEditor } from '@payloadcms/richtext-slate'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'content', // required\n      type: 'richText', // required\n      defaultValue: [\n        {\n          children: [{ text: 'Here is some default content for this field' }],\n        },\n      ],\n      required: true,\n      editor: slateEditor({\n        admin: {\n          elements: [\n            'h2',\n            'h3',\n            'h4',\n            'link',\n            'blockquote',\n            {\n              name: 'cta',\n              Button: CustomCallToActionButton,\n              Element: CustomCallToActionElement,\n              plugins: [\n                // any plugins that are required by this element go here\n              ],\n            },\n          ],\n          leaves: [\n            'bold',\n            'italic',\n            {\n              name: 'highlight',\n              Button: CustomHighlightButton,\n              Leaf: CustomHighlightLeaf,\n              plugins: [\n                // any plugins that are required by this leaf go here\n              ],\n            },\n          ],\n          link: {\n            // Inject your own fields into the Link element\n            fields: [\n              {\n                name: 'rel',\n                label: 'Rel Attribute',\n                type: 'select',\n                hasMany: true,\n                options: ['noopener', 'noreferrer', 'nofollow'],\n              },\n            ],\n          },\n          upload: {\n            collections: {\n              media: {\n                fields: [\n                  // any fields that you would like to save\n                  // on an upload element in the `media` collection\n                ],\n              },\n            },\n          },\n        },\n      }),\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Importing SEO Plugin TypeScript Types\nDESCRIPTION: This snippet demonstrates how to import specific TypeScript types from the `@payloadcms/plugin-seo/types` module. These types (`PluginConfig`, `GenerateTitle`, `GenerateDescription`, `GenerateURL`) are useful for defining plugin configurations or creating custom SEO metadata generation functions with type safety.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nimport type {\n  PluginConfig,\n  GenerateTitle,\n  GenerateDescription\n  GenerateURL\n} from '@payloadcms/plugin-seo/types';\n```\n\n----------------------------------------\n\nTITLE: Refreshing User Token with a GraphQL Mutation\nDESCRIPTION: Example GraphQL mutation `refreshToken[collection-singular-label]` (replace with actual label, e.g., `refreshTokenUser`) to refresh the JWT for the currently authenticated user. It requests the user's email and the newly refreshed token.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_10\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  refreshToken[collection-singular-label] {\n    user {\n      email\n    }\n    refreshedToken\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Server-Side Custom Feature in Payload Lexical (TypeScript)\nDESCRIPTION: Demonstrates the minimal setup for a custom server-side Lexical feature in Payload CMS using the `createServerFeature` helper function from `@payloadcms/richtext-lexical`. This basic feature (`MyFeature`) doesn't add any functionality yet but establishes the required structure and key ('myFeature').\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { createServerFeature } from '@payloadcms/richtext-lexical'\n\nexport const MyFeature = createServerFeature({\n  feature: {},\n  key: 'myFeature',\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Icon Component - React TSX\nDESCRIPTION: This snippet exports a minimal React functional component for rendering a brand/icon image. Use this as the custom icon in Payload CMS by referencing it in your config. Dependency: React. Input: none; Output: <img> with src set to your icon file. Should be small/square for best results.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_18\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyCustomIcon() {\\n  return <img src=\"/path/to/your/icon.png\" alt=\"My Custom Icon\" />\\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Task Handler as a Named Export in a Separate File (TypeScript)\nDESCRIPTION: This snippet defines a handler function for a Payload Task as a named export in its own TypeScript file ('src/tasks/createPost.ts'). The handler conforms to the 'TaskHandler' interface for the given task slug. When invoked, it uses the 'req.payload.create' method to create a post and returns its ID within the 'output' property. The function signature expects an object with 'input', 'job', and 'req'. This modular approach allows separation of concerns and supports external reference in the config. The handler can have its own typing and dependencies, and the output must be structured according to the 'outputSchema'.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/tasks.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { TaskHandler } from 'payload'\n\nexport const createPostHandler: TaskHandler<'createPost'> = async ({\n  input,\n  job,\n  req,\n}) => {\n  const newPost = await req.payload.create({\n    collection: 'post',\n    req,\n    data: {\n      title: input.title,\n    },\n  })\n  return {\n    output: {\n      postID: newPost.id,\n    },\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining saveToJWT Fields in PayloadCMS Collections (TypeScript)\nDESCRIPTION: Demonstrates how to configure a PayloadCMS collection to selectively store field data in JWT tokens using the saveToJWT property. Dependencies include PayloadCMS and its CollectionConfig TypeScript type. Key parameters are fields within the collection, with saveToJWT indicating if and how each field is serialized into the JWT. Inputs are the field configuration objects; outputs are the JWT contents derived from the config. Limitation: omitting saveToJWT or setting to false will exclude fields from the JWT.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/token-data.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Users: CollectionConfig = {\n  slug: 'users',\n  auth: true,\n  fields: [\n    {\n      // will be stored in the JWT\n      saveToJWT: true,\n      type: 'select',\n      name: 'role',\n      options: ['super-admin', 'user'],\n    },\n    {\n      // the entire object will be stored in the JWT\n      // tab fields can do the same thing!\n      saveToJWT: true,\n      type: 'group',\n      name: 'group1',\n      fields: [\n        {\n          type: 'text',\n          name: 'includeField',\n        },\n        {\n          // will be omitted from the JWT\n          saveToJWT: false,\n          type: 'text',\n          name: 'omitField',\n        },\n      ],\n    },\n    {\n      type: 'group',\n      name: 'group2',\n      fields: [\n        {\n          // will be stored in the JWT\n          // but stored at the top level\n          saveToJWT: true,\n          type: 'text',\n          name: 'includeField',\n        },\n        {\n          type: 'text',\n          name: 'omitField',\n        },\n      ],\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Global Entity - Payload CMS JavaScript\nDESCRIPTION: This snippet finds a global document (e.g., \"header\") in Payload using its slug. Options support deep population, localization, user context, and hidden fields. Primarily used for reading global, app-wide data outside normal collections.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_17\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Result will be the Header Global.\nconst result = await payload.findGlobal({\n  slug: 'header', // required\n  depth: 2,\n  locale: 'en',\n  fallbackLocale: false,\n  user: dummyUser,\n  overrideAccess: false,\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload with Postgres Adapter - TypeScript\nDESCRIPTION: The snippet shows how to configure PayloadCMS with the official Postgres adapter using TypeScript. It imports both the Payload buildConfig function and the postgresAdapter, then wires the adapter into the config, specifying the database connection string from an environment variable. This configuration enables Payload to store content in a Postgres database using a connection pool. The key parameter is 'connectionString', which should point to your Postgres instance; ensure the relevant environment variable (DATABASE_URI) is set. Expected input is a valid connection string, and the output is a Payload configuration set up for Postgres. Other config options for Payload can be added within the exported config object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/db-postgres/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { postgresAdapter } from '@payloadcms/db-postgres'\n\nexport default buildConfig({\n  db: postgresAdapter({\n    pool: {\n      connectionString: process.env.DATABASE_URI,\n    },\n  }),\n  // ...rest of config\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling the Gutter in PayloadCMS Rich Text Admin - TypeScript\nDESCRIPTION: Shows how to disable the gutter (left padding and vertical line) in the PayloadCMS rich text editor admin UI by setting the hideGutter property to true using the lexicalEditor configuration. The code assumes you are defining a field configuration within a Payload collection or global, with dependencies including the lexicalEditor function. When hideGutter is true, the field displays without the admin gutter.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/overview.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  name: 'richText',\n  type: 'richText',\n  editor: lexicalEditor({\n    admin: {\n      hideGutter: true\n    },\n  }),\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring S3 Storage Plugin in Payload CMS - TypeScript\nDESCRIPTION: Sets up the @payloadcms/storage-s3 plugin in a Payload CMS configuration to use AWS S3 as the storage backend for specified collections. Requires the Media and MediaWithPrefix collections to be defined and imported, AWS credentials to be set via environment variables, and the @aws-sdk/client-s3 library for S3ClientConfig. Key parameters include 'collections' (with per-collection options such as prefix), 'bucket', and AWS S3 client's configuration. The provided code disables local storage and supports direct client uploads (for Vercel).\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/storage-s3/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { s3Storage } from '@payloadcms/storage-s3'\nimport { Media } from './collections/Media'\nimport { MediaWithPrefix } from './collections/MediaWithPrefix'\n\nexport default buildConfig({\n  collections: [Media, MediaWithPrefix],\n  plugins: [\n    s3Storage({\n      collections: {\n        media: true,\n        'media-with-prefix': {\n          prefix,\n        },\n      },\n      bucket: process.env.S3_BUCKET,\n      config: {\n        credentials: {\n          accessKeyId: process.env.S3_ACCESS_KEY_ID,\n          secretAccessKey: process.env.S3_SECRET_ACCESS_KEY,\n        },\n        region: process.env.S3_REGION,\n        // ... Other S3 configuration\n      },\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Converting Lexical Blocks to HTML with Custom Converters in React\nDESCRIPTION: Illustrates how to handle custom Lexical blocks (both block and inline) during HTML conversion. It defines `htmlConverters` with specific functions for block slugs (`myTextBlock`, `myInlineBlock`) and passes these converters to `convertLexicalToHTML`. This allows tailoring the HTML output for custom rich text elements within a React component.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-html.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport type { MyInlineBlock, MyTextBlock } from '@/payload-types'\nimport type {\n  DefaultNodeTypes,\n  SerializedBlockNode,\n  SerializedInlineBlockNode,\n} from '@payloadcms/richtext-lexical'\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\n\nimport {\n  convertLexicalToHTML,\n  type HTMLConvertersFunction,\n} from '@payloadcms/richtext-lexical/html'\nimport React from 'react'\n\ntype NodeTypes =\n  | DefaultNodeTypes\n  | SerializedBlockNode<MyTextBlock>\n  | SerializedInlineBlockNode<MyInlineBlock>\n\nconst htmlConverters: HTMLConvertersFunction<NodeTypes> = ({\n  defaultConverters,\n}) => ({\n  ...defaultConverters,\n  blocks: {\n    // Each key should match your block's slug\n    myTextBlock: ({ node, providedCSSString }) =>\n      `<div style=\"background-color: red;${providedCSSString}\">${node.fields.text}</div>`,\n  },\n  inlineBlocks: {\n    // Each key should match your inline block's slug\n    myInlineBlock: ({ node, providedStyleTag }) =>\n      `<span${providedStyleTag}>${node.fields.text}</span$>`,\n  },\n})\n\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) => {\n  const html = convertLexicalToHTML({\n    converters: htmlConverters,\n    data,\n  })\n\n  return <div dangerouslySetInnerHTML={{ __html: html }} />\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying User Email using Payload's Local API in TypeScript\nDESCRIPTION: Shows how to verify a user's email programmatically using Payload's Local API method `payload.verifyEmail`. Requires specifying the collection slug and providing the unique verification token (`TOKEN_HERE`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = await payload.verifyEmail({\n  collection: 'collection-slug',\n  token: 'TOKEN_HERE',\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Client Config in a Client Component using useConfig Hook (TSX)\nDESCRIPTION: This snippet shows how a React Client Component (`'use client'`) can access a serializable version of the Payload configuration using the `useConfig` hook provided by `@payloadcms/ui`. This is necessary because the full config object is non-serializable and cannot be passed directly to Client Components.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { useConfig } from '@payloadcms/ui'\n\nexport function MyClientComponent() {\n  // highlight-start\n  const {\n    config: { serverURL },\n  } = useConfig()\n  // highlight-end\n\n  return <Link href={serverURL}>Go Home</Link>\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Sentry Plugin via PNPM\nDESCRIPTION: This command installs the Payload Sentry plugin package using the pnpm package manager. This adds the necessary dependency to the project to enable Sentry integration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/sentry.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @payloadcms/plugin-sentry\n```\n\n----------------------------------------\n\nTITLE: Configuring Live Preview URL for the Pages Collection (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates configuring the Live Preview feature within the `admin` settings of a 'Pages' collection in Payload CMS. The `livePreview.url` property is set to a function that dynamically generates the preview URL for a given page document (`data`) using its `slug` and the application's base URL from the `PAYLOAD_URL` environment variable.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// ./src/collections/Pages.ts\n{\n  // ...\n  admin: {\n    livePreview: {\n      url: ({ data }) => `${process.env.PAYLOAD_URL}/${data.slug}`\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a UI Field Configuration in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to declare a UI field using the Payload CMS Field type. The `type` property is set to 'ui', indicating the field is presentational only and rendered using a custom React component. Required dependencies include the 'payload' types for type-checking. This field is designed for direct insertion into a collection or global Field Config and does not impact stored document data. No additional properties are shown, but further configuration (like custom components) is available.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/ui.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyUIField: Field = {\n  // ...\n  type: 'ui', // highlight-line\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload CMS to Use Resend Email Adapter (TypeScript)\nDESCRIPTION: This snippet configures Payload CMS to use the Resend adapter for email functionality, ideal for serverless environments such as Vercel. The resendAdapter is supplied with sender details and the Resend API key, provided via RESEND_API_KEY environment variable. Dependencies: @payloadcms/email-resend must be installed, with RESEND_API_KEY set. The configuration outputs a Payload setup capable of sending email via the Resend service.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/email/overview.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { resendAdapter } from '@payloadcms/email-resend'\n\nexport default buildConfig({\n  email: resendAdapter({\n    defaultFromAddress: 'dev@payloadcms.com',\n    defaultFromName: 'Payload CMS',\n    apiKey: process.env.RESEND_API_KEY || '',\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Executing Auth REST Endpoints in PayloadCMS (JavaScript/REST)\nDESCRIPTION: This set of JavaScript/REST code snippets documents authentication endpoints in PayloadCMS, including login, logout, unlock, refresh token, user verification, password reset flows, and querying the current user. Each example specifies the HTTP method, endpoint path, a sample request (including body, credentials, and headers), and the intended structured JSON response. These endpoints require the 'user-collection' variable replaced with the specific collection name, and may need authentication headers or tokens. Requests handle user identity and password management workflows, while responses return user information and tokens as appropriate.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Auth Operation: Login\n{\n  operation: \"Login\",\n  method: \"POST\",\n  path: \"/api/{user-collection}/login\",\n  description: \"Logs in a user with email / password\",\n  example: {\n    slug: \"login\",\n    req: {\n      credentials: true,\n      headers: true,\n      body: {\n        email: \"dev@payloadcms.com\",\n        password: \"password\",\n      },\n    },\n    res: {\n      message: \"Auth Passed\",\n      user: {\n        id: \"644b8453cd20c7857da5a9b0\",\n        email: \"dev@payloadcms.com\",\n        _verified: true,\n        createdAt: \"2023-04-28T08:31:15.788Z\",\n        updatedAt: \"2023-04-28T11:11:03.716Z\",\n      },\n      token: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\",\n      exp: 1682689147,\n    },\n  },\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Auth Operation: Logout\n{\n  operation: \"Logout\",\n  method: \"POST\",\n  path: \"/api/{user-collection}/logout\",\n  description: \"Logs out a user\",\n  example: {\n    slug: \"logout\",\n    req: {\n      headers: true,\n      credentials: true,\n    },\n    res: {\n      message: \"You have been logged out successfully.\",\n    },\n  },\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Auth Operation: Unlock\n{\n  operation: \"Unlock\",\n  method: \"POST\",\n  path: \"/api/{user-collection}/unlock\",\n  description: \"Unlock a user account\",\n  example: {\n    slug: \"unlockCollection\",\n    req: {\n      credentials: true,\n      headers: true,\n      body: {\n        email: \"dev@payloadcms.com\",\n      },\n    },\n    res: {\n      message: \"Success\",\n    },\n  },\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Auth Operation: Refresh Token\n{\n  operation: \"Refresh\",\n  method: \"POST\",\n  path: \"/api/{user-collection}/refresh-token\",\n  description: \"Refreshes a token that has not yet expired\",\n  example: {\n    slug: \"refreshToken\",\n    req: {\n      credentials: true,\n      headers: true,\n    },\n    res: {\n      message: \"Token refresh successful\",\n      refreshedToken: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\",\n      exp: 1682689362,\n      user: {\n        email: \"dev@payloadcms.com\",\n        id: \"644b8453cd20c7857da5a9b0\",\n        collection: \"users\",\n      },\n    },\n  },\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Auth Operation: Verify User\n{\n  operation: \"Verify User\",\n  method: \"POST\",\n  path: \"/api/{user-collection}/verify/{token}\",\n  description: \"User verification\",\n  example: {\n    slug: \"verifyUser\",\n    req: {\n      credentials: true,\n      headers: true,\n    },\n    res: {\n      message: \"Email verified successfully.\",\n    },\n  },\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Auth Operation: Current User\n{\n  operation: \"Current User\",\n  method: \"GET\",\n  path: \"/api/{user-collection}/me\",\n  description: \"Returns the currently logged in user with token\",\n  example: {\n    slug: \"currentUser\",\n    req: {\n      credentials: true,\n      headers: true,\n    },\n    res: {\n      user: {\n        id: \"644b8453cd20c7857da5a9b0\",\n        email: \"dev@payloadcms.com\",\n        _verified: true,\n        createdAt: \"2023-04-28T08:31:15.788Z\",\n        updatedAt: \"2023-04-28T11:45:23.926Z\",\n        _strategy: \"local-jwt\",\n      },\n      collection: \"users\",\n      token: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\",\n      exp: 1682689523,\n    },\n  },\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Auth Operation: Forgot Password\n{\n  operation: \"Forgot Password\",\n  method: \"POST\",\n  path: \"/api/{user-collection}/forgot-password\",\n  description: \"Password reset workflow entry point\",\n  example: {\n    slug: \"forgotPassword\",\n    req: {\n      headers: true,\n      credentials: true,\n      body: {\n        email: \"dev@payloadcms.com\",\n      },\n    },\n    res: {\n      message: \"Success\",\n    },\n  },\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Auth Operation: Reset Password\n{\n  operation: \"Reset Password\",\n  method: \"POST\",\n  path: \"/api/{user-collection}/reset-password\",\n  description: \"Reset user password\",\n  example: {\n    slug: \"resetPassword\",\n    req: {\n      credentials: true,\n      headers: true,\n      body: {\n        token: \"7eac3830ffcfc7f9f66c00315dabeb11575dba91\",\n        password: \"newPassword\",\n      },\n    },\n    res: {\n      message: \"Password reset successfully.\",\n      token: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\",\n      user: {\n        id: \"644baa473ea9538765cc30fc\",\n        email: \"dev@payloadcms.com\",\n        _verified: true,\n        createdAt: \"2023-04-28T11:13:11.569Z\",\n        updatedAt: \"2023-04-28T11:49:23.860Z\",\n      },\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Extending JSON Schema for Custom Type Generation - Payload CMS - TypeScript\nDESCRIPTION: This snippet demonstrates extending the generated TypeScript types via a custom function under 'typescript.schema'. By modifying the JSON schema before type output (e.g., adding a 'Test' type definition), you can inject additional interfaces into your types file. The function should accept and return the JSON schema. This is useful for plugins and advanced customization.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/generating-types.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  typescript: {\n    schema: [\n      ({ jsonSchema }) => {\n        // Modify the JSON schema here\n        jsonSchema.definitions.Test = {\n          type: 'object',\n          properties: {\n            title: { type: 'string' },\n            content: { type: 'string' },\n          },\n          required: ['title', 'content'],\n        }\n        return jsonSchema\n      },\n    ]\n  }\n}\n\n// This will generate the following type in your payload-types.ts:\n\nexport interface Test {\n  title: string\n  content: string\n  [k: string]: unknown\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Payload CMS Configuration in TypeScript\nDESCRIPTION: This snippet demonstrates a minimal configuration for a Payload CMS application using the `buildConfig` function. It sets the application secret from an environment variable, configures the MongoDB database connection using `mongooseAdapter` with a connection URI from `process.env.DATABASE_URI`, and defines a simple 'pages' collection with a single 'title' text field. Requires `payload` and `@payloadcms/db-mongodb` packages, and expects `PAYLOAD_SECRET` and `DATABASE_URI` environment variables to be set.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { mongooseAdapter } from '@payloadcms/db-mongodb'\n\nexport default buildConfig({\n  secret: process.env.PAYLOAD_SECRET,\n  db: mongooseAdapter({\n    url: process.env.DATABASE_URI,\n  }),\n  collections: [\n    {\n      slug: 'pages',\n      fields: [\n        {\n          name: 'title',\n          type: 'text',\n        },\n      ],\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Receiving Custom Props in a Payload React Component (TSX)\nDESCRIPTION: This React component (`MyComponent`) shows how to receive and utilize a custom prop (`myCustomProp`) passed from the Payload configuration. The component renders a link (`Link`) with the custom prop as its text content.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { Link } from '@payloadcms/ui'\n\nexport function MyComponent({ myCustomProp }: { myCustomProp: string }) {\n  return <Link href=\"/admin/logout\">{myCustomProp}</Link>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Server-Side Refresh Client Component (TSX)\nDESCRIPTION: This TSX code defines a React client component (`RefreshRouteOnSave.tsx`) marked with `'use client'`. It imports and utilizes Payload's `RefreshRouteOnSave` component, providing it with Next.js's `router.refresh` function via the `useRouter` hook and the Payload server URL. This component bridges Payload's save events with Next.js's mechanism for refreshing server component data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n`RefreshRouteOnSave.tsx`:\n\n```tsx\n'use client'\nimport { RefreshRouteOnSave as PayloadLivePreview } from '@payloadcms/live-preview-react'\nimport { useRouter } from 'next/navigation.js'\nimport React from 'react'\n\nexport const RefreshRouteOnSave: React.FC = () => {\n  const router = useRouter()\n  return <PayloadLivePreview refresh={router.refresh} serverURL={process.env.PAYLOAD_SERVER_URL} />\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Running Payload with Bun and Disabled Transpile (Shell)\nDESCRIPTION: This command demonstrates running the Payload script with the Bun runtime, disabling Payload's built-in transpilation. The '--disable-transpile' flag is necessary for compatibility. Bun must be installed, and the use of this runtime is experimental and may not be fully supported by Payload.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/outside-nextjs.mdx#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nbunx --bun payload run src/seed.ts --disable-transpile\n```\n\n----------------------------------------\n\nTITLE: Installing the Form Builder Plugin via NPM (bash)\nDESCRIPTION: Installs the @payloadcms/plugin-form-builder package via pnpm, making it available to the project. This is a required dependency for using the Form Builder plugin. Can substitute pnpm with npm or yarn according to the package manager used in the development environment. No parameters or I/O except for standard package install behavior.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @payloadcms/plugin-form-builder\n```\n\n----------------------------------------\n\nTITLE: Creating a Payload App Example - Bash\nDESCRIPTION: This snippet demonstrates the use of the npx command to scaffold a new Payload CMS project utilizing the tailwind-shadcn-ui example template. Requires Node.js and npm installed globally. It accepts the '--example' argument with the template name to generate the initial codebase. Output is a ready-to-configure project directory based on the specified example.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/tailwind-shadcn-ui/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-payload-app --example tailwind-shadcn-ui\n```\n\n----------------------------------------\n\nTITLE: Uploading Files via REST API using FormData - Payload CMS - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to upload files to a Payload CMS collection using a browser FormData object with a REST API. It illustrates building the FormData with a file field and a '_payload' field containing additional metadata (e.g., title, description) JSON-stringified. The fetch call targets the collection's endpoint with POST, relying on the browser to set the correct Content-Type. Inputs include the file input element and optional metadata fields; the output is the server's API response. Requires access to a file input DOM element and assumes a REST endpoint at 'api/:upload-slug'. Do not manually set the Content-Type header, as browsers handle it.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/overview.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst fileInput = document.querySelector('#your-file-input')\nconst formData = new FormData()\n\nformData.append('file', fileInput.files[0])\n\n// Replace with the fields defined in your upload-enabled collection.\n// The example below includes an optional field like 'title'.\nformData.append(\n  '_payload',\n  JSON.stringify({\n    title: 'Example Title',\n    description: 'An optional description for the file',\n  }),\n)\n\nfetch('api/:upload-slug', {\n  method: 'POST',\n  body: formData,\n  /**\n   * Do not manually add the Content-Type Header\n   * the browser will handle this.\n   *\n   * headers: {\n   *  'Content-Type': 'multipart/form-data'\n   * }\n   */\n})\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Refresh Token Button React Client Component (TSX)\nDESCRIPTION: Provides a React client component (`RefreshTokenButton`) that renders a button. Clicking the button triggers the `refreshAction` server function to refresh the user's authentication token. Requires the `refreshAction` server function defined elsewhere (e.g., `../actions/refreshAction`). Note: The original example code calls `refreshFunction()`, which is likely a typo and should be `refreshAction()`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\n\nimport { refreshAction } from '../actions/refreshAction' // Path to the server action\n\nexport default function RefreshTokenButton() {\n  const handleRefresh = async () => {\n    try {\n      await refreshAction();\n      // Handle successful refresh (e.g., update UI state if needed)\n    } catch (error) {\n      // Handle refresh error\n      console.error(error);\n    }\n  };\n\n  return <button onClick={handleRefresh}>Refresh</button>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Diff Component in Payload Field (TypeScript)\nDESCRIPTION: Shows configuring a custom `Diff` component for a 'text' field via the `admin.components.Diff` property in Payload. This component is used in the Version Diff view for collections with versioning enabled to show changes between versions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_30\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const myField: Field = {\n  name: 'myField',\n  type: 'text',\n  admin: {\n    components: {\n      Diff: '/path/to/MyCustomDiffComponent', // highlight-line\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Current Locale in a Server Component (TSX)\nDESCRIPTION: This code illustrates how a Server Component in Payload, particularly within a Custom View, receives the current `locale` object as a prop. This locale can then be used in API requests, like `payload.findByID`, to fetch locale-specific data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\n\nexport default async function MyServerComponent({ payload, locale }) {\n  const localizedPage = await payload.findByID({\n    collection: 'pages',\n    id: '123',\n    locale,\n  })\n\n  return <p>{localizedPage.title}</p>\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Local Documentation into Payload Website\nDESCRIPTION: Command to run within the Payload website repository after setting the `DOCS_DIR` environment variable. This command processes the documentation files from the specified local path and integrates them into the website build.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nyarn run fetchDocs:local\n```\n\n----------------------------------------\n\nTITLE: Running Payload Script with SWC Transpiler (Shell)\nDESCRIPTION: This command executes the Payload seed script with SWC transpilation enabled for improved speed. You must have '@swc-node/register' installed. SWC can cause issues with some imports but is generally faster than the default transpiler.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/outside-nextjs.mdx#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\npayload run src/seed.ts --use-swc\n```\n\n----------------------------------------\n\nTITLE: Importing Payload GlobalConfig Types - TypeScript\nDESCRIPTION: This snippet demonstrates how to import the 'GlobalConfig' and 'SanitizedGlobalConfig' types from the 'payload' package, which assist in type-safe configuration of global settings within a Payload CMS project. These types distinguish between raw and fully sanitized global configuration objects, encouraging the use of TypeScript for robust configuration. The import assumes the availability of the 'payload' package within the project dependencies.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/globals.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalConfig, SanitizedGlobalConfig } from 'payload'\\n\n```\n\n----------------------------------------\n\nTITLE: Updating a Document by ID via Payload REST API\nDESCRIPTION: Performs a PATCH request to update a single document within a specific collection using its unique ID. Requires necessary authentication headers and a request body containing the fields to update.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_5\n\nLANGUAGE: HTTP\nCODE:\n```\nPATCH /api/{collection-slug}/{id}\n```\n\n----------------------------------------\n\nTITLE: Rendering Live Preview Refresh Component with Next.js and PayloadCMS - TypeScript React\nDESCRIPTION: This TypeScript React snippet demonstrates rendering the RefreshRouteOnSave component within a Next.js page. It fetches page data via getPayload, then renders both the refresh component and page content. Dependencies include @payloadcms/live-preview-react for RefreshRouteOnSave and the PayloadCMS Local API. The key parameters involve configuration and data loading for collection 'pages', and the setup ensures the route will refresh on document save events, providing the latest preview data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/server.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RefreshRouteOnSave } from './RefreshRouteOnSave.tsx'\nimport { getPayload } from 'payload'\nimport config from '../payload.config'\n\nexport default async function Page() {\n  const payload = await getPayload({ config })\n\n  const page = await payload.findByID({\n    collection: 'pages',\n    id: '123',\n    draft: true,\n  })\n\n  return (\n    <Fragment>\n      <RefreshRouteOnSave />\n      <h1>{page.title}</h1>\n    </Fragment>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Static Live Preview URL in Payload Config\nDESCRIPTION: This snippet demonstrates how to set a static URL for the Live Preview iframe source within the Payload CMS configuration. The `url` property within `admin.livePreview` is assigned a fixed string pointing to the front-end application's address.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/overview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    // ...\n    livePreview: {\n      url: 'http://localhost:3000', // highlight-line\n      collections: ['pages'],\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Filename with beforeOperation Hook in Payload CMS TypeScript\nDESCRIPTION: This snippet shows how to use a 'beforeOperation' hook within a Payload CMS collection configuration to dynamically set a custom filename before the file is saved. It checks if the operation is 'create' or 'update' and if a file exists on the request object ('req.file'), then modifies 'req.file.name'. This allows for programmatic control over filenames based on request data or other logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/overview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nbeforeOperation: [\n  ({ req, operation }) => {\n    if ((operation === 'create' || operation === 'update') && req.file) {\n      req.file.name = 'test.jpg'\n    }\n  },\n],\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring List View Pagination in PayloadCMS - TypeScript\nDESCRIPTION: Shows how to set default and selectable per-page limits for paginated list views in a PayloadCMS collection using the admin.pagination property. Requires a valid Payload CollectionConfig and ensures the list view can be customized by setting values for 'defaultLimit' and selectable 'limits'. Parameters include 'defaultLimit' for the default number of items per page and 'limits' as an array of allowed page sizes. Returns a modified collection config enabling admins to control pagination behavior in the dashboard.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/collections.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Posts: CollectionConfig = {\n  // ...\n  admin: {\n    // highlight-start\n    pagination: {\n      defaultLimit: 10,\n      limits: [10, 20, 50],\n    },\n    // highlight-end\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering Data Refetch with setParams from usePayloadAPI\nDESCRIPTION: This snippet shows how to use the `setParams` function, returned by the `usePayloadAPI` hook, to update request parameters. Calling `setParams` with new parameters (e.g., `{ depth: 2 }`) will trigger a refetch of the data from the API endpoint associated with the hook.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\nsetParams({ depth: 2 })\n```\n\n----------------------------------------\n\nTITLE: Creating a Client Feature with a Custom Node (TypeScript)\nDESCRIPTION: Shows how to include custom Lexical nodes within a client feature. The `createClientFeature` function accepts a configuration object with a `nodes` array. This example registers `MyNode` (imported from './nodes/MyNode') to make it available in the rich text editor on the client side.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n'use client'\n\nimport { createClientFeature } from '@payloadcms/richtext-lexical/client'\nimport { MyNode } from './nodes/MyNode'\n\nexport const MyClientFeature = createClientFeature({\n  nodes: [MyNode],\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a beforeOperation Collection Hook (TypeScript)\nDESCRIPTION: Provides a template for a `beforeOperation` hook function in Payload CMS using TypeScript. This hook executes before a collection operation begins (e.g., `create`, `read`, `update`, `delete`), receives arguments like `args`, `operation`, and `req`, and can modify the operation arguments or perform side effects.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionBeforeOperationHook } from 'payload'\n\nconst beforeOperationHook: CollectionBeforeOperationHook = async ({\n  args,\n  operation,\n  req,\n}) => {\n  return args // return modified operation arguments as necessary\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload CMS with SQLite Adapter (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates importing `buildConfig` from Payload and `sqliteAdapter` from the installed package. It configures Payload to use the SQLite adapter by passing it to the `db` property in `buildConfig`, specifying the database connection URL via the `DATABASE_URI` environment variable. This setup integrates SQLite as the database backend for the Payload CMS application.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/db-sqlite/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload/config'\nimport { sqliteAdapter } from '@payloadcms/db-sqlite'\n\nexport default buildConfig({\n  db: sqliteAdapter({\n    client: {\n      url: process.env.DATABASE_URI,\n    },\n  }),\n  // ...rest of config\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Payload CMS Example Project via CLI (Shell)\nDESCRIPTION: This shell command initializes a new Payload CMS project from one of the available example templates. It requires Node.js and the 'npx' tool to be installed and uses the 'create-payload-app' CLI. The '--example' parameter must be set to the desired example name, such as 'auth' or 'form-builder'. Running this command will scaffold a new project with the selected example pre-configured. The command does not support choosing multiple examples simultaneously and must be run from a shell that supports npx.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/examples/overview.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpx create-payload-app --example example_name\n```\n\n----------------------------------------\n\nTITLE: Querying Tenant-Specific Data using Payload Find Operation\nDESCRIPTION: Shows how to fetch documents from a collection ('pages') filtered by a specific tenant using the Payload `find` operation, typically in a server-side or API context. It uses a `where` clause to match the `tenant.slug` field against a specific value ('gold'), demonstrating how applications can retrieve data relevant only to the current tenant. Assumes a `tenants` collection with a `slug` field exists and that the `payload` client is correctly initialized.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/multi-tenant.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst pagesBySlug = await payload.find({\n  collection: 'pages',\n  depth: 1,\n  draft: false,\n  limit: 1000,\n  overrideAccess: false,\n  where: {\n    // your constraint would depend on the\n    // fields you added to the tenants collection\n    // here we are assuming a slug field exists\n    // on the tenant collection, like in the example above\n    'tenant.slug': {\n      equals: 'gold',\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Querying Local Data with Locale in Payload Local API (JavaScript)\nDESCRIPTION: Illustrates fetching documents with specified locale and fallback behavior using the Payload CMS Local API in JavaScript/Node.js. Requires the 'payload' library instance and appropriate setup. The 'find' method accepts 'collection', 'locale', and 'fallbackLocale' within its options; 'fallbackLocale' as false disables fallback. Returns asynchronous results containing localized post data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/localization.mdx#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst posts = await payload.find({\n  collection: 'posts',\n  locale: 'es',\n  fallbackLocale: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a me Collection Hook in TypeScript\nDESCRIPTION: This snippet illustrates the definition of a `me` hook for an Auth-enabled Payload Collection. This hook enables customization or replacement of the default `me` operation (fetching the currently authenticated user's data). Returning a value from this hook prevents Payload's default `me` logic from executing. It receives `args` (operation arguments) and the `user` object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionMeHook } from 'payload'\n\nconst meHook: CollectionMeHook = async ({\n  args,\n  user,\n}) => {...}\n```\n\n----------------------------------------\n\nTITLE: Deleting Documents via Payload REST API\nDESCRIPTION: Performs a DELETE request to delete multiple documents within a specific collection that match a given 'where' query parameter. Requires necessary authentication headers.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_6\n\nLANGUAGE: HTTP\nCODE:\n```\nDELETE /api/{collection-slug}\n```\n\n----------------------------------------\n\nTITLE: Implementing a beforeChange Hook for Payload CMS Global - TypeScript\nDESCRIPTION: This snippet implements a 'beforeChange' hook used during the update operation for a global in Payload CMS. It accepts the new data, web request, and original document to modify the data prior to persistence, after it has been validated. Integration requires importing the appropriate hook type from 'payload' and returning the transformed data. All parameters provided must be considered for any transformation, and the returned value must represent the data ready to save.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/globals.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalBeforeChangeHook } from 'payload'\n\nconst beforeChangeHook: GlobalBeforeChangeHook = async ({\n  data,\n  req,\n  originalDoc,\n}) => {\n  return data\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Edit View Client Component (TSX)\nDESCRIPTION: Example of a custom React client component ('use client' directive) intended to replace the default Payload Edit View. It receives `DocumentViewClientProps` and renders custom interactive content. This component complements the server component for a complete custom view.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport React from 'react'\nimport type { DocumentViewClientProps } from 'payload'\n\nexport function MyCustomClientEditView(props: DocumentViewClientProps) {\n  return <div>This is a custom Edit View (Client)</div>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Email Field Label Client Component in Payload CMS (TSX)\nDESCRIPTION: This snippet shows how to create a custom React Client Component (using `'use client'`) for an Email field's label. Similar to the server component version, it utilizes the `FieldLabel` from `@payloadcms/ui`, configuring its `label`, `path`, and `required` props based on the passed `field` prop. This allows for client-side customization or interactivity related to the field label.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/email.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { EmailFieldLabelClientComponent } from 'payload'\n\nexport const CustomEmailFieldLabelClient: EmailFieldLabelClientComponent = ({\n  field,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={field?.label || field?.name}\n      path={path}\n      required={field?.required}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Payload Admin Bar via pnpm - Bash\nDESCRIPTION: This snippet shows how to install the @payloadcms/admin-bar package using pnpm. The command downloads and adds the admin bar component to your project's dependencies, making it available for import and use within your application. Requires pnpm as a package manager and an existing Node.js project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/admin-bar/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm i @payloadcms/admin-bar\n```\n\n----------------------------------------\n\nTITLE: Initializing a New Payload Project using PNPM\nDESCRIPTION: This command utilizes `pnpx`, the package runner bundled with pnpm, to execute the `create-payload-app` scaffolding tool at its latest version. It initiates the setup process for a new Payload CMS project. Prerequisites include having Node.js and pnpm installed. The surrounding text recommends appending `-t website` for beginners to use the website template.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/payload/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\npnpx create-payload-app@latest\n```\n\n----------------------------------------\n\nTITLE: Accessing Auto-Generated Collection GraphQL Types (TypeScript)\nDESCRIPTION: Displays the structure of the `graphQL` object available on a Payload collection definition (e.g., `payload.collections.slug.graphQL`). This object provides access to various GraphQL types automatically generated by Payload for the collection, such as the main object type, paginated type, input types, etc., facilitating reuse in custom extensions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/extending.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ngraphQL?: {\n  type: GraphQLObjectType\n  paginatedType: GraphQLObjectType\n  JWT: GraphQLObjectType\n  versionType: GraphQLObjectType\n  whereInputType: GraphQLInputObjectType\n  mutationInputType: GraphQLNonNull<any>\n  updateMutationInputType: GraphQLNonNull<any>\n}\n```\n\n----------------------------------------\n\nTITLE: Importing the Payload Refresh Function in TypeScript\nDESCRIPTION: Imports the `refresh` function from the `@payloadcms/next/auth` package. This function is used to refresh the authentication token for the currently logged-in user.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { refresh } from '@payloadcms/next/auth'\n```\n```\n\n----------------------------------------\n\nTITLE: Sample Seed Function for Payload Data (TypeScript)\nDESCRIPTION: Defines an asynchronous seed function to programmatically insert data (a collection document) in the Payload CMS. Utilizes the Payload API for logging and document creation. Dependency: Payload CMS, TypeScript. Expects a valid payload instance. Outputs a new document to the 'new-collection' collection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const seed = async (payload: Payload): Promise<void> => {\n  payload.logger.info('Seeding data...')\n\n  await payload.create({\n    collection: 'new-collection',\n    data: {\n      title: 'Seeded title',\n    },\n  })\n\n  // Add additional seed data here\n}\n\n```\n\n----------------------------------------\n\nTITLE: Starting Development Server (Shell)\nDESCRIPTION: These shell commands are used to start the Payload development server, depending on the package manager used (pnpm, yarn, or npm). The specific command invokes the 'dev' script defined in the project's `package.json`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/custom-components/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npnpm dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Example Conventional Commit Messages for Payload\nDESCRIPTION: Illustrates the format for commit messages according to the Conventional Commits specification used in the Payload project. Examples show different commit types (`feat`, `fix`, `docs`, `chore`). `feat` and `fix` commits are automatically included in the changelog.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n- feat: adds new feature\n- fix: fixes bug\n- docs: adds documentation\n- chore: does chore\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server (Shell)\nDESCRIPTION: Starts the development server using pnpm, yarn, or npm, depending on the package manager used in the project. This typically runs Payload and the Next.js front-end concurrently, often including database seeding on the first run (if configured in the `dev` script).\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/form-builder/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Accessing Client-Side Environment Variables in a Next.js Component (TSX)\nDESCRIPTION: Shows how to access a public environment variable (prefixed with `NEXT_PUBLIC_`) using `process.env` within a React client component marked with `'use client'`. This requires the variable to be correctly defined and exposed by the Next.js build process. It's crucial to only expose non-sensitive information this way.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/environment-vars.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\n\nconst stripeKey = process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY // highlight-line\n\nconst MyClientComponent = () => {\n  // do something with the key\n\n  return <div>My Client Component</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Postgres Directly within a Migration Transaction (TypeScript)\nDESCRIPTION: Shows how to execute raw SQL queries directly against a Postgres database within a Payload migration's `up` function, utilizing the active transaction. It imports `MigrateUpArgs` and the `sql` tag function from `@payloadcms/db-postgres`. The `up` function receives the `db` object (representing the database client within the transaction) along with `payload` and `req`. Direct SQL queries are executed using `db.execute()` with the `sql` template literal tag, ensuring they run within the migration's transaction.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { type MigrateUpArgs, sql } from '@payloadcms/db-postgres'\n\nexport async function up({ db, payload, req }: MigrateUpArgs): Promise<void> {\n  const { rows: posts } = await db.execute(sql`SELECT * from posts`)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload CMS to Use Slate Editor (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to import and integrate the 'slateEditor' plugin from '@payloadcms/richtext-slate' into a Payload CMS configuration. It shows usage of the 'buildConfig' function, passing 'slateEditor' to the 'editor' property. Required dependencies are 'payload' and '@payloadcms/richtext-slate'; TypeScript support is expected. Inputs consist of the configuration object, and the output is the Payload CMS configuration, with the Slate Rich Text Editor enabled.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/richtext-slate/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { slateEditor } from '@payloadcms/richtext-slate'\n\nexport default buildConfig({\n  editor: slateEditor({}),\n  // ...rest of config\n})\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Payload Collection - TypeScript\nDESCRIPTION: Defines a sample collection schema for Payload CMS using TypeScript. It imports the CollectionConfig type and specifies a single required text field called 'pageTitle'. No external code dependencies are required other than Payload's core types. The slug and field attributes configure how the collection is stored and rendered in Payload. Input is defined via the admin interface, output is managed by the CMS backend, with validation enforcing field requirements.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/text.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\\n\\nexport const ExampleCollection: CollectionConfig = {\\n  slug: 'example-collection',\\n  fields: [\\n    {\\n      name: 'pageTitle', // required\\n      type: 'text', // required\\n      required: true,\\n    },\\n  ],\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Configuring package.json Scripts for Payload Postgres Migrations in CI (JavaScript)\nDESCRIPTION: This snippet shows example `package.json` scripts for a Payload CMS project using Next.js and Postgres. It includes scripts for development (`dev`), production builds (`build`), accessing the Payload CLI (`payload`), and a Continuous Integration (`ci`) script that runs migrations (`payload migrate`) before building the application (`pnpm build`). This setup ensures the production database schema is updated before deploying new code. Requires Node.js, pnpm, cross-env, payload, and next dependencies.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_12\n\nLANGUAGE: js\nCODE:\n```\n  \"scripts\": {\n    // For running in dev mode\n    \"dev\": \"next dev --turbo\",\n\n    // To build your Next + Payload app for production\n    \"build\": \"next build\",\n\n    // A \"tie-in\" to Payload's CLI for convenience\n    // this helps you run `pnpm payload migrate:create` and similar\n    \"payload\": \"cross-env NODE_OPTIONS=--no-deprecation payload\",\n\n    // This command is what you'd set your `build script` to.\n    // Notice how it runs `payload migrate` and then `pnpm build`?\n    // This will run all migrations for you before building, in your CI,\n    // against your production database\n    \"ci\": \"payload migrate && pnpm build\",\n  },\n```\n\n----------------------------------------\n\nTITLE: Linking Virtual Fields with Relationships in PayloadCMS (TypeScript)\nDESCRIPTION: Demonstrates how to link a virtual field ('categoryTitle') to a related document's field ('category.title') in PayloadCMS using TypeScript syntax. The configuration includes two collections: 'categories' (with a simple 'title' text field), and 'posts' (which has a relationship to 'categories' and a virtual field for the category title). The virtual field is auto-populated regardless of query depth, but only works for non-polymorphic, disabled 'hasMany' relationships. Input: data for collections. Output: populated virtual field. Requires PayloadCMS 2.x or later.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_13\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  collections: [\n    {\n      slug: 'categories',\n      fields: [\n        {\n          name: 'title',\n          type: 'text',\n        },\n      ],\n    },\n    {\n      slug: 'posts',\n      fields: [\n        {\n          type: 'relationship',\n          name: 'category',\n          relationTo: 'categories',\n        },\n        {\n          type: 'text',\n          name: 'categoryTitle',\n          virtual: 'category.title',\n        },\n      ],\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Uploadthing Storage Plugin in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to set up the uploadthingStorage plugin within Payload CMS by modifying the configuration file. The 'collections' object specifies which collections should utilize Uploadthing storage, and must match the slug of an upload-type collection. The 'options' object requires an Uploadthing API token (retrieved via environment variable), and sets the access control level (acl). Additional configuration such as 'clientUploads' can be provided for environments with upload size restrictions. The configuration exports the Payload build using buildConfig and integrates all required plugins and options.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/storage-uploadthing/README.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nexport default buildConfig({\n  collections: [Media],\n  plugins: [\n    uploadthingStorage({\n      collections: {\n        media: true,\n      },\n      options: {\n        token: process.env.UPLOADTHING_TOKEN,\n        acl: 'public-read',\n      },\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating a Custom Storage Adapter in Payload CMS (TypeScript)\nDESCRIPTION: Example TypeScript code showing how to use the `cloudStorage` plugin (from `@payloadcms/plugin-cloud-storage`) within the Payload CMS `buildConfig`. It demonstrates configuring the plugin to use a custom adapter (`theAdapterToUse`) for a specific collection (`my-collection-slug`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_12\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\nimport { cloudStoragePlugin } from '@payloadcms/plugin-cloud-storage'\n\nexport default buildConfig({\n  plugins: [\n    cloudStorage({\n      collections: {\n        'my-collection-slug': {\n          adapter: theAdapterToUse, // see docs for the adapter you want to use\n        },\n      },\n    }),\n  ],\n  // The rest of your config goes here\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Refreshing User Token via REST API using Fetch in TypeScript\nDESCRIPTION: Shows how to refresh an expiring JWT using the `fetch` API by sending a POST request to the `/api/[collection-slug]/refresh-token` endpoint for an authenticated user. The expected JSON response containing the user data and the new token is also shown.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await fetch(\n  'http://localhost:3000/api/[collection-slug]/refresh-token',\n  {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  },\n)\n\nconst json = await res.json()\n\n// JSON will be equal to the following:\n/*\n{\n  user: {\n    email: 'dev@payloadcms.com',\n    createdAt: \"2020-12-27T21:16:45.645Z\",\n    updatedAt: \"2021-01-02T18:37:41.588Z\",\n    id: \"5ae8f9bde69e394e717c8832\"\n  },\n  refreshedToken: '34o4345324...',\n  exp: 1609619861\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Defining a beforeRead Hook for Payload CMS Global - TypeScript\nDESCRIPTION: This code defines a 'beforeRead' hook for a global document in Payload CMS that alters the document before it is transformed and output. The hook receives the full, unstripped document and the request context, which can be used to customize, filter, or enforce security on fields prior to localization or field removal. The snippet requires the 'payload' types and asynchronous function support. Output must return the possibly modified document for further processing.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/globals.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalBeforeReadHook } from 'payload'\n\nconst beforeReadHook: GlobalBeforeReadHook = async ({\n  doc,\n  req,\n}) => {...}\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Website Development Server\nDESCRIPTION: Command to start the local development server for the Payload website repository. This allows previewing documentation changes in a browser after fetching them using `yarn run fetchDocs:local`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nyarn run dev\n```\n\n----------------------------------------\n\nTITLE: Opening Payload Admin Panel in Browser (Shell)\nDESCRIPTION: Opens the default web browser to the Payload CMS admin panel, usually accessible at the `/admin` path relative to the base URL (`http://localhost:3000/admin` during development).\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/form-builder/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nopen http://localhost:3000/admin\n```\n\n----------------------------------------\n\nTITLE: Injecting Custom Components After the Login Form (TypeScript)\nDESCRIPTION: Illustrates the use of afterLogin property within admin.components to show custom components following the built-in Login form. Add desired React component paths (as strings). Requires Payload CMS and is useful for supplemental content like help links or policies.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  admin: {\n    // highlight-start\n    components: {\n      afterLogin: ['/path/to/your/component'],\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring a GlobalConfig in Payload (TypeScript)\nDESCRIPTION: Illustrates configuring a GlobalConfig with fields for Payload CMS. Requires Payload and TypeScript. By specifying the slug and fields, GraphQL queries and mutation for the singular global entity are generated. Inputs are field definitions, outputs are GraphQL operations for the global resource. This snippet assumes that the ellipsis represents the actual field configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/overview.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalConfig } from 'payload';\\n\\nconst Header: GlobalConfig = {\\n  slug: 'header',\\n  fields: [\\n    ...\\n  ],\\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Payload Dev Server (CLI Usage)\nDESCRIPTION: Runs the Payload development server locally so developers can access the dev project in their browser. Assumes prior setup of the dev environment and that pnpm is installed. Outputs a running Payload instance at http://localhost:3000.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Starting the Production Server (Shell)\nDESCRIPTION: Starts the Node.js server in production mode using pnpm or npm. This command serves the pre-built application, including the Payload backend and the Next.js front-end, from the optimized build artifacts.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/form-builder/README.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\npnpm start\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Creating Payload Project from Draft Preview Example (Shell)\nDESCRIPTION: This command uses `npx` to execute the `create-payload-app` CLI tool. It initializes a new Payload CMS project by cloning and setting up the specific `draft-preview` example template from the official Payload examples repository.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/draft-preview/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx create-payload-app --example draft-preview\n```\n\n----------------------------------------\n\nTITLE: Defining a Collection with a Required Code Field - TypeScript\nDESCRIPTION: Provides a complete example of declaring a CollectionConfig containing a required Code Field with admin UI options, in TypeScript. Requires the 'payload' package and CollectionConfig import. The example shows how to name a field ('trackingCode'), make it required, and specify UI language for code editing. Inputs are the collection config properties; the output is a configuration object for Payload.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/code.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'trackingCode', // required\n      type: 'code', // required\n      required: true,\n      admin: {\n        language: 'javascript',\n      },\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Edit View Elements in Payload CMS - TypeScript\nDESCRIPTION: This snippet shows how to define a sanitized global configuration object in Payload CMS by extending the admin components/elements section, allowing developers to override or add custom elements within the Edit View. It demonstrates the use of the 'SanitizedGlobalConfig' type from the Payload package and underscores the modularity and extensibility of Payload's admin UI through TypeScript typing. Dependencies include the 'payload' package for type definitions, and the key property is the 'admin.components.elements' object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/globals.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { SanitizedGlobalConfig } from 'payload'\\n\\nexport const MyGlobal: SanitizedGlobalConfig = {\\n  // ...\\n  admin: {\\n    components: {\\n      elements: {\\n        // highlight-line\\n        // ...\\n      },\\n    },\\n  },\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Dropping Database and Re-running Payload Migrations (Shell)\nDESCRIPTION: Provides the command-line instruction to completely drop all tables/collections managed by Payload from the database and then execute all migrations from scratch. This is a destructive operation useful for development or testing environments.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_11\n\nLANGUAGE: text\nCODE:\n```\nnpm run payload migrate:fresh\n```\n\n----------------------------------------\n\nTITLE: Appending Tables to Schema with beforeSchemaInit and Drizzle Imports (TypeScript)\nDESCRIPTION: Explains how to append existing Drizzle ORM tables—imported from a schema file generated via introspection—to the adapter schema using the `beforeSchemaInit` hook in PayloadCMS. Ensures legacy or third-party tables are injected before Payload schema management, preventing table drops and enabling hybrid database management. Expects familiarity with Drizzle, Drizzle schema file structure, and Payload's adapter API.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/sqlite.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { sqliteAdapter } from '@payloadcms/db-sqlite'\nimport { users, countries } from '../drizzle/schema'\n\nsqliteAdapter({\n  beforeSchemaInit: [\n    ({ schema, adapter }) => {\n      return {\n        ...schema,\n        tables: {\n          ...schema.tables,\n          users,\n          countries,\n        },\n      }\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server (Bash)\nDESCRIPTION: These commands (`pnpm dev`, `yarn dev`, `npm run dev`) start the Payload CMS development server using the specified package manager (pnpm, yarn, or npm). This typically enables hot-reloading and other development features.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev`, `yarn dev` or `npm run dev\n```\n\n----------------------------------------\n\nTITLE: Copying Website Environment Configuration (Shell)\nDESCRIPTION: This shell command copies the example environment file (`.env.example`) to a new file (`.env`) within the `./website` directory. This `.env` file is used to configure the Remix website application with its specific environment variables. This step is necessary before running the website application.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/remix/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncp ./website/.env.example ./website/.env\n```\n\n----------------------------------------\n\nTITLE: Simple Before Login React Component (TSX)\nDESCRIPTION: Presents a straightforward React component for use directly before the default login form in Payload Admin. Outputs a message in a div and requires no parameters. Add this to beforeLogin array in the configuration for pre-login customizations or instructions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyBeforeLoginComponent() {\n  return <div>This is a custom component injected before the Login form.</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Payload Live Preview Hook for React using npm - Bash\nDESCRIPTION: This snippet demonstrates how to install the '@payloadcms/live-preview-react' package via npm. This package provides the official Payload CMS 'useLivePreview' React hook, required for enabling live content synchronization in client-side React apps. No runtime parameters are needed beyond the command, and this must be executed in your project's root directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/client.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/live-preview-react\n```\n\n----------------------------------------\n\nTITLE: Configuring Next.js for Standalone Output in JavaScript\nDESCRIPTION: This JavaScript snippet shows how to modify the `next.config.js` file to set the `output` property to `'standalone'`. This configuration optimizes the Next.js build for deployment, particularly in containerized environments like Docker, by creating a self-contained application folder.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/production/deployment.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// next.config.js\nconst nextConfig = {\n  output: 'standalone',\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Schema After Initialization Using extendTable in Payload (TypeScript)\nDESCRIPTION: This example uses the afterSchemaInit hook on the Postgres adapter within a Payload CMS buildConfig to augment an existing table ('places'). It demonstrates adding a new integer column and a composite index spanning two columns via the extendTable utility. Dependencies include @payloadcms/db-postgres, Drizzle's pg-core, and Payload's buildConfig utility. Inputs are the constructed schema, an extendTable function, and the database adapter. Returns the updated schema for use by Payload. Ensure column and index names do not clash with built-in Payload definitions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/postgres.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { postgresAdapter } from '@payloadcms/db-postgres'\nimport { index, integer } from '@payloadcms/db-postgres/drizzle/pg-core'\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  collections: [\n    {\n      slug: 'places',\n      fields: [\n        {\n          name: 'country',\n          type: 'text',\n        },\n        {\n          name: 'city',\n          type: 'text',\n        },\n      ],\n    },\n  ],\n  db: postgresAdapter({\n    afterSchemaInit: [\n      ({ schema, extendTable, adapter }) => {\n        extendTable({\n          table: schema.tables.places,\n          columns: {\n            extraIntegerColumn: integer('extra_integer_column'),\n          },\n          extraConfig: (table) => ({\n            country_city_composite_index: index(\n              'country_city_composite_index',\n            ).on(table.country, table.city),\n          }),\n        })\n\n        return schema\n      },\n    ],\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Payload Form Builder Plugin in Payload Config (TypeScript)\nDESCRIPTION: Demonstrates how to configure PayloadCMS to use the Form Builder plugin in the plugins array in a TypeScript project. This snippet imports required modules and applies the plugin to the project configuration, enabling form management features. The plugin can accept a configuration object for customization. Exports the configured PayloadCMS object for use as the main app entry point.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { formBuilderPlugin } from '@payloadcms/plugin-form-builder'\n\nconst config = buildConfig({\n  collections: [\n    {\n      slug: 'pages',\n      fields: [],\n    },\n  ],\n  plugins: [\n    formBuilderPlugin({\n      // see below for a list of available options\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Enabling Query Presets in Payload Collection - TypeScript\nDESCRIPTION: This snippet demonstrates how to enable Query Presets on a Payload CMS collection using the enableQueryPresets property in the CollectionConfig object. Payload's enableQueryPresets option, when set to true, allows users to save and share filters, columns, and sort orders within the admin interface. The only dependency is Payload CMS with properly imported types, and no additional parameters are required for basic enablement.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/query-presets/overview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  // highlight-start\n  enableQueryPresets: true,\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Running Slate to Lexical Migration Script in TypeScript\nDESCRIPTION: This snippet demonstrates the recommended approach for migrating all Slate rich text data to the Lexical format within a Payload CMS application. It imports the `migrateSlateToLexical` function from `@payloadcms/richtext-lexical/migrate` and executes it asynchronously, passing the initialized Payload instance (`payload`). This script performs a one-time conversion across all relevant collections and fields configured with the `SlateToLexicalFeature` (with `disableHooks: true`). Prerequisites include backing up the database, ensuring fields use the Lexical editor, and potentially configuring custom converters via the `SlateToLexicalFeature`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/migration.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { migrateSlateToLexical } from '@payloadcms/richtext-lexical/migrate'\n\nawait migrateSlateToLexical({ payload })\n```\n\n----------------------------------------\n\nTITLE: Configuring a Default Custom Edit View in Payload (TypeScript)\nDESCRIPTION: This snippet demonstrates how to replace the default Edit View across the Payload admin panel by specifying a path to a custom component within the `buildConfig` function. The `admin.components.views.edit.default.Component` property is set to the path of the custom view component.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    components: {\n      views: {\n        edit: {\n          // highlight-start\n          default: {\n            Component: '/path/to/MyCustomEditViewComponent',\n          },\n          // highlight-end\n        },\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Counting Collection Documents - Payload CMS JavaScript\nDESCRIPTION: This example calls the Local API's count method to determine the number of documents matching a query in a collection. It returns an object with a totalDocs property and supports localization, user context, and access overrides. Parameters: collection, where, locale, user. Payload and related type definitions should be available.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Result will be an object with:\n// {\n//   totalDocs: 10, // count of the documents satisfies query\n// }\nconst result = await payload.count({\n  collection: 'posts', // required\n  locale: 'en',\n  where: {}, // pass a `where` query here\n  user: dummyUser,\n  overrideAccess: false,\n})\n```\n\n----------------------------------------\n\nTITLE: Queuing a Task Job - Payload CMS - TypeScript\nDESCRIPTION: This code sample enqueues a single Task as a Job in Payload CMS by specifying the Task name ('createPost') and input parameters. It uses the 'payload.jobs.queue' function, which places the job in the system for later execution. Requires that the Payload instance is available, and the task is defined in the system. It returns the created Job object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/jobs.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst createdJob = await payload.jobs.queue({\n  task: 'createPost',\n  input: {\n    title: 'my title',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom SaveButton Client Component (TSX)\nDESCRIPTION: Example of a custom React client component ('use client' directive) for the Save button. Similar to the server component, it uses the base `SaveButton` from `@payloadcms/ui`, receives `SaveButtonClientProps`, and can implement custom client-side behavior or appearance.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport React from 'react'\nimport { SaveButton } from '@payloadcms/ui'\nimport type { SaveButtonClientProps } from 'payload'\n\nexport function MySaveButton(props: SaveButtonClientProps) {\n  return <SaveButton label=\"Save\" />\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Enabling Authentication for the Users Collection (TypeScript)\nDESCRIPTION: This TypeScript code snippet shows a partial configuration object for a Payload CMS 'Users' collection. Setting the `auth` property to `true` enables built-in authentication features for this collection, allowing users defined within it to log into the admin panel or protected front-end routes.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// ./src/collections/Users.ts\n{\n  // ...\n  auth: true\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Admin Panel Access Control in Payload CMS (TypeScript)\nDESCRIPTION: Defines an `admin` access control function within a Payload CMS Collection configuration. This function specifically controls access to the Admin Panel UI itself, checking if a user is currently logged in (`Boolean(user)`) via the provided `req` object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionWithAdminAccess: CollectionConfig = {\n  // ...\n  access: {\n    // highlight-start\n    admin: ({ req: { user } }) => {\n      return Boolean(user)\n    },\n    // highlight-end\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: User Login - Payload CMS JavaScript\nDESCRIPTION: This code demonstrates logging a user into Payload via the Local API, returning a JWT token, the user document, and expiration timestamp. Required options include collection and credentials. Optional parameters like req, depth, locale, and access flags allow fine-grained control during authentication and post-login logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\n// result will be formatted as follows:\n// {\n//   token: 'o38jf0q34jfij43f3f...', // JWT used for auth\n//   user: { ... } // the user document that just logged in\n//   exp: 1609619861 // the UNIX timestamp when the JWT will expire\n// }\n\nconst result = await payload.login({\n  collection: 'users', // required\n  data: {\n    // required\n    email: 'dev@payloadcms.com',\n    password: 'rip',\n  },\n  req: req, // optional, pass a Request object to be provided to all hooks\n  depth: 2,\n  locale: 'en',\n  fallbackLocale: false,\n  overrideAccess: false,\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Full Form State and Dispatching Actions with `useAllFormFields` in Payload CMS (TSX)\nDESCRIPTION: This example shows how to use the `useAllFormFields` hook from `@payloadcms/ui` to get access to the complete form state (`fields`) and the `dispatchFields` function. It also demonstrates using utility functions `reduceFieldsToValues` and `getSiblingData` from `payload/shared` to process the form data. Use this hook cautiously as it triggers re-renders on any field change. The component must be a client component.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport { useAllFormFields } from '@payloadcms/ui'\nimport { reduceFieldsToValues, getSiblingData } from 'payload/shared'\n\nconst ExampleComponent: React.FC = () => {\n  // the `fields` const will be equal to all fields' state,\n  // and the `dispatchFields` method is usable to send field state up to the form\n  const [fields, dispatchFields] = useAllFormFields();\n\n  // Pass in fields, and indicate if you'd like to \"unflatten\" field data.\n  // The result below will reflect the data stored in the form at the given time\n  const formData = reduceFieldsToValues(fields, true);\n\n  // Pass in field state and a path,\n  // and you will be sent all sibling data of the path that you've specified\n  const siblingData = getSiblingData(fields, 'someFieldName');\n\n  return (\n    // return some JSX here if necessary\n  )\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring BlocksFeature for a Custom Code Block in Payload Lexical (TypeScript)\nDESCRIPTION: Defines a Payload Rich Text field configuration using `lexicalEditor`. It adds a custom 'Code' block via `BlocksFeature`, which includes a 'language' select dropdown and a 'code' field rendered using a custom React component (`./path/to/CodeComponent#Code`). Requires `@payloadcms/richtext-lexical` and the custom component definition.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  BlocksFeature,\n  lexicalEditor,\n} from '@payloadcms/richtext-lexical'\n\nexport const languages = {\n  ts: 'TypeScript',\n  plaintext: 'Plain Text',\n  tsx: 'TSX',\n  js: 'JavaScript',\n  jsx: 'JSX',\n}\n\n// ...\n{\n  name: 'richText',\n  type: 'richText',\n  editor: lexicalEditor({\n    features: ({ defaultFeatures }) => [\n      ...defaultFeatures,\n      BlocksFeature({\n        blocks: [\n          {\n            slug: 'Code',\n            fields: [\n              {\n                type: 'select',\n                name: 'language',\n                options: Object.entries(languages).map(([key, value]) => ({\n                  label: value,\n                  value: key,\n                })),\n                defaultValue: 'ts',\n              },\n              {\n                admin: {\n                  components: {\n                    Field: './path/to/CodeComponent#Code',\n                  },\n                },\n                name: 'code',\n                type: 'code',\n              },\n            ],\n          }\n        ],\n        inlineBlocks: [],\n      }),\n    ],\n  }),\n},\n```\n\n----------------------------------------\n\nTITLE: Initiating Forgot Password Flow - Payload CMS JavaScript\nDESCRIPTION: This snippet initiates the forgot password process in a Payload-enabled authentication collection. By specifying the collection and email, it returns a token that can be used for password reset. It is designed for scenarios where a user has forgotten their password; must be called with a valid collection and user email.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Returned token will allow for a password reset\nconst token = await payload.forgotPassword({\n  collection: 'users', // required\n  data: {\n    // required\n    email: 'dev@payloadcms.com',\n  },\n  req: req, // pass a Request object to be provided to all hooks\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Payload CMS Configuration with Lexical Editor (TypeScript)\nDESCRIPTION: This TypeScript code snippet initializes a Payload CMS configuration using the `buildConfig` function. It imports the `lexicalEditor` from the `@payloadcms/richtext-lexical` package and assigns it to the `editor` property within the configuration object. This enables the Lexical editor as the default rich text editor for the CMS. The `collections` array is left empty as a placeholder for defining data structures.\nSOURCE: https://github.com/payloadcms/payload/blob/main/test/lexical-mdx/tests/code1.input.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\nimport { lexicalEditor } from '@payloadcms/richtext-lexical'\n\nexport default buildConfig({\n  collections: [\n    // your collections here\n  ],\n  // Pass the Lexical editor to the root config\n  editor: lexicalEditor({}),\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Textarea Field Server Component - Payload CMS React (TSX)\nDESCRIPTION: This TSX snippet creates a custom React server component for a Textarea Field using Payload's UI library and type definitions. The component receives server-side props, passes them through to Payload's TextareaField component, and renders it accordingly in the Admin Panel. Dependencies are React, @payloadcms/ui, and payload type definitions. Props include field configuration, field path, schema path, and permissions. It returns a JSX element rendered on the server, intended for advanced customization of field rendering.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/textarea.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport type React from 'react'\\nimport { TextareaField } from '@payloadcms/ui'\\nimport type { TextareaFieldServerComponent } from 'payload'\\n\\nexport const CustomTextareaFieldServer: TextareaFieldServerComponent = ({\\n  clientField,\\n  path,\\n  schemaPath,\\n  permissions,\\n}) => {\\n  return (\\n    <TextareaField\\n      field={clientField}\\n      path={path}\\n      schemaPath={schemaPath}\\n      permissions={permissions}\\n    />\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom beforeDocumentControls Server Component (TSX)\nDESCRIPTION: Example of a custom React server component designed to be injected before document controls. It receives `BeforeDocumentControlsServerProps` and renders custom UI elements like buttons or status indicators in that specific location.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport React from 'react'\nimport type { BeforeDocumentControlsServerProps } from 'payload'\n\nexport function MyCustomDocumentControlButton(\n  props: BeforeDocumentControlsServerProps,\n) {\n  return <div>This is a custom beforeDocumentControl button (Server)</div>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Refreshing All Payload Migrations (Shell)\nDESCRIPTION: Provides the command-line instruction to first roll back all existing migrations (running their `down` functions) and then re-apply all migrations from the beginning (running their `up` functions).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nnpm run payload migrate:refresh\n```\n\n----------------------------------------\n\nTITLE: Adding Markdown Transformers via Payload CMS Client Feature in TypeScript\nDESCRIPTION: This example shows how to define and register a custom markdown transformer that inserts a custom node into the editor when a specified markdown pattern is detected. It requires the @payloadcms/richtext-lexical/client and /lexical/markdown modules, as well as node helpers. Key fields include a regular expression for matching, an export serializer, and a replace function for mutation. Inputs include detected markdown, and outputs are transformed editor nodes inserted on matched patterns.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_21\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"import { createClientFeature } from '@payloadcms/richtext-lexical/client'\\nimport type { ElementTransformer } from '@payloadcms/richtext-lexical/lexical/markdown'\\nimport { $createMyNode, $isMyNode, MyNode } from './nodes/MyNode'\\n\\nconst MyMarkdownTransformer: ElementTransformer = {\\n  type: 'element',\\n  dependencies: [MyNode],\\n  export: (node, exportChildren) => {\\n    if (!$isMyNode(node)) {\\n      return null\\n    }\\n    return '+++'\\n  },\\n  // match ---\\n  regExp: /^+++\\s*$/,\\n  replace: (parentNode) => {\\n    const node = $createMyNode()\\n    if (node) {\\n      parentNode.replace(node)\\n    }\\n  },\\n}\\n\\nexport const MyFeature = createClientFeature({\\n  markdownTransformers: [MyMarkdownTransformer],\\n})\\n\"\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm - Shell\nDESCRIPTION: This shell command utilizes pnpm to install all project dependencies declared in package.json. Before running, pnpm must be installed. It downloads necessary libraries, including next-intl and PayloadCMS core packages, preparing the project for development and execution. Can only be run within the project directory initialized earlier.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/localization/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Accessing and Using Entity Configurations with getEntityConfig in React (TypeScript)\nDESCRIPTION: Demonstrates the recommended way to retrieve a collection or global config by slug using getEntityConfig from @payloadcms/ui in a React component. Useful for situations where only a specific entity's metadata (such as the media collection's fields) is needed. Requires @payloadcms/ui and useConfig hook; outputs config data for the requested collection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport { useConfig } from '@payloadcms/ui'\\n\\nconst MyComponent: React.FC = () => {\\n  // highlight-start\\n  const { getEntityConfig } = useConfig()\\n  const mediaConfig = getEntityConfig({ collectionSlug: 'media' })\\n  // highlight-end\\n\\n  return (\\n    <span>The media collection has {mediaConfig.fields.length} fields.</span>\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Defining an Array Field in Payload CMS with TypeScript\nDESCRIPTION: This TypeScript snippet shows how to configure an Array Field for Payload CMS. By setting the 'type' property to 'array' and providing a 'fields' array, you enable a set of repeating sub-fields inside a content entry. Dependencies include Payload CMS and its Field types, and the field can be further extended with additional configuration properties for validation, labels, and more. This snippet is suitable for use in collection or global field configs, where Payload expects each field to follow the Field type contract as defined in '@payloadcms'.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/array.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyArrayField: Field = {\n  // ...\n  // highlight-start\n  type: 'array',\n  fields: [\n    // ...\n  ],\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing the Application Home Page (Bash)\nDESCRIPTION: This command uses the `open` utility (common on macOS) to launch the default web browser and navigate to the application's home page, typically running at `http://localhost:3000` during development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nopen http://localhost:3000\n```\n\n----------------------------------------\n\nTITLE: Starting the Application in Production Mode (Bash)\nDESCRIPTION: These commands (`pnpm start` or `npm run start`) execute the start script defined in the project's `package.json`, typically running `node server.js` or `next start`. This starts the Node.js server to serve the pre-built, optimized production application from the `.next` directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\npnpm start` or `npm run start\n```\n\n----------------------------------------\n\nTITLE: Accessing Field Config in a Server Field Component (TSX)\nDESCRIPTION: This code shows a custom React Server Component designed for a specific field type (`TextFieldServerComponent`). It accesses its corresponding field configuration (e.g., the field's `name`) through the `field` prop.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport type { TextFieldServerComponent } from 'payload'\n\nexport const MyClientFieldComponent: TextFieldServerComponent = ({\n  field: { name },\n}) => {\n  return <p>{`This field's name is ${name}`}</p>\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating useLivePreview Hook in a Client-side React Component - Payload CMS - TypeScript (TSX)\nDESCRIPTION: This snippet shows a functional React component using the 'useLivePreview' hook from '@payloadcms/live-preview-react' to receive live updates for a page document. Requires installation of the specified package, a properly typed PageType, and the 'PAYLOAD_SERVER_URL' constant. Expects initial page data as a prop, which is updated in place when admin changes occur; outputs a live-updating document title. Depth, serverURL, and initialData are required/optional properties passed to the hook. This snippet is for client components only.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/client.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport { useLivePreview } from '@payloadcms/live-preview-react'\nimport { Page as PageType } from '@/payload-types'\n\n// Fetch the page in a server component, pass it to the client component, then thread it through the hook\n// The hook will take over from there and keep the preview in sync with the changes you make\n// The `data` property will contain the live data of the document\nexport const PageClient: React.FC<{\n  page: {\n    title: string\n  }\n}> = ({ page: initialPage }) => {\n  const { data } = useLivePreview<PageType>({\n    initialData: initialPage,\n    serverURL: PAYLOAD_SERVER_URL,\n    depth: 2,\n  })\n\n  return <h1>{data.title}</h1>\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Multi-Tenant Plugin using pnpm\nDESCRIPTION: Demonstrates how to install the `@payloadcms/plugin-multi-tenant` package using the pnpm package manager. This command adds the plugin as a dependency to your project, making it available for configuration within Payload CMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/multi-tenant.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n  pnpm add @payloadcms/plugin-multi-tenant\n```\n\n----------------------------------------\n\nTITLE: Installing Payload Live Preview React Package for Client-Side (Bash)\nDESCRIPTION: This command uses npm to install the `@payloadcms/live-preview-react` package. This package is necessary for implementing client-side Live Preview in React applications (like Next.js Pages Router or Create React App) using the `useLivePreview` hook.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/live-preview-react\n```\n\n----------------------------------------\n\nTITLE: Importing Payload Configuration Types (TypeScript)\nDESCRIPTION: Illustrates how to import the `Config` and `SanitizedConfig` types from the 'payload' package. These types provide type safety when defining or working with the Payload configuration object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Config, SanitizedConfig } from 'payload'\n```\n```\n\n----------------------------------------\n\nTITLE: Fetching Localized Data via REST API (JavaScript)\nDESCRIPTION: Demonstrates how to fetch data from the Payload CMS REST API with explicit locale and fallback-locale query parameters using the browser's fetch API. No external dependencies beyond browser or Node.js fetch implementation are required. The 'locale' parameter sets the desired locale for returned content, and 'fallback-locale' disables fallback behavior if set to 'none'. Expects localized JSON response based on the provided params.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/localization.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nfetch('https://localhost:3000/api/pages?locale=es&fallback-locale=none');\n```\n\n----------------------------------------\n\nTITLE: Installing Payload Cloud Storage Plugin via pnpm\nDESCRIPTION: This command installs the `@payloadcms/plugin-cloud-storage` package using the pnpm package manager. This package is required to integrate various cloud storage solutions with Payload CMS. Note that newer, specific packages are recommended for Payload 3.0 and major providers like Vercel Blob, AWS S3, Azure, and GCS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm add @payloadcms/plugin-cloud-storage\n```\n\n----------------------------------------\n\nTITLE: Configuring the Content Source Maps Plugin in Payload (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to configure the `@payloadcms/plugin-csm` within the Payload CMS configuration file (`payload.config.ts`). It imports the `contentSourceMaps` plugin and adds it to the `plugins` array, specifying which collections (e.g., 'pages') should have Content Source Maps enabled. This setup allows Vercel to link front-end content back to the corresponding fields in the Payload admin UI.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/integrations/vercel-content-link.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from \"payload/config\"\nimport contentSourceMaps from \"@payloadcms/plugin-csm\"\n\nconst config = buildConfig({\n  collections: [\n    {\n      slug: \"pages\",\n      fields: [\n        {\n          name: 'slug',\n          type: 'text',\n        },\n        {\n          name: 'title,'\n          type: 'text',\n        },\n      ],\n    },\n  ],\n  plugins: [\n    contentSourceMaps({\n      collections: [\"pages\"],\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Declaring a Collection with a Radio Field in Payload CMS (TypeScript)\nDESCRIPTION: This example provides a full-fledged collection configuration in Payload CMS that includes a radio field. It specifies mandatory attributes such as 'slug', 'fields', 'name', 'type', the array of option objects ('label' and 'value'), and UI preferences like 'admin.layout'. Dependencies include the Payload CMS type definitions and supporting schema infrastructure. It expects the developer to register this configuration as part of the main Payload setup. Inputs are statically defined within the code, outputs manifest as CMS entries with user-selected radio field values.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/radio.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\\n\\nexport const ExampleCollection: CollectionConfig = {\\n  slug: 'example-collection',\\n  fields: [\\n    {\\n      name: 'color', // required\\n      type: 'radio', // required\\n      options: [\\n        // required\\n        {\\n          label: 'Mint',\\n          value: 'mint',\\n        },\\n        {\\n          label: 'Dark Gray',\\n          value: 'dark_gray',\\n        },\\n      ],\\n      defaultValue: 'mint', // The first value in options.\\n      admin: {\\n        layout: 'horizontal',\\n      },\\n    },\\n  ],\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Querying Collection Depth in Payload CMS Local API (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to use the Payload CMS Local API to query a collection with a specified population depth. The function 'getPosts' takes a Payload instance and runs the 'find' operation with a 'depth' option. The 'collection' parameter designates which collection to query ('posts'), and 'depth: 2' tells Payload how many levels deep to populate relationships. Requires Payload CMS and a configured collection. Inputs are the Payload instance; outputs are an array of post documents with related data populated up to the specified depth.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/depth.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Payload } from 'payload'\\n\\nconst getPosts = async (payload: Payload) => {\\n  const posts = await payload.find({\\n    collection: 'posts',\\n    depth: 2, // highlight-line\\n  })\\n\\n  return posts\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Querying a Payload Collection via REST API using Fetch (TypeScript)\nDESCRIPTION: This example demonstrates fetching data from a Payload collection named 'pages' using the built-in REST API. It utilizes the standard `fetch` API to make an HTTP GET request to the `/api/pages` endpoint of a running Payload application (assumed to be at `https://localhost:3000`). The response is then parsed as JSON, and the resulting data is logged to the console. This is a standard way to interact with Payload from client-side applications or external services.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/concepts.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nfetch('https://localhost:3000/api/pages') // highlight-line\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Payload Vercel Postgres Adapter using npm\nDESCRIPTION: This command installs the necessary Node.js package for the Payload CMS Vercel Postgres adapter using the npm package manager. This package enables Payload to connect and interact with a Vercel Postgres database.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/db-vercel-postgres/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/db-vercel-postgres\n```\n\n----------------------------------------\n\nTITLE: Extending Lexical Editor with Custom Features – Payload CMS (TypeScript)\nDESCRIPTION: Demonstrates how to customize the Lexical editor by injecting features via the features prop when initializing with lexicalEditor. Dependencies include default and custom features from @payloadcms/richtext-lexical, as well as any reused Payload blocks. The features prop receives a function with defaultFeatures and rootFeatures, builds and customizes LinkFeature, UploadFeature, and BlocksFeature, and supports advanced field and block customization. Inputs: None required, but dependent on available features and custom blocks; outputs a configured editor instance with tailored feature set. Notable for its extensibility of editor behavior on a per-feature basis.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/overview.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  BlocksFeature,\n  LinkFeature,\n  UploadFeature,\n  lexicalEditor,\n} from '@payloadcms/richtext-lexical'\nimport { Banner } from '../blocks/Banner'\nimport { CallToAction } from '../blocks/CallToAction'\n\n{\n  editor: lexicalEditor({\n    features: ({ defaultFeatures, rootFeatures }) => [\n      ...defaultFeatures,\n      LinkFeature({\n        // Example showing how to customize the built-in fields\n        // of the Link feature\n        fields: ({ defaultFields }) => [\n          ...defaultFields,\n          {\n            name: 'rel',\n            label: 'Rel Attribute',\n            type: 'select',\n            hasMany: true,\n            options: ['noopener', 'noreferrer', 'nofollow'],\n            admin: {\n              description:\n                'The rel attribute defines the relationship between a linked resource and the current document. This is a custom link field.',\n            },\n          },\n        ],\n      }),\n      UploadFeature({\n        collections: {\n          uploads: {\n            // Example showing how to customize the built-in fields\n            // of the Upload feature\n            fields: [\n              {\n                name: 'caption',\n                type: 'richText',\n                editor: lexicalEditor(),\n              },\n            ],\n          },\n        },\n      }),\n      // This is incredibly powerful. You can re-use your Payload blocks\n      // directly in the Lexical editor as follows:\n      BlocksFeature({\n        blocks: [Banner, CallToAction],\n      }),\n    ],\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MongoDB URI for Docker Local Development\nDESCRIPTION: This represents the format for the MongoDB connection URI to be placed in the `.env` file when using the provided Docker Compose setup for local development. It directs Payload to connect to a MongoDB instance running on the local machine's Docker network. Replace `<dbname>` with the desired database name, ensuring it matches the `MONGODB_URI` in `docker-compose.yml`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/blank/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nmongodb://127.0.0.1/<dbname>\n```\n\n----------------------------------------\n\nTITLE: Copying Environment Variables for Payload Project (Shell)\nDESCRIPTION: This shell command changes the current directory to 'my-project' and then copies the example environment file `.env.example` to a new file named `.env`. This `.env` file is where local environment configurations like database URIs are stored.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/blank/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncd my-project && cp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Running Payload Script via CLI (Shell)\nDESCRIPTION: This shell command runs the seed script using the Payload CLI's 'run' function. It loads environment variables and enables running ESM TypeScript directly without extra tools. The script to execute is specified as a path argument. You must have the Payload CLI installed and configured in your project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/outside-nextjs.mdx#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\npayload run src/seed.ts\n```\n\n----------------------------------------\n\nTITLE: Initiating Forgot Password via GraphQL Mutation\nDESCRIPTION: Executes a GraphQL mutation named `forgotPassword[collection-singular-label]` to trigger the forgot password process for a user within a specific collection. The user's email address is passed as an argument. This mutation typically results in an email being sent with a password reset link.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_18\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  forgotPassword[collection-singular-label](email: \"dev@payloadcms.com\")\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS and CSRF Settings in Payload Config with TypeScript\nDESCRIPTION: This TypeScript configuration snippet shows how to set up CORS and CSRF policies in Payload config to support cross-domain requests and authentication. Populate the cors and csrf arrays with the URLs of your front-end apps. This is important when your client and Payload server are on different domains or ports. This applies to payload.config.ts files.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/client.mdx#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  // If your site is running on a different domain than your Payload server,\n  // This will allows requests to be made between the two domains\n  cors: [\n    'http://localhost:3001' // Your front-end application\n  ],\n  // If you are protecting resources behind user authentication,\n  // This will allow cookies to be sent between the two domains\n  csrf: [\n    'http://localhost:3001' // Your front-end application\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Payload App via create-payload-app CLI - Bash\nDESCRIPTION: This snippet shows how to use the 'create-payload-app' CLI to create a new project based on the website template. It requires 'pnpx' and Node.js installed. The 'my-project' argument sets the destination folder, and '-t website' specifies the use of this template. No additional parameters are needed. Outputs a ready-to-install website template in the specified directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/website/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpx create-payload-app my-project -t website\n\n```\n\n----------------------------------------\n\nTITLE: Applying Global Styles to Payload Dashboard using SCSS\nDESCRIPTION: This SCSS snippet demonstrates how to apply custom styles globally within the Payload Admin Panel by targeting a specific class (`.dashboard`) in the root `custom.scss` file. It changes the background color of the dashboard view to red. This file is loaded into the root of the Admin Panel.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/customizing-css.mdx#_snippet_0\n\nLANGUAGE: scss\nCODE:\n```\n.dashboard {\n  background-color: red; // highlight-line\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Environment Example File - Bash\nDESCRIPTION: This command copies the example environment configuration file to create a new .env file in the project directory. This is essential for local development as it sets up required environment variables such as MONGODB_URI and BLOB_READ_WRITE_TOKEN, which must be updated with valid credentials. The 'cp .env.example .env' command should be run inside the project root and requires appropriate OS permissions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/with-vercel-mongodb/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd my-project && cp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Importing TypeScript Types for Custom Label Components (TSX)\nDESCRIPTION: Demonstrates importing specific TypeScript types for custom Label components in Payload CMS. Types like `TextFieldLabelServerComponent` and `TextFieldLabelClientComponent` ensure type safety when developing custom label components for different field types and environments (server/client). Assumes a TSX context for component development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_25\n\nLANGUAGE: tsx\nCODE:\n```\nimport type {\n  TextFieldLabelServerComponent,\n  TextFieldLabelClientComponent,\n  // ...and so on for each Field Type\n} from 'payload'\n```\n\n----------------------------------------\n\nTITLE: Building the Production Application (Shell)\nDESCRIPTION: Runs the production build process using pnpm or npm. For a Next.js project like this example, it typically involves building both the Payload admin panel and the Next.js front-end, creating optimized bundles in a build directory (e.g., `.next`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/form-builder/README.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npnpm build\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Upload Node Converter in Lexical to JSX\nDESCRIPTION: This example demonstrates overriding the default converter for the 'upload' node type, specifically to use Next.js's `Image` component. It defines a custom React component (`CustomUploadComponent`) that receives the `SerializedUploadNode` and renders an `Image` if the related document is valid. This custom component is then assigned to the `upload` key within the `jsxConverters` function passed to the `RichText` component, replacing the default rendering behavior. Requires `react`, `next/image`, and `@payloadcms/richtext-lexical/react`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-jsx.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport type {\n  DefaultNodeTypes,\n  SerializedUploadNode,\n} from '@payloadcms/richtext-lexical'\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\n\nimport {\n  type JSXConvertersFunction,\n  RichText,\n} from '@payloadcms/richtext-lexical/react'\nimport Image from 'next/image'\nimport React from 'react'\n\ntype NodeTypes = DefaultNodeTypes\n\n// Custom upload converter component that uses next/image\nconst CustomUploadComponent: React.FC<{\n  node: SerializedUploadNode\n}> = ({ node }) => {\n  if (node.relationTo === 'uploads') {\n    const uploadDoc = node.value\n    if (typeof uploadDoc !== 'object') {\n      return null\n    }\n    const { alt, height, url, width } = uploadDoc\n    return <Image alt={alt} height={height} src={url} width={width} />\n  }\n\n  return null\n}\n\nconst jsxConverters: JSXConvertersFunction<NodeTypes> = ({\n  defaultConverters,\n}) => ({\n  ...defaultConverters,\n  // Override the default upload converter\n  upload: ({ node }) => {\n    return <CustomUploadComponent node={node} />\n  },\n})\n\nexport const MyComponent: React.FC<{\n  lexicalData: SerializedEditorState\n}> = ({ lexicalData }) => {\n  return <RichText converters={jsxConverters} data={lexicalData} />\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Lexical to HTML Asynchronously with REST Population (Client)\nDESCRIPTION: Demonstrates asynchronous conversion of Lexical JSON to HTML in a React client component, specifically for cases needing dynamic data population (e.g., fetching related documents or uploads). It uses `convertLexicalToHTMLAsync` and `getRestPopulateFn` within a `useEffect` hook to fetch data from a Payload REST API endpoint (`/api`). The HTML is stored in state and rendered once available. This approach might be slow if many nodes need population due to multiple network requests.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-html.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\n\nimport { getRestPopulateFn } from '@payloadcms/richtext-lexical/client'\nimport { convertLexicalToHTMLAsync } from '@payloadcms/richtext-lexical/html-async'\nimport React, { useEffect, useState } from 'react'\n\nexport const MyComponent = ({ data }: { data: SerializedEditorState }) => {\n  const [html, setHTML] = useState<null | string>(null)\n  useEffect(() => {\n    async function convert() {\n      const html = await convertLexicalToHTMLAsync({\n        data,\n        populate: getRestPopulateFn({\n          apiURL: `http://localhost:3000/api`,\n        }),\n      })\n      setHTML(html)\n    }\n\n    void convert()\n  }, [data])\n\n  return html && <div dangerouslySetInnerHTML={{ __html: html }} />\n}\n```\n\n----------------------------------------\n\nTITLE: Setting populate Property in REST API Requests - JavaScript\nDESCRIPTION: Shows how to use the populate query string parameter in REST API calls to include specific fields from related documents, overriding any defaultPopulate rules. The example demonstrates requesting only the 'text' field from related 'pages' in post documents. This is a standalone JavaScript fetch call with direct query params used in the URL.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/select.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nfetch('https://localhost:3000/api/posts?populate[pages][text]=true') // highlight-line\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n```\n\n----------------------------------------\n\nTITLE: Calling Stripe API via Payload Plugin Proxy (TypeScript)\nDESCRIPTION: This code provides an alternative way to interact with the Stripe API using the 'stripeProxy' utility from '@payloadcms/plugin-stripe'. It wraps Stripe API calls for use within Payload projects, passing necessary parameters (including the secret key, method, and arguments) and demonstrates best practices for handling both success and error states based on HTTP status codes. Requires the Payload plugin-stripe package, environment variables, and correct plugin setup.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/stripe.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { stripeProxy } from '@payloadcms/plugin-stripe'\n\nexport const MyFunction = async () => {\n  try {\n    const customer = await stripeProxy({\n      stripeSecretKey: process.env.STRIPE_SECRET_KEY,\n      stripeMethod: 'customers.create',\n      stripeArgs: [\n        {\n          email: data.email,\n        },\n      ],\n    })\n\n    if (customer.status === 200) {\n      // do something...\n    }\n\n    if (customer.status >= 400) {\n      throw new Error(customer.message)\n    }\n  } catch (error) {\n    console.error(error.message)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Components for Collections in Payload CMS (TypeScript)\nDESCRIPTION: Illustrates how to structure the configuration for adding or overriding custom React components within a specific Payload CMS Collection's admin interface. The `admin.components` property within the `CollectionConfig` is used to specify these custom components, allowing for tailored UI elements like custom views or modifications to the List/Edit screens.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/collections.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      // highlight-line\n      // ...\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Date Field Display Options in Payload TypeScript\nDESCRIPTION: This snippet defines a Payload CMS collection named 'ExampleCollection' with three different 'date' type fields. Each field demonstrates how to customize the date picker's appearance (`pickerAppearance`) and the format in which the date is displayed in the admin UI (`displayFormat`) using the `admin.date` configuration object. It shows configurations for 'dayOnly', 'timeOnly', and 'monthOnly' appearances with corresponding display formats.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/date.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'dateOnly',\n      type: 'date',\n      admin: {\n        date: {\n          pickerAppearance: 'dayOnly',\n          displayFormat: 'd MMM yyy',\n        },\n      },\n    },\n    {\n      name: 'timeOnly',\n      type: 'date',\n      admin: {\n        date: {\n          pickerAppearance: 'timeOnly',\n          displayFormat: 'h:mm:ss a',\n        },\n      },\n    },\n    {\n      name: 'monthOnly',\n      type: 'date',\n      admin: {\n        date: {\n          pickerAppearance: 'monthOnly',\n          displayFormat: 'MMMM yyyy',\n        },\n      },\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating User Without Access Control Payload TypeScript\nDESCRIPTION: This snippet demonstrates how to create a user in Payload CMS using the Local API, where access control is skipped by default. There are no dependencies needed apart from the Payload library being initialized. The 'collection' parameter specifies where to store data, and the 'data' object contains user details. Inputs must include valid email and password fields. The output is a user document, and no user permissions are checked during this operation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/access-control.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Access control is this operation would be skipped by default\nconst test = await payload.create({\n  collection: 'users',\n  data: {\n    email: 'test@test.com',\n    password: 'test',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring a Join Field and Corresponding Relationship in Payload CMS (TypeScript)\nDESCRIPTION: Defines a 'join' field named 'relatedPosts' intended for a Category collection. It links to the 'posts' collection based on the 'category' relationship field within 'posts'. Also shows the corresponding 'relationship' field ('category') definition in another collection (presumably 'posts') that the 'join' field relies on. This setup allows viewing related posts from a category's perspective without storing redundant data on the category document.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/join.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyJoinField: Field = {\n  // highlight-start\n  name: 'relatedPosts',\n  type: 'join',\n  collection: 'posts', // The collection containing the related documents\n  on: 'category', // The name of the relationship field in the 'posts' collection\n  // highlight-end\n}\n\n// relationship field in another collection:\nexport const MyRelationshipField: Field = {\n  name: 'category',\n  type: 'relationship',\n  relationTo: 'categories', // The collection this field relates to\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Many-to-One Relationship Field - PayloadCMS - TypeScript\nDESCRIPTION: This configuration example shows how to define a relationship field in a Payload collection that supports multiple related values (hasMany: true) and points to a single collection ('users'). Documents using this field will store an array of user ObjectIDs, and the relationship is unidirectional. This must be set up within the fields array of a collection config.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'owners', // required\n      type: 'relationship', // required\n      relationTo: 'users', // required\n      hasMany: true,\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Default Ethereal Email Service with Nodemailer Adapter in Payload CMS (TypeScript)\nDESCRIPTION: This code snippet illustrates defaulting to the Ethereal email testing service by calling nodemailerAdapter without arguments during development. No transport or sender information is specified, enabling fool-proof test email delivery. Required dependency: @payloadcms/email-nodemailer; suitable for development environments as it logs Ethereal credentials to the console. No input parameters are necessary.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/email/overview.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { nodemailerAdapter } from '@payloadcms/email-nodemailer'\n\nexport default buildConfig({\n  email: nodemailerAdapter(),\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Admin View Using Payload's Default Template (TSX/React)\nDESCRIPTION: This example shows how to build a custom admin view that integrates with Payload's standard layout and navigation by using the `DefaultTemplate` component. The custom component receives `AdminViewServerProps`, extracts necessary data (like `initPageResult`, `params`, `searchParams`), and passes it down to the `DefaultTemplate`, rendering its specific content within the template.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-views.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { AdminViewServerProps } from 'payload'\n\nimport { DefaultTemplate } from '@payloadcms/next/templates'\nimport { Gutter } from '@payloadcms/ui'\nimport React from 'react'\n\nexport function MyCustomView({\n  initPageResult,\n  params,\n  searchParams,\n}: AdminViewServerProps) {\n  return (\n    <DefaultTemplate\n      i18n={initPageResult.req.i18n}\n      locale={initPageResult.locale}\n      params={params}\n      payload={initPageResult.req.payload}\n      permissions={initPageResult.permissions}\n      searchParams={searchParams}\n      user={initPageResult.req.user || undefined}\n      visibleEntities={initPageResult.visibleEntities}\n    >\n      <Gutter>\n        <h1>Custom Default Root View</h1>\n        <p>This view uses the Default Template.</p>\n      </Gutter>\n    </DefaultTemplate>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Collection with a Textarea Field - Payload CMS TypeScript\nDESCRIPTION: This TypeScript code defines a Payload CollectionConfig with a single required Textarea Field named 'metaDescription'. The field is mandatory, and the configuration object must be exported for Payload to recognize it. This example demonstrates usage of Textarea fields as part of a collection schema. Requires 'payload' package and is typically placed in a file in the collections directory. The field stores long-form string data per collection document.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/textarea.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\\n\\nexport const ExampleCollection: CollectionConfig = {\\n  slug: 'example-collection',\\n  fields: [\\n    {\\n      name: 'metaDescription', // required\\n      type: 'textarea', // required\\n      required: true,\\n    },\\n  ],\\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying User Email - Payload CMS JavaScript\nDESCRIPTION: This code verifies a user's email address using a token received (typically via email) after registration for collections with auth enabled. It returns a boolean indicating verification success. Required inputs: collection and token that references the _verificationToken field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_16\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Returned result will be a boolean representing success or failure\nconst result = await payload.verifyEmail({\n  collection: 'users', // required\n  token: 'afh3o2jf2p3f...', // the token saved on the user as `_verificationToken`\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Globals in Payload Config (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to add a 'globals' property to the main Payload Config file using TypeScript. It shows how to initialize the configuration with an array for defining Global configs for your application. The code assumes that necessary dependencies such as 'payload' have been installed. The main inputs involve specifying configuration details for each Global within the provided array, and this structure is essential for registering globals so they are correctly loaded and managed by Payload. Outputs are not directly produced by this snippet, as it forms part of the overall config file.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/globals.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  globals: [\n    // highlight-line\n    // Your Globals go here\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing afterOperation Hook in Payload (TypeScript)\nDESCRIPTION: Demonstrates usage of the afterOperation hook to run actions or modify results after a collection operation in Payload using TypeScript. The snippet imports CollectionAfterOperationHook and provides an async handler that returns the result argument, suitable for extending to modify operation responses or run side effects post-operation. Requires the Payload npm package and TypeScript.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionAfterOperationHook } from 'payload'\n\nconst afterOperationHook: CollectionAfterOperationHook = async ({ result }) => {\n  return result\n}\n```\n\n----------------------------------------\n\nTITLE: Starting MongoDB with Docker Compose - Bash\nDESCRIPTION: This command starts up the MongoDB service defined in the docker-compose.yml file for local development. It assumes that docker and docker-compose are installed, and the MONGODB_URI in the .env file and docker-compose.yml are synchronized. 'docker-compose up' will bring up the containers in the foreground; appending '-d' will run them in the background. Useful for those wishing to avoid installing MongoDB directly on their machine.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/with-vercel-mongodb/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose up\n```\n\n----------------------------------------\n\nTITLE: Importing the Payload Logout Function in TypeScript\nDESCRIPTION: Imports the `logout` function from the `@payloadcms/next/auth` package. This function is used to log out the currently authenticated user by clearing the authentication cookie.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { logout } from '@payloadcms/next/auth'\n```\n```\n\n----------------------------------------\n\nTITLE: Starting Azure Blob Storage Emulator with Docker Compose (Shell)\nDESCRIPTION: Starts the Azure Blob Storage emulator service defined in the `docker-compose.yml` file in the current directory. The `-d` flag runs the containers in detached mode (in the background).\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ndocker-compose up -d\n```\n\n----------------------------------------\n\nTITLE: Configuring Autosave for a Payload Collection in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates enabling and configuring the autosave feature within a Payload CMS `CollectionConfig` for a 'Pages' collection. It sets `versions.drafts.autosave` to `true` for basic enablement. Commented-out code shows alternative configuration using an object to specify a custom `interval` (in milliseconds) for autosaving and to optionally display the 'Save as draft' button (`showSaveDraftButton`) even when autosave is active. This configuration requires versions and drafts to be enabled on the collection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/versions/autosave.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Pages: CollectionConfig = {\n  slug: 'pages',\n  access: {\n    read: ({ req }) => {\n      // If there is a user logged in,\n      // let them retrieve all documents\n      if (req.user) return true\n\n      // If there is no user,\n      // restrict the documents that are returned\n      // to only those where `_status` is equal to `published`\n      return {\n        _status: {\n          equals: 'published',\n        },\n      }\n    },\n  },\n  versions: {\n    drafts: {\n      autosave: true,\n\n      // Alternatively, you can specify an object to customize autosave:\n      // autosave: {\n      // Define how often the document should be autosaved (in milliseconds)\n      //   interval: 1500,\n      //\n      // Show the \"Save as draft\" button even while autosave is enabled\n      //   showSaveDraftButton: true,\n      // },\n    },\n  },\n  //.. the rest of the Pages config here\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Running the Development Server with pnpm - Shell\nDESCRIPTION: This shell command starts the PayloadCMS development server using pnpm, typically invoking a custom or predefined dev script. It initializes hot-reloading and local hosting. Project dependencies must first be installed. Expected output is a running development server accessible via localhost in a web browser.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/localization/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Importing Lexical Editor Config Factory Utilities in TypeScript\nDESCRIPTION: Imports the `editorConfigFactory` and `SanitizedConfig` type from Payload CMS necessary for retrieving Lexical editor configurations. It initializes an empty `config` variable, highlighting the need for a Payload `SanitizedConfig` object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converters.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type { SanitizedConfig } from 'payload'\nimport { editorConfigFactory } from '@payloadcms/richtext-lexical'\n\n// Your Payload Config needs to be available in order to retrieve the default editor config\nconst config: SanitizedConfig = {} as SanitizedConfig\n```\n\n----------------------------------------\n\nTITLE: Fetching Payload Data with Source Maps in Next.js (TypeScript)\nDESCRIPTION: This TypeScript code snippet shows how to conditionally fetch data from the Payload API with Content Source Maps enabled, specifically within a Next.js application. It checks if the application is in draft mode (`isDraftMode`) or running on a Vercel preview environment (`process.env.VERCEL_ENV === 'preview'`) before appending the `encodeSourceMaps=true` query parameter to the API request URL. This ensures source maps are only requested when needed for editing, optimizing performance for production.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/integrations/vercel-content-link.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nif (isDraftMode || process.env.VERCEL_ENV === 'preview') {\n  const res = await fetch(\n    `${process.env.NEXT_PUBLIC_PAYLOAD_CMS_URL}/api/pages?where[slug][equals]=${slug}&encodeSourceMaps=true`,\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Typing the beforeEmail Hook with Plugin Types (TypeScript)\nDESCRIPTION: Shows how to import and apply type safety to the beforeEmail hook using BeforeEmail and FormSubmission types from relevant packages. Ensures that fields like data and originalDoc are properly typed within the callback function, making plugin extensions type-safe. Requires @payloadcms/plugin-form-builder types and project-specific types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { BeforeEmail } from '@payloadcms/plugin-form-builder'\n// Your generated FormSubmission type\nimport type { FormSubmission } from '@payload-types'\n\n// Pass it through and 'data' or 'originalDoc' will now be typed\nconst beforeEmail: BeforeEmail<FormSubmission> = (\n  emailsToSend,\n  beforeChangeParams,\n) => {\n  // modify the emails in any way before they are sent\n  return emails.map((email) => ({\n    ...email,\n    html: email.html, // transform the html in any way you'd like (maybe wrap it in an html template?)\n  }))\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Forgot Password Workflow in Payload CMS Collection (TypeScript)\nDESCRIPTION: This snippet demonstrates enabling customization for the forgot password process in a Payload CMS collection using the `forgotPassword` property in the `auth` config object. The property can include options such as `expiration` and custom email template functions for password reset emails. No concrete customization is shown here; it's a configuration baseline. Requires Payload CMS and a TypeScript project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/email.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Customers: CollectionConfig = {\n  // ...\n  auth: {\n    forgotPassword: {\n      // highlight-line\n      // ...\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cross-Domain Cookies in Payload Auth Collection (TypeScript)\nDESCRIPTION: Demonstrates how to configure cookie settings within a Payload CMS authentication collection to allow cross-domain usage. Setting `sameSite: 'None'` and `secure: true` enables the authentication cookie to be sent with cross-origin requests, necessary when the frontend and Payload API are on different domains. Requires HTTPS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/cookies.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n{\n  slug: 'users',\n  auth: {\n    cookies: {\n      sameSite: 'None',\n      secure: true,\n    }\n  },\n  fields: [\n    // your auth fields here\n  ]\n},\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Payload Bin Script (TypeScript)\nDESCRIPTION: Provides an example of a custom script (`seed.ts`) intended to be run via the Payload CLI. The script must export an async function named `script` that accepts the sanitized Payload config, initializes Payload, performs actions (like creating data), logs output, and exits.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { SanitizedConfig } from 'payload'\n\nimport payload from 'payload'\n\n// Script must define a \"script\" function export that accepts the sanitized config\nexport const script = async (config: SanitizedConfig) => {\n  await payload.init({ config })\n  await payload.create({\n    collection: 'pages',\n    data: { title: 'my title' },\n  })\n  payload.logger.info('Succesffully seeded!')\n  process.exit(0)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a beforeValidate Collection Hook (TypeScript)\nDESCRIPTION: Shows the structure of a `beforeValidate` hook function in Payload CMS. This hook runs during `create` and `update` operations before server-side validation, allowing data manipulation or formatting via the `data` argument. It also receives `operation`, `originalDoc`, and `req`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionBeforeValidateHook } from 'payload'\n\nconst beforeValidateHook: CollectionBeforeValidateHook = async ({ data }) => {\n  return data\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Vercel Blob Storage Adapter - Bash\nDESCRIPTION: This command installs the Vercel Blob Storage adapter for Payload CMS, enabling file and media uploads to Vercel's blob storage. It updates project dependencies, preparing for further config changes in 'payload.config.ts'. Dependencies: pnpm and Node.js environment.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/website/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @payloadcms/storage-vercel-blob\n```\n\n----------------------------------------\n\nTITLE: Installing the Payload Content Source Maps Plugin (Bash)\nDESCRIPTION: This command installs the necessary Payload plugin (`@payloadcms/plugin-csm`) for integrating Vercel Content Link. This plugin embeds Content Source Maps into Payload API responses. Requires npm or a compatible Node.js package manager. An API key is needed for installation, obtainable via the Payload sales team for enterprise customers.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/integrations/vercel-content-link.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @payloadcms/plugin-csm\n```\n\n----------------------------------------\n\nTITLE: Logging Out a User via REST API using Fetch in TypeScript\nDESCRIPTION: Demonstrates how to log out a user by sending a POST request to the `/api/[collection-slug]/logout` endpoint using the `fetch` API. This endpoint clears the HTTP-only cookie containing the user's token.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await fetch('http://localhost:3000/api/[collection-slug]/logout', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Lexical Editor Config with Features in TypeScript\nDESCRIPTION: Illustrates creating a custom Lexical editor configuration by adding specific features (like `FixedToolbarFeature`) to the default set using `editorConfigFactory.fromFeatures`. Requires the Payload `SanitizedConfig` and a function defining the features.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converters.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { FixedToolbarFeature } from '@payloadcms/richtext-lexical'\n\nconst customEditorConfig = await editorConfigFactory.fromFeatures({\n  config,\n  features: ({ defaultFeatures }) => [\n    ...defaultFeatures,\n    FixedToolbarFeature(),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Using Payload Live Preview Utility Functions - TypeScript React\nDESCRIPTION: This TypeScript snippet shows the import and basic usage plan for the ready and isDocumentEvent functions from @payloadcms/live-preview. These functions are used to send a postMessage event to the admin panel and check if incoming MessageEvents are related to document changes. The snippet includes comments guiding how to build your own component utilizing these utilities, making it suitable as a template for custom framework integration. No expected inputs/outputs beyond events; ensure you subscribe and unsubscribe appropriately to window.postMessage.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/server.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { ready, isDocumentEvent } from '@payloadcms/live-preview'\n\n// To build your own component:\n// 1. Listen for document-level `window.postMessage` events sent from the Admin Panel\n// 2. Tell the Admin Panel when it is ready to receive messages\n// 3. Refresh the route every time a new document-level event is received\n// 4. Unsubscribe from the `window.postMessage` events when it unmounts\n```\n\n----------------------------------------\n\nTITLE: Listing Available Collection Hooks in Configuration (TypeScript)\nDESCRIPTION: Illustrates the structure for defining various collection hooks within the `hooks` property of a Payload CMS `CollectionConfig`. It lists common hooks like `beforeOperation`, `beforeValidate`, `afterChange`, and auth-specific hooks, each accepting an array of synchronous or asynchronous functions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig } from 'payload';\n\nexport const CollectionWithHooks: CollectionConfig = {\n  // ...\n  // highlight-start\n  hooks: {\n    beforeOperation: [(args) => {...}],\n    beforeValidate: [(args) => {...}],\n    beforeDelete: [(args) => {...}],\n    beforeChange: [(args) => {...}],\n    beforeRead: [(args) => {...}],\n    afterChange: [(args) => {...}],\n    afterRead: [(args) => {...}],\n    afterDelete: [(args) => {...}],\n    afterOperation: [(args) => {...}],\n    afterError: [(args) => {....}],\n\n    // Auth-enabled Hooks\n    beforeLogin: [(args) => {...}],\n    afterLogin: [(args) => {...}],\n    afterLogout: [(args) => {...}],\n    afterRefresh: [(args) => {...}],\n    afterMe: [(args) => {...}],\n    afterForgotPassword: [(args) => {...}],\n    refresh: [(args) => {...}],\n    me: [(args) => {...}],\n  },\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a GraphQL Resolver Function Signature (TypeScript)\nDESCRIPTION: Shows the standard asynchronous function signature for a GraphQL resolver within PayloadCMS. It receives four arguments: `obj` (the previous object, often unused), `args` (arguments passed to the query/mutation), `context` (containing `req`, `res`, `payload`, `user`, etc.), and `info` (contextual information about the GraphQL operation).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/extending.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n;async (obj, args, context, info) => {}\n```\n\n----------------------------------------\n\nTITLE: Setting Dynamic Live Preview URL Function in Payload Config\nDESCRIPTION: This snippet illustrates how to configure a dynamic URL for Live Preview in Payload CMS by providing a function to the `url` property. This function receives arguments like `data`, `collectionConfig`, and `locale`, allowing URL generation based on the document being edited, useful for multi-tenant or localized applications.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/overview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    // ...\n    livePreview: {\n      // highlight-start\n      url: ({\n        data,\n        collectionConfig,\n        locale\n      }) => `${data.tenant.url}${ // Multi-tenant top-level domain\n        collectionConfig.slug === 'posts' ? `/posts/${data.slug}` : `${data.slug !== 'home' ? `/${data.slug}` : ''}`\n      }${locale ? `?locale=${locale?.code}` : ''}`, // Localization query param\n      collections: ['pages'],\n    },\n    // highlight-end\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing Array Field Admin Options in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript code snippet demonstrates how to extend the admin configuration of an Array Field in Payload CMS. The 'admin' property within the Field config allows you to set UI-specific options such as initial collapsed state and custom row labels, or disable sorting. This config is typically used when customizing the editor experience in the admin dashboard, and assumes the field is defined within a valid Payload Field structure.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/array.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyArrayField: Field = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Nav Component - React TSX\nDESCRIPTION: This snippet defines a simple custom navigation component using React and the @payloadcms/ui package for navigation links. The 'MyCustomNav' function returns a <nav> element containing a dashboard link. It requires React and @payloadcms/ui as dependencies. The component is intended to be referenced in the Payload config for custom navigation. Input: none (receives no props); Output: navigation UI element.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Link } from '@payloadcms/ui'\\n\\nexport default function MyCustomNav() {\\n  return (\\n    <nav>\\n      <ul>\\n        <li>\\n          <Link href=\"/dashboard\">Dashboard</Link>\\n        </li>\\n      </ul>\\n    </nav>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Reusing Default Field Validation in Payload CMS (TypeScript)\nDESCRIPTION: This snippet illustrates how to augment Payload CMS's default field validation with custom logic. It first checks for a specific invalid value ('bad') and returns a custom error message. If the custom check passes, it calls the default `text` validation function imported from `payload/shared` to apply standard text field validations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { text } from 'payload/shared'\nimport type { Field } from 'payload' // Added import for context\n\nconst field: Field = {\n  name: 'notBad',\n  type: 'text',\n  validate: (val, args) => {\n    if (val === 'bad') return 'This cannot be \"bad\"'\n    return text(val, args) // highlight-line\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Collection Schema in Payload (TypeScript)\nDESCRIPTION: This snippet shows how to define a basic collection configuration using Payload's 'CollectionConfig' type. The example creates a 'Posts' collection with a single 'title' field of type 'text'. The configuration specifies both the collection 'slug' and 'fields'. Required dependency: Payload types (imported via 'payload'). Inputs: no runtime input—exported as configuration. Outputs: an exported named constant usable in the Payload config. Limitations: This is a minimal example and does not include advanced features such as access control, hooks, or authentication.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/collections.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Posts: CollectionConfig = {\n  slug: 'posts',\n  fields: [\n    {\n      name: 'title',\n      type: 'text',\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing beforeValidate Hook for Input Formatting in Payload TypeScript\nDESCRIPTION: Provides a practical example of a `beforeValidate` hook for a `username` text field in Payload CMS. This hook automatically trims whitespace and converts the input value to lowercase before server-side validation runs, ensuring data consistency. It receives hook arguments (implicitly including `value`) and returns the modified value.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/fields.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nconst usernameField: Field = {\n  name: 'username',\n  type: 'text',\n  hooks: {\n    beforeValidate: [\n      ({ value }) => {\n        // Trim whitespace and convert to lowercase\n        return value.trim().toLowerCase()\n      },\n    ],\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Core Types from the Payload Package (TypeScript)\nDESCRIPTION: This snippet shows how to import essential TypeScript types like `Config`, `CollectionConfig`, `GlobalConfig`, and `Field` directly from the core `payload` package. These types are crucial for defining Payload configurations (like collections and globals) and ensuring type safety when working with Payload's structure and APIs in a TypeScript project. Importing these types enhances developer experience with autocompletion and compile-time checks.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/concepts.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { Config, CollectionConfig, GlobalConfig, Field } from 'payload'\n```\n```\n\n----------------------------------------\n\nTITLE: Adding a New Custom View in Payload Config (TypeScript)\nDESCRIPTION: This configuration snippet shows how to add a completely new view to the Payload CMS admin panel. A unique key (`myCustomView`) is added to the `admin.components.views` object, specifying the required `Component` path (optionally with a named export using `#`) and the URL `path` where the view will be accessible.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-views.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    components: {\n      views: {\n        // highlight-start\n        myCustomView: {\n          Component: '/path/to/MyCustomView#MyCustomViewComponent',\n          path: '/my-custom-view',\n        },\n        // highlight-end\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Applying CORS Headers to Responses in Payload Custom Endpoints (TypeScript)\nDESCRIPTION: Demonstrates using the `headersWithCors` helper function from the `payload` package to include necessary CORS headers in the `Response` object returned by a custom endpoint. It takes the existing headers (instantiated as `new Headers()`) and the request object (`req`) to determine the correct CORS headers based on the main Payload configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { headersWithCors } from 'payload'\n\n// custom endpoint example\n{\n  path: '/:id/tracking',\n  method: 'post',\n  handler: async (req) => {\n    return Response.json(\n      { message: 'success' },\n      {\n        headers: headersWithCors({\n          headers: new Headers(),\n          req,\n        })\n      },\n    )\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Text Field Client Component - React with Payload - TypeScript\nDESCRIPTION: Defines a client-only custom text field for Payload CMS using React and TypeScript. This component, registered as a TextFieldClientComponent, spreads all props to the TextField UI component. It requires React, @payloadcms/ui, and the Payload type package. The 'use client' directive indicates client-side rendering only. Inputs and outputs directly follow the TextField component's API. This approach is suited for UI interactions handled solely on the client.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/text.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport React from 'react'\\nimport { TextField } from '@payloadcms/ui'\\nimport type { TextFieldClientComponent } from 'payload'\\n\\nexport const CustomTextFieldClient: TextFieldClientComponent = (props) => {\\n  return <TextField {...props} />\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Extending Drizzle Schema after Initialization with Payload Hook - TypeScript\nDESCRIPTION: This snippet demonstrates how to use PayloadCMS's afterSchemaInit hook within the sqliteAdapter to programmatically add new columns and composite indexes to an existing Drizzle schema table in TypeScript. The example shows adding an integer column (extra_integer_column) and a composite index (country_city_composite_index) to the places collection, using utility functions from @payloadcms/db-sqlite and @payloadcms/db-sqlite/drizzle/sqlite-core. Required dependencies include PayloadCMS, Drizzle ORM, and the relevant SQLite adapter packages. The afterSchemaInit hook receives utilities (schema, extendTable, adapter) enabling mutation of the schema before it is finalized.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/sqlite.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { sqliteAdapter } from '@payloadcms/db-sqlite'\nimport { index, integer } from '@payloadcms/db-sqlite/drizzle/sqlite-core'\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  collections: [\n    {\n      slug: 'places',\n      fields: [\n        {\n          name: 'country',\n          type: 'text',\n        },\n        {\n          name: 'city',\n          type: 'text',\n        },\n      ],\n    },\n  ],\n  db: sqliteAdapter({\n    afterSchemaInit: [\n      ({ schema, extendTable, adapter }) => {\n        extendTable({\n          table: schema.tables.places,\n          columns: {\n            extraIntegerColumn: integer('extra_integer_column'),\n          },\n          extraConfig: (table) => ({\n            country_city_composite_index: index(\n              'country_city_composite_index',\n            ).on(table.country, table.city),\n          }),\n        })\n\n        return schema\n      },\n    ],\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Using buildPaginatedListType Utility in Payload (TypeScript)\nDESCRIPTION: Provides an example of using Payload's `buildPaginatedListType` utility function to create a GraphQL type definition for a paginated list. It takes a unique name for the new type (e.g., 'AuthorPosts') and the GraphQL type of the items in the list (e.g., `payload.collections['posts'].graphQL?.type`) as arguments.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/extending.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildPaginatedListType } from '@payloadcms/graphql/types'\n\nexport const getMyPosts = (GraphQL, payload) => {\n  return {\n    args: {},\n    resolve: Resolver,\n    // The name of your new type has to be unique\n    type: buildPaginatedListType(\n      'AuthorPosts',\n      payload.collections['posts'].graphQL?.type,\n    ),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Default Access Control Function - Payload CMS - TypeScript\nDESCRIPTION: This snippet defines the default access control logic provided by Payload CMS, which checks if a user exists on the incoming request. The function expects an object with a `req` property containing a `user` field and returns `true` if the user is present, or `false` otherwise. No additional dependencies are required, but this function is intended to be used within the Payload CMS context and expects Payload to handle authentication and request structure. The function is limited to granting access based solely on user presence, without considering permissions or roles.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/overview.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst defaultPayloadAccess = ({ req: { user } }) => {\n  // Return `true` if a user is found\n  // and `false` if it is undefined or null\n  return Boolean(user) // highlight-line\n}\n```\n\n----------------------------------------\n\nTITLE: Using useDocumentInfo Hook in a Client Component (TSX)\nDESCRIPTION: This example demonstrates using the `useDocumentInfo` hook from `@payloadcms/ui` within a Payload Client Component (`'use client'`). This hook provides access to context about the current document or entity being viewed or edited, such as its `slug`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { useDocumentInfo } from '@payloadcms/ui'\n\nexport function MyClientComponent() {\n  const { slug } = useDocumentInfo() // highlight-line\n\n  return <p>{`Entity slug: ${slug}`}</p>\n}\n```\n\n----------------------------------------\n\nTITLE: Sanitizing Props in the Client Feature using Payload CMS in TypeScript\nDESCRIPTION: This code illustrates how to handle and sanitize props in Payload CMS's createClientFeature by accepting a function argument that processes client-side props. It takes context arguments like clientFunctions and props, performs transformation, and returns sanitizedClientFeatureProps alongside the actual client feature. The snippet relies on @payloadcms/richtext-lexical/client and highlights the requirement to process and return only serializable props for network transmission.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_25\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"createClientFeature<UnSanitizedClientProps, SanitizedClientProps>(\\n  ({\\n    clientFunctions,\\n    featureProviderMap,\\n    props,\\n    resolvedFeatures,\\n    unSanitizedEditorConfig,\\n  }) => {\\n    const sanitizedProps = doSomethingWithProps(props)\\n    return {\\n      sanitizedClientFeatureProps: sanitizedProps,\\n      //Actual client feature here...\\n    }\\n  },\\n)\\n\"\n```\n\n----------------------------------------\n\nTITLE: Installing @payloadcms/richtext-lexical via npm - Bash\nDESCRIPTION: This snippet demonstrates how to install the @payloadcms/richtext-lexical package using the npm package manager. It is a prerequisite for integrating the Lexical Rich Text Editor with Payload CMS. This command must be run in the project root where package.json is located. No parameters are required; it will add the dependency to your project's node_modules.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/richtext-lexical/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/richtext-lexical\n```\n\n----------------------------------------\n\nTITLE: Installing Slate Rich Text Editor Dependency - npm - Bash\nDESCRIPTION: Installs the @payloadcms/richtext-slate package using npm, which is required before configuring the Slate editor in Payload CMS. This step is necessary for subsequent imports and integration of the legacy editor. Requires npm as a prerequisite and should be run in the project's root directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/slate.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save @payloadcms/richtext-slate\n```\n\n----------------------------------------\n\nTITLE: Installing Lexical Rich Text Editor Package – Payload CMS (Bash)\nDESCRIPTION: Demonstrates how to install the @payloadcms/richtext-lexical package using pnpm. This command is necessary before using the Lexical-based editor in your Payload CMS project. Ensure pnpm is installed and run from the project root; successful installation adds the dependency to your node_modules and package.json.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/overview.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @payloadcms/richtext-lexical\n```\n\n----------------------------------------\n\nTITLE: Configuring Fallback Language in Payload CMS i18n Settings\nDESCRIPTION: Demonstrates how to set the `fallbackLanguage` option within the `i18n` configuration object in `payload.config.ts`. This specifies the language (defaulting to 'en') that Payload CMS will use if a user's preferred language is not available or supported.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/i18n.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  // highlight-start\n  i18n: {\n    fallbackLanguage: 'en', // default\n  },\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Overriding Lexical Editor Settings per Field – Payload CMS (TypeScript)\nDESCRIPTION: Shows how to override Lexical editor settings for specific fields in a collection by providing the editor property in a field definition. Requires @payloadcms/richtext-lexical and type { CollectionConfig } from Payload. The snippet sets up a Pages collection with a 'content' richText field, assigning lexicalEditor with individual options at the field level. Returns a customized collection config for advanced field-level control.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/overview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\nimport { lexicalEditor } from '@payloadcms/richtext-lexical'\n\nexport const Pages: CollectionConfig = {\n  slug: 'pages',\n  fields: [\n    {\n      name: 'content',\n      type: 'richText',\n      // Pass the Lexical editor here and override base settings as necessary\n      editor: lexicalEditor({}),\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Upload File Size Limit in Payload CMS TypeScript\nDESCRIPTION: This snippet demonstrates how to set a global file size limit for all uploads within a Payload CMS application. It modifies the base Payload config object by adding an 'upload' property with a 'limits' object, specifying 'fileSize' in bytes (5MB in this example). This applies to all collections unless overridden.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/overview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  collections: [\n    {\n      slug: 'media',\n      fields: [\n        {\n          name: 'alt',\n          type: 'text',\n        },\n      ],\n      upload: true,\n    },\n  ],\n  upload: {\n    limits: {\n      fileSize: 5000000, // 5MB, written in bytes\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS S3 Storage in Payload CMS with TypeScript\nDESCRIPTION: Integrates AWS S3 storage for file uploads in Payload CMS by importing and configuring the \"@payloadcms/storage-s3\" plugin. Requires AWS credentials (access key, secret key, region, and bucket) to be provided via environment variables, and allows specifying collections and an optional prefix. The \"config\" property must conform to AWS's S3ClientConfig. Enables direct client uploads to bypass Vercel's 4.5MB upload limit if \"clientUploads\" is set. Outputs a Payload CMS config object with S3 integration for specified collections.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { s3Storage } from '@payloadcms/storage-s3'\nimport { Media } from './collections/Media'\nimport { MediaWithPrefix } from './collections/MediaWithPrefix'\n\nexport default buildConfig({\n  collections: [Media, MediaWithPrefix],\n  plugins: [\n    s3Storage({\n      collections: {\n        media: true,\n        'media-with-prefix': {\n          prefix,\n        },\n      },\n      bucket: process.env.S3_BUCKET,\n      config: {\n        credentials: {\n          accessKeyId: process.env.S3_ACCESS_KEY_ID,\n          secretAccessKey: process.env.S3_SECRET_ACCESS_KEY,\n        },\n        region: process.env.S3_REGION,\n        // ... Other S3 configuration\n      },\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Live Preview Events with Payload CMS in React/TypeScript\nDESCRIPTION: This TypeScript/React snippet outlines the basic skeleton needed to subscribe to Live Preview events using Payload's subscribe and unsubscribe functions. It highlights integration points for event listening and state management in a custom React hook, but does not provide a full implementation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/client.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { subscribe, unsubscribe } from '@payloadcms/live-preview'\n\n// To build your own hook, subscribe to Live Preview events using the `subscribe` function\n// It handles everything from:\n// 1. Listening to `window.postMessage` events\n// 2. Merging initial data with active form state\n// 3. Populating relationships and uploads\n// 4. Calling the `onChange` callback with the result\n// Your hook should also:\n// 1. Tell the Admin Panel when it is ready to receive messages\n// 2. Handle the results of the `onChange` callback to update the UI\n// 3. Unsubscribe from the `window.postMessage` events when it unmounts\n```\n\n----------------------------------------\n\nTITLE: Adding a Row to an Array Field - PayloadCMS useForm - TypeScript/TSX\nDESCRIPTION: This snippet illustrates how to use the addFieldRow method from the useForm hook to add a new row to an array or block field inside a PayloadCMS admin UI. It relies on importing useForm from @payloadcms/ui and binding addFieldRow to a button click event. The relevant parameters are path (the field's path), rowIndex (where to insert the row), subFieldState (field state values), and optional blockType for block arrays. Inputs are field metadata and new row data; output is a modified fields state. Requires @payloadcms/ui and integration in a React component.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useForm } from \"@payloadcms/ui\"\n\nexport const CustomArrayManager = () => {\n  const { addFieldRow } = useForm()\n\nreturn (\n\n<button\n  type=\"button\"\n  onClick={() => {\n    addFieldRow({\n      path: 'arrayField',\n      schemaPath: 'arrayField',\n      rowIndex: 0, // optionally specify the index to add the row at\n      subFieldState: {\n        textField: {\n          initialValue: 'New row text',\n          valid: true,\n          value: 'New row text',\n        },\n      },\n      // blockType: \"yourBlockSlug\",\n      // ^ if managing a block array, you need to specify the block type\n    })\n  }}\n>\n  Add Row\n</button>\n) }\n```\n\nLANGUAGE: tsx\nCODE:\n```\nconst ExampleCollection = {\nslug: \"example-collection\",\nfields: [\n{\nname: \"arrayField\",\ntype: \"array\",\nfields: [\n{\nname: \"textField\",\ntype: \"text\",\n},\n],\n},\n{\ntype: \"ui\",\nname: \"customArrayManager\",\nadmin: {\ncomponents: {\nField: '/path/to/CustomArrayManagerField',\n},\n},\n},\n],\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Azure Blob Storage Adapter in PayloadCMS (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to integrate the @payloadcms/storage-azure package into a PayloadCMS configuration. It imports the azureStorage plugin and configures multiple collections to use Azure Blob Storage, supporting per-collection options such as custom prefixes. The setup reads Azure storage options like connectionString and containerName from environment variables. Required dependencies are @payloadcms/storage-azure and matching PayloadCMS collections. The function buildConfig expects arrays of collections and plugins, and the output is a complete PayloadCMS configuration object. Proper setup of environment variables and existing collections is necessary.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/storage-azure/README.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { azureStorage } from '@payloadcms/storage-azure'\nimport { Media } from './collections/Media'\nimport { MediaWithPrefix } from './collections/MediaWithPrefix'\n\nexport default buildConfig({\n  collections: [Media, MediaWithPrefix],\n  plugins: [\n    azureStorage({\n      collections: {\n        media: true,\n        'media-with-prefix': {\n          prefix,\n        },\n      },\n      allowContainerCreate: process.env.AZURE_STORAGE_ALLOW_CONTAINER_CREATE === 'true',\n      baseURL: process.env.AZURE_STORAGE_ACCOUNT_BASEURL,\n      connectionString: process.env.AZURE_STORAGE_CONNECTION_STRING,\n      containerName: process.env.AZURE_STORAGE_CONTAINER_NAME,\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Sending an Email Using Payload's sendEmail API (TypeScript)\nDESCRIPTION: This example demonstrates using the sendEmail method from the Payload instance to dispatch an email with recipient, subject, and body data. The message object includes the requisite to, subject, and text properties. No external dependencies are required beyond an initialized Payload setup with email configuration. Inputs are provided in the method call; outputs include response from the sendEmail API—subject to the active email adapter's implementation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/email/overview.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Example of sending an email\nconst email = await payload.sendEmail({\n  to: 'test@example.com',\n  subject: 'This is a test email',\n  text: 'This is my message body',\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Action Component for Payload Admin (TSX)\nDESCRIPTION: Implements a simple React function component intended for use as an action in the Payload CMS Admin Panel header. The component displays a button that triggers a JavaScript alert when clicked. Must be referenced in the config actions property, and requires React support in the build toolchain. Receives no props and renders a button element, which can be replaced by more complex UI as desired.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyCustomAction() {\n  return (\n    <button onClick={() => alert('Hello, world!')}>\n      This is a custom action component\n    </button>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Nodemailer Transport Setup Using createTransport in Payload CMS (TypeScript)\nDESCRIPTION: This example shows how to manually create a custom Nodemailer transport and apply it within Payload CMS configuration. It imports nodemailer and uses createTransport to provide the transport option directly to nodemailerAdapter, allowing usage of any supported transport. Dependency: nodemailer and @payloadcms/email-nodemailer must be installed. Environment variables provide SMTP details; the output is a configured Payload instance employing a custom transport implementation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/email/overview.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { nodemailerAdapter } from '@payloadcms/email-nodemailer'\nimport nodemailer from 'nodemailer'\n\nexport default buildConfig({\n  email: nodemailerAdapter({\n    defaultFromAddress: 'info@payloadcms.com',\n    defaultFromName: 'Payload',\n    // Any Nodemailer transport can be used\n    transport: nodemailer.createTransport({\n      host: process.env.SMTP_HOST,\n      port: 587,\n      auth: {\n        user: process.env.SMTP_USER,\n        pass: process.env.SMTP_PASS,\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom ID Field in a Payload CMS Collection (TypeScript)\nDESCRIPTION: This snippet shows how to override the default auto-generated ID field in a Payload CMS collection. A field with the specific `name: 'id'` is added to the `fields` array, specifying its `type` (e.g., `number`) and making it `required`. Note the constraints mentioned: only 'number' or 'text' types are allowed, and 'text' IDs cannot contain '/' or '.' characters.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  fields: [\n    {\n      name: 'id', // highlight-line\n      required: true,\n      type: 'number',\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Building Payload Custom Server Component with Default Props (TSX)\nDESCRIPTION: This TSX snippet provides an example of a custom React Server Component designed for Payload. It demonstrates receiving and utilizing the default `payload` prop (an instance of the Payload Local API) to fetch data asynchronously within the component.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport React from 'react'\nimport type { Payload } from 'payload'\n\nasync function MyServerComponent({\n  payload, // highlight-line\n}: {\n  payload: Payload\n}) {\n  const page = await payload.findByID({\n    collection: 'pages',\n    id: '123',\n  })\n\n  return <p>{page.title}</p>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Validation Rules to Payload GraphQL (TypeScript)\nDESCRIPTION: Shows how to enforce custom validation rules for all incoming GraphQL queries by providing a validationRules function in the Payload configuration. Requires @payloadcms/graphql/types and proper configuration in Payload CMS. The NoProductionIntrospection rule disables GraphQL introspection in production by detecting forbidden schema/type queries and reporting a GraphQL error. Expects a config environment and runs only in production mode.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/overview.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { GraphQL } from '@payloadcms/graphql/types'\\nimport { buildConfig } from 'payload'\\n\\nexport default buildConfig({\\n  // ...\\n  graphQL: {\\n    validationRules: (args) => [NoProductionIntrospection],\\n  },\\n  // ...\\n})\\n\\nconst NoProductionIntrospection: GraphQL.ValidationRule = (context) => ({\\n  Field(node) {\\n    if (process.env.NODE_ENV === 'production') {\\n      if (node.name.value === '__schema' || node.name.value === '__type') {\\n        context.reportError(\\n          new GraphQL.GraphQLError(\\n            'GraphQL introspection is not allowed, but the query contained __schema or __type',\\n            { nodes: [node] },\\n          ),\\n        )\\n      }\\n    }\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing a Basic Client Feature in TypeScript\nDESCRIPTION: Demonstrates the basic structure of a client feature file (`feature.client.ts`). It uses the 'use client' directive and calls `createClientFeature` from '@payloadcms/richtext-lexical/client' to initialize an empty client feature. This file is intended to run only in the browser environment.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n'use client'\n\nimport { createClientFeature } from '@payloadcms/richtext-lexical/client'\n\nexport const MyClientFeature = createClientFeature({})\n```\n\n----------------------------------------\n\nTITLE: Defining a PayloadCMS Server Feature with an Async Function in TypeScript\nDESCRIPTION: Illustrates defining the `feature` property of `createServerFeature` as an asynchronous function. This function receives contextual arguments like `config`, `props`, `resolvedFeatures`, etc., enabling dynamic feature configuration or property sanitization during the Payload sanitization process when the feature is loaded.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport { createServerFeature } from '@payloadcms/richtext-lexical'\n\ncreateServerFeature({\n  //...\n  feature: async ({\n    config,\n    isRoot,\n    props,\n    resolvedFeatures,\n    unSanitizedEditorConfig,\n    featureProviderMap,\n  }) => {\n    return {\n      //Actual server feature here...\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Relationship Field Client Component in PayloadCMS Admin (TSX)\nDESCRIPTION: Shows a custom React component for rendering the relationship field client-side in PayloadCMS. This is a functional component using the \\'use client\\' directive, importing React, the RelationshipField UI module, and appropriate type definitions. All props received are spread directly into the RelationshipField. This allows for customization or extension of the client UI without modifying the core admin UI components. Dependencies: React, @payloadcms/ui, PayloadCMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_15\n\nLANGUAGE: TSX\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { RelationshipField } from '@payloadcms/ui'\nimport type { RelationshipFieldClientComponent } from 'payload'\n\nexport const CustomRelationshipFieldClient: RelationshipFieldClientComponent = (\n  props,\n) => {\n  return <RelationshipField {...props} />\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting All Payload Migrations (Shell)\nDESCRIPTION: Provides the command-line instruction to revert all migrations that have ever been applied, effectively resetting the database schema changes managed by migrations to their initial state before any migrations were run.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nnpm run payload migrate:reset\n```\n\n----------------------------------------\n\nTITLE: Defining Field Hooks Structure in Payload TypeScript\nDESCRIPTION: This snippet shows the basic structure for adding a `hooks` property to a Payload Field configuration object in TypeScript. It imports the `Field` type from Payload and outlines where hook functions should be defined within the `hooks` object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/fields.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const FieldWithHooks: Field = {\n  // ...\n  hooks: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating Custom Translations into Payload CMS Configuration\nDESCRIPTION: Shows how to import the `customTranslations` object (defined in a separate file) into the main `payload.config.ts` file. These custom translations are then merged with Payload's defaults by assigning the imported object to the `i18n.translations` configuration key.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/i18n.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// <rootDir>/payload.config.ts\n\nimport { buildConfig } from 'payload'\n\nimport { customTranslations } from './custom-translations'\n\nexport default buildConfig({\n  //...\n  i18n: {\n    translations: customTranslations,\n  },\n  //...\n})\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom UI Field to a Collection in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript example shows the structure of a CollectionConfig in Payload CMS, where a UI field is added as part of the fields array. It demonstrates required configuration such as `name` and `type`, and it specifies custom React components for both the edit view and cell rendering through the `admin.components` option. This requires the custom components to be accessible at the specified paths and assumes that Payload is properly set up with TypeScript and React. Inputs include field configuration; outputs are dynamic UI elements in the admin interface. This is intended for enhancing editor experience, not modifying stored data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/ui.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'myCustomUIField', // required\n      type: 'ui', // required\n      admin: {\n        components: {\n          Field: '/path/to/MyCustomUIField',\n          Cell: '/path/to/MyCustomUICell',\n        },\n      },\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Filter Component in Payload Field (TypeScript)\nDESCRIPTION: Illustrates how to assign a custom `Filter` component to a 'text' field in Payload CMS. This is done by setting the `admin.components.Filter` property to the path of the custom React component, which will then be used in the \"Filter By\" dropdown in the List View.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_23\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const myField: Field = {\n  name: 'myField',\n  type: 'text',\n  admin: {\n    components: {\n      Filter: '/path/to/MyCustomFilterComponent', // highlight-line\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Definition for `useField` Hook Return Value\nDESCRIPTION: This TypeScript code defines the `FieldType<T>` type alias, outlining the structure of the object returned by the `useField` hook. It includes properties like `value`, `setValue`, `path`, `errorMessage`, `readOnly`, `permissions`, form state flags (`formInitializing`, `formProcessing`, `formSubmitted`), and potentially row data for array/block fields.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\ntype FieldType<T> = {\n  errorMessage?: string\n  errorPaths?: string[]\n  filterOptions?: FilterOptionsResult\n  formInitializing: boolean\n  formProcessing: boolean\n  formSubmitted: boolean\n  initialValue?: T\n  path: string\n  permissions: FieldPermissions\n  readOnly?: boolean\n  rows?: Row[]\n  schemaPath: string\n  setValue: (val: unknown, disableModifyingForm?: boolean) => void\n  showError: boolean\n  valid?: boolean\n  value: T\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Constraint for Query Preset Document Access - TypeScript\nDESCRIPTION: This snippet adds a custom document-level access constraint to Query Presets in Payload CMS, permitting users to define which roles are authorized for specific operations through the 'constraints' property. The example introduces a 'Specific Roles' option, with corresponding UI fields for role selection and an access function that grants access if the user's roles match those selected. Dependencies include Payload CMS, a configured user model with roles, and appropriate admin panel setup to display the fields. Key parameters are the custom constraint objects with label, value, selectable fields, and a callback access function. The function is used at runtime to check if the current user fits one of the required roles.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/query-presets/overview.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  queryPresets: {\n    // ...\n    // highlight-start\n    constraints: {\n      read: [\n        {\n          label: 'Specific Roles',\n          value: 'specificRoles',\n          fields: [\n            {\n              name: 'roles',\n              type: 'select',\n              hasMany: true,\n              options: [\n                { label: 'Admin', value: 'admin' },\n                { label: 'User', value: 'user' },\n              ],\n            },\n          ],\n          access: ({ req: { user } }) => ({\n            'access.read.roles': {\n              in: [user?.roles],\n            },\n          }),\n        },\n      ],\n      // highlight-end\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS to Allow All Origins in Payload Config (TypeScript)\nDESCRIPTION: Shows how to configure Cross-Origin Resource Sharing (CORS) in the Payload config to accept requests from any domain by setting the `cors` property to a wildcard string `'*'`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  cors: '*', // highlight-line\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Code Field Client Component - React (TSX)\nDESCRIPTION: Defines a client-side (browser) Code Field React component using the 'use client' directive for Next.js compatibility. Imports React, CodeField from '@payloadcms/ui', and required Payload types. The component forwards all props to CodeField, allowing customization of code editor behavior on the client side. Useful for injecting custom logic or UI into the Admin Panel for Code fields.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/code.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { CodeField } from '@payloadcms/ui'\nimport type { CodeFieldClientComponent } from 'payload'\n\nexport const CustomCodeFieldClient: CodeFieldClientComponent = (props) => {\n  return <CodeField {...props} />\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Lexical DecoratorNode in TypeScript/TSX\nDESCRIPTION: Provides a detailed example of a custom Lexical `DecoratorNode` (`MyNode`) implementation in a `.tsx` file. It defines static methods like `getType`, `clone`, `importDOM`, `importJSON`, `exportDOM`, and `exportJSON` for node identification, cloning, HTML/JSON conversion, and serialization. The `createDOM` method defines the outer HTML element, and `decorate` renders a lazy-loaded React component (`MyNodeComponent`) inside it. Helper functions `$createMyNode` and `$isMyNode` are also included for creating and identifying instances of this node.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {\n  DOMConversionMap,\n  DOMConversionOutput,\n  DOMExportOutput,\n  EditorConfig,\n  LexicalNode,\n  SerializedLexicalNode,\n} from '@payloadcms/richtext-lexical/lexical'\n\nimport { $applyNodeReplacement, DecoratorNode } from '@payloadcms/richtext-lexical/lexical'\n\n// SerializedLexicalNode is the default lexical node.\n// By setting your SerializedMyNode type to SerializedLexicalNode,\n// you are basically saying that this node does not save any additional data.\n// If you want your node to save data, feel free to extend it\nexport type SerializedMyNode = SerializedLexicalNode\n\n// Lazy-import the React component to your node here\nconst MyNodeComponent = React.lazy(() =>\n  import('../component/index.js').then((module) => ({\n    default: module.MyNodeComponent,\n  })),\n)\n\n/**\n * This node is a DecoratorNode. DecoratorNodes allow you to render React components in the editor.\n *\n * They need both createDom and decorate functions. createDom => outside of the html. decorate => React Component inside of the html.\n *\n * If we used DecoratorBlockNode instead, we would only need a decorate method\n */\nexport class MyNode extends DecoratorNode<React.ReactElement> {\n  static clone(node: MyNode): MyNode {\n    return new MyNode(node.__key)\n  }\n\n  static getType(): string {\n    return 'myNode'\n  }\n\n  /**\n   * Defines what happens if you copy a div element from another page and paste it into the lexical editor\n   *\n   * This also determines the behavior of lexical's internal HTML -> Lexical converter\n   */\n  static importDOM(): DOMConversionMap | null {\n    return {\n      div: () => ({\n        conversion: $yourConversionMethod,\n        priority: 0,\n      }),\n    }\n  }\n\n  /**\n   * The data for this node is stored serialized as JSON. This is the \"load function\" of that node: it takes the saved data and converts it into a node.\n   */\n  static importJSON(serializedNode: SerializedMyNode): MyNode {\n    return $createMyNode()\n  }\n\n  /**\n   * Determines how the hr element is rendered in the lexical editor. This is only the \"initial\" / \"outer\" HTML element.\n   */\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = document.createElement('div')\n    return element\n  }\n\n  /**\n   * Allows you to render a React component within whatever createDOM returns.\n   */\n  decorate(): React.ReactElement {\n    return <MyNodeComponent nodeKey={this.__key} />\n  }\n\n  /**\n   * Opposite of importDOM, this function defines what happens when you copy a div element from the lexical editor and paste it into another page.\n   *\n   * This also determines the behavior of lexical's internal Lexical -> HTML converter\n   */\n  exportDOM(): DOMExportOutput {\n    return { element: document.createElement('div') }\n  }\n  /**\n   * Opposite of importJSON. This determines what data is saved in the database / in the lexical editor state.\n   */\n  exportJSON(): SerializedLexicalNode {\n    return {\n      type: 'myNode',\n      version: 1,\n    }\n  }\n\n  getTextContent(): string {\n    return '\\n'\n  }\n\n  isInline(): false {\n    return false\n  }\n\n  updateDOM(): boolean {\n    return false\n  }\n}\n\n// This is used in the importDOM method. Totally optional if you do not want your node to be created automatically when copy & pasting certain dom elements\n// into your editor.\nfunction $yourConversionMethod(): DOMConversionOutput {\n  return { node: $createMyNode() }\n}\n\n// This is a utility method to create a new MyNode. Utility methods prefixed with $ make it explicit that this should only be used within lexical\nexport function $createMyNode(): MyNode {\n  return $applyNodeReplacement(new MyNode())\n}\n\n// This is just a utility method you can use to check if a node is a MyNode. This also ensures correct typing.\nexport function $isMyNode(\n  node: LexicalNode | null | undefined,\n): node is MyNode {\n  return node instanceof MyNode\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Custom Storage Adapter Interface (TypeScript)\nDESCRIPTION: TypeScript interface `GeneratedAdapter` defining the required and optional properties for a custom Payload CMS storage adapter built using `@payloadcms/plugin-cloud-storage`. It includes methods for handling uploads, deletes, URL generation, static file handling, and initialization hooks.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nexport interface GeneratedAdapter {\n  /**\n   * Additional fields to be injected into the base collection and image sizes\n   */\n  fields?: Field[]\n  /**\n   * Generates the public URL for a file\n   */\n  generateURL?: GenerateURL\n  handleDelete: HandleDelete\n  handleUpload: HandleUpload\n  name: string\n  onInit?: () => void\n  staticHandler: StaticHandler\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Header Component - React TSX\nDESCRIPTION: Exports a simple header React component displaying a title banner. Used for injecting custom content (such as notifications or banners) above the admin UI header. Input: none; output: <header> JSX. Intended for use with the Payload config's Header component array.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyCustomHeader() {\\n  return (\\n    <header>\\n      <h1>My Custom Header</h1>\\n    </header>\\n  )\\n}\n```\n\n----------------------------------------\n\nTITLE: Enforcing Document Lock on Update Operation in Payload CMS with TypeScript\nDESCRIPTION: This TypeScript snippet shows how to use the 'overrideLock' parameter when performing an update operation via Payload CMS' API. It requires an initialized Payload instance and a valid document id. Setting 'overrideLock: false' will enforce the document lock, ensuring that the update is blocked if another user holds the lock. Inputs include collection name, document id, update data, and the lock override flag; output is the result of the update operation or an error if the document is locked.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/locked-documents.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = await payload.update({\n  collection: 'posts',\n  id: '123',\n  data: {\n    title: 'New title',\n  },\n  overrideLock: false, // Enforces the document lock, preventing updates if the document is locked\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Custom Admin View Component Structure (TSX/React)\nDESCRIPTION: This snippet presents a basic structure for a custom admin view component in Payload CMS using React and TypeScript (TSX). It defines a functional component `MyCustomView` that accepts `AdminViewServerProps` and renders simple JSX content, utilizing the `Gutter` component from `@payloadcms/ui` for layout.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-views.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { AdminViewServerProps } from 'payload'\n\nimport { Gutter } from '@payloadcms/ui'\nimport React from 'react'\n\nexport function MyCustomView(props: AdminViewServerProps) {\n  return (\n    <Gutter>\n      <h1>Custom Default Root View</h1>\n      <p>This view uses the Default Template.</p>\n    </Gutter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using useTranslation Hook to Retrieve and Display Translated Strings - PayloadCMS - TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use the useTranslation hook in a TypeScript component to access the t utility for rendering translated strings. It requires the useTranslation hook to be available from the relevant i18n package or context within PayloadCMS, and expects that translation keys are defined within the corresponding locale files. The t function accepts a string key and returns a localized string if the key is available for the active locale; otherwise, it may fall back to a default. Only translation keys previously added to the translation files can be accessed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst { t } = useTranslation()\n// ...\nt('yourStringKey')\n```\n\n----------------------------------------\n\nTITLE: Extending Admin Options in a GlobalConfig (TypeScript)\nDESCRIPTION: This snippet shows how to add an 'admin' property to a GlobalConfig object in Payload CMS using TypeScript. It demonstrates where to attach various admin configuration options to influence admin panel behavior. You must import 'GlobalConfig' from 'payload' and apply admin-related options inside the 'admin' property. The setup enables customization of navigation grouping, visibility, and components for the Global. Input parameters are additional settings for admin functionality, affecting only the admin panel and not API behaviors.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/globals.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { GlobalConfig } from 'payload'\n\nexport const MyGlobal: GlobalConfig = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Querying with Locale and Fallback in GraphQL API (GraphQL)\nDESCRIPTION: Shows how to query localized documents from the Payload CMS GraphQL API by passing 'locale' and 'fallbackLocale' arguments. The provided locale is converted to a valid enum automatically, while 'fallbackLocale' set to 'none' disables fallback behavior. Requires a working GraphQL endpoint and valid locale names. Returns a docs array with titles in the specified locale.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/localization.mdx#_snippet_6\n\nLANGUAGE: GraphQL\nCODE:\n```\nquery {\n  Posts(locale: de, fallbackLocale: none) {\n    docs {\n      title\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sanitizing Props in the Server Feature using Payload CMS in TypeScript\nDESCRIPTION: This snippet describes how to implement prop sanitization logic for a server feature using Payload CMS's createServerFeature. The 'feature' key is set to an async function that receives several context parameters including the raw (unsanitized) props and transforms them using a custom function before returning them as sanitizedServerFeatureProps. The code depends on @payloadcms/richtext-lexical/server and emphasizes the requirement to return sanitized props explicitly. Inputs include config and the received props, with sanitized/validated outputs returned for use in the server feature.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_24\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"createServerFeature<UnSanitizedProps, SanitizedProps, UnSanitizedClientProps>({\\n  //...\\n  feature: async ({\\n    config,\\n    isRoot,\\n    props,\\n    resolvedFeatures,\\n    unSanitizedEditorConfig,\\n    featureProviderMap,\\n  }) => {\\n    const sanitizedProps = doSomethingWithProps(props)\\n\\n    return {\\n      sanitizedServerFeatureProps: sanitizedProps,\\n      //Actual server feature here...\\n    }\\n  },\\n})\\n\"\n```\n\n----------------------------------------\n\nTITLE: Securing a Custom Admin View Component (TSX/React)\nDESCRIPTION: This snippet illustrates a basic method for securing a custom Payload admin view. The component checks if a `user` object exists within the `initPageResult` prop (passed via `AdminViewServerProps`). If no user is logged in, it renders a message indicating restricted access; otherwise, it renders the intended view content.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-views.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { AdminViewServerProps } from 'payload'\n\nimport { Gutter } from '@payloadcms/ui'\nimport React from 'react'\n\nexport function MyCustomView({ initPageResult }: AdminViewServerProps) {\n  const {\n    req: { user },\n  } = initPageResult\n\n  if (!user) {\n    return <p>You must be logged in to view this page.</p>\n  }\n\n  return (\n    <Gutter>\n      <h1>Custom Default Root View</h1>\n      <p>This view uses the Default Template.</p>\n    </Gutter>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Raw HTML to Lexical Editor State using JSDOM (Server)\nDESCRIPTION: Illustrates how to convert a raw HTML string back into Payload's Lexical `SerializedEditorState` JSON format. This server-side operation uses the `convertHTMLToLexical` function, requiring the Payload configuration (obtained via `editorConfigFactory.default`) and the `JSDOM` library (which must be installed separately and passed in) to parse the HTML.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-html.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  convertHTMLToLexical,\n  editorConfigFactory,\n} from '@payloadcms/richtext-lexical'\n// Make sure you have jsdom and @types/jsdom installed\nimport { JSDOM } from 'jsdom'\n\nconst html = convertHTMLToLexical({\n  editorConfig: await editorConfigFactory.default({\n    config, // Your Payload Config\n  }),\n  html: '<p>text</p>',\n  JSDOM, // Pass in the JSDOM import; it's not bundled to keep package size small\n})\n```\n\n----------------------------------------\n\nTITLE: Importing and Appending Drizzle Schemas During Schema Initialization (TypeScript)\nDESCRIPTION: Illustrates importing pre-defined Drizzle ORM schemas ('users' and 'countries') into a Payload CMS configuration and extending the database schema using the beforeSchemaInit hook in the Postgres adapter. The approach enables integration of existing or introspected schemas with Payload, ensuring that migrations or extensions are smooth and data models remain consistent. Import paths and dependencies should reflect the project's file layout. Avoid table name collisions by adjusting slugs or dbName properties for overlapping Payload collections.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/postgres.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { postgresAdapter } from '@payloadcms/db-postgres'\nimport { users, countries } from '../drizzle/schema'\n\npostgresAdapter({\n  beforeSchemaInit: [\n    ({ schema, adapter }) => {\n      return {\n        ...schema,\n        tables: {\n          ...schema.tables,\n          users,\n          countries,\n        },\n      }\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Augmenting Payload RequestContext Type (TypeScript)\nDESCRIPTION: Demonstrates how to use TypeScript's declaration merging (type augmentation) to add custom properties to the default Payload `RequestContext` interface. This allows for stricter type checking of the `context` object throughout the application.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/context.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RequestContext as OriginalRequestContext } from 'payload'\n\ndeclare module 'payload' {\n  // Create a new interface that merges your additional fields with the original one\n  export interface RequestContext extends OriginalRequestContext {\n    myObject?: string\n    // ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Typed SEO Title Generation Function in TypeScript\nDESCRIPTION: This example illustrates how to use the imported `GenerateTitle` type from `@payloadcms/plugin-seo/types` in conjunction with generated Payload types (like `Page` from `./payload-types.ts`). It shows the definition of a type-safe asynchronous function `generateTitle` that takes the document (`doc`) and locale as input and returns a custom title string based on the document's data.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Page } from './payload-types.ts'\n\nimport type { GenerateTitle } from '@payloadcms/plugin-seo/types'\n\nconst generateTitle: GenerateTitle<Page> = async ({ doc, locale }) => {\n  return `Website.com — ${doc?.title}`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Upload Field with filterOptions - PayloadCMS TypeScript\nDESCRIPTION: This code snippet demonstrates how to define an upload field in PayloadCMS using TypeScript, with the filterOptions property enforcing that only uploads with a mimeType containing 'image' are allowed. The filterOptions object applies a Where query filter both for UI selection and input validation. Requires PayloadCMS as a dependency, and should be used within a collection or global configuration. The input field is limited to files with MIME types including 'image', and further custom validation may require invoking default validators as per documentation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/upload.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst uploadField = {\n  name: 'image',\n  type: 'upload',\n  relationTo: 'media',\n  filterOptions: {\n    mimeType: { contains: 'image' },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating the SEO Plugin in Payload Config - TypeScript\nDESCRIPTION: This TypeScript code demonstrates how to import and register the seoPlugin in the plugins array of your Payload configuration. It configures the plugin for specific collections (e.g., 'pages'), links the uploads collection for meta images, and provides functions for dynamic meta title and description generation. Dependencies include the Payload CMS, the @payloadcms/plugin-seo package, and valid collection definitions. Parameters such as collections, uploadsCollection, generateTitle, and generateDescription customize SEO integration. The config should be exported as the default for Payload to consume.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload';\nimport { seoPlugin } from '@payloadcms/plugin-seo';\n\nconst config = buildConfig({\n  collections: [\n    {\n      slug: 'pages',\n      fields: []\n    },\n    {\n      slug: 'media',\n      upload: {\n        staticDir: // path to your static directory,\n      },\n      fields: []\n    }\n  ],\n  plugins: [\n    seoPlugin({\n      collections: [\n        'pages',\n      ],\n      uploadsCollection: 'media',\n      generateTitle: ({ doc }) => `Website.com — ${doc.title}`,\n      generateDescription: ({ doc }) => doc.excerpt\n    })\n  ]\n});\n\nexport default config;\n```\n\n----------------------------------------\n\nTITLE: Creating Database Migrations - Bash\nDESCRIPTION: This snippet demonstrates how to create new database migration files for a Payload CMS project using the pnpm CLI. It assumes pnpm and all project dependencies are installed, and that the working directory is the project root. Input: none. Output: new migration SQL files in the migrations folder, to be committed and deployed with config changes. Ensure correct configuration of your database adapter before running this command.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/with-vercel-postgres/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm payload migrate:create\n```\n\n----------------------------------------\n\nTITLE: Implementing a Lexical Plugin to Insert a Custom Node (TypeScript/TSX)\nDESCRIPTION: Provides an example of a Lexical plugin (`MyNodePlugin`) implemented as a React component. It uses the 'use client' directive and imports necessary functions from Lexical and Payload. The plugin utilizes the `useLexicalComposerContext` hook to access the editor instance and `useEffect` to register a command (`INSERT_MYNODE_COMMAND`). When this command is dispatched, it inserts a new instance of `MyNode` (created using `$createMyNode`) into the editor at the current selection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n'use client'\nimport type { LexicalCommand } from '@payloadcms/richtext-lexical/lexical'\n\nimport {\n  createCommand,\n  $getSelection,\n  $isRangeSelection,\n  COMMAND_PRIORITY_EDITOR,\n} from '@payloadcms/richtext-lexical/lexical'\n\nimport { useLexicalComposerContext } from '@payloadcms/richtext-lexical/lexical/react/LexicalComposerContext'\nimport { $insertNodeToNearestRoot } from '@payloadcms/richtext-lexical/lexical/utils'\nimport { useEffect } from 'react'\n\nimport type { PluginComponent } from '@payloadcms/richtext-lexical' // type imports can be imported from @payloadcms/richtext-lexical - even on the client\n\nimport { $createMyNode } from '../nodes/MyNode'\nimport './index.scss'\n\nexport const INSERT_MYNODE_COMMAND: LexicalCommand<void> = createCommand(\n  'INSERT_MYNODE_COMMAND',\n)\n\n/**\n * Plugin which registers a lexical command to insert a new MyNode into the editor\n */\nexport const MyNodePlugin: PluginComponent = () => {\n  // The useLexicalComposerContext hook can be used to access the lexical editor instance\n  const [editor] = useLexicalComposerContext()\n\n  useEffect(() => {\n    return editor.registerCommand(\n      INSERT_MYNODE_COMMAND,\n      (type) => {\n        const selection = $getSelection()\n\n        if (!$isRangeSelection(selection)) {\n          return false\n        }\n\n        const focusNode = selection.focus.getNode()\n\n        if (focusNode !== null) {\n          const newMyNode = $createMyNode()\n          $insertNodeToNearestRoot(newMyNode)\n        }\n\n        return true\n      },\n      COMMAND_PRIORITY_EDITOR,\n    )\n  }, [editor])\n\n  return null\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing SQLite Directly within a Migration (TypeScript)\nDESCRIPTION: Shows how to execute SQL queries directly against an SQLite database within a Payload migration's `up` function. It imports `MigrateUpArgs` and the `sql` tag function from `@payloadcms/db-sqlite`. The `up` function receives the `db` object along with `payload` and `req`. Direct SQL queries are executed using `db.run()` with the `sql` template literal tag. Note that transactions are disabled by default in SQLite with Payload, so operations might not be atomic unless explicitly configured.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { type MigrateUpArgs, sql } from '@payloadcms/db-sqlite'\n\nexport async function up({ db, payload, req }: MigrateUpArgs): Promise<void> {\n  const { rows: posts } = await db.run(sql`SELECT * from posts`)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Tabs Field in Payload CMS TypeScript\nDESCRIPTION: This snippet demonstrates the basic structure for defining a Tabs field in a Payload CMS field configuration using TypeScript. It shows setting the `type` property to `'tabs'` and including the required `tabs` array, which will contain the configuration for individual tabs.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/tabs.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyTabsField: Field = {\n  // ...\n  // highlight-start\n  type: 'tabs',\n  tabs: [\n    // ...\n  ],\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Conditionally Registering Nodes in PayloadCMS Server Features in TypeScript\nDESCRIPTION: Shows how to conditionally add nodes to a server feature based on the presence of another feature. It uses the `featureProviderMap` (passed to the `feature` function) to check if a feature with the key 'unorderedList' exists. If it does, the `ListItem` node is not added by this `OrderedListFeature`, preventing duplicate node registrations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport { createServerFeature, createNode } from '@payloadcms/richtext-lexical'\n\nexport const OrderedListFeature = createServerFeature({\n  feature: ({ featureProviderMap }) => {\n    return {\n      // ...\n      nodes: featureProviderMap.has('unorderedList')\n        ? []\n        : [\n            createNode({\n              // ...\n            }),\n          ],\n    }\n  },\n  key: 'orderedList',\n})\n```\n\n----------------------------------------\n\nTITLE: Example Payload CMS Paginated Find Response (JSON)\nDESCRIPTION: This JSON object illustrates the structure of a response from a paginated `find` query in Payload CMS. It includes an array of documents (`docs`) and various metadata properties (`totalDocs`, `limit`, `page`, `totalPages`, `pagingCounter`, `hasPrevPage`, `hasNextPage`, `prevPage`, `nextPage`) which describe the pagination state and the overall dataset.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/pagination.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  // Document Array // highlight-line\n  \"docs\": [\n    {\n      \"title\": \"Page Title\",\n      \"description\": \"Some description text\",\n      \"priority\": 1,\n      \"createdAt\": \"2020-10-17T01:19:29.858Z\",\n      \"updatedAt\": \"2020-10-17T01:19:29.858Z\",\n      \"id\": \"5f8a46a1dd05db75c3c64760\"\n    }\n  ],\n  // Metadata // highlight-line\n  \"totalDocs\": 6,\n  \"limit\": 1,\n  \"totalPages\": 6,\n  \"page\": 1,\n  \"pagingCounter\": 1,\n  \"hasPrevPage\": false,\n  \"hasNextPage\": true,\n  \"prevPage\": null,\n  \"nextPage\": 2\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom SaveButton Server Component (TSX)\nDESCRIPTION: Example of a custom React server component for the Save button. It imports the base `SaveButton` from `@payloadcms/ui`, receives `SaveButtonServerProps`, and renders a customized button, potentially with a different label or added logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport React from 'react'\nimport { SaveButton } from '@payloadcms/ui'\nimport type { SaveButtonServerProps } from 'payload'\n\nexport function MySaveButton(props: SaveButtonServerProps) {\n  return <SaveButton label=\"Save\" />\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Querying and Updating Global Resources via REST in PayloadCMS (JavaScript/REST)\nDESCRIPTION: These code snippets illustrate how to query and update immutable global values in PayloadCMS using RESTful endpoints. The 'Get Global' example retrieves a global object by its slug, while 'Update Global' shows modifying announcement data. Both require specifying the global's slug in the URL and may require authentication. Responses return the current or updated global object, including metadata fields.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Globals Operation: Get Global\n{\n  operation: 'Get Global',\n  method: 'GET',\n  path: '/api/globals/{global-slug}',\n  description: 'Get a global by slug',\n  example: {\n    slug: 'getGlobal',\n    req: {\n      credentials: true,\n      headers: true,\n    },\n    res: {\n      announcement: 'Here is an announcement!',\n      globalType: 'announcement',\n      createdAt: '2023-04-28T08:53:56.066Z',\n      updatedAt: '2023-04-28T08:53:56.066Z',\n      id: '644b89a496c64a833fe579c9',\n    },\n  },\n}\n\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Globals Operation: Update Global\n{\n  operation: 'Update Global',\n  method: 'POST',\n  path: '/api/globals/{global-slug}',\n  description: 'Update a global by slug',\n  example: {\n    slug: 'updateGlobal',\n    req: {\n      headers: true,\n      credentials: true,\n      body: {\n        announcement: 'Paging Doctor Scrunt',\n      },\n    },\n    res: {\n      announcement: 'Paging Doctor Scrunt',\n      globalType: 'announcement',\n      createdAt: '2023-04-28T08:53:56.066Z',\n      updatedAt: '2023-04-28T08:53:56.066Z',\n      id: '644b89a496c64a833fe579c9',\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing After Error Hook for Payload CMS (TypeScript)\nDESCRIPTION: Defines an afterError hook function in TypeScript using the CollectionAfterErrorHook type from Payload. This snippet initializes an async function that receives hook arguments such as req, id, and doc, and enables custom logic after an error has occurred in Payload operations. The hook can be extended to log errors, transform result objects, or modify error handling flows. Requires the 'payload' npm package and appropriate Payload CMS project context. The key input is the error handling context, and the output may affect result transformation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_11\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionAfterErrorHook } from 'payload';\\n\\nconst afterErrorHook: CollectionAfterErrorHook = async ({\\n  req,\\n  id,\\n  doc,\\n}) => {...}\\n\n```\n\n----------------------------------------\n\nTITLE: Querying Join Fields with PayloadCMS GraphQL API in GraphQL\nDESCRIPTION: Illustrates how to query a PayloadCMS Join Field (`relatedPosts`) using GraphQL. The example demonstrates passing arguments like `sort`, `limit`, and `where` directly to the field within the query to filter, sort, and limit the returned related documents. It also shows how to request the `hasNextPage` field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/join.mdx#_snippet_4\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  Categories {\n    docs {\n      relatedPosts(\n        sort: \"createdAt\"\n        limit: 5\n        where: { author: { equals: \"66e3431a3f23e684075aaeb9\" } }\n      ) {\n        docs {\n          title\n        }\n        hasNextPage\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Database Migrations for PayloadCMS - Bash\nDESCRIPTION: This Bash command applies any pending migration files to the current database, ensuring the schema is up-to-date. Prerequisites include previously created migration files and a properly configured PayloadCMS environment. When executed on the server (after build, before server start), it keeps a log of migrations in the database and applies new or updated schema changes as needed. This helps prevent schema drift and maintains consistency across deployment environments.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/with-vercel-website/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm payload migrate\n\n```\n\n----------------------------------------\n\nTITLE: Example Document Data for One-to-One Relationship - PayloadCMS - JSON\nDESCRIPTION: This JSON snippet shows the shape of data for a document that references a single related user by ObjectID using a simple relationship field. The 'owner' field's value is the string ObjectID. This format is used when saving or querying documents with a one-to-one relationship and assumes that the field is configured with hasMany: false and a single relationTo target.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  // ObjectID of the related user\n  \"owner\": \"6031ac9e1289176380734024\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom GraphQL Queries in PayloadCMS (TypeScript)\nDESCRIPTION: Demonstrates how to add a custom GraphQL query (`MyCustomQuery`) to the Payload configuration using the `graphQL.queries` function. This function receives the `GraphQL` dependency and the `payload` instance. It returns an object where keys are query names and values define the query's type, arguments, and resolver.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/extending.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport myCustomQueryResolver from './graphQL/resolvers/myCustomQueryResolver'\n\nexport default buildConfig({\n  graphQL: {\n    // highlight-start\n    queries: (GraphQL, payload) => {\n      return {\n        MyCustomQuery: {\n          type: new GraphQL.GraphQLObjectType({\n            name: 'MyCustomQuery',\n            fields: {\n              text: {\n                type: GraphQL.GraphQLString,\n              },\n              someNumberField: {\n                type: GraphQL.GraphQLFloat,\n              },\n            },\n          }),\n          args: {\n            argNameHere: {\n              type: new GraphQL.GraphQLNonNull(GraphQLString),\n            },\n          },\n          resolve: myCustomQueryResolver,\n        },\n      }\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Payload Collection with Local JSON Schema Validation in TypeScript\nDESCRIPTION: Shows how to configure a `json` field type in a Payload CMS collection (`ExampleCollection`) to validate its data against an embedded JSON schema defined directly within the configuration using the `jsonSchema` property. This example restricts the 'foo' property to specific enum values ('bar', 'foobar').\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/json.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'customerJSON', // required\n      type: 'json', // required\n      jsonSchema: {\n        uri: 'a://b/foo.json', // required\n        fileMatch: ['a://b/foo.json'], // required\n        schema: {\n          type: 'object',\n          properties: {\n            foo: {\n              enum: ['bar', 'foobar'],\n            },\n          },\n        },\n      },\n    },\n  ],\n}\n// {\"foo\": \"bar\"} or {\"foo\": \"foobar\"} - ok\n// Attempting to create {\"foo\": \"not-bar\"} will throw an error\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Slash Menu Group in Payload RichText Lexical (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a function, mwnSlashMenuGroupWithItems, which accepts an array of SlashMenuItem objects and returns a SlashMenuGroup for use within the Payload RichText Lexical slash menu system. The function specifies a unique key and a label, the latter of which also supports i18n by accepting a function. It requires type imports from '@payloadcms/richtext-lexical'. This structure enables custom slash menu groups with mergeable items based on key and is reusable across the application.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_19\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type {\n  SlashMenuGroup,\n  SlashMenuItem,\n} from '@payloadcms/richtext-lexical'\n\nexport function mwnSlashMenuGroupWithItems(\n  items: SlashMenuItem[],\n): SlashMenuGroup {\n  return {\n    items,\n    key: 'myGroup',\n    label: 'My Group', // <= This can be a function to make use of i18n\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Importing Utility Components for Lexical Blocks - TypeScript\nDESCRIPTION: Demonstrates how to import reusable utility components from '@payloadcms/richtext-lexical/client' for editing, removing, and displaying blocks within the Lexical editor. This approach allows developers to easily integrate editing and UI controls for both inline and regular blocks without building custom logic. The imported buttons serve distinct purposes and align with either inline or block-level editing/removal scenarios.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  // Edit block buttons (choose the one that corresponds to your usage)\n  // When clicked, this will open a drawer with your block's fields\n  // so your editors can edit them\n  InlineBlockEditButton,\n  BlockEditButton,\n\n  // Buttons that will remove this block from Lexical\n  // (choose the one that corresponds to your usage)\n  InlineBlockRemoveButton,\n  BlockRemoveButton,\n\n  // The label that should be rendered for an inline block\n  InlineBlockLabel,\n\n  // The default \"container\" that is rendered for an inline block\n  // if you want to re-use it\n  InlineBlockContainer,\n\n  // The default \"collapsible\" UI that is rendered for a regular block\n  // if you want to re-use it\n  BlockCollapsible,\n} from '@payloadcms/richtext-lexical/client'\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload CMS Resend Email Adapter (TypeScript)\nDESCRIPTION: Configures the Payload CMS email functionality to use the Resend adapter within the main configuration file (e.g., payload.config.ts). It imports `resendAdapter`, sets default sender details (`defaultFromAddress`, `defaultFromName`), and retrieves the Resend API key from environment variables (`RESEND_API_KEY`). A fallback to an empty string is provided if the environment variable is not set.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/email-resend/README.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// payload.config.js\nimport { resendAdapter } from '@payloadcms/email-resend'\n\nexport default buildConfig({\n  email: resendAdapter({\n    defaultFromAddress: 'dev@payloadcms.com',\n    defaultFromName: 'Payload CMS',\n    apiKey: process.env.RESEND_API_KEY || '',\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Redirects Plugin in Payload CMS (TypeScript)\nDESCRIPTION: Shows how to import and apply the redirects plugin within a Payload CMS configuration using TypeScript. The snippet creates a config with a simple 'pages' collection and applies the plugin in the plugins array, specifying target collections. Requires dependency on Payload CMS and @payloadcms/plugin-redirects. Inputs include an array of collection slugs; output is an exportable Payload config object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/redirects.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { redirectsPlugin } from '@payloadcms/plugin-redirects'\n\nconst config = buildConfig({\n  collections: [\n    {\n      slug: 'pages',\n      fields: [],\n    },\n  ],\n  plugins: [\n    redirectsPlugin({\n      collections: ['pages'],\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Cancelling a Single Job by ID - Payload CMS - TypeScript\nDESCRIPTION: This snippet illustrates how to cancel an individual Job in Payload CMS using its unique ID. The 'payload.jobs.cancelByID' function takes an object with the required 'id' property (typically obtained from a previously created job) and cancels the job if it is queued or running. No value is returned on success. This operation requires access to the Payload instance and the specific job ID.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/jobs.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait payload.jobs.cancelByID({\n  id: createdJob.id,\n})\n```\n\n----------------------------------------\n\nTITLE: Typing Props in Server and Client Features for Payload CMS in TypeScript\nDESCRIPTION: These two snippets show how to add generic type parameters to both createServerFeature and createClientFeature, ensuring type safety and control over sanitized/unsanitized props. Required dependency is @payloadcms/richtext-lexical/client (and server). Parameters define the types for original and sanitized props for both server and client usage. The function signatures clarify how props are transformed and validated, with no direct outputs except enhanced type safety.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_23\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"createServerFeature<UnSanitizedProps, SanitizedProps, UnSanitizedClientProps>({\\n  //...\\n})\\n\"\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"createClientFeature<UnSanitizedClientProps, SanitizedClientProps>({\\n  //...\\n})\\n\"\n```\n\n----------------------------------------\n\nTITLE: Unlocking User Account - Payload CMS JavaScript\nDESCRIPTION: This snippet unlocks a locked user account based on an email, typically after repeated auth failures. It returns a boolean indicating whether the unlock was successful. OverrideAccess can be enabled to bypass permission checks. Requires collection and data (email) parameters.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/overview.mdx#_snippet_15\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Returned result will be a boolean representing success or failure\nconst result = await payload.unlock({\n  collection: 'users', // required\n  data: {\n    // required\n    email: 'dev@payloadcms.com',\n  },\n  req: req, // optional, pass a Request object to be provided to all hooks\n  overrideAccess: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Reusable Group Field Interface - Payload CMS - TypeScript\nDESCRIPTION: This snippet defines a 'group' field in a Payload collection with an explicit interface name 'SharedMeta'. By doing so, Payload scaffolds a top-level interface for reuse. This pattern is recommended for defining consistent shapes for field groups or blocks across collections and preventing naming collisions by scoping names (e.g., 'MetaGroup').\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/generating-types.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  type: 'group',\n  name: 'meta',\n  interfaceName: 'SharedMeta', <-- here!!\n  fields: [\n    {\n      name: 'title',\n      type: 'text',\n    },\n    {\n      name: 'description',\n      type: 'text',\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Running Database Migrations - Bash\nDESCRIPTION: This snippet provides the command for running all pending Payload CMS database migrations using the pnpm CLI tool. Dependencies include a correctly configured database connection and existing migration files. Input: none. Output: applies outstanding migrations to the connected database, tracking run migrations internally. Run on deployment after configuration changes that alter the schema.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/with-vercel-postgres/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm payload migrate\n```\n\n----------------------------------------\n\nTITLE: Custom Blocks Field (Client Component) - React TypeScript\nDESCRIPTION: Defines a client-side React component for rendering 'BlocksField' within the PayloadCMS admin UI. The component uses the 'use client' directive for Next.js SSR compatibility and takes all properties spread from the core Payload block field prop-types. Utilizes '@payloadcms/ui' and 'BlocksFieldClientComponent' typing for correct integration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { BlocksField } from '@payloadcms/ui'\nimport type { BlocksFieldClientComponent } from 'payload'\n\nexport const CustomBlocksFieldClient: BlocksFieldClientComponent = (props) => {\n  return <BlocksField {...props} />\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Locales with Advanced Locale Objects (TypeScript)\nDESCRIPTION: Illustrates how to define locales using objects for more control (label, code, RTL support, etc.) in the Payload localization config. Dependencies: Payload CMS. Requires specifying both the locale code and, optionally, properties like `label` (for UI display) and `rtl` (text direction for admin UI). Key parameters: locale object properties; fallback locale can be globally toggled. Input: Array of locale objects; output: advanced per-locale behavior when managing multilingual content.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/localization.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  collections: [\n    // collections go here\n  ],\n  localization: {\n    locales: [\n      {\n        label: 'English',\n        code: 'en',\n      },\n      {\n        label: 'Arabic',\n        code: 'ar',\n        // opt-in to setting default text-alignment on Input fields to rtl (right-to-left)\n        // when current locale is rtl\n        rtl: true,\n      },\n    ],\n    defaultLocale: 'en', // required\n    fallback: true, // defaults to true\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Querying Collection Versions via Local API - PayloadCMS - JavaScript\nDESCRIPTION: This JavaScript code snippet shows how to use the PayloadCMS local API to query a paginated list of versions for a specific collection (e.g., 'posts'). It utilizes parameters such as collection name, pagination (page, limit), where-queries, sorting, localization, user, and access control flags. The method 'payload.findVersions' returns a paginated set of version documents. Requires a Payload instance and optional user context for permission checks.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/versions/overview.mdx#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\n// Result will be a paginated set of Versions.\\n// See /docs/queries/pagination for more.\\nconst result = await payload.findVersions({\\n  collection: 'posts', // required\\n  depth: 2,\\n  page: 1,\\n  limit: 10,\\n  where: {}, // pass a `where` query here\\n  sort: '-createdAt',\\n  locale: 'en',\\n  fallbackLocale: false,\\n  user: dummyUser,\\n  overrideAccess: false,\\n  showHiddenFields: true,\\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing After Logout Hook for Payload CMS (TypeScript)\nDESCRIPTION: Defines an afterLogout hook for auth-enabled collections in Payload CMS, written in TypeScript and typed as CollectionAfterLogoutHook. The function is called after a logout operation and can be used to perform side effects or cleanup. It receives the req (request) object, allowing access to request context or user session data. Requires a TypeScript setup and the 'payload' npm package.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_14\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionAfterLogoutHook } from 'payload';\\n\\nconst afterLogoutHook: CollectionAfterLogoutHook = async ({\\n  req,\\n}) => {...}\\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Root-level Admin Route - PayloadCMS - TypeScript\nDESCRIPTION: Demonstrates how to set a custom path for the PayloadCMS Admin Panel by providing a `routes.admin` property in the Payload configuration file. Requires the 'payload' package and the `buildConfig` function. Modify the `admin` property within the `routes` object to mount the Admin Panel at a custom path (e.g., '/custom-admin-route'). Inputs are configuration objects; output is an updated Payload configuration. The snippet should be placed within the payload configuration file (`payload.config.ts`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/overview.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  routes: {\n    admin: '/custom-admin-route', // highlight-line\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Description Component in Payload Collection/Global\nDESCRIPTION: This TypeScript snippet demonstrates configuring a custom `Description` component for a Payload CMS Collection or Global. It assigns the path to the custom component (`/path/to/MyDescriptionComponent`) to the `admin.components.Description` property. This component is shared between the Edit View and List View.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      // highlight-start\n      Description: '/path/to/MyDescriptionComponent',\n      // highlight-end\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Search Records Before Sync with a Hook in TypeScript\nDESCRIPTION: Illustrates providing a 'beforeSync' hook to manipulate search records prior to their creation or update in TypeScript. Requires enabling the plugin and importing related types. The hook receives the original document and the searchDoc, allowing the user to add or fallback specific fields such as 'excerpt'. Output is an updated searchDoc object. Useful for implementing business-specific logic before syncing documents.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/search.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  searchPlugin({\n    beforeSync: ({ originalDoc, searchDoc }) => ({\n      ...searchDoc,\n      // - Modify your docs in any way here, this can be async\n      // - You also need to add the `excerpt` field in the `searchOverrides` config\n      excerpt: originalDoc?.excerpt || 'This is a fallback excerpt',\n    }),\n  }),\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Error Component in Payload Field (TypeScript)\nDESCRIPTION: Demonstrates setting a custom `Error` component for a 'text' field using the `admin.components.Error` property in the Payload field definition. This component will be rendered when the field fails validation, typically below the input.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_28\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const myField: Field = {\n  name: 'myField',\n  type: 'text',\n  admin: {\n    components: {\n      Error: '/path/to/MyCustomErrorComponent', // highlight-line\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Supported Locales for Localization (TypeScript)\nDESCRIPTION: Shows how to configure supported languages/locales and set a default locale in the Payload Config. This snippet requires an array of locale codes (e.g. `en`, `es`, etc.) and a default locale that matches one of the defined locales. Dependencies: Payload CMS. Inputs: list of locale codes and default locale string. Output: Content in the CMS can be managed in specified locales; requests default to the given locale unless specified. Limitation: only string-based locales shown in this example.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/localization.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  localization: {\n    locales: ['en', 'es', 'de'], // required\n    defaultLocale: 'en', // required\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Nodemailer Adapter with createTransport (TypeScript)\nDESCRIPTION: This snippet demonstrates configuring the Payload email adapter within `buildConfig` by providing a pre-configured Nodemailer transport instance created using `nodemailer.createTransport`. It sets default sender information and uses environment variables (`SMTP_HOST`, `SMTP_USER`, `SMTP_PASS`) for SMTP server details and authentication. Requires `@payloadcms/email-nodemailer` and `nodemailer` dependencies.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/email-nodemailer/README.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { nodemailerAdapter } from '@payloadcms/email-nodemailer'\nimport nodemailer from 'nodemailer'\n\nexport default buildConfig({\n  email: nodemailerAdapter({\n    defaultFromAddress: 'info@payloadcms.com',\n    defaultFromName: 'Payload',\n    // Any Nodemailer transport\n    transport: await nodemailer.createTransport({\n      host: process.env.SMTP_HOST,\n      port: 587,\n      auth: {\n        user: process.env.SMTP_USER,\n        pass: process.env.SMTP_PASS,\n      },\n    }),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Drizzle ORM Table Schemas for Payload Integration (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to define database tables using Drizzle ORM's pg-core API for integration into a Payload CMS project. Two tables are set up: 'users' with a primary key and additional columns, and 'countries' with a primary key, name, and a unique index constraint. Dependencies include drizzle-orm/pg-core. These schema definitions can be imported elsewhere to append to the Payload-managed schema. Expected output is exportable table definitions for later schema extension.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/postgres.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  pgTable,\n  uniqueIndex,\n  serial,\n  varchar,\n  text,\n} from 'drizzle-orm/pg-core'\n\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  fullName: text('full_name'),\n  phone: varchar('phone', { length: 256 }),\n})\n\nexport const countries = pgTable(\n  'countries',\n  {\n    id: serial('id').primaryKey(),\n    name: varchar('name', { length: 256 }),\n  },\n  (countries) => {\n    return {\n      nameIndex: uniqueIndex('name_idx').on(countries.name),\n    }\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Passing Props from Server to Client Feature in Payload CMS (TypeScript)\nDESCRIPTION: This snippet details how to pass serializable properties from a Payload CMS server feature to its client counterpart. It shows defining a type for unsanitized client props, then returning a clientFeatureProps object from the server feature with a concrete value. Only serializable data types (no functions or Maps) should be used for cross-network property passing. Requires the usage of createServerFeature and the definition of clientFeatureProps, with the output being available props in the client feature.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_26\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"type UnSanitizedClientProps = {\\n  test: string\\n}\\n\\ncreateServerFeature<UnSanitizedProps, SanitizedProps, UnSanitizedClientProps>({\\n  //...\\n  feature: {\\n    clientFeatureProps: {\\n      test: 'myValue',\\n    },\\n  },\\n})\\n\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Collapsible Field in a Payload Collection (TypeScript)\nDESCRIPTION: Provides a complete example of defining a Payload Collection (`ExampleCollection`) that utilizes a `collapsible` field. The collapsible field's label is dynamically generated based on the nested `title` field's data. It nests required 'title' and 'someTextField' text fields. Requires the `CollectionConfig` type from the `payload` package.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/collapsible.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      label: ({ data }) => data?.title || 'Untitled',\n      type: 'collapsible', // required\n      fields: [\n        // required\n        {\n          name: 'title',\n          type: 'text',\n          required: true,\n        },\n        {\n          name: 'someTextField',\n          type: 'text',\n          required: true,\n        },\n      ],\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Unlocking a User Account with a GraphQL Mutation\nDESCRIPTION: Example GraphQL mutation `unlock[collection-singular-label]` (replace with actual label, e.g., `unlockUser`) used to unlock a user account that might have been locked due to excessive failed login attempts. Appropriate access control is needed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_15\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  unlock[collection-singular-label]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Preview Link in Payload Collection (TypeScript)\nDESCRIPTION: Defines a simple `preview` function within a Payload Collection configuration (`Pages`). This function takes the document's `slug` and constructs a basic, hardcoded URL pointing to the corresponding page on a local development server (localhost:3000).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/preview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Pages: CollectionConfig = {\n  slug: 'pages',\n  admin: {\n    preview: ({ slug }) => `http://localhost:3000/${slug}`,\n  },\n  fields: [\n    {\n      name: 'slug',\n      type: 'text',\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Injecting Custom Components After the Dashboard (TypeScript)\nDESCRIPTION: Shows how to assign custom components to render after the Payload Admin Dashboard's built-in content, using the afterDashboard property in admin.components in the buildConfig API. Add one or more component paths as array members. This feature is supported by Payload CMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  admin: {\n    // highlight-start\n    components: {\n      afterDashboard: ['/path/to/your/component'],\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Locale Information to Requests in Payload Custom Endpoints (TypeScript)\nDESCRIPTION: Shows how to utilize the `addLocalesToRequestFromData` helper function from `payload` within a custom endpoint handler. This function reads locale information from the request data and adds `req.locale` and `req.fallbackLocale` properties to the request object, making them available for subsequent logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { addLocalesToRequestFromData } from 'payload'\n\n// custom endpoint example\n{\n  path: '/:id/tracking',\n  method: 'post',\n  handler: async (req) => {\n    await addLocalesToRequestFromData(req)\n    // you now can access req.locale & req.fallbackLocale\n    return Response.json({ message: 'success' })\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Upload Component in Payload Collection\nDESCRIPTION: This TypeScript snippet demonstrates how to configure a custom file `Upload` component within a Payload CMS Collection configuration. It sets the path to the custom component file (`/path/to/MyUploadComponent`) in the `admin.components.edit.Upload` property. Note: This customization is only available for Collections, not Globals.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      edit: {\n        // highlight-start\n        Upload: '/path/to/MyUploadComponent',\n        // highlight-end\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a refresh Collection Hook in TypeScript\nDESCRIPTION: This snippet shows the definition of a `refresh` hook for an Auth-enabled Payload Collection. This hook allows overriding the default token refresh behavior. If the hook returns a value, Payload skips its default refresh logic. It receives `args` (operation arguments) and the `user` object as parameters.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionRefreshHook } from 'payload'\n\nconst myRefreshHook: CollectionRefreshHook = async ({\n  args,\n  user,\n}) => {...}\n```\n\n----------------------------------------\n\nTITLE: Defining Payload Collection with Remote JSON Schema Validation in TypeScript\nDESCRIPTION: Demonstrates configuring a `json` field (`customerJSON`) in a Payload CMS collection (`ExampleCollection`) to use a remote JSON schema hosted at a specified URL for validation. The `uri` and `fileMatch` properties within the `jsonSchema` object point to the external schema location (e.g., 'https://example.com/customer.schema.json').\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/json.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'customerJSON', // required\n      type: 'json', // required\n      jsonSchema: {\n        uri: 'https://example.com/customer.schema.json', // required\n        fileMatch: ['https://example.com/customer.schema.json'], // required\n      },\n    },\n  ],\n}\n// If 'https://example.com/customer.schema.json' has a JSON schema\n// {\"foo\": \"bar\"} or {\"foo\": \"foobar\"} - ok\n// Attempting to create {\"foo\": \"not-bar\"} will throw an error\n```\n\n----------------------------------------\n\nTITLE: Running Payload Postgres Migrations at Runtime via Adapter Config (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to configure the Payload CMS Postgres adapter to execute pending migrations automatically upon application startup in a production environment. It involves importing the generated migrations array (typically from `./migrations/index.ts` or similar) and passing it to the `prodMigrations` property within the `postgresAdapter` options in the main `buildConfig`. This approach is suitable for long-running server environments but might impact cold start times in serverless setups.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_13\n\nLANGUAGE: ts\nCODE:\n```\n// Import your migrations from the `index.ts` file\n// that Payload generates for you\nimport { migrations } from './migrations'\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // your config here\n  db: postgresAdapter({\n    //  your adapter config here\n    prodMigrations: migrations,\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Collection-Specific Sort Options for Relationship Fields - PayloadCMS - TypeScript\nDESCRIPTION: This snippet uses an object for the 'sortOptions' property to set distinct default sort fields for relationship dropdowns in different collections in the Payload admin panel. The keys are collection slugs and the values the field names, optionally prefixed by '-' for descending order. This functionality requires only Payload configuration and is included within a field definition.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nsortOptions: {\n  \"pages\": \"fieldName1\",\n  \"posts\": \"-fieldName2\",\n  \"categories\": \"fieldName3\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing afterRead Hook in Payload (TypeScript)\nDESCRIPTION: Shows how to use the afterRead hook in a Payload collection with TypeScript, ensuring locales are flattened and protected fields are hidden right before documents are returned. The snippet imports the CollectionAfterReadHook type and defines an async function returning the final doc. It can be customized to further process or filter documents after Payload's internal transformations. Payload must be installed for proper type support.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionAfterReadHook } from 'payload'\n\nconst afterReadHook: CollectionAfterReadHook = async ({ doc }) => {\n  return doc\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Drizzle Schema with Tables and Indexes (TypeScript)\nDESCRIPTION: Presents an example Drizzle schema file defining multiple tables and a unique index for use with PayloadCMS and the SQLite adapter. Showcases the creation of `users` and `countries` tables, with fields for primary keys, text columns, and unique indexing on the country name column. This file would typically be generated via Drizzle introspection and imported into Payload configuration for advanced schema manipulation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/sqlite.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  sqliteTable,\n  text,\n  uniqueIndex,\n  integer,\n} from 'drizzle-orm/sqlite-core'\n\nexport const users = sqliteTable('users', {\n  id: integer('id').primaryKey({ autoIncrement: true }),\n  fullName: text('full_name'),\n  phone: text('phone', { length: 256 }),\n})\n\nexport const countries = sqliteTable(\n  'countries',\n  {\n    id: integer('id').primaryKey({ autoIncrement: true }),\n    name: text('name', { length: 256 }),\n  },\n  (countries) => {\n    return {\n      nameIndex: uniqueIndex('name_idx').on(countries.name),\n    }\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Typing Editor State with Default Node Types - Payload Rich Text - TypeScript\nDESCRIPTION: Demonstrates use of DefaultTypedEditorState from @payloadcms/richtext-lexical for typing editor state to include all default enabled node types in a PayloadCMS Lexical rich text field. This snippet requires DefaultTypedEditorState as an import. The editorState object conforms to the JSON structure expected by the editor, and all properties are type-checked against the default features’ possible nodes.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/overview.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { DefaultTypedEditorState } from '@payloadcms/richtext-lexical'\n\nconst editorState: DefaultTypedEditorState = {\n  root: {\n    type: 'root',\n    direction: 'ltr',\n    format: '',\n    indent: 0,\n    version: 1,\n    children: [\n      {\n        children: [\n          {\n            detail: 0,\n            format: 0,\n            mode: 'normal',\n            style: '',\n            text: 'Some text. Every property here is fully-typed',\n            type: 'text',\n            version: 1,\n          },\n        ],\n        direction: 'ltr',\n        format: '',\n        indent: 0,\n        type: 'paragraph',\n        textFormat: 0,\n        version: 1,\n      },\n    ],\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Viewing Shallow (depth=0) API Response in Payload CMS (JSON)\nDESCRIPTION: This JSON snippet demonstrates the shape of a response when querying a document with a depth set to 0 in Payload CMS. The specified depth means related fields (such as 'author') are returned as their document IDs only, not fully populated objects. There are no dependencies, as this is a static sample response. Inputs are usually from a REST or local API query with depth=0, returning just top-level document properties.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/depth.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \"id\": \"5ae8f9bde69e394e717c8832\",\\n  \"title\": \"This is a great post\",\\n  \"author\": \"5f7dd05cd50d4005f8bcab17\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Blocks Field (Server Component) - React TypeScript\nDESCRIPTION: Implements a server-side React component for rendering PayloadCMS 'BlocksField' using the server component type. This structure ensures all necessary props like clientField, path, schemaPath, and permissions are passed from the server context. Relies on '@payloadcms/ui' and validates types via 'BlocksFieldServerComponent' for integration with the Payload field API.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport type React from 'react'\nimport { BlocksField } from '@payloadcms/ui'\nimport type { BlocksFieldServerComponent } from 'payload'\n\nexport const CustomBlocksFieldServer: BlocksFieldServerComponent = ({\n  clientField,\n  path,\n  schemaPath,\n  permissions,\n}) => {\n  return (\n    <BlocksField\n      field={clientField}\n      path={path}\n      schemaPath={schemaPath}\n      permissions={permissions}\n    />\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Client-Side Live Preview with useLivePreview Hook (TSX)\nDESCRIPTION: This TSX snippet shows a React client component (`PageClient`) using the `useLivePreview` hook from `@payloadcms/live-preview-react`. It takes initial page data (`initialPage`), subscribes to updates from the Payload server (`serverURL`), and manages data fetching depth (`depth`). The hook returns the live `data` object, which automatically reflects changes made in the admin panel.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport { useLivePreview } from '@payloadcms/live-preview-react'\nimport { Page as PageType } from '@/payload-types'\n\n// Fetch the page in a server component, pass it to the client component, then thread it through the hook\n// The hook will take over from there and keep the preview in sync with the changes you make\n// The `data` property will contain the live data of the document\nexport const PageClient: React.FC<{ \n  page: {\n    title: string\n  }\n}> = ({ page: initialPage }) => {\n  const { data } = useLivePreview<PageType>({\n    initialData: initialPage,\n    serverURL: PAYLOAD_SERVER_URL,\n    depth: 2, // Ensure that the depth matches the request for `initialPage`\n  })\n\n  return <h1>{data.title}</h1>\n}\n```\n\n----------------------------------------\n\nTITLE: Styling Component using Payload CSS Theme Variable (SCSS)\nDESCRIPTION: This SCSS snippet demonstrates styling a custom component (`.my-component`) using a CSS variable provided by the Payload theme (`--theme-elevation-500`). This ensures the component's style adapts to the current Payload admin theme.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_19\n\nLANGUAGE: scss\nCODE:\n```\n.my-component {\n  background-color: var(--theme-elevation-500);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Payload SQLite Adapter via npm (Bash)\nDESCRIPTION: This command uses the Node Package Manager (npm) to install the official Payload SQLite adapter package (`@payloadcms/db-sqlite`) as a project dependency.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/db-sqlite/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/db-sqlite\n```\n\n----------------------------------------\n\nTITLE: Scaffolding Custom Document Tab (Server Component) - React TSX\nDESCRIPTION: This TSX snippet shows how to implement a custom Document Tab as a React server component for Payload CMS. It uses the DocumentTabServerProps from Payload and the Link component from @payloadcms/ui to create a navigational tab labeled \"This is a custom Document Tab (Server)\". The component depends on React, Payload's type definitions, and the UI package, expecting props of type DocumentTabServerProps and rendering a navigational link as its output.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/document-views.mdx#_snippet_3\n\nLANGUAGE: TSX\nCODE:\n```\nimport React from 'react'\nimport type { DocumentTabServerProps } from 'payload'\nimport { Link } from '@payloadcms/ui'\n\nexport function MyCustomTabComponent(props: DocumentTabServerProps) {\n  return (\n    <Link href=\"/my-custom-tab\">This is a custom Document Tab (Server)</Link>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using getTranslation for i18n in a Server Component (TSX)\nDESCRIPTION: This example shows how to perform translations within a Payload Server Component. It utilizes the `getTranslation` function from `@payloadcms/translations`, passing the translation key (`myTranslation`) and the `i18n` object received as a prop.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { getTranslation } from '@payloadcms/translations'\n\nexport default async function MyServerComponent({ i18n }) {\n  const translatedTitle = getTranslation(myTranslation, i18n) // highlight-line\n\n  return <p>{translatedTitle}</p>\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to List View Data with useListQuery in React (TypeScript)\nDESCRIPTION: Shows how to use the useListQuery hook from @payloadcms/ui to access live data and queries for the List View in a React component. Requires @payloadcms/ui as a dependency and must be used within the List View context. Returns an object with data and query related to the List View; input/output are the live results from the current query.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport { useListQuery } from '@payloadcms/ui'\\n\\nconst MyComponent: React.FC = () => {\\n  // highlight-start\\n  const { data, query } = useListQuery()\\n  // highlight-end\\n\\n  // ...\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Custom Block Row Label Component - React TypeScript\nDESCRIPTION: Defines a client-side hook-based component for rendering custom row labels in PayloadCMS block fields. Uses 'useRowLabel' from '@payloadcms/ui' to extract row-specific data and dynamically generates a string label that combines block type and formatted row number. Facilitates custom, readable block labels within block editors.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport { useRowLabel } from '@payloadcms/ui'\n\nexport const BlockRowLabel = () => {\n  const { data, rowNumber } = useRowLabel<{ title?: string }>()\n\n  const customLabel = `${data.type} ${String(rowNumber).padStart(2, '0')} `\n\n  return <div>Custom Label: {customLabel}</div>\n}\n\n```\n\n----------------------------------------\n\nTITLE: Querying Current User Data with GraphQL\nDESCRIPTION: Example GraphQL query using the `me` field (specific to the collection's singular label, e.g., `meUser`) to retrieve the logged-in user's email and token expiration time.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  me[collection-singular-label] {\n    user {\n      email\n    }\n    exp\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Date Field Client Component in Payload TSX\nDESCRIPTION: This snippet shows how to create a custom client component for a Date field in Payload CMS, marked with the 'use client' directive. The `CustomDateFieldClient` component imports and renders the standard `@payloadcms/ui/DateTimeField`, spreading all received props (`props`) onto it. This pattern allows developers to replace or extend the client-side behavior of the date field within the Payload admin UI.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/date.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport React from 'react'\nimport { DateTimeField } from '@payloadcms/ui'\nimport type { DateFieldClientComponent } from 'payload'\n\nexport const CustomDateFieldClient: DateFieldClientComponent = (props) => {\n  return <DateTimeField {...props} />\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Payload Config in a Server Component (TSX)\nDESCRIPTION: This example demonstrates how a React Server Component can access the full Payload configuration object directly via the `payload.config` prop, which is automatically passed. This allows access to server-side configuration details like `serverURL`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\n\nexport default async function MyServerComponent({\n  payload: {\n    config, // highlight-line\n  },\n}) {\n  return <Link href={config.serverURL}>Go Home</Link>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Asynchronous afterError Hook for Global Error Handling in Payload (TypeScript)\nDESCRIPTION: This example shows how to define an asynchronous afterError hook within the Payload CMS configuration using TypeScript. The afterError hook is triggered whenever an error occurs at the application level, allowing developers to execute custom logic like logging or notifications. The function receives a destructured object containing error information and context. Developers must import buildConfig from Payload and attach an array of async functions to hooks.afterError in the config. Inputs are hook arguments ({ error, ... }), and no explicit output is returned by the hook. The use of async is optional but recommended for operations like API calls.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/overview.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  hooks: {\n    afterError: [\n      async ({ error }) => {\n        // Do something\n      },\n    ],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Overriding Global Admin Components in Payload (TypeScript)\nDESCRIPTION: This example demonstrates how to customize the admin panel UI for a global by supplying custom components using the 'admin.components' property. It uses 'SanitizedGlobalConfig' from 'payload' to ensure the config object is fully processed. You can assign React components or customization logic within 'admin.components'. Dependencies include React and correct Payload typings. The input is the override configuration; the effect is altering the editing interface for this specific Global in the admin panel, with no impact on server-side behavior.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/globals.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { SanitizedGlobalConfig } from 'payload'\n\nexport const MyGlobal: SanitizedGlobalConfig = {\n  // ...\n  admin: {\n    components: {\n      // highlight-line\n      // ...\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Form Builder Field Configuration in TypeScript\nDESCRIPTION: Demonstrates how to customize an existing field type (e.g., 'text') provided by the '@payloadcms/plugin-form-builder'. It involves importing the default 'fields' object and merging it with custom configurations, such as changing labels, within the 'formBuilderPlugin' options in 'payload.config.ts'.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fields } from '@payloadcms/plugin-form-builder'\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nformBuilderPlugin({\n  // ...\n  fields: {\n    text: {\n      ...fields.text,\n      labels: {\n        singular: 'Custom Text Field',\n        plural: 'Custom Text Fields',\n      },\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Replacing a Collection's Edit View in Payload Config (TypeScript)\nDESCRIPTION: This example demonstrates configuring a specific collection (`MyCollectionConfig`) to use a custom React component for its 'Edit' view. Within the collection's `admin.components.views` property, the `edit` key is assigned an object specifying the `Component` path.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-views.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollectionConfig: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      views: {\n        // highlight-start\n        edit: {\n          Component: '/path/to/MyCustomView', // highlight-line\n        },\n        // highlight-end\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom SaveDraftButton (Client Component) in Payload CMS\nDESCRIPTION: This snippet shows a custom React client component (`MySaveDraftButton`) intended to replace the default Save Draft button in the Payload CMS Edit View. It imports and renders the standard `SaveDraftButton` from `@payloadcms/ui`, utilizing the `'use client'` directive for client-side rendering. It requires `react`, `@payloadcms/ui`, and `payload` types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { SaveDraftButton } from '@payloadcms/ui'\nimport type { SaveDraftButtonClientProps } from 'payload'\n\nexport function MySaveDraftButton(props: SaveDraftButtonClientProps) {\n  return <SaveDraftButton />\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Database Seed Script (Shell)\nDESCRIPTION: Executes the database seed script using pnpm (or equivalent package manager command). This script typically drops the current database and populates it with initial data defined in the seed template, including a default user and example pages. Use with caution as it's destructive.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/form-builder/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\npnpm seed\n```\n\n----------------------------------------\n\nTITLE: Simple Before Dashboard React Component (TSX)\nDESCRIPTION: Defines a functional React component that displays custom content prior to the admin dashboard in Payload CMS. No props or state are used. To activate, ensure the component path is specified under beforeDashboard in Payload config. Useful for announcements, widgets, or introductory content.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyBeforeDashboardComponent() {\n  return <div>This is a custom component injected before the Dashboard.</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Installing MongoDB Database Adapter - Bash\nDESCRIPTION: Installs the official MongoDB database adapter for Payload CMS using pnpm as the package manager. This enables MongoDB to be used as the datastore backend. Prerequisites: MongoDB instance or connection string, project with Payload installed. Output: adapter library added to node_modules. Limitation: specific to MongoDB, use alternative snippet for other databases.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/installation.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm i @payloadcms/db-mongodb\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Checkbox Field Client Component (React/TSX)\nDESCRIPTION: This snippet demonstrates how to create a custom React Client Component for a Payload Checkbox field, indicated by the 'use client' directive. It imports and renders the default 'CheckboxField' component from '@payloadcms/ui', passing all received props using the spread operator. This pattern allows customization of the client-side behavior or appearance of the checkbox field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/checkbox.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport React from 'react'\nimport { CheckboxField } from '@payloadcms/ui'\nimport type { CheckboxFieldClientComponent } from 'payload'\n\nexport const CustomCheckboxFieldClient: CheckboxFieldClientComponent = (\n  props,\n) => {\n  return <CheckboxField {...props} />\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Copying Example Environment Variables (Bash)\nDESCRIPTION: This command copies the example environment variable file (`.env.example`) to a new file named `.env`. This new file will be used by the application to load environment-specific configurations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Querying User Access Permissions with GraphQL\nDESCRIPTION: Example GraphQL query to fetch specific access permissions for a user, demonstrating how to request read permissions for the 'pages' collection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_1\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  Access {\n    pages {\n      read {\n        permission\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Jobs via CLI Bin Script (Shell)\nDESCRIPTION: This shell snippet demonstrates how to execute one or more queued jobs using the built-in Payload CMS CLI tool. The first command runs jobs from a specified queue with a limit; the second adds a `--cron` argument for repeated execution as per a cron schedule. These scripts require that Payload CMS is installed and accessible via `npx`. Input parameters include the queue name, job processing limit, and cron schedule expression. Output is job execution logs in the CLI.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/queues.mdx#_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nnpx payload jobs:run --queue default --limit 10\n```\n\nLANGUAGE: Shell\nCODE:\n```\nnpx payload jobs:run --cron \"*/5 * * * *\"\n```\n\n----------------------------------------\n\nTITLE: Installing Nodemailer Adapter and Nodemailer (Shell)\nDESCRIPTION: This command uses the pnpm package manager to install the Payload CMS Nodemailer email adapter (`@payloadcms/email-nodemailer`) and the Nodemailer library (`nodemailer`) as project dependencies.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/email-nodemailer/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @payloadcms/email-nodemailer nodemailer\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom PublishButton (Server Component) in Payload CMS\nDESCRIPTION: This snippet presents a custom React server component (`MyPublishButton`) for the Publish button in Payload CMS. It imports and renders the standard `PublishButton` from `@payloadcms/ui`, but customizes its label to 'Publish'. This component runs on the server side. It depends on `react`, `@payloadcms/ui`, and `payload` types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { PublishButton } from '@payloadcms/ui'\nimport type { PublishButtonClientProps } from 'payload'\n\nexport function MyPublishButton(props: PublishButtonServerProps) {\n  return <PublishButton label=\"Publish\" />\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nodemailer Adapter with transportOptions (TypeScript)\nDESCRIPTION: This snippet shows an alternative way to configure the Payload email adapter by passing Nodemailer transport options directly to the `transportOptions` property within the `nodemailerAdapter` configuration. It sets default sender information and uses environment variables (`SMTP_HOST`, `SMTP_USER`, `SMTP_PASS`) for SMTP configuration. Requires the `@payloadcms/email-nodemailer` dependency.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/email-nodemailer/README.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { nodemailerAdapter } from '@payloadcms/email-nodemailer'\n\nexport default buildConfig({\n  email: nodemailerAdapter({\n    defaultFromAddress: 'info@payloadcms.com',\n    defaultFromName: 'Payload',\n    // Nodemailer transportOptions\n    transportOptions: {\n      host: process.env.SMTP_HOST,\n      port: 587,\n      auth: {\n        user: process.env.SMTP_USER,\n        pass: process.env.SMTP_PASS,\n      },\n    },\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Timezone Selection for Payload Date Fields in TypeScript\nDESCRIPTION: This snippet shows the configuration required within a Payload CMS field definition to enable timezone selection for a 'date' type field. Setting the `timezone` property to `true` adds a dropdown menu to the date picker in the admin UI, allowing users to select a timezone. The selected timezone is stored alongside the date.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/date.mdx#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\n```ts\n{\n  name: 'date',\n  type: 'date',\n  timezone: true,\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Custom Relationship Field Server Component in PayloadCMS Admin (TSX)\nDESCRIPTION: Implements a custom server-side React component for rendering the admin UI of a relationship field using PayloadCMS and the @payloadcms/ui package. The function accepts the client field configuration, field path, schema path, and permissions, and uses these to render the default RelationshipField component on the server. Prerequisites: React, @payloadcms/ui, PayloadCMS types. Intended as a replacement or wrapper for the default relationship input on forms.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_14\n\nLANGUAGE: TSX\nCODE:\n```\nimport type React from 'react'\nimport { RelationshipField } from '@payloadcms/ui'\nimport type { RelationshipFieldServerComponent } from 'payload'\n\nexport const CustomRelationshipFieldServer: RelationshipFieldServerComponent =\n  ({ clientField, path, schemaPath, permissions }) => {\n    return (\n      <RelationshipField\n        field={clientField}\n        path={path}\n        schemaPath={schemaPath}\n        permissions={permissions}\n      />\n    )\n  }\n```\n\n----------------------------------------\n\nTITLE: Disabling Transaction for Specific Payload API Call in TypeScript\nDESCRIPTION: Demonstrates how to disable the default transaction behavior for a single Payload Local API call. By adding the `disableTransaction: true` argument to the `payload.update` method, this specific update operation will be executed outside of any ongoing transaction, committing immediately upon success regardless of the surrounding transactional context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/transactions.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nawait payload.update({\n  collection: 'posts',\n  data: {\n    some: 'data',\n  },\n  where: {\n    slug: { equals: 'my-slug' },\n  },\n  disableTransaction: true,\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Global Hook Types from PayloadCMS - TypeScript\nDESCRIPTION: Imports several type definitions for global hooks from the 'payload' package, including GlobalBeforeValidateHook, GlobalBeforeChangeHook, GlobalAfterChangeHook, GlobalBeforeReadHook, and GlobalAfterReadHook. These imports enable strong typing and autocomplete for hook implementations, helping prevent runtime errors and improving developer experience. Requires the Payload NPM package installed and TypeScript support in the project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/globals.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type {\n  GlobalBeforeValidateHook,\n  GlobalBeforeChangeHook,\n  GlobalAfterChangeHook,\n  GlobalBeforeReadHook,\n  GlobalAfterReadHook,\n} from 'payload'\n```\n\n----------------------------------------\n\nTITLE: Counting Documents via Payload REST API\nDESCRIPTION: Performs a GET request to count the total number of documents within a specific collection. Can be combined with 'where' query parameters for conditional counting.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rest-api/overview.mdx#_snippet_2\n\nLANGUAGE: HTTP\nCODE:\n```\nGET /api/{collection-slug}/count\n```\n\n----------------------------------------\n\nTITLE: Seeding Data with Payload Local API (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import the Payload config and initialize the Payload instance in a standalone TypeScript script using the Local API. You perform operations such as creating user and page entries by invoking the `create` method. You must have '@payload-config' and the 'payload' package installed, and run this as an ESM module. The script expects configuration to be present and is triggered with the CLI as shown below. The 'getPayload' function initializes the environment, and 'seed' is called at the bottom.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/outside-nextjs.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { getPayload } from 'payload'\nimport config from '@payload-config'\n\nconst seed = async () => {\n  // Get a local copy of Payload by passing your config\n  const payload = await getPayload({ config })\n\n  const user = await payload.create({\n    collection: 'users',\n    data: {\n      email: 'dev@payloadcms.com',\n      password: 'some-password',\n    },\n  })\n\n  const page = await payload.create({\n    collection: 'pages',\n    data: {\n      title: 'My Homepage',\n      // other data to seed here\n    },\n  })\n}\n\n// Call the function here to run your seed script\nawait seed()\n```\n\n----------------------------------------\n\nTITLE: Configuring Development Containers with Docker Compose - YAML\nDESCRIPTION: This snippet provides a docker-compose.yml configuration to coordinate Node.js (for PayloadCMS development), MongoDB, and optionally PostgreSQL. It sets up persistent named volumes for database and Node.js modules, and uses environment files for easy environment configuration. The Node.js service launches with corepack/pnpm and maps the application source directory; the MongoDB container uses the wiredTiger storage engine for better performance. PostgreSQL configuration is included as commented code, enabling easy switching by adapting the database URI and uncommenting those lines. Dependencies include docker-compose, Docker Engine, and required images pulled from Docker Hub. The main parameters are service definitions (image, ports, volumes, commands, dependencies, env_file), and the configuration expects accompanying .env file and local source code present.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/production/deployment.mdx#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\nversion: '3'\\n\\nservices:\\n  payload:\\n    image: node:18-alpine\\n    ports:\\n      - '3000:3000'\\n    volumes:\\n      - .:/home/node/app\\n      - node_modules:/home/node/app/node_modules\\n    working_dir: /home/node/app/\\n    command: sh -c \\\"corepack enable && corepack prepare pnpm@latest --activate && pnpm install && pnpm dev\\\"\\n    depends_on:\\n      - mongo\\n      # - postgres\\n    env_file:\\n      - .env\\n\\n  # Ensure your DATABASE_URI uses 'mongo' as the hostname ie. mongodb://mongo/my-db-name\\n  mongo:\\n    image: mongo:latest\\n    ports:\\n      - '27017:27017'\\n    command:\\n      - --storageEngine=wiredTiger\\n    volumes:\\n      - data:/data/db\\n    logging:\\n      driver: none\\n\\n  # Uncomment the following to use postgres\\n  # postgres:\\n  #   restart: always\\n  #   image: postgres:latest\\n  #   volumes:\\n  #     - pgdata:/var/lib/postgresql/data\\n  #   ports:\\n  #     - \\\"5432:5432\\\"\\n\\nvolumes:\\n  data:\\n  # pgdata:\\n  node_modules:\n```\n\n----------------------------------------\n\nTITLE: Configuring Before/After Input Components in Payload Field (TypeScript)\nDESCRIPTION: Example demonstrating how to add custom components before and after the main input element of a 'text' field in a Payload `CollectionConfig`. The `admin.components.beforeInput` and `admin.components.afterInput` properties accept arrays of component paths or component references, allowing for additional UI elements alongside the field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_32\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollectionConfig: CollectionConfig = {\n  // ...\n  fields: [\n    // ...\n    {\n      name: 'myField',\n      type: 'text',\n      admin: {\n        components: {\n          // highlight-start\n          beforeInput: ['/path/to/MyCustomComponent'],\n          afterInput: ['/path/to/MyOtherCustomComponent'],\n          // highlight-end\n        },\n      },\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Email Templates Before Sending in Form Builder Plugin (TypeScript)\nDESCRIPTION: Defines a beforeEmail hook to modify or wrap outgoing emails, such as adding custom HTML. Useful for advanced styling and branding in notification emails. Accepts emailsToSend and beforeChangeParams arguments, returns a transformed email array. Assumes plugin is imported and configured in PayloadCMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nformBuilderPlugin({\n  // ...\n  beforeEmail: (emailsToSend, beforeChangeParams) => {\n    // modify the emails in any way before they are sent\n    return emails.map((email) => ({\n      ...email,\n      html: email.html, // transform the html in any way you'd like (maybe wrap it in an html template?)\n    }))\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Plugin Options Interface with JSDoc (TypeScript)\nDESCRIPTION: Defines a TypeScript interface for plugin options along with JSDoc comments to facilitate editor tooltips and documentation. Can be exported to assist type-safe plugin consumption. Here, the only option is an optional boolean 'enabled'. Best used in projects using TypeScript with custom plugins.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface PluginTypes {\n  /**\n   * Enable or disable plugin\n   * @default false\n   */\n  enabled?: boolean\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Server-Side Markdown Transformers to a Custom Feature in Payload Lexical (TypeScript)\nDESCRIPTION: Illustrates how to define and register server-side Markdown transformers within a custom Lexical feature using `createServerFeature`. This example defines an `ElementTransformer` to convert a custom `MyNode` to/from the Markdown sequence '+++' using `export` and `replace` functions, respectively. Requires `@payloadcms/richtext-lexical` and the corresponding custom node definition (`MyNode`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { createServerFeature } from '@payloadcms/richtext-lexical'\nimport type { ElementTransformer } from '@payloadcms/richtext-lexical/lexical/markdown'\nimport { $createMyNode, $isMyNode, MyNode } from './nodes/MyNode'\n\nconst MyMarkdownTransformer: ElementTransformer = {\n  type: 'element',\n  dependencies: [MyNode],\n  export: (node, exportChildren) => {\n    if (!$isMyNode(node)) {\n      return null\n    }\n    return '+++'\n  },\n  // match ---\n  regExp: /^\\+\\+\\+\\s*$/,\n  replace: (parentNode) => {\n    const node = $createMyNode()\n    if (node) {\n      parentNode.replace(node)\n    }\n  },\n}\n\nexport const MyFeature = createServerFeature({\n  feature: {\n    markdownTransformers: [MyMarkdownTransformer],\n  },\n  key: 'myFeature',\n})\n```\n\n----------------------------------------\n\nTITLE: Building REST API Query Strings Programmatically using qs-esm in TypeScript\nDESCRIPTION: Demonstrates using the `qs-esm` library's `stringify` function to convert a Payload `Where` query object into a URL-safe query string suitable for the REST API. It ensures the query object is nested under the `where` key and adds the '?' prefix, simplifying the creation of potentially complex REST API requests. Requires the `qs-esm` package and the `Where` type from Payload.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/overview.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { stringify } from 'qs-esm'\nimport type { Where } from 'payload'\n\nconst query: Where = {\n  color: {\n    equals: 'mint',\n  },\n  // This query could be much more complex\n  // and qs-esm would handle it beautifully\n}\n\nconst getPosts = async () => {\n  const stringifiedQuery = stringify(\n    {\n      where: query, // ensure that `qs-esm` adds the `where` property, too!\n    },\n    { addQueryPrefix: true },\n  )\n\n  const response = await fetch(\n    `http://localhost:3000/api/posts${stringifiedQuery}`,\n  )\n  // Continue to handle the response below...\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Server-Side Environment Variables in Payload Config (TypeScript)\nDESCRIPTION: Demonstrates how to read an environment variable (`SERVER_URL`) from `process.env` within the `buildConfig` function in `payload.config.ts`. This approach is used for server-side configuration in Node.js environments, including Next.js.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/environment-vars.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  serverURL: process.env.SERVER_URL, // highlight-line\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Using useLivePreview Composable in a Vue 3 Component - Payload CMS - TypeScript (SFC)\nDESCRIPTION: This snippet demonstrates the usage of the useLivePreview composable from '@payloadcms/live-preview-vue' in a Vue single-file component using the <script setup> syntax. The component expects initial data as a prop, and live updates are merged as admin changes occur. Requires installation of the Payload preview Vue package, a correct server URL, a proper PageData type definition, and Vue 3 or Nuxt 3 as the framework. The data property reflects live document data and is used in the template for dynamic rendering.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/client.mdx#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n<script setup lang=\\\"ts\\\">\nimport type { PageData } from '~/types';\nimport { defineProps } from 'vue';\nimport { useLivePreview } from '@payloadcms/live-preview-vue';\n\n// Fetch the initial data on the parent component or using async state\nconst props = defineProps<{ initialData: PageData }>();\n\n// The hook will take over from here and keep the preview in sync with the changes you make.\n// The `data` property will contain the live data of the document only when viewed from the Preview view of the Admin UI.\nconst { data } = useLivePreview<PageData>({\n  initialData: props.initialData,\n  serverURL: \\\"<PAYLOAD_SERVER_URL>\\\",\n  depth: 2,\n});\n</script>\n\n<template>\n  <h1>{{ data.title }}</h1>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Adding Admin Configuration to a Blocks Field in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript snippet illustrates how to add admin-specific configurations to a Payload CMS Blocks Field. It utilizes the `admin` property within the Field definition object. This property allows customization of the field's appearance and behavior specifically within the Payload Admin Panel, inheriting base field admin options and adding block-specific ones like `group` or `initCollapsed`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyBlocksField: Field = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Using SEO Fields Directly in TypeScript\nDESCRIPTION: This snippet shows how to import pre-built field components from the `@payloadcms/plugin-seo/fields` module. It demonstrates configuring these fields with parameters like the related collection slug (`relationTo`), whether corresponding generation functions are enabled (`hasGenerateFn`), and paths to relevant data fields (`titlePath`, `descriptionPath`, `imagePath`). These fields can be used directly within Payload collection definitions but require the plugin to be configured globally.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport {\n  MetaDescriptionField,\n  MetaImageField,\n  MetaTitleField,\n  OverviewField,\n  PreviewField,\n} from '@payloadcms/plugin-seo/fields'\n\n// Used as fields\nMetaImageField({\n  // the upload collection slug\n  relationTo: 'media',\n\n  // if the `generateImage` function is configured\n  hasGenerateFn: true,\n})\n\nMetaDescriptionField({\n  // if the `generateDescription` function is configured\n  hasGenerateFn: true,\n})\n\nMetaTitleField({\n  // if the `generateTitle` function is configured\n  hasGenerateFn: true,\n})\n\nPreviewField({\n  // if the `generateUrl` function is configured\n  hasGenerateFn: true,\n\n  // field paths to match the target field for data\n  titlePath: 'meta.title',\n  descriptionPath: 'meta.description',\n})\n\nOverviewField({\n  // field paths to match the target field for data\n  titlePath: 'meta.title',\n  descriptionPath: 'meta.description',\n  imagePath: 'meta.image',\n})\n```\n\n----------------------------------------\n\nTITLE: Running Lexical Data Version Upgrade Script in TypeScript\nDESCRIPTION: This snippet shows how to execute a script to upgrade all existing Lexical rich text data within a Payload CMS application to the latest node versions defined in the editor configuration. It imports the `upgradeLexicalData` function from `@payloadcms/richtext-lexical` and runs it asynchronously with the `payload` instance. This process iterates through documents, loads Lexical fields, triggers internal node version upgrades if needed, and re-saves the documents. A database backup is strongly recommended before execution.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/migration.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { upgradeLexicalData } from '@payloadcms/richtext-lexical'\n\nawait upgradeLexicalData({ payload })\n```\n\n----------------------------------------\n\nTITLE: Cancelling Multiple Jobs via Where Query - Payload CMS - TypeScript\nDESCRIPTION: This example details how to cancel multiple jobs that match a given condition using the 'payload.jobs.cancel' function. The 'where' query filters jobs by properties, such as 'workflowSlug', and cancels matching jobs in one operation. Requires Payload system access and knowledge of the jobs schema. No return value is expected, and all jobs matching the query will be affected.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/jobs.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nawait payload.jobs.cancel({\n  where: {\n    workflowSlug: {\n      equals: 'createPost',\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Logging Out a User with a GraphQL Mutation\nDESCRIPTION: Example GraphQL mutation `logout[collection-singular-label]` (replace with actual label, e.g., `logoutUser`) used to log out the currently authenticated user. This operation clears the server-side session or token associated with the user.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_8\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  logout[collection-singular-label]\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding the Search Collection and Adding Custom Fields in TypeScript\nDESCRIPTION: Shows how to customize the auto-generated 'search' collection using the 'searchOverrides' option in TypeScript. Depends on the Payload and @payloadcms/plugin-search libraries and familiarity with Payload collection configs. It demonstrates renaming the collection and programmatically augmenting its fields array, e.g., adding an 'excerpt' textarea. The function receives 'defaultFields' and returns the extended fields array; output is a modified collection config suitable for custom indexing.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/search.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  searchPlugin({\n    searchOverrides: {\n      slug: 'search-results',\n      fields: ({ defaultFields }) => [\n        ...defaultFields,\n        {\n          name: 'excerpt',\n          type: 'textarea',\n          admin: {\n            position: 'sidebar',\n          },\n        },\n      ],\n    },\n  }),\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Uploadthing Storage Plugin in Payload CMS (TypeScript)\nDESCRIPTION: Example TypeScript code demonstrating how to integrate and configure the `uploadthingStorage` plugin within the Payload CMS `buildConfig`. It shows setting the target collection (`media`), providing the Uploadthing token from environment variables, and setting the access control list (ACL) to `public-read`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nexport default buildConfig({\n  collections: [Media],\n  plugins: [\n    uploadthingStorage({\n      collections: {\n        media: true,\n      },\n      options: {\n        token: process.env.UPLOADTHING_TOKEN,\n        acl: 'public-read',\n      },\n    }),\n  ],\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing Field Config in a Client Field Component (TSX)\nDESCRIPTION: This snippet demonstrates a custom React Client Component (`'use client'`) for a field (`TextFieldClientComponent`). It accesses a serializable version of the field's configuration through the `clientField` prop, as non-serializable properties are removed for client components.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport type { TextFieldClientComponent } from 'payload'\n\nexport const MyClientFieldComponent: TextFieldClientComponent = ({\n  clientField: { name },\n}) => {\n  return <p>{`This field's name is ${name}`}</p>\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Dynamic Props to PayloadAdminBar in NextJS App - TypeScript\nDESCRIPTION: This snippet shows how to forward dynamic NextJS props to the PayloadAdminBar component in a React application. It destructures the necessary values (collection, collectionLabels, id) from incoming pageProps and spreads them, along with a static cmsURL, into the PayloadAdminBar component. Requires the Payload Admin Bar component, suitable prop values in pageProps, and a TypeScript/React environment; outputs a configured admin bar tailored to the current route and document context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/admin-bar/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PayloadAdminBar } from '@payloadcms/admin-bar';\n\nexport const App = (appProps) => {\n  const {\n    pageProps: {\n      collection,\n      collectionLabels,\n      id\n    }\n  } = appProps;\n\n  return (\n    <PayloadAdminBar\n      {...{\n        cmsURL: 'https://cms.website.com',\n        collection,\n        collectionLabels,\n        id\n      }}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Field Label Server Component in PayloadCMS Admin (TSX)\nDESCRIPTION: Provides a server-side React component for rendering field labels in the PayloadCMS admin UI, utilizing @payloadcms/ui's FieldLabel. It selects the label from either the client's field label or name, passes required status and path, and can be used to override or wrap default field labeling. Dependencies: React, @payloadcms/ui, PayloadCMS type definitions. Intended for server-side rendering (e.g., in Next.js app router).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_16\n\nLANGUAGE: TSX\nCODE:\n```\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { RelationshipFieldLabelServerComponent } from 'payload'\n\nexport const CustomRelationshipFieldLabelServer: RelationshipFieldLabelServerComponent =\n  (clientField, path) => {\n    return (\n      <FieldLabel\n        label={clientField?.label || clientField?.name}\n        path={path}\n        required={clientField?.required}\n      />\n    )\n  }\n```\n\n----------------------------------------\n\nTITLE: Customizing Forgot Password Email HTML Template in Payload CMS (TypeScript)\nDESCRIPTION: This snippet provides a `generateEmailHTML` function in the `forgotPassword` config to create a custom HTML email for password resets. The function receives an object with `req`, `token`, and `user`, and returns a string of HTML content. Developers must use the token in the reset URL and ensure their application handles the reset using the token. Requires Payload CMS, and external HTML templating can be applied as needed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/email.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Customers: CollectionConfig = {\n  // ...\n  auth: {\n    forgotPassword: {\n      // highlight-start\n      generateEmailHTML: ({ req, token, user }) => {\n        // Use the token provided to allow your user to reset their password\n        const resetPasswordURL = `https://yourfrontend.com/reset-password?token=${token}`\n\n        return `\n          <!doctype html>\n          <html>\n            <body>\n              <h1>Here is my custom email template!</h1>\n              <p>Hello, ${user.email}!</p>\n              <p>Click below to reset your password.</p>\n              <p>\n                <a href=\"${resetPasswordURL}\">${resetPasswordURL}</a>\n              </p>\n            </body>\n          </html>\n        `\n      },\n      // highlight-end\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Using the useDocumentInfo Hook for Document Metadata - TypeScript\nDESCRIPTION: This example demonstrates the use of the useDocumentInfo hook from @payloadcms/ui to access document metadata, specifically retrieving the current document id in a React functional component. Dependencies are React and @payloadcms/ui. The id is undefined when creating a new document, so rendering is conditional based on its presence. If an id exists, a link is generated that filters 'posts' by the current category document's id. The snippet is relevant for cases when you need document context to dynamically generate UI or navigation within PayloadCMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n\"'use client'\\nimport { useDocumentInfo } from '@payloadcms/ui'\\n\\nconst LinkFromCategoryToPosts: React.FC = () => {\\n  // highlight-start\\n  const { id } = useDocumentInfo()\\n  // highlight-end\\n\\n  // id will be undefined on the create form\\n  if (!id) {\\n    return null\\n  }\\n\\n  return (\\n    <a\\n      href={`/admin/collections/posts?where[or][0][and][0][category][in][0]=[${id}]`}\\n    >\\n      View posts\\n    </a>\\n  )\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Mutating Raw SQL Schema Directly during beforeSchemaInit in Payload (TypeScript)\nDESCRIPTION: This snippet shows how to mutate Payload's internal 'rawTables' SQL schema within the beforeSchemaInit hook for low-level schema customization. It demonstrates adding a new table ('my_table'), inserting a custom column into an existing table ('posts'), and creating a new unique index on that column. Use this approach when advanced features unsupported by Drizzle's high-level API are required. Inputs are the schema and adapter, while output is the mutated schema. Some Drizzle features may not be supported by Payload's SQL layer; review limitations in the documentation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/postgres.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { postgresAdapter } from '@payloadcms/db-postgres'\n\npostgresAdapter({\n  beforeSchemaInit: [\n    ({ schema, adapter }) => {\n      // Add a new table\n      adapter.rawTables.myTable = {\n        name: 'my_table',\n        columns: {\n          my_id: {\n            name: 'my_id',\n            type: 'serial',\n            primaryKey: true,\n          },\n        },\n      }\n\n      // Add a new column to generated by Payload table:\n      adapter.rawTables.posts.columns.customColumn = {\n        name: 'custom_column',\n        // Note that Payload SQL doesn't support everything that Drizzle does.\n        type: 'integer',\n        notNull: true,\n      }\n      // Add a new index to generated by Payload table:\n      adapter.rawTables.posts.indexes.customColumnIdx = {\n        name: 'custom_column_idx',\n        unique: true,\n        on: ['custom_column'],\n      }\n\n      return schema\n    },\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Defining and Executing Inline Tasks in Payload CMS Workflow with TypeScript\nDESCRIPTION: This snippet configures a Payload CMS instance, specifying a workflow that uses both predefined and dynamic (inline) tasks within a handler. The inlineTask function is used to define a task in place, bypassing reuse and type assertions available for statically defined tasks. It demonstrates strongly typed task invocation (tasks.createPost) and untyped inline task invocation, including details such as manipulating post data within the handler. Prerequisites include Payload CMS, a configured collection named 'post', and TypeScript support. Key parameters are the workflow's inputSchema (defining required fields like 'title'), as well as the structure of the workflow handler arguments. Output from the inline task is stored in the job but without type safety, and some typing features are unavailable for such dynamically generated tasks.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/workflows.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default buildConfig({\n  // ...\n  jobs: {\n    tasks: [\n      // ...\n    ]\n    workflows: [\n      {\n        slug: 'createPostAndUpdate',\n        inputSchema: [\n          {\n            name: 'title',\n            type: 'text',\n            required: true,\n          },\n        ],\n        handler: async ({ job, tasks, inlineTask }) => {\n          // Here, we run a predefined task.\n          // The `createPost` handler arguments and return type\n          // are both strongly typed\n          const output = await tasks.createPost('1', {\n            input: {\n              title: job.input.title,\n            },\n          })\n\n          // Here, this task is not defined in the Payload config\n          // and is \"inline\". Its output will be stored on the Job in the database\n          // however its arguments will be untyped.\n          const { newPost } = await inlineTask('2', {\n            task: async ({ req }) => {\n              const newPost = await req.payload.update({\n                collection: 'post',\n                id: '2',\n                req,\n                retries: 3,\n                data: {\n                  title: 'updated!',\n                },\n              })\n              return {\n                output: {\n                  newPost\n                },\n              }\n            },\n          })\n        },\n      } as WorkflowConfig<'updatePost'>\n    ]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using usePreferences Hook in a Custom React Component (TypeScript)\nDESCRIPTION: This example demonstrates how to use the `usePreferences` hook from `@payloadcms/ui` within a custom React component intended for the Payload Admin Panel. It shows fetching preferences on mount using `getPreference` and updating them using `setPreference` when a user interacts with the component (e.g., selecting a color). The component maintains a local state (`lastUsedColors`) synchronized with the persisted preferences.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/preferences.mdx#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React, { Fragment, useState, useEffect, useCallback } from 'react'\nimport { usePreferences } from '@payloadcms/ui'\n\nconst lastUsedColorsPreferenceKey = 'last-used-colors'\n\nexport function CustomComponent() {\n  const { getPreference, setPreference } = usePreferences()\n\n  // Store the last used colors in local state\n  const [lastUsedColors, setLastUsedColors] = useState([])\n\n  // Callback to add a color to the last used colors\n  const updateLastUsedColors = useCallback(\n    (color) => {\n      // First, check if color already exists in last used colors.\n      // If it already exists, there is no need to update preferences\n      const colorAlreadyExists = lastUsedColors.indexOf(color) > -1\n\n      if (!colorAlreadyExists) {\n        const newLastUsedColors = [...lastUsedColors, color]\n\n        setLastUsedColors(newLastUsedColors)\n        setPreference(lastUsedColorsPreferenceKey, newLastUsedColors)\n      }\n    },\n    [lastUsedColors, setPreference],\n  )\n\n  // Retrieve preferences on component mount\n  // This will only be run one time, because the `getPreference` method never changes\n  useEffect(() => {\n    const asyncGetPreference = async () => {\n      const lastUsedColorsFromPreferences = await getPreference(\n        lastUsedColorsPreferenceKey,\n      )\n      setLastUsedColors(lastUsedColorsFromPreferences)\n    }\n\n    asyncGetPreference()\n  }, [getPreference])\n\n  return (\n    <div>\n      <button type=\"button\" onClick={() => updateLastUsedColors('red')}>\n        Use red\n      </button>\n      <button type=\"button\" onClick={() => updateLastUsedColors('blue')}>\n        Use blue\n      </button>\n      <button type=\"button\" onClick={() => updateLastUsedColors('purple')}>\n        Use purple\n      </button>\n      <button type=\"button\" onClick={() => updateLastUsedColors('yellow')}>\n        Use yellow\n      </button>\n      {lastUsedColors && (\n        <Fragment>\n          <h5>Last used colors:</h5>\n          <ul>\n            {lastUsedColors?.map((color) => <li key={color}>{color}</li>)}\n          </ul>\n        </Fragment>\n      )}\n    </div>\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Server Radio Field Component for Payload UI (React/TSX)\nDESCRIPTION: This code defines a custom Radio Field UI component suitable for server-side rendering within Payload CMS using React and TypeScript (TSX). It demonstrates how to compose the RadioGroupField component with essential props, enabling customization and extension of the native radio group UI. The snippet depends on '@payloadcms/ui' for UI primitives and relies on the Payload CMS field types and react infrastructure. Expected props include the field definition, schema path, and permissioning, with no browser-specific behavior assumed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/radio.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport type React from 'react'\\nimport { RadioGroupField } from '@payloadcms/ui'\\nimport type { RadioFieldServerComponent } from 'payload'\\n\\nexport const CustomRadioFieldServer: RadioFieldServerComponent = ({\\n  clientField,\\n  path,\\n  schemaPath,\\n  permissions,\\n}) => {\\n  return (\\n    <RadioGroupField\\n      field={clientField}\\n      path={path}\\n      schemaPath={schemaPath}\\n      permissions={permissions}\\n    />\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Creating Custom JSON Field Client Component in TSX\nDESCRIPTION: Provides a React client component (`CustomJSONFieldClient`) marked with `'use client'` for customizing the client-side behavior or rendering of a JSON field within the Payload CMS admin UI. It wraps and passes all received props (`{...props}`) to the default `JSONField` component from `@payloadcms/ui`, serving as a base for client-side customizations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/json.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { JSONField } from '@payloadcms/ui'\nimport type { JSONFieldClientComponent } from 'payload'\n\nexport const CustomJSONFieldClient: JSONFieldClientComponent = (props) => {\n  return <JSONField {...props} />\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Toolbar Buttons Group in Payload RichText Lexical (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a helper function, toolbarFormatGroupWithItems, that creates a toolbar group object for use with the Payload RichText Lexical editor. The function accepts an array of ToolbarGroupItem objects and returns a ToolbarGroup with the type 'buttons', a unique key, and an order parameter. It relies on type imports from '@payloadcms/richtext-lexical' and is intended for use when placing a horizontal button group (for toolbar icons only) within the editor. The key and order specify identity and placement of the group within the toolbar. The snippet can be used directly in client feature configuration and is suitable for merging multiple sets of toolbar items.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_16\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type {\n  ToolbarGroup,\n  ToolbarGroupItem,\n} from '@payloadcms/richtext-lexical'\n\nexport const toolbarFormatGroupWithItems = (\n  items: ToolbarGroupItem[],\n): ToolbarGroup => {\n  return {\n    type: 'buttons',\n    items,\n    key: 'myButtonsToolbar',\n    order: 10,\n  }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling Blocks/Arrays for Vercel Content Link (HTML/TSX)\nDESCRIPTION: This HTML/TSX snippet illustrates how to enable Vercel Content Link for Payload `blocks` and `array` fields, which lack plain text for direct encoding. The plugin adds an `_encodedSourceMap` property to these field types. This property should be rendered (often hidden, e.g., in a `<span>` with `display: none`) inside a container element that has the `data-vercel-edit-target` attribute. This allows Vercel's Edit Mode to target the entire block or section for editing.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/integrations/vercel-content-link.mdx#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<div data-vercel-edit-target>\n  <span style={{ display: \"none\" }}>{_encodedSourceMap}</span>\n  {children}\n</div>\n```\n\n----------------------------------------\n\nTITLE: Configuring Admin Options in Payload Config (TypeScript)\nDESCRIPTION: Shows the basic structure for configuring the Payload Admin Panel within the `payload.config.ts` file. Admin-specific settings are nested under the `admin` property of the object passed to the `buildConfig` function. Various options like `components`, `dateFormat`, `user`, etc., can be defined here.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/overview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: { // highlight-line\n    // ...\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Triggering Job Execution via Fetch Call to REST Endpoint (TypeScript)\nDESCRIPTION: This TypeScript example shows how to invoke Payload CMS job processing by sending a fetch request to the `/api/payload-jobs/run` endpoint. It's intended for scenarios such as serverless deployments, where external tools (e.g., Vercel Cron) trigger job execution. The snippet demonstrates limiting jobs by number and queue, with authentication via a Bearer token in the request header. Dependency: Fetch API (native in modern runtimes or polyfilled). Input parameters are the target endpoint, job limit, queue name, and authorization token. Output is the HTTP response from triggering job runs.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/queues.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// Here, we're saying we want to run only 100 jobs for this invocation\n// and we want to pull jobs from the `nightly` queue:\nawait fetch('/api/payload-jobs/run?limit=100&queue=nightly', {\n  method: 'GET',\n  headers: {\n    Authorization: `Bearer ${token}`,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Custom GraphQL Field Complexity in Payload (TypeScript)\nDESCRIPTION: Configures a field with an explicit GraphQL complexity value in Payload CMS. Useful for controlling query costs for resource-intensive fields such as relationship, upload, or join. The graphQL.complexity property allows tuning resolver cost to limit abusive or overly complex queries. Requires a Payload field definition and knowledge of expected field cost.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/overview.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst fieldWithComplexity = {\\n  name: 'authors',\\n  type: 'relationship',\\n  relationship: 'authors',\\n  graphQL: {\\n    complexity: 100, // highlight-line\\n  },\\n}\n```\n\n----------------------------------------\n\nTITLE: Unlocking a User Account via REST API using Fetch in TypeScript\nDESCRIPTION: Demonstrates how to unlock a locked user account by sending a POST request to the `/api/[collection-slug]/unlock` endpoint using the `fetch` API. Access control can restrict who performs this action.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await fetch(`http://localhost:3000/api/[collection-slug]/unlock`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring serverURL in Payload Project Configuration (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to specify the 'serverURL' field in your Payload project's configuration to ensure the deployed application responds at the intended custom domain. Place this code in your 'payload.config.ts' file; replace the placeholder URL with your actual domain. Other configuration fields should remain as per your existing project's structure. Requires '@payloadcms/payload' as a dependency and is typically used in projects running on custom or default domains within Payload Cloud.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/cloud/projects.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nexport default buildConfig({\\n  serverURL: 'https://example.com',\\n  // the rest of your config,\\n})\n```\n\n----------------------------------------\n\nTITLE: Overriding Parent and Breadcrumb Fields with Helper Functions - TypeScript\nDESCRIPTION: Illustrates advanced customization by using createParentField and createBreadcrumbsField helper methods to override and extend the default field configurations provided by the plugin. This example sets up custom admin options and customizes field labels. The code is intended for use within a Payload collection config TypeScript file, with dependencies on '@payloadcms/plugin-nested-docs/fields'. Prerequisite: These methods merge custom settings atop the built-in field configuration; if you customize the field 'name', ensure you set the corresponding breadcrumbsFieldSlug or parentFieldSlug in plugin options.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/nested-docs.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\nimport { createParentField } from '@payloadcms/plugin-nested-docs/fields'\nimport { createBreadcrumbsField } from '@payloadcms/plugin-nested-docs/fields'\n\nconst examplePageConfig: CollectionConfig = {\n  slug: 'pages',\n  fields: [\n    createParentField(\n      // First argument is equal to the slug of the collection\n      // that the field references\n      'pages',\n\n      // Second argument is equal to field overrides that you specify,\n      // which will be merged into the base parent field config\n      {\n        admin: {\n          position: 'sidebar',\n        },\n        // Note: if you override the `filterOptions` of the `parent` field,\n        // be sure to continue to prevent the document from referencing itself as the parent like this:\n        // filterOptions: ({ id }) => ({ id: {not_equals: id }})\n      },\n    ),\n    createBreadcrumbsField(\n      // First argument is equal to the slug of the collection\n      // that the field references\n      'pages',\n\n      // Argument equal to field overrides that you specify,\n      // which will be merged into the base `breadcrumbs` field config\n      {\n        label: 'Page Breadcrumbs',\n      },\n    ),\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Importing TypeScript Types for Custom Payload Field Components\nDESCRIPTION: This snippet shows how to import relevant TypeScript types from the 'payload' package when building custom field components. It includes types for both client and server components and their respective props, ensuring type safety during development (e.g., `TextFieldClientComponent`, `TextFieldServerProps`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n```tsx\nimport type {\n  TextFieldClientComponent,\n  TextFieldServerComponent,\n  TextFieldClientProps,\n  TextFieldServerProps,\n  // ...and so on for each Field Type\n} from 'payload'\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom PreviewButton (Client Component) in Payload CMS\nDESCRIPTION: This snippet illustrates a custom React client component (`MyPreviewButton`) for the Preview button in Payload CMS, using the `'use client'` directive. It renders the default `PreviewButton` component provided by `@payloadcms/ui`. This component is designed for client-side rendering. Dependencies include `react`, `@payloadcms/ui`, and `payload` types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { PreviewButton } from '@payloadcms/ui'\nimport type { PreviewButtonClientProps } from 'payload'\n\nexport function MyPreviewButton(props: PreviewButtonClientProps) {\n  return <PreviewButton />\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Database Schema for Collection Versions - JSON\nDESCRIPTION: This snippet demonstrates the structure of a version document as stored in a PayloadCMS versions collection. It includes identifiers, links to the parent document, autosave flags, a version object holding the document's data, and timestamps. The schema ensures each version is individually addressable and auditable, and is the standard output format for querying or storing versions within PayloadCMS. The actual fields in 'version' are flexible to the collection's document schema.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/versions/overview.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"_id\\\": \\\"61cf752c19cdf1b1af7b61f1\\\", // a unique ID of this version\\n  \\\"parent\\\": \\\"61ce1354091d5b3ffc20ea6e\\\", // the ID of the parent document\\n  \\\"autosave\\\": false, // used to denote if this version was created via autosave\\n  \\\"version\\\": {\\n    // your document's data goes here\\n    // all fields are set to not required and this property can be partially complete\\n  },\\n  \\\"createdAt\\\": \\\"2021-12-31T21:25:00.992+00:00\\\",\\n  \\\"updatedAt\\\": \\\"2021-12-31T21:25:00.992+00:00\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Locale Using useLocale Hook in React (TypeScript)\nDESCRIPTION: Demonstrates extracting and displaying the current admin UI locale with the useLocale hook from @payloadcms/ui. This hook exposes the selected locale's label, code, and right-to-left property; no configuration is required beyond importing the hook. Example uses a lookup table keyed by locale codes ('en', 'es') to display a localized greeting.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport { useLocale } from '@payloadcms/ui'\\n\\nconst Greeting: React.FC = () => {\\n  // highlight-start\\n  const locale = useLocale()\\n  // highlight-end\\n\\n  const trans = {\\n    en: 'Hello',\\n    es: 'Hola',\\n  }\\n\\n  return <span> {trans[locale.code]} </span>\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Code Field Server Component - React (TSX)\nDESCRIPTION: Illustrates building a custom server-side Code Field React component for Payload, typed as CodeFieldServerComponent. Depends on React, Payload types, and '@payloadcms/ui'. The component receives field and permission props, and renders the standard CodeField component, passing all props through. Suitable for customizing or extending the server-side field UI in Payload projects.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/code.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport type React from 'react'\nimport { CodeField } from '@payloadcms/ui'\nimport type { CodeFieldServerComponent } from 'payload'\n\nexport const CustomCodeFieldServer: CodeFieldServerComponent = ({\n  clientField,\n  path,\n  schemaPath,\n  permissions,\n}) => {\n  return (\n    <CodeField\n      field={clientField}\n      path={path}\n      schemaPath={schemaPath}\n      permissions={permissions}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom PublishButton (Client Component) in Payload CMS\nDESCRIPTION: This snippet provides a custom React client component (`MyPublishButton`) for the Publish button in Payload CMS, marked with `'use client'`. It renders the default `PublishButton` from `@payloadcms/ui` with a custom label 'Publish'. This component is intended for client-side execution. Dependencies include `react`, `@payloadcms/ui`, and `payload` types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { PublishButton } from '@payloadcms/ui'\nimport type { PublishButtonClientProps } from 'payload'\n\nexport function MyPublishButton(props: PublishButtonClientProps) {\n  return <PublishButton label=\"Publish\" />\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Markdown to Lexical Richtext State in Payload CMS - TypeScript\nDESCRIPTION: This snippet demonstrates how to convert a Markdown string to a Lexical editor state (as JSON) using the Payload richtext-lexical utility functions. It requires the Payload Config for editor configuration to be passed to editorConfigFactory. The markdown input is a string; the output, stored in lexicalJSON, contains the lexical state suitable for the editor.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-markdown.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  convertMarkdownToLexical,\n  editorConfigFactory,\n} from '@payloadcms/richtext-lexical'\n\nconst lexicalJSON = convertMarkdownToLexical({\n  editorConfig: await editorConfigFactory.default({\n    config, // <= make sure you have access to your Payload Config\n  }),\n  markdown: '# Hello world\\n\\nThis is a **test**.',\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Multi-Tenant Plugin Configuration Options Type in TypeScript\nDESCRIPTION: Defines the `MultiTenantPluginConfig` TypeScript type, detailing all available configuration options for the multi-tenant plugin. This includes settings like `cleanupAfterTenantDelete`, collection-specific settings (isGlobal, useBaseListFilter, useTenantAccess), debug mode, tenant field customization (`tenantField`), user association field customization (`tenantsArrayField`), internationalization for the tenant selector (`tenantSelectorLabel`), tenant collection slug (`tenantsSlug`), defining super-admin access (`userHasAccessToAllTenants`), and controlling default access/filters (`useTenantsCollectionAccess`, `useTenantsListFilter`, `useUsersTenantFilter`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/multi-tenant.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype MultiTenantPluginConfig<ConfigTypes = unknown> = {\n  /**\n   * After a tenant is deleted, the plugin will attempt to clean up related documents\n   * - removing documents with the tenant ID\n   * - removing the tenant from users\n   *\n   * @default true\n   */\n  cleanupAfterTenantDelete?: boolean\n  /**\n   * Automatically\n   */\n  collections: {\n    [key in CollectionSlug]?: {\n      /**\n       * Set to `true` if you want the collection to behave as a global\n       *\n       * @default false\n       */\n      isGlobal?: boolean\n      /**\n       * Set to `false` if you want to manually apply the baseListFilter\n       *\n       * @default true\n       */\n      useBaseListFilter?: boolean\n      /**\n       * Set to `false` if you want to handle collection access manually without the multi-tenant constraints applied\n       *\n       * @default true\n       */\n      useTenantAccess?: boolean\n    }\n  }\n  /**\n   * Enables debug mode\n   * - Makes the tenant field visible in the admin UI within applicable collections\n   *\n   * @default false\n   */\n  debug?: boolean\n  /**\n   * Enables the multi-tenant plugin\n   *\n   * @default true\n   */\n  enabled?: boolean\n  /**\n   * Field configuration for the field added to all tenant enabled collections\n   */\n  tenantField?: {\n    access?: RelationshipField['access']\n    /**\n     * The name of the field added to all tenant enabled collections\n     *\n     * @default 'tenant'\n     */\n    name?: string\n  }\n  /**\n   * Field configuration for the field added to the users collection\n   *\n   * If `includeDefaultField` is `false`, you must include the field on your users collection manually\n   * This is useful if you want to customize the field or place the field in a specific location\n   */\n  tenantsArrayField?:\n    | {\n        /**\n         * Access configuration for the array field\n         */\n        arrayFieldAccess?: ArrayField['access']\n        /**\n         * Name of the array field\n         *\n         * @default 'tenants'\n         */\n        arrayFieldName?: string\n        /**\n         * Name of the tenant field\n         *\n         * @default 'tenant'\n         */\n        arrayTenantFieldName?: string\n        /**\n         * When `includeDefaultField` is `true`, the field will be added to the users collection automatically\n         */\n        includeDefaultField?: true\n        /**\n         * Additional fields to include on the tenants array field\n         */\n        rowFields?: Field[]\n        /**\n         * Access configuration for the tenant field\n         */\n        tenantFieldAccess?: RelationshipField['access']\n      }\n    | {\n        arrayFieldAccess?: never\n        arrayFieldName?: string\n        arrayTenantFieldName?: string\n        /**\n         * When `includeDefaultField` is `false`, you must include the field on your users collection manually\n         */\n        includeDefaultField?: false\n        rowFields?: never\n        tenantFieldAccess?: never\n      }\n  /**\n   * Customize tenant selector label\n   *\n   * Either a string or an object where the keys are i18n codes and the values are the string labels\n   */\n  tenantSelectorLabel?:\n    | Partial<{\n        [key in AcceptedLanguages]?: string\n      }>\n    | string\n  /**\n   * The slug for the tenant collection\n   *\n   * @default 'tenants'\n   */\n  tenantsSlug?: string\n  /**\n   * Function that determines if a user has access to _all_ tenants\n   *\n   * Useful for super-admin type users\n   */\n  userHasAccessToAllTenants?: (\n    user: ConfigTypes extends { user: unknown } ? ConfigTypes['user'] : User,\n  ) => boolean\n  /**\n   * Opt out of adding access constraints to the tenants collection\n   */\n  useTenantsCollectionAccess?: boolean\n  /**\n   * Opt out including the baseListFilter to filter tenants by selected tenant\n   */\n  useTenantsListFilter?: boolean\n  /**\n   * Opt out including the baseListFilter to filter users by selected tenant\n   */\n  useUsersTenantFilter?: boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom JSON Field Label Client Component in TSX\nDESCRIPTION: Provides a React client component (`CustomJSONFieldLabelClient`) marked with `'use client'` for customizing the label associated with a JSON field in the Payload CMS admin UI. It renders the label using the `FieldLabel` component from `@payloadcms/ui`, displaying `field?.label` or `field?.name` as the label text and showing the required status based on `field?.required`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/json.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { JSONFieldLabelClientComponent } from 'payload'\n\nexport const CustomJSONFieldLabelClient: JSONFieldLabelClientComponent = ({\n  field,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={field?.label || field?.name}\n      path={path}\n      required={field?.required}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing and Toggling Theme with useTheme in React (TypeScript)\nDESCRIPTION: Shows how to access the current theme, autoMode, and change the theme using setTheme from useTheme in @payloadcms/ui. This snippet is for UI components managing admin dark/light/auto theming. All dependencies are internal to @payloadcms/ui and the Payload CMS admin context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_17\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport { useTheme } from '@payloadcms/ui'\\n\\nconst MyComponent: React.FC = () => {\\n  // highlight-start\\n  const { autoMode, setTheme, theme } = useTheme()\\n  // highlight-end\\n\\n  return (\\n    <>\\n      <span>\\n        The current theme is {theme} and autoMode is {autoMode}\\n      </span>\\n      <button\\n        type=\\\"button\\\"\\n        onClick={() =>\\n          setTheme((prev) => (prev === 'light' ? 'dark' : 'light'))\\n        }\\n      >\\n        Toggle theme\\n      </button>\\n    </>\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Using Payload UI Link for Automatic Route Transitions\nDESCRIPTION: This React component demonstrates the default behavior of the `Link` component imported from `@payloadcms/ui`. Using this `Link` component for navigation automatically triggers visual route transitions without requiring explicit setup.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Link } from '@payloadcms/ui'\n\nconst MyComponent = () => {\n  return <Link href=\"/somewhere\">Go Somewhere</Link>\n}\n```\n\n----------------------------------------\n\nTITLE: Typing the Translation Function (t) in Payload CMS Field Definitions\nDESCRIPTION: Illustrates how to ensure type safety when using the translation function (`t`) within dynamic field properties like `label` in a Payload CMS field definition. It involves importing the custom translation keys type (`CustomTranslationsKeys`) and casting the provided `t` function (`defaultT`) using `as TFunction<CustomTranslationsKeys>` to correctly type-check access to custom translation strings.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/i18n.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// <rootDir>/fields/myField.ts\n\nimport type {\n  DefaultTranslationKeys,\n  TFunction,\n} from '@payloadcms/translations'\nimport type { Field } from 'payload'\n\nimport { CustomTranslationsKeys } from '../custom-translations'\n\nconst field: Field = {\n  name: 'myField',\n  type: 'text',\n  label: ({ t: defaultT }) => {\n    const t = defaultT as TFunction<CustomTranslationsKeys>\n    return t('fields:addLabel')\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Email Field Client Component in Payload CMS (TSX)\nDESCRIPTION: This snippet demonstrates creating a custom React Client Component for an Email field, indicated by the `'use client'` directive. It imports and wraps the default `EmailField` component from `@payloadcms/ui`, using props spreading (`{...props}`) to pass down all received properties. This pattern is used for adding client-side interactivity or logic to the field.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/email.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport React from 'react'\nimport { EmailField } from '@payloadcms/ui'\nimport type { EmailFieldClientComponent } from 'payload'\n\nexport const CustomEmailFieldClient: EmailFieldClientComponent = (props) => {\n  return <EmailField {...props} />\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Row Field in Payload CMS with TypeScript\nDESCRIPTION: This snippet demonstrates how to define a custom Row Field in a Payload CMS field configuration using TypeScript. The core functionality sets the 'type' property to 'row' and nests an array of field objects under the 'fields' property. No business logic is involved, and there are no runtime dependencies, but it requires the Payload CMS TypeScript typings to enable type checking. The expected input is a Field configuration object, and the output is a definition that can be included in a Payload collection schema.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/row.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyRowField: Field = {\n  // ...\n  // highlight-start\n  type: 'row',\n  fields: [\n    // ...\n  ],\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Unlocking a User Account using Payload's Local API in TypeScript\nDESCRIPTION: Shows how to unlock a user account programmatically using Payload's Local API method `payload.unlock`. Requires specifying the collection slug for the user to be unlocked.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = await payload.unlock({\n  collection: 'collection-slug',\n})\n```\n\n----------------------------------------\n\nTITLE: Extending Function Hooks in the Payload Config (TypeScript)\nDESCRIPTION: Shows how to extend function properties (such as onInit) in the Payload config by calling the original function and then running additional logic. This avoids losing behavior from previous hooks. Meant for advanced Payload plugin customization. Requires context for plugin options and extension logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconfig.onInit = async payload => {\n  if (incomingConfig.onInit) await incomingConfig.onInit(payload)\n\n  // Add additional onInit code by using the onInitExtension function\n  onInitExtension(pluginOptions, payload)\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Custom Bin Script in Payload Config (TypeScript)\nDESCRIPTION: Shows how to register a custom script (e.g., `seed.ts`) within the Payload configuration using the `bin` array. This makes the script executable via the Payload CLI (e.g., `npx payload seed`) by mapping a `key` to the `scriptPath`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport default buildConfig({\n  bin: [\n    {\n      scriptPath: path.resolve(dirname, 'seed.ts'),\n      key: 'seed',\n    },\n  ],\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Authenticating a User with Payload Local API in a Server Function (TypeScript)\nDESCRIPTION: This server function uses Payload's Local API to authenticate the current user by extracting request headers via Next.js's 'next/headers' APIs. The function is denoted as a server function ('use server') and imports dependencies: '@payload-config', 'getPayload', and 'next/headers'. It returns a greeting containing the user's email if authenticated, or a default message if not. Expected input is the headers; output is a greeting message in an object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n\"'use server'\\n\\nimport { headers as getHeaders } from 'next/headers'\\nimport config from '@payload-config'\\nimport { getPayload } from 'payload'\\n\\nexport const authenticateUser = async () => {\\n  const payload = await getPayload({ config })\\n  const headers = await getHeaders()\\n  const { user } = await payload.auth({ headers })\\n\\n  if (user) {\\n    return { hello: user.email }\\n  }\\n\\n  return { hello: 'Not authenticated' }\\n}\\n\"\n```\n\n----------------------------------------\n\nTITLE: Configuring pasteURL Allow List for Server-side File Fetching - Payload CMS - TypeScript\nDESCRIPTION: This configuration snippet demonstrates how to customize the upload.pasteURL allowList in Payload CMS to control which remote URLs are eligible for server-side file uploads. It exports a CollectionConfig object (in TypeScript) where the upload field contains a pasteURL property with an allowList, specifying allowed hostnames, optional pathnames, ports, protocols, and search parameters. Required dependency: type { CollectionConfig } from 'payload'. This enables secure server-side retrieval of files by whitelisting trusted domains, with wildcard and protocol matching available.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/overview.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Media: CollectionConfig = {\n  slug: 'media',\n  upload: {\n    pasteURL: {\n      allowList: [\n        {\n          hostname: 'payloadcms.com', // required\n          pathname: '',\n          port: '',\n          protocol: 'https',\n          search: ''\n        },\n        {\n          hostname: 'example.com',\n          pathname: '/images/*',\n        },\n      ],\n    },\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom SaveDraftButton Server Component (TSX)\nDESCRIPTION: Example of a custom React server component for the Save Draft button. It imports the base `SaveDraftButton` from `@payloadcms/ui`, receives `SaveDraftButtonServerProps`, and renders a potentially customized version of the button.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport React from 'react'\nimport { SaveDraftButton } from '@payloadcms/ui'\nimport type { SaveDraftButtonServerProps } from 'payload'\n\nexport function MySaveDraftButton(props: SaveDraftButtonServerProps) {\n  return <SaveDraftButton />\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Dynamically Setting Step Navigation with useStepNav in React\nDESCRIPTION: This React component utilizes the `useStepNav` hook from `@payloadcms/ui` to modify the application's step navigation. It accepts an array of `StepNavItem` objects via props and uses the `setStepNav` function within a `useEffect` hook to update the navigation whenever the `nav` prop changes. The component itself renders nothing (`null`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport { type StepNavItem, useStepNav } from '@payloadcms/ui'\nimport { useEffect } from 'react'\n\nexport const MySetStepNavComponent: React.FC<{ \n  nav: StepNavItem[] \n}> = ({ nav }) => {\n  const { setStepNav } = useStepNav()\n\n  useEffect(() => {\n    setStepNav(nav)\n  }, [setStepNav, nav])\n\n  return null\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Lexical Richtext to Plaintext using PayloadCMS Utility in TypeScript\nDESCRIPTION: This snippet shows how to convert Lexical richtext data into plaintext using the PayloadCMS utility function convertLexicalToPlaintext. It imports necessary types and functions from the @payloadcms/richtext-lexical packages. The function takes an object containing the richtext data and returns a plaintext string representation. Dependencies include PayloadCMS lexical packages and properly structured editor state data. Inputs are the serialized editor state, and the output is a string with the extracted plain text.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-plaintext.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\n\nimport { convertLexicalToPlaintext } from '@payloadcms/richtext-lexical/plaintext'\n\n// Your richtext data here\nconst data: SerializedEditorState = {}\n\nconst plaintext = convertLexicalToPlaintext({ data })\n```\n\n----------------------------------------\n\nTITLE: Generated SharedMeta Interface Example - Payload CMS - TypeScript\nDESCRIPTION: This code block shows the top-level reusable 'SharedMeta' interface produced by the previous field definition, as well as its usage in a collection interface. It illustrates how group fields are promoted to named interfaces for structured code reuse, with all field members strongly typed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/generating-types.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// a top level reusable interface!!\nexport interface SharedMeta {\n  title?: string\n  description?: string\n}\n\n// example usage inside collection interface\nexport interface Collection1 {\n  // ...other fields\n  meta?: SharedMeta\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Blocks Field Label (Client Component) - React TypeScript\nDESCRIPTION: Provides a client-side React component for rendering a field label for block fields in PayloadCMS. Uses the '@payloadcms/ui' FieldLabel and accepts label, path, and required props, allowing conditional display and type-checked integration with the client-side block label component slot. Suitable for SSR/reactive frontends with PayloadCMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { BlocksFieldLabelClientComponent } from 'payload'\n\nexport const CustomBlocksFieldLabelClient: BlocksFieldLabelClientComponent = ({\n  label,\n  path,\n  required,\n}) => {\n  return (\n    <FieldLabel\n      label={field?.label || field?.name}\n      path={path}\n      required={field?.required}\n    />\n  )\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Editor State with Custom Node Types - Payload Rich Text - TypeScript\nDESCRIPTION: Demonstrates how to define a strictly-typed editor state for the Lexical rich text field in PayloadCMS with fully customized possible node types, using the TypedEditorState type from @payloadcms/richtext-lexical. Requires the imported node types and TypedEditorState from @payloadcms/richtext-lexical. The editorState constant represents the expected JSON object structure of the editor, and key properties include the type of each node and their nested configuration. Only node types specified in the union are allowed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/overview.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type {\n  SerializedAutoLinkNode,\n  SerializedBlockNode,\n  SerializedHorizontalRuleNode,\n  SerializedLinkNode,\n  SerializedListItemNode,\n  SerializedListNode,\n  SerializedParagraphNode,\n  SerializedQuoteNode,\n  SerializedRelationshipNode,\n  SerializedTextNode,\n  SerializedUploadNode,\n  TypedEditorState,\n  SerializedHeadingNode,\n} from '@payloadcms/richtext-lexical'\n\nconst editorState: TypedEditorState<\n  | SerializedAutoLinkNode\n  | SerializedBlockNode\n  | SerializedHorizontalRuleNode\n  | SerializedLinkNode\n  | SerializedListItemNode\n  | SerializedListNode\n  | SerializedParagraphNode\n  | SerializedQuoteNode\n  | SerializedRelationshipNode\n  | SerializedTextNode\n  | SerializedUploadNode\n  | SerializedHeadingNode\n> = {\n  root: {\n    type: 'root',\n    direction: 'ltr',\n    format: '',\n    indent: 0,\n    version: 1,\n    children: [\n      {\n        children: [\n          {\n            detail: 0,\n            format: 0,\n            mode: 'normal',\n            style: '',\n            text: 'Some text. Every property here is fully-typed',\n            type: 'text',\n            version: 1,\n          },\n        ],\n        direction: 'ltr',\n        format: '',\n        indent: 0,\n        type: 'paragraph',\n        textFormat: 0,\n        version: 1,\n      },\n    ],\n  },\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Date Field Server Component in Payload TSX\nDESCRIPTION: This snippet demonstrates how to create a custom server component for a Date field in Payload CMS. It defines a React server component `CustomDateFieldServer` that utilizes the default `@payloadcms/ui/DateTimeField` component. This component receives props like `clientField`, `path`, `schemaPath`, and `permissions` and passes them down, allowing for customization or wrapping of the standard date field rendering logic on the server.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/date.mdx#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport type React from 'react'\nimport { DateTimeField } from '@payloadcms/ui'\nimport type { DateFieldServerComponent } from 'payload'\n\nexport const CustomDateFieldServer: DateFieldServerComponent = ({\n  clientField,\n  path,\n  schemaPath,\n  permissions,\n}) => {\n  return (\n    <DateTimeField\n      field={clientField}\n      path={path}\n      schemaPath={schemaPath}\n      permissions={permissions}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Basic Sentry Plugin Configuration in Payload\nDESCRIPTION: This TypeScript snippet shows the basic setup for integrating the Sentry plugin into a Payload CMS configuration. It imports the necessary modules (`buildConfig`, `sentryPlugin`, `@sentry/nextjs`) and adds the `sentryPlugin` to the `plugins` array, passing the required `Sentry` instance.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/sentry.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { sentryPlugin } from '@payloadcms/plugin-sentry'\nimport { Pages, Media } from './collections'\n\nimport * as Sentry from '@sentry/nextjs'\n\nconst config = buildConfig({\n  collections: [Pages, Media],\n  plugins: [\n    sentryPlugin({\n      Sentry,\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Referencing a Task Handler by Absolute Path in PayloadCMS Config (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use Node.js 'path' and 'url' modules to construct an absolute path to a separate handler function file in the PayloadCMS configuration. This pattern offloads large dependencies from the main application bundle, aiding performance in complex architectures or Next.js apps. 'path.resolve' and 'createPost.ts#createPostHandler' are used to point to the exported handler. The config structure mirrors inline usage except for 'handler', which now uses a string path and named export reference. All required dependencies must be ensured to be available at build and runtime.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/tasks.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { fileURLToPath } from 'node:url'\nimport path from 'path'\n\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nexport default buildConfig({\n  jobs: {\n    tasks: [\n      {\n        // ...\n        // The #createPostHandler is a named export within the `createPost.ts` file\n        handler:\n          path.resolve(dirname, 'src/tasks/createPost.ts') +\n          '#createPostHandler',\n      },\n    ],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Overriding Payload Default Styles using CSS Layers\nDESCRIPTION: This CSS snippet shows how to override Payload's default styles while respecting the original specificity rules by placing custom CSS within the `@layer payload-default` CSS layer. All Payload default CSS is encapsulated within this layer, allowing custom styles outside this layer to have higher specificity. Using this layer ensures custom styles integrate correctly with Payload's styling system.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/customizing-css.mdx#_snippet_1\n\nLANGUAGE: css\nCODE:\n```\n@layer payload-default {\n  // my styles within the Payload specificity\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Payload Configuration with buildConfig in TypeScript\nDESCRIPTION: This snippet demonstrates the basic structure of a `payload.config.ts` file. It imports the `buildConfig` function from the 'payload' package and exports a default configuration object created by calling this function. This file serves as the central point for defining all Payload CMS settings.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // Your config goes here\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing beforeDelete Hook in Payload (TypeScript)\nDESCRIPTION: Provides a template for the beforeDelete hook in a Payload collection using TypeScript. This hook runs before a delete operation is committed; its returned values are ignored. The snippet imports CollectionBeforeDeleteHook and defines an async handler, destructuring req and id, ready for custom pre-deletion logic or side effects. Requires Payload as a dependency.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionBeforeDeleteHook } from 'payload';\n\nconst beforeDeleteHook: CollectionBeforeDeleteHook = async ({\n  req,\n  id,\n}) => {...}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Route Refresh Logic for Live Preview - TypeScript React\nDESCRIPTION: This TypeScript React function component provides a low-level implementation of RefreshRouteOnSave, suitable for custom or advanced usage. It listens for MessageEvents from the Payload Admin Panel and triggers a route refresh when a document-level event is detected. The component ensures only one ready message is sent, and manages event handlers' subscription and cleanup via useEffect. Dependencies include @payloadcms/live-preview, React, and appropriate props. Expected behavior is seamless server-side live preview in custom front-end scenarios.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/server.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\n\nimport type React from 'react'\n\nimport { isDocumentEvent, ready } from '@payloadcms/live-preview'\nimport { useCallback, useEffect, useRef } from 'react'\n\nexport const RefreshRouteOnSave: React.FC<{\n  apiRoute?: string\n  depth?: number\n  refresh: () => void\n  serverURL: string\n}> = (props) => {\n  const { apiRoute, depth, refresh, serverURL } = props\n  const hasSentReadyMessage = useRef<boolean>(false)\n\n  const onMessage = useCallback(\n    (event: MessageEvent) => {\n      if (isDocumentEvent(event, serverURL)) {\n        if (typeof refresh === 'function') {\n          refresh()\n        }\n      }\n    },\n    [refresh, serverURL],\n  )\n\n  useEffect(() => {\n    if (typeof window !== 'undefined') {\n      window.addEventListener('message', onMessage)\n    }\n\n    if (!hasSentReadyMessage.current) {\n      hasSentReadyMessage.current = true\n\n      ready({\n        serverURL,\n      })\n    }\n\n    return () => {\n      if (typeof window !== 'undefined') {\n        window.removeEventListener('message', onMessage)\n      }\n    }\n  }, [serverURL, onMessage, depth, apiRoute])\n\n  return null\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Document Tabs - Payload CMS TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to add or customize tabs in the Document View of a Payload CMS Collection by configuring the views.edit.[key].tab property. It includes the addition of custom view tabs with custom React components or simple label/href overrides. Dependencies include Payload CMS, a custom CollectionConfig, and user-created React components. The configuration object allows specifying the displayed label, navigation target, or complete tab UI via a component.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/document-views.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  slug: 'my-collection',\n  admin: {\n    components: {\n      views: {\n        edit: {\n          myCustomTab: {\n            Component: '/path/to/MyCustomTab',\n            path: '/my-custom-tab',\n            // highlight-start\n            tab: {\n              Component: '/path/to/MyCustomTabComponent',\n            },\n            // highlight-end\n          },\n          anotherCustomTab: {\n            Component: '/path/to/AnotherCustomView',\n            path: '/another-custom-view',\n            // highlight-start\n            tab: {\n              label: 'Another Custom View',\n              href: '/another-custom-view',\n            },\n            // highlight-end\n          },\n        },\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Date Field Admin Options in Payload CMS (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to configure admin-specific options for a Date Field in Payload CMS. It utilizes the 'admin' property within the field definition to customize the appearance and behavior of the date picker in the admin panel, potentially overriding default settings or passing props to the underlying `react-datepicker` component.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/date.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyDateField: Field = {\n  // ...\n  admin: { // highlight-line\n    // ...\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using useLocale Hook in a Client Component (TSX)\nDESCRIPTION: This snippet shows how to access the currently active locale within a Payload Client Component (`'use client'`). It uses the `useLocale` hook from `@payloadcms/ui` to retrieve the locale object, which contains properties like the locale `code` (e.g., 'en', 'es').\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { useLocale } from '@payloadcms/ui'\n\nfunction Greeting() {\n  const locale = useLocale() // highlight-line\n\n  const trans = {\n    en: 'Hello',\n    es: 'Hola',\n  }\n\n  return <span>{trans[locale.code]}</span>\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Redirects Plugin Options in Payload CMS (TypeScript)\nDESCRIPTION: Provides an extended configuration example for the redirects plugin in TypeScript, including overrides for fields and redirect types. Demonstrates passing a function to augment default fields, customizing redirect types, and overriding the redirect type field configuration. Key parameters are 'collections', 'overrides', 'redirectTypes', and 'redirectTypeFieldOverride'. The snippet assumes integration within a Payload CMS config file.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/redirects.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nredirectsPlugin({\n  collections: ['pages'],\n  overrides: {\n    fields: ({ defaultFields }) => {\n      return [\n        ...defaultFields,\n        {\n          type: 'text',\n          name: 'customField',\n        },\n      ]\n    },\n  },\n  redirectTypes: ['301', '302'],\n  redirectTypeFieldOverride: {\n    label: 'Redirect Type (Overridden)',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Custom Field Label Client Component in PayloadCMS Admin (TSX)\nDESCRIPTION: Implements a client-side field label component using React in PayloadCMS, for use within the new PayloadCMS app router or admin UI customization. Uses the 'use client' directive, and FieldLabel from @payloadcms/ui. Displays a label for the field, deciding between a custom label or the field\\'s name, and passes along path and required properties. Can be used to replace or supplement PayloadCMS's default field labels. Dependencies: React, @payloadcms/ui, PayloadCMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_17\n\nLANGUAGE: TSX\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { RelationshipFieldLabelClientComponent } from 'payload'\n\nexport const CustomRelationshipFieldLabelClient: RelationshipFieldLabelClientComponent =\n  ({ field, path }) => {\n    return (\n      <FieldLabel\n        label={field?.label || field?.name}\n        path={path}\n        required={field?.required}\n      />\n    )\n  }\n```\n\n----------------------------------------\n\nTITLE: Declaring Constants within Drawer Content (TypeScript)\nDESCRIPTION: Demonstrates the declaration of numeric constants using `const` in TypeScript. This identical snippet is embedded within the `drawerContent` string property of a `RestExamples` component configuration, specifically associated with the 'Find' operation example.\nSOURCE: https://github.com/payloadcms/payload/blob/main/test/lexical-mdx/tests/restExamples.input.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nconst a = 1\nconst b = 2\nconst c = 3\nconst d = 4\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Task Restoration Behavior in Payload CMS (TypeScript)\nDESCRIPTION: This snippet demonstrates how to configure the `shouldRestore` property of a task's retries object within a Payload CMS job configuration. Setting `shouldRestore` to `false` ensures the task is always re-run rather than restoring previous successful outputs. The configuration references the `TaskConfig` type for static typing and should be used within a valid Payload CMS project where jobs and tasks configurations are supported.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/tasks.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default buildConfig({\n  // ...\n  jobs: {\n    tasks: [\n      {\n        slug: 'myTask',\n        retries: {\n          shouldRestore: false,\n        },\n        // ...\n      } as TaskConfig<'myTask'>,\n    ],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Edit View Server Component (TSX)\nDESCRIPTION: Example of a custom React server component intended to replace the default Payload Edit View. It receives `DocumentViewServerProps` and renders custom content. This component would be referenced in the Payload configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport React from 'react'\nimport type { DocumentViewServerProps } from 'payload'\n\nexport function MyCustomServerEditView(props: DocumentViewServerProps) {\n  return <div>This is a custom Edit View (Server)</div>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Importing TypeScript Types for Custom Diff Components (TSX)\nDESCRIPTION: Demonstrates importing TypeScript types like `TextFieldDiffServerComponent` and `TextFieldDiffClientComponent` for building type-safe custom Diff components in Payload CMS, used in the version comparison view. Assumes a TSX context for component development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_31\n\nLANGUAGE: tsx\nCODE:\n```\nimport type {\n  TextFieldDiffServerComponent,\n  TextFieldDiffClientComponent,\n  // And so on for each Field Type\n} from 'payload'\n```\n\n----------------------------------------\n\nTITLE: Installing Azure Blob Storage Adapter with Shell\nDESCRIPTION: Installs the Azure Blob Storage adapter for handling uploads to Azure within Payload CMS. The shell command requires \"pnpm\" and should be executed in the workspace root where your Payload project is located. Adds \"@payloadcms/storage-azure\" to your dependencies for further configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\npnpm add @payloadcms/storage-azure\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Icon in Payload Config - TypeScript\nDESCRIPTION: This snippet shows how to register a custom icon component for the Payload CMS admin by setting 'components.graphics.Icon' in the config. The value should be a path to a React component that renders the icon. Requires Payload and a valid icon component at the specified path. Input: config object; Output: Payload instance with a custom admin icon.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\\n\\nexport default buildConfig({\\n  // ...\\n  admin: {\\n    // highlight-start\\n    components: {\\n      graphics: {\\n        Icon: '/path/to/your/component',\\n      },\\n    },\\n    // highlight-end\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Securing Job Run Endpoint with Vercel Cron Secret (TypeScript)\nDESCRIPTION: This TypeScript configuration demonstrates how to secure the `/api/payload-jobs/run` endpoint in Payload CMS. It uses an access control function that authorizes either logged-in users or requests bearing the `CRON_SECRET` as a Bearer token in the header, supporting secure serverless cron executions. The dependencies include environment variable management and correct Payload CMS configuration. Input parameters are the incoming request and server environment. Outputs are boolean values granting or denying endpoint access.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/queues.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default buildConfig({\n  // Other configurations...\n  jobs: {\n    access: {\n      run: ({ req }: { req: PayloadRequest }): boolean => {\n        // Allow logged in users to execute this endpoint (default)\n        if (req.user) return true\n\n        // If there is no logged in user, then check\n        // for the Vercel Cron secret to be present as an\n        // Authorization header:\n        const authHeader = req.headers.get('authorization')\n        return authHeader === `Bearer ${process.env.CRON_SECRET}`\n      },\n    },\n    // Other job configurations...\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Adding the Payload Cloud Plugin to Payload Config (JavaScript)\nDESCRIPTION: This JavaScript snippet shows how to add the official Payload Cloud Plugin to your Payload CMS configuration, enabling integration with Payload Cloud services such as database, file storage, and email. Insert this code in your main configuration file (usually 'payload.config.js' or its TypeScript equivalent). The included dependencies are '@payloadcms/payload-cloud' and 'payload'. The plugins array in the exported configuration object is used to register the plugin, and other config options should follow standard Payload CMS practices. Run 'pnpm add @payloadcms/payload-cloud' beforehand to install the dependency.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/cloud/projects.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport { payloadCloudPlugin } from '@payloadcms/payload-cloud'\\nimport { buildConfig } from 'payload'\\n\\nexport default buildConfig({\\n  plugins: [payloadCloudPlugin()],\\n  // rest of config\\n})\n```\n\n----------------------------------------\n\nTITLE: Simple Before Nav Links React Component (TSX)\nDESCRIPTION: A basic function component for React that can be injected before the sidebar navigation links in Payload Admin, displaying a custom message. Register its path in beforeNavLinks in the Payload config. Best for banners or notices specific to navigation context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyBeforeNavLinksComponent() {\n  return <div>This is a custom component injected before the Nav links.</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Example Checkbox Field in a Payload Collection (TypeScript)\nDESCRIPTION: This snippet shows a practical example of using a Checkbox field within a Payload Collection configuration. It defines a collection named 'example-collection' with a single field 'enableCoolStuff' of type 'checkbox'. It includes optional properties like 'label' for the admin UI and 'defaultValue' set to false.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/checkbox.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const ExampleCollection: CollectionConfig = {\n  slug: 'example-collection',\n  fields: [\n    {\n      name: 'enableCoolStuff', // required\n      type: 'checkbox', // required\n      label: 'Click me to see fanciness',\n      defaultValue: false,\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing User Unlock Access Control in Payload CMS (TypeScript)\nDESCRIPTION: Defines an `unlock` access control function within a Payload CMS Collection configuration. This function determines if the currently logged-in user (`req.user`) has the necessary permissions to unlock other users who may be locked out due to excessive failed login attempts.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/access-control/collections.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionWithUnlockAccess: CollectionConfig = {\n  // ...\n  access: {\n    // highlight-start\n    unlock: ({ req: { user } }) => {\n      return Boolean(user)\n    },\n    // highlight-end\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing Admin Options for JSON Field (TypeScript)\nDESCRIPTION: This snippet shows how to customize the admin panel appearance and behavior for a JSON field in Payload by providing an 'admin' configuration object. It demonstrates extending the basic JSON field declaration with admin-specific options, allowing for further UI customization. Dependencies include the Payload CMS library and an understanding of the Admin Config API. The primary parameter is 'admin', where various options such as editor behavior can be set. Outputs a Field object with enhanced admin configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/json.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyJSONField: Field = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Importing TypeScript Types for Custom Description Components (TSX)\nDESCRIPTION: Shows how to import TypeScript types like `TextFieldDescriptionServerComponent` and `TextFieldDescriptionClientComponent` for custom Description components in Payload CMS. This aids in type-safe development for field descriptions across different field types and environments. Assumes a TSX context for component development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_27\n\nLANGUAGE: tsx\nCODE:\n```\nimport type {\n  TextFieldDescriptionServerComponent,\n  TextFieldDescriptionClientComponent,\n  // And so on for each Field Type\n} from 'payload'\n```\n\n----------------------------------------\n\nTITLE: Fetching Current User Data via REST API Response in TypeScript\nDESCRIPTION: Example JSON response from the `GET /api/[collection-slug]/me` REST endpoint. It returns the logged-in user's details (JWT payload), the authentication token, and the token's expiration timestamp.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  user: { // The JWT \"payload\" ;) from the logged in user\n    email: 'dev@payloadcms.com',\n    createdAt: \"2020-12-27T21:16:45.645Z\",\n    updatedAt: \"2021-01-02T18:37:41.588Z\",\n    id: \"5ae8f9bde69e394e717c8832\"\n  },\n  token: '34o4345324...', // The token that can be used to authenticate the user\n  exp: 1609619861, // Unix timestamp representing when the user's token will expire\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Payload Cloud Plugin Features (TypeScript)\nDESCRIPTION: Illustrates how to selectively disable specific features of the Payload Cloud plugin, such as file storage, email delivery, or upload caching. This is done by passing a configuration object with boolean flags set to `false` for the desired features to the `payloadCloudPlugin` function.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/payload-cloud/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\npayloadCloudPlugin({\n  storage: false, // Disable file storage\n  email: false, // Disable email delivery\n  uploadCaching: false, // Disable upload caching\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring beforeDocumentControls for a Global (TypeScript)\nDESCRIPTION: Illustrates how to inject custom components before the standard document action buttons in a Global's Edit View. The `admin.components.elements.beforeDocumentControls` property takes an array of paths to the custom components.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```\nexport const MyGlobal: GlobalConfig = {\n  admin: {\n    components: {\n      elements: {\n        // highlight-start\n        beforeDocumentControls: ['/path/to/CustomComponent'],\n        // highlight-end\n      },\n    },\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Allowing Iframe Embedding via Content Security Policy - Plaintext Directive\nDESCRIPTION: This plaintext snippet provides a CSP (Content Security Policy) directive allowing your frontend application to be loaded as an iframe by the Payload Admin Panel. Whitelist your app's domain by configuring frame-ancestors. Replace https://your-site.com with your actual domain as appropriate.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/server.mdx#_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\nframe-ancestors: \"self\" localhost:* https://your-site.com;\n```\n\n----------------------------------------\n\nTITLE: Converting Lexical to HTML Asynchronously with Payload Local API (Server)\nDESCRIPTION: Shows a server-side approach for asynchronous Lexical-to-HTML conversion using `convertLexicalToHTMLAsync` within a React Server Component (RSC) or similar server context. It utilizes `getPayloadPopulateFn` and the Payload Local API (`getPayload`) for efficient data population, avoiding multiple network requests. Requires access to the Payload configuration and instance.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-html.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\n\nimport { getPayloadPopulateFn } from '@payloadcms/richtext-lexical'\nimport { convertLexicalToHTMLAsync } from '@payloadcms/richtext-lexical/html-async'\nimport { getPayload } from 'payload'\nimport React from 'react'\n\nimport config from '../../config.js'\n\nexport const MyRSCComponent = async ({ // Note: This implies a Server Component context\n  data,\n}: {\n  data: SerializedEditorState\n}) => {\n  const payload = await getPayload({\n    config,\n  })\n\n  const html = await convertLexicalToHTMLAsync({\n    data,\n    populate: await getPayloadPopulateFn({\n      currentDepth: 0,\n      depth: 1,\n      payload,\n    }),\n  })\n\n  return html && <div dangerouslySetInnerHTML={{ __html: html }} />\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Constants in TypeScript Example\nDESCRIPTION: Demonstrates the declaration of numeric constants using `const` in TypeScript. This snippet appears as a standalone example within the documentation page, preceded by markdown text and bullet points related to query parameters.\nSOURCE: https://github.com/payloadcms/payload/blob/main/test/lexical-mdx/tests/restExamples.input.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nconst a = 1\nconst b = 2\nconst c = 3\nconst d = 4\n```\n```\n\n----------------------------------------\n\nTITLE: Retrieving Field-Specific Lexical Editor Config in a Payload Hook (TypeScript)\nDESCRIPTION: Provides a practical example within a Payload collection definition. It shows how to access a sibling rich text field (`richText`) inside an `afterRead` hook of another field (`text`), retrieve its specific editor configuration using `editorConfigFactory.fromField`, and potentially use it. Dependencies include types and functions from `payload` and `@payloadcms/richtext-lexical`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converters.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig, RichTextField } from 'payload'\n\nimport {\n  editorConfigFactory,\n  getEnabledNodes,\n  lexicalEditor,\n} from '@payloadcms/richtext-lexical'\n\nexport const MyCollection: CollectionConfig = {\n  slug: 'slug',\n  fields: [\n    {\n      name: 'text',\n      type: 'text',\n      hooks: {\n        afterRead: [\n          ({ siblingFields, value }) => {\n            const field: RichTextField = siblingFields.find(\n              (field) => 'name' in field && field.name === 'richText',\n            ) as RichTextField\n\n            const editorConfig = editorConfigFactory.fromField({\n              field,\n            })\n\n            // Now you can use the editor config\n\n            return value\n          },\n        ],\n      },\n    },\n    {\n      name: 'richText',\n      type: 'richText',\n      editor: lexicalEditor(),\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Programmatically Triggering Route Transitions with useRouteTransition\nDESCRIPTION: This TypeScript code snippet shows how to programmatically trigger route transitions when using `next/navigation`'s `useRouter`. It uses the `useRouteTransition` hook from `@payloadcms/ui` to get the `startRouteTransition` function, which wraps the `router.push` call to ensure the transition animation runs during navigation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_24\n\nLANGUAGE: ts\nCODE:\n```\n'use client'\nimport React, { useCallback } from 'react'\nimport { useTransition } from '@payloadcms/ui' // Note: Source text says useTransition, but hook name is useRouteTransition\nimport { useRouter } from 'next/navigation'\n\nconst MyComponent: React.FC = () => {\n  const router = useRouter()\n  const { startRouteTransition } = useRouteTransition() // Corrected based on section title\n\n  const redirectSomewhere = useCallback(() => {\n    startRouteTransition(() => router.push('/somewhere'))\n  }, [startRouteTransition, router])\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Custom Components Before the Dashboard (TypeScript)\nDESCRIPTION: Demonstrates how to use the beforeDashboard property within the admin.components configuration to inject one or more custom components before the built-in Dashboard UI. List paths as strings in an array, referencing your custom React components. This workflow assumes Payload CMS and allows pre-dashboard page augmentations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  admin: {\n    // highlight-start\n    components: {\n      beforeDashboard: ['/path/to/your/component'],\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Simple After Nav Links React Component (TSX)\nDESCRIPTION: Implements a minimal React component that renders a paragraph beneath the sidebar nav links in Payload Admin. Reference it in afterNavLinks config array. Useful for post-nav instructions, feedback, or notifications.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyAfterNavLinksComponent() {\n  return <p>This is a custom component injected after the Nav links.</p>\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Root Admin Components in Payload CMS (TypeScript)\nDESCRIPTION: Shows how to use the admin.components property in the Payload CMS buildConfig TypeScript API to register custom components that alter the root-level look and feel of the admin interface. Requires Payload CMS as a dependency; custom components are referenced via paths as strings in the configuration. Edit the components object within the admin property to list which custom React components to inject for specific extension points.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  admin: {\n    // highlight-start\n    components: {\n      // ...\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Description (Server Component) in Payload CMS\nDESCRIPTION: This snippet shows a custom React server component (`MyDescriptionComponent`) designed to replace the default description area in Payload CMS views (Edit and List). It renders a simple `div` element containing custom text, indicating it's a server-side component. It requires `react` and `payload` types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_22\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport type { ViewDescriptionServerProps } from 'payload'\n\nexport function MyDescriptionComponent(props: ViewDescriptionServerProps) {\n  return <div>This is a custom description component (Server)</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Admin Options for Code Field - TypeScript\nDESCRIPTION: Shows how to customize administrative settings for a Code Field by adding an 'admin' property to the Field object. Requires the 'payload' package and the Field type import. The 'admin' object allows overrides of UI behavior such as language and editor options within the Admin Panel. No functional code is shown, but the structure allows extension with additional admin properties.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/code.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyCodeField: Field = {\n  // ...\n  admin: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Cell Component in Payload Field (TypeScript)\nDESCRIPTION: Demonstrates configuring a custom `Cell` component for a 'text' field within Payload CMS. The `admin.components.Cell` property in the field definition is set to the path of the custom React component. This component replaces the default cell rendering in the List View table.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_22\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const myField: Field = {\n  name: 'myField',\n  type: 'text',\n  admin: {\n    components: {\n      Cell: '/path/to/MyCustomCellComponent', // highlight-line\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Next.js Rewrites for Domain-Based Tenant Routing\nDESCRIPTION: Provides a Next.js configuration snippet for the `rewrites` function within `next.config.js`. It sets up a rewrite rule that captures the host domain as `tenantDomain` using a `has` condition and maps incoming requests (excluding `/admin` and `/api` paths) to a `/[tenantDomain]/[slug]` route structure. This enables domain-based multi-tenancy where the domain determines the tenant context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/multi-tenant.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nasync rewrites() {\n  return [\n    {\n      source: '/((?!admin|api)):path*',\n      destination: '/:tenantDomain/:path*',\n      has: [\n        {\n          type: 'host',\n          value: '(?<tenantDomain>.*)',\n        },\n      ],\n    },\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Array Row Label Client Component in TSX\nDESCRIPTION: This snippet defines a custom React client component (`ArrayRowLabel`), marked with `'use client'`, designed to render a unique label for each row within a Payload CMS Array Field. It utilizes the `useRowLabel` hook from `@payloadcms/ui` to access the data of the current row (`data`, typed to expect an optional `title` property) and the row's index (`rowNumber`). It then constructs and returns a custom label string, incorporating the row's title (or 'Slide' if undefined) and a padded row number. Requires React and the `useRowLabel` hook from `@payloadcms/ui`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/array.mdx#_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\n\nimport { useRowLabel } from '@payloadcms/ui'\n\nexport const ArrayRowLabel = () => {\n  const { data, rowNumber } = useRowLabel<{ title?: string }>()\n\n  const customLabel = `${data.title || 'Slide'} ${String(rowNumber).padStart(2, '0')} `\n\n  return <div>Custom Label: {customLabel}</div>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Customizing Task Restoration Logic Based on Input in Payload CMS (TypeScript)\nDESCRIPTION: This example configures a Payload CMS task to determine restoration behavior dynamically using a function for `shouldRestore`. If the input's `someDate` field is in the future, the task is re-run; otherwise, previous outputs are restored. The task uses a typed input schema and a custom restore function within the `retries` object. Dependencies include Payload CMS with jobs/tasks support and valid TypeScript configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/tasks.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport default buildConfig({\n  // ...\n  jobs: {\n    tasks: [\n      {\n        slug: 'myTask',\n        inputSchema: [\n          {\n            name: 'someDate',\n            type: 'date',\n            required: true,\n          },\n        ],\n        retries: {\n          shouldRestore: ({ input }) => {\n            if (new Date(input.someDate) > new Date()) {\n              return false\n            }\n            return true\n          },\n        },\n        // ...\n      } as TaskConfig<'myTask'>,\n    ],\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Generated Types for User and Post Collections - Payload CMS - TypeScript\nDESCRIPTION: This code sample shows the TypeScript interfaces automatically generated for the 'User' and 'Post' collections from the given Payload config. Each field is appropriately typed and reflects optional vs required status; relationships are expanded to union types. The generated interfaces serve as strongly-typed representations of collection items.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/typescript/generating-types.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface User {\n  id: string\n  name: string\n  email?: string\n  resetPasswordToken?: string\n  resetPasswordExpiration?: string\n  loginAttempts?: number\n  lockUntil?: string\n}\n\nexport interface Post {\n  id: string\n  title?: string\n  author?: string | User\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Header in Payload Config - TypeScript\nDESCRIPTION: Shows how to add one or more custom header components above the admin header in Payload CMS by specifying 'components.Header' as an array of component paths. Requires that each path points to a React component. Dependency: Payload. Input: config object; Output: admin UI with custom header section(s).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\\n\\nexport default buildConfig({\\n  // ...\\n  admin: {\\n    // highlight-start\\n    components: {\\n      Header: ['/path/to/your/component'],\\n    },\\n    // highlight-end\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Nav in Payload Config - TypeScript\nDESCRIPTION: This snippet demonstrates how to specify a custom navigation component for the Payload CMS admin interface by setting the 'components.Nav' property in the config. It assumes a React component is exported at the specified path. Requires Payload as a dependency and an exportable React component at '/path/to/your/component'. The input is the standard Payload config object and the output is a fully configured Payload instance with custom navigation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\\n\\nexport default buildConfig({\\n  // ...\\n  admin: {\\n    // highlight-start\\n    components: {\\n      Nav: '/path/to/your/component',\\n    },\\n    // highlight-end\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Restoring Global Version using Payload Local API in JavaScript\nDESCRIPTION: This snippet illustrates how to restore a specific version of a global document using the Payload Local API. It requires the global slug and the version ID. Optional parameters for depth, user context, access override, and hidden field visibility are available. The function returns the restored global document.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/versions/overview.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Result will be the restored global document.\nconst result = await payload.restoreGlobalVersion({\n  slug: 'header', // required\n  id: '507f1f77bcf86cd799439013', // required\n  depth: 2,\n  user: dummyUser,\n  overrideAccess: false,\n  showHiddenFields: true,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Component using Object Configuration in Payload (TypeScript)\nDESCRIPTION: This TypeScript snippet illustrates configuring a custom component (logout button) in Payload `buildConfig` using an object instead of a string path. The object explicitly defines the component's `path` and `exportName`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    components: {\n      logout: {\n        // highlight-start\n        Button: {\n          path: '/src/components/Logout',\n          exportName: 'MyComponent',\n        },\n        // highlight-end\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom MDX Block with Lexical Editor and MDX Serialization in Payload - TypeScript\nDESCRIPTION: This advanced example defines a custom 'Banner' block with two fields (type, content) and configures MDX serialization/export/import using the jsx property. The snippet demonstrates how to use lexicalEditor with custom features, integrate BlocksFeature, implement serialization (lexical-to-MDX) via jsx.export, and implement parsing (MDX-to-lexical) via jsx.import. The block is then enabled within a Collection with a richtext field and corresponding Markdown conversion logic. Dependencies include @payloadcms/richtext-lexical, Payload types (Block, CollectionConfig, RichTextField), and a configured Payload environment. All key logic is commented for clarity.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converting-markdown.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { SerializedEditorState } from '@payloadcms/richtext-lexical/lexical'\nimport type { Block, CollectionConfig, RichTextField } from 'payload'\n\nimport {\n  BlocksFeature,\n  convertLexicalToMarkdown,\n  editorConfigFactory,\n  lexicalEditor,\n} from '@payloadcms/richtext-lexical'\n\nconst BannerBlock: Block = {\n  slug: 'Banner',\n  fields: [\n    {\n      name: 'type',\n      type: 'select',\n      defaultValue: 'info',\n      options: [\n        { label: 'Info', value: 'info' },\n        { label: 'Warning', value: 'warning' },\n        { label: 'Error', value: 'error' },\n      ],\n    },\n    {\n      name: 'content',\n      type: 'richText',\n      editor: lexicalEditor(),\n    },\n  ],\n  jsx: {\n    /**\n     * Convert from Lexical -> MDX:\n     * <Banner type=\"...\" >child content</Banner>\n     */\n    export: ({ fields, lexicalToMarkdown }) => {\n      const props: any = {}\n      if (fields.type) {\n        props.type = fields.type\n      }\n\n      return {\n        children: lexicalToMarkdown({ editorState: fields.content }),\n        props,\n      }\n    },\n    /**\n     * Convert from MDX -> Lexical:\n     */\n    import: ({ children, markdownToLexical, props }) => {\n      return {\n        type: props?.type,\n        content: markdownToLexical({ markdown: children }),\n      }\n    },\n  },\n}\n\nconst Pages: CollectionConfig = {\n  slug: 'pages',\n  fields: [\n    {\n      name: 'nameOfYourRichTextField',\n      type: 'richText',\n      editor: lexicalEditor({\n        features: ({ defaultFeatures }) => [\n          ...defaultFeatures,\n          BlocksFeature({\n            blocks: [BannerBlock],\n          }),\n        ],\n      }),\n    },\n    {\n      name: 'markdown',\n      type: 'textarea',\n      hooks: {\n        afterRead: [\n          ({ siblingData, siblingFields }) => {\n            const data: SerializedEditorState =\n              siblingData['nameOfYourRichTextField']\n\n            if (!data) {\n              return ''\n            }\n\n            const markdown = convertLexicalToMarkdown({\n              data,\n              editorConfig: editorConfigFactory.fromField({\n                field: siblingFields.find(\n                  (field) =>\n                    'name' in field && field.name === 'nameOfYourRichTextField',\n                ) as RichTextField,\n              }),\n            })\n\n            return markdown\n          },\n        ],\n        beforeChange: [\n          ({ siblingData }) => {\n            // Ensure that the markdown field is not saved in the database\n            delete siblingData['markdown']\n            return null\n          },\n        ],\n      },\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Client Feature with a Custom Plugin (TypeScript)\nDESCRIPTION: Demonstrates adding a custom Lexical plugin to a client feature. Similar to adding nodes, the `createClientFeature` function's configuration object takes a `plugins` array. This example includes `MyPlugin` (imported from './plugin'), which allows adding custom editor interactions or logic via React components within the Lexical context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/custom-features.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n'use client'\n\nimport { createClientFeature } from '@payloadcms/richtext-lexical/client'\nimport { MyPlugin } from './plugin'\n\nexport const MyClientFeature = createClientFeature({\n  plugins: [MyPlugin],\n})\n```\n\n----------------------------------------\n\nTITLE: Injecting Custom Components Before the Login Form (TypeScript)\nDESCRIPTION: Configures Payload Admin to show custom components before the login form, via beforeLogin property under admin.components in the buildConfig API. Insert one or more string paths to components as needed. This action requires Payload and allows tailored pre-login UI like messages or branding.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  admin: {\n    // highlight-start\n    components: {\n      beforeLogin: ['/path/to/your/component'],\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Live Preview Breakpoints in Payload CMS\nDESCRIPTION: This snippet demonstrates how to define custom breakpoints for the Live Preview window in Payload CMS. The `breakpoints` array within `admin.livePreview` accepts objects defining device sizes (`label`, `name`, `width`, `height`), which appear as options in the preview toolbar for resizing the iframe.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/overview.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    // ...\n    livePreview: {\n      url: 'http://localhost:3000',\n      // highlight-start\n      breakpoints: [\n        {\n          label: 'Mobile',\n          name: 'mobile',\n          width: 375,\n          height: 667,\n        },\n      ],\n      // highlight-end\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic defaultPriorities for Plugin in TypeScript\nDESCRIPTION: Demonstrates overriding the searchPlugin 'defaultPriorities' option using a TypeScript function to compute a priority dynamically based on document properties. Requires the Payload and @payloadcms/plugin-search packages as well as TypeScript support. The input is the config with a callback for 'pages' and a static value for 'posts'; the output dynamically computes priorities during search record creation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/search.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  searchPlugin({\n    defaultPriorities: {\n      pages: ({ doc }) => (doc.title.startsWith('Hello, world!') ? 1 : 10),\n      posts: 20,\n    },\n  }),\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom PreviewButton (Server Component) in Payload CMS\nDESCRIPTION: This snippet displays a custom React server component (`MyPreviewButton`) for the Preview button in Payload CMS. It utilizes the standard `PreviewButton` from `@payloadcms/ui` without modifications to its appearance or default behavior. This component executes on the server. It requires `react`, `@payloadcms/ui`, and `payload` types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { PreviewButton } from '@payloadcms/ui'\nimport type { PreviewButtonServerProps } from 'payload'\n\nexport function MyPreviewButton(props: PreviewButtonServerProps) {\n  return <PreviewButton />\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Component Placeholders in Payload Collection Config (TypeScript)\nDESCRIPTION: This snippet demonstrates the basic structure within a Payload `CollectionConfig` for specifying custom admin components. The `admin.components` object is nested within a field definition and serves as a container for overriding default UI elements.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionConfig: CollectionConfig = {\n  // ...\n  fields: [\n    // ...\n    {\n      // ...\n      admin: {\n        components: {\n          // highlight-line\n          // ...\n        },\n      },\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Retrieving Default Lexical Editor Config in TypeScript\nDESCRIPTION: Demonstrates how to obtain the default Lexical editor configuration using `editorConfigFactory.default`. Requires a Payload `SanitizedConfig` object passed as an argument.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converters.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst defaultEditorConfig = await editorConfigFactory.default({ config })\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom PublishButton in Payload Collection\nDESCRIPTION: This TypeScript snippet demonstrates how to configure a custom `PublishButton` component within a Payload CMS Collection configuration. It sets the path to the custom component file (`/path/to/MyPublishButton`) within the `admin.components.edit.PublishButton` property. This allows overriding the default publish button in the Edit View for this specific collection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      edit: {\n        // highlight-start\n        PublishButton: '/path/to/MyPublishButton',\n        // highlight-end\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Component Base Directory and Relative Path in Payload (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to configure a base directory (`admin.importMap.baseDir`) for resolving custom component paths in the Payload `buildConfig`. It then defines the logout button component using a path relative to this base directory, simplifying the reference.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\nimport { fileURLToPath } from 'node:url'\nimport path from 'path'\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    importMap: {\n      baseDir: path.resolve(dirname, 'src'), // highlight-line\n    },\n    components: {\n      logout: {\n        Button: '/components/Logout#MyComponent', // highlight-line\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Relationship Field Sort Options - PayloadCMS - TypeScript\nDESCRIPTION: This snippet sets the 'sortOptions' property on a relationship field to a string, which globally determines the sorting field for the dropdown in the admin panel. This method requires no additional dependencies and is added directly inside the field configuration object. The string value defines the field name; prepend with '-' to indicate descending order. Only one global sort field can be set using this approach.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nsortOptions: 'fieldName',\n```\n\n----------------------------------------\n\nTITLE: Using Payload SCSS Library and Mixins (SCSS)\nDESCRIPTION: This SCSS code shows how to import Payload's SCSS library (`@import '~@payloadcms/ui/scss';`). It then uses a built-in mixin (`mid-break`) to apply responsive styles, changing the background color based on screen size using a theme variable.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_20\n\nLANGUAGE: scss\nCODE:\n```\n@import '~@payloadcms/ui/scss';\n\n.my-component {\n  @include mid-break {\n    background-color: var(--theme-elevation-900);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Allowed Field Types for the Form Builder Plugin (TypeScript)\nDESCRIPTION: Shows how to specify which field types are available in the form builder via the fields property in plugin options. Each key corresponds to a field slug; values indicate enable/disable or can provide a custom field block. Dependencies include correct configuration of PayloadCMS and plugin import. Inputs are the desired field keys; output is plugin behavior upon form construction.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nformBuilderPlugin({\n  // ...\n  fields: {\n    text: true,\n    textarea: true,\n    select: true,\n    email: true,\n    state: true,\n    country: true,\n    checkbox: true,\n    number: true,\n    message: true,\n    payment: false,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Lexical Editor with Slate-to-Lexical Feature in TypeScript\nDESCRIPTION: This code defines a Payload CMS Collection (`Pages`) with a `richText` field configured to use the `lexicalEditor`. It demonstrates how to add the `SlateToLexicalFeature` from `@payloadcms/richtext-lexical/migrate` to the editor's features array. This feature enables the Lexical editor to automatically convert legacy Slate JSON data to the Lexical format on-the-fly when the editor is initialized in the Admin Panel, providing a gradual migration path.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/migration.mdx#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nimport { SlateToLexicalFeature } from '@payloadcms/richtext-lexical/migrate'\nimport { lexicalEditor } from '@payloadcms/richtext-lexical'\n\nconst Pages: CollectionConfig = {\n  slug: 'pages',\n  fields: [\n    {\n      name: 'nameOfYourRichTextField',\n      type: 'richText',\n      editor: lexicalEditor({\n        features: ({ defaultFeatures }) => [\n          ...defaultFeatures,\n          SlateToLexicalFeature({}),\n        ],\n      }),\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Payload Example Project with npx - Shell\nDESCRIPTION: This snippet shows how to generate a new Payload application using a specific example with create-payload-app and the --example flag. Requires Node.js and npm, and the named example should match an existing one in the Payload Examples Directory. The command clones example files, configures dependencies, and prepares a project folder for immediate development. Input parameter is the example_name, and output is the initialized project set up to mirror the chosen example.\nSOURCE: https://github.com/payloadcms/payload/blob/main/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpx create-payload-app --example example_name\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Logout Button in Payload Config - TypeScript\nDESCRIPTION: Demonstrates how to register a custom logout button for the Payload CMS admin by setting 'components.logout.Button' in the Payload config. The specified value must be a path to a React component implementing the button. Dependency: Payload. Input: config object; Output: custom logout button in UI.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\\n\\nexport default buildConfig({\\n  // ...\\n  admin: {\\n    // highlight-start\\n    components: {\\n      logout: {\\n        Button: '/path/to/your/component',\\n      },\\n    },\\n    // highlight-end\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Docker Compose Service Configuration - yaml\nDESCRIPTION: References the existence of a docker-compose.yml file used to define services (primarily MongoDB) for running Payload CMS in Docker. The snippet itself is described, but not shown. For correct operation, ensure that both your .env file and docker-compose.yml reference the same MONGODB_URI and that Docker is properly installed. Used as part of the local development flow with or without running Docker in detached mode (-d).\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/with-vercel-mongodb/README.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n# docker-compose.yml (not shown)\n# Defines MongoDB service configuration for development\n# Ensure MONGODB_URI is consistent between .env and this file\n```\n\n----------------------------------------\n\nTITLE: Configuring Collection-Level Metadata in Payload (TypeScript)\nDESCRIPTION: Demonstrates embedding collection-specific metadata in a Payload collection via the 'admin.meta' object. Uses TypeScript and requires the CollectionConfig type import. Allows per-collection settings for titles, descriptions, and Next.js metadata, impacting all admin panel views for the collection unless individually overridden.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/metadata.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    // highlight-start\n    meta: {\n      // highlight-end\n      title: 'My Collection',\n      description: 'The best collection in the world',\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Using the useTenantSelection Hook in React Components\nDESCRIPTION: Demonstrates how to import and utilize the `useTenantSelection` hook from `@payloadcms/plugin-multi-tenant/client` within a React (TSX) component. This hook provides access to the tenant selection state and functions, allowing custom components to interact with the multi-tenant context managed by the plugin.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/multi-tenant.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useTenantSelection } from '@payloadcms/plugin-multi-tenant/client'\n\n...\n\nconst tenantContext = useTenantSelection()\n```\n\n----------------------------------------\n\nTITLE: Advanced Sentry Plugin Configuration in Payload\nDESCRIPTION: This TypeScript code demonstrates configuring advanced options for the Payload Sentry plugin. It includes setting specific HTTP error codes (`captureErrors`) to be tracked by Sentry, adding custom contextual data (`context`) like the request locale to error reports, and enabling debug mode. The required `Sentry` instance is also passed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/sentry.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\nimport { sentryPlugin } from '@payloadcms/plugin-sentry'\n\nimport * as Sentry from '@sentry/nextjs'\n\nimport { Pages, Media } from './collections'\n\nconst config = buildConfig({\n  collections: [Pages, Media],\n  plugins: [\n    sentryPlugin({\n      options: {\n        captureErrors: [400, 403],\n        context: ({ defaultContext, req }) => {\n          return {\n            ...defaultContext,\n            tags: {\n              locale: req.locale,\n            },\n          }\n        },\n        debug: true,\n      },\n      Sentry,\n    }),\n  ],\n})\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom React Context Provider in TSX\nDESCRIPTION: This TSX snippet shows how to implement a custom React Context provider for use in the Payload admin interface. The provider is built as a Client Component (with the 'use client' directive required for Next.js and React server/client boundaries). It defines the context, provider component accepting children as props, and a custom hook to access the context. Dependencies include React and a defined context value variable. Inputs: children React nodes; Output: context-wrapped subtree. The provider must not include server-only code and is intended for client-side use only.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-providers.mdx#_snippet_1\n\nLANGUAGE: TSX\nCODE:\n```\n'use client'\nimport React, { createContext, use } from 'react'\n\nconst MyCustomContext = React.createContext(myCustomValue)\n\nexport function MyProvider({ children }: { children: React.ReactNode }) {\n  return <MyCustomContext value={myCustomValue}>{children}</MyCustomContext>\n}\n\nexport const useMyCustomContext = () => use(MyCustomContext)\n```\n\n----------------------------------------\n\nTITLE: Configuring Nodemailer Adapter for Development (TypeScript)\nDESCRIPTION: This snippet demonstrates configuring the Payload email adapter for development by calling `nodemailerAdapter()` without any arguments. This setup automatically uses the ethereal.email service for testing emails, logging the necessary credentials to the console upon application startup. Requires the `@payloadcms/email-nodemailer` dependency.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/email-nodemailer/README.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { nodemailerAdapter } from '@payloadcms/email-nodemailer'\n\nexport default buildConfig({\n  email: nodemailerAdapter(), // This will be the old ethereal.email functionality\n})\n```\n\n----------------------------------------\n\nTITLE: Manually Adding and Customizing the Tenants Array Field (TypeScript)\nDESCRIPTION: Shows how to manually define and integrate the tenants array field into a Payload `users` collection configuration, allowing for customization and specific placement. It imports the `tenantsArrayField` helper from the plugin, customizes it (e.g., adding access control or row fields), and then spreads its properties into the collection's fields array, potentially overriding properties like the label. This requires setting `tenantsArrayField.includeDefaultField: false` in the plugin configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-multi-tenant/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\nimport { tenantsArrayField } from '@payloadcms/plugin-multi-tenant/fields'\n\nconst customTenantsArrayField = tenantsArrayField({\n  arrayFieldAccess: {}, // access control for the array field\n  tenantFieldAccess: {}, // access control for the tenants field on the array row\n  rowFields: [], // additional row fields\n})\n\nexport const UsersCollection: CollectionConfig = {\n  slug: 'users',\n  fields: [\n    {\n      ...customTenantsArrayField,\n      label: 'Associated Tenants',\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Logout Button Component - React TSX\nDESCRIPTION: Defines a basic React component rendering a button that, when clicked, displays an alert indicating logout. Intended for use as a custom logout button in the Payload admin panel. Accepts no input props. Output: button element with click handler. Use this in your config to override the default logout UI.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_24\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyCustomLogoutButton() {\\n  return <button onClick={() => alert('Logging out!')}>Log Out</button>\\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the App in Production Mode - npm - Shell Script\nDESCRIPTION: This snippet provides the command to launch the Remix application in production mode with npm, after the build process is complete. It assumes that the 'start' script is set up in package.json and that the application has already been built. When executed, the command runs the compiled app from the build output, serving files for production traffic. No arguments are required; all configuration is assumed to be handled previously.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/remix/website/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to S3 Emulator (Shell)\nDESCRIPTION: Navigates the command line interface into the directory containing the Docker configuration for the S3 (LocalStack) emulator (`./src/adapters/s3/emulator`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ncd ./src/adapters/s3/emulator\n```\n\n----------------------------------------\n\nTITLE: Enabling Auto-Login for Local Development - TypeScript\nDESCRIPTION: Demonstrates how to enable auto-login in Payload's buildConfig for development or testing. The 'autoLogin' property is conditionally set based on an environment variable, pre-filling login credentials in the UI. This approach requires TypeScript, Payload CMS, and the use of environment variables to prevent accidental use in production. The 'prefillOnly' flag allows credentials to be pre-filled without automatic submission.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/overview.mdx#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\\n\\nexport default buildConfig({\\n  // ...\\n  // highlight-start\\n  autoLogin:\\n    process.env.NEXT_PUBLIC_ENABLE_AUTOLOGIN === 'true'\\n      ? {\\n          email: 'test@example.com',\\n          password: 'test',\\n          prefillOnly: true,\\n        }\\n      : false,\\n  // highlight-end\\n})\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Providers with Payload Config in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to register your own custom React Context provider within the Payload CMS admin by modifying the Payload configuration file. You need to import buildConfig from 'payload' and specify the provider file paths using the admin.components.providers property. The configuration expects paths to modules exporting your provider components. The output is an exported Payload config setup; any misconfigured paths will cause build/runtime errors.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/custom-providers.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  admin: {\n    components: {\n      providers: ['/path/to/MyProvider'], // highlight-line\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Example Document Data for Polymorphic One-to-One Relationship - PayloadCMS - JSON\nDESCRIPTION: This JSON object demonstrates the saved data format for a polymorphic relationship field in PayloadCMS. The 'owner' property is an object with 'relationTo' indicating the collection slug and 'value' containing the referenced document's ObjectID. This representation is used when relationTo is an array and hasMany is false.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_8\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"owner\": {\n    \"relationTo\": \"organizations\",\n    \"value\": \"6031ac9e1289176380734024\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Logout Button React Client Component (TSX)\nDESCRIPTION: Provides a React client component (`LogoutButton`) that renders a button. Clicking the button triggers the `logoutAction` server function to log the user out. Requires the `logoutAction` server function defined elsewhere (e.g., `../logoutAction`). Note: The original example code calls `logoutFunction()`, which is likely a typo and should be `logoutAction()`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\n\nimport { logoutAction } from '../logoutAction' // Path to the server action\n\nexport default function LogoutButton() {\n  const handleLogout = async () => {\n    try {\n      await logoutAction();\n      // Handle successful logout (e.g., redirect to login page)\n    } catch (error) {\n      // Handle logout error\n      console.error(error);\n    }\n  };\n\n  return <button onClick={handleLogout}>Logout</button>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Payment Calculation Utility from Form Builder Plugin (TypeScript)\nDESCRIPTION: Imports getPaymentTotal from the plugin, which is required for calculating payment totals on form submissions where payment is enabled. Input is the correct calculation parameters (base price, price conditions, form field values). Used as a utility within handlePayment hooks for payment processing.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nimport { getPaymentTotal } from '@payloadcms/plugin-form-builder'\n```\n\n----------------------------------------\n\nTITLE: Using Spread Syntax to Extend Payload Config Arrays (JavaScript/TypeScript)\nDESCRIPTION: Demonstrates using spread syntax (ES6) to safely extend arrays in the Payload configuration, such as collections, globals, or any array properties. Ensures existing array items are retained while adding new ones. Applicable in both JavaScript and TypeScript in the context of Payload CMS plugin development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconfig.collections = [\n  ...(config.collections || []),\n newCollection,\n  // Add additional collections here\n]\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconfig.globals = [\n  ...(config.globals || []),\n  // Add additional globals here\n]\n\nconfig.hooks = {\n  ...(config.hooks || {}),\n  // Add additional hooks here\n}\n```\n\n----------------------------------------\n\nTITLE: Importing the Core GraphQL Package Type for Typing (TypeScript)\nDESCRIPTION: Shows how to import the `GraphQL` type definition directly from the Payload GraphQL package. This is primarily useful for type hinting and ensuring consistency with the GraphQL version used internally by Payload, rather than for direct use in runtime logic for queries/mutations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/extending.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { GraphQL } from '@payloadcms/graphql/types'\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Types for Custom Payload CMS Translations\nDESCRIPTION: Creates a dedicated TypeScript file (`custom-translations.ts`) to define custom translation strings and associated types. It defines a `customTranslations` object containing the new strings and exports types (`CustomTranslationsObject`, `CustomTranslationsKeys`) that merge these custom definitions with Payload's default translation types for enhanced type safety.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/i18n.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// <rootDir>/custom-translations.ts\n\nimport { enTranslations } from '@payloadcms/translations/languages/en'\nimport type { NestedKeysStripped } from '@payloadcms/translations'\n\nexport const customTranslations = {\n  en: {\n    general: {\n      myCustomKey: 'My custom english translation',\n    },\n    fields: {\n      addLabel: 'Add!',\n    },\n  },\n}\n\nexport type CustomTranslationsObject = typeof customTranslations.en &\n  typeof enTranslations\nexport type CustomTranslationsKeys =\n  NestedKeysStripped<CustomTranslationsObject>\n```\n\n----------------------------------------\n\nTITLE: Customizing Verification Email Subject in Payload CMS (TypeScript)\nDESCRIPTION: This snippet customizes the email subject for verification emails sent by Payload CMS using the `generateEmailSubject` function within a collection configuration. The function receives `req` and `user`, and returns a string for use as the email subject. This configuration is useful for branding or localization and applies when sending verification emails for account activation. Requires Payload CMS and TypeScript support.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/email.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Customers: CollectionConfig = {\n  // ...\n  auth: {\n    verify: {\n      // highlight-start\n      generateEmailSubject: ({ req, user }) => {\n        return `Hey ${user.email}, reset your password!`\n      },\n      // highlight-end\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Collapsible Field in Payload CMS (TypeScript)\nDESCRIPTION: This snippet shows the fundamental structure for defining a Collapsible Field within a Payload CMS configuration. It highlights setting the `type` property to 'collapsible' and including a `fields` array to nest other fields within the collapsible component. Requires the `Field` type from the `payload` package.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/collapsible.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n\nexport const MyCollapsibleField: Field = {\n  // ...\n  // highlight-start\n  type: 'collapsible',\n  fields: [\n    // ...\n  ],\n  // highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Examining Standard Join Field Data Structure in JSON\nDESCRIPTION: Illustrates the JSON object structure returned by a standard PayloadCMS Join Field when populated with related documents. It includes a `docs` array containing the related documents (or only their IDs if the query depth limit is reached), a boolean `hasNextPage` indicating if more related documents exist beyond the current limit, and an optional `totalDocs` field which appears only if `count: true` is specified in the query.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/join.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"66e3431a3f23e684075aae9c\",\n  \"relatedPosts\": {\n    \"docs\": [\n      {\n        \"id\": \"66e3431a3f23e684075aaeb9\",\n        // other fields...\n        \"category\": \"66e3431a3f23e684075aae9c\"\n      }\n      // { ... }\n    ],\n    \"hasNextPage\": false,\n    \"totalDocs\": 10 // if count: true is passed\n  }\n  // other fields...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing TypeScript Types for Custom Error Components (TSX)\nDESCRIPTION: Illustrates importing specific TypeScript types such as `TextFieldErrorServerComponent` and `TextFieldErrorClientComponent` for custom Error components in Payload CMS, ensuring type safety during development. Assumes a TSX context for component development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_29\n\nLANGUAGE: tsx\nCODE:\n```\nimport type {\n  TextFieldErrorServerComponent,\n  TextFieldErrorClientComponent,\n  // And so on for each Field Type\n} from 'payload'\n```\n\n----------------------------------------\n\nTITLE: Creating PayloadCMS Database Migrations - Bash\nDESCRIPTION: This Bash command generates migration files for the PayloadCMS project when using a Postgres database. Requires that PayloadCMS is installed and configured, with the correct database connection in place. The generated migration files are used to update and manage the SQL schema in a consistent and version-controlled manner. Run this command locally before deploying changes that impact the database schema.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/with-vercel-website/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm payload migrate:create\n\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Document Updates with useDocumentEvents in React\nDESCRIPTION: This React component demonstrates using the `useDocumentEvents` hook from `@payloadcms/ui` to subscribe to cross-document update events. It accesses the `mostRecentUpdate` property from the hook, which contains details about the last updated document (slug, id, updatedAt), and renders it as a JSON string.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport { useDocumentEvents } from '@payloadcms/ui'\n\nconst ListenForUpdates: React.FC = () => {\n  const { mostRecentUpdate } = useDocumentEvents()\n\n  return <span>{JSON.stringify(mostRecentUpdate)}</span>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Slate Node Converter for Lexical Migration in TypeScript\nDESCRIPTION: This snippet illustrates how to create a custom converter for migrating non-standard Slate nodes to the Lexical format. It defines `SlateUploadConverter` implementing the `SlateNodeConverter` interface from `@payloadcms/richtext-lexical`. The `converter` function receives a Slate node (`slateNode`) and transforms its properties into the structure expected by the corresponding Lexical node (`SerializedUploadNode`), specifically for an 'upload' type node in this example. The `nodeTypes` array indicates that this converter applies to Slate nodes of type 'upload'.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/migration.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport type { SerializedUploadNode } from '../uploadNode'\nimport type { SlateNodeConverter } from '@payloadcms/richtext-lexical'\n\nexport const SlateUploadConverter: SlateNodeConverter = {\n  converter({ slateNode }) {\n    return {\n      fields: {\n        ...slateNode.fields,\n      },\n      format: '',\n      relationTo: slateNode.relationTo,\n      type: 'upload',\n      value: {\n        id: slateNode.value?.id || '',\n      },\n      version: 1,\n    } as const as SerializedUploadNode\n  },\n  nodeTypes: ['upload'],\n}\n```\n\n----------------------------------------\n\nTITLE: Using useTranslation Hook for i18n in a Client Component (TSX)\nDESCRIPTION: This snippet demonstrates internationalization (i18n) within a Payload Client Component (`'use client'`). It uses the `useTranslation` hook from `@payloadcms/ui` to get the translation function `t` and the `i18n` instance, enabling translation of keys within specific namespaces.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { useTranslation } from '@payloadcms/ui'\n\nexport function MyClientComponent() {\n  const { t, i18n } = useTranslation() // highlight-line\n\n  return (\n    <ul>\n      <li>{t('namespace1:key', { variable: 'value' })}</li>\n      <li>{t('namespace2:key', { variable: 'value' })}</li>\n      <li>{i18n.language}</li>\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload with Vercel Blob Storage - TypeScript\nDESCRIPTION: This snippet shows how to configure Payload CMS to use Vercel's blob storage for managing uploaded media. It is placed in 'payload.config.ts'. Dependencies: '@payloadcms/storage-vercel-blob', valid token in process.env.BLOB_READ_WRITE_TOKEN, and a collection identifier (e.g., Media.slug). The plugin is registered in the 'plugins' array, configuring collections and authentication.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/website/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nimport { vercelBlobStorage } from '@payloadcms/storage-vercel-blob'\n\nexport default buildConfig({\n  // ...\n  plugins: [\n    vercelBlobStorage({\n      collections: {\n        [Media.slug]: true,\n      },\n      token: process.env.BLOB_READ_WRITE_TOKEN || '',\n    }),\n  ],\n  // ...\n```\n\n----------------------------------------\n\nTITLE: Default Admin Login Credentials (Text)\nDESCRIPTION: Provides the default email and password (demo@payloadcms.com / demo) for accessing the admin panel of the seeded example project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/custom-components/README.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nEmail: demo@payloadcms.com\nPassword: demo\n```\n\n----------------------------------------\n\nTITLE: Configuring Local Hosts File for Domain-Based Tenant Testing\nDESCRIPTION: This configuration adds entries to the system's hosts file (typically `/etc/hosts` on Linux/macOS or `C:\\Windows\\System32\\drivers\\etc\\hosts` on Windows). It maps the domains `gold.localhost`, `silver.localhost`, and `bronze.localhost` to the local machine's loopback address (127.0.0.1), enabling testing of the domain-based tenant selection feature during local development. Modifying this file usually requires administrative privileges.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/multi-tenant/README.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n127.0.0.1 gold.localhost silver.localhost bronze.localhost\n```\n\n----------------------------------------\n\nTITLE: Configuring Admin Options for an Email Field in Payload CMS (TypeScript)\nDESCRIPTION: This snippet demonstrates how to add admin-specific configurations to an Email field using the `admin` property within the field definition. This allows customization of the field's appearance and behavior within the Payload Admin Panel, such as setting a placeholder or autocomplete behavior.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/email.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Field } from 'payload'\n\nexport const MyEmailField: Field = {\n  // ...\n  admin: { // highlight-line\n    // ...\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Autosave Interval for Responsive Previews - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to configure the autosave interval in a PayloadCMS collection to make live preview updates feel more responsive. Lowering the interval value (in milliseconds) increases the autosave frequency, which can make route refreshes occur faster. Place the provided configuration in your collection.ts definition, under versions.drafts.autosave.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/server.mdx#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\n// collection.ts\n{\n   versions: {\n    drafts: {\n      autosave: {\n        interval: 375,\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Custom GraphQL JSON Types from Payload (TypeScript)\nDESCRIPTION: Illustrates how to import the `GraphQLJSON` and `GraphQLJSONObject` scalar types provided by the Payload GraphQL package. These types are useful for handling arbitrary JSON data within your custom GraphQL schema.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/extending.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { GraphQLJSON, GraphQLJSONObject } from '@payloadcms/graphql/types'\n```\n\n----------------------------------------\n\nTITLE: Customizing Radio Field Admin UI Options in Payload CMS (TypeScript)\nDESCRIPTION: This snippet illustrates how to extend the radio field configuration in Payload CMS with 'admin' UI options using TypeScript. By assigning an 'admin' object, developers can control presentation-specific behaviors, such as layout of the radio inputs in the CMS admin panel. This code is intended to be merged with core field definitions and assumes the surrounding code initializes Payload and its fields according to the project schema.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/radio.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Field } from 'payload'\\n\\nexport const MyRadioField: Field = {\\n  // ...\\n  admin: {\\n    // highlight-line\\n    // ...\\n  },\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Forgot Password Email Subject in Payload CMS (TypeScript)\nDESCRIPTION: This snippet shows how to customize the subject of the forgot password email via the `generateEmailSubject` function in the Payload CMS collection config. The function receives `req` and `user` and returns a string to be used as the email subject. It allows developers to provide a branded or user-specific subject line for password reset emails. Requires Payload CMS project and access to the user object in the callback.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/email.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\n\nexport const Customers: CollectionConfig = {\n  // ...\n  auth: {\n    forgotPassword: {\n      // highlight-start\n      generateEmailSubject: ({ req, user }) => {\n        return `Hey ${user.email}, reset your password!`\n      },\n      // highlight-end\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Global Hooks in Payload CMS with TypeScript\nDESCRIPTION: This snippet demonstrates the basic setup for attaching hooks to a Payload CMS global configuration in TypeScript. It shows how to use the 'hooks' property of a GlobalConfig object to define hook logic. Dependencies include the 'payload' package and appropriate TypeScript types. The snippet is a scaffold for attaching custom lifecycle hooks to global documents; all hook arrays are left open for custom user logic.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/globals.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { GlobalConfig } from 'payload'\n\nexport const GlobalWithHooks: GlobalConfig = {\n  // ...\n  hooks: {\n    // highlight-line\n    // ...\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server - Bash\nDESCRIPTION: This snippet provides alternate commands (for pnpm, yarn, or npm users) to launch the Payload CMS development server locally. The command will seed the database upon confirmation. Output is a running development server available on localhost with live updates for changes in the ./src directory. Dependencies: All dependencies should already be installed within the project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/tailwind-shadcn-ui/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn dev\n```\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Running Development Server with pnpm - Bash\nDESCRIPTION: This snippet shows the commands to install dependencies using pnpm and start the development server for the Payload CMS starter template. Requires pnpm installed globally, all Node.js dependencies defined in package.json, and a properly set up .env file. 'pnpm install' prepares the project, and 'pnpm dev' launches the dev server at http://localhost:3000 for local development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/with-vercel-mongodb/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install && pnpm dev\n```\n\n----------------------------------------\n\nTITLE: Creating a Payload Project from the Live Preview Example (Bash)\nDESCRIPTION: This command uses `npx` to execute `create-payload-app`, bootstrapping a new Payload CMS project based on the official 'live-preview' example template from the Payload repository.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-payload-app --example live-preview\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Description (Client Component) in Payload CMS\nDESCRIPTION: This snippet presents a custom React client component (`MyDescriptionComponent`) for the description area in Payload CMS views, marked with `'use client'`. It renders a `div` with custom text, specifying it's a client-side implementation. It depends on `react` and `payload` types.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_23\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport type { ViewDescriptionClientProps } from 'payload'\n\nexport function MyDescriptionComponent(props: ViewDescriptionClientProps) {\n  return <div>This is a custom description component (Client)</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Dependencies to Payload Import Map (TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to add custom dependencies, like components, directly to the Payload Import Map using the `admin.dependencies` object in `buildConfig`. This is useful for ensuring specific imports are available, especially within plugins, and allows specifying path, type, and props.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  admin: {\n    // ...\n    dependencies: {\n      myTestComponent: {\n        // myTestComponent is the key - can be anything\n        path: '/components/TestComponent.js#TestComponent',\n        type: 'component',\n        clientProps: {\n          test: 'hello',\n        },\n      },\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Importing and Using PayloadAdminBar in React - JSX\nDESCRIPTION: This code demonstrates basic integration of the PayloadAdminBar React component into an application. It shows how to import the component from the @payloadcms/admin-bar package and render it with the required props: cmsURL, collection, and id. Requires React and the @payloadcms/admin-bar package; the component expects the CMS endpoint, the collection type, and the document id as key parameters.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/admin-bar/README.md#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { PayloadAdminBar } from '@payloadcms/admin-bar'\n\nexport const App = () => {\n  return <PayloadAdminBar cmsURL=\"https://cms.website.com\" collection=\"pages\" id=\"12345\" />\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Field Label Server Component - React with Payload - TypeScript\nDESCRIPTION: Implements a server-rendered custom field label component for Payload CMS using React and TypeScript. Uses the FieldLabel from @payloadcms/ui and accepts clientField, path, and required status as props. The component selects the label from the field or falls back to the field name, ensuring proper labeling and requirement enforcement. Depends on React, @payloadcms/ui, and Payload types, specifically for server rendering fields on the admin UI.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/text.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\\nimport { FieldLabel } from '@payloadcms/ui'\\nimport type { TextFieldLabelServerComponent } from 'payload'\\n\\nexport const CustomTextFieldLabelServer: TextFieldLabelServerComponent = ({\\n  clientField,\\n  path,\\n  required,\\n}) => {\\n  return (\\n    <FieldLabel\\n      label={clientField?.label || clientField?.name}\\n      path={path}\\n      required={clientField?.required}\\n    />\\n  )\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Customizing Meta Fields with Additional Fields - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to extend the default SEO meta fields within the plugin configuration. The fields option accepts a function that receives defaultFields and returns a modified array, supporting both modification and addition of new fields such as a customField of type text. This pattern allows granular control over the meta object structure, dependent on the Payload config TypeScript interface and the @payloadcms/plugin-seo package.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\n{\n  // ...\n  seoPlugin({\n    fields: ({ defaultFields }) => [\n      ...defaultFields,\n      {\n        name: 'customField',\n        type: 'text',\n      },\n    ],\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Slate Editor Per Field in Collection - Payload CMS - TypeScript\nDESCRIPTION: Shows how to enable and customize the legacy Slate rich text editor for a specific field within a collection. Imports CollectionConfig and slateEditor, then defines a field of type 'richText' where the editor property is set to the result of slateEditor(), with admin options to customize allowed elements and leaves. Requires understanding Payload field configuration and the @payloadcms/richtext-slate dependency. Supports adding custom SlateJS elements and leaves via arrays/objects.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/slate.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CollectionConfig } from 'payload'\nimport { slateEditor } from '@payloadcms/richtext-slate'\n\nexport const Pages: CollectionConfig = {\n  slug: 'pages',\n  fields: [\n    {\n      name: 'content',\n      type: 'richText',\n      // Pass the Slate editor here and configure it accordingly\n      editor: slateEditor({\n        admin: {\n          elements: [\n            // customize elements allowed in Slate editor here\n          ],\n          leaves: [\n            // customize leaves allowed in Slate editor here\n          ],\n        },\n      }),\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a Default Recipient Email Address for Form Plugin (TypeScript)\nDESCRIPTION: Demonstrates providing a fallback defaultToEmail address in the plugin config. Used if the form's to value is unset; otherwise, payload email config defaultFromAddress is used. Ensures submissions always have a recipient. Only inputs are configuration string values.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nformBuilderPlugin({\n  // ...\n  defaultToEmail: 'test@example.com',\n})\n```\n\n----------------------------------------\n\nTITLE: Overriding the Forms Collection in Form Builder Plugin (TypeScript)\nDESCRIPTION: Shows how to override the default forms collection using formOverrides with a custom Payload Collection Config. Demonstrates restricting read access to authenticated users and disabling update. The fields property receives defaultFields and appends a custom text field. Requires familiarity with Payload access control and collections.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nformBuilderPlugin({\n  // ...\n  formOverrides: {\n    slug: 'contact-forms',\n    access: {\n      read: ({ req: { user } }) => !!user, // authenticated users only\n      update: () => false,\n    },\n    fields: ({ defaultFields }) => {\n      return [\n        ...defaultFields,\n        {\n          name: 'custom',\n          type: 'text',\n        },\n      ]\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Retrieving User Access Permissions via REST API Response in TypeScript\nDESCRIPTION: Example JSON response structure from the `GET /api/access` REST endpoint. It details the permissions (create, read, update, delete) a logged-in user has for different collections and their fields, including admin access status.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  canAccessAdmin: true,\n  collections: {\n    pages: {\n      create: {\n        permission: true,\n      },\n      read: {\n        permission: true,\n      },\n      update: {\n        permission: true,\n      },\n      delete: {\n        permission: true,\n      },\n      fields: {\n        title: {\n          create: {\n            permission: true,\n          },\n          read: {\n            permission: true,\n          },\n          update: {\n            permission: true,\n          },\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Checkbox Field Label Server Component (React/TSX)\nDESCRIPTION: This snippet shows how to create a custom React Server Component for rendering the label associated with a Checkbox field in the Payload admin UI. It imports and uses the 'FieldLabel' component from '@payloadcms/ui', passing the field's label (or name as fallback), path, and required status. This allows customizing the server-rendered label.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/checkbox.mdx#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { CheckboxFieldLabelServerComponent } from 'payload'\n\nexport const CustomCheckboxFieldLabelServer: CheckboxFieldLabelServerComponent =\n  ({ clientField, path }) => {\n    return (\n      <FieldLabel\n        label={clientField?.label || clientField?.name}\n        path={path}\n        required={clientField?.required}\n      />\n    )\n  }\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Admin Thumbnail via Image Size Name in Payload CMS TypeScript\nDESCRIPTION: This configuration snippet demonstrates setting the admin panel thumbnail for an upload-enabled collection by referencing the name of a defined image size. By setting 'adminThumbnail' to 'small', Payload will use the image generated for the 'small' size defined in 'imageSizes' as the thumbnail in the admin UI.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/overview.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const Media: CollectionConfig = {\n  slug: 'media',\n  upload: {\n    // highlight-start\n    adminThumbnail: 'small',\n    // highlight-end\n    imageSizes: [\n      {\n        name: 'small',\n        fit: 'cover',\n        height: 300,\n        width: 900,\n      },\n      {\n        name: 'large',\n        fit: 'cover',\n        height: 600,\n        width: 1800,\n      },\n    ],\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Payload with Vercel Postgres Adapter - TypeScript\nDESCRIPTION: This configuration snippet demonstrates how to integrate Payload CMS with Vercel's Postgres database using the official adapter. It should be placed in your 'payload.config.ts' file. Dependencies: '@payloadcms/db-vercel-postgres', valid Postgres connection string in process.env.POSTGRES_URL. The db adapter is set up using a connection pool.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/website/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// payload.config.ts\nimport { vercelPostgresAdapter } from '@payloadcms/db-vercel-postgres'\n\nexport default buildConfig({\n  // ...\n  db: vercelPostgresAdapter({\n    pool: {\n      connectionString: process.env.POSTGRES_URL || '',\n    },\n  }),\n  // ...\n```\n\n----------------------------------------\n\nTITLE: Accessing Locally Previewed Payload Documentation\nDESCRIPTION: The default local URL where the Payload documentation can be previewed in a web browser after starting the website's development server (`yarn run dev`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nhttp://localhost:3000/docs/\n```\n\n----------------------------------------\n\nTITLE: Creating Payload Project from Example using NPX (Shell)\nDESCRIPTION: This shell command uses NPX to execute `create-payload-app`, initializing a new Payload CMS project based on the 'custom-components' example template.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/custom-components/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx create-payload-app --example custom-components\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Client Field Label in Payload CMS (TypeScript/React)\nDESCRIPTION: This TypeScript React client component (`CustomCodeFieldLabelClient`), marked with the `'use client'` directive, renders a custom label for a code field in the Payload CMS admin UI during client-side rendering. It receives client-side field data (`field`, `path`) as props and uses the `@payloadcms/ui` `FieldLabel` component for rendering. The label text defaults to the field's name if an explicit label is not provided. The `required` status is derived from the `field` prop.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/code.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { CodeFieldLabelClientComponent } from 'payload'\n\nexport const CustomCodeFieldLabelClient: CodeFieldLabelClientComponent = ({\n  field,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={field?.label || field?.name}\n      path={path}\n      required={field?.required}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Placeholder Text for Payload Rich Text Admin - TypeScript\nDESCRIPTION: Demonstrates customization of the placeholder text in the PayloadCMS rich text field editor by setting the placeholder property in the admin config. Requires the lexicalEditor utility for field configuration. The placeholder string is shown when the editor is empty, improving UX for end users during content entry.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/overview.mdx#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  name: 'richText',\n  type: 'richText',\n  editor: lexicalEditor({\n    admin: {\n      placeholder: 'Type your content here...'\n    },\n  }),\n}\n\n```\n\n----------------------------------------\n\nTITLE: Injecting Custom Components Before the Nav Links (TypeScript)\nDESCRIPTION: Configures the admin.components.beforeNavLinks property to prepend custom content inside the admin sidebar navigation, before built-in links, by specifying paths to React components as array entries. Requires Payload CMS to process config.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  // ...\n  admin: {\n    // highlight-start\n    components: {\n      beforeNavLinks: ['/path/to/your/component'],\n    },\n    // highlight-end\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Email Field Label Server Component in Payload CMS (TSX)\nDESCRIPTION: This snippet illustrates how to build a custom React Server Component for rendering the label associated with an Email field. It uses the `FieldLabel` component from `@payloadcms/ui`, dynamically setting the label text (using `clientField.label` or falling back to `clientField.name`) and indicating if the field is required based on `clientField.required`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/email.mdx#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport React from 'react'\nimport { FieldLabel } from '@payloadcms/ui'\nimport type { EmailFieldLabelServerComponent } from 'payload'\n\nexport const CustomEmailFieldLabelServer: EmailFieldLabelServerComponent = ({\n  clientField,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={clientField?.label || clientField?.name}\n      path={path}\n      required={clientField?.required}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Querying Data with Payload's find API and UseLivePreview Hook in TypeScript/React\nDESCRIPTION: These two snippets show how to coordinate your initial Payload find query and the useLivePreview hook for consistent data structure, especially regarding the depth parameter. The first snippet uses Payload's find API to query for documents with a specific depth, and the second snippet demonstrates initializing your hook with the same depth. Synchronizing these prevents data inconsistency and relationship loading issues.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/client.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// Your initial request\nconst { docs } = await payload.find({\n  collection: 'pages',\n  depth: 1, // Ensure this is set to the proper depth for your application\n  where: {\n    slug: {\n      equals: 'home',\n    },\n  },\n})\n```\n\nLANGUAGE: tsx\nCODE:\n```\n// Your hook\nconst { data } = useLivePreview<PageType>({\n  initialData: initialPage,\n  serverURL: PAYLOAD_SERVER_URL,\n  depth: 1, // Ensure this matches the depth of your initial request\n})\n```\n\n----------------------------------------\n\nTITLE: Adding a Plugin to the Payload Dev Config in TypeScript\nDESCRIPTION: Shows how to insert a plugin in the dev environment's Payload config (dev/payload.config.ts) for local development. This snippet adds the samplePlugin with options, allowing quick enable/disable functionality for testing. Expects TypeScript syntax and integration with Payload CMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n  plugins: [\n    // when you rename the plugin or add options, make sure to update it here\n    samplePlugin({\n      enabled: false,\n    })\n  ]\n```\n\n----------------------------------------\n\nTITLE: Extracting Lexical Editor Config from a Field Definition in TypeScript\nDESCRIPTION: Shows how to extract the specific Lexical editor configuration associated with a particular rich text field definition using `editorConfigFactory.fromField`. Requires the field definition object (e.g., from `config.collections[0].fields[1]`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converters.mdx#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst fieldEditorConfig = editorConfigFactory.fromField({\n  field: config.collections[0].fields[1],\n})\n```\n\n----------------------------------------\n\nTITLE: Viewing Populated (depth=1) API Response in Payload CMS (JSON)\nDESCRIPTION: This JSON snippet demonstrates the shape of a response when querying a document with a depth set to 1 in Payload CMS. Here, related fields such as 'author' are populated as nested objects instead of plaintext IDs, showing additional data (e.g., author name). Inputs come from a REST or local API query with depth=1. Outputs include enhanced nested document details, increasing response size but giving more relationship context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/queries/depth.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \"id\": \"5ae8f9bde69e394e717c8832\",\\n  \"title\": \"This is a great post\",\\n  \"author\": {\\n    \"id\": \"5f7dd05cd50d4005f8bcab17\",\\n    \"name\": \"John Doe\"\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Array Field Label Client Component in TSX\nDESCRIPTION: This snippet defines a custom React client component (`CustomArrayFieldLabelClient`) for rendering the label of a Payload CMS Array Field, marked with `'use client'`. It uses the `FieldLabel` component from `@payloadcms/ui`. The component receives client-side props (`field`, `path`) and determines the label text (using `field.label` or `field.name`) and required status. Requires React and dependencies from `@payloadcms/ui` and `payload`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/array.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\n'use client'\nimport type { ArrayFieldLabelClientComponent } from 'payload'\n\nimport { FieldLabel } from '@payloadcms/ui'\nimport React from 'react'\n\nexport const CustomArrayFieldLabelClient: ArrayFieldLabelClientComponent = ({\n  field,\n  path,\n}) => {\n  return (\n    <FieldLabel\n      label={field?.label || field?.name}\n      path={path}\n      required={field?.required}\n    />\n  )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Vercel Blob Storage Adapter with Shell\nDESCRIPTION: Installs the Vercel Blob storage adapter into your Payload project using pnpm. This command must be executed in your project's root directory and requires \"pnpm\" to be installed globally. It fetches the package \"@payloadcms/storage-vercel-blob\" from the npm registry and adds it to your dependencies.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm add @payloadcms/storage-vercel-blob\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Logo in Payload Config - TypeScript\nDESCRIPTION: This example demonstrates how to set a custom logo component in the Payload CMS admin by assigning 'components.graphics.Logo' in the Payload config. The logo component should be referenced by path. Dependency: Payload. Input: config object; Output: custom admin logo in UI.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\\n\\nexport default buildConfig({\\n  // ...\\n  admin: {\\n    // highlight-start\\n    components: {\\n      graphics: {\\n        Logo: '/path/to/your/component',\\n      },\\n    },\\n    // highlight-end\\n  },\\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring a Custom SaveButton for a Collection (TypeScript)\nDESCRIPTION: This snippet shows how to replace the default Save button in a Collection's Edit View by providing a path to a custom component via the `admin.components.edit.SaveButton` property in the Collection configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollection: CollectionConfig = {\n  // ...\n  admin: {\n    components: {\n      edit: {\n        // highlight-start\n        SaveButton: '/path/to/MySaveButton',\n        // highlight-end\n      },\n    },\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Queuing Jobs with Custom Processing Order (TypeScript)\nDESCRIPTION: This TypeScript code shows how to queue a job in Payload CMS and set a custom processing order directly on the job. The snippet utilizes the `payload.jobs.queue` method with parameters for workflow, input data, and the processing order ('-createdAt', for LIFO). It requires access to the server context with the Payload instance. Inputs are workflow name, job input data, and processing order; the output is the created job object.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/queues.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst createdJob = await payload.jobs.queue({\n  workflow: 'createPostAndUpdate',\n  input: {\n    title: 'my title',\n  },\n  processingOrder: '-createdAt', // Process jobs in reverse order of creation = LIFO\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Payload Block Type in TypeScript\nDESCRIPTION: This TypeScript snippet shows how to import the 'Block' type directly from the 'payload' package. This is useful for maintaining strong typings when defining block configurations in separate files outside the main Payload configuration file.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/blocks.mdx#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { Block } from 'payload'\n```\n```\n\n----------------------------------------\n\nTITLE: Conditionally Enabling the Cloud Storage Plugin in Payload CMS (TypeScript)\nDESCRIPTION: TypeScript example demonstrating how to conditionally enable the `cloudStoragePlugin` based on the value of an environment variable (`process.env.MY_CONDITION`). The `enabled` property controls whether the plugin is active when set within the plugin configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_13\n\nLANGUAGE: ts\nCODE:\n```\n```ts\ncloudStoragePlugin({\n  enabled: process.env.MY_CONDITION === 'true',\n  collections: {\n    'my-collection-slug': {\n      adapter: theAdapterToUse, // see docs for the adapter you want to use\n    },\n  },\n}),\n```\n```\n\n----------------------------------------\n\nTITLE: Examining Polymorphic Join Field Data Structure in JSON\nDESCRIPTION: Shows the JSON object structure for a polymorphic PayloadCMS Join Field (where `collection` is an array). The `docs` array contains objects, each specifying the `relationTo` (the slug of the related collection) and `value` (the related document itself or its ID if the depth limit is reached). Similar to standard joins, it includes `hasNextPage` and the optional `totalDocs` if requested.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/join.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": \"66e3431a3f23e684075aae9c\",\n  \"relatedPosts\": {\n    \"docs\": [\n      {\n        \"relationTo\": \"posts\",\n        \"value\": {\n          \"id\": \"66e3431a3f23e684075aaeb9\",\n          // other fields...\n          \"category\": \"66e3431a3f23e684075aae9c\"\n        }\n      }\n      // { ... }\n    ],\n    \"hasNextPage\": false,\n    \"totalDocs\": 10 // if count: true is passed\n  }\n  // other fields...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Edit View Elements for a Global (TypeScript)\nDESCRIPTION: Shows how to specify custom components for specific parts of the Edit View within a Global's configuration. The `admin.components.elements` object is used to override UI elements related to the Global's edit interface.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/edit-view.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n```ts\nimport type { GlobalConfig } from 'payload'\n\nexport const MyGlobal: GlobalConfig = {\n  // ...\n  admin: {\n    components: {\n      // highlight-start\n      elements: {\n        // ...\n      },\n      // highlight-end\n    },\n  },\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Containers with Docker Compose (Shell)\nDESCRIPTION: This shell command executes Docker Compose using the `docker-compose.yml` file in the current directory. It builds, (re)creates, starts, and attaches to the containers defined in the configuration (typically including a MongoDB service). This is used to launch the development environment managed by Docker.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/blank/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ndocker-compose up\n```\n\n----------------------------------------\n\nTITLE: Resetting User Password via GraphQL Mutation\nDESCRIPTION: Executes a GraphQL mutation named `resetPassword[collection-singular-label]` to update a user's password. It requires the `token` obtained from the forgot password process and the `password` (the new desired password) as arguments. This mutation securely updates the user's password in the specified collection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/authentication/operations.mdx#_snippet_21\n\nLANGUAGE: graphql\nCODE:\n```\nmutation {\n  resetPassword[collection-singular-label](token: \"TOKEN_GOES_HERE\", password: \"not-today\")\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Development Server (Shell)\nDESCRIPTION: These commands run the `dev` script defined in the project's `package.json` file using different package managers (pnpm, yarn, npm). This script typically starts the Payload CMS application in development mode, enabling features like hot-reloading for faster development cycles.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/draft-preview/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn dev\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Running Database Migrations - Bash\nDESCRIPTION: This command executes all pending database migrations for the Payload CMS project using Postgres. It must be run on the server before starting the application to ensure the schema matches expected structure. Dependencies: pnpm and Payload CLI. Runs migrations recorded in the project and updates migration records in the database.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/website/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm payload migrate\n```\n\n----------------------------------------\n\nTITLE: Defining a Next.js Public Environment Variable (Bash)\nDESCRIPTION: Demonstrates defining an environment variable prefixed with `NEXT_PUBLIC_` (e.g., `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY`) in a shell environment or `.env` file. Next.js automatically makes variables with this prefix available in the client-side JavaScript bundle for use in components.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/environment-vars.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_XXXXXXXXXXXXXXXXXX\n```\n\n----------------------------------------\n\nTITLE: Installing Base Cloud Storage Plugin via pnpm\nDESCRIPTION: Command to install the `@payloadcms/plugin-cloud-storage` package using pnpm. This package provides the necessary interfaces and utilities to build custom storage adapters for Payload CMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\n`pnpm add @payloadcms/plugin-cloud-storage`\n```\n\n----------------------------------------\n\nTITLE: Measuring Component Edit Depth with useEditDepth in React (TypeScript)\nDESCRIPTION: Uses the useEditDepth hook from @payloadcms/ui to obtain the component's nesting level within editing modals or nested documents. Useful for rendering context-aware UIs based on the level of document editing. Requires @payloadcms/ui and works inside Payload CMS admin areas.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_16\n\nLANGUAGE: tsx\nCODE:\n```\n'use client'\\nimport { useEditDepth } from '@payloadcms/ui'\\n\\nconst MyComponent: React.FC = () => {\\n  // highlight-start\\n  const editDepth = useEditDepth()\\n  // highlight-end\\n\\n  return <span>My component is {editDepth} levels deep</span>\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Importing TypeScript Types for Nested Docs Plugin - TypeScript\nDESCRIPTION: Shows how to import strongly-typed definitions for plugin configuration and helper signatures from the '@payloadcms/plugin-nested-docs/types' module. Relevant in TypeScript projects using this plugin to enable type checking of configuration and option callback parameters. Dependencies: TypeScript and @payloadcms/plugin-nested-docs installed in the project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/nested-docs.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  PluginConfig,\n  GenerateURL,\n  GenerateLabel,\n} from '@payloadcms/plugin-nested-docs/types'\n```\n\n----------------------------------------\n\nTITLE: Importing the Payload Login Function in TypeScript\nDESCRIPTION: Imports the `login` function from the `@payloadcms/next/auth` package. This function is used to authenticate a user within a Payload CMS application.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/local-api/server-functions.mdx#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { login } from '@payloadcms/next/auth'\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring a Collection as Global in Multi Tenant Plugin (TypeScript)\nDESCRIPTION: Demonstrates how to configure a Payload collection (e.g., 'navigation') to function as a global resource within a multi-tenant setup using the `multiTenantPlugin`. Setting `isGlobal: true` for a collection makes it behave like a global, hiding the list view and ensuring content is specific per tenant.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-multi-tenant/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nmultiTenantPlugin({\n  collections: {\n    navigation: {\n      isGlobal: true,\n    },\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Importing PluginConfig Type from Redirects Plugin (TypeScript)\nDESCRIPTION: Illustrates how to import the PluginConfig type from the plugin's types directory in TypeScript. This import enables type-checking and autocompletion for plugin configuration objects. The snippet assumes the @payloadcms/plugin-redirects dependency is installed and is used for type-safe configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/redirects.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PluginConfig } from '@payloadcms/plugin-redirects/types'\n```\n\n----------------------------------------\n\nTITLE: Adding a Static Description to a Field in Payload CMS (TypeScript)\nDESCRIPTION: Demonstrates how to add a simple, static help text (description) to a field in the Payload Admin Panel. The 'description' property within the 'admin' object is set to a string value.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const MyCollectionConfig: CollectionConfig = {\n  // ...\n  fields: [\n    // ...\n    {\n      name: 'myField',\n      type: 'text',\n      admin: {\n        description: 'Hello, world!', // highlight-line\n      },\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Splitting Encoded Data with Vercel Stega (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates using the `vercelStegaSplit` function from the `@vercel/stega` library. It addresses troubleshooting scenarios, particularly with date fields or text styling conflicts (like negative letter-spacing), where the encoded source map data needs to be separated from the actual display text. The function returns an object with `cleaned` (the original text without encoding) and `encoded` (the source map data) properties.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/integrations/vercel-content-link.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { vercelStegaSplit } from '@vercel/stega'\nconst { cleaned, encoded } = vercelStegaSplit(text)\n```\n\n----------------------------------------\n\nTITLE: Simple After Login React Component (TSX)\nDESCRIPTION: Defines a minimal React component to be rendered immediately after the login UI in Payload Admin. Renders a div with an informational message and has no dependencies other than React. Reference this in afterLogin config for custom tips or follow-ups.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyAfterLoginComponent() {\n  return <div>This is a custom component injected after the Login form.</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Storage and Email Features in Payload Cloud Plugin (JavaScript)\nDESCRIPTION: This JavaScript snippet illustrates how to opt out of specific features (file storage and email delivery) provided by the Payload Cloud Plugin by passing an options object. This should be placed in your Payload config's plugin registration as a function call, typically when you want to manage files or email outside of Payload Cloud or prevent those services from initializing. Boolean 'storage' and 'email' options can be set to 'false' to disable their respective features.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/cloud/projects.mdx#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\npayloadCloud({\\n  storage: false, // Disable file storage\\n  email: false, // Disable email delivery\\n})\n```\n\n----------------------------------------\n\nTITLE: Copying Example Environment Variables (Shell)\nDESCRIPTION: This command copies the template environment variable file `.env.example` to a new file named `.env`. The `.env` file is used by the application to load environment-specific configuration variables like API keys or database credentials, and is typically ignored by version control.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/draft-preview/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Installing Payload MongoDB Adapter via npm (Bash)\nDESCRIPTION: Installs the official MongoDB adapter package (@payloadcms/db-mongodb) using npm. Required before integrating the adapter into a Payload project. Ensure you have Node.js and npm installed. Run this command in your project directory to add the dependency.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/db-mongodb/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/db-mongodb\n```\n\n----------------------------------------\n\nTITLE: Creating a New Payload Migration File (Shell)\nDESCRIPTION: Provides the command-line instruction to generate a new migration file in the configured migrations directory. An optional name can be provided; otherwise, a timestamp-based name is used. Flags like `--skip-empty` and `--force-accept-warning` can modify its behavior, especially for Postgres.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nnpm run payload migrate:create optional-name-here\n```\n\n----------------------------------------\n\nTITLE: Installing Base Live Preview Library - Bash Script\nDESCRIPTION: This Bash snippet installs the core @payloadcms/live-preview npm package, which provides the foundational functionality for building custom live preview integrations. It is required for environments that are not using the React-specific package and is the first step before utilizing ready and isDocumentEvent functions in custom implementations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/server.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/live-preview\n```\n\n----------------------------------------\n\nTITLE: Implementing After Me Hook for Payload CMS (TypeScript)\nDESCRIPTION: Creates an afterMe hook for Payload CMS in TypeScript, leveraging the CollectionAfterMeHook type. This hook runs after 'me' endpoint operations, allowing customization or logging of the current user's response. It gets both the req (request) and response parameters. Needed dependencies include the 'payload' package and a valid Payload CMS configuration. The main inputs are the request and response objects; the output is a processed user response.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/hooks/collections.mdx#_snippet_15\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { CollectionAfterMeHook } from 'payload';\\n\\nconst afterMeHook: CollectionAfterMeHook = async ({\\n  req,\\n  response,\\n}) => {...}\\n\n```\n\n----------------------------------------\n\nTITLE: Setting Global Query Presets Options in Payload Config - TypeScript\nDESCRIPTION: This snippet demonstrates how to configure global Query Presets options within a Payload CMS configuration file using the queryPresets property on the root config object. The buildConfig function from Payload is used for configuration. You can customize various aspects such as access controls, labels, and constraints. This requires Payload CMS and its configuration architecture. No key parameters are enforced by default, but you may customize the queryPresets object as needed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/query-presets/overview.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { buildConfig } from 'payload'\n\nconst config = buildConfig({\n  // ...\n  // highlight-start\n  queryPresets: {\n    // ...\n  },\n  // highlight-end\n})\n```\n\n----------------------------------------\n\nTITLE: Running Payload Integration Tests (Postgres) using PNPM\nDESCRIPTION: Command to execute the Payload integration (int) tests specifically against a PostgreSQL database. Requires having Postgres installed and configured on the system. The `PAYLOAD_DATABASE` environment variable must be set to `postgres` for this command to target Postgres.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\npnpm test:int:postgres\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Development Server without Auto-Login using PNPM\nDESCRIPTION: Command to start the Payload development server using a specific test configuration but disabling the default auto-login feature. This is achieved by passing the `--no-auto-login` flag. Alternatively, the `PAYLOAD_PUBLIC_DISABLE_AUTO_LOGIN` environment variable can be set to `false`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npnpm dev my-test-dir --no-auto-login\n```\n\n----------------------------------------\n\nTITLE: Importing Sentry Plugin TypeScript Types\nDESCRIPTION: This TypeScript code snippet shows how to import the `PluginOptions` type directly from the `@payloadcms/plugin-sentry` package. This is useful for ensuring type safety when configuring the plugin options in a TypeScript project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/sentry.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { PluginOptions } from '@payloadcms/plugin-sentry'\n```\n\n----------------------------------------\n\nTITLE: Basic Structure for Field Admin Options in Payload CMS (TypeScript)\nDESCRIPTION: This snippet shows the basic structure for adding admin-specific configurations to a field within a Payload CMS CollectionConfig using TypeScript. The 'admin' property is nested within a field definition (e.g., 'myField') to hold various UI customization options.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport type { CollectionConfig } from 'payload'\n\nexport const CollectionConfig: CollectionConfig = {\n  // ...\n  fields: [\n    // ...\n    {\n      name: 'myField',\n      type: 'text',\n      admin: {\n        // highlight-line\n        // ...\n      },\n    },\n  ],\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Running Payload End-to-End Tests using PNPM\nDESCRIPTION: Command to execute only the end-to-end (e2e) tests for Payload CMS, which typically use Playwright to interact with the Admin UI. This command should be run from the root of the monorepo using PNPM.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\npnpm test:e2e\n```\n\n----------------------------------------\n\nTITLE: Running Full Payload Test Suite using PNPM\nDESCRIPTION: Command to execute the entire test suite for the Payload CMS project, including both integration (Jest) and end-to-end (Playwright) tests. This command should be run from the root of the monorepo using PNPM.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\npnpm test\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Starting Payload Dev Server (Shell)\nDESCRIPTION: This shell command uses `pnpm` to install the project's dependencies as defined in `package.json` and associated lock files, and then starts the Payload CMS development server. Changes made in the `./src` directory will be hot-reloaded.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/blank/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npnpm install && pnpm dev\n```\n\n----------------------------------------\n\nTITLE: Generating GraphQL Schema with Payload CLI - Bash\nDESCRIPTION: This shell command invokes the Payload GraphQL CLI tool to generate a GraphQL schema file. It assumes '@payloadcms/graphql' is installed and accessible, and Payload config is discoverable. The generated schema file (schema.graphql) will be saved to the current working directory or as configured. No parameters are required.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/graphql-schema.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm payload-graphql generate:schema\n```\n\n----------------------------------------\n\nTITLE: Defining Multi Tenant Plugin Configuration Type (TypeScript)\nDESCRIPTION: Defines the TypeScript type `MultiTenantPluginConfig` for configuring the Multi Tenant Plugin. It outlines various options like cleanup behavior, collection-specific settings (e.g., `isGlobal`, `useBaseListFilter`, `useTenantAccess`), debug mode, enabling/disabling the plugin, field customization (`tenantField`, `tenantsArrayField`), tenant selector labels, slugs, user access checks, and opting out of default access/filters.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-multi-tenant/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype MultiTenantPluginConfig<ConfigTypes = unknown> = {\n  /**\n   * After a tenant is deleted, the plugin will attempt to clean up related documents\n   * - removing documents with the tenant ID\n   * - removing the tenant from users\n   *\n   * @default true\n   */\n  cleanupAfterTenantDelete?: boolean\n  /**\n   * Automatically\n   */\n  collections: {\n    [key in CollectionSlug]?: {\n      /**\n       * Set to `true` if you want the collection to behave as a global\n       *\n       * @default false\n       */\n      isGlobal?: boolean\n      /**\n       * Set to `false` if you want to manually apply the baseListFilter\n       *\n       * @default true\n       */\n      useBaseListFilter?: boolean\n      /**\n       * Set to `false` if you want to handle collection access manually without the multi-tenant constraints applied\n       *\n       * @default true\n       */\n      useTenantAccess?: boolean\n    }\n  }\n  /**\n   * Enables debug mode\n   * - Makes the tenant field visible in the admin UI within applicable collections\n   *\n   * @default false\n   */\n  debug?: boolean\n  /**\n   * Enables the multi-tenant plugin\n   *\n   * @default true\n   */\n  enabled?: boolean\n  /**\n   * Field configuration for the field added to all tenant enabled collections\n   */\n  tenantField?: {\n    access?: RelationshipField['access']\n    /**\n     * The name of the field added to all tenant enabled collections\n     *\n     * @default 'tenant'\n     */\n    name?: string\n  }\n  /**\n   * Field configuration for the field added to the users collection\n   *\n   * If `includeDefaultField` is `false`, you must include the field on your users collection manually\n   * This is useful if you want to customize the field or place the field in a specific location\n   */\n  tenantsArrayField?:\n    | {\n        /**\n         * Access configuration for the array field\n         */\n        arrayFieldAccess?: ArrayField['access']\n        /**\n         * Name of the array field\n         *\n         * @default 'tenants'\n         */\n        arrayFieldName?: string\n        /**\n         * Name of the tenant field\n         *\n         * @default 'tenant'\n         */\n        arrayTenantFieldName?: string\n        /**\n         * When `includeDefaultField` is `true`, the field will be added to the users collection automatically\n         */\n        includeDefaultField?: true\n        /**\n         * Additional fields to include on the tenants array field\n         */\n        rowFields?: Field[]\n        /**\n         * Access configuration for the tenant field\n         */\n        tenantFieldAccess?: RelationshipField['access']\n      }\n    | {\n        arrayFieldAccess?: never\n        arrayFieldName?: string\n        arrayTenantFieldName?: string\n        /**\n         * When `includeDefaultField` is `false`, you must include the field on your users collection manually\n         */\n        includeDefaultField?: false\n        rowFields?: never\n        tenantFieldAccess?: never\n      }\n  /**\n   * Customize tenant selector label\n   *\n   * Either a string or an object where the keys are i18n codes and the values are the string labels\n   */\n  tenantSelectorLabel?:\n    | Partial<{\n        [key in AcceptedLanguages]?: string\n      }>\n    | string\n  /**\n   * The slug for the tenant collection\n   *\n   * @default 'tenants'\n   */\n  tenantsSlug?: string\n  /**\n   * Function that determines if a user has access to _all_ tenants\n   *\n   * Useful for super-admin type users\n   */\n  userHasAccessToAllTenants?: (\n    user: ConfigTypes extends { user: unknown } ? ConfigTypes['user'] : User,\n  ) => boolean\n  /**\n   * Opt out of adding access constraints to the tenants collection\n   */\n  useTenantsCollectionAccess?: boolean\n  /**\n   * Opt out including the baseListFilter to filter tenants by selected tenant\n   */\n  useTenantsListFilter?: boolean\n  /**\n   * Opt out including the baseListFilter to filter users by selected tenant\n   */\n  useUsersTenantFilter?: boolean\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Development Sandbox Dependencies (Shell)\nDESCRIPTION: Installs the necessary Node.js package dependencies specific to the local development sandbox environment. This command needs to be run within the `./dev` directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Configuring Scheduled Serverless Cron with Vercel for Job Queue (JSON)\nDESCRIPTION: This JSON snippet represents the `vercel.json` configuration file, enabling Vercel Cron to invoke the Payload CMS job runner endpoint on a fixed schedule. It sets the crons array so that the `/api/payload-jobs/run` route is triggered every 5 minutes. No dependencies beyond Vercel deployment are needed. Input is the schedule and endpoint path—the output is a Vercel setup where the job runner is invoked periodically.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/jobs-queue/queues.mdx#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"crons\": [\n    {\n      \"path\": \"/api/payload-jobs/run\",\n      \"schedule\": \"*/5 * * * *\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Building the Next.js Application for Production (Bash)\nDESCRIPTION: These commands (`pnpm build` or `npm run build`) execute the Next.js build script (`next build`) defined in the project's `package.json`. This process compiles and optimizes the Next.js application, including the Payload admin panel, creating a production-ready build in the `.next` directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\npnpm build` or `npm run build\n```\n\n----------------------------------------\n\nTITLE: Using the useCollapsible Hook in React - TypeScript\nDESCRIPTION: This snippet shows how to use the useCollapsible hook from the @payloadcms/ui package to manage the open/closed state of a parent collapsible UI component in a React app. Dependencies include React and @payloadcms/ui. The hook provides the isCollapsed state and a toggle function, which are used to conditionally render descriptive text and to toggle the collapsible when the button is clicked. Key parameters: none; returns an object with multiple state variables and methods. The component expects to render inside a React tree where collapsible context is provided, and toggling only affects the nearest collapsible ancestor.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/react-hooks.mdx#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n\"'use client'\\nimport React from 'react'\\n\\nimport { useCollapsible } from '@payloadcms/ui'\\n\\nconst CustomComponent: React.FC = () => {\\n  const { isCollapsed, toggle } = useCollapsible()\\n\\n  return (\\n    <div>\\n      <p className=\\\"field-type\\\">I am {isCollapsed ? 'closed' : 'open'}</p>\\n      <button onClick={toggle} type=\\\"button\\\">\\n        Toggle\\n      </button>\\n    </div>\\n  )\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Database Seeding Example in Server Code (TypeScript)\nDESCRIPTION: Illustrates conditional invocation of a seed function in dev/src/server.ts for seeding test data when the PAYLOAD_SEED environment variable is set. Designed for TypeScript and Node.js environments, it helps automate test data insertion.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nif (process.env.PAYLOAD_SEED === 'true') {\n    await seed(payload)\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Robots Meta Tag in Payload Config (TypeScript)\nDESCRIPTION: Sets the 'robots' meta tag via the 'robots' property on the 'admin.meta' object to prevent admin panel pages from being indexed or followed by search engines. Typical values like 'noindex, nofollow' are specified as strings. This configuration restricts search engine visibility but does not alone prevent crawling—see robots.txt for further restriction.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/metadata.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  // ...\n  admin: {\n    meta: {\n      // highlight-start\n      robots: 'noindex, nofollow',\n      // highlight-end\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Output and Root Directories in tsconfig.json for Production (JSON)\nDESCRIPTION: Illustrates configuring both `outDir` and `rootDir` in `tsconfig.json`. In production mode, Payload prioritizes searching for the config file in the `outDir` before falling back to the `rootDir`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n  // ...\n  // highlight-start\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  }\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Open Graph Metadata in Payload Admin Panel (TypeScript)\nDESCRIPTION: Configures Open Graph properties for enhanced social media sharing when links to the admin panel are posted. The 'openGraph' key inside the 'admin.meta' object specifies OG fields like description, images, siteName, and title. Images are defined as objects with URL, width, and height. Requires correct structuring under the Payload config, uses Next.js metadata standards, and supports multiple social platforms.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/metadata.mdx#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  // ...\n  admin: {\n    meta: {\n      // highlight-start\n      openGraph: {\n      // highlight-end\n        description: 'The best admin panel in the world',\n        images: [\n          {\n            url: 'https://example.com/image.jpg',\n            width: 800,\n            height: 600,\n          },\n        ],\n        siteName: 'Payload',\n        title: 'My Admin Panel',\n      },\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Content Security Policy for Live Preview Iframes in Plaintext\nDESCRIPTION: This plaintext configuration line is an example of setting the frame-ancestors directive in a Content Security Policy to permit your Payload Admin Panel to load your front-end app in an iframe. Add the admin domain and any app domains to allow proper embedding and interaction for Live Preview features.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/client.mdx#_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\nframe-ancestors: \"self\" localhost:* https://your-site.com;\n```\n\n----------------------------------------\n\nTITLE: Customizing Icons Metadata for Payload Admin Panel (TypeScript)\nDESCRIPTION: Demonstrates customization of the 'icons' property within 'admin.meta', allowing for multiple <link> icon tags (like favicon and Apple touch icons). Each icon entry sets relation, type, and URL, supporting various devices and browsers. Used in Payload config, requires object entries per icon, and directly impacts browser display and home screen appearance of the admin panel.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/metadata.mdx#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  // ...\n  admin: {\n    meta: {\n      // highlight-start\n      icons: [\n      // highlight-end\n        {\n          rel: 'icon',\n          type: 'image/png',\n          url: '/favicon.png',\n        },\n        {\n          rel: 'apple-touch-icon',\n          type: 'image/png',\n          url: '/apple-touch-icon.png',\n        },\n      ],\n    },\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing dotenv for Environment Variables in Non-Next.js Payload (TypeScript)\nDESCRIPTION: Demonstrates importing the `dotenv` package and calling `dotenv.config()` early in the application, typically in the main configuration file (`payload.config.ts`), to load variables from a `.env` file into `process.env`. This is necessary for applications not using Next.js's built-in environment variable handling.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/environment-vars.mdx#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport dotenv from 'dotenv'\ndotenv.config() // highlight-line\n\nimport { buildConfig } from 'payload'\n\nexport default buildConfig({\n  serverURL: process.env.SERVER_URL,\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Example Data Structure for Polymorphic HasMany Relationship Field (JSON)\nDESCRIPTION: Illustrates the expected JSON structure for the 'owners' field when hasMany and polymorphism are enabled in PayloadCMS. Each object in the 'owners' array contains a 'relationTo' (the related collection slug) and a 'value' (the related document's id as a string). This structure is returned from the API and required as input when submitting data to the collection. No prerequisites other than using the relevant PayloadCMS schema.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/relationship.mdx#_snippet_12\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"owners\": [\n    {\n      \"relationTo\": \"users\",\n      \"value\": \"6031ac9e1289176380734024\"\n    },\n    {\n      \"relationTo\": \"organizations\",\n      \"value\": \"602c3c327b811235943ee12b\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Rich Text Custom Types from payloadcms/richtext-slate in TypeScript\nDESCRIPTION: This brief snippet shows how to import type definitions for custom Rich Text elements and leaves from the '@payloadcms/richtext-slate' package. These types support TypeScript development for extending Rich Text functionality in PayloadCMS projects. The types provide compile-time safety for custom SlateJS element and leaf implementations and do not have runtime outputs or dependencies beyond TypeScript and the target package.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/slate.mdx#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type {\n  RichTextCustomElement,\n  RichTextCustomLeaf,\n} from '@payloadcms/richtext-slate'\n```\n\n----------------------------------------\n\nTITLE: Copying Example Environment Variables (Shell)\nDESCRIPTION: Copies the example environment variable file (`.env.example`) to a new file named `.env`. This is a necessary step to configure the project's environment variables before running it.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/form-builder/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Payload Website Repository\nDESCRIPTION: Command to install the necessary project dependencies for the Payload website repository (`payloadcms/website`). This step is required before previewing local documentation changes.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Building the App for Production - npm - Shell Script\nDESCRIPTION: This snippet demonstrates how to build the Remix application for production using npm. It requires that the 'build' script is configured in package.json and all dependencies are installed. When executed, it compiles and bundles both server-side and client-side code into the 'build/server' and 'build/client' directories for deployment. Input is none; output is the compiled assets and artifacts in the build directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/remix/website/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Using the Stripe REST Proxy Endpoint via Fetch (TypeScript)\nDESCRIPTION: Shows how to make a request to the Stripe REST API through the plugin's proxy endpoint (`/api/stripe/rest`) using the browser's `fetch` API. It sends a POST request with the Stripe method and arguments in the JSON body. Requires the `rest: true` option in the plugin config and proper authentication (like cookies or JWT token if not in a browser). Note the security warning regarding production use.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/stripe.mdx#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst res = await fetch(`/api/stripe/rest`, {\n  method: 'POST',\n  credentials: 'include',\n  headers: {\n    'Content-Type': 'application/json',\n    // Authorization: `JWT ${token}` // NOTE: do this if not in a browser (i.e. curl or Postman)\n  },\n  body: JSON.stringify({\n    stripeMethod: 'stripe.subscriptions.list',\n    stripeArgs: [\n      {\n        customer: 'abc',\n      },\n    ],\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Starting Remix Website Development Server with pnpm (Shell)\nDESCRIPTION: This shell command uses `pnpm` to execute the `dev:website` script, likely defined in the root `package.json` or the Remix app's `package.json`. This starts the development server for the Remix frontend website. It needs to be run in a separate terminal, typically after the Payload server is running, and requires project dependencies to be installed and the website `.env` file configured.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/remix/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\npnpm run dev:website\n```\n\n----------------------------------------\n\nTITLE: Extracting Lexical Editor Config from an Instantiated Editor in TypeScript\nDESCRIPTION: Explains how to get the editor configuration from an already instantiated Lexical editor instance using `editorConfigFactory.fromEditor`. This method is noted as less efficient and alternatives like `fromFeatures` are suggested. Requires the Payload `SanitizedConfig` and the editor instance.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/converters.mdx#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nconst editor = lexicalEditor({\n  features: ({ defaultFeatures }) => [\n    ...defaultFeatures,\n    FixedToolbarFeature(),\n  ],\n})\n\nconst instantiatedEditorConfig = await editorConfigFactory.fromEditor({\n  config,\n  editor,\n})\n```\n\n----------------------------------------\n\nTITLE: Simple After Dashboard React Component (TSX)\nDESCRIPTION: Defines a minimal React functional component intended to be attached after the admin dashboard by listing it in the afterDashboard config. No inputs are required, and it simply renders a message. Useful for custom footers, promotional blocks, or links.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyAfterDashboardComponent() {\n  return <div>This is a custom component injected after the Dashboard.</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Core Live Preview Functions for Custom Hooks (TSX)\nDESCRIPTION: This TSX code snippet demonstrates importing the `subscribe` and `unsubscribe` functions from the core `@payloadcms/live-preview` package. These functions are the essential tools for creating custom Live Preview logic in JavaScript frameworks, handling communication with the Payload admin panel via `window.postMessage` events and managing data updates.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { subscribe, unsubscribe } from '@payloadcms/live-preview'\n\n// Build your own hook to subscribe to the live preview events\n// This function will handle everything for you like\n// 1. subscribing to `window.postMessage` events\n// 2. merging initial page data with incoming form state\n// 3. populating relationships and uploads\n```\n\n----------------------------------------\n\nTITLE: Inserting Dynamic Form Data into Email Templates using HTML\nDESCRIPTION: Illustrates how to embed submitted form data dynamically into the email body using double curly brace syntax. The example shows inserting the value of a form field named 'name'. The documentation also mentions wildcards '{{*}}' for all data and '{{*:table}}' for a table format.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_12\n\nLANGUAGE: html\nCODE:\n```\nThank you for your submission, {{name}}!\n```\n\n----------------------------------------\n\nTITLE: Example Jest Test Suite for Plugin Verification in TypeScript\nDESCRIPTION: A Jest test suite example to validate seeded data within the Payload environment for plugin development. Depends on Jest and Payload CMS, and operates in a TypeScript test file. Tests create queries on collections and assert expected outcomes, ensuring plugins function as intended.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nlet payload: Payload\n\ndescribe('Plugin tests', () => {\n  // Example test to check for seeded data\n  it('seeds data accordingly', async () => {\n    const newCollectionQuery = await payload.find({\n      collection: 'newCollection',\n      sort: 'createdAt',\n    })\n\n    newCollection = newCollectionQuery.docs\n\n    expect(newCollectionQuery.totalDocs).toEqual(1)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Google Cloud Storage Adapter with Shell\nDESCRIPTION: Installs the Google Cloud Storage adapter for Payload CMS using pnpm. This shell command should be run in your project root with pnpm installed, fetching the \"@payloadcms/storage-gcs\" package and adding it to your dependencies.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npnpm add @payloadcms/storage-gcs\n```\n\n----------------------------------------\n\nTITLE: Creating S3 Bucket in LocalStack (Shell)\nDESCRIPTION: Uses the AWS CLI to create a new S3 bucket named `payload-bucket` within the running LocalStack emulator. It specifies the LocalStack endpoint URL (`http://localhost:4566`). Assumes the `localstack` profile is configured or default credentials match.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\naws --endpoint-url=http://localhost:4566 s3 mb s3://payload-bucket\n```\n\n----------------------------------------\n\nTITLE: Creating a Dev Environment for Payload Plugin Development (CLI Usage)\nDESCRIPTION: Provides shell commands to initialize a sanitized development environment for Payload plugin development. Runs on any system with Node.js, npx, and compatible shell. These commands set up a new folder and initialize a sample Payload project for plugin development and testing. Outputs a ready-to-use dev workspace.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/build-your-own.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir dev\ncd dev\nnpx create-payload-app@latest\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Logo Component - React TSX\nDESCRIPTION: Defines a minimal React functional component for rendering a custom logo via an <img> element. Used to show branding in places such as the login view. The input is none; the output is an <img> tag pointing to your logo image. Intended to be referenced in the Payload config.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/root-components.mdx#_snippet_20\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function MyCustomLogo() {\\n  return <img src=\"/path/to/your/logo.png\" alt=\"My Custom Logo\" />\\n}\n```\n\n----------------------------------------\n\nTITLE: Running Integration Tests for PayloadCMS - Bash\nDESCRIPTION: This bash snippet runs all integration tests found in the `/test/_community/int.spec.ts` file using the pnpm test:int script. It allows developers to verify API functionality and potential regressions in a controlled environment. It requires appropriate test scripts and is executed from the command line within the PayloadCMS project context.\nSOURCE: https://github.com/payloadcms/payload/blob/main/ISSUE_GUIDE.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm test:int _community\n```\n\n----------------------------------------\n\nTITLE: Required Environment Variables for Local Payload Cloud File Storage Access\nDESCRIPTION: Lists the essential environment variables that must be configured in a local development environment to enable the Payload Cloud plugin to connect and interact with file storage resources. These variables include flags, project identifiers, Cognito pool details, and S3 bucket information.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/payload-cloud/README.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n```txt\nPAYLOAD_CLOUD=true\nPAYLOAD_CLOUD_ENVIRONMENT=prod\nPAYLOAD_CLOUD_COGNITO_USER_POOL_CLIENT_ID=\nPAYLOAD_CLOUD_COGNITO_USER_POOL_ID=\nPAYLOAD_CLOUD_COGNITO_IDENTITY_POOL_ID=\nPAYLOAD_CLOUD_PROJECT_ID=\nPAYLOAD_CLOUD_BUCKET=\nPAYLOAD_CLOUD_BUCKET_REGION=\nPAYLOAD_CLOUD_COGNITO_PASSWORD=\n```\n```\n\n----------------------------------------\n\nTITLE: Starting S3 Emulator (LocalStack) with Docker Compose (Shell)\nDESCRIPTION: Starts the LocalStack S3 emulator service defined in the `docker-compose.yml` file in the current directory. The `-d` flag runs the containers in detached mode.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\ndocker-compose up -d\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Development Server with pnpm (Shell)\nDESCRIPTION: This shell command uses `pnpm` to execute the `dev:payload` script, typically defined in the root `package.json` or the Payload app's `package.json`. This script starts the development server for the Payload CMS admin panel and backend. It requires dependencies to be installed and the `.env` file to be configured first.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/remix/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npnpm run dev:payload\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Production Server (Shell)\nDESCRIPTION: These commands run the `start` script defined in the `package.json` using pnpm or npm. This script launches the Node.js server to serve the previously built production version of the Payload application. It runs the optimized application code from the build output directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/draft-preview/README.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\npnpm start\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Setting S3 Bucket ACL in LocalStack (Shell)\nDESCRIPTION: Uses the AWS CLI S3 API to set the Access Control List (ACL) of the `payload-bucket` to `public-read`, making its contents publicly accessible. It targets the LocalStack endpoint URL.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\naws --endpoint-url=http://localhost:4566 s3api put-bucket-acl --bucket payload-bucket --acl public-read\n```\n\n----------------------------------------\n\nTITLE: Installing Resend Email Adapter using pnpm (Shell)\nDESCRIPTION: Installs the necessary Payload CMS Resend email adapter package using the pnpm package manager. This command adds the '@payloadcms/email-resend' dependency to your project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/email-resend/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @payloadcms/email-resend\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to GCS Emulator (Shell)\nDESCRIPTION: Navigates the command line interface into the directory containing the Docker configuration for the Google Cloud Storage (GCS) emulator (`./src/adapters/gcs/emulator`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\ncd ./src/adapters/gcs/emulator\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Dev Server with S3 Adapter (Shell)\nDESCRIPTION: Runs the predefined `dev:s3` script from `package.json` (likely located in the `./dev` directory) to start the Payload development server specifically configured to use the S3 storage adapter (connecting to the LocalStack emulator).\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\nyarn dev:s3\n```\n\n----------------------------------------\n\nTITLE: Extending shouldBreakOutOnEnter in Custom SlateJS Elements in TypeScript\nDESCRIPTION: This code defines a custom SlateJS element configuration, demonstrating how to add a plugin that customizes the editor's break-out-on-enter behavior for a 'large-body' element. It shows how to override the editor's 'shouldBreakOutOnEnter' logic so that pressing Enter inside a 'large-body' element causes the cursor to move to a new paragraph. This snippet requires dependencies on Slate, PayloadCMS, and any referenced components (Button, Element, and plugin), and should be used as part of a larger rich text configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/rich-text/slate.mdx#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport Button from './Button'\nimport Element from './Element'\nimport withLargeBody from './plugin'\n\nexport default {\n  name: 'large-body',\n  Button,\n  Element,\n  plugins: [\n    (incomingEditor) => {\n      const editor = incomingEditor\n      const { shouldBreakOutOnEnter } = editor\n\n      editor.shouldBreakOutOnEnter = (element) =>\n        element.type === 'large-body' ? true : shouldBreakOutOnEnter(element)\n\n      return editor\n    },\n  ],\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Uploadthing Storage Adapter via pnpm\nDESCRIPTION: Command to install the `@payloadcms/storage-uploadthing` package using the pnpm package manager. This package provides integration between Payload CMS and the Uploadthing file service.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\n```sh\npnpm add @payloadcms/storage-uploadthing\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Nested Docs Plugin using pnpm - Bash\nDESCRIPTION: Installs the @payloadcms/plugin-nested-docs package into your project using pnpm. Ensure you run this command in the root directory of your Payload CMS project. You must have pnpm installed as a prerequisite.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/nested-docs.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n  pnpm add @payloadcms/plugin-nested-docs\n```\n\n----------------------------------------\n\nTITLE: Specifying Root Directory in tsconfig.json for Development (JSON)\nDESCRIPTION: Shows how to configure the `rootDir` within `compilerOptions` in a `tsconfig.json` file. Payload uses this setting in development mode to locate the configuration file if it's not found in the root directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n  // ...\n  // highlight-start\n  \"compilerOptions\": {\n    \"rootDir\": \"src\"\n  }\n  // highlight-end\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Payload White-label Example Project (Shell)\nDESCRIPTION: This command uses `npx create-payload-app` with the `--example whitelabel` flag to scaffold a new Payload CMS project based on the official white-label example template. It downloads the necessary files and sets up the basic project structure.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/whitelabel/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx create-payload-app --example whitelabel\n```\n\n----------------------------------------\n\nTITLE: Initializing Payload CMS with Next.js Custom Server - Shell\nDESCRIPTION: This CLI command initializes a new Payload CMS project based on the custom Next.js server example. It leverages 'npx create-payload-app' which handles setup, dependency installation, and example file generation. The '--example custom-server' parameter instructs the initializer to use a predefined template integrating Express.js. Required: Node.js, npm, and network access for package installation. Input: none. Output: a new project directory set up with custom server example code. Ensure all prerequisites are installed before running.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/custom-server/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx create-payload-app --example custom-server\n```\n\n----------------------------------------\n\nTITLE: Generating Drizzle Schema from PayloadCMS CLI (Shell)\nDESCRIPTION: Illustrates the command-line instruction to generate Drizzle ORM schema artifacts, which is a prerequisite for type-safe direct Drizzle interactions within PayloadCMS. This command must be executed after configuring SQLite and before importing Drizzle tables into the Payload configuration. Outputs generated schema files in the project's directory structure to enable strongly typed operations.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/sqlite.mdx#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpx payload generate:db-schema\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Containers for Local Development - Bash\nDESCRIPTION: This command launches the containers defined in the local docker-compose.yml file for the Payload CMS project. It assumes Docker and docker-compose are installed, and that environment variables (.env) and compose configuration are properly set. Input: none. Output: starts the Postgres service (and other defined services) locally, enabling consistent development and testing environments.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/with-vercel-postgres/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose up\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for Cloud Storage Access in ENV Files (env)\nDESCRIPTION: This snippet lists all necessary environment variables to configure direct access to Payload Cloud file storage and required Cognito authentication information. Place these key-value pairs into your project's .env file to enable the Payload Cloud Plugin to authenticate and manage media on S3 via Cloudflare CDN. Ensure that actual values are obtained from your Payload Cloud project's file storage tab and replace the placeholders as needed. The plugin automatically detects these variables for seamless integration, but do not omit any variable for successful access and authentication.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/cloud/projects.mdx#_snippet_0\n\nLANGUAGE: env\nCODE:\n```\nPAYLOAD_CLOUD=true\\nPAYLOAD_CLOUD_ENVIRONMENT=prod\\nPAYLOAD_CLOUD_COGNITO_USER_POOL_CLIENT_ID=\\nPAYLOAD_CLOUD_COGNITO_USER_POOL_ID=\\nPAYLOAD_CLOUD_COGNITO_IDENTITY_POOL_ID=\\nPAYLOAD_CLOUD_PROJECT_ID=\\nPAYLOAD_CLOUD_BUCKET=\\nPAYLOAD_CLOUD_BUCKET_REGION=\\nPAYLOAD_CLOUD_COGNITO_PASSWORD=\\n\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Dev Server with Azure Adapter (Shell)\nDESCRIPTION: Runs the predefined `dev:azure` script from `package.json` (likely located in the `./dev` directory) to start the Payload development server specifically configured to use the Azure storage adapter.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nyarn dev:azure\n```\n\n----------------------------------------\n\nTITLE: Creating a PayloadCMS Project with Localization Example - Shell\nDESCRIPTION: This shell command uses npx to create a new PayloadCMS project based on the localization example template. It fetches the latest compatible starter files and scaffolds the necessary folder structure. Prerequisites include Node.js, a package manager, and npx installed globally. Input is not required beyond this command, and output is a new project directory prepared for localization implementation. Limitations: Internet connection required, and the template version may become outdated.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/localization/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx create-payload-app --example localization\n```\n\n----------------------------------------\n\nTITLE: Building Payload Admin Panel for Production (Shell)\nDESCRIPTION: These are alternative commands to trigger the production build process for the Payload admin panel (often utilizing Next.js). Running `pnpm build` or `npm run build` executes the build script defined in `package.json`, creating optimized static assets and server bundles (e.g., in a `.next` directory) required for deployment.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/whitelabel/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\npnpm build` or `npm run build\n```\n\n----------------------------------------\n\nTITLE: Creating Payload Project from Form Builder Example (Shell)\nDESCRIPTION: Uses `npx create-payload-app` to scaffold a new Payload CMS project based on the official 'form-builder' example template. This command downloads the template and sets up the initial project structure.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/form-builder/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx create-payload-app --example form-builder\n```\n\n----------------------------------------\n\nTITLE: Installing Live Preview Dependencies with NPM in Bash\nDESCRIPTION: This snippet demonstrates installing the @payloadcms/live-preview package using npm, a prerequisite for building Live Preview hooks. The command should be run in the project root, and it adds the dependency to your node_modules and package.json. Ensure Node.js and npm are installed before running this command.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/client.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/live-preview\n```\n\n----------------------------------------\n\nTITLE: Installing @payloadcms/graphql as Dev Dependency with pnpm - Bash\nDESCRIPTION: This snippet installs the '@payloadcms/graphql' package as a development dependency using the 'pnpm' package manager. Required to enable GraphQL-related schema utilities in a Payload CMS project. The only parameter to change is the choice of package manager; it assumes a Node.js environment with pnpm installed. No output is produced other than the dependency added to your node_modules and package.json.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/graphql-schema.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @payloadcms/graphql -D\n```\n\n----------------------------------------\n\nTITLE: Creating a Database Migration - Bash\nDESCRIPTION: This command generates migration files for the Payload CMS database schema when using Postgres. It should be run locally after schema changes to track them and prepare corresponding SQL migration scripts. Dependencies: pnpm and Payload CLI. Input: None. Output: Migration files stored within the project directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/website/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm payload migrate:create\n```\n\n----------------------------------------\n\nTITLE: Initializing Payload CMS with Website Template (Shell)\nDESCRIPTION: This shell command uses npx (Node Package Execute) to run the latest version of the `create-payload-app` package. The `-t website` flag specifies that the project should be initialized using the official 'website' template, which is pre-configured for typical CMS use cases.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/what-is-payload.mdx#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx create-payload-app@latest -t website\n```\n\n----------------------------------------\n\nTITLE: Installing AWS S3 Storage Adapter with Shell\nDESCRIPTION: Installs the AWS S3 storage adapter required for file uploads via AWS S3 in Payload CMS. This command requires global \"pnpm\" and runs in your project directory, adding the \"@payloadcms/storage-s3\" dependency for further configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/upload/storage-adapters.mdx#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm add @payloadcms/storage-s3\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Dev Server with GCS Adapter (Shell)\nDESCRIPTION: Runs the predefined `dev:gcs` script from `package.json` (likely located in the `./dev` directory) to start the Payload development server specifically configured to use the Google Cloud Storage (GCS) adapter.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\nyarn dev:gcs\n```\n\n----------------------------------------\n\nTITLE: Installing the Stripe Plugin via pnpm (Bash)\nDESCRIPTION: Installs the `@payloadcms/plugin-stripe` package using the pnpm package manager. This command adds the Stripe plugin dependency to your project, enabling its use within PayloadCMS. Ensure pnpm is installed before running this command.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/stripe.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n  pnpm add @payloadcms/plugin-stripe\n```\n\n----------------------------------------\n\nTITLE: Installing Vercel Blob Storage Plugin using pnpm (Shell)\nDESCRIPTION: Installs the `@payloadcms/storage-vercel-blob` package into the project using the pnpm package manager. This package is required to integrate Payload CMS with Vercel Blob storage.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/storage-vercel-blob/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @payloadcms/storage-vercel-blob\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Starting Dev Server with pnpm (Shell)\nDESCRIPTION: This command sequence first installs the project's dependencies using the `pnpm install` command and then immediately starts the Payload development server using `pnpm dev`. This is a common workflow for local development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/whitelabel/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm install && pnpm dev\n```\n\n----------------------------------------\n\nTITLE: Adding Vercel Postgres Adapter - Bash\nDESCRIPTION: This command installs the Vercel Postgres adapter package required for integrating Payload CMS with Vercel's managed Postgres database. It updates your project dependencies so you can import and configure the adapter within your Payload config. Run this command before updating your Payload configuration for Vercel deployment.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/website/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @payloadcms/db-vercel-postgres\n```\n\n----------------------------------------\n\nTITLE: Installing @payloadcms/storage-azure Using pnpm (Shell)\nDESCRIPTION: This snippet shows the shell command needed to add the @payloadcms/storage-azure package to a PayloadCMS project using pnpm. It requires a working Node.js and pnpm environment. Running this command installs the Azure Blob Storage adapter as a dependency, enabling its usage in the project. No input parameters are needed; the output is the updated package dependencies.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/storage-azure/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @payloadcms/storage-azure\n```\n\n----------------------------------------\n\nTITLE: Installing Payload Live Preview Composable for Vue using npm - Bash\nDESCRIPTION: This snippet shows how to install the '@payloadcms/live-preview-vue' package via npm. This package provides the official Payload CMS composition API for Live Preview functionality in Vue/Nuxt applications. Run this command in your project directory before attempting to use the related hook.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/client.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/live-preview-vue\n```\n\n----------------------------------------\n\nTITLE: Installing Payload GCS Storage Adapter - Shell\nDESCRIPTION: Demonstrates the shell command needed to install the @payloadcms/storage-gcs package using pnpm. This is a prerequisite for configuring Payload to use Google Cloud Storage, and should be run in the root directory of your Payload project. The command ensures that the necessary storage adapter is available as a dependency before proceeding with further configuration.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/storage-gcs/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm add @payloadcms/storage-gcs\n```\n\n----------------------------------------\n\nTITLE: Creating Environment Configuration File (Shell)\nDESCRIPTION: Copies the example environment file (`.env.example`) to create a new environment configuration file (`.env`) within the `./dev` directory. This file needs to be populated with the necessary environment variables.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Installing SQLite Database Adapter - Bash\nDESCRIPTION: Installs the SQLite database adapter for Payload CMS. Enables SQLite as a storage backend. Run this command in your project directory after Payload is installed. Outputs the adapter to node_modules. Limitation: suited for development or lightweight workloads only.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/installation.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npnpm i @payloadcms/db-sqlite\n```\n\n----------------------------------------\n\nTITLE: Importing Stripe Plugin Types for TypeScript\nDESCRIPTION: This code fragment demonstrates how to import TypeScript types required for advanced development or extension of the Payload Stripe plugin. The imports include StripeConfig, StripeWebhookHandler, and StripeProxy types from the plugin's types directory. It presumes TypeScript usage and the presence of '@payloadcms/plugin-stripe' in node_modules.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/stripe.mdx#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n  StripeConfig,\n  StripeWebhookHandler,\n  StripeProxy,\n  ...\n} from '@payloadcms/plugin-stripe/types';\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to Azure Emulator (Shell)\nDESCRIPTION: Navigates the command line interface into the directory containing the Docker configuration for the Azure Blob Storage emulator (`./src/adapters/azure/emulator`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncd ./src/adapters/azure/emulator\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with pnpm (Shell)\nDESCRIPTION: This shell command uses the `pnpm` package manager to install all the necessary dependencies defined in the `package.json` files for both the Payload and Remix applications within the monorepo. This command must be run after cloning the project and copying the environment files, and before starting the development servers.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/remix/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Copying Environment Variable Example File - Bash\nDESCRIPTION: This bash command copies the template .env.example file to a new .env file, which is expected by the application for environment configuration. It is assumed to be run in the project root, and the user may need to edit PAYLOAD_PUBLIC_SITE_URL as required. The command helps set up project-level secrets and environment parameters.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/tailwind-shadcn-ui/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Checking Payload Migration Status (Shell)\nDESCRIPTION: Provides the command-line instruction to display the status of all migrations, indicating which have been run and which are pending. It outputs a table summarizing the migration history.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nnpm run payload migrate:status\n```\n\n----------------------------------------\n\nTITLE: Installing AWS CLI on macOS (Shell)\nDESCRIPTION: Installs the AWS Command Line Interface (CLI) using the Homebrew package manager on macOS. This is a prerequisite for interacting with the LocalStack S3 emulator via the command line.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nbrew install awscli\n```\n\n----------------------------------------\n\nTITLE: Rolling Back Last Payload Migration Batch (Shell)\nDESCRIPTION: Provides the command-line instruction to revert the most recently applied batch of migrations. This executes the `down` function for each migration in that batch.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nnpm run payload migrate:down\n```\n\n----------------------------------------\n\nTITLE: Copying Environment File for PayloadCMS Project - Shell\nDESCRIPTION: This shell command copies the .env.example template to .env, preparing the necessary environment configuration for the project. It assumes the shell (cp command) and both files are present in the working directory. This file contains environment variables that govern credentials, database configuration, and third-party integration keys. Failure to run this command or populate .env will result in misconfigured projects.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/localization/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Importing Plugin Types for TypeScript Type Safety\nDESCRIPTION: Demonstrates how to import TypeScript types from @payloadcms/plugin-search for use in type-safe configuration and hooks. Requires the @payloadcms/plugin-search package and TypeScript. There are no inputs or outputs—this line simply enables more reliable autocompletion and type checking in your configuration files.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/search.mdx#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { SearchConfig, BeforeSync } from '@payloadcms/plugin-search/types'\n```\n\n----------------------------------------\n\nTITLE: Installing the Core Payload Live Preview Package (Bash)\nDESCRIPTION: This command uses npm to install the core `@payloadcms/live-preview` package. This package provides the underlying functions (`subscribe`, `unsubscribe`) needed to build custom Live Preview integrations for non-React JavaScript frameworks (e.g., Vue, Svelte).\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/live-preview\n```\n\n----------------------------------------\n\nTITLE: Installing Payload CMS Translations Package using pnpm\nDESCRIPTION: Installs the `@payloadcms/translations` package using the `pnpm` package manager. This package is required to add internationalization support and language packs to a Payload CMS project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/i18n.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install @payloadcms/translations\n```\n\n----------------------------------------\n\nTITLE: Configuring AWS CLI Profile for LocalStack (Shell)\nDESCRIPTION: Configures a new AWS CLI profile named `localstack`. This profile uses dummy credentials (as LocalStack doesn't verify them) but requires the correct region (`us-east-1`) specified in the `.env.example` to interact with the S3 emulator.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\naws configure --profile localstack\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Containers in Detached Mode (Shell)\nDESCRIPTION: This shell command is an alternative way to start the Docker Compose services. The `-d` flag runs the containers in the background (detached mode), freeing up the terminal. This is useful for running background services like the database.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/blank/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ndocker-compose up -d\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Payload Config Path via Environment Variable in package.json (JSON)\nDESCRIPTION: Example of defining a script in `package.json` that runs the Payload CLI while specifying a custom configuration file path using the `PAYLOAD_CONFIG_PATH` environment variable. This bypasses automatic config detection.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/overview.mdx#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n```json\n{\n  \"scripts\": {\n    \"payload\": \"PAYLOAD_CONFIG_PATH=/path/to/custom-config.ts payload\"\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Running Pending Payload Migrations (Shell)\nDESCRIPTION: Provides the command-line instruction to execute any outstanding Payload CMS migrations that haven't been run yet. This command uses the `payload` npm script defined in `package.json`.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/database/migrations.mdx#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nnpm run payload migrate\n```\n\n----------------------------------------\n\nTITLE: Running Payload Database Seed Script (Shell)\nDESCRIPTION: This command executes the `seed` script defined in the project's `package.json` using the pnpm package manager. This script typically resets the database and populates it with initial sample data, such as a demo user and example pages, which is useful for development and testing. Be cautious as this is often a destructive operation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/draft-preview/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\npnpm seed\n```\n\n----------------------------------------\n\nTITLE: Generating Payload Test Types using PNPM\nDESCRIPTION: Command to generate TypeScript types (`payload-types.ts`) from a specific test configuration file (`config.ts`) located within a test directory. Replace `my-test-dir` with the actual name of the testing directory (e.g., `fields`). This uses the PNPM package manager.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npnpm dev:generate-types my-test-dir\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Production Server (Shell)\nDESCRIPTION: These are alternative commands to start the Node.js server in production mode after a successful build. Running `pnpm start` or `npm run start` executes the start script defined in `package.json`, which serves the pre-built Payload application and admin panel.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/whitelabel/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\npnpm start` or `npm run start\n```\n\n----------------------------------------\n\nTITLE: Installing Slate Rich Text Editor Module with npm (Bash)\nDESCRIPTION: This Bash command installs the '@payloadcms/richtext-slate' package from npm, which is required to use the Slate Rich Text Editor in Payload CMS projects. It must be executed in a Node.js project directory, and assumes the user has npm installed. No additional arguments are required; the command will update package.json and fetch all dependencies.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/richtext-slate/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/richtext-slate\n\n```\n\n----------------------------------------\n\nTITLE: Opening Payload Admin Panel in Browser (Shell)\nDESCRIPTION: This command utilizes the `open` utility (common on macOS, alternatives exist for other OS) to automatically launch the default web browser and navigate to the Payload CMS admin interface, typically running at `http://localhost:3000/admin` during local development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/draft-preview/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nopen http://localhost:3000/admin\n```\n\n----------------------------------------\n\nTITLE: Starting GCS Emulator with Docker Compose (Shell)\nDESCRIPTION: Starts the Google Cloud Storage emulator service defined in the `docker-compose.yml` file in the current directory. The `-d` flag runs the containers in detached mode.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\ndocker-compose up -d\n```\n\n----------------------------------------\n\nTITLE: Overriding Import Map File Location in Payload Config (TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to customize the location where Payload generates the Import Map file using the `admin.importMap.importMapFile` property within `buildConfig`. It sets a custom path for the import map file while also configuring the base directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/custom-components/overview.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { buildConfig } from 'payload'\nimport { fileURLToPath } from 'node:url'\nimport path from 'path'\nconst filename = fileURLToPath(import.meta.url)\nconst dirname = path.dirname(filename)\n\nconst config = buildConfig({\n  // ...\n  admin: {\n    importMap: {\n      baseDir: path.resolve(dirname, 'src'),\n      importMapFile: path.resolve(\n        dirname,\n        'app',\n        '(payload)',\n        'custom-import-map.js',\n      ), // highlight-line\n    },\n  },\n})\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Sentry for Next.js via Wizard\nDESCRIPTION: This command runs the Sentry wizard to automatically set up Sentry integration for a Next.js project. This is a prerequisite step before configuring the Payload Sentry plugin.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/sentry.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpx @sentry/wizard@latest -i nextjs\n```\n\n----------------------------------------\n\nTITLE: Installing Live Preview React Integration - Bash Script\nDESCRIPTION: This Bash command installs the @payloadcms/live-preview-react package, which enables easy integration of live preview features in React applications such as those built with Next.js. The package should be installed before you attempt to use the React-based RefreshRouteOnSave component for server-side preview updates.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/server.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @payloadcms/live-preview-react\n```\n\n----------------------------------------\n\nTITLE: Installing Redirects Plugin with npm (Bash)\nDESCRIPTION: Demonstrates how to install the @payloadcms/plugin-redirects package using pnpm, a JavaScript package manager. The command downloads and adds the plugin to the project's dependencies, making it available for import in the application code. No parameters are required and the plugin will be ready for use post installation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/redirects.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @payloadcms/plugin-redirects\n```\n\n----------------------------------------\n\nTITLE: Building Payload Application for Production (Shell)\nDESCRIPTION: These commands execute the `build` script specified in the `package.json` using either pnpm or npm. This script compiles and bundles the Payload application (including the admin panel, often built with Next.js) into an optimized format suitable for production deployment, typically outputting files to a `.next` or `.build` directory.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/draft-preview/README.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npnpm build\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Installing Postgres Database Adapter - Bash\nDESCRIPTION: Installs the Postgres database adapter for Payload CMS, facilitating PostgreSQL as the datastore. Run this in the root of your project. Prerequisites: Postgres connection string, Node.js environment. Output: adapter package added. Use for Postgres integration only.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/installation.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm i @payloadcms/db-postgres\n```\n\n----------------------------------------\n\nTITLE: Initializing Payload Project from Multi-Tenant Example using npx\nDESCRIPTION: This shell command uses `npx` to execute `create-payload-app`, scaffolding a new Payload CMS project based on the `multi-tenant` example repository. It requires Node.js and npm/pnpm/yarn to be installed.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/multi-tenant/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpx create-payload-app --example multi-tenant\n```\n\n----------------------------------------\n\nTITLE: Installing Uploadthing Storage Dependency with pnpm (Shell)\nDESCRIPTION: This shell snippet demonstrates installing the @payloadcms/storage-uploadthing package using the pnpm package manager. It is required as a dependency before configuring Uploadthing as a storage provider in your Payload CMS project. The command should be run in the root directory of your project. No input is required, and success results in the package being added to node_modules.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/storage-uploadthing/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @payloadcms/storage-uploadthing\n```\n\n----------------------------------------\n\nTITLE: Installing the SEO Plugin via pnpm - Bash\nDESCRIPTION: This Bash snippet shows the command needed to install the @payloadcms/plugin-seo package using pnpm. It is required before you can import or configure the SEO plugin in your Payload project. Make sure pnpm is already installed in your development environment.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/seo.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @payloadcms/plugin-seo\n```\n\n----------------------------------------\n\nTITLE: Opening Project Home Page in Browser (Shell)\nDESCRIPTION: Opens the default web browser to the application's home page, typically served at `http://localhost:3000` during development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/form-builder/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nopen http://localhost:3000\n```\n\n----------------------------------------\n\nTITLE: Organizing Next.js Application Files and Folders - Plaintext\nDESCRIPTION: Illustrates the recommended folder structure for integrating Payload files into an existing Next.js app. The '(payload)' directory contains all Payload-related code and is distinct from other app files. No dependencies; just a documentation diagram. Input: filesystem layout. Output: directory organization guidance.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/getting-started/installation.mdx#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\napp/\n├─ (payload)/\n├── // Payload files\n├─ (my-app)/\n├── // Your app files\n```\n\n----------------------------------------\n\nTITLE: Opening Payload Admin Panel in Browser (Shell)\nDESCRIPTION: This command uses the `open` utility (common on macOS; similar commands exist for other operating systems) to automatically launch the default web browser and navigate to the Payload admin panel, typically hosted at `http://localhost:3000/admin` during development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/whitelabel/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nopen http://localhost:3000/admin\n```\n\n----------------------------------------\n\nTITLE: Displaying Informational Banner in Documentation (MDX/JSX)\nDESCRIPTION: This snippet utilizes a custom 'Banner' component within a likely MDX or similar documentation framework to render an informational message. It uses a 'type' prop set to 'info' to control the banner's appearance and conveys a suggestion about using server-side Live Preview.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/live-preview/frontend.mdx#_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<Banner type=\"info\">\n  We suggest using server-side Live Preview if your framework supports Server\n  Components, it is both simpler to setup and more performant to run than the\n  client-side alternative.\n</Banner>\n```\n\n----------------------------------------\n\nTITLE: Using the Payload App Creation CLI - Shell/Text\nDESCRIPTION: This snippet demonstrates usage patterns for the `create-payload-app` CLI tool to scaffold new Payload projects. Dependencies include npm (or yarn, pnpm) along with Node.js installed on the user's machine. Key parameters are the project name (`-n`), template (`-t`), and package manager options like `--use-npm`, `--use-yarn`, and `--use-pnpm`. Inputs are command-line arguments, outputs are initialized project directories with dependencies installed as specified. The tool supports both interactive and non-interactive execution, with various template choices and options for skipping dependency installation.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/create-payload-app/README.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n  USAGE\n\n      $ npx create-payload-app\n      $ npx create-payload-app my-project\n      $ npx create-payload-app -n my-project -t website\n\n  OPTIONS\n\n      -n     my-payload-app         Set project name\n      -t     template_name          Choose specific template\n\n        Available templates:\n\n        blank                       Blank Template\n        website                     Website Template\n        ecommerce                   E-commerce Template\n        plugin                      Template for creating a Payload plugin\n        payload-demo                Payload demo site at https://demo.payloadcms.com\n        payload-website             Payload website CMS at https://payloadcms.com\n\n      --use-npm                     Use npm to install dependencies\n      --use-yarn                    Use yarn to install dependencies\n      --use-pnpm                    Use pnpm to install dependencies\n      --no-deps                     Do not install any dependencies\n      -h                            Show help\n```\n\n----------------------------------------\n\nTITLE: Running the Development Server - npm - Shell Script\nDESCRIPTION: This snippet provides the command to start the Remix development server using npm. It assumes that npm dependencies are already installed and the 'dev' script is defined in package.json. Running this command will launch the app in development mode, enabling features like hot reloading and detailed error reporting. Output is shown in the terminal.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/remix/website/README.md#_snippet_0\n\nLANGUAGE: shellscript\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing @payloadcms/storage-s3 via pnpm - Shell\nDESCRIPTION: Installs the @payloadcms/storage-s3 package using pnpm, making the AWS S3 adapter available for configuration in your Payload CMS project. This step is a prerequisite before importing and configuring the storage plugin. Requires pnpm to be installed in your development environment.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/storage-s3/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm add @payloadcms/storage-s3\n```\n\n----------------------------------------\n\nTITLE: Blocking Admin Panel Crawling with robots.txt (Text)\nDESCRIPTION: Provides a robots.txt configuration to disallow all search engine user agents from crawling the /admin/ route. Placing this file in the server root directory enforces crawling prevention as browsers and search engines process robots.txt directives before accessing those paths.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/metadata.mdx#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nUser-agent: *\nDisallow: /admin/\n```\n\n----------------------------------------\n\nTITLE: Installing Multi Tenant Plugin via PNPM (Bash)\nDESCRIPTION: Installs the Payload CMS Multi Tenant Plugin package using the pnpm package manager. This command adds the plugin as a dependency to your project.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-multi-tenant/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @payloadcms/plugin-multi-tenant\n```\n\n----------------------------------------\n\nTITLE: Importing Form Builder Plugin Types in TypeScript\nDESCRIPTION: Shows how to import various TypeScript types directly from the '@payloadcms/plugin-form-builder/types' module. This allows developers to leverage type safety and autocompletion when working with the plugin's configurations, forms, submissions, and callbacks.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/plugins/form-builder.mdx#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {\n  PluginConfig,\n  Form,\n  FormSubmission,\n  FieldsConfig,\n  BeforeEmail,\n  HandlePayment,\n  ...\n} from \"@payloadcms/plugin-form-builder/types\";\n```\n\n----------------------------------------\n\nTITLE: Copying Payload Environment Configuration (Shell)\nDESCRIPTION: This shell command copies the example environment file (`.env.example`) to a new file (`.env`) within the `./payload` directory. This `.env` file will hold the specific environment variables required for the Payload CMS application. It's a prerequisite step before running the Payload app.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/remix/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncp ./payload/.env.example ./payload./.env\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Development Server with Test Config using PNPM\nDESCRIPTION: Command to start the Payload development server using the configuration defined in a specific test directory. Replace `my-test-dir` with the target test directory name (e.g., `fields`). This command utilizes PNPM and refreshes a test database on each restart.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm dev my-test-dir\n```\n\n----------------------------------------\n\nTITLE: Running Payload Integration Tests (MongoDB) using PNPM\nDESCRIPTION: Command to execute only the integration (int) tests for Payload CMS, run by Jest. By default, these tests run against a MongoDB database. This command should be run from the root of the monorepo using PNPM.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\npnpm test:int\n```\n\n----------------------------------------\n\nTITLE: Starting Payload Dev Server with Custom Config - PayloadCMS - Bash\nDESCRIPTION: This bash code snippet demonstrates how to launch the Payload development server, pointing at a custom test configuration directory (`_community`). This command wipes the test database on each restart and is essential for manually reproducing issues in the admin panel. Prerequisites include an installed PayloadCMS environment and the pnpm package manager.\nSOURCE: https://github.com/payloadcms/payload/blob/main/ISSUE_GUIDE.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# This command will start up Payload using your config\\n# NOTE: it will wipe the test database on restart\\npnpm dev _community\n```\n\n----------------------------------------\n\nTITLE: Project Structure for .env File Placement\nDESCRIPTION: Illustrates the recommended location of the `.env` file at the root level of a Payload project directory, alongside `package.json` and `payload.config.ts`. This placement allows Next.js and potentially `dotenv` to find it automatically.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/configuration/environment-vars.mdx#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nproject-name/\n├─ .env\n├─ package.json\n├─ payload.config.ts\n```\n\n----------------------------------------\n\nTITLE: Cloning Payload Website Template via Git Sparse Checkout - Bash\nDESCRIPTION: This snippet demonstrates how to directly clone the website template using advanced git operations. It initializes a shallow clone of the main repository, isolates the 'templates/website' directory, resets git metadata for a fresh start, and sets all template files to the project root. Requires the Git CLI and Unix shell utilities. This command sequence is intended for users needing more granular control or not using the default template bootstrapper.\nSOURCE: https://github.com/payloadcms/payload/blob/main/templates/website/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -n --depth=1 --filter=tree:0 https://github.com/payloadcms/payload my-project && cd my-project && git sparse-checkout set --no-cone templates/website && git checkout && rm -rf .git && git init && git add . && git mv -f templates/website/{.,}* . && git add . && git commit -m \"Initial commit\"\n```\n\n----------------------------------------\n\nTITLE: Generated GraphQL Type and Schema Reference Example - TypeScript\nDESCRIPTION: This is the expected GraphQL type output generated by providing a 'group' config with an interface name. The 'SharedMeta' type is used within a collection type (e.g., Collection1) to represent nested fields. Assumes the generator tool in '@payloadcms/graphql' processes the config correctly. Intended for illustration and documentation; not standalone code. No parameters. Output is a custom GraphQL type definition in the resulting schema file.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/graphql/graphql-schema.mdx#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// A top level reusable type will be generated\ntype SharedMeta {\n  title: String\n  description: String\n}\n\n// And will be referenced inside the generated schema\ntype Collection1 {\n  // ...other fields\n  meta: SharedMeta\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing the Payload Admin Panel (Bash)\nDESCRIPTION: This command uses the `open` utility (common on macOS) to launch the default web browser and navigate to the Payload CMS admin panel, typically accessible at `http://localhost:3000/admin` during development.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/live-preview/README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nopen http://localhost:3000/admin\n```\n\n----------------------------------------\n\nTITLE: Importing Field Type from Payload (TypeScript)\nDESCRIPTION: Basic TypeScript import statement for the `Field` type from the 'payload' package. This type is fundamental when defining field configurations in Payload CMS.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/fields/overview.mdx#_snippet_33\n\nLANGUAGE: ts\nCODE:\n```\nimport type { Field } from 'payload'\n```\n\n----------------------------------------\n\nTITLE: Illustrating Payload Project Structure in Next.js (Plaintext)\nDESCRIPTION: Displays the directory layout generated by Payload within a Next.js application's `app` directory. It shows the `(payload)` route group containing subdirectories for the admin UI (`admin`), REST API (`api`), GraphQL API (`graphql`), GraphQL Playground (`graphql-playground`), custom styles (`custom.scss`), and the group's layout file (`layout.tsx`). This structure isolates Payload functionality using Next.js conventions.\nSOURCE: https://github.com/payloadcms/payload/blob/main/docs/admin/overview.mdx#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\napp/\n├─ (payload)/\n├── admin/\n├─── [[...segments]]/\n├──── page.tsx\n├──── not-found.tsx\n├── api/\n├─── [...slug]/\n├──── route.ts\n├── graphql/\n├──── route.ts\n├── graphql-playground/\n├──── route.ts\n├── custom.scss\n├── layout.tsx\n```\n\n----------------------------------------\n\nTITLE: Copying Environment Variables for Payload Project (Shell)\nDESCRIPTION: This shell command copies the provided example environment variable file (`.env.example`) to a new file named `.env`. The `.env` file is used by Payload to load project-specific configuration and secrets during runtime.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/whitelabel/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncp .env.example .env\n```\n\n----------------------------------------\n\nTITLE: Building Payload Translations with Yarn, NPM, or PNPM (Shell)\nDESCRIPTION: These shell commands rebuild the Payload translation assets after modifications. Choose the command corresponding to your preferred package manager (yarn, npm, or pnpm). This step is required after updating a translation value, adding a new key/value pair to all languages, or creating and configuring a new language file.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/translations/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n   yarn build\n   // or\n   npm build\n   // or\n   pnpm build\n```\n\n----------------------------------------\n\nTITLE: Defining Constants in TypeScript Example\nDESCRIPTION: This TypeScript code snippet, embedded within the markdown content of a REST API example's drawer, demonstrates the declaration of four constant variables (`a`, `b`, `c`, `d`) using the `const` keyword and assigning them simple integer values.\nSOURCE: https://github.com/payloadcms/payload/blob/main/test/lexical-mdx/tests/restExamples2.input.mdx#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst a = 1\nconst b = 2\nconst c = 3\nconst d = 4\n```\n\n----------------------------------------\n\nTITLE: Installing Root Dependencies (Shell)\nDESCRIPTION: Installs the necessary Node.js package dependencies listed in the `package.json` file located in the root directory of the repository. This command should be run after cloning the repository.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Illustrative Test Directory Structure in Payload\nDESCRIPTION: Shows the typical file structure within a specific test category directory (e.g., `test/fields/`) in the Payload CMS project. It includes the granular Payload configuration (`config.ts`), integration tests (`int.spec.ts`), end-to-end tests (`e2e.spec.ts`), and generated TypeScript types (`payload-types.ts`).\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n.\n├── config.ts\n├── int.spec.ts\n├── e2e.spec.ts\n└── payload-types.ts\n```\n\n----------------------------------------\n\nTITLE: Example Conventional Commit Messages with Scope for Payload\nDESCRIPTION: Shows how to use scopes within Conventional Commits, specifically for changes related to `templates` or `examples` directories. These commits use the `chore` type and specify the relevant scope in parentheses.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n- chore(templates): adds feature to template\n- chore(examples): fixes bug in example\n```\n\n----------------------------------------\n\nTITLE: Setting DOCS_DIR Environment Variable for Local Docs Preview\nDESCRIPTION: Example of how to define the `DOCS_DIR` environment variable in the `.env` file of the Payload website repository. This variable must point to the absolute path of the local `docs` folder within your cloned Payload core repository.\nSOURCE: https://github.com/payloadcms/payload/blob/main/CONTRIBUTING.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nDOCS_DIR=/Users/yourname/Documents/GitHub/payload/docs\n```\n\n----------------------------------------\n\nTITLE: Opening Home and Admin Panel URLs - Bash\nDESCRIPTION: These commands are used to open the application's home page and admin interface in the default browser. The URLs assume the server is running locally on port 3000. While effectively documentation instructions, they can be executed on UNIX-like systems with GUI browsers. No dependencies besides an active local server and a default browser.\nSOURCE: https://github.com/payloadcms/payload/blob/main/examples/tailwind-shadcn-ui/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nopen http://localhost:3000\n```\n\nLANGUAGE: bash\nCODE:\n```\nopen http://localhost:3000/admin\n```\n\n----------------------------------------\n\nTITLE: Displaying Test Directory Structure - Markdown (text) - English\nDESCRIPTION: This snippet visually represents the structure of the test directory using a file tree. It specifies the default files expected in the `_community` test directory, such as the configuration, payload types, and optional test specifications. The structure facilitates an easy overview of where to place or locate specific config and test scripts within PayloadCMS tests.\nSOURCE: https://github.com/payloadcms/payload/blob/main/ISSUE_GUIDE.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n.\\n├── config.ts\\n├── int.spec.ts\\n├── e2e.spec.ts\\n└── payload-types.ts\n```\n\n----------------------------------------\n\nTITLE: Changing Directory to Development Sandbox (Shell)\nDESCRIPTION: Navigates the command line interface into the `./dev` directory, which contains the local development sandbox environment.\nSOURCE: https://github.com/payloadcms/payload/blob/main/packages/plugin-cloud-storage/docs/local-dev.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd ./dev\n```"
  }
]